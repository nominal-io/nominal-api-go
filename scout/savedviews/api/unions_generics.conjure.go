// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/scout/api"
)

type DisplayStateWithT[T any] DisplayState

func (u *DisplayStateWithT[T]) Accept(ctx context.Context, v DisplayStateVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "displayStateV1":
		if u.displayStateV1 == nil {
			return result, fmt.Errorf("field \"displayStateV1\" is required")
		}
		return v.VisitDisplayStateV1(ctx, *u.displayStateV1)
	}
}

func (u *DisplayStateWithT[T]) AcceptFuncs(displayStateV1Func func(TableState) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "displayStateV1":
		if u.displayStateV1 == nil {
			return result, fmt.Errorf("field \"displayStateV1\" is required")
		}
		return displayStateV1Func(*u.displayStateV1)
	}
}

func (u *DisplayStateWithT[T]) DisplayStateV1NoopSuccess(TableState) (T, error) {
	var result T
	return result, nil
}

func (u *DisplayStateWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DisplayStateVisitorWithT[T any] interface {
	VisitDisplayStateV1(ctx context.Context, v TableState) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SearchSavedViewsQueryWithT[T any] SearchSavedViewsQuery

func (u *SearchSavedViewsQueryWithT[T]) Accept(ctx context.Context, v SearchSavedViewsQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(ctx, *u.not)
	case "titleExactSubstringSearch":
		if u.titleExactSubstringSearch == nil {
			return result, fmt.Errorf("field \"titleExactSubstringSearch\" is required")
		}
		return v.VisitTitleExactSubstringSearch(ctx, *u.titleExactSubstringSearch)
	case "resourceType":
		if u.resourceType == nil {
			return result, fmt.Errorf("field \"resourceType\" is required")
		}
		return v.VisitResourceType(ctx, *u.resourceType)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	}
}

func (u *SearchSavedViewsQueryWithT[T]) AcceptFuncs(andFunc func(SearchSavedViewsQueryList) (T, error), orFunc func(SearchSavedViewsQueryList) (T, error), notFunc func(SearchSavedViewsQuery) (T, error), titleExactSubstringSearchFunc func(string) (T, error), resourceTypeFunc func(ResourceType) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "titleExactSubstringSearch":
		if u.titleExactSubstringSearch == nil {
			return result, fmt.Errorf("field \"titleExactSubstringSearch\" is required")
		}
		return titleExactSubstringSearchFunc(*u.titleExactSubstringSearch)
	case "resourceType":
		if u.resourceType == nil {
			return result, fmt.Errorf("field \"resourceType\" is required")
		}
		return resourceTypeFunc(*u.resourceType)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchSavedViewsQueryWithT[T]) AndNoopSuccess(SearchSavedViewsQueryList) (T, error) {
	var result T
	return result, nil
}

func (u *SearchSavedViewsQueryWithT[T]) OrNoopSuccess(SearchSavedViewsQueryList) (T, error) {
	var result T
	return result, nil
}

func (u *SearchSavedViewsQueryWithT[T]) NotNoopSuccess(SearchSavedViewsQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchSavedViewsQueryWithT[T]) TitleExactSubstringSearchNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchSavedViewsQueryWithT[T]) ResourceTypeNoopSuccess(ResourceType) (T, error) {
	var result T
	return result, nil
}

func (u *SearchSavedViewsQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchSavedViewsQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchSavedViewsQueryVisitorWithT[T any] interface {
	VisitAnd(ctx context.Context, v SearchSavedViewsQueryList) (T, error)
	VisitOr(ctx context.Context, v SearchSavedViewsQueryList) (T, error)
	VisitNot(ctx context.Context, v SearchSavedViewsQuery) (T, error)
	VisitTitleExactSubstringSearch(ctx context.Context, v string) (T, error)
	VisitResourceType(ctx context.Context, v ResourceType) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SearchStateWithT[T any] SearchState

func (u *SearchStateWithT[T]) Accept(ctx context.Context, v SearchStateVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "asset":
		if u.asset == nil {
			return result, fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAsset(ctx, *u.asset)
	case "run":
		if u.run == nil {
			return result, fmt.Errorf("field \"run\" is required")
		}
		return v.VisitRun(ctx, *u.run)
	case "checklist":
		if u.checklist == nil {
			return result, fmt.Errorf("field \"checklist\" is required")
		}
		return v.VisitChecklist(ctx, *u.checklist)
	case "workbook":
		if u.workbook == nil {
			return result, fmt.Errorf("field \"workbook\" is required")
		}
		return v.VisitWorkbook(ctx, *u.workbook)
	case "template":
		if u.template == nil {
			return result, fmt.Errorf("field \"template\" is required")
		}
		return v.VisitTemplate(ctx, *u.template)
	}
}

func (u *SearchStateWithT[T]) AcceptFuncs(assetFunc func(AssetSearchState) (T, error), runFunc func(RunSearchState) (T, error), checklistFunc func(ChecklistSearchState) (T, error), workbookFunc func(WorkbookSearchState) (T, error), templateFunc func(TemplateSearchState) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "asset":
		if u.asset == nil {
			return result, fmt.Errorf("field \"asset\" is required")
		}
		return assetFunc(*u.asset)
	case "run":
		if u.run == nil {
			return result, fmt.Errorf("field \"run\" is required")
		}
		return runFunc(*u.run)
	case "checklist":
		if u.checklist == nil {
			return result, fmt.Errorf("field \"checklist\" is required")
		}
		return checklistFunc(*u.checklist)
	case "workbook":
		if u.workbook == nil {
			return result, fmt.Errorf("field \"workbook\" is required")
		}
		return workbookFunc(*u.workbook)
	case "template":
		if u.template == nil {
			return result, fmt.Errorf("field \"template\" is required")
		}
		return templateFunc(*u.template)
	}
}

func (u *SearchStateWithT[T]) AssetNoopSuccess(AssetSearchState) (T, error) {
	var result T
	return result, nil
}

func (u *SearchStateWithT[T]) RunNoopSuccess(RunSearchState) (T, error) {
	var result T
	return result, nil
}

func (u *SearchStateWithT[T]) ChecklistNoopSuccess(ChecklistSearchState) (T, error) {
	var result T
	return result, nil
}

func (u *SearchStateWithT[T]) WorkbookNoopSuccess(WorkbookSearchState) (T, error) {
	var result T
	return result, nil
}

func (u *SearchStateWithT[T]) TemplateNoopSuccess(TemplateSearchState) (T, error) {
	var result T
	return result, nil
}

func (u *SearchStateWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchStateVisitorWithT[T any] interface {
	VisitAsset(ctx context.Context, v AssetSearchState) (T, error)
	VisitRun(ctx context.Context, v RunSearchState) (T, error)
	VisitChecklist(ctx context.Context, v ChecklistSearchState) (T, error)
	VisitWorkbook(ctx context.Context, v WorkbookSearchState) (T, error)
	VisitTemplate(ctx context.Context, v TemplateSearchState) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SortKeyWithT[T any] SortKey

func (u *SortKeyWithT[T]) Accept(ctx context.Context, v SortKeyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "field":
		if u.field == nil {
			return result, fmt.Errorf("field \"field\" is required")
		}
		return v.VisitField(ctx, *u.field)
	}
}

func (u *SortKeyWithT[T]) AcceptFuncs(fieldFunc func(SortField) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "field":
		if u.field == nil {
			return result, fmt.Errorf("field \"field\" is required")
		}
		return fieldFunc(*u.field)
	}
}

func (u *SortKeyWithT[T]) FieldNoopSuccess(SortField) (T, error) {
	var result T
	return result, nil
}

func (u *SortKeyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SortKeyVisitorWithT[T any] interface {
	VisitField(ctx context.Context, v SortField) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UpdateColorWithT[T any] UpdateColor

func (u *UpdateColorWithT[T]) Accept(ctx context.Context, v UpdateColorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "color":
		if u.color == nil {
			return result, fmt.Errorf("field \"color\" is required")
		}
		return v.VisitColor(ctx, *u.color)
	case "clearColor":
		if u.clearColor == nil {
			return result, fmt.Errorf("field \"clearColor\" is required")
		}
		return v.VisitClearColor(ctx, *u.clearColor)
	}
}

func (u *UpdateColorWithT[T]) AcceptFuncs(colorFunc func(api.Color) (T, error), clearColorFunc func(api1.Empty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "color":
		if u.color == nil {
			return result, fmt.Errorf("field \"color\" is required")
		}
		return colorFunc(*u.color)
	case "clearColor":
		if u.clearColor == nil {
			return result, fmt.Errorf("field \"clearColor\" is required")
		}
		return clearColorFunc(*u.clearColor)
	}
}

func (u *UpdateColorWithT[T]) ColorNoopSuccess(api.Color) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateColorWithT[T]) ClearColorNoopSuccess(api1.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateColorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UpdateColorVisitorWithT[T any] interface {
	VisitColor(ctx context.Context, v api.Color) (T, error)
	VisitClearColor(ctx context.Context, v api1.Empty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UpdateSymbolWithT[T any] UpdateSymbol

func (u *UpdateSymbolWithT[T]) Accept(ctx context.Context, v UpdateSymbolVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "symbol":
		if u.symbol == nil {
			return result, fmt.Errorf("field \"symbol\" is required")
		}
		return v.VisitSymbol(ctx, *u.symbol)
	case "clearSymbol":
		if u.clearSymbol == nil {
			return result, fmt.Errorf("field \"clearSymbol\" is required")
		}
		return v.VisitClearSymbol(ctx, *u.clearSymbol)
	}
}

func (u *UpdateSymbolWithT[T]) AcceptFuncs(symbolFunc func(api.Symbol) (T, error), clearSymbolFunc func(api1.Empty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "symbol":
		if u.symbol == nil {
			return result, fmt.Errorf("field \"symbol\" is required")
		}
		return symbolFunc(*u.symbol)
	case "clearSymbol":
		if u.clearSymbol == nil {
			return result, fmt.Errorf("field \"clearSymbol\" is required")
		}
		return clearSymbolFunc(*u.clearSymbol)
	}
}

func (u *UpdateSymbolWithT[T]) SymbolNoopSuccess(api.Symbol) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateSymbolWithT[T]) ClearSymbolNoopSuccess(api1.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateSymbolWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UpdateSymbolVisitorWithT[T any] interface {
	VisitSymbol(ctx context.Context, v api.Symbol) (T, error)
	VisitClearSymbol(ctx context.Context, v api1.Empty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
