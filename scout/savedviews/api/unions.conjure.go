// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	api2 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/io/nominal/event"
	api1 "github.com/nominal-io/nominal-api-go/scout/api"
	"github.com/nominal-io/nominal-api-go/scout/run/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type AssetMetricColumnTimeRange struct {
	typ           string
	mostRecentRun *MostRecentRun
	custom        *api.CustomTimeframeFilter
	preset        *api.PresetTimeframeFilter
}

type assetMetricColumnTimeRangeDeserializer struct {
	Type          string                     `json:"type"`
	MostRecentRun *MostRecentRun             `json:"mostRecentRun"`
	Custom        *api.CustomTimeframeFilter `json:"custom"`
	Preset        *api.PresetTimeframeFilter `json:"preset"`
}

func (u *assetMetricColumnTimeRangeDeserializer) toStruct() AssetMetricColumnTimeRange {
	return AssetMetricColumnTimeRange{typ: u.Type, mostRecentRun: u.MostRecentRun, custom: u.Custom, preset: u.Preset}
}

func (u *AssetMetricColumnTimeRange) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "mostRecentRun":
		if u.mostRecentRun == nil {
			return nil, fmt.Errorf("field \"mostRecentRun\" is required")
		}
		return struct {
			Type          string        `json:"type"`
			MostRecentRun MostRecentRun `json:"mostRecentRun"`
		}{Type: "mostRecentRun", MostRecentRun: *u.mostRecentRun}, nil
	case "custom":
		if u.custom == nil {
			return nil, fmt.Errorf("field \"custom\" is required")
		}
		return struct {
			Type   string                    `json:"type"`
			Custom api.CustomTimeframeFilter `json:"custom"`
		}{Type: "custom", Custom: *u.custom}, nil
	case "preset":
		if u.preset == nil {
			return nil, fmt.Errorf("field \"preset\" is required")
		}
		return struct {
			Type   string                    `json:"type"`
			Preset api.PresetTimeframeFilter `json:"preset"`
		}{Type: "preset", Preset: *u.preset}, nil
	}
}

func (u AssetMetricColumnTimeRange) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *AssetMetricColumnTimeRange) UnmarshalJSON(data []byte) error {
	var deser assetMetricColumnTimeRangeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "mostRecentRun":
		if u.mostRecentRun == nil {
			return fmt.Errorf("field \"mostRecentRun\" is required")
		}
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
	case "preset":
		if u.preset == nil {
			return fmt.Errorf("field \"preset\" is required")
		}
	}
	return nil
}

func (u AssetMetricColumnTimeRange) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *AssetMetricColumnTimeRange) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *AssetMetricColumnTimeRange) AcceptFuncs(mostRecentRunFunc func(MostRecentRun) error, customFunc func(api.CustomTimeframeFilter) error, presetFunc func(api.PresetTimeframeFilter) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "mostRecentRun":
		if u.mostRecentRun == nil {
			return fmt.Errorf("field \"mostRecentRun\" is required")
		}
		return mostRecentRunFunc(*u.mostRecentRun)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	case "preset":
		if u.preset == nil {
			return fmt.Errorf("field \"preset\" is required")
		}
		return presetFunc(*u.preset)
	}
}

func (u *AssetMetricColumnTimeRange) MostRecentRunNoopSuccess(MostRecentRun) error {
	return nil
}

func (u *AssetMetricColumnTimeRange) CustomNoopSuccess(api.CustomTimeframeFilter) error {
	return nil
}

func (u *AssetMetricColumnTimeRange) PresetNoopSuccess(api.PresetTimeframeFilter) error {
	return nil
}

func (u *AssetMetricColumnTimeRange) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *AssetMetricColumnTimeRange) Accept(v AssetMetricColumnTimeRangeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "mostRecentRun":
		if u.mostRecentRun == nil {
			return fmt.Errorf("field \"mostRecentRun\" is required")
		}
		return v.VisitMostRecentRun(*u.mostRecentRun)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(*u.custom)
	case "preset":
		if u.preset == nil {
			return fmt.Errorf("field \"preset\" is required")
		}
		return v.VisitPreset(*u.preset)
	}
}

type AssetMetricColumnTimeRangeVisitor interface {
	VisitMostRecentRun(v MostRecentRun) error
	VisitCustom(v api.CustomTimeframeFilter) error
	VisitPreset(v api.PresetTimeframeFilter) error
	VisitUnknown(typeName string) error
}

func (u *AssetMetricColumnTimeRange) AcceptWithContext(ctx context.Context, v AssetMetricColumnTimeRangeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "mostRecentRun":
		if u.mostRecentRun == nil {
			return fmt.Errorf("field \"mostRecentRun\" is required")
		}
		return v.VisitMostRecentRunWithContext(ctx, *u.mostRecentRun)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustomWithContext(ctx, *u.custom)
	case "preset":
		if u.preset == nil {
			return fmt.Errorf("field \"preset\" is required")
		}
		return v.VisitPresetWithContext(ctx, *u.preset)
	}
}

type AssetMetricColumnTimeRangeVisitorWithContext interface {
	VisitMostRecentRunWithContext(ctx context.Context, v MostRecentRun) error
	VisitCustomWithContext(ctx context.Context, v api.CustomTimeframeFilter) error
	VisitPresetWithContext(ctx context.Context, v api.PresetTimeframeFilter) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAssetMetricColumnTimeRangeFromMostRecentRun(v MostRecentRun) AssetMetricColumnTimeRange {
	return AssetMetricColumnTimeRange{typ: "mostRecentRun", mostRecentRun: &v}
}

func NewAssetMetricColumnTimeRangeFromCustom(v api.CustomTimeframeFilter) AssetMetricColumnTimeRange {
	return AssetMetricColumnTimeRange{typ: "custom", custom: &v}
}

func NewAssetMetricColumnTimeRangeFromPreset(v api.PresetTimeframeFilter) AssetMetricColumnTimeRange {
	return AssetMetricColumnTimeRange{typ: "preset", preset: &v}
}

type DisplayState struct {
	typ            string
	displayStateV1 *TableState
}

type displayStateDeserializer struct {
	Type           string      `json:"type"`
	DisplayStateV1 *TableState `json:"displayStateV1"`
}

func (u *displayStateDeserializer) toStruct() DisplayState {
	return DisplayState{typ: u.Type, displayStateV1: u.DisplayStateV1}
}

func (u *DisplayState) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "displayStateV1":
		if u.displayStateV1 == nil {
			return nil, fmt.Errorf("field \"displayStateV1\" is required")
		}
		return struct {
			Type           string     `json:"type"`
			DisplayStateV1 TableState `json:"displayStateV1"`
		}{Type: "displayStateV1", DisplayStateV1: *u.displayStateV1}, nil
	}
}

func (u DisplayState) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DisplayState) UnmarshalJSON(data []byte) error {
	var deser displayStateDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "displayStateV1":
		if u.displayStateV1 == nil {
			return fmt.Errorf("field \"displayStateV1\" is required")
		}
	}
	return nil
}

func (u DisplayState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DisplayState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DisplayState) AcceptFuncs(displayStateV1Func func(TableState) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "displayStateV1":
		if u.displayStateV1 == nil {
			return fmt.Errorf("field \"displayStateV1\" is required")
		}
		return displayStateV1Func(*u.displayStateV1)
	}
}

func (u *DisplayState) DisplayStateV1NoopSuccess(TableState) error {
	return nil
}

func (u *DisplayState) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DisplayState) Accept(v DisplayStateVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "displayStateV1":
		if u.displayStateV1 == nil {
			return fmt.Errorf("field \"displayStateV1\" is required")
		}
		return v.VisitDisplayStateV1(*u.displayStateV1)
	}
}

type DisplayStateVisitor interface {
	VisitDisplayStateV1(v TableState) error
	VisitUnknown(typeName string) error
}

func (u *DisplayState) AcceptWithContext(ctx context.Context, v DisplayStateVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "displayStateV1":
		if u.displayStateV1 == nil {
			return fmt.Errorf("field \"displayStateV1\" is required")
		}
		return v.VisitDisplayStateV1WithContext(ctx, *u.displayStateV1)
	}
}

type DisplayStateVisitorWithContext interface {
	VisitDisplayStateV1WithContext(ctx context.Context, v TableState) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDisplayStateFromDisplayStateV1(v TableState) DisplayState {
	return DisplayState{typ: "displayStateV1", displayStateV1: &v}
}

type MetricColumnData struct {
	typ   string
	event *event.SearchQuery
}

type metricColumnDataDeserializer struct {
	Type  string             `json:"type"`
	Event *event.SearchQuery `json:"event"`
}

func (u *metricColumnDataDeserializer) toStruct() MetricColumnData {
	return MetricColumnData{typ: u.Type, event: u.Event}
}

func (u *MetricColumnData) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "event":
		if u.event == nil {
			return nil, fmt.Errorf("field \"event\" is required")
		}
		return struct {
			Type  string            `json:"type"`
			Event event.SearchQuery `json:"event"`
		}{Type: "event", Event: *u.event}, nil
	}
}

func (u MetricColumnData) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *MetricColumnData) UnmarshalJSON(data []byte) error {
	var deser metricColumnDataDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "event":
		if u.event == nil {
			return fmt.Errorf("field \"event\" is required")
		}
	}
	return nil
}

func (u MetricColumnData) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *MetricColumnData) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *MetricColumnData) AcceptFuncs(eventFunc func(event.SearchQuery) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "event":
		if u.event == nil {
			return fmt.Errorf("field \"event\" is required")
		}
		return eventFunc(*u.event)
	}
}

func (u *MetricColumnData) EventNoopSuccess(event.SearchQuery) error {
	return nil
}

func (u *MetricColumnData) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *MetricColumnData) Accept(v MetricColumnDataVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "event":
		if u.event == nil {
			return fmt.Errorf("field \"event\" is required")
		}
		return v.VisitEvent(*u.event)
	}
}

type MetricColumnDataVisitor interface {
	VisitEvent(v event.SearchQuery) error
	VisitUnknown(typeName string) error
}

func (u *MetricColumnData) AcceptWithContext(ctx context.Context, v MetricColumnDataVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "event":
		if u.event == nil {
			return fmt.Errorf("field \"event\" is required")
		}
		return v.VisitEventWithContext(ctx, *u.event)
	}
}

type MetricColumnDataVisitorWithContext interface {
	VisitEventWithContext(ctx context.Context, v event.SearchQuery) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewMetricColumnDataFromEvent(v event.SearchQuery) MetricColumnData {
	return MetricColumnData{typ: "event", event: &v}
}

type MetricColumns struct {
	typ   string
	asset *AssetMetricColumns
}

type metricColumnsDeserializer struct {
	Type  string              `json:"type"`
	Asset *AssetMetricColumns `json:"asset"`
}

func (u *metricColumnsDeserializer) toStruct() MetricColumns {
	return MetricColumns{typ: u.Type, asset: u.Asset}
}

func (u *MetricColumns) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "asset":
		if u.asset == nil {
			return nil, fmt.Errorf("field \"asset\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Asset AssetMetricColumns `json:"asset"`
		}{Type: "asset", Asset: *u.asset}, nil
	}
}

func (u MetricColumns) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *MetricColumns) UnmarshalJSON(data []byte) error {
	var deser metricColumnsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
	}
	return nil
}

func (u MetricColumns) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *MetricColumns) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *MetricColumns) AcceptFuncs(assetFunc func(AssetMetricColumns) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return assetFunc(*u.asset)
	}
}

func (u *MetricColumns) AssetNoopSuccess(AssetMetricColumns) error {
	return nil
}

func (u *MetricColumns) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *MetricColumns) Accept(v MetricColumnsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAsset(*u.asset)
	}
}

type MetricColumnsVisitor interface {
	VisitAsset(v AssetMetricColumns) error
	VisitUnknown(typeName string) error
}

func (u *MetricColumns) AcceptWithContext(ctx context.Context, v MetricColumnsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAssetWithContext(ctx, *u.asset)
	}
}

type MetricColumnsVisitorWithContext interface {
	VisitAssetWithContext(ctx context.Context, v AssetMetricColumns) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewMetricColumnsFromAsset(v AssetMetricColumns) MetricColumns {
	return MetricColumns{typ: "asset", asset: &v}
}

type SearchSavedViewsQuery struct {
	typ                       string
	and                       *SearchSavedViewsQueryList
	or                        *SearchSavedViewsQueryList
	not                       *SearchSavedViewsQuery
	titleExactSubstringSearch *string
	resourceType              *ResourceType
	workspace                 *rids.WorkspaceRid
}

type searchSavedViewsQueryDeserializer struct {
	Type                      string                     `json:"type"`
	And                       *SearchSavedViewsQueryList `json:"and"`
	Or                        *SearchSavedViewsQueryList `json:"or"`
	Not                       *SearchSavedViewsQuery     `json:"not"`
	TitleExactSubstringSearch *string                    `json:"titleExactSubstringSearch"`
	ResourceType              *ResourceType              `json:"resourceType"`
	Workspace                 *rids.WorkspaceRid         `json:"workspace"`
}

func (u *searchSavedViewsQueryDeserializer) toStruct() SearchSavedViewsQuery {
	return SearchSavedViewsQuery{typ: u.Type, and: u.And, or: u.Or, not: u.Not, titleExactSubstringSearch: u.TitleExactSubstringSearch, resourceType: u.ResourceType, workspace: u.Workspace}
}

func (u *SearchSavedViewsQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			And  SearchSavedViewsQueryList `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			Or   SearchSavedViewsQueryList `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string                `json:"type"`
			Not  SearchSavedViewsQuery `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	case "titleExactSubstringSearch":
		if u.titleExactSubstringSearch == nil {
			return nil, fmt.Errorf("field \"titleExactSubstringSearch\" is required")
		}
		return struct {
			Type                      string `json:"type"`
			TitleExactSubstringSearch string `json:"titleExactSubstringSearch"`
		}{Type: "titleExactSubstringSearch", TitleExactSubstringSearch: *u.titleExactSubstringSearch}, nil
	case "resourceType":
		if u.resourceType == nil {
			return nil, fmt.Errorf("field \"resourceType\" is required")
		}
		return struct {
			Type         string       `json:"type"`
			ResourceType ResourceType `json:"resourceType"`
		}{Type: "resourceType", ResourceType: *u.resourceType}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	}
}

func (u SearchSavedViewsQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchSavedViewsQuery) UnmarshalJSON(data []byte) error {
	var deser searchSavedViewsQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	case "titleExactSubstringSearch":
		if u.titleExactSubstringSearch == nil {
			return fmt.Errorf("field \"titleExactSubstringSearch\" is required")
		}
	case "resourceType":
		if u.resourceType == nil {
			return fmt.Errorf("field \"resourceType\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	}
	return nil
}

func (u SearchSavedViewsQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchSavedViewsQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchSavedViewsQuery) AcceptFuncs(andFunc func(SearchSavedViewsQueryList) error, orFunc func(SearchSavedViewsQueryList) error, notFunc func(SearchSavedViewsQuery) error, titleExactSubstringSearchFunc func(string) error, resourceTypeFunc func(ResourceType) error, workspaceFunc func(rids.WorkspaceRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "titleExactSubstringSearch":
		if u.titleExactSubstringSearch == nil {
			return fmt.Errorf("field \"titleExactSubstringSearch\" is required")
		}
		return titleExactSubstringSearchFunc(*u.titleExactSubstringSearch)
	case "resourceType":
		if u.resourceType == nil {
			return fmt.Errorf("field \"resourceType\" is required")
		}
		return resourceTypeFunc(*u.resourceType)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchSavedViewsQuery) AndNoopSuccess(SearchSavedViewsQueryList) error {
	return nil
}

func (u *SearchSavedViewsQuery) OrNoopSuccess(SearchSavedViewsQueryList) error {
	return nil
}

func (u *SearchSavedViewsQuery) NotNoopSuccess(SearchSavedViewsQuery) error {
	return nil
}

func (u *SearchSavedViewsQuery) TitleExactSubstringSearchNoopSuccess(string) error {
	return nil
}

func (u *SearchSavedViewsQuery) ResourceTypeNoopSuccess(ResourceType) error {
	return nil
}

func (u *SearchSavedViewsQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *SearchSavedViewsQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchSavedViewsQuery) Accept(v SearchSavedViewsQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	case "titleExactSubstringSearch":
		if u.titleExactSubstringSearch == nil {
			return fmt.Errorf("field \"titleExactSubstringSearch\" is required")
		}
		return v.VisitTitleExactSubstringSearch(*u.titleExactSubstringSearch)
	case "resourceType":
		if u.resourceType == nil {
			return fmt.Errorf("field \"resourceType\" is required")
		}
		return v.VisitResourceType(*u.resourceType)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	}
}

type SearchSavedViewsQueryVisitor interface {
	VisitAnd(v SearchSavedViewsQueryList) error
	VisitOr(v SearchSavedViewsQueryList) error
	VisitNot(v SearchSavedViewsQuery) error
	VisitTitleExactSubstringSearch(v string) error
	VisitResourceType(v ResourceType) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitUnknown(typeName string) error
}

func (u *SearchSavedViewsQuery) AcceptWithContext(ctx context.Context, v SearchSavedViewsQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	case "titleExactSubstringSearch":
		if u.titleExactSubstringSearch == nil {
			return fmt.Errorf("field \"titleExactSubstringSearch\" is required")
		}
		return v.VisitTitleExactSubstringSearchWithContext(ctx, *u.titleExactSubstringSearch)
	case "resourceType":
		if u.resourceType == nil {
			return fmt.Errorf("field \"resourceType\" is required")
		}
		return v.VisitResourceTypeWithContext(ctx, *u.resourceType)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	}
}

type SearchSavedViewsQueryVisitorWithContext interface {
	VisitAndWithContext(ctx context.Context, v SearchSavedViewsQueryList) error
	VisitOrWithContext(ctx context.Context, v SearchSavedViewsQueryList) error
	VisitNotWithContext(ctx context.Context, v SearchSavedViewsQuery) error
	VisitTitleExactSubstringSearchWithContext(ctx context.Context, v string) error
	VisitResourceTypeWithContext(ctx context.Context, v ResourceType) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchSavedViewsQueryFromAnd(v SearchSavedViewsQueryList) SearchSavedViewsQuery {
	return SearchSavedViewsQuery{typ: "and", and: &v}
}

func NewSearchSavedViewsQueryFromOr(v SearchSavedViewsQueryList) SearchSavedViewsQuery {
	return SearchSavedViewsQuery{typ: "or", or: &v}
}

func NewSearchSavedViewsQueryFromNot(v SearchSavedViewsQuery) SearchSavedViewsQuery {
	return SearchSavedViewsQuery{typ: "not", not: &v}
}

func NewSearchSavedViewsQueryFromTitleExactSubstringSearch(v string) SearchSavedViewsQuery {
	return SearchSavedViewsQuery{typ: "titleExactSubstringSearch", titleExactSubstringSearch: &v}
}

func NewSearchSavedViewsQueryFromResourceType(v ResourceType) SearchSavedViewsQuery {
	return SearchSavedViewsQuery{typ: "resourceType", resourceType: &v}
}

func NewSearchSavedViewsQueryFromWorkspace(v rids.WorkspaceRid) SearchSavedViewsQuery {
	return SearchSavedViewsQuery{typ: "workspace", workspace: &v}
}

type SearchState struct {
	typ       string
	asset     *AssetSearchState
	run       *RunSearchState
	checklist *ChecklistSearchState
	workbook  *WorkbookSearchState
	template  *TemplateSearchState
}

type searchStateDeserializer struct {
	Type      string                `json:"type"`
	Asset     *AssetSearchState     `json:"asset"`
	Run       *RunSearchState       `json:"run"`
	Checklist *ChecklistSearchState `json:"checklist"`
	Workbook  *WorkbookSearchState  `json:"workbook"`
	Template  *TemplateSearchState  `json:"template"`
}

func (u *searchStateDeserializer) toStruct() SearchState {
	return SearchState{typ: u.Type, asset: u.Asset, run: u.Run, checklist: u.Checklist, workbook: u.Workbook, template: u.Template}
}

func (u *SearchState) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "asset":
		if u.asset == nil {
			return nil, fmt.Errorf("field \"asset\" is required")
		}
		return struct {
			Type  string           `json:"type"`
			Asset AssetSearchState `json:"asset"`
		}{Type: "asset", Asset: *u.asset}, nil
	case "run":
		if u.run == nil {
			return nil, fmt.Errorf("field \"run\" is required")
		}
		return struct {
			Type string         `json:"type"`
			Run  RunSearchState `json:"run"`
		}{Type: "run", Run: *u.run}, nil
	case "checklist":
		if u.checklist == nil {
			return nil, fmt.Errorf("field \"checklist\" is required")
		}
		return struct {
			Type      string               `json:"type"`
			Checklist ChecklistSearchState `json:"checklist"`
		}{Type: "checklist", Checklist: *u.checklist}, nil
	case "workbook":
		if u.workbook == nil {
			return nil, fmt.Errorf("field \"workbook\" is required")
		}
		return struct {
			Type     string              `json:"type"`
			Workbook WorkbookSearchState `json:"workbook"`
		}{Type: "workbook", Workbook: *u.workbook}, nil
	case "template":
		if u.template == nil {
			return nil, fmt.Errorf("field \"template\" is required")
		}
		return struct {
			Type     string              `json:"type"`
			Template TemplateSearchState `json:"template"`
		}{Type: "template", Template: *u.template}, nil
	}
}

func (u SearchState) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchState) UnmarshalJSON(data []byte) error {
	var deser searchStateDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
	case "template":
		if u.template == nil {
			return fmt.Errorf("field \"template\" is required")
		}
	}
	return nil
}

func (u SearchState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchState) AcceptFuncs(assetFunc func(AssetSearchState) error, runFunc func(RunSearchState) error, checklistFunc func(ChecklistSearchState) error, workbookFunc func(WorkbookSearchState) error, templateFunc func(TemplateSearchState) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return assetFunc(*u.asset)
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
		return runFunc(*u.run)
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
		return checklistFunc(*u.checklist)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return workbookFunc(*u.workbook)
	case "template":
		if u.template == nil {
			return fmt.Errorf("field \"template\" is required")
		}
		return templateFunc(*u.template)
	}
}

func (u *SearchState) AssetNoopSuccess(AssetSearchState) error {
	return nil
}

func (u *SearchState) RunNoopSuccess(RunSearchState) error {
	return nil
}

func (u *SearchState) ChecklistNoopSuccess(ChecklistSearchState) error {
	return nil
}

func (u *SearchState) WorkbookNoopSuccess(WorkbookSearchState) error {
	return nil
}

func (u *SearchState) TemplateNoopSuccess(TemplateSearchState) error {
	return nil
}

func (u *SearchState) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchState) Accept(v SearchStateVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAsset(*u.asset)
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
		return v.VisitRun(*u.run)
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
		return v.VisitChecklist(*u.checklist)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return v.VisitWorkbook(*u.workbook)
	case "template":
		if u.template == nil {
			return fmt.Errorf("field \"template\" is required")
		}
		return v.VisitTemplate(*u.template)
	}
}

type SearchStateVisitor interface {
	VisitAsset(v AssetSearchState) error
	VisitRun(v RunSearchState) error
	VisitChecklist(v ChecklistSearchState) error
	VisitWorkbook(v WorkbookSearchState) error
	VisitTemplate(v TemplateSearchState) error
	VisitUnknown(typeName string) error
}

func (u *SearchState) AcceptWithContext(ctx context.Context, v SearchStateVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAssetWithContext(ctx, *u.asset)
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
		return v.VisitRunWithContext(ctx, *u.run)
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
		return v.VisitChecklistWithContext(ctx, *u.checklist)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return v.VisitWorkbookWithContext(ctx, *u.workbook)
	case "template":
		if u.template == nil {
			return fmt.Errorf("field \"template\" is required")
		}
		return v.VisitTemplateWithContext(ctx, *u.template)
	}
}

type SearchStateVisitorWithContext interface {
	VisitAssetWithContext(ctx context.Context, v AssetSearchState) error
	VisitRunWithContext(ctx context.Context, v RunSearchState) error
	VisitChecklistWithContext(ctx context.Context, v ChecklistSearchState) error
	VisitWorkbookWithContext(ctx context.Context, v WorkbookSearchState) error
	VisitTemplateWithContext(ctx context.Context, v TemplateSearchState) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchStateFromAsset(v AssetSearchState) SearchState {
	return SearchState{typ: "asset", asset: &v}
}

func NewSearchStateFromRun(v RunSearchState) SearchState {
	return SearchState{typ: "run", run: &v}
}

func NewSearchStateFromChecklist(v ChecklistSearchState) SearchState {
	return SearchState{typ: "checklist", checklist: &v}
}

func NewSearchStateFromWorkbook(v WorkbookSearchState) SearchState {
	return SearchState{typ: "workbook", workbook: &v}
}

func NewSearchStateFromTemplate(v TemplateSearchState) SearchState {
	return SearchState{typ: "template", template: &v}
}

type SortKey struct {
	typ   string
	field *SortField
}

type sortKeyDeserializer struct {
	Type  string     `json:"type"`
	Field *SortField `json:"field"`
}

func (u *sortKeyDeserializer) toStruct() SortKey {
	return SortKey{typ: u.Type, field: u.Field}
}

func (u *SortKey) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "field":
		if u.field == nil {
			return nil, fmt.Errorf("field \"field\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Field SortField `json:"field"`
		}{Type: "field", Field: *u.field}, nil
	}
}

func (u SortKey) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SortKey) UnmarshalJSON(data []byte) error {
	var deser sortKeyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
	}
	return nil
}

func (u SortKey) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SortKey) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SortKey) AcceptFuncs(fieldFunc func(SortField) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return fieldFunc(*u.field)
	}
}

func (u *SortKey) FieldNoopSuccess(SortField) error {
	return nil
}

func (u *SortKey) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SortKey) Accept(v SortKeyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return v.VisitField(*u.field)
	}
}

type SortKeyVisitor interface {
	VisitField(v SortField) error
	VisitUnknown(typeName string) error
}

func (u *SortKey) AcceptWithContext(ctx context.Context, v SortKeyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return v.VisitFieldWithContext(ctx, *u.field)
	}
}

type SortKeyVisitorWithContext interface {
	VisitFieldWithContext(ctx context.Context, v SortField) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSortKeyFromField(v SortField) SortKey {
	return SortKey{typ: "field", field: &v}
}

type UpdateColor struct {
	typ        string
	color      *api1.Color
	clearColor *api2.Empty
}

type updateColorDeserializer struct {
	Type       string      `json:"type"`
	Color      *api1.Color `json:"color"`
	ClearColor *api2.Empty `json:"clearColor"`
}

func (u *updateColorDeserializer) toStruct() UpdateColor {
	return UpdateColor{typ: u.Type, color: u.Color, clearColor: u.ClearColor}
}

func (u *UpdateColor) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "color":
		if u.color == nil {
			return nil, fmt.Errorf("field \"color\" is required")
		}
		return struct {
			Type  string     `json:"type"`
			Color api1.Color `json:"color"`
		}{Type: "color", Color: *u.color}, nil
	case "clearColor":
		if u.clearColor == nil {
			return nil, fmt.Errorf("field \"clearColor\" is required")
		}
		return struct {
			Type       string     `json:"type"`
			ClearColor api2.Empty `json:"clearColor"`
		}{Type: "clearColor", ClearColor: *u.clearColor}, nil
	}
}

func (u UpdateColor) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UpdateColor) UnmarshalJSON(data []byte) error {
	var deser updateColorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "color":
		if u.color == nil {
			return fmt.Errorf("field \"color\" is required")
		}
	case "clearColor":
		if u.clearColor == nil {
			return fmt.Errorf("field \"clearColor\" is required")
		}
	}
	return nil
}

func (u UpdateColor) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UpdateColor) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UpdateColor) AcceptFuncs(colorFunc func(api1.Color) error, clearColorFunc func(api2.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "color":
		if u.color == nil {
			return fmt.Errorf("field \"color\" is required")
		}
		return colorFunc(*u.color)
	case "clearColor":
		if u.clearColor == nil {
			return fmt.Errorf("field \"clearColor\" is required")
		}
		return clearColorFunc(*u.clearColor)
	}
}

func (u *UpdateColor) ColorNoopSuccess(api1.Color) error {
	return nil
}

func (u *UpdateColor) ClearColorNoopSuccess(api2.Empty) error {
	return nil
}

func (u *UpdateColor) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UpdateColor) Accept(v UpdateColorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "color":
		if u.color == nil {
			return fmt.Errorf("field \"color\" is required")
		}
		return v.VisitColor(*u.color)
	case "clearColor":
		if u.clearColor == nil {
			return fmt.Errorf("field \"clearColor\" is required")
		}
		return v.VisitClearColor(*u.clearColor)
	}
}

type UpdateColorVisitor interface {
	VisitColor(v api1.Color) error
	VisitClearColor(v api2.Empty) error
	VisitUnknown(typeName string) error
}

func (u *UpdateColor) AcceptWithContext(ctx context.Context, v UpdateColorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "color":
		if u.color == nil {
			return fmt.Errorf("field \"color\" is required")
		}
		return v.VisitColorWithContext(ctx, *u.color)
	case "clearColor":
		if u.clearColor == nil {
			return fmt.Errorf("field \"clearColor\" is required")
		}
		return v.VisitClearColorWithContext(ctx, *u.clearColor)
	}
}

type UpdateColorVisitorWithContext interface {
	VisitColorWithContext(ctx context.Context, v api1.Color) error
	VisitClearColorWithContext(ctx context.Context, v api2.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUpdateColorFromColor(v api1.Color) UpdateColor {
	return UpdateColor{typ: "color", color: &v}
}

func NewUpdateColorFromClearColor(v api2.Empty) UpdateColor {
	return UpdateColor{typ: "clearColor", clearColor: &v}
}

type UpdateSymbol struct {
	typ         string
	symbol      *api1.Symbol
	clearSymbol *api2.Empty
}

type updateSymbolDeserializer struct {
	Type        string       `json:"type"`
	Symbol      *api1.Symbol `json:"symbol"`
	ClearSymbol *api2.Empty  `json:"clearSymbol"`
}

func (u *updateSymbolDeserializer) toStruct() UpdateSymbol {
	return UpdateSymbol{typ: u.Type, symbol: u.Symbol, clearSymbol: u.ClearSymbol}
}

func (u *UpdateSymbol) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "symbol":
		if u.symbol == nil {
			return nil, fmt.Errorf("field \"symbol\" is required")
		}
		return struct {
			Type   string      `json:"type"`
			Symbol api1.Symbol `json:"symbol"`
		}{Type: "symbol", Symbol: *u.symbol}, nil
	case "clearSymbol":
		if u.clearSymbol == nil {
			return nil, fmt.Errorf("field \"clearSymbol\" is required")
		}
		return struct {
			Type        string     `json:"type"`
			ClearSymbol api2.Empty `json:"clearSymbol"`
		}{Type: "clearSymbol", ClearSymbol: *u.clearSymbol}, nil
	}
}

func (u UpdateSymbol) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UpdateSymbol) UnmarshalJSON(data []byte) error {
	var deser updateSymbolDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "symbol":
		if u.symbol == nil {
			return fmt.Errorf("field \"symbol\" is required")
		}
	case "clearSymbol":
		if u.clearSymbol == nil {
			return fmt.Errorf("field \"clearSymbol\" is required")
		}
	}
	return nil
}

func (u UpdateSymbol) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UpdateSymbol) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UpdateSymbol) AcceptFuncs(symbolFunc func(api1.Symbol) error, clearSymbolFunc func(api2.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "symbol":
		if u.symbol == nil {
			return fmt.Errorf("field \"symbol\" is required")
		}
		return symbolFunc(*u.symbol)
	case "clearSymbol":
		if u.clearSymbol == nil {
			return fmt.Errorf("field \"clearSymbol\" is required")
		}
		return clearSymbolFunc(*u.clearSymbol)
	}
}

func (u *UpdateSymbol) SymbolNoopSuccess(api1.Symbol) error {
	return nil
}

func (u *UpdateSymbol) ClearSymbolNoopSuccess(api2.Empty) error {
	return nil
}

func (u *UpdateSymbol) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UpdateSymbol) Accept(v UpdateSymbolVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "symbol":
		if u.symbol == nil {
			return fmt.Errorf("field \"symbol\" is required")
		}
		return v.VisitSymbol(*u.symbol)
	case "clearSymbol":
		if u.clearSymbol == nil {
			return fmt.Errorf("field \"clearSymbol\" is required")
		}
		return v.VisitClearSymbol(*u.clearSymbol)
	}
}

type UpdateSymbolVisitor interface {
	VisitSymbol(v api1.Symbol) error
	VisitClearSymbol(v api2.Empty) error
	VisitUnknown(typeName string) error
}

func (u *UpdateSymbol) AcceptWithContext(ctx context.Context, v UpdateSymbolVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "symbol":
		if u.symbol == nil {
			return fmt.Errorf("field \"symbol\" is required")
		}
		return v.VisitSymbolWithContext(ctx, *u.symbol)
	case "clearSymbol":
		if u.clearSymbol == nil {
			return fmt.Errorf("field \"clearSymbol\" is required")
		}
		return v.VisitClearSymbolWithContext(ctx, *u.clearSymbol)
	}
}

type UpdateSymbolVisitorWithContext interface {
	VisitSymbolWithContext(ctx context.Context, v api1.Symbol) error
	VisitClearSymbolWithContext(ctx context.Context, v api2.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUpdateSymbolFromSymbol(v api1.Symbol) UpdateSymbol {
	return UpdateSymbol{typ: "symbol", symbol: &v}
}

func NewUpdateSymbolFromClearSymbol(v api2.Empty) UpdateSymbol {
	return UpdateSymbol{typ: "clearSymbol", clearSymbol: &v}
}
