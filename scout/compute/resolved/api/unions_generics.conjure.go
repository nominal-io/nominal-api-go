// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/timeseries/logicalseries/api"
)

type ArraySeriesNodeWithT[T any] ArraySeriesNode

func (u *ArraySeriesNodeWithT[T]) Accept(ctx context.Context, v ArraySeriesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return result, fmt.Errorf("field \"numeric1d\" is required")
		}
		return v.VisitNumeric1d(ctx, *u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return result, fmt.Errorf("field \"enum1d\" is required")
		}
		return v.VisitEnum1d(ctx, *u.enum1d)
	}
}

func (u *ArraySeriesNodeWithT[T]) AcceptFuncs(numeric1dFunc func(NumericArraySeriesNode) (T, error), enum1dFunc func(EnumArraySeriesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return result, fmt.Errorf("field \"numeric1d\" is required")
		}
		return numeric1dFunc(*u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return result, fmt.Errorf("field \"enum1d\" is required")
		}
		return enum1dFunc(*u.enum1d)
	}
}

func (u *ArraySeriesNodeWithT[T]) Numeric1dNoopSuccess(NumericArraySeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *ArraySeriesNodeWithT[T]) Enum1dNoopSuccess(EnumArraySeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *ArraySeriesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ArraySeriesNodeVisitorWithT[T any] interface {
	VisitNumeric1d(ctx context.Context, v NumericArraySeriesNode) (T, error)
	VisitEnum1d(ctx context.Context, v EnumArraySeriesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Cartesian3dNodeWithT[T any] Cartesian3dNode

func (u *Cartesian3dNodeWithT[T]) Accept(ctx context.Context, v Cartesian3dNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return result, fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3d(ctx, *u.scatter3d)
	}
}

func (u *Cartesian3dNodeWithT[T]) AcceptFuncs(scatter3dFunc func(Scatter3dNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return result, fmt.Errorf("field \"scatter3d\" is required")
		}
		return scatter3dFunc(*u.scatter3d)
	}
}

func (u *Cartesian3dNodeWithT[T]) Scatter3dNoopSuccess(Scatter3dNode) (T, error) {
	var result T
	return result, nil
}

func (u *Cartesian3dNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Cartesian3dNodeVisitorWithT[T any] interface {
	VisitScatter3d(ctx context.Context, v Scatter3dNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CartesianNodeWithT[T any] CartesianNode

func (u *CartesianNodeWithT[T]) Accept(ctx context.Context, v CartesianNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(ctx, *u.scatter)
	}
}

func (u *CartesianNodeWithT[T]) AcceptFuncs(scatterFunc func(ScatterNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *CartesianNodeWithT[T]) ScatterNoopSuccess(ScatterNode) (T, error) {
	var result T
	return result, nil
}

func (u *CartesianNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CartesianNodeVisitorWithT[T any] interface {
	VisitScatter(ctx context.Context, v ScatterNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CurveFitDetailsWithT[T any] CurveFitDetails

func (u *CurveFitDetailsWithT[T]) Accept(ctx context.Context, v CurveFitDetailsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "exponential":
		if u.exponential == nil {
			return result, fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponential(ctx, *u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return result, fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmic(ctx, *u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return result, fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomial(ctx, *u.polynomial)
	case "power":
		if u.power == nil {
			return result, fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPower(ctx, *u.power)
	}
}

func (u *CurveFitDetailsWithT[T]) AcceptFuncs(exponentialFunc func(ExponentialCurve) (T, error), logarithmicFunc func(LogarithmicCurve) (T, error), polynomialFunc func(PolynomialCurve) (T, error), powerFunc func(PowerCurve) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "exponential":
		if u.exponential == nil {
			return result, fmt.Errorf("field \"exponential\" is required")
		}
		return exponentialFunc(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return result, fmt.Errorf("field \"logarithmic\" is required")
		}
		return logarithmicFunc(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return result, fmt.Errorf("field \"polynomial\" is required")
		}
		return polynomialFunc(*u.polynomial)
	case "power":
		if u.power == nil {
			return result, fmt.Errorf("field \"power\" is required")
		}
		return powerFunc(*u.power)
	}
}

func (u *CurveFitDetailsWithT[T]) ExponentialNoopSuccess(ExponentialCurve) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitDetailsWithT[T]) LogarithmicNoopSuccess(LogarithmicCurve) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitDetailsWithT[T]) PolynomialNoopSuccess(PolynomialCurve) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitDetailsWithT[T]) PowerNoopSuccess(PowerCurve) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitDetailsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CurveFitDetailsVisitorWithT[T any] interface {
	VisitExponential(ctx context.Context, v ExponentialCurve) (T, error)
	VisitLogarithmic(ctx context.Context, v LogarithmicCurve) (T, error)
	VisitPolynomial(ctx context.Context, v PolynomialCurve) (T, error)
	VisitPower(ctx context.Context, v PowerCurve) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CurveFitPlotTypeNodeWithT[T any] CurveFitPlotTypeNode

func (u *CurveFitPlotTypeNodeWithT[T]) Accept(ctx context.Context, v CurveFitPlotTypeNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return result, fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeries(ctx, *u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(ctx, *u.scatter)
	}
}

func (u *CurveFitPlotTypeNodeWithT[T]) AcceptFuncs(timeSeriesFunc func(TimeSeriesCurveFitNode) (T, error), scatterFunc func(ScatterCurveFitNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return result, fmt.Errorf("field \"timeSeries\" is required")
		}
		return timeSeriesFunc(*u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *CurveFitPlotTypeNodeWithT[T]) TimeSeriesNoopSuccess(TimeSeriesCurveFitNode) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitPlotTypeNodeWithT[T]) ScatterNoopSuccess(ScatterCurveFitNode) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitPlotTypeNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CurveFitPlotTypeNodeVisitorWithT[T any] interface {
	VisitTimeSeries(ctx context.Context, v TimeSeriesCurveFitNode) (T, error)
	VisitScatter(ctx context.Context, v ScatterCurveFitNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EnumArraySeriesNodeWithT[T any] EnumArraySeriesNode

func (u *EnumArraySeriesNodeWithT[T]) Accept(ctx context.Context, v EnumArraySeriesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *EnumArraySeriesNodeWithT[T]) AcceptFuncs(rawFunc func(ResolvedSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *EnumArraySeriesNodeWithT[T]) RawNoopSuccess(ResolvedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumArraySeriesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EnumArraySeriesNodeVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v ResolvedSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EnumSeriesNodeWithT[T any] EnumSeriesNode

func (u *EnumSeriesNodeWithT[T]) Accept(ctx context.Context, v EnumSeriesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(ctx, *u.literal)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "resample":
		if u.resample == nil {
			return result, fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResample(ctx, *u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(ctx, *u.timeShift)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(ctx, *u.union)
	case "aggregate":
		if u.aggregate == nil {
			return result, fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregate(ctx, *u.aggregate)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return result, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformation(ctx, *u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return result, fmt.Errorf("field \"valueMap\" is required")
		}
		return v.VisitValueMap(ctx, *u.valueMap)
	case "arraySelect":
		if u.arraySelect == nil {
			return result, fmt.Errorf("field \"arraySelect\" is required")
		}
		return v.VisitArraySelect(ctx, *u.arraySelect)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(ctx, *u.extractFromStruct)
	}
}

func (u *EnumSeriesNodeWithT[T]) AcceptFuncs(literalFunc func(LiteralEnumSeriesNode) (T, error), rawFunc func(RawEnumSeriesNode) (T, error), resampleFunc func(EnumResampleSeriesNode) (T, error), timeRangeFilterFunc func(EnumTimeRangeFilterSeriesNode) (T, error), timeShiftFunc func(EnumTimeShiftSeriesNode) (T, error), unionFunc func(EnumUnionSeriesNode) (T, error), aggregateFunc func(AggregateEnumSeriesNode) (T, error), filterTransformationFunc func(EnumFilterTransformationSeriesNode) (T, error), valueMapFunc func(ValueMapSeriesNode) (T, error), arraySelectFunc func(SelectIndexFromEnumArraySeriesNode) (T, error), extractFromStructFunc func(ExtractEnumFromStructSeriesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "resample":
		if u.resample == nil {
			return result, fmt.Errorf("field \"resample\" is required")
		}
		return resampleFunc(*u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "aggregate":
		if u.aggregate == nil {
			return result, fmt.Errorf("field \"aggregate\" is required")
		}
		return aggregateFunc(*u.aggregate)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return result, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return filterTransformationFunc(*u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return result, fmt.Errorf("field \"valueMap\" is required")
		}
		return valueMapFunc(*u.valueMap)
	case "arraySelect":
		if u.arraySelect == nil {
			return result, fmt.Errorf("field \"arraySelect\" is required")
		}
		return arraySelectFunc(*u.arraySelect)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	}
}

func (u *EnumSeriesNodeWithT[T]) LiteralNoopSuccess(LiteralEnumSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) RawNoopSuccess(RawEnumSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) ResampleNoopSuccess(EnumResampleSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) TimeRangeFilterNoopSuccess(EnumTimeRangeFilterSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) TimeShiftNoopSuccess(EnumTimeShiftSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) UnionNoopSuccess(EnumUnionSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) AggregateNoopSuccess(AggregateEnumSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) FilterTransformationNoopSuccess(EnumFilterTransformationSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) ValueMapNoopSuccess(ValueMapSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) ArraySelectNoopSuccess(SelectIndexFromEnumArraySeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) ExtractFromStructNoopSuccess(ExtractEnumFromStructSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EnumSeriesNodeVisitorWithT[T any] interface {
	VisitLiteral(ctx context.Context, v LiteralEnumSeriesNode) (T, error)
	VisitRaw(ctx context.Context, v RawEnumSeriesNode) (T, error)
	VisitResample(ctx context.Context, v EnumResampleSeriesNode) (T, error)
	VisitTimeRangeFilter(ctx context.Context, v EnumTimeRangeFilterSeriesNode) (T, error)
	VisitTimeShift(ctx context.Context, v EnumTimeShiftSeriesNode) (T, error)
	VisitUnion(ctx context.Context, v EnumUnionSeriesNode) (T, error)
	VisitAggregate(ctx context.Context, v AggregateEnumSeriesNode) (T, error)
	VisitFilterTransformation(ctx context.Context, v EnumFilterTransformationSeriesNode) (T, error)
	VisitValueMap(ctx context.Context, v ValueMapSeriesNode) (T, error)
	VisitArraySelect(ctx context.Context, v SelectIndexFromEnumArraySeriesNode) (T, error)
	VisitExtractFromStruct(ctx context.Context, v ExtractEnumFromStructSeriesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FrequencyDomainNodeWithT[T any] FrequencyDomainNode

func (u *FrequencyDomainNodeWithT[T]) Accept(ctx context.Context, v FrequencyDomainNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(ctx, *u.fft)
	case "psd":
		if u.psd == nil {
			return result, fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsd(ctx, *u.psd)
	}
}

func (u *FrequencyDomainNodeWithT[T]) AcceptFuncs(fftFunc func(FftNode) (T, error), psdFunc func(PsdNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	case "psd":
		if u.psd == nil {
			return result, fmt.Errorf("field \"psd\" is required")
		}
		return psdFunc(*u.psd)
	}
}

func (u *FrequencyDomainNodeWithT[T]) FftNoopSuccess(FftNode) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainNodeWithT[T]) PsdNoopSuccess(PsdNode) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FrequencyDomainNodeVisitorWithT[T any] interface {
	VisitFft(ctx context.Context, v FftNode) (T, error)
	VisitPsd(ctx context.Context, v PsdNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FrequencyDomainNodeV2WithT[T any] FrequencyDomainNodeV2

func (u *FrequencyDomainNodeV2WithT[T]) Accept(ctx context.Context, v FrequencyDomainNodeV2VisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(ctx, *u.fft)
	case "psd":
		if u.psd == nil {
			return result, fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsd(ctx, *u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return result, fmt.Errorf("field \"cpsd\" is required")
		}
		return v.VisitCpsd(ctx, *u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return result, fmt.Errorf("field \"nyquist\" is required")
		}
		return v.VisitNyquist(ctx, *u.nyquist)
	case "bode":
		if u.bode == nil {
			return result, fmt.Errorf("field \"bode\" is required")
		}
		return v.VisitBode(ctx, *u.bode)
	}
}

func (u *FrequencyDomainNodeV2WithT[T]) AcceptFuncs(fftFunc func(FftNode) (T, error), psdFunc func(PsdNode) (T, error), cpsdFunc func(CpsdNode) (T, error), nyquistFunc func(NyquistNode) (T, error), bodeFunc func(BodeNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	case "psd":
		if u.psd == nil {
			return result, fmt.Errorf("field \"psd\" is required")
		}
		return psdFunc(*u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return result, fmt.Errorf("field \"cpsd\" is required")
		}
		return cpsdFunc(*u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return result, fmt.Errorf("field \"nyquist\" is required")
		}
		return nyquistFunc(*u.nyquist)
	case "bode":
		if u.bode == nil {
			return result, fmt.Errorf("field \"bode\" is required")
		}
		return bodeFunc(*u.bode)
	}
}

func (u *FrequencyDomainNodeV2WithT[T]) FftNoopSuccess(FftNode) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainNodeV2WithT[T]) PsdNoopSuccess(PsdNode) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainNodeV2WithT[T]) CpsdNoopSuccess(CpsdNode) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainNodeV2WithT[T]) NyquistNoopSuccess(NyquistNode) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainNodeV2WithT[T]) BodeNoopSuccess(BodeNode) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainNodeV2WithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FrequencyDomainNodeV2VisitorWithT[T any] interface {
	VisitFft(ctx context.Context, v FftNode) (T, error)
	VisitPsd(ctx context.Context, v PsdNode) (T, error)
	VisitCpsd(ctx context.Context, v CpsdNode) (T, error)
	VisitNyquist(ctx context.Context, v NyquistNode) (T, error)
	VisitBode(ctx context.Context, v BodeNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type HistogramNodeWithT[T any] HistogramNode

func (u *HistogramNodeWithT[T]) Accept(ctx context.Context, v HistogramNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return result, fmt.Errorf("field \"numericHistogram\" is required")
		}
		return v.VisitNumericHistogram(ctx, *u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return result, fmt.Errorf("field \"enumHistogram\" is required")
		}
		return v.VisitEnumHistogram(ctx, *u.enumHistogram)
	}
}

func (u *HistogramNodeWithT[T]) AcceptFuncs(numericHistogramFunc func(NumericHistogramNode) (T, error), enumHistogramFunc func(EnumHistogramNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return result, fmt.Errorf("field \"numericHistogram\" is required")
		}
		return numericHistogramFunc(*u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return result, fmt.Errorf("field \"enumHistogram\" is required")
		}
		return enumHistogramFunc(*u.enumHistogram)
	}
}

func (u *HistogramNodeWithT[T]) NumericHistogramNoopSuccess(NumericHistogramNode) (T, error) {
	var result T
	return result, nil
}

func (u *HistogramNodeWithT[T]) EnumHistogramNoopSuccess(EnumHistogramNode) (T, error) {
	var result T
	return result, nil
}

func (u *HistogramNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type HistogramNodeVisitorWithT[T any] interface {
	VisitNumericHistogram(ctx context.Context, v NumericHistogramNode) (T, error)
	VisitEnumHistogram(ctx context.Context, v EnumHistogramNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type InterpolationConfigurationWithT[T any] InterpolationConfiguration

func (u *InterpolationConfigurationWithT[T]) Accept(ctx context.Context, v InterpolationConfigurationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return result, fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return v.VisitForwardFillInterpolation(ctx, *u.forwardFillInterpolation)
	}
}

func (u *InterpolationConfigurationWithT[T]) AcceptFuncs(forwardFillInterpolationFunc func(ForwardFillInterpolation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return result, fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return forwardFillInterpolationFunc(*u.forwardFillInterpolation)
	}
}

func (u *InterpolationConfigurationWithT[T]) ForwardFillInterpolationNoopSuccess(ForwardFillInterpolation) (T, error) {
	var result T
	return result, nil
}

func (u *InterpolationConfigurationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type InterpolationConfigurationVisitorWithT[T any] interface {
	VisitForwardFillInterpolation(ctx context.Context, v ForwardFillInterpolation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type LogSeriesNodeWithT[T any] LogSeriesNode

func (u *LogSeriesNodeWithT[T]) Accept(ctx context.Context, v LogSeriesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(ctx, *u.union)
	case "filter":
		if u.filter == nil {
			return result, fmt.Errorf("field \"filter\" is required")
		}
		return v.VisitFilter(ctx, *u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(ctx, *u.timeShift)
	}
}

func (u *LogSeriesNodeWithT[T]) AcceptFuncs(rawFunc func(RawLogSeriesNode) (T, error), unionFunc func(LogUnionSeriesNode) (T, error), filterFunc func(LogFilterSeriesNode) (T, error), timeShiftFunc func(LogTimeShiftSeriesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "filter":
		if u.filter == nil {
			return result, fmt.Errorf("field \"filter\" is required")
		}
		return filterFunc(*u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	}
}

func (u *LogSeriesNodeWithT[T]) RawNoopSuccess(RawLogSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *LogSeriesNodeWithT[T]) UnionNoopSuccess(LogUnionSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *LogSeriesNodeWithT[T]) FilterNoopSuccess(LogFilterSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *LogSeriesNodeWithT[T]) TimeShiftNoopSuccess(LogTimeShiftSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *LogSeriesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LogSeriesNodeVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v RawLogSeriesNode) (T, error)
	VisitUnion(ctx context.Context, v LogUnionSeriesNode) (T, error)
	VisitFilter(ctx context.Context, v LogFilterSeriesNode) (T, error)
	VisitTimeShift(ctx context.Context, v LogTimeShiftSeriesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericArraySeriesNodeWithT[T any] NumericArraySeriesNode

func (u *NumericArraySeriesNodeWithT[T]) Accept(ctx context.Context, v NumericArraySeriesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *NumericArraySeriesNodeWithT[T]) AcceptFuncs(rawFunc func(ResolvedSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *NumericArraySeriesNodeWithT[T]) RawNoopSuccess(ResolvedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericArraySeriesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericArraySeriesNodeVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v ResolvedSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericHistogramBucketStrategyWithT[T any] NumericHistogramBucketStrategy

func (u *NumericHistogramBucketStrategyWithT[T]) Accept(ctx context.Context, v NumericHistogramBucketStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return result, fmt.Errorf("field \"bucketCount\" is required")
		}
		return v.VisitBucketCount(ctx, *u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return result, fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return v.VisitBucketWidthAndOffset(ctx, *u.bucketWidthAndOffset)
	}
}

func (u *NumericHistogramBucketStrategyWithT[T]) AcceptFuncs(bucketCountFunc func(int) (T, error), bucketWidthAndOffsetFunc func(NumericHistogramBucketWidthAndOffset) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return result, fmt.Errorf("field \"bucketCount\" is required")
		}
		return bucketCountFunc(*u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return result, fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return bucketWidthAndOffsetFunc(*u.bucketWidthAndOffset)
	}
}

func (u *NumericHistogramBucketStrategyWithT[T]) BucketCountNoopSuccess(int) (T, error) {
	var result T
	return result, nil
}

func (u *NumericHistogramBucketStrategyWithT[T]) BucketWidthAndOffsetNoopSuccess(NumericHistogramBucketWidthAndOffset) (T, error) {
	var result T
	return result, nil
}

func (u *NumericHistogramBucketStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericHistogramBucketStrategyVisitorWithT[T any] interface {
	VisitBucketCount(ctx context.Context, v int) (T, error)
	VisitBucketWidthAndOffset(ctx context.Context, v NumericHistogramBucketWidthAndOffset) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericSeriesNodeWithT[T any] NumericSeriesNode

func (u *NumericSeriesNodeWithT[T]) Accept(ctx context.Context, v NumericSeriesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "arithmetic":
		if u.arithmetic == nil {
			return result, fmt.Errorf("field \"arithmetic\" is required")
		}
		return v.VisitArithmetic(ctx, *u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return result, fmt.Errorf("field \"bitOperation\" is required")
		}
		return v.VisitBitOperation(ctx, *u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return result, fmt.Errorf("field \"countDuplicate\" is required")
		}
		return v.VisitCountDuplicate(ctx, *u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return result, fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return v.VisitCumulativeSum(ctx, *u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return result, fmt.Errorf("field \"derivative\" is required")
		}
		return v.VisitDerivative(ctx, *u.derivative)
	case "integral":
		if u.integral == nil {
			return result, fmt.Errorf("field \"integral\" is required")
		}
		return v.VisitIntegral(ctx, *u.integral)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(ctx, *u.max)
	case "mean":
		if u.mean == nil {
			return result, fmt.Errorf("field \"mean\" is required")
		}
		return v.VisitMean(ctx, *u.mean)
	case "min":
		if u.min == nil {
			return result, fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(ctx, *u.min)
	case "offset":
		if u.offset == nil {
			return result, fmt.Errorf("field \"offset\" is required")
		}
		return v.VisitOffset(ctx, *u.offset)
	case "product":
		if u.product == nil {
			return result, fmt.Errorf("field \"product\" is required")
		}
		return v.VisitProduct(ctx, *u.product)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "resample":
		if u.resample == nil {
			return result, fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResample(ctx, *u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return result, fmt.Errorf("field \"rollingOperation\" is required")
		}
		return v.VisitRollingOperation(ctx, *u.rollingOperation)
	case "aggregate":
		if u.aggregate == nil {
			return result, fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregate(ctx, *u.aggregate)
	case "signalFilter":
		if u.signalFilter == nil {
			return result, fmt.Errorf("field \"signalFilter\" is required")
		}
		return v.VisitSignalFilter(ctx, *u.signalFilter)
	case "sum":
		if u.sum == nil {
			return result, fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSum(ctx, *u.sum)
	case "scale":
		if u.scale == nil {
			return result, fmt.Errorf("field \"scale\" is required")
		}
		return v.VisitScale(ctx, *u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return result, fmt.Errorf("field \"timeDifference\" is required")
		}
		return v.VisitTimeDifference(ctx, *u.timeDifference)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(ctx, *u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return result, fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return v.VisitUnaryArithmetic(ctx, *u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return result, fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return v.VisitBinaryArithmetic(ctx, *u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(ctx, *u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return result, fmt.Errorf("field \"unitConversion\" is required")
		}
		return v.VisitUnitConversion(ctx, *u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return result, fmt.Errorf("field \"valueDifference\" is required")
		}
		return v.VisitValueDifference(ctx, *u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return result, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformation(ctx, *u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return result, fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return v.VisitThresholdFilter(ctx, *u.thresholdFilter)
	case "arraySelect":
		if u.arraySelect == nil {
			return result, fmt.Errorf("field \"arraySelect\" is required")
		}
		return v.VisitArraySelect(ctx, *u.arraySelect)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return result, fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return v.VisitAbsoluteTimestamp(ctx, *u.absoluteTimestamp)
	case "newestPoints":
		if u.newestPoints == nil {
			return result, fmt.Errorf("field \"newestPoints\" is required")
		}
		return v.VisitNewestPoints(ctx, *u.newestPoints)
	case "rangesNumericAggregationToNumeric":
		if u.rangesNumericAggregationToNumeric == nil {
			return result, fmt.Errorf("field \"rangesNumericAggregationToNumeric\" is required")
		}
		return v.VisitRangesNumericAggregationToNumeric(ctx, *u.rangesNumericAggregationToNumeric)
	case "filterByExpression":
		if u.filterByExpression == nil {
			return result, fmt.Errorf("field \"filterByExpression\" is required")
		}
		return v.VisitFilterByExpression(ctx, *u.filterByExpression)
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return result, fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return v.VisitEnumToNumeric(ctx, *u.enumToNumeric)
	case "refprop":
		if u.refprop == nil {
			return result, fmt.Errorf("field \"refprop\" is required")
		}
		return v.VisitRefprop(ctx, *u.refprop)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(ctx, *u.extractFromStruct)
	}
}

func (u *NumericSeriesNodeWithT[T]) AcceptFuncs(arithmeticFunc func(ArithmeticSeriesNode) (T, error), bitOperationFunc func(BitOperationSeriesNode) (T, error), countDuplicateFunc func(EnumCountDuplicateSeriesNode) (T, error), cumulativeSumFunc func(CumulativeSumSeriesNode) (T, error), derivativeFunc func(DerivativeSeriesNode) (T, error), integralFunc func(IntegralSeriesNode) (T, error), maxFunc func(MaxSeriesNode) (T, error), meanFunc func(MeanSeriesNode) (T, error), minFunc func(MinSeriesNode) (T, error), offsetFunc func(OffsetSeriesNode) (T, error), productFunc func(ProductSeriesNode) (T, error), rawFunc func(RawNumericSeriesNode) (T, error), resampleFunc func(NumericResampleSeriesNode) (T, error), rollingOperationFunc func(RollingOperationSeriesNode) (T, error), aggregateFunc func(AggregateNumericSeriesNode) (T, error), signalFilterFunc func(SignalFilterSeriesNode) (T, error), sumFunc func(SumSeriesNode) (T, error), scaleFunc func(ScaleSeriesNode) (T, error), timeDifferenceFunc func(TimeDifferenceSeriesNode) (T, error), timeRangeFilterFunc func(NumericTimeRangeFilterSeriesNode) (T, error), timeShiftFunc func(NumericTimeShiftSeriesNode) (T, error), unaryArithmeticFunc func(UnaryArithmeticSeriesNode) (T, error), binaryArithmeticFunc func(BinaryArithmeticSeriesNode) (T, error), unionFunc func(NumericUnionSeriesNode) (T, error), unitConversionFunc func(UnitConversionSeriesNode) (T, error), valueDifferenceFunc func(ValueDifferenceSeriesNode) (T, error), filterTransformationFunc func(NumericFilterTransformationSeriesNode) (T, error), thresholdFilterFunc func(NumericThresholdFilterSeriesNode) (T, error), arraySelectFunc func(SelectIndexFromNumericArraySeriesNode) (T, error), absoluteTimestampFunc func(AbsoluteTimestampSeriesNode) (T, error), newestPointsFunc func(SelectNewestPointsSeriesNode) (T, error), rangesNumericAggregationToNumericFunc func(RangesNumericAggregationToNumericSeriesNode) (T, error), filterByExpressionFunc func(FilterByExpressionSeriesNode) (T, error), enumToNumericFunc func(EnumToNumericSeriesNode) (T, error), refpropFunc func(RefpropSeriesNode) (T, error), extractFromStructFunc func(ExtractNumericFromStructSeriesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "arithmetic":
		if u.arithmetic == nil {
			return result, fmt.Errorf("field \"arithmetic\" is required")
		}
		return arithmeticFunc(*u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return result, fmt.Errorf("field \"bitOperation\" is required")
		}
		return bitOperationFunc(*u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return result, fmt.Errorf("field \"countDuplicate\" is required")
		}
		return countDuplicateFunc(*u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return result, fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return cumulativeSumFunc(*u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return result, fmt.Errorf("field \"derivative\" is required")
		}
		return derivativeFunc(*u.derivative)
	case "integral":
		if u.integral == nil {
			return result, fmt.Errorf("field \"integral\" is required")
		}
		return integralFunc(*u.integral)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "mean":
		if u.mean == nil {
			return result, fmt.Errorf("field \"mean\" is required")
		}
		return meanFunc(*u.mean)
	case "min":
		if u.min == nil {
			return result, fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "offset":
		if u.offset == nil {
			return result, fmt.Errorf("field \"offset\" is required")
		}
		return offsetFunc(*u.offset)
	case "product":
		if u.product == nil {
			return result, fmt.Errorf("field \"product\" is required")
		}
		return productFunc(*u.product)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "resample":
		if u.resample == nil {
			return result, fmt.Errorf("field \"resample\" is required")
		}
		return resampleFunc(*u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return result, fmt.Errorf("field \"rollingOperation\" is required")
		}
		return rollingOperationFunc(*u.rollingOperation)
	case "aggregate":
		if u.aggregate == nil {
			return result, fmt.Errorf("field \"aggregate\" is required")
		}
		return aggregateFunc(*u.aggregate)
	case "signalFilter":
		if u.signalFilter == nil {
			return result, fmt.Errorf("field \"signalFilter\" is required")
		}
		return signalFilterFunc(*u.signalFilter)
	case "sum":
		if u.sum == nil {
			return result, fmt.Errorf("field \"sum\" is required")
		}
		return sumFunc(*u.sum)
	case "scale":
		if u.scale == nil {
			return result, fmt.Errorf("field \"scale\" is required")
		}
		return scaleFunc(*u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return result, fmt.Errorf("field \"timeDifference\" is required")
		}
		return timeDifferenceFunc(*u.timeDifference)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return result, fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return unaryArithmeticFunc(*u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return result, fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return binaryArithmeticFunc(*u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return result, fmt.Errorf("field \"unitConversion\" is required")
		}
		return unitConversionFunc(*u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return result, fmt.Errorf("field \"valueDifference\" is required")
		}
		return valueDifferenceFunc(*u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return result, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return filterTransformationFunc(*u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return result, fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return thresholdFilterFunc(*u.thresholdFilter)
	case "arraySelect":
		if u.arraySelect == nil {
			return result, fmt.Errorf("field \"arraySelect\" is required")
		}
		return arraySelectFunc(*u.arraySelect)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return result, fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return absoluteTimestampFunc(*u.absoluteTimestamp)
	case "newestPoints":
		if u.newestPoints == nil {
			return result, fmt.Errorf("field \"newestPoints\" is required")
		}
		return newestPointsFunc(*u.newestPoints)
	case "rangesNumericAggregationToNumeric":
		if u.rangesNumericAggregationToNumeric == nil {
			return result, fmt.Errorf("field \"rangesNumericAggregationToNumeric\" is required")
		}
		return rangesNumericAggregationToNumericFunc(*u.rangesNumericAggregationToNumeric)
	case "filterByExpression":
		if u.filterByExpression == nil {
			return result, fmt.Errorf("field \"filterByExpression\" is required")
		}
		return filterByExpressionFunc(*u.filterByExpression)
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return result, fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return enumToNumericFunc(*u.enumToNumeric)
	case "refprop":
		if u.refprop == nil {
			return result, fmt.Errorf("field \"refprop\" is required")
		}
		return refpropFunc(*u.refprop)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	}
}

func (u *NumericSeriesNodeWithT[T]) ArithmeticNoopSuccess(ArithmeticSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) BitOperationNoopSuccess(BitOperationSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) CountDuplicateNoopSuccess(EnumCountDuplicateSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) CumulativeSumNoopSuccess(CumulativeSumSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) DerivativeNoopSuccess(DerivativeSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) IntegralNoopSuccess(IntegralSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) MaxNoopSuccess(MaxSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) MeanNoopSuccess(MeanSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) MinNoopSuccess(MinSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) OffsetNoopSuccess(OffsetSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) ProductNoopSuccess(ProductSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) RawNoopSuccess(RawNumericSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) ResampleNoopSuccess(NumericResampleSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) RollingOperationNoopSuccess(RollingOperationSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) AggregateNoopSuccess(AggregateNumericSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) SignalFilterNoopSuccess(SignalFilterSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) SumNoopSuccess(SumSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) ScaleNoopSuccess(ScaleSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) TimeDifferenceNoopSuccess(TimeDifferenceSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) TimeRangeFilterNoopSuccess(NumericTimeRangeFilterSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) TimeShiftNoopSuccess(NumericTimeShiftSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) UnaryArithmeticNoopSuccess(UnaryArithmeticSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) BinaryArithmeticNoopSuccess(BinaryArithmeticSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) UnionNoopSuccess(NumericUnionSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) UnitConversionNoopSuccess(UnitConversionSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) ValueDifferenceNoopSuccess(ValueDifferenceSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) FilterTransformationNoopSuccess(NumericFilterTransformationSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) ThresholdFilterNoopSuccess(NumericThresholdFilterSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) ArraySelectNoopSuccess(SelectIndexFromNumericArraySeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) AbsoluteTimestampNoopSuccess(AbsoluteTimestampSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) NewestPointsNoopSuccess(SelectNewestPointsSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) RangesNumericAggregationToNumericNoopSuccess(RangesNumericAggregationToNumericSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) FilterByExpressionNoopSuccess(FilterByExpressionSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) EnumToNumericNoopSuccess(EnumToNumericSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) RefpropNoopSuccess(RefpropSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) ExtractFromStructNoopSuccess(ExtractNumericFromStructSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericSeriesNodeVisitorWithT[T any] interface {
	VisitArithmetic(ctx context.Context, v ArithmeticSeriesNode) (T, error)
	VisitBitOperation(ctx context.Context, v BitOperationSeriesNode) (T, error)
	VisitCountDuplicate(ctx context.Context, v EnumCountDuplicateSeriesNode) (T, error)
	VisitCumulativeSum(ctx context.Context, v CumulativeSumSeriesNode) (T, error)
	VisitDerivative(ctx context.Context, v DerivativeSeriesNode) (T, error)
	VisitIntegral(ctx context.Context, v IntegralSeriesNode) (T, error)
	VisitMax(ctx context.Context, v MaxSeriesNode) (T, error)
	VisitMean(ctx context.Context, v MeanSeriesNode) (T, error)
	VisitMin(ctx context.Context, v MinSeriesNode) (T, error)
	VisitOffset(ctx context.Context, v OffsetSeriesNode) (T, error)
	VisitProduct(ctx context.Context, v ProductSeriesNode) (T, error)
	VisitRaw(ctx context.Context, v RawNumericSeriesNode) (T, error)
	VisitResample(ctx context.Context, v NumericResampleSeriesNode) (T, error)
	VisitRollingOperation(ctx context.Context, v RollingOperationSeriesNode) (T, error)
	VisitAggregate(ctx context.Context, v AggregateNumericSeriesNode) (T, error)
	VisitSignalFilter(ctx context.Context, v SignalFilterSeriesNode) (T, error)
	VisitSum(ctx context.Context, v SumSeriesNode) (T, error)
	VisitScale(ctx context.Context, v ScaleSeriesNode) (T, error)
	VisitTimeDifference(ctx context.Context, v TimeDifferenceSeriesNode) (T, error)
	VisitTimeRangeFilter(ctx context.Context, v NumericTimeRangeFilterSeriesNode) (T, error)
	VisitTimeShift(ctx context.Context, v NumericTimeShiftSeriesNode) (T, error)
	VisitUnaryArithmetic(ctx context.Context, v UnaryArithmeticSeriesNode) (T, error)
	VisitBinaryArithmetic(ctx context.Context, v BinaryArithmeticSeriesNode) (T, error)
	VisitUnion(ctx context.Context, v NumericUnionSeriesNode) (T, error)
	VisitUnitConversion(ctx context.Context, v UnitConversionSeriesNode) (T, error)
	VisitValueDifference(ctx context.Context, v ValueDifferenceSeriesNode) (T, error)
	VisitFilterTransformation(ctx context.Context, v NumericFilterTransformationSeriesNode) (T, error)
	VisitThresholdFilter(ctx context.Context, v NumericThresholdFilterSeriesNode) (T, error)
	VisitArraySelect(ctx context.Context, v SelectIndexFromNumericArraySeriesNode) (T, error)
	VisitAbsoluteTimestamp(ctx context.Context, v AbsoluteTimestampSeriesNode) (T, error)
	VisitNewestPoints(ctx context.Context, v SelectNewestPointsSeriesNode) (T, error)
	VisitRangesNumericAggregationToNumeric(ctx context.Context, v RangesNumericAggregationToNumericSeriesNode) (T, error)
	VisitFilterByExpression(ctx context.Context, v FilterByExpressionSeriesNode) (T, error)
	VisitEnumToNumeric(ctx context.Context, v EnumToNumericSeriesNode) (T, error)
	VisitRefprop(ctx context.Context, v RefpropSeriesNode) (T, error)
	VisitExtractFromStruct(ctx context.Context, v ExtractNumericFromStructSeriesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type RangesNodeWithT[T any] RangesNode

func (u *RangesNodeWithT[T]) Accept(ctx context.Context, v RangesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "durationFilter":
		if u.durationFilter == nil {
			return result, fmt.Errorf("field \"durationFilter\" is required")
		}
		return v.VisitDurationFilter(ctx, *u.durationFilter)
	case "enumEquality":
		if u.enumEquality == nil {
			return result, fmt.Errorf("field \"enumEquality\" is required")
		}
		return v.VisitEnumEquality(ctx, *u.enumEquality)
	case "enumFilter":
		if u.enumFilter == nil {
			return result, fmt.Errorf("field \"enumFilter\" is required")
		}
		return v.VisitEnumFilter(ctx, *u.enumFilter)
	case "extrema":
		if u.extrema == nil {
			return result, fmt.Errorf("field \"extrema\" is required")
		}
		return v.VisitExtrema(ctx, *u.extrema)
	case "intersectRange":
		if u.intersectRange == nil {
			return result, fmt.Errorf("field \"intersectRange\" is required")
		}
		return v.VisitIntersectRange(ctx, *u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return result, fmt.Errorf("field \"literalRanges\" is required")
		}
		return v.VisitLiteralRanges(ctx, *u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return result, fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return v.VisitMinMaxThreshold(ctx, *u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(ctx, *u.not)
	case "onChange":
		if u.onChange == nil {
			return result, fmt.Errorf("field \"onChange\" is required")
		}
		return v.VisitOnChange(ctx, *u.onChange)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return result, fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return v.VisitRangeNumericAggregation(ctx, *u.rangeNumericAggregation)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return result, fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return v.VisitSeriesCrossoverRangesNode(ctx, *u.seriesCrossoverRangesNode)
	case "staleRange":
		if u.staleRange == nil {
			return result, fmt.Errorf("field \"staleRange\" is required")
		}
		return v.VisitStaleRange(ctx, *u.staleRange)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return result, fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return v.VisitStabilityDetection(ctx, *u.stabilityDetection)
	case "threshold":
		if u.threshold == nil {
			return result, fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThreshold(ctx, *u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return result, fmt.Errorf("field \"unionRange\" is required")
		}
		return v.VisitUnionRange(ctx, *u.unionRange)
	case "paddedRanges":
		if u.paddedRanges == nil {
			return result, fmt.Errorf("field \"paddedRanges\" is required")
		}
		return v.VisitPaddedRanges(ctx, *u.paddedRanges)
	}
}

func (u *RangesNodeWithT[T]) AcceptFuncs(durationFilterFunc func(DurationFilterRangesNode) (T, error), enumEqualityFunc func(EnumEqualityRangesNode) (T, error), enumFilterFunc func(EnumFilterRangesNode) (T, error), extremaFunc func(ExtremaRangesNode) (T, error), intersectRangeFunc func(IntersectRangesNode) (T, error), literalRangesFunc func(LiteralRangesNode) (T, error), minMaxThresholdFunc func(MinMaxThresholdRangesNode) (T, error), notFunc func(NotRangesNode) (T, error), onChangeFunc func(OnChangeRangesNode) (T, error), rangeNumericAggregationFunc func(RangesNumericAggregationNode) (T, error), seriesCrossoverRangesNodeFunc func(SeriesCrossoverRangesNode) (T, error), staleRangeFunc func(StaleRangesNode) (T, error), stabilityDetectionFunc func(StabilityDetectionRangesNode) (T, error), thresholdFunc func(ThresholdingRangesNode) (T, error), unionRangeFunc func(UnionRangesNode) (T, error), paddedRangesFunc func(PaddedRangesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "durationFilter":
		if u.durationFilter == nil {
			return result, fmt.Errorf("field \"durationFilter\" is required")
		}
		return durationFilterFunc(*u.durationFilter)
	case "enumEquality":
		if u.enumEquality == nil {
			return result, fmt.Errorf("field \"enumEquality\" is required")
		}
		return enumEqualityFunc(*u.enumEquality)
	case "enumFilter":
		if u.enumFilter == nil {
			return result, fmt.Errorf("field \"enumFilter\" is required")
		}
		return enumFilterFunc(*u.enumFilter)
	case "extrema":
		if u.extrema == nil {
			return result, fmt.Errorf("field \"extrema\" is required")
		}
		return extremaFunc(*u.extrema)
	case "intersectRange":
		if u.intersectRange == nil {
			return result, fmt.Errorf("field \"intersectRange\" is required")
		}
		return intersectRangeFunc(*u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return result, fmt.Errorf("field \"literalRanges\" is required")
		}
		return literalRangesFunc(*u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return result, fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return minMaxThresholdFunc(*u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "onChange":
		if u.onChange == nil {
			return result, fmt.Errorf("field \"onChange\" is required")
		}
		return onChangeFunc(*u.onChange)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return result, fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return rangeNumericAggregationFunc(*u.rangeNumericAggregation)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return result, fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return seriesCrossoverRangesNodeFunc(*u.seriesCrossoverRangesNode)
	case "staleRange":
		if u.staleRange == nil {
			return result, fmt.Errorf("field \"staleRange\" is required")
		}
		return staleRangeFunc(*u.staleRange)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return result, fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return stabilityDetectionFunc(*u.stabilityDetection)
	case "threshold":
		if u.threshold == nil {
			return result, fmt.Errorf("field \"threshold\" is required")
		}
		return thresholdFunc(*u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return result, fmt.Errorf("field \"unionRange\" is required")
		}
		return unionRangeFunc(*u.unionRange)
	case "paddedRanges":
		if u.paddedRanges == nil {
			return result, fmt.Errorf("field \"paddedRanges\" is required")
		}
		return paddedRangesFunc(*u.paddedRanges)
	}
}

func (u *RangesNodeWithT[T]) DurationFilterNoopSuccess(DurationFilterRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) EnumEqualityNoopSuccess(EnumEqualityRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) EnumFilterNoopSuccess(EnumFilterRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) ExtremaNoopSuccess(ExtremaRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) IntersectRangeNoopSuccess(IntersectRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) LiteralRangesNoopSuccess(LiteralRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) MinMaxThresholdNoopSuccess(MinMaxThresholdRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) NotNoopSuccess(NotRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) OnChangeNoopSuccess(OnChangeRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) RangeNumericAggregationNoopSuccess(RangesNumericAggregationNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) SeriesCrossoverRangesNodeNoopSuccess(SeriesCrossoverRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) StaleRangeNoopSuccess(StaleRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) StabilityDetectionNoopSuccess(StabilityDetectionRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) ThresholdNoopSuccess(ThresholdingRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) UnionRangeNoopSuccess(UnionRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) PaddedRangesNoopSuccess(PaddedRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type RangesNodeVisitorWithT[T any] interface {
	VisitDurationFilter(ctx context.Context, v DurationFilterRangesNode) (T, error)
	VisitEnumEquality(ctx context.Context, v EnumEqualityRangesNode) (T, error)
	VisitEnumFilter(ctx context.Context, v EnumFilterRangesNode) (T, error)
	VisitExtrema(ctx context.Context, v ExtremaRangesNode) (T, error)
	VisitIntersectRange(ctx context.Context, v IntersectRangesNode) (T, error)
	VisitLiteralRanges(ctx context.Context, v LiteralRangesNode) (T, error)
	VisitMinMaxThreshold(ctx context.Context, v MinMaxThresholdRangesNode) (T, error)
	VisitNot(ctx context.Context, v NotRangesNode) (T, error)
	VisitOnChange(ctx context.Context, v OnChangeRangesNode) (T, error)
	VisitRangeNumericAggregation(ctx context.Context, v RangesNumericAggregationNode) (T, error)
	VisitSeriesCrossoverRangesNode(ctx context.Context, v SeriesCrossoverRangesNode) (T, error)
	VisitStaleRange(ctx context.Context, v StaleRangesNode) (T, error)
	VisitStabilityDetection(ctx context.Context, v StabilityDetectionRangesNode) (T, error)
	VisitThreshold(ctx context.Context, v ThresholdingRangesNode) (T, error)
	VisitUnionRange(ctx context.Context, v UnionRangesNode) (T, error)
	VisitPaddedRanges(ctx context.Context, v PaddedRangesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ResampleInterpolationConfigurationWithT[T any] ResampleInterpolationConfiguration

func (u *ResampleInterpolationConfigurationWithT[T]) Accept(ctx context.Context, v ResampleInterpolationConfigurationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return v.VisitForwardFillResampleInterpolationConfiguration(ctx, *u.forwardFillResampleInterpolationConfiguration)
	case "constantDefaultValueResampleInterpolationConfiguration":
		if u.constantDefaultValueResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"constantDefaultValueResampleInterpolationConfiguration\" is required")
		}
		return v.VisitConstantDefaultValueResampleInterpolationConfiguration(ctx, *u.constantDefaultValueResampleInterpolationConfiguration)
	}
}

func (u *ResampleInterpolationConfigurationWithT[T]) AcceptFuncs(forwardFillResampleInterpolationConfigurationFunc func(ForwardFillResampleInterpolationConfiguration) (T, error), constantDefaultValueResampleInterpolationConfigurationFunc func(ConstantDefaultValueResampleInterpolationConfiguration) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return forwardFillResampleInterpolationConfigurationFunc(*u.forwardFillResampleInterpolationConfiguration)
	case "constantDefaultValueResampleInterpolationConfiguration":
		if u.constantDefaultValueResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"constantDefaultValueResampleInterpolationConfiguration\" is required")
		}
		return constantDefaultValueResampleInterpolationConfigurationFunc(*u.constantDefaultValueResampleInterpolationConfiguration)
	}
}

func (u *ResampleInterpolationConfigurationWithT[T]) ForwardFillResampleInterpolationConfigurationNoopSuccess(ForwardFillResampleInterpolationConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *ResampleInterpolationConfigurationWithT[T]) ConstantDefaultValueResampleInterpolationConfigurationNoopSuccess(ConstantDefaultValueResampleInterpolationConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *ResampleInterpolationConfigurationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ResampleInterpolationConfigurationVisitorWithT[T any] interface {
	VisitForwardFillResampleInterpolationConfiguration(ctx context.Context, v ForwardFillResampleInterpolationConfiguration) (T, error)
	VisitConstantDefaultValueResampleInterpolationConfiguration(ctx context.Context, v ConstantDefaultValueResampleInterpolationConfiguration) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ResampleInterpolationConstantDefaultValueWithT[T any] ResampleInterpolationConstantDefaultValue

func (u *ResampleInterpolationConstantDefaultValueWithT[T]) Accept(ctx context.Context, v ResampleInterpolationConstantDefaultValueVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	}
}

func (u *ResampleInterpolationConstantDefaultValueWithT[T]) AcceptFuncs(numericFunc func(float64) (T, error), enumFunc func(string) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	}
}

func (u *ResampleInterpolationConstantDefaultValueWithT[T]) NumericNoopSuccess(float64) (T, error) {
	var result T
	return result, nil
}

func (u *ResampleInterpolationConstantDefaultValueWithT[T]) EnumNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *ResampleInterpolationConstantDefaultValueWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ResampleInterpolationConstantDefaultValueVisitorWithT[T any] interface {
	VisitNumeric(ctx context.Context, v float64) (T, error)
	VisitEnum(ctx context.Context, v string) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ResolvedNodeWithT[T any] ResolvedNode

func (u *ResolvedNodeWithT[T]) Accept(ctx context.Context, v ResolvedNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(ctx, *u.ranges)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(ctx, *u.series)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(ctx, *u.value)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(ctx, *u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return result, fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3d(ctx, *u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return result, fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequency(ctx, *u.frequency)
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return result, fmt.Errorf("field \"frequencyV2\" is required")
		}
		return v.VisitFrequencyV2(ctx, *u.frequencyV2)
	case "histogram":
		if u.histogram == nil {
			return result, fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogram(ctx, *u.histogram)
	case "curve":
		if u.curve == nil {
			return result, fmt.Errorf("field \"curve\" is required")
		}
		return v.VisitCurve(ctx, *u.curve)
	}
}

func (u *ResolvedNodeWithT[T]) AcceptFuncs(rangesFunc func(SummarizeRangesNode) (T, error), seriesFunc func(SummarizeSeriesNode) (T, error), valueFunc func(SelectValueNode) (T, error), cartesianFunc func(SummarizeCartesianNode) (T, error), cartesian3dFunc func(SummarizeCartesian3dNode) (T, error), frequencyFunc func(FrequencyDomainNode) (T, error), frequencyV2Func func(FrequencyDomainNodeV2) (T, error), histogramFunc func(HistogramNode) (T, error), curveFunc func(CurveFitNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return result, fmt.Errorf("field \"cartesian3d\" is required")
		}
		return cartesian3dFunc(*u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return result, fmt.Errorf("field \"frequency\" is required")
		}
		return frequencyFunc(*u.frequency)
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return result, fmt.Errorf("field \"frequencyV2\" is required")
		}
		return frequencyV2Func(*u.frequencyV2)
	case "histogram":
		if u.histogram == nil {
			return result, fmt.Errorf("field \"histogram\" is required")
		}
		return histogramFunc(*u.histogram)
	case "curve":
		if u.curve == nil {
			return result, fmt.Errorf("field \"curve\" is required")
		}
		return curveFunc(*u.curve)
	}
}

func (u *ResolvedNodeWithT[T]) RangesNoopSuccess(SummarizeRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *ResolvedNodeWithT[T]) SeriesNoopSuccess(SummarizeSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *ResolvedNodeWithT[T]) ValueNoopSuccess(SelectValueNode) (T, error) {
	var result T
	return result, nil
}

func (u *ResolvedNodeWithT[T]) CartesianNoopSuccess(SummarizeCartesianNode) (T, error) {
	var result T
	return result, nil
}

func (u *ResolvedNodeWithT[T]) Cartesian3dNoopSuccess(SummarizeCartesian3dNode) (T, error) {
	var result T
	return result, nil
}

func (u *ResolvedNodeWithT[T]) FrequencyNoopSuccess(FrequencyDomainNode) (T, error) {
	var result T
	return result, nil
}

func (u *ResolvedNodeWithT[T]) FrequencyV2NoopSuccess(FrequencyDomainNodeV2) (T, error) {
	var result T
	return result, nil
}

func (u *ResolvedNodeWithT[T]) HistogramNoopSuccess(HistogramNode) (T, error) {
	var result T
	return result, nil
}

func (u *ResolvedNodeWithT[T]) CurveNoopSuccess(CurveFitNode) (T, error) {
	var result T
	return result, nil
}

func (u *ResolvedNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ResolvedNodeVisitorWithT[T any] interface {
	VisitRanges(ctx context.Context, v SummarizeRangesNode) (T, error)
	VisitSeries(ctx context.Context, v SummarizeSeriesNode) (T, error)
	VisitValue(ctx context.Context, v SelectValueNode) (T, error)
	VisitCartesian(ctx context.Context, v SummarizeCartesianNode) (T, error)
	VisitCartesian3d(ctx context.Context, v SummarizeCartesian3dNode) (T, error)
	VisitFrequency(ctx context.Context, v FrequencyDomainNode) (T, error)
	VisitFrequencyV2(ctx context.Context, v FrequencyDomainNodeV2) (T, error)
	VisitHistogram(ctx context.Context, v HistogramNode) (T, error)
	VisitCurve(ctx context.Context, v CurveFitNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SelectValueNodeWithT[T any] SelectValueNode

func (u *SelectValueNodeWithT[T]) Accept(ctx context.Context, v SelectValueNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return result, fmt.Errorf("field \"firstPoint\" is required")
		}
		return v.VisitFirstPoint(ctx, *u.firstPoint)
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return result, fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return v.VisitFirstValuePoint(ctx, *u.firstValuePoint)
	case "firstRange":
		if u.firstRange == nil {
			return result, fmt.Errorf("field \"firstRange\" is required")
		}
		return v.VisitFirstRange(ctx, *u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return result, fmt.Errorf("field \"lastPoint\" is required")
		}
		return v.VisitLastPoint(ctx, *u.lastPoint)
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return result, fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return v.VisitLastValuePoint(ctx, *u.lastValuePoint)
	case "lastRange":
		if u.lastRange == nil {
			return result, fmt.Errorf("field \"lastRange\" is required")
		}
		return v.VisitLastRange(ctx, *u.lastRange)
	}
}

func (u *SelectValueNodeWithT[T]) AcceptFuncs(firstPointFunc func(SeriesNode) (T, error), firstValuePointFunc func(SeriesNode) (T, error), firstRangeFunc func(RangesNode) (T, error), lastPointFunc func(SeriesNode) (T, error), lastValuePointFunc func(SeriesNode) (T, error), lastRangeFunc func(RangesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return result, fmt.Errorf("field \"firstPoint\" is required")
		}
		return firstPointFunc(*u.firstPoint)
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return result, fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return firstValuePointFunc(*u.firstValuePoint)
	case "firstRange":
		if u.firstRange == nil {
			return result, fmt.Errorf("field \"firstRange\" is required")
		}
		return firstRangeFunc(*u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return result, fmt.Errorf("field \"lastPoint\" is required")
		}
		return lastPointFunc(*u.lastPoint)
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return result, fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return lastValuePointFunc(*u.lastValuePoint)
	case "lastRange":
		if u.lastRange == nil {
			return result, fmt.Errorf("field \"lastRange\" is required")
		}
		return lastRangeFunc(*u.lastRange)
	}
}

func (u *SelectValueNodeWithT[T]) FirstPointNoopSuccess(SeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueNodeWithT[T]) FirstValuePointNoopSuccess(SeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueNodeWithT[T]) FirstRangeNoopSuccess(RangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueNodeWithT[T]) LastPointNoopSuccess(SeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueNodeWithT[T]) LastValuePointNoopSuccess(SeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueNodeWithT[T]) LastRangeNoopSuccess(RangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SelectValueNodeVisitorWithT[T any] interface {
	VisitFirstPoint(ctx context.Context, v SeriesNode) (T, error)
	VisitFirstValuePoint(ctx context.Context, v SeriesNode) (T, error)
	VisitFirstRange(ctx context.Context, v RangesNode) (T, error)
	VisitLastPoint(ctx context.Context, v SeriesNode) (T, error)
	VisitLastValuePoint(ctx context.Context, v SeriesNode) (T, error)
	VisitLastRange(ctx context.Context, v RangesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SeriesNodeWithT[T any] SeriesNode

func (u *SeriesNodeWithT[T]) Accept(ctx context.Context, v SeriesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(ctx, *u.log)
	case "array":
		if u.array == nil {
			return result, fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(ctx, *u.array)
	case "struct":
		if u.struct_ == nil {
			return result, fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStruct(ctx, *u.struct_)
	}
}

func (u *SeriesNodeWithT[T]) AcceptFuncs(rawFunc func(RawUntypedSeriesNode) (T, error), enumFunc func(EnumSeriesNode) (T, error), numericFunc func(NumericSeriesNode) (T, error), logFunc func(LogSeriesNode) (T, error), arrayFunc func(ArraySeriesNode) (T, error), struct_Func func(StructSeriesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "array":
		if u.array == nil {
			return result, fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	case "struct":
		if u.struct_ == nil {
			return result, fmt.Errorf("field \"struct\" is required")
		}
		return struct_Func(*u.struct_)
	}
}

func (u *SeriesNodeWithT[T]) RawNoopSuccess(RawUntypedSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesNodeWithT[T]) EnumNoopSuccess(EnumSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesNodeWithT[T]) NumericNoopSuccess(NumericSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesNodeWithT[T]) LogNoopSuccess(LogSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesNodeWithT[T]) ArrayNoopSuccess(ArraySeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesNodeWithT[T]) StructNoopSuccess(StructSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SeriesNodeVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v RawUntypedSeriesNode) (T, error)
	VisitEnum(ctx context.Context, v EnumSeriesNode) (T, error)
	VisitNumeric(ctx context.Context, v NumericSeriesNode) (T, error)
	VisitLog(ctx context.Context, v LogSeriesNode) (T, error)
	VisitArray(ctx context.Context, v ArraySeriesNode) (T, error)
	VisitStruct(ctx context.Context, v StructSeriesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SignalFilterConfigurationWithT[T any] SignalFilterConfiguration

func (u *SignalFilterConfigurationWithT[T]) Accept(ctx context.Context, v SignalFilterConfigurationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return result, fmt.Errorf("field \"lowPass\" is required")
		}
		return v.VisitLowPass(ctx, *u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return result, fmt.Errorf("field \"highPass\" is required")
		}
		return v.VisitHighPass(ctx, *u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return result, fmt.Errorf("field \"bandPass\" is required")
		}
		return v.VisitBandPass(ctx, *u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return result, fmt.Errorf("field \"bandStop\" is required")
		}
		return v.VisitBandStop(ctx, *u.bandStop)
	}
}

func (u *SignalFilterConfigurationWithT[T]) AcceptFuncs(lowPassFunc func(LowPassConfiguration) (T, error), highPassFunc func(HighPassConfiguration) (T, error), bandPassFunc func(BandPassConfiguration) (T, error), bandStopFunc func(BandStopConfiguration) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return result, fmt.Errorf("field \"lowPass\" is required")
		}
		return lowPassFunc(*u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return result, fmt.Errorf("field \"highPass\" is required")
		}
		return highPassFunc(*u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return result, fmt.Errorf("field \"bandPass\" is required")
		}
		return bandPassFunc(*u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return result, fmt.Errorf("field \"bandStop\" is required")
		}
		return bandStopFunc(*u.bandStop)
	}
}

func (u *SignalFilterConfigurationWithT[T]) LowPassNoopSuccess(LowPassConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *SignalFilterConfigurationWithT[T]) HighPassNoopSuccess(HighPassConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *SignalFilterConfigurationWithT[T]) BandPassNoopSuccess(BandPassConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *SignalFilterConfigurationWithT[T]) BandStopNoopSuccess(BandStopConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *SignalFilterConfigurationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SignalFilterConfigurationVisitorWithT[T any] interface {
	VisitLowPass(ctx context.Context, v LowPassConfiguration) (T, error)
	VisitHighPass(ctx context.Context, v HighPassConfiguration) (T, error)
	VisitBandPass(ctx context.Context, v BandPassConfiguration) (T, error)
	VisitBandStop(ctx context.Context, v BandStopConfiguration) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type StorageLocatorWithT[T any] StorageLocator

func (u *StorageLocatorWithT[T]) Accept(ctx context.Context, v StorageLocatorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "nominal":
		if u.nominal == nil {
			return result, fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominal(ctx, *u.nominal)
	case "external":
		if u.external == nil {
			return result, fmt.Errorf("field \"external\" is required")
		}
		return v.VisitExternal(ctx, *u.external)
	}
}

func (u *StorageLocatorWithT[T]) AcceptFuncs(nominalFunc func(NominalStorageLocator) (T, error), externalFunc func(api.LogicalSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "nominal":
		if u.nominal == nil {
			return result, fmt.Errorf("field \"nominal\" is required")
		}
		return nominalFunc(*u.nominal)
	case "external":
		if u.external == nil {
			return result, fmt.Errorf("field \"external\" is required")
		}
		return externalFunc(*u.external)
	}
}

func (u *StorageLocatorWithT[T]) NominalNoopSuccess(NominalStorageLocator) (T, error) {
	var result T
	return result, nil
}

func (u *StorageLocatorWithT[T]) ExternalNoopSuccess(api.LogicalSeries) (T, error) {
	var result T
	return result, nil
}

func (u *StorageLocatorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type StorageLocatorVisitorWithT[T any] interface {
	VisitNominal(ctx context.Context, v NominalStorageLocator) (T, error)
	VisitExternal(ctx context.Context, v api.LogicalSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type StructSeriesNodeWithT[T any] StructSeriesNode

func (u *StructSeriesNodeWithT[T]) Accept(ctx context.Context, v StructSeriesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(ctx, *u.extractFromStruct)
	}
}

func (u *StructSeriesNodeWithT[T]) AcceptFuncs(rawFunc func(ResolvedSeries) (T, error), extractFromStructFunc func(ExtractStructFromStructSeriesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	}
}

func (u *StructSeriesNodeWithT[T]) RawNoopSuccess(ResolvedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *StructSeriesNodeWithT[T]) ExtractFromStructNoopSuccess(ExtractStructFromStructSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *StructSeriesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type StructSeriesNodeVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v ResolvedSeries) (T, error)
	VisitExtractFromStruct(ctx context.Context, v ExtractStructFromStructSeriesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TagFiltersWithT[T any] TagFilters

func (u *TagFiltersWithT[T]) Accept(ctx context.Context, v TagFiltersVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(ctx, *u.single)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	}
}

func (u *TagFiltersWithT[T]) AcceptFuncs(singleFunc func(TagFilter) (T, error), andFunc func([]TagFilters) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	}
}

func (u *TagFiltersWithT[T]) SingleNoopSuccess(TagFilter) (T, error) {
	var result T
	return result, nil
}

func (u *TagFiltersWithT[T]) AndNoopSuccess([]TagFilters) (T, error) {
	var result T
	return result, nil
}

func (u *TagFiltersWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TagFiltersVisitorWithT[T any] interface {
	VisitSingle(ctx context.Context, v TagFilter) (T, error)
	VisitAnd(ctx context.Context, v []TagFilters) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ThresholdWithT[T any] Threshold

func (u *ThresholdWithT[T]) Accept(ctx context.Context, v ThresholdVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "absolute":
		if u.absolute == nil {
			return result, fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsolute(ctx, *u.absolute)
	case "percentage":
		if u.percentage == nil {
			return result, fmt.Errorf("field \"percentage\" is required")
		}
		return v.VisitPercentage(ctx, *u.percentage)
	}
}

func (u *ThresholdWithT[T]) AcceptFuncs(absoluteFunc func(AbsoluteThreshold) (T, error), percentageFunc func(PercentageThreshold) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "absolute":
		if u.absolute == nil {
			return result, fmt.Errorf("field \"absolute\" is required")
		}
		return absoluteFunc(*u.absolute)
	case "percentage":
		if u.percentage == nil {
			return result, fmt.Errorf("field \"percentage\" is required")
		}
		return percentageFunc(*u.percentage)
	}
}

func (u *ThresholdWithT[T]) AbsoluteNoopSuccess(AbsoluteThreshold) (T, error) {
	var result T
	return result, nil
}

func (u *ThresholdWithT[T]) PercentageNoopSuccess(PercentageThreshold) (T, error) {
	var result T
	return result, nil
}

func (u *ThresholdWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ThresholdVisitorWithT[T any] interface {
	VisitAbsolute(ctx context.Context, v AbsoluteThreshold) (T, error)
	VisitPercentage(ctx context.Context, v PercentageThreshold) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
