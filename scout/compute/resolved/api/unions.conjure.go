// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/timeseries/logicalseries/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type ArraySeriesNode struct {
	typ       string
	numeric1d *NumericArraySeriesNode
	enum1d    *EnumArraySeriesNode
}

type arraySeriesNodeDeserializer struct {
	Type      string                  `json:"type"`
	Numeric1d *NumericArraySeriesNode `json:"numeric1d"`
	Enum1d    *EnumArraySeriesNode    `json:"enum1d"`
}

func (u *arraySeriesNodeDeserializer) toStruct() ArraySeriesNode {
	return ArraySeriesNode{typ: u.Type, numeric1d: u.Numeric1d, enum1d: u.Enum1d}
}

func (u *ArraySeriesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return nil, fmt.Errorf("field \"numeric1d\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			Numeric1d NumericArraySeriesNode `json:"numeric1d"`
		}{Type: "numeric1d", Numeric1d: *u.numeric1d}, nil
	case "enum1d":
		if u.enum1d == nil {
			return nil, fmt.Errorf("field \"enum1d\" is required")
		}
		return struct {
			Type   string              `json:"type"`
			Enum1d EnumArraySeriesNode `json:"enum1d"`
		}{Type: "enum1d", Enum1d: *u.enum1d}, nil
	}
}

func (u ArraySeriesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ArraySeriesNode) UnmarshalJSON(data []byte) error {
	var deser arraySeriesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
	}
	return nil
}

func (u ArraySeriesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ArraySeriesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ArraySeriesNode) AcceptFuncs(numeric1dFunc func(NumericArraySeriesNode) error, enum1dFunc func(EnumArraySeriesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
		return numeric1dFunc(*u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
		return enum1dFunc(*u.enum1d)
	}
}

func (u *ArraySeriesNode) Numeric1dNoopSuccess(NumericArraySeriesNode) error {
	return nil
}

func (u *ArraySeriesNode) Enum1dNoopSuccess(EnumArraySeriesNode) error {
	return nil
}

func (u *ArraySeriesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ArraySeriesNode) Accept(v ArraySeriesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
		return v.VisitNumeric1d(*u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
		return v.VisitEnum1d(*u.enum1d)
	}
}

type ArraySeriesNodeVisitor interface {
	VisitNumeric1d(v NumericArraySeriesNode) error
	VisitEnum1d(v EnumArraySeriesNode) error
	VisitUnknown(typeName string) error
}

func (u *ArraySeriesNode) AcceptWithContext(ctx context.Context, v ArraySeriesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
		return v.VisitNumeric1dWithContext(ctx, *u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
		return v.VisitEnum1dWithContext(ctx, *u.enum1d)
	}
}

type ArraySeriesNodeVisitorWithContext interface {
	VisitNumeric1dWithContext(ctx context.Context, v NumericArraySeriesNode) error
	VisitEnum1dWithContext(ctx context.Context, v EnumArraySeriesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewArraySeriesNodeFromNumeric1d(v NumericArraySeriesNode) ArraySeriesNode {
	return ArraySeriesNode{typ: "numeric1d", numeric1d: &v}
}

func NewArraySeriesNodeFromEnum1d(v EnumArraySeriesNode) ArraySeriesNode {
	return ArraySeriesNode{typ: "enum1d", enum1d: &v}
}

type Cartesian3dNode struct {
	typ       string
	scatter3d *Scatter3dNode
}

type cartesian3dNodeDeserializer struct {
	Type      string         `json:"type"`
	Scatter3d *Scatter3dNode `json:"scatter3d"`
}

func (u *cartesian3dNodeDeserializer) toStruct() Cartesian3dNode {
	return Cartesian3dNode{typ: u.Type, scatter3d: u.Scatter3d}
}

func (u *Cartesian3dNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return nil, fmt.Errorf("field \"scatter3d\" is required")
		}
		return struct {
			Type      string        `json:"type"`
			Scatter3d Scatter3dNode `json:"scatter3d"`
		}{Type: "scatter3d", Scatter3d: *u.scatter3d}, nil
	}
}

func (u Cartesian3dNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Cartesian3dNode) UnmarshalJSON(data []byte) error {
	var deser cartesian3dNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
	}
	return nil
}

func (u Cartesian3dNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Cartesian3dNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Cartesian3dNode) AcceptFuncs(scatter3dFunc func(Scatter3dNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return scatter3dFunc(*u.scatter3d)
	}
}

func (u *Cartesian3dNode) Scatter3dNoopSuccess(Scatter3dNode) error {
	return nil
}

func (u *Cartesian3dNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Cartesian3dNode) Accept(v Cartesian3dNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3d(*u.scatter3d)
	}
}

type Cartesian3dNodeVisitor interface {
	VisitScatter3d(v Scatter3dNode) error
	VisitUnknown(typeName string) error
}

func (u *Cartesian3dNode) AcceptWithContext(ctx context.Context, v Cartesian3dNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3dWithContext(ctx, *u.scatter3d)
	}
}

type Cartesian3dNodeVisitorWithContext interface {
	VisitScatter3dWithContext(ctx context.Context, v Scatter3dNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCartesian3dNodeFromScatter3d(v Scatter3dNode) Cartesian3dNode {
	return Cartesian3dNode{typ: "scatter3d", scatter3d: &v}
}

type CartesianNode struct {
	typ     string
	scatter *ScatterNode
}

type cartesianNodeDeserializer struct {
	Type    string       `json:"type"`
	Scatter *ScatterNode `json:"scatter"`
}

func (u *cartesianNodeDeserializer) toStruct() CartesianNode {
	return CartesianNode{typ: u.Type, scatter: u.Scatter}
}

func (u *CartesianNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "scatter":
		if u.scatter == nil {
			return nil, fmt.Errorf("field \"scatter\" is required")
		}
		return struct {
			Type    string      `json:"type"`
			Scatter ScatterNode `json:"scatter"`
		}{Type: "scatter", Scatter: *u.scatter}, nil
	}
}

func (u CartesianNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CartesianNode) UnmarshalJSON(data []byte) error {
	var deser cartesianNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
	}
	return nil
}

func (u CartesianNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CartesianNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CartesianNode) AcceptFuncs(scatterFunc func(ScatterNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *CartesianNode) ScatterNoopSuccess(ScatterNode) error {
	return nil
}

func (u *CartesianNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CartesianNode) Accept(v CartesianNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(*u.scatter)
	}
}

type CartesianNodeVisitor interface {
	VisitScatter(v ScatterNode) error
	VisitUnknown(typeName string) error
}

func (u *CartesianNode) AcceptWithContext(ctx context.Context, v CartesianNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatterWithContext(ctx, *u.scatter)
	}
}

type CartesianNodeVisitorWithContext interface {
	VisitScatterWithContext(ctx context.Context, v ScatterNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCartesianNodeFromScatter(v ScatterNode) CartesianNode {
	return CartesianNode{typ: "scatter", scatter: &v}
}

type CurveFitDetails struct {
	typ         string
	exponential *ExponentialCurve
	logarithmic *LogarithmicCurve
	polynomial  *PolynomialCurve
	power       *PowerCurve
}

type curveFitDetailsDeserializer struct {
	Type        string            `json:"type"`
	Exponential *ExponentialCurve `json:"exponential"`
	Logarithmic *LogarithmicCurve `json:"logarithmic"`
	Polynomial  *PolynomialCurve  `json:"polynomial"`
	Power       *PowerCurve       `json:"power"`
}

func (u *curveFitDetailsDeserializer) toStruct() CurveFitDetails {
	return CurveFitDetails{typ: u.Type, exponential: u.Exponential, logarithmic: u.Logarithmic, polynomial: u.Polynomial, power: u.Power}
}

func (u *CurveFitDetails) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "exponential":
		if u.exponential == nil {
			return nil, fmt.Errorf("field \"exponential\" is required")
		}
		return struct {
			Type        string           `json:"type"`
			Exponential ExponentialCurve `json:"exponential"`
		}{Type: "exponential", Exponential: *u.exponential}, nil
	case "logarithmic":
		if u.logarithmic == nil {
			return nil, fmt.Errorf("field \"logarithmic\" is required")
		}
		return struct {
			Type        string           `json:"type"`
			Logarithmic LogarithmicCurve `json:"logarithmic"`
		}{Type: "logarithmic", Logarithmic: *u.logarithmic}, nil
	case "polynomial":
		if u.polynomial == nil {
			return nil, fmt.Errorf("field \"polynomial\" is required")
		}
		return struct {
			Type       string          `json:"type"`
			Polynomial PolynomialCurve `json:"polynomial"`
		}{Type: "polynomial", Polynomial: *u.polynomial}, nil
	case "power":
		if u.power == nil {
			return nil, fmt.Errorf("field \"power\" is required")
		}
		return struct {
			Type  string     `json:"type"`
			Power PowerCurve `json:"power"`
		}{Type: "power", Power: *u.power}, nil
	}
}

func (u CurveFitDetails) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CurveFitDetails) UnmarshalJSON(data []byte) error {
	var deser curveFitDetailsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
	}
	return nil
}

func (u CurveFitDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CurveFitDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CurveFitDetails) AcceptFuncs(exponentialFunc func(ExponentialCurve) error, logarithmicFunc func(LogarithmicCurve) error, polynomialFunc func(PolynomialCurve) error, powerFunc func(PowerCurve) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return exponentialFunc(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return logarithmicFunc(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return polynomialFunc(*u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return powerFunc(*u.power)
	}
}

func (u *CurveFitDetails) ExponentialNoopSuccess(ExponentialCurve) error {
	return nil
}

func (u *CurveFitDetails) LogarithmicNoopSuccess(LogarithmicCurve) error {
	return nil
}

func (u *CurveFitDetails) PolynomialNoopSuccess(PolynomialCurve) error {
	return nil
}

func (u *CurveFitDetails) PowerNoopSuccess(PowerCurve) error {
	return nil
}

func (u *CurveFitDetails) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CurveFitDetails) Accept(v CurveFitDetailsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponential(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmic(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomial(*u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPower(*u.power)
	}
}

type CurveFitDetailsVisitor interface {
	VisitExponential(v ExponentialCurve) error
	VisitLogarithmic(v LogarithmicCurve) error
	VisitPolynomial(v PolynomialCurve) error
	VisitPower(v PowerCurve) error
	VisitUnknown(typeName string) error
}

func (u *CurveFitDetails) AcceptWithContext(ctx context.Context, v CurveFitDetailsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponentialWithContext(ctx, *u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmicWithContext(ctx, *u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomialWithContext(ctx, *u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPowerWithContext(ctx, *u.power)
	}
}

type CurveFitDetailsVisitorWithContext interface {
	VisitExponentialWithContext(ctx context.Context, v ExponentialCurve) error
	VisitLogarithmicWithContext(ctx context.Context, v LogarithmicCurve) error
	VisitPolynomialWithContext(ctx context.Context, v PolynomialCurve) error
	VisitPowerWithContext(ctx context.Context, v PowerCurve) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCurveFitDetailsFromExponential(v ExponentialCurve) CurveFitDetails {
	return CurveFitDetails{typ: "exponential", exponential: &v}
}

func NewCurveFitDetailsFromLogarithmic(v LogarithmicCurve) CurveFitDetails {
	return CurveFitDetails{typ: "logarithmic", logarithmic: &v}
}

func NewCurveFitDetailsFromPolynomial(v PolynomialCurve) CurveFitDetails {
	return CurveFitDetails{typ: "polynomial", polynomial: &v}
}

func NewCurveFitDetailsFromPower(v PowerCurve) CurveFitDetails {
	return CurveFitDetails{typ: "power", power: &v}
}

type CurveFitPlotTypeNode struct {
	typ        string
	timeSeries *TimeSeriesCurveFitNode
	scatter    *ScatterCurveFitNode
}

type curveFitPlotTypeNodeDeserializer struct {
	Type       string                  `json:"type"`
	TimeSeries *TimeSeriesCurveFitNode `json:"timeSeries"`
	Scatter    *ScatterCurveFitNode    `json:"scatter"`
}

func (u *curveFitPlotTypeNodeDeserializer) toStruct() CurveFitPlotTypeNode {
	return CurveFitPlotTypeNode{typ: u.Type, timeSeries: u.TimeSeries, scatter: u.Scatter}
}

func (u *CurveFitPlotTypeNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return nil, fmt.Errorf("field \"timeSeries\" is required")
		}
		return struct {
			Type       string                 `json:"type"`
			TimeSeries TimeSeriesCurveFitNode `json:"timeSeries"`
		}{Type: "timeSeries", TimeSeries: *u.timeSeries}, nil
	case "scatter":
		if u.scatter == nil {
			return nil, fmt.Errorf("field \"scatter\" is required")
		}
		return struct {
			Type    string              `json:"type"`
			Scatter ScatterCurveFitNode `json:"scatter"`
		}{Type: "scatter", Scatter: *u.scatter}, nil
	}
}

func (u CurveFitPlotTypeNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CurveFitPlotTypeNode) UnmarshalJSON(data []byte) error {
	var deser curveFitPlotTypeNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
	}
	return nil
}

func (u CurveFitPlotTypeNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CurveFitPlotTypeNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CurveFitPlotTypeNode) AcceptFuncs(timeSeriesFunc func(TimeSeriesCurveFitNode) error, scatterFunc func(ScatterCurveFitNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return timeSeriesFunc(*u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *CurveFitPlotTypeNode) TimeSeriesNoopSuccess(TimeSeriesCurveFitNode) error {
	return nil
}

func (u *CurveFitPlotTypeNode) ScatterNoopSuccess(ScatterCurveFitNode) error {
	return nil
}

func (u *CurveFitPlotTypeNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CurveFitPlotTypeNode) Accept(v CurveFitPlotTypeNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeries(*u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(*u.scatter)
	}
}

type CurveFitPlotTypeNodeVisitor interface {
	VisitTimeSeries(v TimeSeriesCurveFitNode) error
	VisitScatter(v ScatterCurveFitNode) error
	VisitUnknown(typeName string) error
}

func (u *CurveFitPlotTypeNode) AcceptWithContext(ctx context.Context, v CurveFitPlotTypeNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeriesWithContext(ctx, *u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatterWithContext(ctx, *u.scatter)
	}
}

type CurveFitPlotTypeNodeVisitorWithContext interface {
	VisitTimeSeriesWithContext(ctx context.Context, v TimeSeriesCurveFitNode) error
	VisitScatterWithContext(ctx context.Context, v ScatterCurveFitNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCurveFitPlotTypeNodeFromTimeSeries(v TimeSeriesCurveFitNode) CurveFitPlotTypeNode {
	return CurveFitPlotTypeNode{typ: "timeSeries", timeSeries: &v}
}

func NewCurveFitPlotTypeNodeFromScatter(v ScatterCurveFitNode) CurveFitPlotTypeNode {
	return CurveFitPlotTypeNode{typ: "scatter", scatter: &v}
}

type EnumArraySeriesNode struct {
	typ string
	raw *ResolvedSeries
}

type enumArraySeriesNodeDeserializer struct {
	Type string          `json:"type"`
	Raw  *ResolvedSeries `json:"raw"`
}

func (u *enumArraySeriesNodeDeserializer) toStruct() EnumArraySeriesNode {
	return EnumArraySeriesNode{typ: u.Type, raw: u.Raw}
}

func (u *EnumArraySeriesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string         `json:"type"`
			Raw  ResolvedSeries `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u EnumArraySeriesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumArraySeriesNode) UnmarshalJSON(data []byte) error {
	var deser enumArraySeriesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u EnumArraySeriesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumArraySeriesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumArraySeriesNode) AcceptFuncs(rawFunc func(ResolvedSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *EnumArraySeriesNode) RawNoopSuccess(ResolvedSeries) error {
	return nil
}

func (u *EnumArraySeriesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumArraySeriesNode) Accept(v EnumArraySeriesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type EnumArraySeriesNodeVisitor interface {
	VisitRaw(v ResolvedSeries) error
	VisitUnknown(typeName string) error
}

func (u *EnumArraySeriesNode) AcceptWithContext(ctx context.Context, v EnumArraySeriesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type EnumArraySeriesNodeVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v ResolvedSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumArraySeriesNodeFromRaw(v ResolvedSeries) EnumArraySeriesNode {
	return EnumArraySeriesNode{typ: "raw", raw: &v}
}

type EnumSeriesNode struct {
	typ                  string
	raw                  *RawEnumSeriesNode
	resample             *EnumResampleSeriesNode
	timeRangeFilter      *EnumTimeRangeFilterSeriesNode
	timeShift            *EnumTimeShiftSeriesNode
	union                *EnumUnionSeriesNode
	aggregate            *AggregateEnumSeriesNode
	filterTransformation *EnumFilterTransformationSeriesNode
	valueMap             *ValueMapSeriesNode
	arraySelect          *SelectIndexFromEnumArraySeriesNode
	extractFromStruct    *ExtractEnumFromStructSeriesNode
	eventAggregation     *EventsEnumSeriesNode
}

type enumSeriesNodeDeserializer struct {
	Type                 string                              `json:"type"`
	Raw                  *RawEnumSeriesNode                  `json:"raw"`
	Resample             *EnumResampleSeriesNode             `json:"resample"`
	TimeRangeFilter      *EnumTimeRangeFilterSeriesNode      `json:"timeRangeFilter"`
	TimeShift            *EnumTimeShiftSeriesNode            `json:"timeShift"`
	Union                *EnumUnionSeriesNode                `json:"union"`
	Aggregate            *AggregateEnumSeriesNode            `json:"aggregate"`
	FilterTransformation *EnumFilterTransformationSeriesNode `json:"filterTransformation"`
	ValueMap             *ValueMapSeriesNode                 `json:"valueMap"`
	ArraySelect          *SelectIndexFromEnumArraySeriesNode `json:"arraySelect"`
	ExtractFromStruct    *ExtractEnumFromStructSeriesNode    `json:"extractFromStruct"`
	EventAggregation     *EventsEnumSeriesNode               `json:"eventAggregation"`
}

func (u *enumSeriesNodeDeserializer) toStruct() EnumSeriesNode {
	return EnumSeriesNode{typ: u.Type, raw: u.Raw, resample: u.Resample, timeRangeFilter: u.TimeRangeFilter, timeShift: u.TimeShift, union: u.Union, aggregate: u.Aggregate, filterTransformation: u.FilterTransformation, valueMap: u.ValueMap, arraySelect: u.ArraySelect, extractFromStruct: u.ExtractFromStruct, eventAggregation: u.EventAggregation}
}

func (u *EnumSeriesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string            `json:"type"`
			Raw  RawEnumSeriesNode `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "resample":
		if u.resample == nil {
			return nil, fmt.Errorf("field \"resample\" is required")
		}
		return struct {
			Type     string                 `json:"type"`
			Resample EnumResampleSeriesNode `json:"resample"`
		}{Type: "resample", Resample: *u.resample}, nil
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return nil, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return struct {
			Type            string                        `json:"type"`
			TimeRangeFilter EnumTimeRangeFilterSeriesNode `json:"timeRangeFilter"`
		}{Type: "timeRangeFilter", TimeRangeFilter: *u.timeRangeFilter}, nil
	case "timeShift":
		if u.timeShift == nil {
			return nil, fmt.Errorf("field \"timeShift\" is required")
		}
		return struct {
			Type      string                  `json:"type"`
			TimeShift EnumTimeShiftSeriesNode `json:"timeShift"`
		}{Type: "timeShift", TimeShift: *u.timeShift}, nil
	case "union":
		if u.union == nil {
			return nil, fmt.Errorf("field \"union\" is required")
		}
		return struct {
			Type  string              `json:"type"`
			Union EnumUnionSeriesNode `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	case "aggregate":
		if u.aggregate == nil {
			return nil, fmt.Errorf("field \"aggregate\" is required")
		}
		return struct {
			Type      string                  `json:"type"`
			Aggregate AggregateEnumSeriesNode `json:"aggregate"`
		}{Type: "aggregate", Aggregate: *u.aggregate}, nil
	case "filterTransformation":
		if u.filterTransformation == nil {
			return nil, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return struct {
			Type                 string                             `json:"type"`
			FilterTransformation EnumFilterTransformationSeriesNode `json:"filterTransformation"`
		}{Type: "filterTransformation", FilterTransformation: *u.filterTransformation}, nil
	case "valueMap":
		if u.valueMap == nil {
			return nil, fmt.Errorf("field \"valueMap\" is required")
		}
		return struct {
			Type     string             `json:"type"`
			ValueMap ValueMapSeriesNode `json:"valueMap"`
		}{Type: "valueMap", ValueMap: *u.valueMap}, nil
	case "arraySelect":
		if u.arraySelect == nil {
			return nil, fmt.Errorf("field \"arraySelect\" is required")
		}
		return struct {
			Type        string                             `json:"type"`
			ArraySelect SelectIndexFromEnumArraySeriesNode `json:"arraySelect"`
		}{Type: "arraySelect", ArraySelect: *u.arraySelect}, nil
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return nil, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return struct {
			Type              string                          `json:"type"`
			ExtractFromStruct ExtractEnumFromStructSeriesNode `json:"extractFromStruct"`
		}{Type: "extractFromStruct", ExtractFromStruct: *u.extractFromStruct}, nil
	case "eventAggregation":
		if u.eventAggregation == nil {
			return nil, fmt.Errorf("field \"eventAggregation\" is required")
		}
		return struct {
			Type             string               `json:"type"`
			EventAggregation EventsEnumSeriesNode `json:"eventAggregation"`
		}{Type: "eventAggregation", EventAggregation: *u.eventAggregation}, nil
	}
}

func (u EnumSeriesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumSeriesNode) UnmarshalJSON(data []byte) error {
	var deser enumSeriesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
	case "arraySelect":
		if u.arraySelect == nil {
			return fmt.Errorf("field \"arraySelect\" is required")
		}
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
	case "eventAggregation":
		if u.eventAggregation == nil {
			return fmt.Errorf("field \"eventAggregation\" is required")
		}
	}
	return nil
}

func (u EnumSeriesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumSeriesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumSeriesNode) AcceptFuncs(rawFunc func(RawEnumSeriesNode) error, resampleFunc func(EnumResampleSeriesNode) error, timeRangeFilterFunc func(EnumTimeRangeFilterSeriesNode) error, timeShiftFunc func(EnumTimeShiftSeriesNode) error, unionFunc func(EnumUnionSeriesNode) error, aggregateFunc func(AggregateEnumSeriesNode) error, filterTransformationFunc func(EnumFilterTransformationSeriesNode) error, valueMapFunc func(ValueMapSeriesNode) error, arraySelectFunc func(SelectIndexFromEnumArraySeriesNode) error, extractFromStructFunc func(ExtractEnumFromStructSeriesNode) error, eventAggregationFunc func(EventsEnumSeriesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return resampleFunc(*u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return aggregateFunc(*u.aggregate)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return filterTransformationFunc(*u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
		return valueMapFunc(*u.valueMap)
	case "arraySelect":
		if u.arraySelect == nil {
			return fmt.Errorf("field \"arraySelect\" is required")
		}
		return arraySelectFunc(*u.arraySelect)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	case "eventAggregation":
		if u.eventAggregation == nil {
			return fmt.Errorf("field \"eventAggregation\" is required")
		}
		return eventAggregationFunc(*u.eventAggregation)
	}
}

func (u *EnumSeriesNode) RawNoopSuccess(RawEnumSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) ResampleNoopSuccess(EnumResampleSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) TimeRangeFilterNoopSuccess(EnumTimeRangeFilterSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) TimeShiftNoopSuccess(EnumTimeShiftSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) UnionNoopSuccess(EnumUnionSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) AggregateNoopSuccess(AggregateEnumSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) FilterTransformationNoopSuccess(EnumFilterTransformationSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) ValueMapNoopSuccess(ValueMapSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) ArraySelectNoopSuccess(SelectIndexFromEnumArraySeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) ExtractFromStructNoopSuccess(ExtractEnumFromStructSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) EventAggregationNoopSuccess(EventsEnumSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumSeriesNode) Accept(v EnumSeriesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResample(*u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(*u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregate(*u.aggregate)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformation(*u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
		return v.VisitValueMap(*u.valueMap)
	case "arraySelect":
		if u.arraySelect == nil {
			return fmt.Errorf("field \"arraySelect\" is required")
		}
		return v.VisitArraySelect(*u.arraySelect)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(*u.extractFromStruct)
	case "eventAggregation":
		if u.eventAggregation == nil {
			return fmt.Errorf("field \"eventAggregation\" is required")
		}
		return v.VisitEventAggregation(*u.eventAggregation)
	}
}

type EnumSeriesNodeVisitor interface {
	VisitRaw(v RawEnumSeriesNode) error
	VisitResample(v EnumResampleSeriesNode) error
	VisitTimeRangeFilter(v EnumTimeRangeFilterSeriesNode) error
	VisitTimeShift(v EnumTimeShiftSeriesNode) error
	VisitUnion(v EnumUnionSeriesNode) error
	VisitAggregate(v AggregateEnumSeriesNode) error
	VisitFilterTransformation(v EnumFilterTransformationSeriesNode) error
	VisitValueMap(v ValueMapSeriesNode) error
	VisitArraySelect(v SelectIndexFromEnumArraySeriesNode) error
	VisitExtractFromStruct(v ExtractEnumFromStructSeriesNode) error
	VisitEventAggregation(v EventsEnumSeriesNode) error
	VisitUnknown(typeName string) error
}

func (u *EnumSeriesNode) AcceptWithContext(ctx context.Context, v EnumSeriesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResampleWithContext(ctx, *u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilterWithContext(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShiftWithContext(ctx, *u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregateWithContext(ctx, *u.aggregate)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformationWithContext(ctx, *u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
		return v.VisitValueMapWithContext(ctx, *u.valueMap)
	case "arraySelect":
		if u.arraySelect == nil {
			return fmt.Errorf("field \"arraySelect\" is required")
		}
		return v.VisitArraySelectWithContext(ctx, *u.arraySelect)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStructWithContext(ctx, *u.extractFromStruct)
	case "eventAggregation":
		if u.eventAggregation == nil {
			return fmt.Errorf("field \"eventAggregation\" is required")
		}
		return v.VisitEventAggregationWithContext(ctx, *u.eventAggregation)
	}
}

type EnumSeriesNodeVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v RawEnumSeriesNode) error
	VisitResampleWithContext(ctx context.Context, v EnumResampleSeriesNode) error
	VisitTimeRangeFilterWithContext(ctx context.Context, v EnumTimeRangeFilterSeriesNode) error
	VisitTimeShiftWithContext(ctx context.Context, v EnumTimeShiftSeriesNode) error
	VisitUnionWithContext(ctx context.Context, v EnumUnionSeriesNode) error
	VisitAggregateWithContext(ctx context.Context, v AggregateEnumSeriesNode) error
	VisitFilterTransformationWithContext(ctx context.Context, v EnumFilterTransformationSeriesNode) error
	VisitValueMapWithContext(ctx context.Context, v ValueMapSeriesNode) error
	VisitArraySelectWithContext(ctx context.Context, v SelectIndexFromEnumArraySeriesNode) error
	VisitExtractFromStructWithContext(ctx context.Context, v ExtractEnumFromStructSeriesNode) error
	VisitEventAggregationWithContext(ctx context.Context, v EventsEnumSeriesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumSeriesNodeFromRaw(v RawEnumSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "raw", raw: &v}
}

func NewEnumSeriesNodeFromResample(v EnumResampleSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "resample", resample: &v}
}

func NewEnumSeriesNodeFromTimeRangeFilter(v EnumTimeRangeFilterSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "timeRangeFilter", timeRangeFilter: &v}
}

func NewEnumSeriesNodeFromTimeShift(v EnumTimeShiftSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "timeShift", timeShift: &v}
}

func NewEnumSeriesNodeFromUnion(v EnumUnionSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "union", union: &v}
}

func NewEnumSeriesNodeFromAggregate(v AggregateEnumSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "aggregate", aggregate: &v}
}

func NewEnumSeriesNodeFromFilterTransformation(v EnumFilterTransformationSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "filterTransformation", filterTransformation: &v}
}

func NewEnumSeriesNodeFromValueMap(v ValueMapSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "valueMap", valueMap: &v}
}

func NewEnumSeriesNodeFromArraySelect(v SelectIndexFromEnumArraySeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "arraySelect", arraySelect: &v}
}

func NewEnumSeriesNodeFromExtractFromStruct(v ExtractEnumFromStructSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "extractFromStruct", extractFromStruct: &v}
}

func NewEnumSeriesNodeFromEventAggregation(v EventsEnumSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "eventAggregation", eventAggregation: &v}
}

type EventsEnumValueSource struct {
	typ      string
	property *string
	level    *api.Empty
}

type eventsEnumValueSourceDeserializer struct {
	Type     string     `json:"type"`
	Property *string    `json:"property"`
	Level    *api.Empty `json:"level"`
}

func (u *eventsEnumValueSourceDeserializer) toStruct() EventsEnumValueSource {
	return EventsEnumValueSource{typ: u.Type, property: u.Property, level: u.Level}
}

func (u *EventsEnumValueSource) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string `json:"type"`
			Property string `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "level":
		if u.level == nil {
			return nil, fmt.Errorf("field \"level\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Level api.Empty `json:"level"`
		}{Type: "level", Level: *u.level}, nil
	}
}

func (u EventsEnumValueSource) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EventsEnumValueSource) UnmarshalJSON(data []byte) error {
	var deser eventsEnumValueSourceDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "level":
		if u.level == nil {
			return fmt.Errorf("field \"level\" is required")
		}
	}
	return nil
}

func (u EventsEnumValueSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EventsEnumValueSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EventsEnumValueSource) AcceptFuncs(propertyFunc func(string) error, levelFunc func(api.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "level":
		if u.level == nil {
			return fmt.Errorf("field \"level\" is required")
		}
		return levelFunc(*u.level)
	}
}

func (u *EventsEnumValueSource) PropertyNoopSuccess(string) error {
	return nil
}

func (u *EventsEnumValueSource) LevelNoopSuccess(api.Empty) error {
	return nil
}

func (u *EventsEnumValueSource) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EventsEnumValueSource) Accept(v EventsEnumValueSourceVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "level":
		if u.level == nil {
			return fmt.Errorf("field \"level\" is required")
		}
		return v.VisitLevel(*u.level)
	}
}

type EventsEnumValueSourceVisitor interface {
	VisitProperty(v string) error
	VisitLevel(v api.Empty) error
	VisitUnknown(typeName string) error
}

func (u *EventsEnumValueSource) AcceptWithContext(ctx context.Context, v EventsEnumValueSourceVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "level":
		if u.level == nil {
			return fmt.Errorf("field \"level\" is required")
		}
		return v.VisitLevelWithContext(ctx, *u.level)
	}
}

type EventsEnumValueSourceVisitorWithContext interface {
	VisitPropertyWithContext(ctx context.Context, v string) error
	VisitLevelWithContext(ctx context.Context, v api.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEventsEnumValueSourceFromProperty(v string) EventsEnumValueSource {
	return EventsEnumValueSource{typ: "property", property: &v}
}

func NewEventsEnumValueSourceFromLevel(v api.Empty) EventsEnumValueSource {
	return EventsEnumValueSource{typ: "level", level: &v}
}

type FrequencyDomainNode struct {
	typ string
	fft *FftNode
	psd *PsdNode
}

type frequencyDomainNodeDeserializer struct {
	Type string   `json:"type"`
	Fft  *FftNode `json:"fft"`
	Psd  *PsdNode `json:"psd"`
}

func (u *frequencyDomainNodeDeserializer) toStruct() FrequencyDomainNode {
	return FrequencyDomainNode{typ: u.Type, fft: u.Fft, psd: u.Psd}
}

func (u *FrequencyDomainNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "fft":
		if u.fft == nil {
			return nil, fmt.Errorf("field \"fft\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Fft  FftNode `json:"fft"`
		}{Type: "fft", Fft: *u.fft}, nil
	case "psd":
		if u.psd == nil {
			return nil, fmt.Errorf("field \"psd\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Psd  PsdNode `json:"psd"`
		}{Type: "psd", Psd: *u.psd}, nil
	}
}

func (u FrequencyDomainNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FrequencyDomainNode) UnmarshalJSON(data []byte) error {
	var deser frequencyDomainNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
	}
	return nil
}

func (u FrequencyDomainNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FrequencyDomainNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FrequencyDomainNode) AcceptFuncs(fftFunc func(FftNode) error, psdFunc func(PsdNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return psdFunc(*u.psd)
	}
}

func (u *FrequencyDomainNode) FftNoopSuccess(FftNode) error {
	return nil
}

func (u *FrequencyDomainNode) PsdNoopSuccess(PsdNode) error {
	return nil
}

func (u *FrequencyDomainNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FrequencyDomainNode) Accept(v FrequencyDomainNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(*u.fft)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsd(*u.psd)
	}
}

type FrequencyDomainNodeVisitor interface {
	VisitFft(v FftNode) error
	VisitPsd(v PsdNode) error
	VisitUnknown(typeName string) error
}

func (u *FrequencyDomainNode) AcceptWithContext(ctx context.Context, v FrequencyDomainNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFftWithContext(ctx, *u.fft)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsdWithContext(ctx, *u.psd)
	}
}

type FrequencyDomainNodeVisitorWithContext interface {
	VisitFftWithContext(ctx context.Context, v FftNode) error
	VisitPsdWithContext(ctx context.Context, v PsdNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFrequencyDomainNodeFromFft(v FftNode) FrequencyDomainNode {
	return FrequencyDomainNode{typ: "fft", fft: &v}
}

func NewFrequencyDomainNodeFromPsd(v PsdNode) FrequencyDomainNode {
	return FrequencyDomainNode{typ: "psd", psd: &v}
}

type FrequencyDomainNodeV2 struct {
	typ     string
	fft     *FftNode
	psd     *PsdNode
	cpsd    *CpsdNode
	nyquist *NyquistNode
	bode    *BodeNode
}

type frequencyDomainNodeV2Deserializer struct {
	Type    string       `json:"type"`
	Fft     *FftNode     `json:"fft"`
	Psd     *PsdNode     `json:"psd"`
	Cpsd    *CpsdNode    `json:"cpsd"`
	Nyquist *NyquistNode `json:"nyquist"`
	Bode    *BodeNode    `json:"bode"`
}

func (u *frequencyDomainNodeV2Deserializer) toStruct() FrequencyDomainNodeV2 {
	return FrequencyDomainNodeV2{typ: u.Type, fft: u.Fft, psd: u.Psd, cpsd: u.Cpsd, nyquist: u.Nyquist, bode: u.Bode}
}

func (u *FrequencyDomainNodeV2) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "fft":
		if u.fft == nil {
			return nil, fmt.Errorf("field \"fft\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Fft  FftNode `json:"fft"`
		}{Type: "fft", Fft: *u.fft}, nil
	case "psd":
		if u.psd == nil {
			return nil, fmt.Errorf("field \"psd\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Psd  PsdNode `json:"psd"`
		}{Type: "psd", Psd: *u.psd}, nil
	case "cpsd":
		if u.cpsd == nil {
			return nil, fmt.Errorf("field \"cpsd\" is required")
		}
		return struct {
			Type string   `json:"type"`
			Cpsd CpsdNode `json:"cpsd"`
		}{Type: "cpsd", Cpsd: *u.cpsd}, nil
	case "nyquist":
		if u.nyquist == nil {
			return nil, fmt.Errorf("field \"nyquist\" is required")
		}
		return struct {
			Type    string      `json:"type"`
			Nyquist NyquistNode `json:"nyquist"`
		}{Type: "nyquist", Nyquist: *u.nyquist}, nil
	case "bode":
		if u.bode == nil {
			return nil, fmt.Errorf("field \"bode\" is required")
		}
		return struct {
			Type string   `json:"type"`
			Bode BodeNode `json:"bode"`
		}{Type: "bode", Bode: *u.bode}, nil
	}
}

func (u FrequencyDomainNodeV2) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FrequencyDomainNodeV2) UnmarshalJSON(data []byte) error {
	var deser frequencyDomainNodeV2Deserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
	}
	return nil
}

func (u FrequencyDomainNodeV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FrequencyDomainNodeV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FrequencyDomainNodeV2) AcceptFuncs(fftFunc func(FftNode) error, psdFunc func(PsdNode) error, cpsdFunc func(CpsdNode) error, nyquistFunc func(NyquistNode) error, bodeFunc func(BodeNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return psdFunc(*u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
		return cpsdFunc(*u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
		return nyquistFunc(*u.nyquist)
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
		return bodeFunc(*u.bode)
	}
}

func (u *FrequencyDomainNodeV2) FftNoopSuccess(FftNode) error {
	return nil
}

func (u *FrequencyDomainNodeV2) PsdNoopSuccess(PsdNode) error {
	return nil
}

func (u *FrequencyDomainNodeV2) CpsdNoopSuccess(CpsdNode) error {
	return nil
}

func (u *FrequencyDomainNodeV2) NyquistNoopSuccess(NyquistNode) error {
	return nil
}

func (u *FrequencyDomainNodeV2) BodeNoopSuccess(BodeNode) error {
	return nil
}

func (u *FrequencyDomainNodeV2) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FrequencyDomainNodeV2) Accept(v FrequencyDomainNodeV2Visitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(*u.fft)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsd(*u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
		return v.VisitCpsd(*u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
		return v.VisitNyquist(*u.nyquist)
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
		return v.VisitBode(*u.bode)
	}
}

type FrequencyDomainNodeV2Visitor interface {
	VisitFft(v FftNode) error
	VisitPsd(v PsdNode) error
	VisitCpsd(v CpsdNode) error
	VisitNyquist(v NyquistNode) error
	VisitBode(v BodeNode) error
	VisitUnknown(typeName string) error
}

func (u *FrequencyDomainNodeV2) AcceptWithContext(ctx context.Context, v FrequencyDomainNodeV2VisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFftWithContext(ctx, *u.fft)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsdWithContext(ctx, *u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
		return v.VisitCpsdWithContext(ctx, *u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
		return v.VisitNyquistWithContext(ctx, *u.nyquist)
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
		return v.VisitBodeWithContext(ctx, *u.bode)
	}
}

type FrequencyDomainNodeV2VisitorWithContext interface {
	VisitFftWithContext(ctx context.Context, v FftNode) error
	VisitPsdWithContext(ctx context.Context, v PsdNode) error
	VisitCpsdWithContext(ctx context.Context, v CpsdNode) error
	VisitNyquistWithContext(ctx context.Context, v NyquistNode) error
	VisitBodeWithContext(ctx context.Context, v BodeNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFrequencyDomainNodeV2FromFft(v FftNode) FrequencyDomainNodeV2 {
	return FrequencyDomainNodeV2{typ: "fft", fft: &v}
}

func NewFrequencyDomainNodeV2FromPsd(v PsdNode) FrequencyDomainNodeV2 {
	return FrequencyDomainNodeV2{typ: "psd", psd: &v}
}

func NewFrequencyDomainNodeV2FromCpsd(v CpsdNode) FrequencyDomainNodeV2 {
	return FrequencyDomainNodeV2{typ: "cpsd", cpsd: &v}
}

func NewFrequencyDomainNodeV2FromNyquist(v NyquistNode) FrequencyDomainNodeV2 {
	return FrequencyDomainNodeV2{typ: "nyquist", nyquist: &v}
}

func NewFrequencyDomainNodeV2FromBode(v BodeNode) FrequencyDomainNodeV2 {
	return FrequencyDomainNodeV2{typ: "bode", bode: &v}
}

type HistogramNode struct {
	typ              string
	numericHistogram *NumericHistogramNode
	enumHistogram    *EnumHistogramNode
}

type histogramNodeDeserializer struct {
	Type             string                `json:"type"`
	NumericHistogram *NumericHistogramNode `json:"numericHistogram"`
	EnumHistogram    *EnumHistogramNode    `json:"enumHistogram"`
}

func (u *histogramNodeDeserializer) toStruct() HistogramNode {
	return HistogramNode{typ: u.Type, numericHistogram: u.NumericHistogram, enumHistogram: u.EnumHistogram}
}

func (u *HistogramNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return nil, fmt.Errorf("field \"numericHistogram\" is required")
		}
		return struct {
			Type             string               `json:"type"`
			NumericHistogram NumericHistogramNode `json:"numericHistogram"`
		}{Type: "numericHistogram", NumericHistogram: *u.numericHistogram}, nil
	case "enumHistogram":
		if u.enumHistogram == nil {
			return nil, fmt.Errorf("field \"enumHistogram\" is required")
		}
		return struct {
			Type          string            `json:"type"`
			EnumHistogram EnumHistogramNode `json:"enumHistogram"`
		}{Type: "enumHistogram", EnumHistogram: *u.enumHistogram}, nil
	}
}

func (u HistogramNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *HistogramNode) UnmarshalJSON(data []byte) error {
	var deser histogramNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
	}
	return nil
}

func (u HistogramNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *HistogramNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *HistogramNode) AcceptFuncs(numericHistogramFunc func(NumericHistogramNode) error, enumHistogramFunc func(EnumHistogramNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
		return numericHistogramFunc(*u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
		return enumHistogramFunc(*u.enumHistogram)
	}
}

func (u *HistogramNode) NumericHistogramNoopSuccess(NumericHistogramNode) error {
	return nil
}

func (u *HistogramNode) EnumHistogramNoopSuccess(EnumHistogramNode) error {
	return nil
}

func (u *HistogramNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *HistogramNode) Accept(v HistogramNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
		return v.VisitNumericHistogram(*u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
		return v.VisitEnumHistogram(*u.enumHistogram)
	}
}

type HistogramNodeVisitor interface {
	VisitNumericHistogram(v NumericHistogramNode) error
	VisitEnumHistogram(v EnumHistogramNode) error
	VisitUnknown(typeName string) error
}

func (u *HistogramNode) AcceptWithContext(ctx context.Context, v HistogramNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
		return v.VisitNumericHistogramWithContext(ctx, *u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
		return v.VisitEnumHistogramWithContext(ctx, *u.enumHistogram)
	}
}

type HistogramNodeVisitorWithContext interface {
	VisitNumericHistogramWithContext(ctx context.Context, v NumericHistogramNode) error
	VisitEnumHistogramWithContext(ctx context.Context, v EnumHistogramNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewHistogramNodeFromNumericHistogram(v NumericHistogramNode) HistogramNode {
	return HistogramNode{typ: "numericHistogram", numericHistogram: &v}
}

func NewHistogramNodeFromEnumHistogram(v EnumHistogramNode) HistogramNode {
	return HistogramNode{typ: "enumHistogram", enumHistogram: &v}
}

type InterpolationConfiguration struct {
	typ                      string
	forwardFillInterpolation *ForwardFillInterpolation
}

type interpolationConfigurationDeserializer struct {
	Type                     string                    `json:"type"`
	ForwardFillInterpolation *ForwardFillInterpolation `json:"forwardFillInterpolation"`
}

func (u *interpolationConfigurationDeserializer) toStruct() InterpolationConfiguration {
	return InterpolationConfiguration{typ: u.Type, forwardFillInterpolation: u.ForwardFillInterpolation}
}

func (u *InterpolationConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return nil, fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return struct {
			Type                     string                   `json:"type"`
			ForwardFillInterpolation ForwardFillInterpolation `json:"forwardFillInterpolation"`
		}{Type: "forwardFillInterpolation", ForwardFillInterpolation: *u.forwardFillInterpolation}, nil
	}
}

func (u InterpolationConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *InterpolationConfiguration) UnmarshalJSON(data []byte) error {
	var deser interpolationConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
	}
	return nil
}

func (u InterpolationConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *InterpolationConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *InterpolationConfiguration) AcceptFuncs(forwardFillInterpolationFunc func(ForwardFillInterpolation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return forwardFillInterpolationFunc(*u.forwardFillInterpolation)
	}
}

func (u *InterpolationConfiguration) ForwardFillInterpolationNoopSuccess(ForwardFillInterpolation) error {
	return nil
}

func (u *InterpolationConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *InterpolationConfiguration) Accept(v InterpolationConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return v.VisitForwardFillInterpolation(*u.forwardFillInterpolation)
	}
}

type InterpolationConfigurationVisitor interface {
	VisitForwardFillInterpolation(v ForwardFillInterpolation) error
	VisitUnknown(typeName string) error
}

func (u *InterpolationConfiguration) AcceptWithContext(ctx context.Context, v InterpolationConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return v.VisitForwardFillInterpolationWithContext(ctx, *u.forwardFillInterpolation)
	}
}

type InterpolationConfigurationVisitorWithContext interface {
	VisitForwardFillInterpolationWithContext(ctx context.Context, v ForwardFillInterpolation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewInterpolationConfigurationFromForwardFillInterpolation(v ForwardFillInterpolation) InterpolationConfiguration {
	return InterpolationConfiguration{typ: "forwardFillInterpolation", forwardFillInterpolation: &v}
}

type LogSeriesNode struct {
	typ       string
	raw       *RawLogSeriesNode
	union     *LogUnionSeriesNode
	filter    *LogFilterSeriesNode
	timeShift *LogTimeShiftSeriesNode
}

type logSeriesNodeDeserializer struct {
	Type      string                  `json:"type"`
	Raw       *RawLogSeriesNode       `json:"raw"`
	Union     *LogUnionSeriesNode     `json:"union"`
	Filter    *LogFilterSeriesNode    `json:"filter"`
	TimeShift *LogTimeShiftSeriesNode `json:"timeShift"`
}

func (u *logSeriesNodeDeserializer) toStruct() LogSeriesNode {
	return LogSeriesNode{typ: u.Type, raw: u.Raw, union: u.Union, filter: u.Filter, timeShift: u.TimeShift}
}

func (u *LogSeriesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string           `json:"type"`
			Raw  RawLogSeriesNode `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "union":
		if u.union == nil {
			return nil, fmt.Errorf("field \"union\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Union LogUnionSeriesNode `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	case "filter":
		if u.filter == nil {
			return nil, fmt.Errorf("field \"filter\" is required")
		}
		return struct {
			Type   string              `json:"type"`
			Filter LogFilterSeriesNode `json:"filter"`
		}{Type: "filter", Filter: *u.filter}, nil
	case "timeShift":
		if u.timeShift == nil {
			return nil, fmt.Errorf("field \"timeShift\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			TimeShift LogTimeShiftSeriesNode `json:"timeShift"`
		}{Type: "timeShift", TimeShift: *u.timeShift}, nil
	}
}

func (u LogSeriesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LogSeriesNode) UnmarshalJSON(data []byte) error {
	var deser logSeriesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
	}
	return nil
}

func (u LogSeriesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LogSeriesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LogSeriesNode) AcceptFuncs(rawFunc func(RawLogSeriesNode) error, unionFunc func(LogUnionSeriesNode) error, filterFunc func(LogFilterSeriesNode) error, timeShiftFunc func(LogTimeShiftSeriesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
		return filterFunc(*u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	}
}

func (u *LogSeriesNode) RawNoopSuccess(RawLogSeriesNode) error {
	return nil
}

func (u *LogSeriesNode) UnionNoopSuccess(LogUnionSeriesNode) error {
	return nil
}

func (u *LogSeriesNode) FilterNoopSuccess(LogFilterSeriesNode) error {
	return nil
}

func (u *LogSeriesNode) TimeShiftNoopSuccess(LogTimeShiftSeriesNode) error {
	return nil
}

func (u *LogSeriesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LogSeriesNode) Accept(v LogSeriesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
		return v.VisitFilter(*u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(*u.timeShift)
	}
}

type LogSeriesNodeVisitor interface {
	VisitRaw(v RawLogSeriesNode) error
	VisitUnion(v LogUnionSeriesNode) error
	VisitFilter(v LogFilterSeriesNode) error
	VisitTimeShift(v LogTimeShiftSeriesNode) error
	VisitUnknown(typeName string) error
}

func (u *LogSeriesNode) AcceptWithContext(ctx context.Context, v LogSeriesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
		return v.VisitFilterWithContext(ctx, *u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShiftWithContext(ctx, *u.timeShift)
	}
}

type LogSeriesNodeVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v RawLogSeriesNode) error
	VisitUnionWithContext(ctx context.Context, v LogUnionSeriesNode) error
	VisitFilterWithContext(ctx context.Context, v LogFilterSeriesNode) error
	VisitTimeShiftWithContext(ctx context.Context, v LogTimeShiftSeriesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLogSeriesNodeFromRaw(v RawLogSeriesNode) LogSeriesNode {
	return LogSeriesNode{typ: "raw", raw: &v}
}

func NewLogSeriesNodeFromUnion(v LogUnionSeriesNode) LogSeriesNode {
	return LogSeriesNode{typ: "union", union: &v}
}

func NewLogSeriesNodeFromFilter(v LogFilterSeriesNode) LogSeriesNode {
	return LogSeriesNode{typ: "filter", filter: &v}
}

func NewLogSeriesNodeFromTimeShift(v LogTimeShiftSeriesNode) LogSeriesNode {
	return LogSeriesNode{typ: "timeShift", timeShift: &v}
}

type NumericArraySeriesNode struct {
	typ string
	raw *ResolvedSeries
}

type numericArraySeriesNodeDeserializer struct {
	Type string          `json:"type"`
	Raw  *ResolvedSeries `json:"raw"`
}

func (u *numericArraySeriesNodeDeserializer) toStruct() NumericArraySeriesNode {
	return NumericArraySeriesNode{typ: u.Type, raw: u.Raw}
}

func (u *NumericArraySeriesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string         `json:"type"`
			Raw  ResolvedSeries `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u NumericArraySeriesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericArraySeriesNode) UnmarshalJSON(data []byte) error {
	var deser numericArraySeriesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u NumericArraySeriesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericArraySeriesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericArraySeriesNode) AcceptFuncs(rawFunc func(ResolvedSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *NumericArraySeriesNode) RawNoopSuccess(ResolvedSeries) error {
	return nil
}

func (u *NumericArraySeriesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericArraySeriesNode) Accept(v NumericArraySeriesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type NumericArraySeriesNodeVisitor interface {
	VisitRaw(v ResolvedSeries) error
	VisitUnknown(typeName string) error
}

func (u *NumericArraySeriesNode) AcceptWithContext(ctx context.Context, v NumericArraySeriesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type NumericArraySeriesNodeVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v ResolvedSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericArraySeriesNodeFromRaw(v ResolvedSeries) NumericArraySeriesNode {
	return NumericArraySeriesNode{typ: "raw", raw: &v}
}

type NumericHistogramBucketStrategy struct {
	typ                  string
	bucketCount          *int
	bucketWidthAndOffset *NumericHistogramBucketWidthAndOffset
}

type numericHistogramBucketStrategyDeserializer struct {
	Type                 string                                `json:"type"`
	BucketCount          *int                                  `json:"bucketCount"`
	BucketWidthAndOffset *NumericHistogramBucketWidthAndOffset `json:"bucketWidthAndOffset"`
}

func (u *numericHistogramBucketStrategyDeserializer) toStruct() NumericHistogramBucketStrategy {
	return NumericHistogramBucketStrategy{typ: u.Type, bucketCount: u.BucketCount, bucketWidthAndOffset: u.BucketWidthAndOffset}
}

func (u *NumericHistogramBucketStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return nil, fmt.Errorf("field \"bucketCount\" is required")
		}
		return struct {
			Type        string `json:"type"`
			BucketCount int    `json:"bucketCount"`
		}{Type: "bucketCount", BucketCount: *u.bucketCount}, nil
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return nil, fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return struct {
			Type                 string                               `json:"type"`
			BucketWidthAndOffset NumericHistogramBucketWidthAndOffset `json:"bucketWidthAndOffset"`
		}{Type: "bucketWidthAndOffset", BucketWidthAndOffset: *u.bucketWidthAndOffset}, nil
	}
}

func (u NumericHistogramBucketStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericHistogramBucketStrategy) UnmarshalJSON(data []byte) error {
	var deser numericHistogramBucketStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
	}
	return nil
}

func (u NumericHistogramBucketStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericHistogramBucketStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericHistogramBucketStrategy) AcceptFuncs(bucketCountFunc func(int) error, bucketWidthAndOffsetFunc func(NumericHistogramBucketWidthAndOffset) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
		return bucketCountFunc(*u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return bucketWidthAndOffsetFunc(*u.bucketWidthAndOffset)
	}
}

func (u *NumericHistogramBucketStrategy) BucketCountNoopSuccess(int) error {
	return nil
}

func (u *NumericHistogramBucketStrategy) BucketWidthAndOffsetNoopSuccess(NumericHistogramBucketWidthAndOffset) error {
	return nil
}

func (u *NumericHistogramBucketStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericHistogramBucketStrategy) Accept(v NumericHistogramBucketStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
		return v.VisitBucketCount(*u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return v.VisitBucketWidthAndOffset(*u.bucketWidthAndOffset)
	}
}

type NumericHistogramBucketStrategyVisitor interface {
	VisitBucketCount(v int) error
	VisitBucketWidthAndOffset(v NumericHistogramBucketWidthAndOffset) error
	VisitUnknown(typeName string) error
}

func (u *NumericHistogramBucketStrategy) AcceptWithContext(ctx context.Context, v NumericHistogramBucketStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
		return v.VisitBucketCountWithContext(ctx, *u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return v.VisitBucketWidthAndOffsetWithContext(ctx, *u.bucketWidthAndOffset)
	}
}

type NumericHistogramBucketStrategyVisitorWithContext interface {
	VisitBucketCountWithContext(ctx context.Context, v int) error
	VisitBucketWidthAndOffsetWithContext(ctx context.Context, v NumericHistogramBucketWidthAndOffset) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericHistogramBucketStrategyFromBucketCount(v int) NumericHistogramBucketStrategy {
	return NumericHistogramBucketStrategy{typ: "bucketCount", bucketCount: &v}
}

func NewNumericHistogramBucketStrategyFromBucketWidthAndOffset(v NumericHistogramBucketWidthAndOffset) NumericHistogramBucketStrategy {
	return NumericHistogramBucketStrategy{typ: "bucketWidthAndOffset", bucketWidthAndOffset: &v}
}

type NumericSeriesNode struct {
	typ                               string
	arithmetic                        *ArithmeticSeriesNode
	bitOperation                      *BitOperationSeriesNode
	countDuplicate                    *EnumCountDuplicateSeriesNode
	cumulativeSum                     *CumulativeSumSeriesNode
	derivative                        *DerivativeSeriesNode
	integral                          *IntegralSeriesNode
	max                               *MaxSeriesNode
	mean                              *MeanSeriesNode
	min                               *MinSeriesNode
	offset                            *OffsetSeriesNode
	product                           *ProductSeriesNode
	raw                               *RawNumericSeriesNode
	resample                          *NumericResampleSeriesNode
	rollingOperation                  *RollingOperationSeriesNode
	aggregate                         *AggregateNumericSeriesNode
	signalFilter                      *SignalFilterSeriesNode
	sum                               *SumSeriesNode
	scale                             *ScaleSeriesNode
	timeDifference                    *TimeDifferenceSeriesNode
	timeRangeFilter                   *NumericTimeRangeFilterSeriesNode
	timeShift                         *NumericTimeShiftSeriesNode
	unaryArithmetic                   *UnaryArithmeticSeriesNode
	binaryArithmetic                  *BinaryArithmeticSeriesNode
	union                             *NumericUnionSeriesNode
	unitConversion                    *UnitConversionSeriesNode
	valueDifference                   *ValueDifferenceSeriesNode
	filterTransformation              *NumericFilterTransformationSeriesNode
	thresholdFilter                   *NumericThresholdFilterSeriesNode
	arraySelect                       *SelectIndexFromNumericArraySeriesNode
	absoluteTimestamp                 *AbsoluteTimestampSeriesNode
	newestPoints                      *SelectNewestPointsSeriesNode
	rangesNumericAggregationToNumeric *RangesNumericAggregationToNumericSeriesNode
	filterByExpression                *FilterByExpressionSeriesNode
	enumToNumeric                     *EnumToNumericSeriesNode
	refprop                           *RefpropSeriesNode
	extractFromStruct                 *ExtractNumericFromStructSeriesNode
}

type numericSeriesNodeDeserializer struct {
	Type                              string                                       `json:"type"`
	Arithmetic                        *ArithmeticSeriesNode                        `json:"arithmetic"`
	BitOperation                      *BitOperationSeriesNode                      `json:"bitOperation"`
	CountDuplicate                    *EnumCountDuplicateSeriesNode                `json:"countDuplicate"`
	CumulativeSum                     *CumulativeSumSeriesNode                     `json:"cumulativeSum"`
	Derivative                        *DerivativeSeriesNode                        `json:"derivative"`
	Integral                          *IntegralSeriesNode                          `json:"integral"`
	Max                               *MaxSeriesNode                               `json:"max"`
	Mean                              *MeanSeriesNode                              `json:"mean"`
	Min                               *MinSeriesNode                               `json:"min"`
	Offset                            *OffsetSeriesNode                            `json:"offset"`
	Product                           *ProductSeriesNode                           `json:"product"`
	Raw                               *RawNumericSeriesNode                        `json:"raw"`
	Resample                          *NumericResampleSeriesNode                   `json:"resample"`
	RollingOperation                  *RollingOperationSeriesNode                  `json:"rollingOperation"`
	Aggregate                         *AggregateNumericSeriesNode                  `json:"aggregate"`
	SignalFilter                      *SignalFilterSeriesNode                      `json:"signalFilter"`
	Sum                               *SumSeriesNode                               `json:"sum"`
	Scale                             *ScaleSeriesNode                             `json:"scale"`
	TimeDifference                    *TimeDifferenceSeriesNode                    `json:"timeDifference"`
	TimeRangeFilter                   *NumericTimeRangeFilterSeriesNode            `json:"timeRangeFilter"`
	TimeShift                         *NumericTimeShiftSeriesNode                  `json:"timeShift"`
	UnaryArithmetic                   *UnaryArithmeticSeriesNode                   `json:"unaryArithmetic"`
	BinaryArithmetic                  *BinaryArithmeticSeriesNode                  `json:"binaryArithmetic"`
	Union                             *NumericUnionSeriesNode                      `json:"union"`
	UnitConversion                    *UnitConversionSeriesNode                    `json:"unitConversion"`
	ValueDifference                   *ValueDifferenceSeriesNode                   `json:"valueDifference"`
	FilterTransformation              *NumericFilterTransformationSeriesNode       `json:"filterTransformation"`
	ThresholdFilter                   *NumericThresholdFilterSeriesNode            `json:"thresholdFilter"`
	ArraySelect                       *SelectIndexFromNumericArraySeriesNode       `json:"arraySelect"`
	AbsoluteTimestamp                 *AbsoluteTimestampSeriesNode                 `json:"absoluteTimestamp"`
	NewestPoints                      *SelectNewestPointsSeriesNode                `json:"newestPoints"`
	RangesNumericAggregationToNumeric *RangesNumericAggregationToNumericSeriesNode `json:"rangesNumericAggregationToNumeric"`
	FilterByExpression                *FilterByExpressionSeriesNode                `json:"filterByExpression"`
	EnumToNumeric                     *EnumToNumericSeriesNode                     `json:"enumToNumeric"`
	Refprop                           *RefpropSeriesNode                           `json:"refprop"`
	ExtractFromStruct                 *ExtractNumericFromStructSeriesNode          `json:"extractFromStruct"`
}

func (u *numericSeriesNodeDeserializer) toStruct() NumericSeriesNode {
	return NumericSeriesNode{typ: u.Type, arithmetic: u.Arithmetic, bitOperation: u.BitOperation, countDuplicate: u.CountDuplicate, cumulativeSum: u.CumulativeSum, derivative: u.Derivative, integral: u.Integral, max: u.Max, mean: u.Mean, min: u.Min, offset: u.Offset, product: u.Product, raw: u.Raw, resample: u.Resample, rollingOperation: u.RollingOperation, aggregate: u.Aggregate, signalFilter: u.SignalFilter, sum: u.Sum, scale: u.Scale, timeDifference: u.TimeDifference, timeRangeFilter: u.TimeRangeFilter, timeShift: u.TimeShift, unaryArithmetic: u.UnaryArithmetic, binaryArithmetic: u.BinaryArithmetic, union: u.Union, unitConversion: u.UnitConversion, valueDifference: u.ValueDifference, filterTransformation: u.FilterTransformation, thresholdFilter: u.ThresholdFilter, arraySelect: u.ArraySelect, absoluteTimestamp: u.AbsoluteTimestamp, newestPoints: u.NewestPoints, rangesNumericAggregationToNumeric: u.RangesNumericAggregationToNumeric, filterByExpression: u.FilterByExpression, enumToNumeric: u.EnumToNumeric, refprop: u.Refprop, extractFromStruct: u.ExtractFromStruct}
}

func (u *NumericSeriesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "arithmetic":
		if u.arithmetic == nil {
			return nil, fmt.Errorf("field \"arithmetic\" is required")
		}
		return struct {
			Type       string               `json:"type"`
			Arithmetic ArithmeticSeriesNode `json:"arithmetic"`
		}{Type: "arithmetic", Arithmetic: *u.arithmetic}, nil
	case "bitOperation":
		if u.bitOperation == nil {
			return nil, fmt.Errorf("field \"bitOperation\" is required")
		}
		return struct {
			Type         string                 `json:"type"`
			BitOperation BitOperationSeriesNode `json:"bitOperation"`
		}{Type: "bitOperation", BitOperation: *u.bitOperation}, nil
	case "countDuplicate":
		if u.countDuplicate == nil {
			return nil, fmt.Errorf("field \"countDuplicate\" is required")
		}
		return struct {
			Type           string                       `json:"type"`
			CountDuplicate EnumCountDuplicateSeriesNode `json:"countDuplicate"`
		}{Type: "countDuplicate", CountDuplicate: *u.countDuplicate}, nil
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return nil, fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return struct {
			Type          string                  `json:"type"`
			CumulativeSum CumulativeSumSeriesNode `json:"cumulativeSum"`
		}{Type: "cumulativeSum", CumulativeSum: *u.cumulativeSum}, nil
	case "derivative":
		if u.derivative == nil {
			return nil, fmt.Errorf("field \"derivative\" is required")
		}
		return struct {
			Type       string               `json:"type"`
			Derivative DerivativeSeriesNode `json:"derivative"`
		}{Type: "derivative", Derivative: *u.derivative}, nil
	case "integral":
		if u.integral == nil {
			return nil, fmt.Errorf("field \"integral\" is required")
		}
		return struct {
			Type     string             `json:"type"`
			Integral IntegralSeriesNode `json:"integral"`
		}{Type: "integral", Integral: *u.integral}, nil
	case "max":
		if u.max == nil {
			return nil, fmt.Errorf("field \"max\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Max  MaxSeriesNode `json:"max"`
		}{Type: "max", Max: *u.max}, nil
	case "mean":
		if u.mean == nil {
			return nil, fmt.Errorf("field \"mean\" is required")
		}
		return struct {
			Type string         `json:"type"`
			Mean MeanSeriesNode `json:"mean"`
		}{Type: "mean", Mean: *u.mean}, nil
	case "min":
		if u.min == nil {
			return nil, fmt.Errorf("field \"min\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Min  MinSeriesNode `json:"min"`
		}{Type: "min", Min: *u.min}, nil
	case "offset":
		if u.offset == nil {
			return nil, fmt.Errorf("field \"offset\" is required")
		}
		return struct {
			Type   string           `json:"type"`
			Offset OffsetSeriesNode `json:"offset"`
		}{Type: "offset", Offset: *u.offset}, nil
	case "product":
		if u.product == nil {
			return nil, fmt.Errorf("field \"product\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Product ProductSeriesNode `json:"product"`
		}{Type: "product", Product: *u.product}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Raw  RawNumericSeriesNode `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "resample":
		if u.resample == nil {
			return nil, fmt.Errorf("field \"resample\" is required")
		}
		return struct {
			Type     string                    `json:"type"`
			Resample NumericResampleSeriesNode `json:"resample"`
		}{Type: "resample", Resample: *u.resample}, nil
	case "rollingOperation":
		if u.rollingOperation == nil {
			return nil, fmt.Errorf("field \"rollingOperation\" is required")
		}
		return struct {
			Type             string                     `json:"type"`
			RollingOperation RollingOperationSeriesNode `json:"rollingOperation"`
		}{Type: "rollingOperation", RollingOperation: *u.rollingOperation}, nil
	case "aggregate":
		if u.aggregate == nil {
			return nil, fmt.Errorf("field \"aggregate\" is required")
		}
		return struct {
			Type      string                     `json:"type"`
			Aggregate AggregateNumericSeriesNode `json:"aggregate"`
		}{Type: "aggregate", Aggregate: *u.aggregate}, nil
	case "signalFilter":
		if u.signalFilter == nil {
			return nil, fmt.Errorf("field \"signalFilter\" is required")
		}
		return struct {
			Type         string                 `json:"type"`
			SignalFilter SignalFilterSeriesNode `json:"signalFilter"`
		}{Type: "signalFilter", SignalFilter: *u.signalFilter}, nil
	case "sum":
		if u.sum == nil {
			return nil, fmt.Errorf("field \"sum\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Sum  SumSeriesNode `json:"sum"`
		}{Type: "sum", Sum: *u.sum}, nil
	case "scale":
		if u.scale == nil {
			return nil, fmt.Errorf("field \"scale\" is required")
		}
		return struct {
			Type  string          `json:"type"`
			Scale ScaleSeriesNode `json:"scale"`
		}{Type: "scale", Scale: *u.scale}, nil
	case "timeDifference":
		if u.timeDifference == nil {
			return nil, fmt.Errorf("field \"timeDifference\" is required")
		}
		return struct {
			Type           string                   `json:"type"`
			TimeDifference TimeDifferenceSeriesNode `json:"timeDifference"`
		}{Type: "timeDifference", TimeDifference: *u.timeDifference}, nil
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return nil, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return struct {
			Type            string                           `json:"type"`
			TimeRangeFilter NumericTimeRangeFilterSeriesNode `json:"timeRangeFilter"`
		}{Type: "timeRangeFilter", TimeRangeFilter: *u.timeRangeFilter}, nil
	case "timeShift":
		if u.timeShift == nil {
			return nil, fmt.Errorf("field \"timeShift\" is required")
		}
		return struct {
			Type      string                     `json:"type"`
			TimeShift NumericTimeShiftSeriesNode `json:"timeShift"`
		}{Type: "timeShift", TimeShift: *u.timeShift}, nil
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return nil, fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return struct {
			Type            string                    `json:"type"`
			UnaryArithmetic UnaryArithmeticSeriesNode `json:"unaryArithmetic"`
		}{Type: "unaryArithmetic", UnaryArithmetic: *u.unaryArithmetic}, nil
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return nil, fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return struct {
			Type             string                     `json:"type"`
			BinaryArithmetic BinaryArithmeticSeriesNode `json:"binaryArithmetic"`
		}{Type: "binaryArithmetic", BinaryArithmetic: *u.binaryArithmetic}, nil
	case "union":
		if u.union == nil {
			return nil, fmt.Errorf("field \"union\" is required")
		}
		return struct {
			Type  string                 `json:"type"`
			Union NumericUnionSeriesNode `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	case "unitConversion":
		if u.unitConversion == nil {
			return nil, fmt.Errorf("field \"unitConversion\" is required")
		}
		return struct {
			Type           string                   `json:"type"`
			UnitConversion UnitConversionSeriesNode `json:"unitConversion"`
		}{Type: "unitConversion", UnitConversion: *u.unitConversion}, nil
	case "valueDifference":
		if u.valueDifference == nil {
			return nil, fmt.Errorf("field \"valueDifference\" is required")
		}
		return struct {
			Type            string                    `json:"type"`
			ValueDifference ValueDifferenceSeriesNode `json:"valueDifference"`
		}{Type: "valueDifference", ValueDifference: *u.valueDifference}, nil
	case "filterTransformation":
		if u.filterTransformation == nil {
			return nil, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return struct {
			Type                 string                                `json:"type"`
			FilterTransformation NumericFilterTransformationSeriesNode `json:"filterTransformation"`
		}{Type: "filterTransformation", FilterTransformation: *u.filterTransformation}, nil
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return nil, fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return struct {
			Type            string                           `json:"type"`
			ThresholdFilter NumericThresholdFilterSeriesNode `json:"thresholdFilter"`
		}{Type: "thresholdFilter", ThresholdFilter: *u.thresholdFilter}, nil
	case "arraySelect":
		if u.arraySelect == nil {
			return nil, fmt.Errorf("field \"arraySelect\" is required")
		}
		return struct {
			Type        string                                `json:"type"`
			ArraySelect SelectIndexFromNumericArraySeriesNode `json:"arraySelect"`
		}{Type: "arraySelect", ArraySelect: *u.arraySelect}, nil
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return nil, fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return struct {
			Type              string                      `json:"type"`
			AbsoluteTimestamp AbsoluteTimestampSeriesNode `json:"absoluteTimestamp"`
		}{Type: "absoluteTimestamp", AbsoluteTimestamp: *u.absoluteTimestamp}, nil
	case "newestPoints":
		if u.newestPoints == nil {
			return nil, fmt.Errorf("field \"newestPoints\" is required")
		}
		return struct {
			Type         string                       `json:"type"`
			NewestPoints SelectNewestPointsSeriesNode `json:"newestPoints"`
		}{Type: "newestPoints", NewestPoints: *u.newestPoints}, nil
	case "rangesNumericAggregationToNumeric":
		if u.rangesNumericAggregationToNumeric == nil {
			return nil, fmt.Errorf("field \"rangesNumericAggregationToNumeric\" is required")
		}
		return struct {
			Type                              string                                      `json:"type"`
			RangesNumericAggregationToNumeric RangesNumericAggregationToNumericSeriesNode `json:"rangesNumericAggregationToNumeric"`
		}{Type: "rangesNumericAggregationToNumeric", RangesNumericAggregationToNumeric: *u.rangesNumericAggregationToNumeric}, nil
	case "filterByExpression":
		if u.filterByExpression == nil {
			return nil, fmt.Errorf("field \"filterByExpression\" is required")
		}
		return struct {
			Type               string                       `json:"type"`
			FilterByExpression FilterByExpressionSeriesNode `json:"filterByExpression"`
		}{Type: "filterByExpression", FilterByExpression: *u.filterByExpression}, nil
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return nil, fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return struct {
			Type          string                  `json:"type"`
			EnumToNumeric EnumToNumericSeriesNode `json:"enumToNumeric"`
		}{Type: "enumToNumeric", EnumToNumeric: *u.enumToNumeric}, nil
	case "refprop":
		if u.refprop == nil {
			return nil, fmt.Errorf("field \"refprop\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Refprop RefpropSeriesNode `json:"refprop"`
		}{Type: "refprop", Refprop: *u.refprop}, nil
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return nil, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return struct {
			Type              string                             `json:"type"`
			ExtractFromStruct ExtractNumericFromStructSeriesNode `json:"extractFromStruct"`
		}{Type: "extractFromStruct", ExtractFromStruct: *u.extractFromStruct}, nil
	}
}

func (u NumericSeriesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericSeriesNode) UnmarshalJSON(data []byte) error {
	var deser numericSeriesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
	case "arraySelect":
		if u.arraySelect == nil {
			return fmt.Errorf("field \"arraySelect\" is required")
		}
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
	case "newestPoints":
		if u.newestPoints == nil {
			return fmt.Errorf("field \"newestPoints\" is required")
		}
	case "rangesNumericAggregationToNumeric":
		if u.rangesNumericAggregationToNumeric == nil {
			return fmt.Errorf("field \"rangesNumericAggregationToNumeric\" is required")
		}
	case "filterByExpression":
		if u.filterByExpression == nil {
			return fmt.Errorf("field \"filterByExpression\" is required")
		}
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return fmt.Errorf("field \"enumToNumeric\" is required")
		}
	case "refprop":
		if u.refprop == nil {
			return fmt.Errorf("field \"refprop\" is required")
		}
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
	}
	return nil
}

func (u NumericSeriesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericSeriesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericSeriesNode) AcceptFuncs(arithmeticFunc func(ArithmeticSeriesNode) error, bitOperationFunc func(BitOperationSeriesNode) error, countDuplicateFunc func(EnumCountDuplicateSeriesNode) error, cumulativeSumFunc func(CumulativeSumSeriesNode) error, derivativeFunc func(DerivativeSeriesNode) error, integralFunc func(IntegralSeriesNode) error, maxFunc func(MaxSeriesNode) error, meanFunc func(MeanSeriesNode) error, minFunc func(MinSeriesNode) error, offsetFunc func(OffsetSeriesNode) error, productFunc func(ProductSeriesNode) error, rawFunc func(RawNumericSeriesNode) error, resampleFunc func(NumericResampleSeriesNode) error, rollingOperationFunc func(RollingOperationSeriesNode) error, aggregateFunc func(AggregateNumericSeriesNode) error, signalFilterFunc func(SignalFilterSeriesNode) error, sumFunc func(SumSeriesNode) error, scaleFunc func(ScaleSeriesNode) error, timeDifferenceFunc func(TimeDifferenceSeriesNode) error, timeRangeFilterFunc func(NumericTimeRangeFilterSeriesNode) error, timeShiftFunc func(NumericTimeShiftSeriesNode) error, unaryArithmeticFunc func(UnaryArithmeticSeriesNode) error, binaryArithmeticFunc func(BinaryArithmeticSeriesNode) error, unionFunc func(NumericUnionSeriesNode) error, unitConversionFunc func(UnitConversionSeriesNode) error, valueDifferenceFunc func(ValueDifferenceSeriesNode) error, filterTransformationFunc func(NumericFilterTransformationSeriesNode) error, thresholdFilterFunc func(NumericThresholdFilterSeriesNode) error, arraySelectFunc func(SelectIndexFromNumericArraySeriesNode) error, absoluteTimestampFunc func(AbsoluteTimestampSeriesNode) error, newestPointsFunc func(SelectNewestPointsSeriesNode) error, rangesNumericAggregationToNumericFunc func(RangesNumericAggregationToNumericSeriesNode) error, filterByExpressionFunc func(FilterByExpressionSeriesNode) error, enumToNumericFunc func(EnumToNumericSeriesNode) error, refpropFunc func(RefpropSeriesNode) error, extractFromStructFunc func(ExtractNumericFromStructSeriesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return arithmeticFunc(*u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return bitOperationFunc(*u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
		return countDuplicateFunc(*u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return cumulativeSumFunc(*u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return derivativeFunc(*u.derivative)
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
		return integralFunc(*u.integral)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return meanFunc(*u.mean)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
		return offsetFunc(*u.offset)
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
		return productFunc(*u.product)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return resampleFunc(*u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return rollingOperationFunc(*u.rollingOperation)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return aggregateFunc(*u.aggregate)
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
		return signalFilterFunc(*u.signalFilter)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return sumFunc(*u.sum)
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
		return scaleFunc(*u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return timeDifferenceFunc(*u.timeDifference)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return unaryArithmeticFunc(*u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return binaryArithmeticFunc(*u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
		return unitConversionFunc(*u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return valueDifferenceFunc(*u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return filterTransformationFunc(*u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return thresholdFilterFunc(*u.thresholdFilter)
	case "arraySelect":
		if u.arraySelect == nil {
			return fmt.Errorf("field \"arraySelect\" is required")
		}
		return arraySelectFunc(*u.arraySelect)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return absoluteTimestampFunc(*u.absoluteTimestamp)
	case "newestPoints":
		if u.newestPoints == nil {
			return fmt.Errorf("field \"newestPoints\" is required")
		}
		return newestPointsFunc(*u.newestPoints)
	case "rangesNumericAggregationToNumeric":
		if u.rangesNumericAggregationToNumeric == nil {
			return fmt.Errorf("field \"rangesNumericAggregationToNumeric\" is required")
		}
		return rangesNumericAggregationToNumericFunc(*u.rangesNumericAggregationToNumeric)
	case "filterByExpression":
		if u.filterByExpression == nil {
			return fmt.Errorf("field \"filterByExpression\" is required")
		}
		return filterByExpressionFunc(*u.filterByExpression)
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return enumToNumericFunc(*u.enumToNumeric)
	case "refprop":
		if u.refprop == nil {
			return fmt.Errorf("field \"refprop\" is required")
		}
		return refpropFunc(*u.refprop)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	}
}

func (u *NumericSeriesNode) ArithmeticNoopSuccess(ArithmeticSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) BitOperationNoopSuccess(BitOperationSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) CountDuplicateNoopSuccess(EnumCountDuplicateSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) CumulativeSumNoopSuccess(CumulativeSumSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) DerivativeNoopSuccess(DerivativeSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) IntegralNoopSuccess(IntegralSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) MaxNoopSuccess(MaxSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) MeanNoopSuccess(MeanSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) MinNoopSuccess(MinSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) OffsetNoopSuccess(OffsetSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) ProductNoopSuccess(ProductSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) RawNoopSuccess(RawNumericSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) ResampleNoopSuccess(NumericResampleSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) RollingOperationNoopSuccess(RollingOperationSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) AggregateNoopSuccess(AggregateNumericSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) SignalFilterNoopSuccess(SignalFilterSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) SumNoopSuccess(SumSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) ScaleNoopSuccess(ScaleSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) TimeDifferenceNoopSuccess(TimeDifferenceSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) TimeRangeFilterNoopSuccess(NumericTimeRangeFilterSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) TimeShiftNoopSuccess(NumericTimeShiftSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) UnaryArithmeticNoopSuccess(UnaryArithmeticSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) BinaryArithmeticNoopSuccess(BinaryArithmeticSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) UnionNoopSuccess(NumericUnionSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) UnitConversionNoopSuccess(UnitConversionSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) ValueDifferenceNoopSuccess(ValueDifferenceSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) FilterTransformationNoopSuccess(NumericFilterTransformationSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) ThresholdFilterNoopSuccess(NumericThresholdFilterSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) ArraySelectNoopSuccess(SelectIndexFromNumericArraySeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) AbsoluteTimestampNoopSuccess(AbsoluteTimestampSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) NewestPointsNoopSuccess(SelectNewestPointsSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) RangesNumericAggregationToNumericNoopSuccess(RangesNumericAggregationToNumericSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) FilterByExpressionNoopSuccess(FilterByExpressionSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) EnumToNumericNoopSuccess(EnumToNumericSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) RefpropNoopSuccess(RefpropSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) ExtractFromStructNoopSuccess(ExtractNumericFromStructSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericSeriesNode) Accept(v NumericSeriesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return v.VisitArithmetic(*u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return v.VisitBitOperation(*u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
		return v.VisitCountDuplicate(*u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return v.VisitCumulativeSum(*u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return v.VisitDerivative(*u.derivative)
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
		return v.VisitIntegral(*u.integral)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(*u.max)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return v.VisitMean(*u.mean)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(*u.min)
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
		return v.VisitOffset(*u.offset)
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
		return v.VisitProduct(*u.product)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResample(*u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return v.VisitRollingOperation(*u.rollingOperation)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregate(*u.aggregate)
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
		return v.VisitSignalFilter(*u.signalFilter)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSum(*u.sum)
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
		return v.VisitScale(*u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return v.VisitTimeDifference(*u.timeDifference)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(*u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return v.VisitUnaryArithmetic(*u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return v.VisitBinaryArithmetic(*u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
		return v.VisitUnitConversion(*u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return v.VisitValueDifference(*u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformation(*u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return v.VisitThresholdFilter(*u.thresholdFilter)
	case "arraySelect":
		if u.arraySelect == nil {
			return fmt.Errorf("field \"arraySelect\" is required")
		}
		return v.VisitArraySelect(*u.arraySelect)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return v.VisitAbsoluteTimestamp(*u.absoluteTimestamp)
	case "newestPoints":
		if u.newestPoints == nil {
			return fmt.Errorf("field \"newestPoints\" is required")
		}
		return v.VisitNewestPoints(*u.newestPoints)
	case "rangesNumericAggregationToNumeric":
		if u.rangesNumericAggregationToNumeric == nil {
			return fmt.Errorf("field \"rangesNumericAggregationToNumeric\" is required")
		}
		return v.VisitRangesNumericAggregationToNumeric(*u.rangesNumericAggregationToNumeric)
	case "filterByExpression":
		if u.filterByExpression == nil {
			return fmt.Errorf("field \"filterByExpression\" is required")
		}
		return v.VisitFilterByExpression(*u.filterByExpression)
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return v.VisitEnumToNumeric(*u.enumToNumeric)
	case "refprop":
		if u.refprop == nil {
			return fmt.Errorf("field \"refprop\" is required")
		}
		return v.VisitRefprop(*u.refprop)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(*u.extractFromStruct)
	}
}

type NumericSeriesNodeVisitor interface {
	VisitArithmetic(v ArithmeticSeriesNode) error
	VisitBitOperation(v BitOperationSeriesNode) error
	VisitCountDuplicate(v EnumCountDuplicateSeriesNode) error
	VisitCumulativeSum(v CumulativeSumSeriesNode) error
	VisitDerivative(v DerivativeSeriesNode) error
	VisitIntegral(v IntegralSeriesNode) error
	VisitMax(v MaxSeriesNode) error
	VisitMean(v MeanSeriesNode) error
	VisitMin(v MinSeriesNode) error
	VisitOffset(v OffsetSeriesNode) error
	VisitProduct(v ProductSeriesNode) error
	VisitRaw(v RawNumericSeriesNode) error
	VisitResample(v NumericResampleSeriesNode) error
	VisitRollingOperation(v RollingOperationSeriesNode) error
	VisitAggregate(v AggregateNumericSeriesNode) error
	VisitSignalFilter(v SignalFilterSeriesNode) error
	VisitSum(v SumSeriesNode) error
	VisitScale(v ScaleSeriesNode) error
	VisitTimeDifference(v TimeDifferenceSeriesNode) error
	VisitTimeRangeFilter(v NumericTimeRangeFilterSeriesNode) error
	VisitTimeShift(v NumericTimeShiftSeriesNode) error
	VisitUnaryArithmetic(v UnaryArithmeticSeriesNode) error
	VisitBinaryArithmetic(v BinaryArithmeticSeriesNode) error
	VisitUnion(v NumericUnionSeriesNode) error
	VisitUnitConversion(v UnitConversionSeriesNode) error
	VisitValueDifference(v ValueDifferenceSeriesNode) error
	VisitFilterTransformation(v NumericFilterTransformationSeriesNode) error
	VisitThresholdFilter(v NumericThresholdFilterSeriesNode) error
	VisitArraySelect(v SelectIndexFromNumericArraySeriesNode) error
	VisitAbsoluteTimestamp(v AbsoluteTimestampSeriesNode) error
	VisitNewestPoints(v SelectNewestPointsSeriesNode) error
	VisitRangesNumericAggregationToNumeric(v RangesNumericAggregationToNumericSeriesNode) error
	VisitFilterByExpression(v FilterByExpressionSeriesNode) error
	VisitEnumToNumeric(v EnumToNumericSeriesNode) error
	VisitRefprop(v RefpropSeriesNode) error
	VisitExtractFromStruct(v ExtractNumericFromStructSeriesNode) error
	VisitUnknown(typeName string) error
}

func (u *NumericSeriesNode) AcceptWithContext(ctx context.Context, v NumericSeriesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return v.VisitArithmeticWithContext(ctx, *u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return v.VisitBitOperationWithContext(ctx, *u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
		return v.VisitCountDuplicateWithContext(ctx, *u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return v.VisitCumulativeSumWithContext(ctx, *u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return v.VisitDerivativeWithContext(ctx, *u.derivative)
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
		return v.VisitIntegralWithContext(ctx, *u.integral)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMaxWithContext(ctx, *u.max)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return v.VisitMeanWithContext(ctx, *u.mean)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMinWithContext(ctx, *u.min)
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
		return v.VisitOffsetWithContext(ctx, *u.offset)
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
		return v.VisitProductWithContext(ctx, *u.product)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResampleWithContext(ctx, *u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return v.VisitRollingOperationWithContext(ctx, *u.rollingOperation)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregateWithContext(ctx, *u.aggregate)
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
		return v.VisitSignalFilterWithContext(ctx, *u.signalFilter)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSumWithContext(ctx, *u.sum)
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
		return v.VisitScaleWithContext(ctx, *u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return v.VisitTimeDifferenceWithContext(ctx, *u.timeDifference)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilterWithContext(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShiftWithContext(ctx, *u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return v.VisitUnaryArithmeticWithContext(ctx, *u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return v.VisitBinaryArithmeticWithContext(ctx, *u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
		return v.VisitUnitConversionWithContext(ctx, *u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return v.VisitValueDifferenceWithContext(ctx, *u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformationWithContext(ctx, *u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return v.VisitThresholdFilterWithContext(ctx, *u.thresholdFilter)
	case "arraySelect":
		if u.arraySelect == nil {
			return fmt.Errorf("field \"arraySelect\" is required")
		}
		return v.VisitArraySelectWithContext(ctx, *u.arraySelect)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return v.VisitAbsoluteTimestampWithContext(ctx, *u.absoluteTimestamp)
	case "newestPoints":
		if u.newestPoints == nil {
			return fmt.Errorf("field \"newestPoints\" is required")
		}
		return v.VisitNewestPointsWithContext(ctx, *u.newestPoints)
	case "rangesNumericAggregationToNumeric":
		if u.rangesNumericAggregationToNumeric == nil {
			return fmt.Errorf("field \"rangesNumericAggregationToNumeric\" is required")
		}
		return v.VisitRangesNumericAggregationToNumericWithContext(ctx, *u.rangesNumericAggregationToNumeric)
	case "filterByExpression":
		if u.filterByExpression == nil {
			return fmt.Errorf("field \"filterByExpression\" is required")
		}
		return v.VisitFilterByExpressionWithContext(ctx, *u.filterByExpression)
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return v.VisitEnumToNumericWithContext(ctx, *u.enumToNumeric)
	case "refprop":
		if u.refprop == nil {
			return fmt.Errorf("field \"refprop\" is required")
		}
		return v.VisitRefpropWithContext(ctx, *u.refprop)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStructWithContext(ctx, *u.extractFromStruct)
	}
}

type NumericSeriesNodeVisitorWithContext interface {
	VisitArithmeticWithContext(ctx context.Context, v ArithmeticSeriesNode) error
	VisitBitOperationWithContext(ctx context.Context, v BitOperationSeriesNode) error
	VisitCountDuplicateWithContext(ctx context.Context, v EnumCountDuplicateSeriesNode) error
	VisitCumulativeSumWithContext(ctx context.Context, v CumulativeSumSeriesNode) error
	VisitDerivativeWithContext(ctx context.Context, v DerivativeSeriesNode) error
	VisitIntegralWithContext(ctx context.Context, v IntegralSeriesNode) error
	VisitMaxWithContext(ctx context.Context, v MaxSeriesNode) error
	VisitMeanWithContext(ctx context.Context, v MeanSeriesNode) error
	VisitMinWithContext(ctx context.Context, v MinSeriesNode) error
	VisitOffsetWithContext(ctx context.Context, v OffsetSeriesNode) error
	VisitProductWithContext(ctx context.Context, v ProductSeriesNode) error
	VisitRawWithContext(ctx context.Context, v RawNumericSeriesNode) error
	VisitResampleWithContext(ctx context.Context, v NumericResampleSeriesNode) error
	VisitRollingOperationWithContext(ctx context.Context, v RollingOperationSeriesNode) error
	VisitAggregateWithContext(ctx context.Context, v AggregateNumericSeriesNode) error
	VisitSignalFilterWithContext(ctx context.Context, v SignalFilterSeriesNode) error
	VisitSumWithContext(ctx context.Context, v SumSeriesNode) error
	VisitScaleWithContext(ctx context.Context, v ScaleSeriesNode) error
	VisitTimeDifferenceWithContext(ctx context.Context, v TimeDifferenceSeriesNode) error
	VisitTimeRangeFilterWithContext(ctx context.Context, v NumericTimeRangeFilterSeriesNode) error
	VisitTimeShiftWithContext(ctx context.Context, v NumericTimeShiftSeriesNode) error
	VisitUnaryArithmeticWithContext(ctx context.Context, v UnaryArithmeticSeriesNode) error
	VisitBinaryArithmeticWithContext(ctx context.Context, v BinaryArithmeticSeriesNode) error
	VisitUnionWithContext(ctx context.Context, v NumericUnionSeriesNode) error
	VisitUnitConversionWithContext(ctx context.Context, v UnitConversionSeriesNode) error
	VisitValueDifferenceWithContext(ctx context.Context, v ValueDifferenceSeriesNode) error
	VisitFilterTransformationWithContext(ctx context.Context, v NumericFilterTransformationSeriesNode) error
	VisitThresholdFilterWithContext(ctx context.Context, v NumericThresholdFilterSeriesNode) error
	VisitArraySelectWithContext(ctx context.Context, v SelectIndexFromNumericArraySeriesNode) error
	VisitAbsoluteTimestampWithContext(ctx context.Context, v AbsoluteTimestampSeriesNode) error
	VisitNewestPointsWithContext(ctx context.Context, v SelectNewestPointsSeriesNode) error
	VisitRangesNumericAggregationToNumericWithContext(ctx context.Context, v RangesNumericAggregationToNumericSeriesNode) error
	VisitFilterByExpressionWithContext(ctx context.Context, v FilterByExpressionSeriesNode) error
	VisitEnumToNumericWithContext(ctx context.Context, v EnumToNumericSeriesNode) error
	VisitRefpropWithContext(ctx context.Context, v RefpropSeriesNode) error
	VisitExtractFromStructWithContext(ctx context.Context, v ExtractNumericFromStructSeriesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericSeriesNodeFromArithmetic(v ArithmeticSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "arithmetic", arithmetic: &v}
}

func NewNumericSeriesNodeFromBitOperation(v BitOperationSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "bitOperation", bitOperation: &v}
}

func NewNumericSeriesNodeFromCountDuplicate(v EnumCountDuplicateSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "countDuplicate", countDuplicate: &v}
}

func NewNumericSeriesNodeFromCumulativeSum(v CumulativeSumSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "cumulativeSum", cumulativeSum: &v}
}

func NewNumericSeriesNodeFromDerivative(v DerivativeSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "derivative", derivative: &v}
}

func NewNumericSeriesNodeFromIntegral(v IntegralSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "integral", integral: &v}
}

func NewNumericSeriesNodeFromMax(v MaxSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "max", max: &v}
}

func NewNumericSeriesNodeFromMean(v MeanSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "mean", mean: &v}
}

func NewNumericSeriesNodeFromMin(v MinSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "min", min: &v}
}

func NewNumericSeriesNodeFromOffset(v OffsetSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "offset", offset: &v}
}

func NewNumericSeriesNodeFromProduct(v ProductSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "product", product: &v}
}

func NewNumericSeriesNodeFromRaw(v RawNumericSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "raw", raw: &v}
}

func NewNumericSeriesNodeFromResample(v NumericResampleSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "resample", resample: &v}
}

func NewNumericSeriesNodeFromRollingOperation(v RollingOperationSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "rollingOperation", rollingOperation: &v}
}

func NewNumericSeriesNodeFromAggregate(v AggregateNumericSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "aggregate", aggregate: &v}
}

func NewNumericSeriesNodeFromSignalFilter(v SignalFilterSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "signalFilter", signalFilter: &v}
}

func NewNumericSeriesNodeFromSum(v SumSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "sum", sum: &v}
}

func NewNumericSeriesNodeFromScale(v ScaleSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "scale", scale: &v}
}

func NewNumericSeriesNodeFromTimeDifference(v TimeDifferenceSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "timeDifference", timeDifference: &v}
}

func NewNumericSeriesNodeFromTimeRangeFilter(v NumericTimeRangeFilterSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "timeRangeFilter", timeRangeFilter: &v}
}

func NewNumericSeriesNodeFromTimeShift(v NumericTimeShiftSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "timeShift", timeShift: &v}
}

func NewNumericSeriesNodeFromUnaryArithmetic(v UnaryArithmeticSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "unaryArithmetic", unaryArithmetic: &v}
}

func NewNumericSeriesNodeFromBinaryArithmetic(v BinaryArithmeticSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "binaryArithmetic", binaryArithmetic: &v}
}

func NewNumericSeriesNodeFromUnion(v NumericUnionSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "union", union: &v}
}

func NewNumericSeriesNodeFromUnitConversion(v UnitConversionSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "unitConversion", unitConversion: &v}
}

func NewNumericSeriesNodeFromValueDifference(v ValueDifferenceSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "valueDifference", valueDifference: &v}
}

func NewNumericSeriesNodeFromFilterTransformation(v NumericFilterTransformationSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "filterTransformation", filterTransformation: &v}
}

func NewNumericSeriesNodeFromThresholdFilter(v NumericThresholdFilterSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "thresholdFilter", thresholdFilter: &v}
}

func NewNumericSeriesNodeFromArraySelect(v SelectIndexFromNumericArraySeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "arraySelect", arraySelect: &v}
}

func NewNumericSeriesNodeFromAbsoluteTimestamp(v AbsoluteTimestampSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "absoluteTimestamp", absoluteTimestamp: &v}
}

func NewNumericSeriesNodeFromNewestPoints(v SelectNewestPointsSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "newestPoints", newestPoints: &v}
}

func NewNumericSeriesNodeFromRangesNumericAggregationToNumeric(v RangesNumericAggregationToNumericSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "rangesNumericAggregationToNumeric", rangesNumericAggregationToNumeric: &v}
}

func NewNumericSeriesNodeFromFilterByExpression(v FilterByExpressionSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "filterByExpression", filterByExpression: &v}
}

func NewNumericSeriesNodeFromEnumToNumeric(v EnumToNumericSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "enumToNumeric", enumToNumeric: &v}
}

func NewNumericSeriesNodeFromRefprop(v RefpropSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "refprop", refprop: &v}
}

func NewNumericSeriesNodeFromExtractFromStruct(v ExtractNumericFromStructSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "extractFromStruct", extractFromStruct: &v}
}

type RangesNode struct {
	typ                       string
	durationFilter            *DurationFilterRangesNode
	enumEquality              *EnumEqualityRangesNode
	enumFilter                *EnumFilterRangesNode
	extrema                   *ExtremaRangesNode
	intersectRange            *IntersectRangesNode
	literalRanges             *LiteralRangesNode
	minMaxThreshold           *MinMaxThresholdRangesNode
	not                       *NotRangesNode
	onChange                  *OnChangeRangesNode
	rangeNumericAggregation   *RangesNumericAggregationNode
	seriesCrossoverRangesNode *SeriesCrossoverRangesNode
	staleRange                *StaleRangesNode
	stabilityDetection        *StabilityDetectionRangesNode
	threshold                 *ThresholdingRangesNode
	unionRange                *UnionRangesNode
	eventSearch               *EventSearchNode
	paddedRanges              *PaddedRangesNode
}

type rangesNodeDeserializer struct {
	Type                      string                        `json:"type"`
	DurationFilter            *DurationFilterRangesNode     `json:"durationFilter"`
	EnumEquality              *EnumEqualityRangesNode       `json:"enumEquality"`
	EnumFilter                *EnumFilterRangesNode         `json:"enumFilter"`
	Extrema                   *ExtremaRangesNode            `json:"extrema"`
	IntersectRange            *IntersectRangesNode          `json:"intersectRange"`
	LiteralRanges             *LiteralRangesNode            `json:"literalRanges"`
	MinMaxThreshold           *MinMaxThresholdRangesNode    `json:"minMaxThreshold"`
	Not                       *NotRangesNode                `json:"not"`
	OnChange                  *OnChangeRangesNode           `json:"onChange"`
	RangeNumericAggregation   *RangesNumericAggregationNode `json:"rangeNumericAggregation"`
	SeriesCrossoverRangesNode *SeriesCrossoverRangesNode    `json:"seriesCrossoverRangesNode"`
	StaleRange                *StaleRangesNode              `json:"staleRange"`
	StabilityDetection        *StabilityDetectionRangesNode `json:"stabilityDetection"`
	Threshold                 *ThresholdingRangesNode       `json:"threshold"`
	UnionRange                *UnionRangesNode              `json:"unionRange"`
	EventSearch               *EventSearchNode              `json:"eventSearch"`
	PaddedRanges              *PaddedRangesNode             `json:"paddedRanges"`
}

func (u *rangesNodeDeserializer) toStruct() RangesNode {
	return RangesNode{typ: u.Type, durationFilter: u.DurationFilter, enumEquality: u.EnumEquality, enumFilter: u.EnumFilter, extrema: u.Extrema, intersectRange: u.IntersectRange, literalRanges: u.LiteralRanges, minMaxThreshold: u.MinMaxThreshold, not: u.Not, onChange: u.OnChange, rangeNumericAggregation: u.RangeNumericAggregation, seriesCrossoverRangesNode: u.SeriesCrossoverRangesNode, staleRange: u.StaleRange, stabilityDetection: u.StabilityDetection, threshold: u.Threshold, unionRange: u.UnionRange, eventSearch: u.EventSearch, paddedRanges: u.PaddedRanges}
}

func (u *RangesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "durationFilter":
		if u.durationFilter == nil {
			return nil, fmt.Errorf("field \"durationFilter\" is required")
		}
		return struct {
			Type           string                   `json:"type"`
			DurationFilter DurationFilterRangesNode `json:"durationFilter"`
		}{Type: "durationFilter", DurationFilter: *u.durationFilter}, nil
	case "enumEquality":
		if u.enumEquality == nil {
			return nil, fmt.Errorf("field \"enumEquality\" is required")
		}
		return struct {
			Type         string                 `json:"type"`
			EnumEquality EnumEqualityRangesNode `json:"enumEquality"`
		}{Type: "enumEquality", EnumEquality: *u.enumEquality}, nil
	case "enumFilter":
		if u.enumFilter == nil {
			return nil, fmt.Errorf("field \"enumFilter\" is required")
		}
		return struct {
			Type       string               `json:"type"`
			EnumFilter EnumFilterRangesNode `json:"enumFilter"`
		}{Type: "enumFilter", EnumFilter: *u.enumFilter}, nil
	case "extrema":
		if u.extrema == nil {
			return nil, fmt.Errorf("field \"extrema\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Extrema ExtremaRangesNode `json:"extrema"`
		}{Type: "extrema", Extrema: *u.extrema}, nil
	case "intersectRange":
		if u.intersectRange == nil {
			return nil, fmt.Errorf("field \"intersectRange\" is required")
		}
		return struct {
			Type           string              `json:"type"`
			IntersectRange IntersectRangesNode `json:"intersectRange"`
		}{Type: "intersectRange", IntersectRange: *u.intersectRange}, nil
	case "literalRanges":
		if u.literalRanges == nil {
			return nil, fmt.Errorf("field \"literalRanges\" is required")
		}
		return struct {
			Type          string            `json:"type"`
			LiteralRanges LiteralRangesNode `json:"literalRanges"`
		}{Type: "literalRanges", LiteralRanges: *u.literalRanges}, nil
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return nil, fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return struct {
			Type            string                    `json:"type"`
			MinMaxThreshold MinMaxThresholdRangesNode `json:"minMaxThreshold"`
		}{Type: "minMaxThreshold", MinMaxThreshold: *u.minMaxThreshold}, nil
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Not  NotRangesNode `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	case "onChange":
		if u.onChange == nil {
			return nil, fmt.Errorf("field \"onChange\" is required")
		}
		return struct {
			Type     string             `json:"type"`
			OnChange OnChangeRangesNode `json:"onChange"`
		}{Type: "onChange", OnChange: *u.onChange}, nil
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return nil, fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return struct {
			Type                    string                       `json:"type"`
			RangeNumericAggregation RangesNumericAggregationNode `json:"rangeNumericAggregation"`
		}{Type: "rangeNumericAggregation", RangeNumericAggregation: *u.rangeNumericAggregation}, nil
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return nil, fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return struct {
			Type                      string                    `json:"type"`
			SeriesCrossoverRangesNode SeriesCrossoverRangesNode `json:"seriesCrossoverRangesNode"`
		}{Type: "seriesCrossoverRangesNode", SeriesCrossoverRangesNode: *u.seriesCrossoverRangesNode}, nil
	case "staleRange":
		if u.staleRange == nil {
			return nil, fmt.Errorf("field \"staleRange\" is required")
		}
		return struct {
			Type       string          `json:"type"`
			StaleRange StaleRangesNode `json:"staleRange"`
		}{Type: "staleRange", StaleRange: *u.staleRange}, nil
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return nil, fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return struct {
			Type               string                       `json:"type"`
			StabilityDetection StabilityDetectionRangesNode `json:"stabilityDetection"`
		}{Type: "stabilityDetection", StabilityDetection: *u.stabilityDetection}, nil
	case "threshold":
		if u.threshold == nil {
			return nil, fmt.Errorf("field \"threshold\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			Threshold ThresholdingRangesNode `json:"threshold"`
		}{Type: "threshold", Threshold: *u.threshold}, nil
	case "unionRange":
		if u.unionRange == nil {
			return nil, fmt.Errorf("field \"unionRange\" is required")
		}
		return struct {
			Type       string          `json:"type"`
			UnionRange UnionRangesNode `json:"unionRange"`
		}{Type: "unionRange", UnionRange: *u.unionRange}, nil
	case "eventSearch":
		if u.eventSearch == nil {
			return nil, fmt.Errorf("field \"eventSearch\" is required")
		}
		return struct {
			Type        string          `json:"type"`
			EventSearch EventSearchNode `json:"eventSearch"`
		}{Type: "eventSearch", EventSearch: *u.eventSearch}, nil
	case "paddedRanges":
		if u.paddedRanges == nil {
			return nil, fmt.Errorf("field \"paddedRanges\" is required")
		}
		return struct {
			Type         string           `json:"type"`
			PaddedRanges PaddedRangesNode `json:"paddedRanges"`
		}{Type: "paddedRanges", PaddedRanges: *u.paddedRanges}, nil
	}
}

func (u RangesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangesNode) UnmarshalJSON(data []byte) error {
	var deser rangesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
	case "enumEquality":
		if u.enumEquality == nil {
			return fmt.Errorf("field \"enumEquality\" is required")
		}
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
	case "extrema":
		if u.extrema == nil {
			return fmt.Errorf("field \"extrema\" is required")
		}
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
	case "eventSearch":
		if u.eventSearch == nil {
			return fmt.Errorf("field \"eventSearch\" is required")
		}
	case "paddedRanges":
		if u.paddedRanges == nil {
			return fmt.Errorf("field \"paddedRanges\" is required")
		}
	}
	return nil
}

func (u RangesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangesNode) AcceptFuncs(durationFilterFunc func(DurationFilterRangesNode) error, enumEqualityFunc func(EnumEqualityRangesNode) error, enumFilterFunc func(EnumFilterRangesNode) error, extremaFunc func(ExtremaRangesNode) error, intersectRangeFunc func(IntersectRangesNode) error, literalRangesFunc func(LiteralRangesNode) error, minMaxThresholdFunc func(MinMaxThresholdRangesNode) error, notFunc func(NotRangesNode) error, onChangeFunc func(OnChangeRangesNode) error, rangeNumericAggregationFunc func(RangesNumericAggregationNode) error, seriesCrossoverRangesNodeFunc func(SeriesCrossoverRangesNode) error, staleRangeFunc func(StaleRangesNode) error, stabilityDetectionFunc func(StabilityDetectionRangesNode) error, thresholdFunc func(ThresholdingRangesNode) error, unionRangeFunc func(UnionRangesNode) error, eventSearchFunc func(EventSearchNode) error, paddedRangesFunc func(PaddedRangesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
		return durationFilterFunc(*u.durationFilter)
	case "enumEquality":
		if u.enumEquality == nil {
			return fmt.Errorf("field \"enumEquality\" is required")
		}
		return enumEqualityFunc(*u.enumEquality)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return enumFilterFunc(*u.enumFilter)
	case "extrema":
		if u.extrema == nil {
			return fmt.Errorf("field \"extrema\" is required")
		}
		return extremaFunc(*u.extrema)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return intersectRangeFunc(*u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
		return literalRangesFunc(*u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return minMaxThresholdFunc(*u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return onChangeFunc(*u.onChange)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return rangeNumericAggregationFunc(*u.rangeNumericAggregation)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return seriesCrossoverRangesNodeFunc(*u.seriesCrossoverRangesNode)
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
		return staleRangeFunc(*u.staleRange)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return stabilityDetectionFunc(*u.stabilityDetection)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return thresholdFunc(*u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return unionRangeFunc(*u.unionRange)
	case "eventSearch":
		if u.eventSearch == nil {
			return fmt.Errorf("field \"eventSearch\" is required")
		}
		return eventSearchFunc(*u.eventSearch)
	case "paddedRanges":
		if u.paddedRanges == nil {
			return fmt.Errorf("field \"paddedRanges\" is required")
		}
		return paddedRangesFunc(*u.paddedRanges)
	}
}

func (u *RangesNode) DurationFilterNoopSuccess(DurationFilterRangesNode) error {
	return nil
}

func (u *RangesNode) EnumEqualityNoopSuccess(EnumEqualityRangesNode) error {
	return nil
}

func (u *RangesNode) EnumFilterNoopSuccess(EnumFilterRangesNode) error {
	return nil
}

func (u *RangesNode) ExtremaNoopSuccess(ExtremaRangesNode) error {
	return nil
}

func (u *RangesNode) IntersectRangeNoopSuccess(IntersectRangesNode) error {
	return nil
}

func (u *RangesNode) LiteralRangesNoopSuccess(LiteralRangesNode) error {
	return nil
}

func (u *RangesNode) MinMaxThresholdNoopSuccess(MinMaxThresholdRangesNode) error {
	return nil
}

func (u *RangesNode) NotNoopSuccess(NotRangesNode) error {
	return nil
}

func (u *RangesNode) OnChangeNoopSuccess(OnChangeRangesNode) error {
	return nil
}

func (u *RangesNode) RangeNumericAggregationNoopSuccess(RangesNumericAggregationNode) error {
	return nil
}

func (u *RangesNode) SeriesCrossoverRangesNodeNoopSuccess(SeriesCrossoverRangesNode) error {
	return nil
}

func (u *RangesNode) StaleRangeNoopSuccess(StaleRangesNode) error {
	return nil
}

func (u *RangesNode) StabilityDetectionNoopSuccess(StabilityDetectionRangesNode) error {
	return nil
}

func (u *RangesNode) ThresholdNoopSuccess(ThresholdingRangesNode) error {
	return nil
}

func (u *RangesNode) UnionRangeNoopSuccess(UnionRangesNode) error {
	return nil
}

func (u *RangesNode) EventSearchNoopSuccess(EventSearchNode) error {
	return nil
}

func (u *RangesNode) PaddedRangesNoopSuccess(PaddedRangesNode) error {
	return nil
}

func (u *RangesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangesNode) Accept(v RangesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
		return v.VisitDurationFilter(*u.durationFilter)
	case "enumEquality":
		if u.enumEquality == nil {
			return fmt.Errorf("field \"enumEquality\" is required")
		}
		return v.VisitEnumEquality(*u.enumEquality)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return v.VisitEnumFilter(*u.enumFilter)
	case "extrema":
		if u.extrema == nil {
			return fmt.Errorf("field \"extrema\" is required")
		}
		return v.VisitExtrema(*u.extrema)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return v.VisitIntersectRange(*u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
		return v.VisitLiteralRanges(*u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return v.VisitMinMaxThreshold(*u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return v.VisitOnChange(*u.onChange)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return v.VisitRangeNumericAggregation(*u.rangeNumericAggregation)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return v.VisitSeriesCrossoverRangesNode(*u.seriesCrossoverRangesNode)
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
		return v.VisitStaleRange(*u.staleRange)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return v.VisitStabilityDetection(*u.stabilityDetection)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThreshold(*u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return v.VisitUnionRange(*u.unionRange)
	case "eventSearch":
		if u.eventSearch == nil {
			return fmt.Errorf("field \"eventSearch\" is required")
		}
		return v.VisitEventSearch(*u.eventSearch)
	case "paddedRanges":
		if u.paddedRanges == nil {
			return fmt.Errorf("field \"paddedRanges\" is required")
		}
		return v.VisitPaddedRanges(*u.paddedRanges)
	}
}

type RangesNodeVisitor interface {
	VisitDurationFilter(v DurationFilterRangesNode) error
	VisitEnumEquality(v EnumEqualityRangesNode) error
	VisitEnumFilter(v EnumFilterRangesNode) error
	VisitExtrema(v ExtremaRangesNode) error
	VisitIntersectRange(v IntersectRangesNode) error
	VisitLiteralRanges(v LiteralRangesNode) error
	VisitMinMaxThreshold(v MinMaxThresholdRangesNode) error
	VisitNot(v NotRangesNode) error
	VisitOnChange(v OnChangeRangesNode) error
	VisitRangeNumericAggregation(v RangesNumericAggregationNode) error
	VisitSeriesCrossoverRangesNode(v SeriesCrossoverRangesNode) error
	VisitStaleRange(v StaleRangesNode) error
	VisitStabilityDetection(v StabilityDetectionRangesNode) error
	VisitThreshold(v ThresholdingRangesNode) error
	VisitUnionRange(v UnionRangesNode) error
	VisitEventSearch(v EventSearchNode) error
	VisitPaddedRanges(v PaddedRangesNode) error
	VisitUnknown(typeName string) error
}

func (u *RangesNode) AcceptWithContext(ctx context.Context, v RangesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
		return v.VisitDurationFilterWithContext(ctx, *u.durationFilter)
	case "enumEquality":
		if u.enumEquality == nil {
			return fmt.Errorf("field \"enumEquality\" is required")
		}
		return v.VisitEnumEqualityWithContext(ctx, *u.enumEquality)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return v.VisitEnumFilterWithContext(ctx, *u.enumFilter)
	case "extrema":
		if u.extrema == nil {
			return fmt.Errorf("field \"extrema\" is required")
		}
		return v.VisitExtremaWithContext(ctx, *u.extrema)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return v.VisitIntersectRangeWithContext(ctx, *u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
		return v.VisitLiteralRangesWithContext(ctx, *u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return v.VisitMinMaxThresholdWithContext(ctx, *u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return v.VisitOnChangeWithContext(ctx, *u.onChange)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return v.VisitRangeNumericAggregationWithContext(ctx, *u.rangeNumericAggregation)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return v.VisitSeriesCrossoverRangesNodeWithContext(ctx, *u.seriesCrossoverRangesNode)
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
		return v.VisitStaleRangeWithContext(ctx, *u.staleRange)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return v.VisitStabilityDetectionWithContext(ctx, *u.stabilityDetection)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThresholdWithContext(ctx, *u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return v.VisitUnionRangeWithContext(ctx, *u.unionRange)
	case "eventSearch":
		if u.eventSearch == nil {
			return fmt.Errorf("field \"eventSearch\" is required")
		}
		return v.VisitEventSearchWithContext(ctx, *u.eventSearch)
	case "paddedRanges":
		if u.paddedRanges == nil {
			return fmt.Errorf("field \"paddedRanges\" is required")
		}
		return v.VisitPaddedRangesWithContext(ctx, *u.paddedRanges)
	}
}

type RangesNodeVisitorWithContext interface {
	VisitDurationFilterWithContext(ctx context.Context, v DurationFilterRangesNode) error
	VisitEnumEqualityWithContext(ctx context.Context, v EnumEqualityRangesNode) error
	VisitEnumFilterWithContext(ctx context.Context, v EnumFilterRangesNode) error
	VisitExtremaWithContext(ctx context.Context, v ExtremaRangesNode) error
	VisitIntersectRangeWithContext(ctx context.Context, v IntersectRangesNode) error
	VisitLiteralRangesWithContext(ctx context.Context, v LiteralRangesNode) error
	VisitMinMaxThresholdWithContext(ctx context.Context, v MinMaxThresholdRangesNode) error
	VisitNotWithContext(ctx context.Context, v NotRangesNode) error
	VisitOnChangeWithContext(ctx context.Context, v OnChangeRangesNode) error
	VisitRangeNumericAggregationWithContext(ctx context.Context, v RangesNumericAggregationNode) error
	VisitSeriesCrossoverRangesNodeWithContext(ctx context.Context, v SeriesCrossoverRangesNode) error
	VisitStaleRangeWithContext(ctx context.Context, v StaleRangesNode) error
	VisitStabilityDetectionWithContext(ctx context.Context, v StabilityDetectionRangesNode) error
	VisitThresholdWithContext(ctx context.Context, v ThresholdingRangesNode) error
	VisitUnionRangeWithContext(ctx context.Context, v UnionRangesNode) error
	VisitEventSearchWithContext(ctx context.Context, v EventSearchNode) error
	VisitPaddedRangesWithContext(ctx context.Context, v PaddedRangesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangesNodeFromDurationFilter(v DurationFilterRangesNode) RangesNode {
	return RangesNode{typ: "durationFilter", durationFilter: &v}
}

func NewRangesNodeFromEnumEquality(v EnumEqualityRangesNode) RangesNode {
	return RangesNode{typ: "enumEquality", enumEquality: &v}
}

func NewRangesNodeFromEnumFilter(v EnumFilterRangesNode) RangesNode {
	return RangesNode{typ: "enumFilter", enumFilter: &v}
}

func NewRangesNodeFromExtrema(v ExtremaRangesNode) RangesNode {
	return RangesNode{typ: "extrema", extrema: &v}
}

func NewRangesNodeFromIntersectRange(v IntersectRangesNode) RangesNode {
	return RangesNode{typ: "intersectRange", intersectRange: &v}
}

func NewRangesNodeFromLiteralRanges(v LiteralRangesNode) RangesNode {
	return RangesNode{typ: "literalRanges", literalRanges: &v}
}

func NewRangesNodeFromMinMaxThreshold(v MinMaxThresholdRangesNode) RangesNode {
	return RangesNode{typ: "minMaxThreshold", minMaxThreshold: &v}
}

func NewRangesNodeFromNot(v NotRangesNode) RangesNode {
	return RangesNode{typ: "not", not: &v}
}

func NewRangesNodeFromOnChange(v OnChangeRangesNode) RangesNode {
	return RangesNode{typ: "onChange", onChange: &v}
}

func NewRangesNodeFromRangeNumericAggregation(v RangesNumericAggregationNode) RangesNode {
	return RangesNode{typ: "rangeNumericAggregation", rangeNumericAggregation: &v}
}

func NewRangesNodeFromSeriesCrossoverRangesNode(v SeriesCrossoverRangesNode) RangesNode {
	return RangesNode{typ: "seriesCrossoverRangesNode", seriesCrossoverRangesNode: &v}
}

func NewRangesNodeFromStaleRange(v StaleRangesNode) RangesNode {
	return RangesNode{typ: "staleRange", staleRange: &v}
}

func NewRangesNodeFromStabilityDetection(v StabilityDetectionRangesNode) RangesNode {
	return RangesNode{typ: "stabilityDetection", stabilityDetection: &v}
}

func NewRangesNodeFromThreshold(v ThresholdingRangesNode) RangesNode {
	return RangesNode{typ: "threshold", threshold: &v}
}

func NewRangesNodeFromUnionRange(v UnionRangesNode) RangesNode {
	return RangesNode{typ: "unionRange", unionRange: &v}
}

func NewRangesNodeFromEventSearch(v EventSearchNode) RangesNode {
	return RangesNode{typ: "eventSearch", eventSearch: &v}
}

func NewRangesNodeFromPaddedRanges(v PaddedRangesNode) RangesNode {
	return RangesNode{typ: "paddedRanges", paddedRanges: &v}
}

type ResampleInterpolationConfiguration struct {
	typ                                                    string
	forwardFillResampleInterpolationConfiguration          *ForwardFillResampleInterpolationConfiguration
	constantDefaultValueResampleInterpolationConfiguration *ConstantDefaultValueResampleInterpolationConfiguration
}

type resampleInterpolationConfigurationDeserializer struct {
	Type                                                   string                                                  `json:"type"`
	ForwardFillResampleInterpolationConfiguration          *ForwardFillResampleInterpolationConfiguration          `json:"forwardFillResampleInterpolationConfiguration"`
	ConstantDefaultValueResampleInterpolationConfiguration *ConstantDefaultValueResampleInterpolationConfiguration `json:"constantDefaultValueResampleInterpolationConfiguration"`
}

func (u *resampleInterpolationConfigurationDeserializer) toStruct() ResampleInterpolationConfiguration {
	return ResampleInterpolationConfiguration{typ: u.Type, forwardFillResampleInterpolationConfiguration: u.ForwardFillResampleInterpolationConfiguration, constantDefaultValueResampleInterpolationConfiguration: u.ConstantDefaultValueResampleInterpolationConfiguration}
}

func (u *ResampleInterpolationConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return nil, fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return struct {
			Type                                          string                                        `json:"type"`
			ForwardFillResampleInterpolationConfiguration ForwardFillResampleInterpolationConfiguration `json:"forwardFillResampleInterpolationConfiguration"`
		}{Type: "forwardFillResampleInterpolationConfiguration", ForwardFillResampleInterpolationConfiguration: *u.forwardFillResampleInterpolationConfiguration}, nil
	case "constantDefaultValueResampleInterpolationConfiguration":
		if u.constantDefaultValueResampleInterpolationConfiguration == nil {
			return nil, fmt.Errorf("field \"constantDefaultValueResampleInterpolationConfiguration\" is required")
		}
		return struct {
			Type                                                   string                                                 `json:"type"`
			ConstantDefaultValueResampleInterpolationConfiguration ConstantDefaultValueResampleInterpolationConfiguration `json:"constantDefaultValueResampleInterpolationConfiguration"`
		}{Type: "constantDefaultValueResampleInterpolationConfiguration", ConstantDefaultValueResampleInterpolationConfiguration: *u.constantDefaultValueResampleInterpolationConfiguration}, nil
	}
}

func (u ResampleInterpolationConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ResampleInterpolationConfiguration) UnmarshalJSON(data []byte) error {
	var deser resampleInterpolationConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
	case "constantDefaultValueResampleInterpolationConfiguration":
		if u.constantDefaultValueResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantDefaultValueResampleInterpolationConfiguration\" is required")
		}
	}
	return nil
}

func (u ResampleInterpolationConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ResampleInterpolationConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ResampleInterpolationConfiguration) AcceptFuncs(forwardFillResampleInterpolationConfigurationFunc func(ForwardFillResampleInterpolationConfiguration) error, constantDefaultValueResampleInterpolationConfigurationFunc func(ConstantDefaultValueResampleInterpolationConfiguration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return forwardFillResampleInterpolationConfigurationFunc(*u.forwardFillResampleInterpolationConfiguration)
	case "constantDefaultValueResampleInterpolationConfiguration":
		if u.constantDefaultValueResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantDefaultValueResampleInterpolationConfiguration\" is required")
		}
		return constantDefaultValueResampleInterpolationConfigurationFunc(*u.constantDefaultValueResampleInterpolationConfiguration)
	}
}

func (u *ResampleInterpolationConfiguration) ForwardFillResampleInterpolationConfigurationNoopSuccess(ForwardFillResampleInterpolationConfiguration) error {
	return nil
}

func (u *ResampleInterpolationConfiguration) ConstantDefaultValueResampleInterpolationConfigurationNoopSuccess(ConstantDefaultValueResampleInterpolationConfiguration) error {
	return nil
}

func (u *ResampleInterpolationConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ResampleInterpolationConfiguration) Accept(v ResampleInterpolationConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return v.VisitForwardFillResampleInterpolationConfiguration(*u.forwardFillResampleInterpolationConfiguration)
	case "constantDefaultValueResampleInterpolationConfiguration":
		if u.constantDefaultValueResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantDefaultValueResampleInterpolationConfiguration\" is required")
		}
		return v.VisitConstantDefaultValueResampleInterpolationConfiguration(*u.constantDefaultValueResampleInterpolationConfiguration)
	}
}

type ResampleInterpolationConfigurationVisitor interface {
	VisitForwardFillResampleInterpolationConfiguration(v ForwardFillResampleInterpolationConfiguration) error
	VisitConstantDefaultValueResampleInterpolationConfiguration(v ConstantDefaultValueResampleInterpolationConfiguration) error
	VisitUnknown(typeName string) error
}

func (u *ResampleInterpolationConfiguration) AcceptWithContext(ctx context.Context, v ResampleInterpolationConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return v.VisitForwardFillResampleInterpolationConfigurationWithContext(ctx, *u.forwardFillResampleInterpolationConfiguration)
	case "constantDefaultValueResampleInterpolationConfiguration":
		if u.constantDefaultValueResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantDefaultValueResampleInterpolationConfiguration\" is required")
		}
		return v.VisitConstantDefaultValueResampleInterpolationConfigurationWithContext(ctx, *u.constantDefaultValueResampleInterpolationConfiguration)
	}
}

type ResampleInterpolationConfigurationVisitorWithContext interface {
	VisitForwardFillResampleInterpolationConfigurationWithContext(ctx context.Context, v ForwardFillResampleInterpolationConfiguration) error
	VisitConstantDefaultValueResampleInterpolationConfigurationWithContext(ctx context.Context, v ConstantDefaultValueResampleInterpolationConfiguration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewResampleInterpolationConfigurationFromForwardFillResampleInterpolationConfiguration(v ForwardFillResampleInterpolationConfiguration) ResampleInterpolationConfiguration {
	return ResampleInterpolationConfiguration{typ: "forwardFillResampleInterpolationConfiguration", forwardFillResampleInterpolationConfiguration: &v}
}

func NewResampleInterpolationConfigurationFromConstantDefaultValueResampleInterpolationConfiguration(v ConstantDefaultValueResampleInterpolationConfiguration) ResampleInterpolationConfiguration {
	return ResampleInterpolationConfiguration{typ: "constantDefaultValueResampleInterpolationConfiguration", constantDefaultValueResampleInterpolationConfiguration: &v}
}

type ResampleInterpolationConstantDefaultValue struct {
	typ     string
	numeric *float64
	enum    *string
}

type resampleInterpolationConstantDefaultValueDeserializer struct {
	Type    string   `json:"type"`
	Numeric *float64 `json:"numeric"`
	Enum    *string  `json:"enum"`
}

func (u *resampleInterpolationConstantDefaultValueDeserializer) toStruct() ResampleInterpolationConstantDefaultValue {
	return ResampleInterpolationConstantDefaultValue{typ: u.Type, numeric: u.Numeric, enum: u.Enum}
}

func (u *ResampleInterpolationConstantDefaultValue) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Numeric float64 `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string `json:"type"`
			Enum string `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	}
}

func (u ResampleInterpolationConstantDefaultValue) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ResampleInterpolationConstantDefaultValue) UnmarshalJSON(data []byte) error {
	var deser resampleInterpolationConstantDefaultValueDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	}
	return nil
}

func (u ResampleInterpolationConstantDefaultValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ResampleInterpolationConstantDefaultValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ResampleInterpolationConstantDefaultValue) AcceptFuncs(numericFunc func(float64) error, enumFunc func(string) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	}
}

func (u *ResampleInterpolationConstantDefaultValue) NumericNoopSuccess(float64) error {
	return nil
}

func (u *ResampleInterpolationConstantDefaultValue) EnumNoopSuccess(string) error {
	return nil
}

func (u *ResampleInterpolationConstantDefaultValue) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ResampleInterpolationConstantDefaultValue) Accept(v ResampleInterpolationConstantDefaultValueVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	}
}

type ResampleInterpolationConstantDefaultValueVisitor interface {
	VisitNumeric(v float64) error
	VisitEnum(v string) error
	VisitUnknown(typeName string) error
}

func (u *ResampleInterpolationConstantDefaultValue) AcceptWithContext(ctx context.Context, v ResampleInterpolationConstantDefaultValueVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	}
}

type ResampleInterpolationConstantDefaultValueVisitorWithContext interface {
	VisitNumericWithContext(ctx context.Context, v float64) error
	VisitEnumWithContext(ctx context.Context, v string) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewResampleInterpolationConstantDefaultValueFromNumeric(v float64) ResampleInterpolationConstantDefaultValue {
	return ResampleInterpolationConstantDefaultValue{typ: "numeric", numeric: &v}
}

func NewResampleInterpolationConstantDefaultValueFromEnum(v string) ResampleInterpolationConstantDefaultValue {
	return ResampleInterpolationConstantDefaultValue{typ: "enum", enum: &v}
}

type ResolvedNode struct {
	typ         string
	ranges      *SummarizeRangesNode
	series      *SummarizeSeriesNode
	value       *SelectValueNode
	cartesian   *SummarizeCartesianNode
	cartesian3d *SummarizeCartesian3dNode
	frequency   *FrequencyDomainNode
	frequencyV2 *FrequencyDomainNodeV2
	histogram   *HistogramNode
	curve       *CurveFitNode
}

type resolvedNodeDeserializer struct {
	Type        string                    `json:"type"`
	Ranges      *SummarizeRangesNode      `json:"ranges"`
	Series      *SummarizeSeriesNode      `json:"series"`
	Value       *SelectValueNode          `json:"value"`
	Cartesian   *SummarizeCartesianNode   `json:"cartesian"`
	Cartesian3d *SummarizeCartesian3dNode `json:"cartesian3d"`
	Frequency   *FrequencyDomainNode      `json:"frequency"`
	FrequencyV2 *FrequencyDomainNodeV2    `json:"frequencyV2"`
	Histogram   *HistogramNode            `json:"histogram"`
	Curve       *CurveFitNode             `json:"curve"`
}

func (u *resolvedNodeDeserializer) toStruct() ResolvedNode {
	return ResolvedNode{typ: u.Type, ranges: u.Ranges, series: u.Series, value: u.Value, cartesian: u.Cartesian, cartesian3d: u.Cartesian3d, frequency: u.Frequency, frequencyV2: u.FrequencyV2, histogram: u.Histogram, curve: u.Curve}
}

func (u *ResolvedNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "ranges":
		if u.ranges == nil {
			return nil, fmt.Errorf("field \"ranges\" is required")
		}
		return struct {
			Type   string              `json:"type"`
			Ranges SummarizeRangesNode `json:"ranges"`
		}{Type: "ranges", Ranges: *u.ranges}, nil
	case "series":
		if u.series == nil {
			return nil, fmt.Errorf("field \"series\" is required")
		}
		return struct {
			Type   string              `json:"type"`
			Series SummarizeSeriesNode `json:"series"`
		}{Type: "series", Series: *u.series}, nil
	case "value":
		if u.value == nil {
			return nil, fmt.Errorf("field \"value\" is required")
		}
		return struct {
			Type  string          `json:"type"`
			Value SelectValueNode `json:"value"`
		}{Type: "value", Value: *u.value}, nil
	case "cartesian":
		if u.cartesian == nil {
			return nil, fmt.Errorf("field \"cartesian\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			Cartesian SummarizeCartesianNode `json:"cartesian"`
		}{Type: "cartesian", Cartesian: *u.cartesian}, nil
	case "cartesian3d":
		if u.cartesian3d == nil {
			return nil, fmt.Errorf("field \"cartesian3d\" is required")
		}
		return struct {
			Type        string                   `json:"type"`
			Cartesian3d SummarizeCartesian3dNode `json:"cartesian3d"`
		}{Type: "cartesian3d", Cartesian3d: *u.cartesian3d}, nil
	case "frequency":
		if u.frequency == nil {
			return nil, fmt.Errorf("field \"frequency\" is required")
		}
		return struct {
			Type      string              `json:"type"`
			Frequency FrequencyDomainNode `json:"frequency"`
		}{Type: "frequency", Frequency: *u.frequency}, nil
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return nil, fmt.Errorf("field \"frequencyV2\" is required")
		}
		return struct {
			Type        string                `json:"type"`
			FrequencyV2 FrequencyDomainNodeV2 `json:"frequencyV2"`
		}{Type: "frequencyV2", FrequencyV2: *u.frequencyV2}, nil
	case "histogram":
		if u.histogram == nil {
			return nil, fmt.Errorf("field \"histogram\" is required")
		}
		return struct {
			Type      string        `json:"type"`
			Histogram HistogramNode `json:"histogram"`
		}{Type: "histogram", Histogram: *u.histogram}, nil
	case "curve":
		if u.curve == nil {
			return nil, fmt.Errorf("field \"curve\" is required")
		}
		return struct {
			Type  string       `json:"type"`
			Curve CurveFitNode `json:"curve"`
		}{Type: "curve", Curve: *u.curve}, nil
	}
}

func (u ResolvedNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ResolvedNode) UnmarshalJSON(data []byte) error {
	var deser resolvedNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return fmt.Errorf("field \"frequencyV2\" is required")
		}
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
	}
	return nil
}

func (u ResolvedNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ResolvedNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ResolvedNode) AcceptFuncs(rangesFunc func(SummarizeRangesNode) error, seriesFunc func(SummarizeSeriesNode) error, valueFunc func(SelectValueNode) error, cartesianFunc func(SummarizeCartesianNode) error, cartesian3dFunc func(SummarizeCartesian3dNode) error, frequencyFunc func(FrequencyDomainNode) error, frequencyV2Func func(FrequencyDomainNodeV2) error, histogramFunc func(HistogramNode) error, curveFunc func(CurveFitNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return cartesian3dFunc(*u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return frequencyFunc(*u.frequency)
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return fmt.Errorf("field \"frequencyV2\" is required")
		}
		return frequencyV2Func(*u.frequencyV2)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return histogramFunc(*u.histogram)
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
		return curveFunc(*u.curve)
	}
}

func (u *ResolvedNode) RangesNoopSuccess(SummarizeRangesNode) error {
	return nil
}

func (u *ResolvedNode) SeriesNoopSuccess(SummarizeSeriesNode) error {
	return nil
}

func (u *ResolvedNode) ValueNoopSuccess(SelectValueNode) error {
	return nil
}

func (u *ResolvedNode) CartesianNoopSuccess(SummarizeCartesianNode) error {
	return nil
}

func (u *ResolvedNode) Cartesian3dNoopSuccess(SummarizeCartesian3dNode) error {
	return nil
}

func (u *ResolvedNode) FrequencyNoopSuccess(FrequencyDomainNode) error {
	return nil
}

func (u *ResolvedNode) FrequencyV2NoopSuccess(FrequencyDomainNodeV2) error {
	return nil
}

func (u *ResolvedNode) HistogramNoopSuccess(HistogramNode) error {
	return nil
}

func (u *ResolvedNode) CurveNoopSuccess(CurveFitNode) error {
	return nil
}

func (u *ResolvedNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ResolvedNode) Accept(v ResolvedNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(*u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(*u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(*u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3d(*u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequency(*u.frequency)
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return fmt.Errorf("field \"frequencyV2\" is required")
		}
		return v.VisitFrequencyV2(*u.frequencyV2)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogram(*u.histogram)
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
		return v.VisitCurve(*u.curve)
	}
}

type ResolvedNodeVisitor interface {
	VisitRanges(v SummarizeRangesNode) error
	VisitSeries(v SummarizeSeriesNode) error
	VisitValue(v SelectValueNode) error
	VisitCartesian(v SummarizeCartesianNode) error
	VisitCartesian3d(v SummarizeCartesian3dNode) error
	VisitFrequency(v FrequencyDomainNode) error
	VisitFrequencyV2(v FrequencyDomainNodeV2) error
	VisitHistogram(v HistogramNode) error
	VisitCurve(v CurveFitNode) error
	VisitUnknown(typeName string) error
}

func (u *ResolvedNode) AcceptWithContext(ctx context.Context, v ResolvedNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRangesWithContext(ctx, *u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeriesWithContext(ctx, *u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValueWithContext(ctx, *u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesianWithContext(ctx, *u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3dWithContext(ctx, *u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequencyWithContext(ctx, *u.frequency)
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return fmt.Errorf("field \"frequencyV2\" is required")
		}
		return v.VisitFrequencyV2WithContext(ctx, *u.frequencyV2)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogramWithContext(ctx, *u.histogram)
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
		return v.VisitCurveWithContext(ctx, *u.curve)
	}
}

type ResolvedNodeVisitorWithContext interface {
	VisitRangesWithContext(ctx context.Context, v SummarizeRangesNode) error
	VisitSeriesWithContext(ctx context.Context, v SummarizeSeriesNode) error
	VisitValueWithContext(ctx context.Context, v SelectValueNode) error
	VisitCartesianWithContext(ctx context.Context, v SummarizeCartesianNode) error
	VisitCartesian3dWithContext(ctx context.Context, v SummarizeCartesian3dNode) error
	VisitFrequencyWithContext(ctx context.Context, v FrequencyDomainNode) error
	VisitFrequencyV2WithContext(ctx context.Context, v FrequencyDomainNodeV2) error
	VisitHistogramWithContext(ctx context.Context, v HistogramNode) error
	VisitCurveWithContext(ctx context.Context, v CurveFitNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewResolvedNodeFromRanges(v SummarizeRangesNode) ResolvedNode {
	return ResolvedNode{typ: "ranges", ranges: &v}
}

func NewResolvedNodeFromSeries(v SummarizeSeriesNode) ResolvedNode {
	return ResolvedNode{typ: "series", series: &v}
}

func NewResolvedNodeFromValue(v SelectValueNode) ResolvedNode {
	return ResolvedNode{typ: "value", value: &v}
}

func NewResolvedNodeFromCartesian(v SummarizeCartesianNode) ResolvedNode {
	return ResolvedNode{typ: "cartesian", cartesian: &v}
}

func NewResolvedNodeFromCartesian3d(v SummarizeCartesian3dNode) ResolvedNode {
	return ResolvedNode{typ: "cartesian3d", cartesian3d: &v}
}

func NewResolvedNodeFromFrequency(v FrequencyDomainNode) ResolvedNode {
	return ResolvedNode{typ: "frequency", frequency: &v}
}

func NewResolvedNodeFromFrequencyV2(v FrequencyDomainNodeV2) ResolvedNode {
	return ResolvedNode{typ: "frequencyV2", frequencyV2: &v}
}

func NewResolvedNodeFromHistogram(v HistogramNode) ResolvedNode {
	return ResolvedNode{typ: "histogram", histogram: &v}
}

func NewResolvedNodeFromCurve(v CurveFitNode) ResolvedNode {
	return ResolvedNode{typ: "curve", curve: &v}
}

type SelectValueNode struct {
	typ             string
	firstPoint      *SeriesNode
	firstValuePoint *SeriesNode
	firstRange      *RangesNode
	lastPoint       *SeriesNode
	lastValuePoint  *SeriesNode
	lastRange       *RangesNode
}

type selectValueNodeDeserializer struct {
	Type            string      `json:"type"`
	FirstPoint      *SeriesNode `json:"firstPoint"`
	FirstValuePoint *SeriesNode `json:"firstValuePoint"`
	FirstRange      *RangesNode `json:"firstRange"`
	LastPoint       *SeriesNode `json:"lastPoint"`
	LastValuePoint  *SeriesNode `json:"lastValuePoint"`
	LastRange       *RangesNode `json:"lastRange"`
}

func (u *selectValueNodeDeserializer) toStruct() SelectValueNode {
	return SelectValueNode{typ: u.Type, firstPoint: u.FirstPoint, firstValuePoint: u.FirstValuePoint, firstRange: u.FirstRange, lastPoint: u.LastPoint, lastValuePoint: u.LastValuePoint, lastRange: u.LastRange}
}

func (u *SelectValueNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return nil, fmt.Errorf("field \"firstPoint\" is required")
		}
		return struct {
			Type       string     `json:"type"`
			FirstPoint SeriesNode `json:"firstPoint"`
		}{Type: "firstPoint", FirstPoint: *u.firstPoint}, nil
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return nil, fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return struct {
			Type            string     `json:"type"`
			FirstValuePoint SeriesNode `json:"firstValuePoint"`
		}{Type: "firstValuePoint", FirstValuePoint: *u.firstValuePoint}, nil
	case "firstRange":
		if u.firstRange == nil {
			return nil, fmt.Errorf("field \"firstRange\" is required")
		}
		return struct {
			Type       string     `json:"type"`
			FirstRange RangesNode `json:"firstRange"`
		}{Type: "firstRange", FirstRange: *u.firstRange}, nil
	case "lastPoint":
		if u.lastPoint == nil {
			return nil, fmt.Errorf("field \"lastPoint\" is required")
		}
		return struct {
			Type      string     `json:"type"`
			LastPoint SeriesNode `json:"lastPoint"`
		}{Type: "lastPoint", LastPoint: *u.lastPoint}, nil
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return nil, fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return struct {
			Type           string     `json:"type"`
			LastValuePoint SeriesNode `json:"lastValuePoint"`
		}{Type: "lastValuePoint", LastValuePoint: *u.lastValuePoint}, nil
	case "lastRange":
		if u.lastRange == nil {
			return nil, fmt.Errorf("field \"lastRange\" is required")
		}
		return struct {
			Type      string     `json:"type"`
			LastRange RangesNode `json:"lastRange"`
		}{Type: "lastRange", LastRange: *u.lastRange}, nil
	}
}

func (u SelectValueNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SelectValueNode) UnmarshalJSON(data []byte) error {
	var deser selectValueNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return fmt.Errorf("field \"firstValuePoint\" is required")
		}
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return fmt.Errorf("field \"lastValuePoint\" is required")
		}
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
	}
	return nil
}

func (u SelectValueNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SelectValueNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SelectValueNode) AcceptFuncs(firstPointFunc func(SeriesNode) error, firstValuePointFunc func(SeriesNode) error, firstRangeFunc func(RangesNode) error, lastPointFunc func(SeriesNode) error, lastValuePointFunc func(SeriesNode) error, lastRangeFunc func(RangesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return firstPointFunc(*u.firstPoint)
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return firstValuePointFunc(*u.firstValuePoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return firstRangeFunc(*u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
		return lastPointFunc(*u.lastPoint)
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return lastValuePointFunc(*u.lastValuePoint)
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
		return lastRangeFunc(*u.lastRange)
	}
}

func (u *SelectValueNode) FirstPointNoopSuccess(SeriesNode) error {
	return nil
}

func (u *SelectValueNode) FirstValuePointNoopSuccess(SeriesNode) error {
	return nil
}

func (u *SelectValueNode) FirstRangeNoopSuccess(RangesNode) error {
	return nil
}

func (u *SelectValueNode) LastPointNoopSuccess(SeriesNode) error {
	return nil
}

func (u *SelectValueNode) LastValuePointNoopSuccess(SeriesNode) error {
	return nil
}

func (u *SelectValueNode) LastRangeNoopSuccess(RangesNode) error {
	return nil
}

func (u *SelectValueNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SelectValueNode) Accept(v SelectValueNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return v.VisitFirstPoint(*u.firstPoint)
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return v.VisitFirstValuePoint(*u.firstValuePoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return v.VisitFirstRange(*u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
		return v.VisitLastPoint(*u.lastPoint)
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return v.VisitLastValuePoint(*u.lastValuePoint)
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
		return v.VisitLastRange(*u.lastRange)
	}
}

type SelectValueNodeVisitor interface {
	VisitFirstPoint(v SeriesNode) error
	VisitFirstValuePoint(v SeriesNode) error
	VisitFirstRange(v RangesNode) error
	VisitLastPoint(v SeriesNode) error
	VisitLastValuePoint(v SeriesNode) error
	VisitLastRange(v RangesNode) error
	VisitUnknown(typeName string) error
}

func (u *SelectValueNode) AcceptWithContext(ctx context.Context, v SelectValueNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return v.VisitFirstPointWithContext(ctx, *u.firstPoint)
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return v.VisitFirstValuePointWithContext(ctx, *u.firstValuePoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return v.VisitFirstRangeWithContext(ctx, *u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
		return v.VisitLastPointWithContext(ctx, *u.lastPoint)
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return v.VisitLastValuePointWithContext(ctx, *u.lastValuePoint)
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
		return v.VisitLastRangeWithContext(ctx, *u.lastRange)
	}
}

type SelectValueNodeVisitorWithContext interface {
	VisitFirstPointWithContext(ctx context.Context, v SeriesNode) error
	VisitFirstValuePointWithContext(ctx context.Context, v SeriesNode) error
	VisitFirstRangeWithContext(ctx context.Context, v RangesNode) error
	VisitLastPointWithContext(ctx context.Context, v SeriesNode) error
	VisitLastValuePointWithContext(ctx context.Context, v SeriesNode) error
	VisitLastRangeWithContext(ctx context.Context, v RangesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSelectValueNodeFromFirstPoint(v SeriesNode) SelectValueNode {
	return SelectValueNode{typ: "firstPoint", firstPoint: &v}
}

func NewSelectValueNodeFromFirstValuePoint(v SeriesNode) SelectValueNode {
	return SelectValueNode{typ: "firstValuePoint", firstValuePoint: &v}
}

func NewSelectValueNodeFromFirstRange(v RangesNode) SelectValueNode {
	return SelectValueNode{typ: "firstRange", firstRange: &v}
}

func NewSelectValueNodeFromLastPoint(v SeriesNode) SelectValueNode {
	return SelectValueNode{typ: "lastPoint", lastPoint: &v}
}

func NewSelectValueNodeFromLastValuePoint(v SeriesNode) SelectValueNode {
	return SelectValueNode{typ: "lastValuePoint", lastValuePoint: &v}
}

func NewSelectValueNodeFromLastRange(v RangesNode) SelectValueNode {
	return SelectValueNode{typ: "lastRange", lastRange: &v}
}

type SeriesNode struct {
	typ     string
	raw     *RawUntypedSeriesNode
	enum    *EnumSeriesNode
	numeric *NumericSeriesNode
	log     *LogSeriesNode
	array   *ArraySeriesNode
	struct_ *StructSeriesNode
}

type seriesNodeDeserializer struct {
	Type    string                `json:"type"`
	Raw     *RawUntypedSeriesNode `json:"raw"`
	Enum    *EnumSeriesNode       `json:"enum"`
	Numeric *NumericSeriesNode    `json:"numeric"`
	Log     *LogSeriesNode        `json:"log"`
	Array   *ArraySeriesNode      `json:"array"`
	Struct  *StructSeriesNode     `json:"struct"`
}

func (u *seriesNodeDeserializer) toStruct() SeriesNode {
	return SeriesNode{typ: u.Type, raw: u.Raw, enum: u.Enum, numeric: u.Numeric, log: u.Log, array: u.Array, struct_: u.Struct}
}

func (u *SeriesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Raw  RawUntypedSeriesNode `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string         `json:"type"`
			Enum EnumSeriesNode `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Numeric NumericSeriesNode `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "log":
		if u.log == nil {
			return nil, fmt.Errorf("field \"log\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Log  LogSeriesNode `json:"log"`
		}{Type: "log", Log: *u.log}, nil
	case "array":
		if u.array == nil {
			return nil, fmt.Errorf("field \"array\" is required")
		}
		return struct {
			Type  string          `json:"type"`
			Array ArraySeriesNode `json:"array"`
		}{Type: "array", Array: *u.array}, nil
	case "struct":
		if u.struct_ == nil {
			return nil, fmt.Errorf("field \"struct\" is required")
		}
		return struct {
			Type   string           `json:"type"`
			Struct StructSeriesNode `json:"struct"`
		}{Type: "struct", Struct: *u.struct_}, nil
	}
}

func (u SeriesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SeriesNode) UnmarshalJSON(data []byte) error {
	var deser seriesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
	}
	return nil
}

func (u SeriesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SeriesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SeriesNode) AcceptFuncs(rawFunc func(RawUntypedSeriesNode) error, enumFunc func(EnumSeriesNode) error, numericFunc func(NumericSeriesNode) error, logFunc func(LogSeriesNode) error, arrayFunc func(ArraySeriesNode) error, struct_Func func(StructSeriesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return struct_Func(*u.struct_)
	}
}

func (u *SeriesNode) RawNoopSuccess(RawUntypedSeriesNode) error {
	return nil
}

func (u *SeriesNode) EnumNoopSuccess(EnumSeriesNode) error {
	return nil
}

func (u *SeriesNode) NumericNoopSuccess(NumericSeriesNode) error {
	return nil
}

func (u *SeriesNode) LogNoopSuccess(LogSeriesNode) error {
	return nil
}

func (u *SeriesNode) ArrayNoopSuccess(ArraySeriesNode) error {
	return nil
}

func (u *SeriesNode) StructNoopSuccess(StructSeriesNode) error {
	return nil
}

func (u *SeriesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SeriesNode) Accept(v SeriesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(*u.log)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(*u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStruct(*u.struct_)
	}
}

type SeriesNodeVisitor interface {
	VisitRaw(v RawUntypedSeriesNode) error
	VisitEnum(v EnumSeriesNode) error
	VisitNumeric(v NumericSeriesNode) error
	VisitLog(v LogSeriesNode) error
	VisitArray(v ArraySeriesNode) error
	VisitStruct(v StructSeriesNode) error
	VisitUnknown(typeName string) error
}

func (u *SeriesNode) AcceptWithContext(ctx context.Context, v SeriesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLogWithContext(ctx, *u.log)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArrayWithContext(ctx, *u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStructWithContext(ctx, *u.struct_)
	}
}

type SeriesNodeVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v RawUntypedSeriesNode) error
	VisitEnumWithContext(ctx context.Context, v EnumSeriesNode) error
	VisitNumericWithContext(ctx context.Context, v NumericSeriesNode) error
	VisitLogWithContext(ctx context.Context, v LogSeriesNode) error
	VisitArrayWithContext(ctx context.Context, v ArraySeriesNode) error
	VisitStructWithContext(ctx context.Context, v StructSeriesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSeriesNodeFromRaw(v RawUntypedSeriesNode) SeriesNode {
	return SeriesNode{typ: "raw", raw: &v}
}

func NewSeriesNodeFromEnum(v EnumSeriesNode) SeriesNode {
	return SeriesNode{typ: "enum", enum: &v}
}

func NewSeriesNodeFromNumeric(v NumericSeriesNode) SeriesNode {
	return SeriesNode{typ: "numeric", numeric: &v}
}

func NewSeriesNodeFromLog(v LogSeriesNode) SeriesNode {
	return SeriesNode{typ: "log", log: &v}
}

func NewSeriesNodeFromArray(v ArraySeriesNode) SeriesNode {
	return SeriesNode{typ: "array", array: &v}
}

func NewSeriesNodeFromStruct(v StructSeriesNode) SeriesNode {
	return SeriesNode{typ: "struct", struct_: &v}
}

type SignalFilterConfiguration struct {
	typ      string
	lowPass  *LowPassConfiguration
	highPass *HighPassConfiguration
	bandPass *BandPassConfiguration
	bandStop *BandStopConfiguration
}

type signalFilterConfigurationDeserializer struct {
	Type     string                 `json:"type"`
	LowPass  *LowPassConfiguration  `json:"lowPass"`
	HighPass *HighPassConfiguration `json:"highPass"`
	BandPass *BandPassConfiguration `json:"bandPass"`
	BandStop *BandStopConfiguration `json:"bandStop"`
}

func (u *signalFilterConfigurationDeserializer) toStruct() SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: u.Type, lowPass: u.LowPass, highPass: u.HighPass, bandPass: u.BandPass, bandStop: u.BandStop}
}

func (u *SignalFilterConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return nil, fmt.Errorf("field \"lowPass\" is required")
		}
		return struct {
			Type    string               `json:"type"`
			LowPass LowPassConfiguration `json:"lowPass"`
		}{Type: "lowPass", LowPass: *u.lowPass}, nil
	case "highPass":
		if u.highPass == nil {
			return nil, fmt.Errorf("field \"highPass\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			HighPass HighPassConfiguration `json:"highPass"`
		}{Type: "highPass", HighPass: *u.highPass}, nil
	case "bandPass":
		if u.bandPass == nil {
			return nil, fmt.Errorf("field \"bandPass\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			BandPass BandPassConfiguration `json:"bandPass"`
		}{Type: "bandPass", BandPass: *u.bandPass}, nil
	case "bandStop":
		if u.bandStop == nil {
			return nil, fmt.Errorf("field \"bandStop\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			BandStop BandStopConfiguration `json:"bandStop"`
		}{Type: "bandStop", BandStop: *u.bandStop}, nil
	}
}

func (u SignalFilterConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SignalFilterConfiguration) UnmarshalJSON(data []byte) error {
	var deser signalFilterConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
	}
	return nil
}

func (u SignalFilterConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SignalFilterConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SignalFilterConfiguration) AcceptFuncs(lowPassFunc func(LowPassConfiguration) error, highPassFunc func(HighPassConfiguration) error, bandPassFunc func(BandPassConfiguration) error, bandStopFunc func(BandStopConfiguration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
		return lowPassFunc(*u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
		return highPassFunc(*u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
		return bandPassFunc(*u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
		return bandStopFunc(*u.bandStop)
	}
}

func (u *SignalFilterConfiguration) LowPassNoopSuccess(LowPassConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) HighPassNoopSuccess(HighPassConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) BandPassNoopSuccess(BandPassConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) BandStopNoopSuccess(BandStopConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SignalFilterConfiguration) Accept(v SignalFilterConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
		return v.VisitLowPass(*u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
		return v.VisitHighPass(*u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
		return v.VisitBandPass(*u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
		return v.VisitBandStop(*u.bandStop)
	}
}

type SignalFilterConfigurationVisitor interface {
	VisitLowPass(v LowPassConfiguration) error
	VisitHighPass(v HighPassConfiguration) error
	VisitBandPass(v BandPassConfiguration) error
	VisitBandStop(v BandStopConfiguration) error
	VisitUnknown(typeName string) error
}

func (u *SignalFilterConfiguration) AcceptWithContext(ctx context.Context, v SignalFilterConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
		return v.VisitLowPassWithContext(ctx, *u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
		return v.VisitHighPassWithContext(ctx, *u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
		return v.VisitBandPassWithContext(ctx, *u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
		return v.VisitBandStopWithContext(ctx, *u.bandStop)
	}
}

type SignalFilterConfigurationVisitorWithContext interface {
	VisitLowPassWithContext(ctx context.Context, v LowPassConfiguration) error
	VisitHighPassWithContext(ctx context.Context, v HighPassConfiguration) error
	VisitBandPassWithContext(ctx context.Context, v BandPassConfiguration) error
	VisitBandStopWithContext(ctx context.Context, v BandStopConfiguration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSignalFilterConfigurationFromLowPass(v LowPassConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "lowPass", lowPass: &v}
}

func NewSignalFilterConfigurationFromHighPass(v HighPassConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "highPass", highPass: &v}
}

func NewSignalFilterConfigurationFromBandPass(v BandPassConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "bandPass", bandPass: &v}
}

func NewSignalFilterConfigurationFromBandStop(v BandStopConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "bandStop", bandStop: &v}
}

type StorageLocator struct {
	typ      string
	nominal  *NominalStorageLocator
	external *api1.LogicalSeries
}

type storageLocatorDeserializer struct {
	Type     string                 `json:"type"`
	Nominal  *NominalStorageLocator `json:"nominal"`
	External *api1.LogicalSeries    `json:"external"`
}

func (u *storageLocatorDeserializer) toStruct() StorageLocator {
	return StorageLocator{typ: u.Type, nominal: u.Nominal, external: u.External}
}

func (u *StorageLocator) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "nominal":
		if u.nominal == nil {
			return nil, fmt.Errorf("field \"nominal\" is required")
		}
		return struct {
			Type    string                `json:"type"`
			Nominal NominalStorageLocator `json:"nominal"`
		}{Type: "nominal", Nominal: *u.nominal}, nil
	case "external":
		if u.external == nil {
			return nil, fmt.Errorf("field \"external\" is required")
		}
		return struct {
			Type     string             `json:"type"`
			External api1.LogicalSeries `json:"external"`
		}{Type: "external", External: *u.external}, nil
	}
}

func (u StorageLocator) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *StorageLocator) UnmarshalJSON(data []byte) error {
	var deser storageLocatorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
	case "external":
		if u.external == nil {
			return fmt.Errorf("field \"external\" is required")
		}
	}
	return nil
}

func (u StorageLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *StorageLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *StorageLocator) AcceptFuncs(nominalFunc func(NominalStorageLocator) error, externalFunc func(api1.LogicalSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return nominalFunc(*u.nominal)
	case "external":
		if u.external == nil {
			return fmt.Errorf("field \"external\" is required")
		}
		return externalFunc(*u.external)
	}
}

func (u *StorageLocator) NominalNoopSuccess(NominalStorageLocator) error {
	return nil
}

func (u *StorageLocator) ExternalNoopSuccess(api1.LogicalSeries) error {
	return nil
}

func (u *StorageLocator) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *StorageLocator) Accept(v StorageLocatorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominal(*u.nominal)
	case "external":
		if u.external == nil {
			return fmt.Errorf("field \"external\" is required")
		}
		return v.VisitExternal(*u.external)
	}
}

type StorageLocatorVisitor interface {
	VisitNominal(v NominalStorageLocator) error
	VisitExternal(v api1.LogicalSeries) error
	VisitUnknown(typeName string) error
}

func (u *StorageLocator) AcceptWithContext(ctx context.Context, v StorageLocatorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominalWithContext(ctx, *u.nominal)
	case "external":
		if u.external == nil {
			return fmt.Errorf("field \"external\" is required")
		}
		return v.VisitExternalWithContext(ctx, *u.external)
	}
}

type StorageLocatorVisitorWithContext interface {
	VisitNominalWithContext(ctx context.Context, v NominalStorageLocator) error
	VisitExternalWithContext(ctx context.Context, v api1.LogicalSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewStorageLocatorFromNominal(v NominalStorageLocator) StorageLocator {
	return StorageLocator{typ: "nominal", nominal: &v}
}

func NewStorageLocatorFromExternal(v api1.LogicalSeries) StorageLocator {
	return StorageLocator{typ: "external", external: &v}
}

type StructSeriesNode struct {
	typ               string
	raw               *ResolvedSeries
	extractFromStruct *ExtractStructFromStructSeriesNode
}

type structSeriesNodeDeserializer struct {
	Type              string                             `json:"type"`
	Raw               *ResolvedSeries                    `json:"raw"`
	ExtractFromStruct *ExtractStructFromStructSeriesNode `json:"extractFromStruct"`
}

func (u *structSeriesNodeDeserializer) toStruct() StructSeriesNode {
	return StructSeriesNode{typ: u.Type, raw: u.Raw, extractFromStruct: u.ExtractFromStruct}
}

func (u *StructSeriesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string         `json:"type"`
			Raw  ResolvedSeries `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return nil, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return struct {
			Type              string                            `json:"type"`
			ExtractFromStruct ExtractStructFromStructSeriesNode `json:"extractFromStruct"`
		}{Type: "extractFromStruct", ExtractFromStruct: *u.extractFromStruct}, nil
	}
}

func (u StructSeriesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *StructSeriesNode) UnmarshalJSON(data []byte) error {
	var deser structSeriesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
	}
	return nil
}

func (u StructSeriesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *StructSeriesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *StructSeriesNode) AcceptFuncs(rawFunc func(ResolvedSeries) error, extractFromStructFunc func(ExtractStructFromStructSeriesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	}
}

func (u *StructSeriesNode) RawNoopSuccess(ResolvedSeries) error {
	return nil
}

func (u *StructSeriesNode) ExtractFromStructNoopSuccess(ExtractStructFromStructSeriesNode) error {
	return nil
}

func (u *StructSeriesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *StructSeriesNode) Accept(v StructSeriesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(*u.extractFromStruct)
	}
}

type StructSeriesNodeVisitor interface {
	VisitRaw(v ResolvedSeries) error
	VisitExtractFromStruct(v ExtractStructFromStructSeriesNode) error
	VisitUnknown(typeName string) error
}

func (u *StructSeriesNode) AcceptWithContext(ctx context.Context, v StructSeriesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStructWithContext(ctx, *u.extractFromStruct)
	}
}

type StructSeriesNodeVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v ResolvedSeries) error
	VisitExtractFromStructWithContext(ctx context.Context, v ExtractStructFromStructSeriesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewStructSeriesNodeFromRaw(v ResolvedSeries) StructSeriesNode {
	return StructSeriesNode{typ: "raw", raw: &v}
}

func NewStructSeriesNodeFromExtractFromStruct(v ExtractStructFromStructSeriesNode) StructSeriesNode {
	return StructSeriesNode{typ: "extractFromStruct", extractFromStruct: &v}
}

type TagFilters struct {
	typ    string
	single *TagFilter
	and    *[]TagFilters
}

type tagFiltersDeserializer struct {
	Type   string        `json:"type"`
	Single *TagFilter    `json:"single"`
	And    *[]TagFilters `json:"and"`
}

func (u *tagFiltersDeserializer) toStruct() TagFilters {
	return TagFilters{typ: u.Type, single: u.Single, and: u.And}
}

func (u *TagFilters) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "single":
		if u.single == nil {
			return nil, fmt.Errorf("field \"single\" is required")
		}
		return struct {
			Type   string    `json:"type"`
			Single TagFilter `json:"single"`
		}{Type: "single", Single: *u.single}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string       `json:"type"`
			And  []TagFilters `json:"and"`
		}{Type: "and", And: *u.and}, nil
	}
}

func (u TagFilters) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TagFilters) UnmarshalJSON(data []byte) error {
	var deser tagFiltersDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	}
	return nil
}

func (u TagFilters) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TagFilters) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TagFilters) AcceptFuncs(singleFunc func(TagFilter) error, andFunc func([]TagFilters) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	}
}

func (u *TagFilters) SingleNoopSuccess(TagFilter) error {
	return nil
}

func (u *TagFilters) AndNoopSuccess([]TagFilters) error {
	return nil
}

func (u *TagFilters) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TagFilters) Accept(v TagFiltersVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(*u.single)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	}
}

type TagFiltersVisitor interface {
	VisitSingle(v TagFilter) error
	VisitAnd(v []TagFilters) error
	VisitUnknown(typeName string) error
}

func (u *TagFilters) AcceptWithContext(ctx context.Context, v TagFiltersVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingleWithContext(ctx, *u.single)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	}
}

type TagFiltersVisitorWithContext interface {
	VisitSingleWithContext(ctx context.Context, v TagFilter) error
	VisitAndWithContext(ctx context.Context, v []TagFilters) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTagFiltersFromSingle(v TagFilter) TagFilters {
	return TagFilters{typ: "single", single: &v}
}

func NewTagFiltersFromAnd(v []TagFilters) TagFilters {
	return TagFilters{typ: "and", and: &v}
}

type Threshold struct {
	typ        string
	absolute   *AbsoluteThreshold
	percentage *PercentageThreshold
}

type thresholdDeserializer struct {
	Type       string               `json:"type"`
	Absolute   *AbsoluteThreshold   `json:"absolute"`
	Percentage *PercentageThreshold `json:"percentage"`
}

func (u *thresholdDeserializer) toStruct() Threshold {
	return Threshold{typ: u.Type, absolute: u.Absolute, percentage: u.Percentage}
}

func (u *Threshold) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "absolute":
		if u.absolute == nil {
			return nil, fmt.Errorf("field \"absolute\" is required")
		}
		return struct {
			Type     string            `json:"type"`
			Absolute AbsoluteThreshold `json:"absolute"`
		}{Type: "absolute", Absolute: *u.absolute}, nil
	case "percentage":
		if u.percentage == nil {
			return nil, fmt.Errorf("field \"percentage\" is required")
		}
		return struct {
			Type       string              `json:"type"`
			Percentage PercentageThreshold `json:"percentage"`
		}{Type: "percentage", Percentage: *u.percentage}, nil
	}
}

func (u Threshold) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Threshold) UnmarshalJSON(data []byte) error {
	var deser thresholdDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
	}
	return nil
}

func (u Threshold) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Threshold) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Threshold) AcceptFuncs(absoluteFunc func(AbsoluteThreshold) error, percentageFunc func(PercentageThreshold) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return absoluteFunc(*u.absolute)
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
		return percentageFunc(*u.percentage)
	}
}

func (u *Threshold) AbsoluteNoopSuccess(AbsoluteThreshold) error {
	return nil
}

func (u *Threshold) PercentageNoopSuccess(PercentageThreshold) error {
	return nil
}

func (u *Threshold) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Threshold) Accept(v ThresholdVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsolute(*u.absolute)
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
		return v.VisitPercentage(*u.percentage)
	}
}

type ThresholdVisitor interface {
	VisitAbsolute(v AbsoluteThreshold) error
	VisitPercentage(v PercentageThreshold) error
	VisitUnknown(typeName string) error
}

func (u *Threshold) AcceptWithContext(ctx context.Context, v ThresholdVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsoluteWithContext(ctx, *u.absolute)
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
		return v.VisitPercentageWithContext(ctx, *u.percentage)
	}
}

type ThresholdVisitorWithContext interface {
	VisitAbsoluteWithContext(ctx context.Context, v AbsoluteThreshold) error
	VisitPercentageWithContext(ctx context.Context, v PercentageThreshold) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewThresholdFromAbsolute(v AbsoluteThreshold) Threshold {
	return Threshold{typ: "absolute", absolute: &v}
}

func NewThresholdFromPercentage(v PercentageThreshold) Threshold {
	return Threshold{typ: "percentage", percentage: &v}
}
