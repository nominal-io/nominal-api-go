// Code generated by conjure-go. DO NOT EDIT.

package deprecated

import (
	"context"
	"fmt"

	api1 "github.com/nominal-io/nominal-api/io/nominal/api"
	"github.com/nominal-io/nominal-api/scout/compute/api"
	api2 "github.com/nominal-io/nominal-api/scout/run/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type CartesianNode struct {
	typ     string
	scatter *ScatterNode
}

type cartesianNodeDeserializer struct {
	Type    string       `json:"type"`
	Scatter *ScatterNode `json:"scatter"`
}

func (u *cartesianNodeDeserializer) toStruct() CartesianNode {
	return CartesianNode{typ: u.Type, scatter: u.Scatter}
}

func (u *CartesianNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "scatter":
		if u.scatter == nil {
			return nil, fmt.Errorf("field \"scatter\" is required")
		}
		return struct {
			Type    string      `json:"type"`
			Scatter ScatterNode `json:"scatter"`
		}{Type: "scatter", Scatter: *u.scatter}, nil
	}
}

func (u CartesianNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CartesianNode) UnmarshalJSON(data []byte) error {
	var deser cartesianNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
	}
	return nil
}

func (u CartesianNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CartesianNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CartesianNode) AcceptFuncs(scatterFunc func(ScatterNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *CartesianNode) ScatterNoopSuccess(ScatterNode) error {
	return nil
}

func (u *CartesianNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CartesianNode) Accept(v CartesianNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(*u.scatter)
	}
}

type CartesianNodeVisitor interface {
	VisitScatter(v ScatterNode) error
	VisitUnknown(typeName string) error
}

func (u *CartesianNode) AcceptWithContext(ctx context.Context, v CartesianNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatterWithContext(ctx, *u.scatter)
	}
}

type CartesianNodeVisitorWithContext interface {
	VisitScatterWithContext(ctx context.Context, v ScatterNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCartesianNodeFromScatter(v ScatterNode) CartesianNode {
	return CartesianNode{typ: "scatter", scatter: &v}
}

type ComputableNode struct {
	typ       string
	ranges    *SummarizeRangesNode
	series    *SummarizeSeriesNode
	value     *SelectValueNode
	cartesian *SummarizeCartesianNode
	frequency *FrequencyDomainNode
}

type computableNodeDeserializer struct {
	Type      string                  `json:"type"`
	Ranges    *SummarizeRangesNode    `json:"ranges"`
	Series    *SummarizeSeriesNode    `json:"series"`
	Value     *SelectValueNode        `json:"value"`
	Cartesian *SummarizeCartesianNode `json:"cartesian"`
	Frequency *FrequencyDomainNode    `json:"frequency"`
}

func (u *computableNodeDeserializer) toStruct() ComputableNode {
	return ComputableNode{typ: u.Type, ranges: u.Ranges, series: u.Series, value: u.Value, cartesian: u.Cartesian, frequency: u.Frequency}
}

func (u *ComputableNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "ranges":
		if u.ranges == nil {
			return nil, fmt.Errorf("field \"ranges\" is required")
		}
		return struct {
			Type   string              `json:"type"`
			Ranges SummarizeRangesNode `json:"ranges"`
		}{Type: "ranges", Ranges: *u.ranges}, nil
	case "series":
		if u.series == nil {
			return nil, fmt.Errorf("field \"series\" is required")
		}
		return struct {
			Type   string              `json:"type"`
			Series SummarizeSeriesNode `json:"series"`
		}{Type: "series", Series: *u.series}, nil
	case "value":
		if u.value == nil {
			return nil, fmt.Errorf("field \"value\" is required")
		}
		return struct {
			Type  string          `json:"type"`
			Value SelectValueNode `json:"value"`
		}{Type: "value", Value: *u.value}, nil
	case "cartesian":
		if u.cartesian == nil {
			return nil, fmt.Errorf("field \"cartesian\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			Cartesian SummarizeCartesianNode `json:"cartesian"`
		}{Type: "cartesian", Cartesian: *u.cartesian}, nil
	case "frequency":
		if u.frequency == nil {
			return nil, fmt.Errorf("field \"frequency\" is required")
		}
		return struct {
			Type      string              `json:"type"`
			Frequency FrequencyDomainNode `json:"frequency"`
		}{Type: "frequency", Frequency: *u.frequency}, nil
	}
}

func (u ComputableNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputableNode) UnmarshalJSON(data []byte) error {
	var deser computableNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
	}
	return nil
}

func (u ComputableNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputableNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputableNode) AcceptFuncs(rangesFunc func(SummarizeRangesNode) error, seriesFunc func(SummarizeSeriesNode) error, valueFunc func(SelectValueNode) error, cartesianFunc func(SummarizeCartesianNode) error, frequencyFunc func(FrequencyDomainNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return frequencyFunc(*u.frequency)
	}
}

func (u *ComputableNode) RangesNoopSuccess(SummarizeRangesNode) error {
	return nil
}

func (u *ComputableNode) SeriesNoopSuccess(SummarizeSeriesNode) error {
	return nil
}

func (u *ComputableNode) ValueNoopSuccess(SelectValueNode) error {
	return nil
}

func (u *ComputableNode) CartesianNoopSuccess(SummarizeCartesianNode) error {
	return nil
}

func (u *ComputableNode) FrequencyNoopSuccess(FrequencyDomainNode) error {
	return nil
}

func (u *ComputableNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputableNode) Accept(v ComputableNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(*u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(*u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(*u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(*u.cartesian)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequency(*u.frequency)
	}
}

type ComputableNodeVisitor interface {
	VisitRanges(v SummarizeRangesNode) error
	VisitSeries(v SummarizeSeriesNode) error
	VisitValue(v SelectValueNode) error
	VisitCartesian(v SummarizeCartesianNode) error
	VisitFrequency(v FrequencyDomainNode) error
	VisitUnknown(typeName string) error
}

func (u *ComputableNode) AcceptWithContext(ctx context.Context, v ComputableNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRangesWithContext(ctx, *u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeriesWithContext(ctx, *u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValueWithContext(ctx, *u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesianWithContext(ctx, *u.cartesian)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequencyWithContext(ctx, *u.frequency)
	}
}

type ComputableNodeVisitorWithContext interface {
	VisitRangesWithContext(ctx context.Context, v SummarizeRangesNode) error
	VisitSeriesWithContext(ctx context.Context, v SummarizeSeriesNode) error
	VisitValueWithContext(ctx context.Context, v SelectValueNode) error
	VisitCartesianWithContext(ctx context.Context, v SummarizeCartesianNode) error
	VisitFrequencyWithContext(ctx context.Context, v FrequencyDomainNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputableNodeFromRanges(v SummarizeRangesNode) ComputableNode {
	return ComputableNode{typ: "ranges", ranges: &v}
}

func NewComputableNodeFromSeries(v SummarizeSeriesNode) ComputableNode {
	return ComputableNode{typ: "series", series: &v}
}

func NewComputableNodeFromValue(v SelectValueNode) ComputableNode {
	return ComputableNode{typ: "value", value: &v}
}

func NewComputableNodeFromCartesian(v SummarizeCartesianNode) ComputableNode {
	return ComputableNode{typ: "cartesian", cartesian: &v}
}

func NewComputableNodeFromFrequency(v FrequencyDomainNode) ComputableNode {
	return ComputableNode{typ: "frequency", frequency: &v}
}

type EnumSeriesNode struct {
	typ             string
	raw             *api.Reference
	timeRangeFilter *EnumTimeRangeFilterSeriesNode
	timeShift       *EnumTimeShiftSeriesNode
	union           *EnumUnionSeriesNode
}

type enumSeriesNodeDeserializer struct {
	Type            string                         `json:"type"`
	Raw             *api.Reference                 `json:"raw"`
	TimeRangeFilter *EnumTimeRangeFilterSeriesNode `json:"timeRangeFilter"`
	TimeShift       *EnumTimeShiftSeriesNode       `json:"timeShift"`
	Union           *EnumUnionSeriesNode           `json:"union"`
}

func (u *enumSeriesNodeDeserializer) toStruct() EnumSeriesNode {
	return EnumSeriesNode{typ: u.Type, raw: u.Raw, timeRangeFilter: u.TimeRangeFilter, timeShift: u.TimeShift, union: u.Union}
}

func (u *EnumSeriesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return nil, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return struct {
			Type            string                        `json:"type"`
			TimeRangeFilter EnumTimeRangeFilterSeriesNode `json:"timeRangeFilter"`
		}{Type: "timeRangeFilter", TimeRangeFilter: *u.timeRangeFilter}, nil
	case "timeShift":
		if u.timeShift == nil {
			return nil, fmt.Errorf("field \"timeShift\" is required")
		}
		return struct {
			Type      string                  `json:"type"`
			TimeShift EnumTimeShiftSeriesNode `json:"timeShift"`
		}{Type: "timeShift", TimeShift: *u.timeShift}, nil
	case "union":
		if u.union == nil {
			return nil, fmt.Errorf("field \"union\" is required")
		}
		return struct {
			Type  string              `json:"type"`
			Union EnumUnionSeriesNode `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	}
}

func (u EnumSeriesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumSeriesNode) UnmarshalJSON(data []byte) error {
	var deser enumSeriesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
	}
	return nil
}

func (u EnumSeriesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumSeriesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumSeriesNode) AcceptFuncs(rawFunc func(api.Reference) error, timeRangeFilterFunc func(EnumTimeRangeFilterSeriesNode) error, timeShiftFunc func(EnumTimeShiftSeriesNode) error, unionFunc func(EnumUnionSeriesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	}
}

func (u *EnumSeriesNode) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *EnumSeriesNode) TimeRangeFilterNoopSuccess(EnumTimeRangeFilterSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) TimeShiftNoopSuccess(EnumTimeShiftSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) UnionNoopSuccess(EnumUnionSeriesNode) error {
	return nil
}

func (u *EnumSeriesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumSeriesNode) Accept(v EnumSeriesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(*u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	}
}

type EnumSeriesNodeVisitor interface {
	VisitRaw(v api.Reference) error
	VisitTimeRangeFilter(v EnumTimeRangeFilterSeriesNode) error
	VisitTimeShift(v EnumTimeShiftSeriesNode) error
	VisitUnion(v EnumUnionSeriesNode) error
	VisitUnknown(typeName string) error
}

func (u *EnumSeriesNode) AcceptWithContext(ctx context.Context, v EnumSeriesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilterWithContext(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShiftWithContext(ctx, *u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	}
}

type EnumSeriesNodeVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitTimeRangeFilterWithContext(ctx context.Context, v EnumTimeRangeFilterSeriesNode) error
	VisitTimeShiftWithContext(ctx context.Context, v EnumTimeShiftSeriesNode) error
	VisitUnionWithContext(ctx context.Context, v EnumUnionSeriesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumSeriesNodeFromRaw(v api.Reference) EnumSeriesNode {
	return EnumSeriesNode{typ: "raw", raw: &v}
}

func NewEnumSeriesNodeFromTimeRangeFilter(v EnumTimeRangeFilterSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "timeRangeFilter", timeRangeFilter: &v}
}

func NewEnumSeriesNodeFromTimeShift(v EnumTimeShiftSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "timeShift", timeShift: &v}
}

func NewEnumSeriesNodeFromUnion(v EnumUnionSeriesNode) EnumSeriesNode {
	return EnumSeriesNode{typ: "union", union: &v}
}

type FrequencyDomainNode struct {
	typ string
	fft *FftNode
}

type frequencyDomainNodeDeserializer struct {
	Type string   `json:"type"`
	Fft  *FftNode `json:"fft"`
}

func (u *frequencyDomainNodeDeserializer) toStruct() FrequencyDomainNode {
	return FrequencyDomainNode{typ: u.Type, fft: u.Fft}
}

func (u *FrequencyDomainNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "fft":
		if u.fft == nil {
			return nil, fmt.Errorf("field \"fft\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Fft  FftNode `json:"fft"`
		}{Type: "fft", Fft: *u.fft}, nil
	}
}

func (u FrequencyDomainNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FrequencyDomainNode) UnmarshalJSON(data []byte) error {
	var deser frequencyDomainNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
	}
	return nil
}

func (u FrequencyDomainNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FrequencyDomainNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FrequencyDomainNode) AcceptFuncs(fftFunc func(FftNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	}
}

func (u *FrequencyDomainNode) FftNoopSuccess(FftNode) error {
	return nil
}

func (u *FrequencyDomainNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FrequencyDomainNode) Accept(v FrequencyDomainNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(*u.fft)
	}
}

type FrequencyDomainNodeVisitor interface {
	VisitFft(v FftNode) error
	VisitUnknown(typeName string) error
}

func (u *FrequencyDomainNode) AcceptWithContext(ctx context.Context, v FrequencyDomainNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFftWithContext(ctx, *u.fft)
	}
}

type FrequencyDomainNodeVisitorWithContext interface {
	VisitFftWithContext(ctx context.Context, v FftNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFrequencyDomainNodeFromFft(v FftNode) FrequencyDomainNode {
	return FrequencyDomainNode{typ: "fft", fft: &v}
}

type NumericSeriesNode struct {
	typ              string
	raw              *api.Reference
	arithmetic       *ArithmeticSeriesNode
	bitOperation     *BitOperationSeriesNode
	cumulativeSum    *CumulativeSumSeriesNode
	derivative       *DerivativeSeriesNode
	rollingOperation *RollingOperationSeriesNode
	unaryArithmetic  *UnaryArithmeticSeriesNode
	timeDifference   *TimeDifferenceSeriesNode
	timeRangeFilter  *NumericTimeRangeFilterSeriesNode
	timeShift        *NumericTimeShiftSeriesNode
	union            *NumericUnionSeriesNode
	valueDifference  *ValueDifferenceSeriesNode
}

type numericSeriesNodeDeserializer struct {
	Type             string                            `json:"type"`
	Raw              *api.Reference                    `json:"raw"`
	Arithmetic       *ArithmeticSeriesNode             `json:"arithmetic"`
	BitOperation     *BitOperationSeriesNode           `json:"bitOperation"`
	CumulativeSum    *CumulativeSumSeriesNode          `json:"cumulativeSum"`
	Derivative       *DerivativeSeriesNode             `json:"derivative"`
	RollingOperation *RollingOperationSeriesNode       `json:"rollingOperation"`
	UnaryArithmetic  *UnaryArithmeticSeriesNode        `json:"unaryArithmetic"`
	TimeDifference   *TimeDifferenceSeriesNode         `json:"timeDifference"`
	TimeRangeFilter  *NumericTimeRangeFilterSeriesNode `json:"timeRangeFilter"`
	TimeShift        *NumericTimeShiftSeriesNode       `json:"timeShift"`
	Union            *NumericUnionSeriesNode           `json:"union"`
	ValueDifference  *ValueDifferenceSeriesNode        `json:"valueDifference"`
}

func (u *numericSeriesNodeDeserializer) toStruct() NumericSeriesNode {
	return NumericSeriesNode{typ: u.Type, raw: u.Raw, arithmetic: u.Arithmetic, bitOperation: u.BitOperation, cumulativeSum: u.CumulativeSum, derivative: u.Derivative, rollingOperation: u.RollingOperation, unaryArithmetic: u.UnaryArithmetic, timeDifference: u.TimeDifference, timeRangeFilter: u.TimeRangeFilter, timeShift: u.TimeShift, union: u.Union, valueDifference: u.ValueDifference}
}

func (u *NumericSeriesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "arithmetic":
		if u.arithmetic == nil {
			return nil, fmt.Errorf("field \"arithmetic\" is required")
		}
		return struct {
			Type       string               `json:"type"`
			Arithmetic ArithmeticSeriesNode `json:"arithmetic"`
		}{Type: "arithmetic", Arithmetic: *u.arithmetic}, nil
	case "bitOperation":
		if u.bitOperation == nil {
			return nil, fmt.Errorf("field \"bitOperation\" is required")
		}
		return struct {
			Type         string                 `json:"type"`
			BitOperation BitOperationSeriesNode `json:"bitOperation"`
		}{Type: "bitOperation", BitOperation: *u.bitOperation}, nil
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return nil, fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return struct {
			Type          string                  `json:"type"`
			CumulativeSum CumulativeSumSeriesNode `json:"cumulativeSum"`
		}{Type: "cumulativeSum", CumulativeSum: *u.cumulativeSum}, nil
	case "derivative":
		if u.derivative == nil {
			return nil, fmt.Errorf("field \"derivative\" is required")
		}
		return struct {
			Type       string               `json:"type"`
			Derivative DerivativeSeriesNode `json:"derivative"`
		}{Type: "derivative", Derivative: *u.derivative}, nil
	case "rollingOperation":
		if u.rollingOperation == nil {
			return nil, fmt.Errorf("field \"rollingOperation\" is required")
		}
		return struct {
			Type             string                     `json:"type"`
			RollingOperation RollingOperationSeriesNode `json:"rollingOperation"`
		}{Type: "rollingOperation", RollingOperation: *u.rollingOperation}, nil
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return nil, fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return struct {
			Type            string                    `json:"type"`
			UnaryArithmetic UnaryArithmeticSeriesNode `json:"unaryArithmetic"`
		}{Type: "unaryArithmetic", UnaryArithmetic: *u.unaryArithmetic}, nil
	case "timeDifference":
		if u.timeDifference == nil {
			return nil, fmt.Errorf("field \"timeDifference\" is required")
		}
		return struct {
			Type           string                   `json:"type"`
			TimeDifference TimeDifferenceSeriesNode `json:"timeDifference"`
		}{Type: "timeDifference", TimeDifference: *u.timeDifference}, nil
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return nil, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return struct {
			Type            string                           `json:"type"`
			TimeRangeFilter NumericTimeRangeFilterSeriesNode `json:"timeRangeFilter"`
		}{Type: "timeRangeFilter", TimeRangeFilter: *u.timeRangeFilter}, nil
	case "timeShift":
		if u.timeShift == nil {
			return nil, fmt.Errorf("field \"timeShift\" is required")
		}
		return struct {
			Type      string                     `json:"type"`
			TimeShift NumericTimeShiftSeriesNode `json:"timeShift"`
		}{Type: "timeShift", TimeShift: *u.timeShift}, nil
	case "union":
		if u.union == nil {
			return nil, fmt.Errorf("field \"union\" is required")
		}
		return struct {
			Type  string                 `json:"type"`
			Union NumericUnionSeriesNode `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	case "valueDifference":
		if u.valueDifference == nil {
			return nil, fmt.Errorf("field \"valueDifference\" is required")
		}
		return struct {
			Type            string                    `json:"type"`
			ValueDifference ValueDifferenceSeriesNode `json:"valueDifference"`
		}{Type: "valueDifference", ValueDifference: *u.valueDifference}, nil
	}
}

func (u NumericSeriesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericSeriesNode) UnmarshalJSON(data []byte) error {
	var deser numericSeriesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
	}
	return nil
}

func (u NumericSeriesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericSeriesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericSeriesNode) AcceptFuncs(rawFunc func(api.Reference) error, arithmeticFunc func(ArithmeticSeriesNode) error, bitOperationFunc func(BitOperationSeriesNode) error, cumulativeSumFunc func(CumulativeSumSeriesNode) error, derivativeFunc func(DerivativeSeriesNode) error, rollingOperationFunc func(RollingOperationSeriesNode) error, unaryArithmeticFunc func(UnaryArithmeticSeriesNode) error, timeDifferenceFunc func(TimeDifferenceSeriesNode) error, timeRangeFilterFunc func(NumericTimeRangeFilterSeriesNode) error, timeShiftFunc func(NumericTimeShiftSeriesNode) error, unionFunc func(NumericUnionSeriesNode) error, valueDifferenceFunc func(ValueDifferenceSeriesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return arithmeticFunc(*u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return bitOperationFunc(*u.bitOperation)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return cumulativeSumFunc(*u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return derivativeFunc(*u.derivative)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return rollingOperationFunc(*u.rollingOperation)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return unaryArithmeticFunc(*u.unaryArithmetic)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return timeDifferenceFunc(*u.timeDifference)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return valueDifferenceFunc(*u.valueDifference)
	}
}

func (u *NumericSeriesNode) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *NumericSeriesNode) ArithmeticNoopSuccess(ArithmeticSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) BitOperationNoopSuccess(BitOperationSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) CumulativeSumNoopSuccess(CumulativeSumSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) DerivativeNoopSuccess(DerivativeSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) RollingOperationNoopSuccess(RollingOperationSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) UnaryArithmeticNoopSuccess(UnaryArithmeticSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) TimeDifferenceNoopSuccess(TimeDifferenceSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) TimeRangeFilterNoopSuccess(NumericTimeRangeFilterSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) TimeShiftNoopSuccess(NumericTimeShiftSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) UnionNoopSuccess(NumericUnionSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) ValueDifferenceNoopSuccess(ValueDifferenceSeriesNode) error {
	return nil
}

func (u *NumericSeriesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericSeriesNode) Accept(v NumericSeriesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return v.VisitArithmetic(*u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return v.VisitBitOperation(*u.bitOperation)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return v.VisitCumulativeSum(*u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return v.VisitDerivative(*u.derivative)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return v.VisitRollingOperation(*u.rollingOperation)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return v.VisitUnaryArithmetic(*u.unaryArithmetic)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return v.VisitTimeDifference(*u.timeDifference)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(*u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return v.VisitValueDifference(*u.valueDifference)
	}
}

type NumericSeriesNodeVisitor interface {
	VisitRaw(v api.Reference) error
	VisitArithmetic(v ArithmeticSeriesNode) error
	VisitBitOperation(v BitOperationSeriesNode) error
	VisitCumulativeSum(v CumulativeSumSeriesNode) error
	VisitDerivative(v DerivativeSeriesNode) error
	VisitRollingOperation(v RollingOperationSeriesNode) error
	VisitUnaryArithmetic(v UnaryArithmeticSeriesNode) error
	VisitTimeDifference(v TimeDifferenceSeriesNode) error
	VisitTimeRangeFilter(v NumericTimeRangeFilterSeriesNode) error
	VisitTimeShift(v NumericTimeShiftSeriesNode) error
	VisitUnion(v NumericUnionSeriesNode) error
	VisitValueDifference(v ValueDifferenceSeriesNode) error
	VisitUnknown(typeName string) error
}

func (u *NumericSeriesNode) AcceptWithContext(ctx context.Context, v NumericSeriesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return v.VisitArithmeticWithContext(ctx, *u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return v.VisitBitOperationWithContext(ctx, *u.bitOperation)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return v.VisitCumulativeSumWithContext(ctx, *u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return v.VisitDerivativeWithContext(ctx, *u.derivative)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return v.VisitRollingOperationWithContext(ctx, *u.rollingOperation)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return v.VisitUnaryArithmeticWithContext(ctx, *u.unaryArithmetic)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return v.VisitTimeDifferenceWithContext(ctx, *u.timeDifference)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilterWithContext(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShiftWithContext(ctx, *u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return v.VisitValueDifferenceWithContext(ctx, *u.valueDifference)
	}
}

type NumericSeriesNodeVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitArithmeticWithContext(ctx context.Context, v ArithmeticSeriesNode) error
	VisitBitOperationWithContext(ctx context.Context, v BitOperationSeriesNode) error
	VisitCumulativeSumWithContext(ctx context.Context, v CumulativeSumSeriesNode) error
	VisitDerivativeWithContext(ctx context.Context, v DerivativeSeriesNode) error
	VisitRollingOperationWithContext(ctx context.Context, v RollingOperationSeriesNode) error
	VisitUnaryArithmeticWithContext(ctx context.Context, v UnaryArithmeticSeriesNode) error
	VisitTimeDifferenceWithContext(ctx context.Context, v TimeDifferenceSeriesNode) error
	VisitTimeRangeFilterWithContext(ctx context.Context, v NumericTimeRangeFilterSeriesNode) error
	VisitTimeShiftWithContext(ctx context.Context, v NumericTimeShiftSeriesNode) error
	VisitUnionWithContext(ctx context.Context, v NumericUnionSeriesNode) error
	VisitValueDifferenceWithContext(ctx context.Context, v ValueDifferenceSeriesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericSeriesNodeFromRaw(v api.Reference) NumericSeriesNode {
	return NumericSeriesNode{typ: "raw", raw: &v}
}

func NewNumericSeriesNodeFromArithmetic(v ArithmeticSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "arithmetic", arithmetic: &v}
}

func NewNumericSeriesNodeFromBitOperation(v BitOperationSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "bitOperation", bitOperation: &v}
}

func NewNumericSeriesNodeFromCumulativeSum(v CumulativeSumSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "cumulativeSum", cumulativeSum: &v}
}

func NewNumericSeriesNodeFromDerivative(v DerivativeSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "derivative", derivative: &v}
}

func NewNumericSeriesNodeFromRollingOperation(v RollingOperationSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "rollingOperation", rollingOperation: &v}
}

func NewNumericSeriesNodeFromUnaryArithmetic(v UnaryArithmeticSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "unaryArithmetic", unaryArithmetic: &v}
}

func NewNumericSeriesNodeFromTimeDifference(v TimeDifferenceSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "timeDifference", timeDifference: &v}
}

func NewNumericSeriesNodeFromTimeRangeFilter(v NumericTimeRangeFilterSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "timeRangeFilter", timeRangeFilter: &v}
}

func NewNumericSeriesNodeFromTimeShift(v NumericTimeShiftSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "timeShift", timeShift: &v}
}

func NewNumericSeriesNodeFromUnion(v NumericUnionSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "union", union: &v}
}

func NewNumericSeriesNodeFromValueDifference(v ValueDifferenceSeriesNode) NumericSeriesNode {
	return NumericSeriesNode{typ: "valueDifference", valueDifference: &v}
}

type RangesNode struct {
	typ            string
	onChange       *OnChangeRangesNode
	enumFilter     *EnumFilterRangesNode
	threshold      *ThresholdingRangesNode
	unionRange     *UnionRangesNode
	intersectRange *IntersectRangesNode
}

type rangesNodeDeserializer struct {
	Type           string                  `json:"type"`
	OnChange       *OnChangeRangesNode     `json:"onChange"`
	EnumFilter     *EnumFilterRangesNode   `json:"enumFilter"`
	Threshold      *ThresholdingRangesNode `json:"threshold"`
	UnionRange     *UnionRangesNode        `json:"unionRange"`
	IntersectRange *IntersectRangesNode    `json:"intersectRange"`
}

func (u *rangesNodeDeserializer) toStruct() RangesNode {
	return RangesNode{typ: u.Type, onChange: u.OnChange, enumFilter: u.EnumFilter, threshold: u.Threshold, unionRange: u.UnionRange, intersectRange: u.IntersectRange}
}

func (u *RangesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "onChange":
		if u.onChange == nil {
			return nil, fmt.Errorf("field \"onChange\" is required")
		}
		return struct {
			Type     string             `json:"type"`
			OnChange OnChangeRangesNode `json:"onChange"`
		}{Type: "onChange", OnChange: *u.onChange}, nil
	case "enumFilter":
		if u.enumFilter == nil {
			return nil, fmt.Errorf("field \"enumFilter\" is required")
		}
		return struct {
			Type       string               `json:"type"`
			EnumFilter EnumFilterRangesNode `json:"enumFilter"`
		}{Type: "enumFilter", EnumFilter: *u.enumFilter}, nil
	case "threshold":
		if u.threshold == nil {
			return nil, fmt.Errorf("field \"threshold\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			Threshold ThresholdingRangesNode `json:"threshold"`
		}{Type: "threshold", Threshold: *u.threshold}, nil
	case "unionRange":
		if u.unionRange == nil {
			return nil, fmt.Errorf("field \"unionRange\" is required")
		}
		return struct {
			Type       string          `json:"type"`
			UnionRange UnionRangesNode `json:"unionRange"`
		}{Type: "unionRange", UnionRange: *u.unionRange}, nil
	case "intersectRange":
		if u.intersectRange == nil {
			return nil, fmt.Errorf("field \"intersectRange\" is required")
		}
		return struct {
			Type           string              `json:"type"`
			IntersectRange IntersectRangesNode `json:"intersectRange"`
		}{Type: "intersectRange", IntersectRange: *u.intersectRange}, nil
	}
}

func (u RangesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangesNode) UnmarshalJSON(data []byte) error {
	var deser rangesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
	}
	return nil
}

func (u RangesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangesNode) AcceptFuncs(onChangeFunc func(OnChangeRangesNode) error, enumFilterFunc func(EnumFilterRangesNode) error, thresholdFunc func(ThresholdingRangesNode) error, unionRangeFunc func(UnionRangesNode) error, intersectRangeFunc func(IntersectRangesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return onChangeFunc(*u.onChange)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return enumFilterFunc(*u.enumFilter)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return thresholdFunc(*u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return unionRangeFunc(*u.unionRange)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return intersectRangeFunc(*u.intersectRange)
	}
}

func (u *RangesNode) OnChangeNoopSuccess(OnChangeRangesNode) error {
	return nil
}

func (u *RangesNode) EnumFilterNoopSuccess(EnumFilterRangesNode) error {
	return nil
}

func (u *RangesNode) ThresholdNoopSuccess(ThresholdingRangesNode) error {
	return nil
}

func (u *RangesNode) UnionRangeNoopSuccess(UnionRangesNode) error {
	return nil
}

func (u *RangesNode) IntersectRangeNoopSuccess(IntersectRangesNode) error {
	return nil
}

func (u *RangesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangesNode) Accept(v RangesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return v.VisitOnChange(*u.onChange)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return v.VisitEnumFilter(*u.enumFilter)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThreshold(*u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return v.VisitUnionRange(*u.unionRange)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return v.VisitIntersectRange(*u.intersectRange)
	}
}

type RangesNodeVisitor interface {
	VisitOnChange(v OnChangeRangesNode) error
	VisitEnumFilter(v EnumFilterRangesNode) error
	VisitThreshold(v ThresholdingRangesNode) error
	VisitUnionRange(v UnionRangesNode) error
	VisitIntersectRange(v IntersectRangesNode) error
	VisitUnknown(typeName string) error
}

func (u *RangesNode) AcceptWithContext(ctx context.Context, v RangesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return v.VisitOnChangeWithContext(ctx, *u.onChange)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return v.VisitEnumFilterWithContext(ctx, *u.enumFilter)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThresholdWithContext(ctx, *u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return v.VisitUnionRangeWithContext(ctx, *u.unionRange)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return v.VisitIntersectRangeWithContext(ctx, *u.intersectRange)
	}
}

type RangesNodeVisitorWithContext interface {
	VisitOnChangeWithContext(ctx context.Context, v OnChangeRangesNode) error
	VisitEnumFilterWithContext(ctx context.Context, v EnumFilterRangesNode) error
	VisitThresholdWithContext(ctx context.Context, v ThresholdingRangesNode) error
	VisitUnionRangeWithContext(ctx context.Context, v UnionRangesNode) error
	VisitIntersectRangeWithContext(ctx context.Context, v IntersectRangesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangesNodeFromOnChange(v OnChangeRangesNode) RangesNode {
	return RangesNode{typ: "onChange", onChange: &v}
}

func NewRangesNodeFromEnumFilter(v EnumFilterRangesNode) RangesNode {
	return RangesNode{typ: "enumFilter", enumFilter: &v}
}

func NewRangesNodeFromThreshold(v ThresholdingRangesNode) RangesNode {
	return RangesNode{typ: "threshold", threshold: &v}
}

func NewRangesNodeFromUnionRange(v UnionRangesNode) RangesNode {
	return RangesNode{typ: "unionRange", unionRange: &v}
}

func NewRangesNodeFromIntersectRange(v IntersectRangesNode) RangesNode {
	return RangesNode{typ: "intersectRange", intersectRange: &v}
}

type SelectValueNode struct {
	typ        string
	firstPoint *SeriesNode
	firstRange *RangesNode
}

type selectValueNodeDeserializer struct {
	Type       string      `json:"type"`
	FirstPoint *SeriesNode `json:"firstPoint"`
	FirstRange *RangesNode `json:"firstRange"`
}

func (u *selectValueNodeDeserializer) toStruct() SelectValueNode {
	return SelectValueNode{typ: u.Type, firstPoint: u.FirstPoint, firstRange: u.FirstRange}
}

func (u *SelectValueNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return nil, fmt.Errorf("field \"firstPoint\" is required")
		}
		return struct {
			Type       string     `json:"type"`
			FirstPoint SeriesNode `json:"firstPoint"`
		}{Type: "firstPoint", FirstPoint: *u.firstPoint}, nil
	case "firstRange":
		if u.firstRange == nil {
			return nil, fmt.Errorf("field \"firstRange\" is required")
		}
		return struct {
			Type       string     `json:"type"`
			FirstRange RangesNode `json:"firstRange"`
		}{Type: "firstRange", FirstRange: *u.firstRange}, nil
	}
}

func (u SelectValueNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SelectValueNode) UnmarshalJSON(data []byte) error {
	var deser selectValueNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
	}
	return nil
}

func (u SelectValueNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SelectValueNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SelectValueNode) AcceptFuncs(firstPointFunc func(SeriesNode) error, firstRangeFunc func(RangesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return firstPointFunc(*u.firstPoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return firstRangeFunc(*u.firstRange)
	}
}

func (u *SelectValueNode) FirstPointNoopSuccess(SeriesNode) error {
	return nil
}

func (u *SelectValueNode) FirstRangeNoopSuccess(RangesNode) error {
	return nil
}

func (u *SelectValueNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SelectValueNode) Accept(v SelectValueNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return v.VisitFirstPoint(*u.firstPoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return v.VisitFirstRange(*u.firstRange)
	}
}

type SelectValueNodeVisitor interface {
	VisitFirstPoint(v SeriesNode) error
	VisitFirstRange(v RangesNode) error
	VisitUnknown(typeName string) error
}

func (u *SelectValueNode) AcceptWithContext(ctx context.Context, v SelectValueNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return v.VisitFirstPointWithContext(ctx, *u.firstPoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return v.VisitFirstRangeWithContext(ctx, *u.firstRange)
	}
}

type SelectValueNodeVisitorWithContext interface {
	VisitFirstPointWithContext(ctx context.Context, v SeriesNode) error
	VisitFirstRangeWithContext(ctx context.Context, v RangesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSelectValueNodeFromFirstPoint(v SeriesNode) SelectValueNode {
	return SelectValueNode{typ: "firstPoint", firstPoint: &v}
}

func NewSelectValueNodeFromFirstRange(v RangesNode) SelectValueNode {
	return SelectValueNode{typ: "firstRange", firstRange: &v}
}

type SeriesNode struct {
	typ     string
	raw     *api.Reference
	enum    *EnumSeriesNode
	numeric *NumericSeriesNode
}

type seriesNodeDeserializer struct {
	Type    string             `json:"type"`
	Raw     *api.Reference     `json:"raw"`
	Enum    *EnumSeriesNode    `json:"enum"`
	Numeric *NumericSeriesNode `json:"numeric"`
}

func (u *seriesNodeDeserializer) toStruct() SeriesNode {
	return SeriesNode{typ: u.Type, raw: u.Raw, enum: u.Enum, numeric: u.Numeric}
}

func (u *SeriesNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string         `json:"type"`
			Enum EnumSeriesNode `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Numeric NumericSeriesNode `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	}
}

func (u SeriesNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SeriesNode) UnmarshalJSON(data []byte) error {
	var deser seriesNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	}
	return nil
}

func (u SeriesNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SeriesNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SeriesNode) AcceptFuncs(rawFunc func(api.Reference) error, enumFunc func(EnumSeriesNode) error, numericFunc func(NumericSeriesNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	}
}

func (u *SeriesNode) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *SeriesNode) EnumNoopSuccess(EnumSeriesNode) error {
	return nil
}

func (u *SeriesNode) NumericNoopSuccess(NumericSeriesNode) error {
	return nil
}

func (u *SeriesNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SeriesNode) Accept(v SeriesNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	}
}

type SeriesNodeVisitor interface {
	VisitRaw(v api.Reference) error
	VisitEnum(v EnumSeriesNode) error
	VisitNumeric(v NumericSeriesNode) error
	VisitUnknown(typeName string) error
}

func (u *SeriesNode) AcceptWithContext(ctx context.Context, v SeriesNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	}
}

type SeriesNodeVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitEnumWithContext(ctx context.Context, v EnumSeriesNode) error
	VisitNumericWithContext(ctx context.Context, v NumericSeriesNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSeriesNodeFromRaw(v api.Reference) SeriesNode {
	return SeriesNode{typ: "raw", raw: &v}
}

func NewSeriesNodeFromEnum(v EnumSeriesNode) SeriesNode {
	return SeriesNode{typ: "enum", enum: &v}
}

func NewSeriesNodeFromNumeric(v NumericSeriesNode) SeriesNode {
	return SeriesNode{typ: "numeric", numeric: &v}
}

type VariableValue struct {
	typ       string
	series    *api.SeriesSpec
	timestamp *api1.Timestamp
}

type variableValueDeserializer struct {
	Type      string          `json:"type"`
	Series    *api.SeriesSpec `json:"series"`
	Timestamp *api1.Timestamp `json:"timestamp"`
}

func (u *variableValueDeserializer) toStruct() VariableValue {
	return VariableValue{typ: u.Type, series: u.Series, timestamp: u.Timestamp}
}

func (u *VariableValue) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "series":
		if u.series == nil {
			return nil, fmt.Errorf("field \"series\" is required")
		}
		return struct {
			Type   string         `json:"type"`
			Series api.SeriesSpec `json:"series"`
		}{Type: "series", Series: *u.series}, nil
	case "timestamp":
		if u.timestamp == nil {
			return nil, fmt.Errorf("field \"timestamp\" is required")
		}
		return struct {
			Type      string         `json:"type"`
			Timestamp api1.Timestamp `json:"timestamp"`
		}{Type: "timestamp", Timestamp: *u.timestamp}, nil
	}
}

func (u VariableValue) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VariableValue) UnmarshalJSON(data []byte) error {
	var deser variableValueDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
	}
	return nil
}

func (u VariableValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VariableValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VariableValue) AcceptFuncs(seriesFunc func(api.SeriesSpec) error, timestampFunc func(api1.Timestamp) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return timestampFunc(*u.timestamp)
	}
}

func (u *VariableValue) SeriesNoopSuccess(api.SeriesSpec) error {
	return nil
}

func (u *VariableValue) TimestampNoopSuccess(api1.Timestamp) error {
	return nil
}

func (u *VariableValue) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VariableValue) Accept(v VariableValueVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(*u.series)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestamp(*u.timestamp)
	}
}

type VariableValueVisitor interface {
	VisitSeries(v api.SeriesSpec) error
	VisitTimestamp(v api1.Timestamp) error
	VisitUnknown(typeName string) error
}

func (u *VariableValue) AcceptWithContext(ctx context.Context, v VariableValueVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeriesWithContext(ctx, *u.series)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestampWithContext(ctx, *u.timestamp)
	}
}

type VariableValueVisitorWithContext interface {
	VisitSeriesWithContext(ctx context.Context, v api.SeriesSpec) error
	VisitTimestampWithContext(ctx context.Context, v api1.Timestamp) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVariableValueFromSeries(v api.SeriesSpec) VariableValue {
	return VariableValue{typ: "series", series: &v}
}

func NewVariableValueFromTimestamp(v api1.Timestamp) VariableValue {
	return VariableValue{typ: "timestamp", timestamp: &v}
}

type Window struct {
	typ      string
	duration *api2.Duration
}

type windowDeserializer struct {
	Type     string         `json:"type"`
	Duration *api2.Duration `json:"duration"`
}

func (u *windowDeserializer) toStruct() Window {
	return Window{typ: u.Type, duration: u.Duration}
}

func (u *Window) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "duration":
		if u.duration == nil {
			return nil, fmt.Errorf("field \"duration\" is required")
		}
		return struct {
			Type     string        `json:"type"`
			Duration api2.Duration `json:"duration"`
		}{Type: "duration", Duration: *u.duration}, nil
	}
}

func (u Window) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Window) UnmarshalJSON(data []byte) error {
	var deser windowDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
	}
	return nil
}

func (u Window) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Window) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Window) AcceptFuncs(durationFunc func(api2.Duration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return durationFunc(*u.duration)
	}
}

func (u *Window) DurationNoopSuccess(api2.Duration) error {
	return nil
}

func (u *Window) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Window) Accept(v WindowVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDuration(*u.duration)
	}
}

type WindowVisitor interface {
	VisitDuration(v api2.Duration) error
	VisitUnknown(typeName string) error
}

func (u *Window) AcceptWithContext(ctx context.Context, v WindowVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDurationWithContext(ctx, *u.duration)
	}
}

type WindowVisitorWithContext interface {
	VisitDurationWithContext(ctx context.Context, v api2.Duration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewWindowFromDuration(v api2.Duration) Window {
	return Window{typ: "duration", duration: &v}
}
