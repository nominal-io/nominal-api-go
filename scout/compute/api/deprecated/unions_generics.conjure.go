// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package deprecated

import (
	"context"
	"fmt"

	api1 "github.com/nominal-io/nominal-api/io/nominal/api"
	"github.com/nominal-io/nominal-api/scout/compute/api"
	api2 "github.com/nominal-io/nominal-api/scout/run/api"
)

type CartesianNodeWithT[T any] CartesianNode

func (u *CartesianNodeWithT[T]) Accept(ctx context.Context, v CartesianNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(ctx, *u.scatter)
	}
}

func (u *CartesianNodeWithT[T]) AcceptFuncs(scatterFunc func(ScatterNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *CartesianNodeWithT[T]) ScatterNoopSuccess(ScatterNode) (T, error) {
	var result T
	return result, nil
}

func (u *CartesianNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CartesianNodeVisitorWithT[T any] interface {
	VisitScatter(ctx context.Context, v ScatterNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComputableNodeWithT[T any] ComputableNode

func (u *ComputableNodeWithT[T]) Accept(ctx context.Context, v ComputableNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(ctx, *u.ranges)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(ctx, *u.series)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(ctx, *u.value)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(ctx, *u.cartesian)
	case "frequency":
		if u.frequency == nil {
			return result, fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequency(ctx, *u.frequency)
	}
}

func (u *ComputableNodeWithT[T]) AcceptFuncs(rangesFunc func(SummarizeRangesNode) (T, error), seriesFunc func(SummarizeSeriesNode) (T, error), valueFunc func(SelectValueNode) (T, error), cartesianFunc func(SummarizeCartesianNode) (T, error), frequencyFunc func(FrequencyDomainNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "frequency":
		if u.frequency == nil {
			return result, fmt.Errorf("field \"frequency\" is required")
		}
		return frequencyFunc(*u.frequency)
	}
}

func (u *ComputableNodeWithT[T]) RangesNoopSuccess(SummarizeRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) SeriesNoopSuccess(SummarizeSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) ValueNoopSuccess(SelectValueNode) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) CartesianNoopSuccess(SummarizeCartesianNode) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) FrequencyNoopSuccess(FrequencyDomainNode) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComputableNodeVisitorWithT[T any] interface {
	VisitRanges(ctx context.Context, v SummarizeRangesNode) (T, error)
	VisitSeries(ctx context.Context, v SummarizeSeriesNode) (T, error)
	VisitValue(ctx context.Context, v SelectValueNode) (T, error)
	VisitCartesian(ctx context.Context, v SummarizeCartesianNode) (T, error)
	VisitFrequency(ctx context.Context, v FrequencyDomainNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EnumSeriesNodeWithT[T any] EnumSeriesNode

func (u *EnumSeriesNodeWithT[T]) Accept(ctx context.Context, v EnumSeriesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(ctx, *u.timeShift)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(ctx, *u.union)
	}
}

func (u *EnumSeriesNodeWithT[T]) AcceptFuncs(rawFunc func(api.Reference) (T, error), timeRangeFilterFunc func(EnumTimeRangeFilterSeriesNode) (T, error), timeShiftFunc func(EnumTimeShiftSeriesNode) (T, error), unionFunc func(EnumUnionSeriesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	}
}

func (u *EnumSeriesNodeWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) TimeRangeFilterNoopSuccess(EnumTimeRangeFilterSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) TimeShiftNoopSuccess(EnumTimeShiftSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) UnionNoopSuccess(EnumUnionSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EnumSeriesNodeVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitTimeRangeFilter(ctx context.Context, v EnumTimeRangeFilterSeriesNode) (T, error)
	VisitTimeShift(ctx context.Context, v EnumTimeShiftSeriesNode) (T, error)
	VisitUnion(ctx context.Context, v EnumUnionSeriesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FrequencyDomainNodeWithT[T any] FrequencyDomainNode

func (u *FrequencyDomainNodeWithT[T]) Accept(ctx context.Context, v FrequencyDomainNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(ctx, *u.fft)
	}
}

func (u *FrequencyDomainNodeWithT[T]) AcceptFuncs(fftFunc func(FftNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	}
}

func (u *FrequencyDomainNodeWithT[T]) FftNoopSuccess(FftNode) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FrequencyDomainNodeVisitorWithT[T any] interface {
	VisitFft(ctx context.Context, v FftNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericSeriesNodeWithT[T any] NumericSeriesNode

func (u *NumericSeriesNodeWithT[T]) Accept(ctx context.Context, v NumericSeriesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "arithmetic":
		if u.arithmetic == nil {
			return result, fmt.Errorf("field \"arithmetic\" is required")
		}
		return v.VisitArithmetic(ctx, *u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return result, fmt.Errorf("field \"bitOperation\" is required")
		}
		return v.VisitBitOperation(ctx, *u.bitOperation)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return result, fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return v.VisitCumulativeSum(ctx, *u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return result, fmt.Errorf("field \"derivative\" is required")
		}
		return v.VisitDerivative(ctx, *u.derivative)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return result, fmt.Errorf("field \"rollingOperation\" is required")
		}
		return v.VisitRollingOperation(ctx, *u.rollingOperation)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return result, fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return v.VisitUnaryArithmetic(ctx, *u.unaryArithmetic)
	case "timeDifference":
		if u.timeDifference == nil {
			return result, fmt.Errorf("field \"timeDifference\" is required")
		}
		return v.VisitTimeDifference(ctx, *u.timeDifference)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(ctx, *u.timeShift)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(ctx, *u.union)
	case "valueDifference":
		if u.valueDifference == nil {
			return result, fmt.Errorf("field \"valueDifference\" is required")
		}
		return v.VisitValueDifference(ctx, *u.valueDifference)
	}
}

func (u *NumericSeriesNodeWithT[T]) AcceptFuncs(rawFunc func(api.Reference) (T, error), arithmeticFunc func(ArithmeticSeriesNode) (T, error), bitOperationFunc func(BitOperationSeriesNode) (T, error), cumulativeSumFunc func(CumulativeSumSeriesNode) (T, error), derivativeFunc func(DerivativeSeriesNode) (T, error), rollingOperationFunc func(RollingOperationSeriesNode) (T, error), unaryArithmeticFunc func(UnaryArithmeticSeriesNode) (T, error), timeDifferenceFunc func(TimeDifferenceSeriesNode) (T, error), timeRangeFilterFunc func(NumericTimeRangeFilterSeriesNode) (T, error), timeShiftFunc func(NumericTimeShiftSeriesNode) (T, error), unionFunc func(NumericUnionSeriesNode) (T, error), valueDifferenceFunc func(ValueDifferenceSeriesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "arithmetic":
		if u.arithmetic == nil {
			return result, fmt.Errorf("field \"arithmetic\" is required")
		}
		return arithmeticFunc(*u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return result, fmt.Errorf("field \"bitOperation\" is required")
		}
		return bitOperationFunc(*u.bitOperation)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return result, fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return cumulativeSumFunc(*u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return result, fmt.Errorf("field \"derivative\" is required")
		}
		return derivativeFunc(*u.derivative)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return result, fmt.Errorf("field \"rollingOperation\" is required")
		}
		return rollingOperationFunc(*u.rollingOperation)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return result, fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return unaryArithmeticFunc(*u.unaryArithmetic)
	case "timeDifference":
		if u.timeDifference == nil {
			return result, fmt.Errorf("field \"timeDifference\" is required")
		}
		return timeDifferenceFunc(*u.timeDifference)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "valueDifference":
		if u.valueDifference == nil {
			return result, fmt.Errorf("field \"valueDifference\" is required")
		}
		return valueDifferenceFunc(*u.valueDifference)
	}
}

func (u *NumericSeriesNodeWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) ArithmeticNoopSuccess(ArithmeticSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) BitOperationNoopSuccess(BitOperationSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) CumulativeSumNoopSuccess(CumulativeSumSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) DerivativeNoopSuccess(DerivativeSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) RollingOperationNoopSuccess(RollingOperationSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) UnaryArithmeticNoopSuccess(UnaryArithmeticSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) TimeDifferenceNoopSuccess(TimeDifferenceSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) TimeRangeFilterNoopSuccess(NumericTimeRangeFilterSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) TimeShiftNoopSuccess(NumericTimeShiftSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) UnionNoopSuccess(NumericUnionSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) ValueDifferenceNoopSuccess(ValueDifferenceSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericSeriesNodeVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitArithmetic(ctx context.Context, v ArithmeticSeriesNode) (T, error)
	VisitBitOperation(ctx context.Context, v BitOperationSeriesNode) (T, error)
	VisitCumulativeSum(ctx context.Context, v CumulativeSumSeriesNode) (T, error)
	VisitDerivative(ctx context.Context, v DerivativeSeriesNode) (T, error)
	VisitRollingOperation(ctx context.Context, v RollingOperationSeriesNode) (T, error)
	VisitUnaryArithmetic(ctx context.Context, v UnaryArithmeticSeriesNode) (T, error)
	VisitTimeDifference(ctx context.Context, v TimeDifferenceSeriesNode) (T, error)
	VisitTimeRangeFilter(ctx context.Context, v NumericTimeRangeFilterSeriesNode) (T, error)
	VisitTimeShift(ctx context.Context, v NumericTimeShiftSeriesNode) (T, error)
	VisitUnion(ctx context.Context, v NumericUnionSeriesNode) (T, error)
	VisitValueDifference(ctx context.Context, v ValueDifferenceSeriesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type RangesNodeWithT[T any] RangesNode

func (u *RangesNodeWithT[T]) Accept(ctx context.Context, v RangesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "onChange":
		if u.onChange == nil {
			return result, fmt.Errorf("field \"onChange\" is required")
		}
		return v.VisitOnChange(ctx, *u.onChange)
	case "enumFilter":
		if u.enumFilter == nil {
			return result, fmt.Errorf("field \"enumFilter\" is required")
		}
		return v.VisitEnumFilter(ctx, *u.enumFilter)
	case "threshold":
		if u.threshold == nil {
			return result, fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThreshold(ctx, *u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return result, fmt.Errorf("field \"unionRange\" is required")
		}
		return v.VisitUnionRange(ctx, *u.unionRange)
	case "intersectRange":
		if u.intersectRange == nil {
			return result, fmt.Errorf("field \"intersectRange\" is required")
		}
		return v.VisitIntersectRange(ctx, *u.intersectRange)
	}
}

func (u *RangesNodeWithT[T]) AcceptFuncs(onChangeFunc func(OnChangeRangesNode) (T, error), enumFilterFunc func(EnumFilterRangesNode) (T, error), thresholdFunc func(ThresholdingRangesNode) (T, error), unionRangeFunc func(UnionRangesNode) (T, error), intersectRangeFunc func(IntersectRangesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "onChange":
		if u.onChange == nil {
			return result, fmt.Errorf("field \"onChange\" is required")
		}
		return onChangeFunc(*u.onChange)
	case "enumFilter":
		if u.enumFilter == nil {
			return result, fmt.Errorf("field \"enumFilter\" is required")
		}
		return enumFilterFunc(*u.enumFilter)
	case "threshold":
		if u.threshold == nil {
			return result, fmt.Errorf("field \"threshold\" is required")
		}
		return thresholdFunc(*u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return result, fmt.Errorf("field \"unionRange\" is required")
		}
		return unionRangeFunc(*u.unionRange)
	case "intersectRange":
		if u.intersectRange == nil {
			return result, fmt.Errorf("field \"intersectRange\" is required")
		}
		return intersectRangeFunc(*u.intersectRange)
	}
}

func (u *RangesNodeWithT[T]) OnChangeNoopSuccess(OnChangeRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) EnumFilterNoopSuccess(EnumFilterRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) ThresholdNoopSuccess(ThresholdingRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) UnionRangeNoopSuccess(UnionRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) IntersectRangeNoopSuccess(IntersectRangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *RangesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type RangesNodeVisitorWithT[T any] interface {
	VisitOnChange(ctx context.Context, v OnChangeRangesNode) (T, error)
	VisitEnumFilter(ctx context.Context, v EnumFilterRangesNode) (T, error)
	VisitThreshold(ctx context.Context, v ThresholdingRangesNode) (T, error)
	VisitUnionRange(ctx context.Context, v UnionRangesNode) (T, error)
	VisitIntersectRange(ctx context.Context, v IntersectRangesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SelectValueNodeWithT[T any] SelectValueNode

func (u *SelectValueNodeWithT[T]) Accept(ctx context.Context, v SelectValueNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return result, fmt.Errorf("field \"firstPoint\" is required")
		}
		return v.VisitFirstPoint(ctx, *u.firstPoint)
	case "firstRange":
		if u.firstRange == nil {
			return result, fmt.Errorf("field \"firstRange\" is required")
		}
		return v.VisitFirstRange(ctx, *u.firstRange)
	}
}

func (u *SelectValueNodeWithT[T]) AcceptFuncs(firstPointFunc func(SeriesNode) (T, error), firstRangeFunc func(RangesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return result, fmt.Errorf("field \"firstPoint\" is required")
		}
		return firstPointFunc(*u.firstPoint)
	case "firstRange":
		if u.firstRange == nil {
			return result, fmt.Errorf("field \"firstRange\" is required")
		}
		return firstRangeFunc(*u.firstRange)
	}
}

func (u *SelectValueNodeWithT[T]) FirstPointNoopSuccess(SeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueNodeWithT[T]) FirstRangeNoopSuccess(RangesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SelectValueNodeVisitorWithT[T any] interface {
	VisitFirstPoint(ctx context.Context, v SeriesNode) (T, error)
	VisitFirstRange(ctx context.Context, v RangesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SeriesNodeWithT[T any] SeriesNode

func (u *SeriesNodeWithT[T]) Accept(ctx context.Context, v SeriesNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	}
}

func (u *SeriesNodeWithT[T]) AcceptFuncs(rawFunc func(api.Reference) (T, error), enumFunc func(EnumSeriesNode) (T, error), numericFunc func(NumericSeriesNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	}
}

func (u *SeriesNodeWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesNodeWithT[T]) EnumNoopSuccess(EnumSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesNodeWithT[T]) NumericNoopSuccess(NumericSeriesNode) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SeriesNodeVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitEnum(ctx context.Context, v EnumSeriesNode) (T, error)
	VisitNumeric(ctx context.Context, v NumericSeriesNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VariableValueWithT[T any] VariableValue

func (u *VariableValueWithT[T]) Accept(ctx context.Context, v VariableValueVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(ctx, *u.series)
	case "timestamp":
		if u.timestamp == nil {
			return result, fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestamp(ctx, *u.timestamp)
	}
}

func (u *VariableValueWithT[T]) AcceptFuncs(seriesFunc func(api.SeriesSpec) (T, error), timestampFunc func(api1.Timestamp) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "timestamp":
		if u.timestamp == nil {
			return result, fmt.Errorf("field \"timestamp\" is required")
		}
		return timestampFunc(*u.timestamp)
	}
}

func (u *VariableValueWithT[T]) SeriesNoopSuccess(api.SeriesSpec) (T, error) {
	var result T
	return result, nil
}

func (u *VariableValueWithT[T]) TimestampNoopSuccess(api1.Timestamp) (T, error) {
	var result T
	return result, nil
}

func (u *VariableValueWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VariableValueVisitorWithT[T any] interface {
	VisitSeries(ctx context.Context, v api.SeriesSpec) (T, error)
	VisitTimestamp(ctx context.Context, v api1.Timestamp) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type WindowWithT[T any] Window

func (u *WindowWithT[T]) Accept(ctx context.Context, v WindowVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "duration":
		if u.duration == nil {
			return result, fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDuration(ctx, *u.duration)
	}
}

func (u *WindowWithT[T]) AcceptFuncs(durationFunc func(api2.Duration) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "duration":
		if u.duration == nil {
			return result, fmt.Errorf("field \"duration\" is required")
		}
		return durationFunc(*u.duration)
	}
}

func (u *WindowWithT[T]) DurationNoopSuccess(api2.Duration) (T, error) {
	var result T
	return result, nil
}

func (u *WindowWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type WindowVisitorWithT[T any] interface {
	VisitDuration(ctx context.Context, v api2.Duration) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
