// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/units/api"
)

type ArrowArrayPlotWithT[T any] ArrowArrayPlot

func (u *ArrowArrayPlotWithT[T]) Accept(ctx context.Context, v ArrowArrayPlotVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return result, fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumeric(ctx, *u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return result, fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnum(ctx, *u.bucketedEnum)
	}
}

func (u *ArrowArrayPlotWithT[T]) AcceptFuncs(bucketedNumericFunc func(BucketedNumericArrayPlot) (T, error), bucketedEnumFunc func(BucketedEnumArrayPlot) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return result, fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return bucketedNumericFunc(*u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return result, fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return bucketedEnumFunc(*u.bucketedEnum)
	}
}

func (u *ArrowArrayPlotWithT[T]) BucketedNumericNoopSuccess(BucketedNumericArrayPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ArrowArrayPlotWithT[T]) BucketedEnumNoopSuccess(BucketedEnumArrayPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ArrowArrayPlotWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ArrowArrayPlotVisitorWithT[T any] interface {
	VisitBucketedNumeric(ctx context.Context, v BucketedNumericArrayPlot) (T, error)
	VisitBucketedEnum(ctx context.Context, v BucketedEnumArrayPlot) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type BitOperationFunctionWithT[T any] BitOperationFunction

func (u *BitOperationFunctionWithT[T]) Accept(ctx context.Context, v BitOperationFunctionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "xor":
		if u.xor == nil {
			return result, fmt.Errorf("field \"xor\" is required")
		}
		return v.VisitXor(ctx, *u.xor)
	case "shiftRight":
		if u.shiftRight == nil {
			return result, fmt.Errorf("field \"shiftRight\" is required")
		}
		return v.VisitShiftRight(ctx, *u.shiftRight)
	case "shiftLeft":
		if u.shiftLeft == nil {
			return result, fmt.Errorf("field \"shiftLeft\" is required")
		}
		return v.VisitShiftLeft(ctx, *u.shiftLeft)
	case "bitTest":
		if u.bitTest == nil {
			return result, fmt.Errorf("field \"bitTest\" is required")
		}
		return v.VisitBitTest(ctx, *u.bitTest)
	}
}

func (u *BitOperationFunctionWithT[T]) AcceptFuncs(andFunc func(BitAndFunction) (T, error), orFunc func(BitOrFunction) (T, error), xorFunc func(BitXorFunction) (T, error), shiftRightFunc func(BitShiftRightFunction) (T, error), shiftLeftFunc func(BitShiftLeftFunction) (T, error), bitTestFunc func(BitTestFunction) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "xor":
		if u.xor == nil {
			return result, fmt.Errorf("field \"xor\" is required")
		}
		return xorFunc(*u.xor)
	case "shiftRight":
		if u.shiftRight == nil {
			return result, fmt.Errorf("field \"shiftRight\" is required")
		}
		return shiftRightFunc(*u.shiftRight)
	case "shiftLeft":
		if u.shiftLeft == nil {
			return result, fmt.Errorf("field \"shiftLeft\" is required")
		}
		return shiftLeftFunc(*u.shiftLeft)
	case "bitTest":
		if u.bitTest == nil {
			return result, fmt.Errorf("field \"bitTest\" is required")
		}
		return bitTestFunc(*u.bitTest)
	}
}

func (u *BitOperationFunctionWithT[T]) AndNoopSuccess(BitAndFunction) (T, error) {
	var result T
	return result, nil
}

func (u *BitOperationFunctionWithT[T]) OrNoopSuccess(BitOrFunction) (T, error) {
	var result T
	return result, nil
}

func (u *BitOperationFunctionWithT[T]) XorNoopSuccess(BitXorFunction) (T, error) {
	var result T
	return result, nil
}

func (u *BitOperationFunctionWithT[T]) ShiftRightNoopSuccess(BitShiftRightFunction) (T, error) {
	var result T
	return result, nil
}

func (u *BitOperationFunctionWithT[T]) ShiftLeftNoopSuccess(BitShiftLeftFunction) (T, error) {
	var result T
	return result, nil
}

func (u *BitOperationFunctionWithT[T]) BitTestNoopSuccess(BitTestFunction) (T, error) {
	var result T
	return result, nil
}

func (u *BitOperationFunctionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type BitOperationFunctionVisitorWithT[T any] interface {
	VisitAnd(ctx context.Context, v BitAndFunction) (T, error)
	VisitOr(ctx context.Context, v BitOrFunction) (T, error)
	VisitXor(ctx context.Context, v BitXorFunction) (T, error)
	VisitShiftRight(ctx context.Context, v BitShiftRightFunction) (T, error)
	VisitShiftLeft(ctx context.Context, v BitShiftLeftFunction) (T, error)
	VisitBitTest(ctx context.Context, v BitTestFunction) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ChannelSeriesWithT[T any] ChannelSeries

func (u *ChannelSeriesWithT[T]) Accept(ctx context.Context, v ChannelSeriesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "dataSource":
		if u.dataSource == nil {
			return result, fmt.Errorf("field \"dataSource\" is required")
		}
		return v.VisitDataSource(ctx, *u.dataSource)
	case "asset":
		if u.asset == nil {
			return result, fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAsset(ctx, *u.asset)
	case "run":
		if u.run == nil {
			return result, fmt.Errorf("field \"run\" is required")
		}
		return v.VisitRun(ctx, *u.run)
	}
}

func (u *ChannelSeriesWithT[T]) AcceptFuncs(dataSourceFunc func(DataSourceChannel) (T, error), assetFunc func(AssetChannel) (T, error), runFunc func(RunChannel) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dataSource":
		if u.dataSource == nil {
			return result, fmt.Errorf("field \"dataSource\" is required")
		}
		return dataSourceFunc(*u.dataSource)
	case "asset":
		if u.asset == nil {
			return result, fmt.Errorf("field \"asset\" is required")
		}
		return assetFunc(*u.asset)
	case "run":
		if u.run == nil {
			return result, fmt.Errorf("field \"run\" is required")
		}
		return runFunc(*u.run)
	}
}

func (u *ChannelSeriesWithT[T]) DataSourceNoopSuccess(DataSourceChannel) (T, error) {
	var result T
	return result, nil
}

func (u *ChannelSeriesWithT[T]) AssetNoopSuccess(AssetChannel) (T, error) {
	var result T
	return result, nil
}

func (u *ChannelSeriesWithT[T]) RunNoopSuccess(RunChannel) (T, error) {
	var result T
	return result, nil
}

func (u *ChannelSeriesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ChannelSeriesVisitorWithT[T any] interface {
	VisitDataSource(ctx context.Context, v DataSourceChannel) (T, error)
	VisitAsset(ctx context.Context, v AssetChannel) (T, error)
	VisitRun(ctx context.Context, v RunChannel) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComputeNodeResponseWithT[T any] ComputeNodeResponse

func (u *ComputeNodeResponseWithT[T]) Accept(ctx context.Context, v ComputeNodeResponseVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(ctx, *u.range_)
	case "rangesSummary":
		if u.rangesSummary == nil {
			return result, fmt.Errorf("field \"rangesSummary\" is required")
		}
		return v.VisitRangesSummary(ctx, *u.rangesSummary)
	case "rangeValue":
		var rangeValue *Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return v.VisitRangeValue(ctx, rangeValue)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return result, fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumeric(ctx, *u.bucketedNumeric)
	case "numericPoint":
		var numericPoint *NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return v.VisitNumericPoint(ctx, numericPoint)
	case "singlePoint":
		var singlePoint *SinglePoint
		if u.singlePoint != nil {
			singlePoint = *u.singlePoint
		}
		return v.VisitSinglePoint(ctx, singlePoint)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return result, fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return v.VisitArrowNumeric(ctx, *u.arrowNumeric)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return result, fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return v.VisitArrowBucketedNumeric(ctx, *u.arrowBucketedNumeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "enumPoint":
		var enumPoint *EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return v.VisitEnumPoint(ctx, enumPoint)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return result, fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnum(ctx, *u.bucketedEnum)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return result, fmt.Errorf("field \"arrowEnum\" is required")
		}
		return v.VisitArrowEnum(ctx, *u.arrowEnum)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return result, fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return v.VisitArrowBucketedEnum(ctx, *u.arrowBucketedEnum)
	case "pagedLog":
		if u.pagedLog == nil {
			return result, fmt.Errorf("field \"pagedLog\" is required")
		}
		return v.VisitPagedLog(ctx, *u.pagedLog)
	case "logPoint":
		var logPoint *LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return v.VisitLogPoint(ctx, logPoint)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(ctx, *u.cartesian)
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return result, fmt.Errorf("field \"bucketedCartesian\" is required")
		}
		return v.VisitBucketedCartesian(ctx, *u.bucketedCartesian)
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return result, fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
		return v.VisitBucketedCartesian3d(ctx, *u.bucketedCartesian3d)
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return result, fmt.Errorf("field \"frequencyDomain\" is required")
		}
		return v.VisitFrequencyDomain(ctx, *u.frequencyDomain)
	case "frequencyDomainV2":
		if u.frequencyDomainV2 == nil {
			return result, fmt.Errorf("field \"frequencyDomainV2\" is required")
		}
		return v.VisitFrequencyDomainV2(ctx, *u.frequencyDomainV2)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return result, fmt.Errorf("field \"numericHistogram\" is required")
		}
		return v.VisitNumericHistogram(ctx, *u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return result, fmt.Errorf("field \"enumHistogram\" is required")
		}
		return v.VisitEnumHistogram(ctx, *u.enumHistogram)
	case "curveFit":
		if u.curveFit == nil {
			return result, fmt.Errorf("field \"curveFit\" is required")
		}
		return v.VisitCurveFit(ctx, *u.curveFit)
	case "grouped":
		if u.grouped == nil {
			return result, fmt.Errorf("field \"grouped\" is required")
		}
		return v.VisitGrouped(ctx, *u.grouped)
	case "array":
		if u.array == nil {
			return result, fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(ctx, *u.array)
	case "bucketedStruct":
		if u.bucketedStruct == nil {
			return result, fmt.Errorf("field \"bucketedStruct\" is required")
		}
		return v.VisitBucketedStruct(ctx, *u.bucketedStruct)
	case "fullResolution":
		if u.fullResolution == nil {
			return result, fmt.Errorf("field \"fullResolution\" is required")
		}
		return v.VisitFullResolution(ctx, *u.fullResolution)
	}
}

func (u *ComputeNodeResponseWithT[T]) AcceptFuncs(range_Func func([]Range) (T, error), rangesSummaryFunc func(RangesSummary) (T, error), rangeValueFunc func(*Range) (T, error), numericFunc func(NumericPlot) (T, error), bucketedNumericFunc func(BucketedNumericPlot) (T, error), numericPointFunc func(*NumericPoint) (T, error), singlePointFunc func(*SinglePoint) (T, error), arrowNumericFunc func(ArrowNumericPlot) (T, error), arrowBucketedNumericFunc func(ArrowBucketedNumericPlot) (T, error), enumFunc func(EnumPlot) (T, error), enumPointFunc func(*EnumPoint) (T, error), bucketedEnumFunc func(BucketedEnumPlot) (T, error), arrowEnumFunc func(ArrowEnumPlot) (T, error), arrowBucketedEnumFunc func(ArrowBucketedEnumPlot) (T, error), pagedLogFunc func(PagedLogPlot) (T, error), logPointFunc func(*LogPoint) (T, error), cartesianFunc func(CartesianPlot) (T, error), bucketedCartesianFunc func(BucketedCartesianPlot) (T, error), bucketedCartesian3dFunc func(BucketedCartesian3dPlot) (T, error), frequencyDomainFunc func(FrequencyDomainPlot) (T, error), frequencyDomainV2Func func(FrequencyDomainPlotV2) (T, error), numericHistogramFunc func(NumericHistogramPlot) (T, error), enumHistogramFunc func(EnumHistogramPlot) (T, error), curveFitFunc func(CurveFitResult) (T, error), groupedFunc func(GroupedComputeNodeResponses) (T, error), arrayFunc func(ArrowArrayPlot) (T, error), bucketedStructFunc func(ArrowBucketedStructPlot) (T, error), fullResolutionFunc func(ArrowFullResolutionPlot) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "rangesSummary":
		if u.rangesSummary == nil {
			return result, fmt.Errorf("field \"rangesSummary\" is required")
		}
		return rangesSummaryFunc(*u.rangesSummary)
	case "rangeValue":
		var rangeValue *Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return rangeValueFunc(rangeValue)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return result, fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return bucketedNumericFunc(*u.bucketedNumeric)
	case "numericPoint":
		var numericPoint *NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return numericPointFunc(numericPoint)
	case "singlePoint":
		var singlePoint *SinglePoint
		if u.singlePoint != nil {
			singlePoint = *u.singlePoint
		}
		return singlePointFunc(singlePoint)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return result, fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return arrowNumericFunc(*u.arrowNumeric)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return result, fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return arrowBucketedNumericFunc(*u.arrowBucketedNumeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "enumPoint":
		var enumPoint *EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return enumPointFunc(enumPoint)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return result, fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return bucketedEnumFunc(*u.bucketedEnum)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return result, fmt.Errorf("field \"arrowEnum\" is required")
		}
		return arrowEnumFunc(*u.arrowEnum)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return result, fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return arrowBucketedEnumFunc(*u.arrowBucketedEnum)
	case "pagedLog":
		if u.pagedLog == nil {
			return result, fmt.Errorf("field \"pagedLog\" is required")
		}
		return pagedLogFunc(*u.pagedLog)
	case "logPoint":
		var logPoint *LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return logPointFunc(logPoint)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return result, fmt.Errorf("field \"bucketedCartesian\" is required")
		}
		return bucketedCartesianFunc(*u.bucketedCartesian)
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return result, fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
		return bucketedCartesian3dFunc(*u.bucketedCartesian3d)
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return result, fmt.Errorf("field \"frequencyDomain\" is required")
		}
		return frequencyDomainFunc(*u.frequencyDomain)
	case "frequencyDomainV2":
		if u.frequencyDomainV2 == nil {
			return result, fmt.Errorf("field \"frequencyDomainV2\" is required")
		}
		return frequencyDomainV2Func(*u.frequencyDomainV2)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return result, fmt.Errorf("field \"numericHistogram\" is required")
		}
		return numericHistogramFunc(*u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return result, fmt.Errorf("field \"enumHistogram\" is required")
		}
		return enumHistogramFunc(*u.enumHistogram)
	case "curveFit":
		if u.curveFit == nil {
			return result, fmt.Errorf("field \"curveFit\" is required")
		}
		return curveFitFunc(*u.curveFit)
	case "grouped":
		if u.grouped == nil {
			return result, fmt.Errorf("field \"grouped\" is required")
		}
		return groupedFunc(*u.grouped)
	case "array":
		if u.array == nil {
			return result, fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	case "bucketedStruct":
		if u.bucketedStruct == nil {
			return result, fmt.Errorf("field \"bucketedStruct\" is required")
		}
		return bucketedStructFunc(*u.bucketedStruct)
	case "fullResolution":
		if u.fullResolution == nil {
			return result, fmt.Errorf("field \"fullResolution\" is required")
		}
		return fullResolutionFunc(*u.fullResolution)
	}
}

func (u *ComputeNodeResponseWithT[T]) RangeNoopSuccess([]Range) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) RangesSummaryNoopSuccess(RangesSummary) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) RangeValueNoopSuccess(*Range) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) NumericNoopSuccess(NumericPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) BucketedNumericNoopSuccess(BucketedNumericPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) NumericPointNoopSuccess(*NumericPoint) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) SinglePointNoopSuccess(*SinglePoint) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) ArrowNumericNoopSuccess(ArrowNumericPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) ArrowBucketedNumericNoopSuccess(ArrowBucketedNumericPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) EnumNoopSuccess(EnumPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) EnumPointNoopSuccess(*EnumPoint) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) BucketedEnumNoopSuccess(BucketedEnumPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) ArrowEnumNoopSuccess(ArrowEnumPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) ArrowBucketedEnumNoopSuccess(ArrowBucketedEnumPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) PagedLogNoopSuccess(PagedLogPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) LogPointNoopSuccess(*LogPoint) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) CartesianNoopSuccess(CartesianPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) BucketedCartesianNoopSuccess(BucketedCartesianPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) BucketedCartesian3dNoopSuccess(BucketedCartesian3dPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) FrequencyDomainNoopSuccess(FrequencyDomainPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) FrequencyDomainV2NoopSuccess(FrequencyDomainPlotV2) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) NumericHistogramNoopSuccess(NumericHistogramPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) EnumHistogramNoopSuccess(EnumHistogramPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) CurveFitNoopSuccess(CurveFitResult) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) GroupedNoopSuccess(GroupedComputeNodeResponses) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) ArrayNoopSuccess(ArrowArrayPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) BucketedStructNoopSuccess(ArrowBucketedStructPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) FullResolutionNoopSuccess(ArrowFullResolutionPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResponseWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComputeNodeResponseVisitorWithT[T any] interface {
	VisitRange(ctx context.Context, v []Range) (T, error)
	VisitRangesSummary(ctx context.Context, v RangesSummary) (T, error)
	VisitRangeValue(ctx context.Context, v *Range) (T, error)
	VisitNumeric(ctx context.Context, v NumericPlot) (T, error)
	VisitBucketedNumeric(ctx context.Context, v BucketedNumericPlot) (T, error)
	VisitNumericPoint(ctx context.Context, v *NumericPoint) (T, error)
	VisitSinglePoint(ctx context.Context, v *SinglePoint) (T, error)
	VisitArrowNumeric(ctx context.Context, v ArrowNumericPlot) (T, error)
	VisitArrowBucketedNumeric(ctx context.Context, v ArrowBucketedNumericPlot) (T, error)
	VisitEnum(ctx context.Context, v EnumPlot) (T, error)
	VisitEnumPoint(ctx context.Context, v *EnumPoint) (T, error)
	VisitBucketedEnum(ctx context.Context, v BucketedEnumPlot) (T, error)
	VisitArrowEnum(ctx context.Context, v ArrowEnumPlot) (T, error)
	VisitArrowBucketedEnum(ctx context.Context, v ArrowBucketedEnumPlot) (T, error)
	VisitPagedLog(ctx context.Context, v PagedLogPlot) (T, error)
	VisitLogPoint(ctx context.Context, v *LogPoint) (T, error)
	VisitCartesian(ctx context.Context, v CartesianPlot) (T, error)
	VisitBucketedCartesian(ctx context.Context, v BucketedCartesianPlot) (T, error)
	VisitBucketedCartesian3d(ctx context.Context, v BucketedCartesian3dPlot) (T, error)
	VisitFrequencyDomain(ctx context.Context, v FrequencyDomainPlot) (T, error)
	VisitFrequencyDomainV2(ctx context.Context, v FrequencyDomainPlotV2) (T, error)
	VisitNumericHistogram(ctx context.Context, v NumericHistogramPlot) (T, error)
	VisitEnumHistogram(ctx context.Context, v EnumHistogramPlot) (T, error)
	VisitCurveFit(ctx context.Context, v CurveFitResult) (T, error)
	VisitGrouped(ctx context.Context, v GroupedComputeNodeResponses) (T, error)
	VisitArray(ctx context.Context, v ArrowArrayPlot) (T, error)
	VisitBucketedStruct(ctx context.Context, v ArrowBucketedStructPlot) (T, error)
	VisitFullResolution(ctx context.Context, v ArrowFullResolutionPlot) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComputeNodeResultWithT[T any] ComputeNodeResult

func (u *ComputeNodeResultWithT[T]) Accept(ctx context.Context, v ComputeNodeResultVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(ctx, *u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(ctx, *u.error)
	}
}

func (u *ComputeNodeResultWithT[T]) AcceptFuncs(successFunc func(ComputeNodeResponse) (T, error), errorFunc func(ErrorResult) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *ComputeNodeResultWithT[T]) SuccessNoopSuccess(ComputeNodeResponse) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResultWithT[T]) ErrorNoopSuccess(ErrorResult) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeResultWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComputeNodeResultVisitorWithT[T any] interface {
	VisitSuccess(ctx context.Context, v ComputeNodeResponse) (T, error)
	VisitError(ctx context.Context, v ErrorResult) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComputeUnitResultWithT[T any] ComputeUnitResult

func (u *ComputeUnitResultWithT[T]) Accept(ctx context.Context, v ComputeUnitResultVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(ctx, *u.single)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(ctx, *u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return result, fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3d(ctx, *u.cartesian3d)
	}
}

func (u *ComputeUnitResultWithT[T]) AcceptFuncs(singleFunc func(UnitResult) (T, error), cartesianFunc func(CartesianUnitResult) (T, error), cartesian3dFunc func(Cartesian3dUnitResult) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return result, fmt.Errorf("field \"cartesian3d\" is required")
		}
		return cartesian3dFunc(*u.cartesian3d)
	}
}

func (u *ComputeUnitResultWithT[T]) SingleNoopSuccess(UnitResult) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeUnitResultWithT[T]) CartesianNoopSuccess(CartesianUnitResult) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeUnitResultWithT[T]) Cartesian3dNoopSuccess(Cartesian3dUnitResult) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeUnitResultWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComputeUnitResultVisitorWithT[T any] interface {
	VisitSingle(ctx context.Context, v UnitResult) (T, error)
	VisitCartesian(ctx context.Context, v CartesianUnitResult) (T, error)
	VisitCartesian3d(ctx context.Context, v Cartesian3dUnitResult) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CurveFitDetailsWithT[T any] CurveFitDetails

func (u *CurveFitDetailsWithT[T]) Accept(ctx context.Context, v CurveFitDetailsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "exponential":
		if u.exponential == nil {
			return result, fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponential(ctx, *u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return result, fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmic(ctx, *u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return result, fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomial(ctx, *u.polynomial)
	case "power":
		if u.power == nil {
			return result, fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPower(ctx, *u.power)
	}
}

func (u *CurveFitDetailsWithT[T]) AcceptFuncs(exponentialFunc func(ExponentialCurve) (T, error), logarithmicFunc func(LogarithmicCurve) (T, error), polynomialFunc func(PolynomialCurve) (T, error), powerFunc func(PowerCurve) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "exponential":
		if u.exponential == nil {
			return result, fmt.Errorf("field \"exponential\" is required")
		}
		return exponentialFunc(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return result, fmt.Errorf("field \"logarithmic\" is required")
		}
		return logarithmicFunc(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return result, fmt.Errorf("field \"polynomial\" is required")
		}
		return polynomialFunc(*u.polynomial)
	case "power":
		if u.power == nil {
			return result, fmt.Errorf("field \"power\" is required")
		}
		return powerFunc(*u.power)
	}
}

func (u *CurveFitDetailsWithT[T]) ExponentialNoopSuccess(ExponentialCurve) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitDetailsWithT[T]) LogarithmicNoopSuccess(LogarithmicCurve) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitDetailsWithT[T]) PolynomialNoopSuccess(PolynomialCurve) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitDetailsWithT[T]) PowerNoopSuccess(PowerCurve) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitDetailsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CurveFitDetailsVisitorWithT[T any] interface {
	VisitExponential(ctx context.Context, v ExponentialCurve) (T, error)
	VisitLogarithmic(ctx context.Context, v LogarithmicCurve) (T, error)
	VisitPolynomial(ctx context.Context, v PolynomialCurve) (T, error)
	VisitPower(ctx context.Context, v PowerCurve) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CurveResultDetailsWithT[T any] CurveResultDetails

func (u *CurveResultDetailsWithT[T]) Accept(ctx context.Context, v CurveResultDetailsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "exponential":
		if u.exponential == nil {
			return result, fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponential(ctx, *u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return result, fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmic(ctx, *u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return result, fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomial(ctx, *u.polynomial)
	case "power":
		if u.power == nil {
			return result, fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPower(ctx, *u.power)
	}
}

func (u *CurveResultDetailsWithT[T]) AcceptFuncs(exponentialFunc func(ExponentialResultDetails) (T, error), logarithmicFunc func(LogarithmicResultDetails) (T, error), polynomialFunc func(PolynomialResultDetails) (T, error), powerFunc func(PowerResultDetails) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "exponential":
		if u.exponential == nil {
			return result, fmt.Errorf("field \"exponential\" is required")
		}
		return exponentialFunc(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return result, fmt.Errorf("field \"logarithmic\" is required")
		}
		return logarithmicFunc(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return result, fmt.Errorf("field \"polynomial\" is required")
		}
		return polynomialFunc(*u.polynomial)
	case "power":
		if u.power == nil {
			return result, fmt.Errorf("field \"power\" is required")
		}
		return powerFunc(*u.power)
	}
}

func (u *CurveResultDetailsWithT[T]) ExponentialNoopSuccess(ExponentialResultDetails) (T, error) {
	var result T
	return result, nil
}

func (u *CurveResultDetailsWithT[T]) LogarithmicNoopSuccess(LogarithmicResultDetails) (T, error) {
	var result T
	return result, nil
}

func (u *CurveResultDetailsWithT[T]) PolynomialNoopSuccess(PolynomialResultDetails) (T, error) {
	var result T
	return result, nil
}

func (u *CurveResultDetailsWithT[T]) PowerNoopSuccess(PowerResultDetails) (T, error) {
	var result T
	return result, nil
}

func (u *CurveResultDetailsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CurveResultDetailsVisitorWithT[T any] interface {
	VisitExponential(ctx context.Context, v ExponentialResultDetails) (T, error)
	VisitLogarithmic(ctx context.Context, v LogarithmicResultDetails) (T, error)
	VisitPolynomial(ctx context.Context, v PolynomialResultDetails) (T, error)
	VisitPower(ctx context.Context, v PowerResultDetails) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type DecimateStrategyWithT[T any] DecimateStrategy

func (u *DecimateStrategyWithT[T]) Accept(ctx context.Context, v DecimateStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "resolution":
		if u.resolution == nil {
			return result, fmt.Errorf("field \"resolution\" is required")
		}
		return v.VisitResolution(ctx, *u.resolution)
	case "buckets":
		if u.buckets == nil {
			return result, fmt.Errorf("field \"buckets\" is required")
		}
		return v.VisitBuckets(ctx, *u.buckets)
	}
}

func (u *DecimateStrategyWithT[T]) AcceptFuncs(resolutionFunc func(DecimateWithResolution) (T, error), bucketsFunc func(DecimateWithBuckets) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "resolution":
		if u.resolution == nil {
			return result, fmt.Errorf("field \"resolution\" is required")
		}
		return resolutionFunc(*u.resolution)
	case "buckets":
		if u.buckets == nil {
			return result, fmt.Errorf("field \"buckets\" is required")
		}
		return bucketsFunc(*u.buckets)
	}
}

func (u *DecimateStrategyWithT[T]) ResolutionNoopSuccess(DecimateWithResolution) (T, error) {
	var result T
	return result, nil
}

func (u *DecimateStrategyWithT[T]) BucketsNoopSuccess(DecimateWithBuckets) (T, error) {
	var result T
	return result, nil
}

func (u *DecimateStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DecimateStrategyVisitorWithT[T any] interface {
	VisitResolution(ctx context.Context, v DecimateWithResolution) (T, error)
	VisitBuckets(ctx context.Context, v DecimateWithBuckets) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type DoubleConstantWithT[T any] DoubleConstant

func (u *DoubleConstantWithT[T]) Accept(ctx context.Context, v DoubleConstantVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(ctx, *u.variable)
	}
}

func (u *DoubleConstantWithT[T]) AcceptFuncs(literalFunc func(float64) (T, error), variableFunc func(VariableName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *DoubleConstantWithT[T]) LiteralNoopSuccess(float64) (T, error) {
	var result T
	return result, nil
}

func (u *DoubleConstantWithT[T]) VariableNoopSuccess(VariableName) (T, error) {
	var result T
	return result, nil
}

func (u *DoubleConstantWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DoubleConstantVisitorWithT[T any] interface {
	VisitLiteral(ctx context.Context, v float64) (T, error)
	VisitVariable(ctx context.Context, v VariableName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EnumResampleInterpolationConfigurationWithT[T any] EnumResampleInterpolationConfiguration

func (u *EnumResampleInterpolationConfigurationWithT[T]) Accept(ctx context.Context, v EnumResampleInterpolationConfigurationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return v.VisitForwardFillResampleInterpolationConfiguration(ctx, *u.forwardFillResampleInterpolationConfiguration)
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return v.VisitConstantResampleInterpolationConfiguration(ctx, *u.constantResampleInterpolationConfiguration)
	}
}

func (u *EnumResampleInterpolationConfigurationWithT[T]) AcceptFuncs(forwardFillResampleInterpolationConfigurationFunc func(ForwardFillResampleInterpolationConfiguration) (T, error), constantResampleInterpolationConfigurationFunc func(EnumConstantResampleInterpolationConfiguration) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return forwardFillResampleInterpolationConfigurationFunc(*u.forwardFillResampleInterpolationConfiguration)
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return constantResampleInterpolationConfigurationFunc(*u.constantResampleInterpolationConfiguration)
	}
}

func (u *EnumResampleInterpolationConfigurationWithT[T]) ForwardFillResampleInterpolationConfigurationNoopSuccess(ForwardFillResampleInterpolationConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *EnumResampleInterpolationConfigurationWithT[T]) ConstantResampleInterpolationConfigurationNoopSuccess(EnumConstantResampleInterpolationConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *EnumResampleInterpolationConfigurationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EnumResampleInterpolationConfigurationVisitorWithT[T any] interface {
	VisitForwardFillResampleInterpolationConfiguration(ctx context.Context, v ForwardFillResampleInterpolationConfiguration) (T, error)
	VisitConstantResampleInterpolationConfiguration(ctx context.Context, v EnumConstantResampleInterpolationConfiguration) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EventsEnumValueSourceWithT[T any] EventsEnumValueSource

func (u *EventsEnumValueSourceWithT[T]) Accept(ctx context.Context, v EventsEnumValueSourceVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	case "level":
		if u.level == nil {
			return result, fmt.Errorf("field \"level\" is required")
		}
		return v.VisitLevel(ctx, *u.level)
	}
}

func (u *EventsEnumValueSourceWithT[T]) AcceptFuncs(propertyFunc func(StringConstant) (T, error), levelFunc func(api.Empty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "level":
		if u.level == nil {
			return result, fmt.Errorf("field \"level\" is required")
		}
		return levelFunc(*u.level)
	}
}

func (u *EventsEnumValueSourceWithT[T]) PropertyNoopSuccess(StringConstant) (T, error) {
	var result T
	return result, nil
}

func (u *EventsEnumValueSourceWithT[T]) LevelNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *EventsEnumValueSourceWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EventsEnumValueSourceVisitorWithT[T any] interface {
	VisitProperty(ctx context.Context, v StringConstant) (T, error)
	VisitLevel(ctx context.Context, v api.Empty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FrequencyDomainPlotV2WithT[T any] FrequencyDomainPlotV2

func (u *FrequencyDomainPlotV2WithT[T]) Accept(ctx context.Context, v FrequencyDomainPlotV2VisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "real":
		if u.real == nil {
			return result, fmt.Errorf("field \"real\" is required")
		}
		return v.VisitReal(ctx, *u.real)
	case "complex":
		if u.complex == nil {
			return result, fmt.Errorf("field \"complex\" is required")
		}
		return v.VisitComplex(ctx, *u.complex)
	case "magnitudeAndPhase":
		if u.magnitudeAndPhase == nil {
			return result, fmt.Errorf("field \"magnitudeAndPhase\" is required")
		}
		return v.VisitMagnitudeAndPhase(ctx, *u.magnitudeAndPhase)
	}
}

func (u *FrequencyDomainPlotV2WithT[T]) AcceptFuncs(realFunc func(FrequencyDomainPlot) (T, error), complexFunc func(FrequencyDomainPlotComplex) (T, error), magnitudeAndPhaseFunc func(FrequencyDomainPlotMagnitudeAndPhase) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "real":
		if u.real == nil {
			return result, fmt.Errorf("field \"real\" is required")
		}
		return realFunc(*u.real)
	case "complex":
		if u.complex == nil {
			return result, fmt.Errorf("field \"complex\" is required")
		}
		return complexFunc(*u.complex)
	case "magnitudeAndPhase":
		if u.magnitudeAndPhase == nil {
			return result, fmt.Errorf("field \"magnitudeAndPhase\" is required")
		}
		return magnitudeAndPhaseFunc(*u.magnitudeAndPhase)
	}
}

func (u *FrequencyDomainPlotV2WithT[T]) RealNoopSuccess(FrequencyDomainPlot) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainPlotV2WithT[T]) ComplexNoopSuccess(FrequencyDomainPlotComplex) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainPlotV2WithT[T]) MagnitudeAndPhaseNoopSuccess(FrequencyDomainPlotMagnitudeAndPhase) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainPlotV2WithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FrequencyDomainPlotV2VisitorWithT[T any] interface {
	VisitReal(ctx context.Context, v FrequencyDomainPlot) (T, error)
	VisitComplex(ctx context.Context, v FrequencyDomainPlotComplex) (T, error)
	VisitMagnitudeAndPhase(ctx context.Context, v FrequencyDomainPlotMagnitudeAndPhase) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type GroupingWithT[T any] Grouping

func (u *GroupingWithT[T]) Accept(ctx context.Context, v GroupingVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return result, fmt.Errorf("field \"tagsWithValues\" is required")
		}
		return v.VisitTagsWithValues(ctx, *u.tagsWithValues)
	}
}

func (u *GroupingWithT[T]) AcceptFuncs(tagsWithValuesFunc func(map[string]string) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return result, fmt.Errorf("field \"tagsWithValues\" is required")
		}
		return tagsWithValuesFunc(*u.tagsWithValues)
	}
}

func (u *GroupingWithT[T]) TagsWithValuesNoopSuccess(map[string]string) (T, error) {
	var result T
	return result, nil
}

func (u *GroupingWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type GroupingVisitorWithT[T any] interface {
	VisitTagsWithValues(ctx context.Context, v map[string]string) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type IntegerConstantWithT[T any] IntegerConstant

func (u *IntegerConstantWithT[T]) Accept(ctx context.Context, v IntegerConstantVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(ctx, *u.variable)
	}
}

func (u *IntegerConstantWithT[T]) AcceptFuncs(literalFunc func(int) (T, error), variableFunc func(VariableName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *IntegerConstantWithT[T]) LiteralNoopSuccess(int) (T, error) {
	var result T
	return result, nil
}

func (u *IntegerConstantWithT[T]) VariableNoopSuccess(VariableName) (T, error) {
	var result T
	return result, nil
}

func (u *IntegerConstantWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type IntegerConstantVisitorWithT[T any] interface {
	VisitLiteral(ctx context.Context, v int) (T, error)
	VisitVariable(ctx context.Context, v VariableName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type LogFilterOperatorWithT[T any] LogFilterOperator

func (u *LogFilterOperatorWithT[T]) Accept(ctx context.Context, v LogFilterOperatorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "regexFilter":
		if u.regexFilter == nil {
			return result, fmt.Errorf("field \"regexFilter\" is required")
		}
		return v.VisitRegexFilter(ctx, *u.regexFilter)
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return result, fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
		return v.VisitExactMatchCaseInsensitiveFilter(ctx, *u.exactMatchCaseInsensitiveFilter)
	}
}

func (u *LogFilterOperatorWithT[T]) AcceptFuncs(regexFilterFunc func(LogRegexFilterOperator) (T, error), exactMatchCaseInsensitiveFilterFunc func(LogExactMatchCaseInsensitiveFilter) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "regexFilter":
		if u.regexFilter == nil {
			return result, fmt.Errorf("field \"regexFilter\" is required")
		}
		return regexFilterFunc(*u.regexFilter)
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return result, fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
		return exactMatchCaseInsensitiveFilterFunc(*u.exactMatchCaseInsensitiveFilter)
	}
}

func (u *LogFilterOperatorWithT[T]) RegexFilterNoopSuccess(LogRegexFilterOperator) (T, error) {
	var result T
	return result, nil
}

func (u *LogFilterOperatorWithT[T]) ExactMatchCaseInsensitiveFilterNoopSuccess(LogExactMatchCaseInsensitiveFilter) (T, error) {
	var result T
	return result, nil
}

func (u *LogFilterOperatorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LogFilterOperatorVisitorWithT[T any] interface {
	VisitRegexFilter(ctx context.Context, v LogRegexFilterOperator) (T, error)
	VisitExactMatchCaseInsensitiveFilter(ctx context.Context, v LogExactMatchCaseInsensitiveFilter) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ModuleVersionReferenceWithT[T any] ModuleVersionReference

func (u *ModuleVersionReferenceWithT[T]) Accept(ctx context.Context, v ModuleVersionReferenceVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "pinned":
		if u.pinned == nil {
			return result, fmt.Errorf("field \"pinned\" is required")
		}
		return v.VisitPinned(ctx, *u.pinned)
	}
}

func (u *ModuleVersionReferenceWithT[T]) AcceptFuncs(pinnedFunc func(PinnedModuleVersionReference) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pinned":
		if u.pinned == nil {
			return result, fmt.Errorf("field \"pinned\" is required")
		}
		return pinnedFunc(*u.pinned)
	}
}

func (u *ModuleVersionReferenceWithT[T]) PinnedNoopSuccess(PinnedModuleVersionReference) (T, error) {
	var result T
	return result, nil
}

func (u *ModuleVersionReferenceWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ModuleVersionReferenceVisitorWithT[T any] interface {
	VisitPinned(ctx context.Context, v PinnedModuleVersionReference) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NegativeValueConfigurationWithT[T any] NegativeValueConfiguration

func (u *NegativeValueConfigurationWithT[T]) Accept(ctx context.Context, v NegativeValueConfigurationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return result, fmt.Errorf("field \"allowNegativeValues\" is required")
		}
		return v.VisitAllowNegativeValues(ctx, *u.allowNegativeValues)
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return result, fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
		return v.VisitSetNegativeValuesToZero(ctx, *u.setNegativeValuesToZero)
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return result, fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
		return v.VisitExcludeNegativeValues(ctx, *u.excludeNegativeValues)
	}
}

func (u *NegativeValueConfigurationWithT[T]) AcceptFuncs(allowNegativeValuesFunc func(AllowNegativeValues) (T, error), setNegativeValuesToZeroFunc func(SetNegativeValuesToZero) (T, error), excludeNegativeValuesFunc func(ExcludeNegativeValues) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return result, fmt.Errorf("field \"allowNegativeValues\" is required")
		}
		return allowNegativeValuesFunc(*u.allowNegativeValues)
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return result, fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
		return setNegativeValuesToZeroFunc(*u.setNegativeValuesToZero)
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return result, fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
		return excludeNegativeValuesFunc(*u.excludeNegativeValues)
	}
}

func (u *NegativeValueConfigurationWithT[T]) AllowNegativeValuesNoopSuccess(AllowNegativeValues) (T, error) {
	var result T
	return result, nil
}

func (u *NegativeValueConfigurationWithT[T]) SetNegativeValuesToZeroNoopSuccess(SetNegativeValuesToZero) (T, error) {
	var result T
	return result, nil
}

func (u *NegativeValueConfigurationWithT[T]) ExcludeNegativeValuesNoopSuccess(ExcludeNegativeValues) (T, error) {
	var result T
	return result, nil
}

func (u *NegativeValueConfigurationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NegativeValueConfigurationVisitorWithT[T any] interface {
	VisitAllowNegativeValues(ctx context.Context, v AllowNegativeValues) (T, error)
	VisitSetNegativeValuesToZero(ctx context.Context, v SetNegativeValuesToZero) (T, error)
	VisitExcludeNegativeValues(ctx context.Context, v ExcludeNegativeValues) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericHistogramBucketStrategyWithT[T any] NumericHistogramBucketStrategy

func (u *NumericHistogramBucketStrategyWithT[T]) Accept(ctx context.Context, v NumericHistogramBucketStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return result, fmt.Errorf("field \"bucketCount\" is required")
		}
		return v.VisitBucketCount(ctx, *u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return result, fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return v.VisitBucketWidthAndOffset(ctx, *u.bucketWidthAndOffset)
	}
}

func (u *NumericHistogramBucketStrategyWithT[T]) AcceptFuncs(bucketCountFunc func(IntegerConstant) (T, error), bucketWidthAndOffsetFunc func(NumericHistogramBucketWidthAndOffset) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return result, fmt.Errorf("field \"bucketCount\" is required")
		}
		return bucketCountFunc(*u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return result, fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return bucketWidthAndOffsetFunc(*u.bucketWidthAndOffset)
	}
}

func (u *NumericHistogramBucketStrategyWithT[T]) BucketCountNoopSuccess(IntegerConstant) (T, error) {
	var result T
	return result, nil
}

func (u *NumericHistogramBucketStrategyWithT[T]) BucketWidthAndOffsetNoopSuccess(NumericHistogramBucketWidthAndOffset) (T, error) {
	var result T
	return result, nil
}

func (u *NumericHistogramBucketStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericHistogramBucketStrategyVisitorWithT[T any] interface {
	VisitBucketCount(ctx context.Context, v IntegerConstant) (T, error)
	VisitBucketWidthAndOffset(ctx context.Context, v NumericHistogramBucketWidthAndOffset) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericResampleInterpolationConfigurationWithT[T any] NumericResampleInterpolationConfiguration

func (u *NumericResampleInterpolationConfigurationWithT[T]) Accept(ctx context.Context, v NumericResampleInterpolationConfigurationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return v.VisitForwardFillResampleInterpolationConfiguration(ctx, *u.forwardFillResampleInterpolationConfiguration)
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return v.VisitConstantResampleInterpolationConfiguration(ctx, *u.constantResampleInterpolationConfiguration)
	}
}

func (u *NumericResampleInterpolationConfigurationWithT[T]) AcceptFuncs(forwardFillResampleInterpolationConfigurationFunc func(ForwardFillResampleInterpolationConfiguration) (T, error), constantResampleInterpolationConfigurationFunc func(NumericConstantResampleInterpolationConfiguration) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return forwardFillResampleInterpolationConfigurationFunc(*u.forwardFillResampleInterpolationConfiguration)
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return result, fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return constantResampleInterpolationConfigurationFunc(*u.constantResampleInterpolationConfiguration)
	}
}

func (u *NumericResampleInterpolationConfigurationWithT[T]) ForwardFillResampleInterpolationConfigurationNoopSuccess(ForwardFillResampleInterpolationConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *NumericResampleInterpolationConfigurationWithT[T]) ConstantResampleInterpolationConfigurationNoopSuccess(NumericConstantResampleInterpolationConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *NumericResampleInterpolationConfigurationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericResampleInterpolationConfigurationVisitorWithT[T any] interface {
	VisitForwardFillResampleInterpolationConfiguration(ctx context.Context, v ForwardFillResampleInterpolationConfiguration) (T, error)
	VisitConstantResampleInterpolationConfiguration(ctx context.Context, v NumericConstantResampleInterpolationConfiguration) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type OutputRangeStartWithT[T any] OutputRangeStart

func (u *OutputRangeStartWithT[T]) Accept(ctx context.Context, v OutputRangeStartVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return result, fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
		return v.VisitFirstPointMatchingCondition(ctx, *u.firstPointMatchingCondition)
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return result, fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
		return v.VisitAfterPersistenceWindow(ctx, *u.afterPersistenceWindow)
	}
}

func (u *OutputRangeStartWithT[T]) AcceptFuncs(firstPointMatchingConditionFunc func(FirstPointMatchingCondition) (T, error), afterPersistenceWindowFunc func(AfterPersistenceWindow) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return result, fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
		return firstPointMatchingConditionFunc(*u.firstPointMatchingCondition)
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return result, fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
		return afterPersistenceWindowFunc(*u.afterPersistenceWindow)
	}
}

func (u *OutputRangeStartWithT[T]) FirstPointMatchingConditionNoopSuccess(FirstPointMatchingCondition) (T, error) {
	var result T
	return result, nil
}

func (u *OutputRangeStartWithT[T]) AfterPersistenceWindowNoopSuccess(AfterPersistenceWindow) (T, error) {
	var result T
	return result, nil
}

func (u *OutputRangeStartWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type OutputRangeStartVisitorWithT[T any] interface {
	VisitFirstPointMatchingCondition(ctx context.Context, v FirstPointMatchingCondition) (T, error)
	VisitAfterPersistenceWindow(ctx context.Context, v AfterPersistenceWindow) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PageStrategyWithT[T any] PageStrategy

func (u *PageStrategyWithT[T]) Accept(ctx context.Context, v PageStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "pageInfo":
		if u.pageInfo == nil {
			return result, fmt.Errorf("field \"pageInfo\" is required")
		}
		return v.VisitPageInfo(ctx, *u.pageInfo)
	}
}

func (u *PageStrategyWithT[T]) AcceptFuncs(pageInfoFunc func(PageInfo) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pageInfo":
		if u.pageInfo == nil {
			return result, fmt.Errorf("field \"pageInfo\" is required")
		}
		return pageInfoFunc(*u.pageInfo)
	}
}

func (u *PageStrategyWithT[T]) PageInfoNoopSuccess(PageInfo) (T, error) {
	var result T
	return result, nil
}

func (u *PageStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PageStrategyVisitorWithT[T any] interface {
	VisitPageInfo(ctx context.Context, v PageInfo) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PageTokenWithT[T any] PageToken

func (u *PageTokenWithT[T]) Accept(ctx context.Context, v PageTokenVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "timestampAndId":
		if u.timestampAndId == nil {
			return result, fmt.Errorf("field \"timestampAndId\" is required")
		}
		return v.VisitTimestampAndId(ctx, *u.timestampAndId)
	}
}

func (u *PageTokenWithT[T]) AcceptFuncs(timestampAndIdFunc func(TimestampAndId) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timestampAndId":
		if u.timestampAndId == nil {
			return result, fmt.Errorf("field \"timestampAndId\" is required")
		}
		return timestampAndIdFunc(*u.timestampAndId)
	}
}

func (u *PageTokenWithT[T]) TimestampAndIdNoopSuccess(TimestampAndId) (T, error) {
	var result T
	return result, nil
}

func (u *PageTokenWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PageTokenVisitorWithT[T any] interface {
	VisitTimestampAndId(ctx context.Context, v TimestampAndId) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type RangeAggregationOperationWithT[T any] RangeAggregationOperation

func (u *RangeAggregationOperationWithT[T]) Accept(ctx context.Context, v RangeAggregationOperationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "sum":
		if u.sum == nil {
			return result, fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSum(ctx, *u.sum)
	case "rootMeanSquare":
		if u.rootMeanSquare == nil {
			return result, fmt.Errorf("field \"rootMeanSquare\" is required")
		}
		return v.VisitRootMeanSquare(ctx, *u.rootMeanSquare)
	case "average":
		if u.average == nil {
			return result, fmt.Errorf("field \"average\" is required")
		}
		return v.VisitAverage(ctx, *u.average)
	case "min":
		if u.min == nil {
			return result, fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(ctx, *u.min)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(ctx, *u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return result, fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviation(ctx, *u.standardDeviation)
	case "count":
		if u.count == nil {
			return result, fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCount(ctx, *u.count)
	case "all":
		if u.all == nil {
			return result, fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAll(ctx, *u.all)
	}
}

func (u *RangeAggregationOperationWithT[T]) AcceptFuncs(sumFunc func(Summation) (T, error), rootMeanSquareFunc func(RootMeanSquare) (T, error), averageFunc func(Average) (T, error), minFunc func(Minimum) (T, error), maxFunc func(Maximum) (T, error), standardDeviationFunc func(StandardDeviation) (T, error), countFunc func(Count) (T, error), allFunc func(api.Empty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "sum":
		if u.sum == nil {
			return result, fmt.Errorf("field \"sum\" is required")
		}
		return sumFunc(*u.sum)
	case "rootMeanSquare":
		if u.rootMeanSquare == nil {
			return result, fmt.Errorf("field \"rootMeanSquare\" is required")
		}
		return rootMeanSquareFunc(*u.rootMeanSquare)
	case "average":
		if u.average == nil {
			return result, fmt.Errorf("field \"average\" is required")
		}
		return averageFunc(*u.average)
	case "min":
		if u.min == nil {
			return result, fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return result, fmt.Errorf("field \"standardDeviation\" is required")
		}
		return standardDeviationFunc(*u.standardDeviation)
	case "count":
		if u.count == nil {
			return result, fmt.Errorf("field \"count\" is required")
		}
		return countFunc(*u.count)
	case "all":
		if u.all == nil {
			return result, fmt.Errorf("field \"all\" is required")
		}
		return allFunc(*u.all)
	}
}

func (u *RangeAggregationOperationWithT[T]) SumNoopSuccess(Summation) (T, error) {
	var result T
	return result, nil
}

func (u *RangeAggregationOperationWithT[T]) RootMeanSquareNoopSuccess(RootMeanSquare) (T, error) {
	var result T
	return result, nil
}

func (u *RangeAggregationOperationWithT[T]) AverageNoopSuccess(Average) (T, error) {
	var result T
	return result, nil
}

func (u *RangeAggregationOperationWithT[T]) MinNoopSuccess(Minimum) (T, error) {
	var result T
	return result, nil
}

func (u *RangeAggregationOperationWithT[T]) MaxNoopSuccess(Maximum) (T, error) {
	var result T
	return result, nil
}

func (u *RangeAggregationOperationWithT[T]) StandardDeviationNoopSuccess(StandardDeviation) (T, error) {
	var result T
	return result, nil
}

func (u *RangeAggregationOperationWithT[T]) CountNoopSuccess(Count) (T, error) {
	var result T
	return result, nil
}

func (u *RangeAggregationOperationWithT[T]) AllNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *RangeAggregationOperationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type RangeAggregationOperationVisitorWithT[T any] interface {
	VisitSum(ctx context.Context, v Summation) (T, error)
	VisitRootMeanSquare(ctx context.Context, v RootMeanSquare) (T, error)
	VisitAverage(ctx context.Context, v Average) (T, error)
	VisitMin(ctx context.Context, v Minimum) (T, error)
	VisitMax(ctx context.Context, v Maximum) (T, error)
	VisitStandardDeviation(ctx context.Context, v StandardDeviation) (T, error)
	VisitCount(ctx context.Context, v Count) (T, error)
	VisitAll(ctx context.Context, v api.Empty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type RangeValueWithT[T any] RangeValue

func (u *RangeValueWithT[T]) Accept(ctx context.Context, v RangeValueVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "double":
		if u.double == nil {
			return result, fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(ctx, *u.double)
	case "aggregation":
		if u.aggregation == nil {
			return result, fmt.Errorf("field \"aggregation\" is required")
		}
		return v.VisitAggregation(ctx, *u.aggregation)
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return result, fmt.Errorf("field \"noPointsInRange\" is required")
		}
		return v.VisitNoPointsInRange(ctx, *u.noPointsInRange)
	}
}

func (u *RangeValueWithT[T]) AcceptFuncs(doubleFunc func(float64) (T, error), aggregationFunc func(RangeAggregation) (T, error), noPointsInRangeFunc func(api.Empty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "double":
		if u.double == nil {
			return result, fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "aggregation":
		if u.aggregation == nil {
			return result, fmt.Errorf("field \"aggregation\" is required")
		}
		return aggregationFunc(*u.aggregation)
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return result, fmt.Errorf("field \"noPointsInRange\" is required")
		}
		return noPointsInRangeFunc(*u.noPointsInRange)
	}
}

func (u *RangeValueWithT[T]) DoubleNoopSuccess(float64) (T, error) {
	var result T
	return result, nil
}

func (u *RangeValueWithT[T]) AggregationNoopSuccess(RangeAggregation) (T, error) {
	var result T
	return result, nil
}

func (u *RangeValueWithT[T]) NoPointsInRangeNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *RangeValueWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type RangeValueVisitorWithT[T any] interface {
	VisitDouble(ctx context.Context, v float64) (T, error)
	VisitAggregation(ctx context.Context, v RangeAggregation) (T, error)
	VisitNoPointsInRange(ctx context.Context, v api.Empty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type RollingOperatorWithT[T any] RollingOperator

func (u *RollingOperatorWithT[T]) Accept(ctx context.Context, v RollingOperatorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "average":
		if u.average == nil {
			return result, fmt.Errorf("field \"average\" is required")
		}
		return v.VisitAverage(ctx, *u.average)
	case "count":
		if u.count == nil {
			return result, fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCount(ctx, *u.count)
	case "min":
		if u.min == nil {
			return result, fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(ctx, *u.min)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(ctx, *u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return result, fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviation(ctx, *u.standardDeviation)
	case "sum":
		if u.sum == nil {
			return result, fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSum(ctx, *u.sum)
	}
}

func (u *RollingOperatorWithT[T]) AcceptFuncs(averageFunc func(Average) (T, error), countFunc func(Count) (T, error), minFunc func(Minimum) (T, error), maxFunc func(Maximum) (T, error), standardDeviationFunc func(StandardDeviation) (T, error), sumFunc func(Sum) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "average":
		if u.average == nil {
			return result, fmt.Errorf("field \"average\" is required")
		}
		return averageFunc(*u.average)
	case "count":
		if u.count == nil {
			return result, fmt.Errorf("field \"count\" is required")
		}
		return countFunc(*u.count)
	case "min":
		if u.min == nil {
			return result, fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return result, fmt.Errorf("field \"standardDeviation\" is required")
		}
		return standardDeviationFunc(*u.standardDeviation)
	case "sum":
		if u.sum == nil {
			return result, fmt.Errorf("field \"sum\" is required")
		}
		return sumFunc(*u.sum)
	}
}

func (u *RollingOperatorWithT[T]) AverageNoopSuccess(Average) (T, error) {
	var result T
	return result, nil
}

func (u *RollingOperatorWithT[T]) CountNoopSuccess(Count) (T, error) {
	var result T
	return result, nil
}

func (u *RollingOperatorWithT[T]) MinNoopSuccess(Minimum) (T, error) {
	var result T
	return result, nil
}

func (u *RollingOperatorWithT[T]) MaxNoopSuccess(Maximum) (T, error) {
	var result T
	return result, nil
}

func (u *RollingOperatorWithT[T]) StandardDeviationNoopSuccess(StandardDeviation) (T, error) {
	var result T
	return result, nil
}

func (u *RollingOperatorWithT[T]) SumNoopSuccess(Sum) (T, error) {
	var result T
	return result, nil
}

func (u *RollingOperatorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type RollingOperatorVisitorWithT[T any] interface {
	VisitAverage(ctx context.Context, v Average) (T, error)
	VisitCount(ctx context.Context, v Count) (T, error)
	VisitMin(ctx context.Context, v Minimum) (T, error)
	VisitMax(ctx context.Context, v Maximum) (T, error)
	VisitStandardDeviation(ctx context.Context, v StandardDeviation) (T, error)
	VisitSum(ctx context.Context, v Sum) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ScatterSummarizationStrategyWithT[T any] ScatterSummarizationStrategy

func (u *ScatterSummarizationStrategyWithT[T]) Accept(ctx context.Context, v ScatterSummarizationStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "spatial":
		if u.spatial == nil {
			return result, fmt.Errorf("field \"spatial\" is required")
		}
		return v.VisitSpatial(ctx, *u.spatial)
	case "temporal":
		if u.temporal == nil {
			return result, fmt.Errorf("field \"temporal\" is required")
		}
		return v.VisitTemporal(ctx, *u.temporal)
	}
}

func (u *ScatterSummarizationStrategyWithT[T]) AcceptFuncs(spatialFunc func(SpatialDecimateStrategy) (T, error), temporalFunc func(TemporalDecimateStrategy) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "spatial":
		if u.spatial == nil {
			return result, fmt.Errorf("field \"spatial\" is required")
		}
		return spatialFunc(*u.spatial)
	case "temporal":
		if u.temporal == nil {
			return result, fmt.Errorf("field \"temporal\" is required")
		}
		return temporalFunc(*u.temporal)
	}
}

func (u *ScatterSummarizationStrategyWithT[T]) SpatialNoopSuccess(SpatialDecimateStrategy) (T, error) {
	var result T
	return result, nil
}

func (u *ScatterSummarizationStrategyWithT[T]) TemporalNoopSuccess(TemporalDecimateStrategy) (T, error) {
	var result T
	return result, nil
}

func (u *ScatterSummarizationStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ScatterSummarizationStrategyVisitorWithT[T any] interface {
	VisitSpatial(ctx context.Context, v SpatialDecimateStrategy) (T, error)
	VisitTemporal(ctx context.Context, v TemporalDecimateStrategy) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SignalFilterConfigurationWithT[T any] SignalFilterConfiguration

func (u *SignalFilterConfigurationWithT[T]) Accept(ctx context.Context, v SignalFilterConfigurationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return result, fmt.Errorf("field \"lowPass\" is required")
		}
		return v.VisitLowPass(ctx, *u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return result, fmt.Errorf("field \"highPass\" is required")
		}
		return v.VisitHighPass(ctx, *u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return result, fmt.Errorf("field \"bandPass\" is required")
		}
		return v.VisitBandPass(ctx, *u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return result, fmt.Errorf("field \"bandStop\" is required")
		}
		return v.VisitBandStop(ctx, *u.bandStop)
	}
}

func (u *SignalFilterConfigurationWithT[T]) AcceptFuncs(lowPassFunc func(LowPassConfiguration) (T, error), highPassFunc func(HighPassConfiguration) (T, error), bandPassFunc func(BandPassConfiguration) (T, error), bandStopFunc func(BandStopConfiguration) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return result, fmt.Errorf("field \"lowPass\" is required")
		}
		return lowPassFunc(*u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return result, fmt.Errorf("field \"highPass\" is required")
		}
		return highPassFunc(*u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return result, fmt.Errorf("field \"bandPass\" is required")
		}
		return bandPassFunc(*u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return result, fmt.Errorf("field \"bandStop\" is required")
		}
		return bandStopFunc(*u.bandStop)
	}
}

func (u *SignalFilterConfigurationWithT[T]) LowPassNoopSuccess(LowPassConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *SignalFilterConfigurationWithT[T]) HighPassNoopSuccess(HighPassConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *SignalFilterConfigurationWithT[T]) BandPassNoopSuccess(BandPassConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *SignalFilterConfigurationWithT[T]) BandStopNoopSuccess(BandStopConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *SignalFilterConfigurationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SignalFilterConfigurationVisitorWithT[T any] interface {
	VisitLowPass(ctx context.Context, v LowPassConfiguration) (T, error)
	VisitHighPass(ctx context.Context, v HighPassConfiguration) (T, error)
	VisitBandPass(ctx context.Context, v BandPassConfiguration) (T, error)
	VisitBandStop(ctx context.Context, v BandStopConfiguration) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type StringConstantWithT[T any] StringConstant

func (u *StringConstantWithT[T]) Accept(ctx context.Context, v StringConstantVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(ctx, *u.variable)
	}
}

func (u *StringConstantWithT[T]) AcceptFuncs(literalFunc func(string) (T, error), variableFunc func(VariableName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *StringConstantWithT[T]) LiteralNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *StringConstantWithT[T]) VariableNoopSuccess(VariableName) (T, error) {
	var result T
	return result, nil
}

func (u *StringConstantWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type StringConstantVisitorWithT[T any] interface {
	VisitLiteral(ctx context.Context, v string) (T, error)
	VisitVariable(ctx context.Context, v VariableName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type StringSetConstantWithT[T any] StringSetConstant

func (u *StringSetConstantWithT[T]) Accept(ctx context.Context, v StringSetConstantVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(ctx, *u.variable)
	}
}

func (u *StringSetConstantWithT[T]) AcceptFuncs(literalFunc func([]string) (T, error), variableFunc func(VariableName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *StringSetConstantWithT[T]) LiteralNoopSuccess([]string) (T, error) {
	var result T
	return result, nil
}

func (u *StringSetConstantWithT[T]) VariableNoopSuccess(VariableName) (T, error) {
	var result T
	return result, nil
}

func (u *StringSetConstantWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type StringSetConstantVisitorWithT[T any] interface {
	VisitLiteral(ctx context.Context, v []string) (T, error)
	VisitVariable(ctx context.Context, v VariableName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SummarizationStrategyWithT[T any] SummarizationStrategy

func (u *SummarizationStrategyWithT[T]) Accept(ctx context.Context, v SummarizationStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "decimate":
		if u.decimate == nil {
			return result, fmt.Errorf("field \"decimate\" is required")
		}
		return v.VisitDecimate(ctx, *u.decimate)
	case "page":
		if u.page == nil {
			return result, fmt.Errorf("field \"page\" is required")
		}
		return v.VisitPage(ctx, *u.page)
	case "truncate":
		if u.truncate == nil {
			return result, fmt.Errorf("field \"truncate\" is required")
		}
		return v.VisitTruncate(ctx, *u.truncate)
	}
}

func (u *SummarizationStrategyWithT[T]) AcceptFuncs(decimateFunc func(DecimateStrategy) (T, error), pageFunc func(PageStrategy) (T, error), truncateFunc func(TruncateStrategy) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "decimate":
		if u.decimate == nil {
			return result, fmt.Errorf("field \"decimate\" is required")
		}
		return decimateFunc(*u.decimate)
	case "page":
		if u.page == nil {
			return result, fmt.Errorf("field \"page\" is required")
		}
		return pageFunc(*u.page)
	case "truncate":
		if u.truncate == nil {
			return result, fmt.Errorf("field \"truncate\" is required")
		}
		return truncateFunc(*u.truncate)
	}
}

func (u *SummarizationStrategyWithT[T]) DecimateNoopSuccess(DecimateStrategy) (T, error) {
	var result T
	return result, nil
}

func (u *SummarizationStrategyWithT[T]) PageNoopSuccess(PageStrategy) (T, error) {
	var result T
	return result, nil
}

func (u *SummarizationStrategyWithT[T]) TruncateNoopSuccess(TruncateStrategy) (T, error) {
	var result T
	return result, nil
}

func (u *SummarizationStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SummarizationStrategyVisitorWithT[T any] interface {
	VisitDecimate(ctx context.Context, v DecimateStrategy) (T, error)
	VisitPage(ctx context.Context, v PageStrategy) (T, error)
	VisitTruncate(ctx context.Context, v TruncateStrategy) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TagFiltersWithT[T any] TagFilters

func (u *TagFiltersWithT[T]) Accept(ctx context.Context, v TagFiltersVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(ctx, *u.single)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	}
}

func (u *TagFiltersWithT[T]) AcceptFuncs(singleFunc func(TagFilter) (T, error), andFunc func([]TagFilters) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	}
}

func (u *TagFiltersWithT[T]) SingleNoopSuccess(TagFilter) (T, error) {
	var result T
	return result, nil
}

func (u *TagFiltersWithT[T]) AndNoopSuccess([]TagFilters) (T, error) {
	var result T
	return result, nil
}

func (u *TagFiltersWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TagFiltersVisitorWithT[T any] interface {
	VisitSingle(ctx context.Context, v TagFilter) (T, error)
	VisitAnd(ctx context.Context, v []TagFilters) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ThresholdWithT[T any] Threshold

func (u *ThresholdWithT[T]) Accept(ctx context.Context, v ThresholdVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "absolute":
		if u.absolute == nil {
			return result, fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsolute(ctx, *u.absolute)
	case "percentage":
		if u.percentage == nil {
			return result, fmt.Errorf("field \"percentage\" is required")
		}
		return v.VisitPercentage(ctx, *u.percentage)
	}
}

func (u *ThresholdWithT[T]) AcceptFuncs(absoluteFunc func(AbsoluteThreshold) (T, error), percentageFunc func(PercentageThreshold) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "absolute":
		if u.absolute == nil {
			return result, fmt.Errorf("field \"absolute\" is required")
		}
		return absoluteFunc(*u.absolute)
	case "percentage":
		if u.percentage == nil {
			return result, fmt.Errorf("field \"percentage\" is required")
		}
		return percentageFunc(*u.percentage)
	}
}

func (u *ThresholdWithT[T]) AbsoluteNoopSuccess(AbsoluteThreshold) (T, error) {
	var result T
	return result, nil
}

func (u *ThresholdWithT[T]) PercentageNoopSuccess(PercentageThreshold) (T, error) {
	var result T
	return result, nil
}

func (u *ThresholdWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ThresholdVisitorWithT[T any] interface {
	VisitAbsolute(ctx context.Context, v AbsoluteThreshold) (T, error)
	VisitPercentage(ctx context.Context, v PercentageThreshold) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimestampConstantWithT[T any] TimestampConstant

func (u *TimestampConstantWithT[T]) Accept(ctx context.Context, v TimestampConstantVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(ctx, *u.variable)
	}
}

func (u *TimestampConstantWithT[T]) AcceptFuncs(literalFunc func(api.Timestamp) (T, error), variableFunc func(VariableName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *TimestampConstantWithT[T]) LiteralNoopSuccess(api.Timestamp) (T, error) {
	var result T
	return result, nil
}

func (u *TimestampConstantWithT[T]) VariableNoopSuccess(VariableName) (T, error) {
	var result T
	return result, nil
}

func (u *TimestampConstantWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimestampConstantVisitorWithT[T any] interface {
	VisitLiteral(ctx context.Context, v api.Timestamp) (T, error)
	VisitVariable(ctx context.Context, v VariableName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TruncateStrategyWithT[T any] TruncateStrategy

func (u *TruncateStrategyWithT[T]) Accept(ctx context.Context, v TruncateStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "maxPointsToReturn":
		if u.maxPointsToReturn == nil {
			return result, fmt.Errorf("field \"maxPointsToReturn\" is required")
		}
		return v.VisitMaxPointsToReturn(ctx, *u.maxPointsToReturn)
	}
}

func (u *TruncateStrategyWithT[T]) AcceptFuncs(maxPointsToReturnFunc func(int) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "maxPointsToReturn":
		if u.maxPointsToReturn == nil {
			return result, fmt.Errorf("field \"maxPointsToReturn\" is required")
		}
		return maxPointsToReturnFunc(*u.maxPointsToReturn)
	}
}

func (u *TruncateStrategyWithT[T]) MaxPointsToReturnNoopSuccess(int) (T, error) {
	var result T
	return result, nil
}

func (u *TruncateStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TruncateStrategyVisitorWithT[T any] interface {
	VisitMaxPointsToReturn(ctx context.Context, v int) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UnitComputationErrorWithT[T any] UnitComputationError

func (u *UnitComputationErrorWithT[T]) Accept(ctx context.Context, v UnitComputationErrorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return result, fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
		return v.VisitIncompatibleUnitsOperation(ctx, *u.incompatibleUnitsOperation)
	case "unitsMissing":
		if u.unitsMissing == nil {
			return result, fmt.Errorf("field \"unitsMissing\" is required")
		}
		return v.VisitUnitsMissing(ctx, *u.unitsMissing)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(ctx, *u.error)
	}
}

func (u *UnitComputationErrorWithT[T]) AcceptFuncs(incompatibleUnitsOperationFunc func(IncompatibleUnitOperation) (T, error), unitsMissingFunc func(UnitsMissing) (T, error), errorFunc func(api.SerializableError) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return result, fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
		return incompatibleUnitsOperationFunc(*u.incompatibleUnitsOperation)
	case "unitsMissing":
		if u.unitsMissing == nil {
			return result, fmt.Errorf("field \"unitsMissing\" is required")
		}
		return unitsMissingFunc(*u.unitsMissing)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *UnitComputationErrorWithT[T]) IncompatibleUnitsOperationNoopSuccess(IncompatibleUnitOperation) (T, error) {
	var result T
	return result, nil
}

func (u *UnitComputationErrorWithT[T]) UnitsMissingNoopSuccess(UnitsMissing) (T, error) {
	var result T
	return result, nil
}

func (u *UnitComputationErrorWithT[T]) ErrorNoopSuccess(api.SerializableError) (T, error) {
	var result T
	return result, nil
}

func (u *UnitComputationErrorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UnitComputationErrorVisitorWithT[T any] interface {
	VisitIncompatibleUnitsOperation(ctx context.Context, v IncompatibleUnitOperation) (T, error)
	VisitUnitsMissing(ctx context.Context, v UnitsMissing) (T, error)
	VisitError(ctx context.Context, v api.SerializableError) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UnitResultWithT[T any] UnitResult

func (u *UnitResultWithT[T]) Accept(ctx context.Context, v UnitResultVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(ctx, *u.success)
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return result, fmt.Errorf("field \"noUnitAvailable\" is required")
		}
		return v.VisitNoUnitAvailable(ctx, *u.noUnitAvailable)
	}
}

func (u *UnitResultWithT[T]) AcceptFuncs(successFunc func(api1.UnitSymbol) (T, error), noUnitAvailableFunc func([]UnitComputationError) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return result, fmt.Errorf("field \"noUnitAvailable\" is required")
		}
		return noUnitAvailableFunc(*u.noUnitAvailable)
	}
}

func (u *UnitResultWithT[T]) SuccessNoopSuccess(api1.UnitSymbol) (T, error) {
	var result T
	return result, nil
}

func (u *UnitResultWithT[T]) NoUnitAvailableNoopSuccess([]UnitComputationError) (T, error) {
	var result T
	return result, nil
}

func (u *UnitResultWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UnitResultVisitorWithT[T any] interface {
	VisitSuccess(ctx context.Context, v api1.UnitSymbol) (T, error)
	VisitNoUnitAvailable(ctx context.Context, v []UnitComputationError) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ValueWithT[T any] Value

func (u *ValueWithT[T]) Accept(ctx context.Context, v ValueVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "stringValue":
		if u.stringValue == nil {
			return result, fmt.Errorf("field \"stringValue\" is required")
		}
		return v.VisitStringValue(ctx, *u.stringValue)
	case "float64Value":
		if u.float64Value == nil {
			return result, fmt.Errorf("field \"float64Value\" is required")
		}
		return v.VisitFloat64Value(ctx, *u.float64Value)
	case "int64Value":
		if u.int64Value == nil {
			return result, fmt.Errorf("field \"int64Value\" is required")
		}
		return v.VisitInt64Value(ctx, *u.int64Value)
	case "arrayValue":
		if u.arrayValue == nil {
			return result, fmt.Errorf("field \"arrayValue\" is required")
		}
		return v.VisitArrayValue(ctx, *u.arrayValue)
	case "structValue":
		if u.structValue == nil {
			return result, fmt.Errorf("field \"structValue\" is required")
		}
		return v.VisitStructValue(ctx, *u.structValue)
	}
}

func (u *ValueWithT[T]) AcceptFuncs(stringValueFunc func(string) (T, error), float64ValueFunc func(float64) (T, error), int64ValueFunc func(string) (T, error), arrayValueFunc func([]*Value) (T, error), structValueFunc func(interface{}) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "stringValue":
		if u.stringValue == nil {
			return result, fmt.Errorf("field \"stringValue\" is required")
		}
		return stringValueFunc(*u.stringValue)
	case "float64Value":
		if u.float64Value == nil {
			return result, fmt.Errorf("field \"float64Value\" is required")
		}
		return float64ValueFunc(*u.float64Value)
	case "int64Value":
		if u.int64Value == nil {
			return result, fmt.Errorf("field \"int64Value\" is required")
		}
		return int64ValueFunc(*u.int64Value)
	case "arrayValue":
		if u.arrayValue == nil {
			return result, fmt.Errorf("field \"arrayValue\" is required")
		}
		return arrayValueFunc(*u.arrayValue)
	case "structValue":
		if u.structValue == nil {
			return result, fmt.Errorf("field \"structValue\" is required")
		}
		return structValueFunc(*u.structValue)
	}
}

func (u *ValueWithT[T]) StringValueNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *ValueWithT[T]) Float64ValueNoopSuccess(float64) (T, error) {
	var result T
	return result, nil
}

func (u *ValueWithT[T]) Int64ValueNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *ValueWithT[T]) ArrayValueNoopSuccess([]*Value) (T, error) {
	var result T
	return result, nil
}

func (u *ValueWithT[T]) StructValueNoopSuccess(interface{}) (T, error) {
	var result T
	return result, nil
}

func (u *ValueWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ValueVisitorWithT[T any] interface {
	VisitStringValue(ctx context.Context, v string) (T, error)
	VisitFloat64Value(ctx context.Context, v float64) (T, error)
	VisitInt64Value(ctx context.Context, v string) (T, error)
	VisitArrayValue(ctx context.Context, v []*Value) (T, error)
	VisitStructValue(ctx context.Context, v interface{}) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
