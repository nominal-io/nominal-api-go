// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	werror "github.com/palantir/witchcraft-go-error"
)

// The Compute Service provides the ability to compute the output of compute graphs.
type ComputeServiceClient interface {
	// Computes the output of the compute graph specified by a ComputeNodeRequest.
	Compute(ctx context.Context, authHeader bearertoken.Token, requestArg ComputeNodeRequest) (ComputeNodeResponse, error)
	/*
	   Computes the output of the compute graph specified by a ParameterizedComputeNodeRequest. A parameterized
	   compute request supports multiple values for a single variable, supplied by the ParameterizedContext.
	   Results are returned in the same order of the request.
	*/
	ParameterizedCompute(ctx context.Context, authHeader bearertoken.Token, requestArg ParameterizedComputeNodeRequest) (ParameterizedComputeNodeResponse, error)
	/*
	   Returns the resulting unit for the output of a compute graph. If the resulting unit is equivalent to exactly
	   one existing unit in the system, it will be returned (for example, a series in Coulombs divided by a series
	   in Volts will return an output of Farads). If the output does not have units (for example, a range output,)
	   the unit result will return noUnitAvailable, and if the computation was not successful, corresponding errors
	   are returned.
	*/
	ComputeUnits(ctx context.Context, authHeader bearertoken.Token, requestArg ComputeUnitsRequest) (ComputeUnitResult, error)
	/*
	   Computes the output of compute graphs specified by BatchComputeNodeRequest. Results are returned in the same
	   order as the request.
	*/
	BatchComputeWithUnits(ctx context.Context, authHeader bearertoken.Token, requestArg BatchComputeWithUnitsRequest) (BatchComputeWithUnitsResponse, error)
	/*
	   Same as computeUnits, however this endpoint functions on a batch of requests for wire efficiency purposes. An
	   extra note is that this method will serialize underlying conjure errors into the BatchComputeUnitResult type,
	   meaning callers are required to check for errors explicitly (rather than relying on exceptions being thrown).
	*/
	BatchComputeUnits(ctx context.Context, authHeader bearertoken.Token, requestArg BatchComputeUnitsRequest) (BatchComputeUnitResult, error)
	/*
	   Computes the output of the compute graph specified by a ComputeNodeRequest, as well as providing the resulting
	   unit for the output of a compute graph. If the resulting unit is equivalent to exactly one existing unit in the
	   system, it will be returned (for example, a series in Coulombs divided by a series in Volts will return an
	   output of Farads). If the output does not have units (for example, a range output,) the unit result will return
	   noUnitAvailable, and if the computation was not successful, corresponding errors are returned.
	*/
	ComputeWithUnits(ctx context.Context, authHeader bearertoken.Token, requestArg ComputeWithUnitsRequest) (ComputeWithUnitsResponse, error)
}

type computeServiceClient struct {
	client httpclient.Client
}

func NewComputeServiceClient(client httpclient.Client) ComputeServiceClient {
	return &computeServiceClient{client: client}
}

func (c *computeServiceClient) Compute(ctx context.Context, authHeader bearertoken.Token, requestArg ComputeNodeRequest) (ComputeNodeResponse, error) {
	var defaultReturnVal ComputeNodeResponse
	var returnVal *ComputeNodeResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Compute"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/compute/v2/compute"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "compute failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "compute response cannot be nil")
	}
	return *returnVal, nil
}

func (c *computeServiceClient) ParameterizedCompute(ctx context.Context, authHeader bearertoken.Token, requestArg ParameterizedComputeNodeRequest) (ParameterizedComputeNodeResponse, error) {
	var defaultReturnVal ParameterizedComputeNodeResponse
	var returnVal *ParameterizedComputeNodeResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ParameterizedCompute"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/compute/v2/compute/parameterized"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "parameterizedCompute failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "parameterizedCompute response cannot be nil")
	}
	return *returnVal, nil
}

func (c *computeServiceClient) ComputeUnits(ctx context.Context, authHeader bearertoken.Token, requestArg ComputeUnitsRequest) (ComputeUnitResult, error) {
	var defaultReturnVal ComputeUnitResult
	var returnVal *ComputeUnitResult
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ComputeUnits"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/compute/v2/compute/units"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "computeUnits failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "computeUnits response cannot be nil")
	}
	return *returnVal, nil
}

func (c *computeServiceClient) BatchComputeWithUnits(ctx context.Context, authHeader bearertoken.Token, requestArg BatchComputeWithUnitsRequest) (BatchComputeWithUnitsResponse, error) {
	var defaultReturnVal BatchComputeWithUnitsResponse
	var returnVal *BatchComputeWithUnitsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchComputeWithUnits"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/compute/v2/compute/batch"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "batchComputeWithUnits failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "batchComputeWithUnits response cannot be nil")
	}
	return *returnVal, nil
}

func (c *computeServiceClient) BatchComputeUnits(ctx context.Context, authHeader bearertoken.Token, requestArg BatchComputeUnitsRequest) (BatchComputeUnitResult, error) {
	var defaultReturnVal BatchComputeUnitResult
	var returnVal *BatchComputeUnitResult
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchComputeUnits"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/compute/v2/compute/batch-units"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "batchComputeUnits failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "batchComputeUnits response cannot be nil")
	}
	return *returnVal, nil
}

func (c *computeServiceClient) ComputeWithUnits(ctx context.Context, authHeader bearertoken.Token, requestArg ComputeWithUnitsRequest) (ComputeWithUnitsResponse, error) {
	var defaultReturnVal ComputeWithUnitsResponse
	var returnVal *ComputeWithUnitsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ComputeWithUnits"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/compute/v2/computeWithUnits"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "computeWithUnits failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "computeWithUnits response cannot be nil")
	}
	return *returnVal, nil
}

// The Compute Service provides the ability to compute the output of compute graphs.
type ComputeServiceClientWithAuth interface {
	// Computes the output of the compute graph specified by a ComputeNodeRequest.
	Compute(ctx context.Context, requestArg ComputeNodeRequest) (ComputeNodeResponse, error)
	/*
	   Computes the output of the compute graph specified by a ParameterizedComputeNodeRequest. A parameterized
	   compute request supports multiple values for a single variable, supplied by the ParameterizedContext.
	   Results are returned in the same order of the request.
	*/
	ParameterizedCompute(ctx context.Context, requestArg ParameterizedComputeNodeRequest) (ParameterizedComputeNodeResponse, error)
	/*
	   Returns the resulting unit for the output of a compute graph. If the resulting unit is equivalent to exactly
	   one existing unit in the system, it will be returned (for example, a series in Coulombs divided by a series
	   in Volts will return an output of Farads). If the output does not have units (for example, a range output,)
	   the unit result will return noUnitAvailable, and if the computation was not successful, corresponding errors
	   are returned.
	*/
	ComputeUnits(ctx context.Context, requestArg ComputeUnitsRequest) (ComputeUnitResult, error)
	/*
	   Computes the output of compute graphs specified by BatchComputeNodeRequest. Results are returned in the same
	   order as the request.
	*/
	BatchComputeWithUnits(ctx context.Context, requestArg BatchComputeWithUnitsRequest) (BatchComputeWithUnitsResponse, error)
	/*
	   Same as computeUnits, however this endpoint functions on a batch of requests for wire efficiency purposes. An
	   extra note is that this method will serialize underlying conjure errors into the BatchComputeUnitResult type,
	   meaning callers are required to check for errors explicitly (rather than relying on exceptions being thrown).
	*/
	BatchComputeUnits(ctx context.Context, requestArg BatchComputeUnitsRequest) (BatchComputeUnitResult, error)
	/*
	   Computes the output of the compute graph specified by a ComputeNodeRequest, as well as providing the resulting
	   unit for the output of a compute graph. If the resulting unit is equivalent to exactly one existing unit in the
	   system, it will be returned (for example, a series in Coulombs divided by a series in Volts will return an
	   output of Farads). If the output does not have units (for example, a range output,) the unit result will return
	   noUnitAvailable, and if the computation was not successful, corresponding errors are returned.
	*/
	ComputeWithUnits(ctx context.Context, requestArg ComputeWithUnitsRequest) (ComputeWithUnitsResponse, error)
}

func NewComputeServiceClientWithAuth(client ComputeServiceClient, authHeader bearertoken.Token) ComputeServiceClientWithAuth {
	return &computeServiceClientWithAuth{client: client, authHeader: authHeader}
}

type computeServiceClientWithAuth struct {
	client     ComputeServiceClient
	authHeader bearertoken.Token
}

func (c *computeServiceClientWithAuth) Compute(ctx context.Context, requestArg ComputeNodeRequest) (ComputeNodeResponse, error) {
	return c.client.Compute(ctx, c.authHeader, requestArg)
}

func (c *computeServiceClientWithAuth) ParameterizedCompute(ctx context.Context, requestArg ParameterizedComputeNodeRequest) (ParameterizedComputeNodeResponse, error) {
	return c.client.ParameterizedCompute(ctx, c.authHeader, requestArg)
}

func (c *computeServiceClientWithAuth) ComputeUnits(ctx context.Context, requestArg ComputeUnitsRequest) (ComputeUnitResult, error) {
	return c.client.ComputeUnits(ctx, c.authHeader, requestArg)
}

func (c *computeServiceClientWithAuth) BatchComputeWithUnits(ctx context.Context, requestArg BatchComputeWithUnitsRequest) (BatchComputeWithUnitsResponse, error) {
	return c.client.BatchComputeWithUnits(ctx, c.authHeader, requestArg)
}

func (c *computeServiceClientWithAuth) BatchComputeUnits(ctx context.Context, requestArg BatchComputeUnitsRequest) (BatchComputeUnitResult, error) {
	return c.client.BatchComputeUnits(ctx, c.authHeader, requestArg)
}

func (c *computeServiceClientWithAuth) ComputeWithUnits(ctx context.Context, requestArg ComputeWithUnitsRequest) (ComputeWithUnitsResponse, error) {
	return c.client.ComputeWithUnits(ctx, c.authHeader, requestArg)
}

func NewComputeServiceClientWithTokenProvider(client ComputeServiceClient, tokenProvider httpclient.TokenProvider) ComputeServiceClientWithAuth {
	return &computeServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type computeServiceClientWithTokenProvider struct {
	client        ComputeServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *computeServiceClientWithTokenProvider) Compute(ctx context.Context, requestArg ComputeNodeRequest) (ComputeNodeResponse, error) {
	var defaultReturnVal ComputeNodeResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Compute(ctx, bearertoken.Token(token), requestArg)
}

func (c *computeServiceClientWithTokenProvider) ParameterizedCompute(ctx context.Context, requestArg ParameterizedComputeNodeRequest) (ParameterizedComputeNodeResponse, error) {
	var defaultReturnVal ParameterizedComputeNodeResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ParameterizedCompute(ctx, bearertoken.Token(token), requestArg)
}

func (c *computeServiceClientWithTokenProvider) ComputeUnits(ctx context.Context, requestArg ComputeUnitsRequest) (ComputeUnitResult, error) {
	var defaultReturnVal ComputeUnitResult
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ComputeUnits(ctx, bearertoken.Token(token), requestArg)
}

func (c *computeServiceClientWithTokenProvider) BatchComputeWithUnits(ctx context.Context, requestArg BatchComputeWithUnitsRequest) (BatchComputeWithUnitsResponse, error) {
	var defaultReturnVal BatchComputeWithUnitsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchComputeWithUnits(ctx, bearertoken.Token(token), requestArg)
}

func (c *computeServiceClientWithTokenProvider) BatchComputeUnits(ctx context.Context, requestArg BatchComputeUnitsRequest) (BatchComputeUnitResult, error) {
	var defaultReturnVal BatchComputeUnitResult
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchComputeUnits(ctx, bearertoken.Token(token), requestArg)
}

func (c *computeServiceClientWithTokenProvider) ComputeWithUnits(ctx context.Context, requestArg ComputeWithUnitsRequest) (ComputeWithUnitsResponse, error) {
	var defaultReturnVal ComputeWithUnitsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ComputeWithUnits(ctx, bearertoken.Token(token), requestArg)
}
