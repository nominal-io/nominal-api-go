// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/units/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type ArrowArrayPlot struct {
	typ             string
	bucketedNumeric *BucketedNumericArrayPlot
	bucketedEnum    *BucketedEnumArrayPlot
}

type arrowArrayPlotDeserializer struct {
	Type            string                    `json:"type"`
	BucketedNumeric *BucketedNumericArrayPlot `json:"bucketedNumeric"`
	BucketedEnum    *BucketedEnumArrayPlot    `json:"bucketedEnum"`
}

func (u *arrowArrayPlotDeserializer) toStruct() ArrowArrayPlot {
	return ArrowArrayPlot{typ: u.Type, bucketedNumeric: u.BucketedNumeric, bucketedEnum: u.BucketedEnum}
}

func (u *ArrowArrayPlot) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return nil, fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return struct {
			Type            string                   `json:"type"`
			BucketedNumeric BucketedNumericArrayPlot `json:"bucketedNumeric"`
		}{Type: "bucketedNumeric", BucketedNumeric: *u.bucketedNumeric}, nil
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return nil, fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return struct {
			Type         string                `json:"type"`
			BucketedEnum BucketedEnumArrayPlot `json:"bucketedEnum"`
		}{Type: "bucketedEnum", BucketedEnum: *u.bucketedEnum}, nil
	}
}

func (u ArrowArrayPlot) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ArrowArrayPlot) UnmarshalJSON(data []byte) error {
	var deser arrowArrayPlotDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
	}
	return nil
}

func (u ArrowArrayPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ArrowArrayPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ArrowArrayPlot) AcceptFuncs(bucketedNumericFunc func(BucketedNumericArrayPlot) error, bucketedEnumFunc func(BucketedEnumArrayPlot) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return bucketedNumericFunc(*u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return bucketedEnumFunc(*u.bucketedEnum)
	}
}

func (u *ArrowArrayPlot) BucketedNumericNoopSuccess(BucketedNumericArrayPlot) error {
	return nil
}

func (u *ArrowArrayPlot) BucketedEnumNoopSuccess(BucketedEnumArrayPlot) error {
	return nil
}

func (u *ArrowArrayPlot) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ArrowArrayPlot) Accept(v ArrowArrayPlotVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumeric(*u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnum(*u.bucketedEnum)
	}
}

type ArrowArrayPlotVisitor interface {
	VisitBucketedNumeric(v BucketedNumericArrayPlot) error
	VisitBucketedEnum(v BucketedEnumArrayPlot) error
	VisitUnknown(typeName string) error
}

func (u *ArrowArrayPlot) AcceptWithContext(ctx context.Context, v ArrowArrayPlotVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumericWithContext(ctx, *u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnumWithContext(ctx, *u.bucketedEnum)
	}
}

type ArrowArrayPlotVisitorWithContext interface {
	VisitBucketedNumericWithContext(ctx context.Context, v BucketedNumericArrayPlot) error
	VisitBucketedEnumWithContext(ctx context.Context, v BucketedEnumArrayPlot) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewArrowArrayPlotFromBucketedNumeric(v BucketedNumericArrayPlot) ArrowArrayPlot {
	return ArrowArrayPlot{typ: "bucketedNumeric", bucketedNumeric: &v}
}

func NewArrowArrayPlotFromBucketedEnum(v BucketedEnumArrayPlot) ArrowArrayPlot {
	return ArrowArrayPlot{typ: "bucketedEnum", bucketedEnum: &v}
}

type BitOperationFunction struct {
	typ        string
	and        *BitAndFunction
	or         *BitOrFunction
	xor        *BitXorFunction
	shiftRight *BitShiftRightFunction
	shiftLeft  *BitShiftLeftFunction
	bitTest    *BitTestFunction
}

type bitOperationFunctionDeserializer struct {
	Type       string                 `json:"type"`
	And        *BitAndFunction        `json:"and"`
	Or         *BitOrFunction         `json:"or"`
	Xor        *BitXorFunction        `json:"xor"`
	ShiftRight *BitShiftRightFunction `json:"shiftRight"`
	ShiftLeft  *BitShiftLeftFunction  `json:"shiftLeft"`
	BitTest    *BitTestFunction       `json:"bitTest"`
}

func (u *bitOperationFunctionDeserializer) toStruct() BitOperationFunction {
	return BitOperationFunction{typ: u.Type, and: u.And, or: u.Or, xor: u.Xor, shiftRight: u.ShiftRight, shiftLeft: u.ShiftLeft, bitTest: u.BitTest}
}

func (u *BitOperationFunction) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string         `json:"type"`
			And  BitAndFunction `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Or   BitOrFunction `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "xor":
		if u.xor == nil {
			return nil, fmt.Errorf("field \"xor\" is required")
		}
		return struct {
			Type string         `json:"type"`
			Xor  BitXorFunction `json:"xor"`
		}{Type: "xor", Xor: *u.xor}, nil
	case "shiftRight":
		if u.shiftRight == nil {
			return nil, fmt.Errorf("field \"shiftRight\" is required")
		}
		return struct {
			Type       string                `json:"type"`
			ShiftRight BitShiftRightFunction `json:"shiftRight"`
		}{Type: "shiftRight", ShiftRight: *u.shiftRight}, nil
	case "shiftLeft":
		if u.shiftLeft == nil {
			return nil, fmt.Errorf("field \"shiftLeft\" is required")
		}
		return struct {
			Type      string               `json:"type"`
			ShiftLeft BitShiftLeftFunction `json:"shiftLeft"`
		}{Type: "shiftLeft", ShiftLeft: *u.shiftLeft}, nil
	case "bitTest":
		if u.bitTest == nil {
			return nil, fmt.Errorf("field \"bitTest\" is required")
		}
		return struct {
			Type    string          `json:"type"`
			BitTest BitTestFunction `json:"bitTest"`
		}{Type: "bitTest", BitTest: *u.bitTest}, nil
	}
}

func (u BitOperationFunction) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *BitOperationFunction) UnmarshalJSON(data []byte) error {
	var deser bitOperationFunctionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "xor":
		if u.xor == nil {
			return fmt.Errorf("field \"xor\" is required")
		}
	case "shiftRight":
		if u.shiftRight == nil {
			return fmt.Errorf("field \"shiftRight\" is required")
		}
	case "shiftLeft":
		if u.shiftLeft == nil {
			return fmt.Errorf("field \"shiftLeft\" is required")
		}
	case "bitTest":
		if u.bitTest == nil {
			return fmt.Errorf("field \"bitTest\" is required")
		}
	}
	return nil
}

func (u BitOperationFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *BitOperationFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *BitOperationFunction) AcceptFuncs(andFunc func(BitAndFunction) error, orFunc func(BitOrFunction) error, xorFunc func(BitXorFunction) error, shiftRightFunc func(BitShiftRightFunction) error, shiftLeftFunc func(BitShiftLeftFunction) error, bitTestFunc func(BitTestFunction) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "xor":
		if u.xor == nil {
			return fmt.Errorf("field \"xor\" is required")
		}
		return xorFunc(*u.xor)
	case "shiftRight":
		if u.shiftRight == nil {
			return fmt.Errorf("field \"shiftRight\" is required")
		}
		return shiftRightFunc(*u.shiftRight)
	case "shiftLeft":
		if u.shiftLeft == nil {
			return fmt.Errorf("field \"shiftLeft\" is required")
		}
		return shiftLeftFunc(*u.shiftLeft)
	case "bitTest":
		if u.bitTest == nil {
			return fmt.Errorf("field \"bitTest\" is required")
		}
		return bitTestFunc(*u.bitTest)
	}
}

func (u *BitOperationFunction) AndNoopSuccess(BitAndFunction) error {
	return nil
}

func (u *BitOperationFunction) OrNoopSuccess(BitOrFunction) error {
	return nil
}

func (u *BitOperationFunction) XorNoopSuccess(BitXorFunction) error {
	return nil
}

func (u *BitOperationFunction) ShiftRightNoopSuccess(BitShiftRightFunction) error {
	return nil
}

func (u *BitOperationFunction) ShiftLeftNoopSuccess(BitShiftLeftFunction) error {
	return nil
}

func (u *BitOperationFunction) BitTestNoopSuccess(BitTestFunction) error {
	return nil
}

func (u *BitOperationFunction) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *BitOperationFunction) Accept(v BitOperationFunctionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "xor":
		if u.xor == nil {
			return fmt.Errorf("field \"xor\" is required")
		}
		return v.VisitXor(*u.xor)
	case "shiftRight":
		if u.shiftRight == nil {
			return fmt.Errorf("field \"shiftRight\" is required")
		}
		return v.VisitShiftRight(*u.shiftRight)
	case "shiftLeft":
		if u.shiftLeft == nil {
			return fmt.Errorf("field \"shiftLeft\" is required")
		}
		return v.VisitShiftLeft(*u.shiftLeft)
	case "bitTest":
		if u.bitTest == nil {
			return fmt.Errorf("field \"bitTest\" is required")
		}
		return v.VisitBitTest(*u.bitTest)
	}
}

type BitOperationFunctionVisitor interface {
	VisitAnd(v BitAndFunction) error
	VisitOr(v BitOrFunction) error
	VisitXor(v BitXorFunction) error
	VisitShiftRight(v BitShiftRightFunction) error
	VisitShiftLeft(v BitShiftLeftFunction) error
	VisitBitTest(v BitTestFunction) error
	VisitUnknown(typeName string) error
}

func (u *BitOperationFunction) AcceptWithContext(ctx context.Context, v BitOperationFunctionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "xor":
		if u.xor == nil {
			return fmt.Errorf("field \"xor\" is required")
		}
		return v.VisitXorWithContext(ctx, *u.xor)
	case "shiftRight":
		if u.shiftRight == nil {
			return fmt.Errorf("field \"shiftRight\" is required")
		}
		return v.VisitShiftRightWithContext(ctx, *u.shiftRight)
	case "shiftLeft":
		if u.shiftLeft == nil {
			return fmt.Errorf("field \"shiftLeft\" is required")
		}
		return v.VisitShiftLeftWithContext(ctx, *u.shiftLeft)
	case "bitTest":
		if u.bitTest == nil {
			return fmt.Errorf("field \"bitTest\" is required")
		}
		return v.VisitBitTestWithContext(ctx, *u.bitTest)
	}
}

type BitOperationFunctionVisitorWithContext interface {
	VisitAndWithContext(ctx context.Context, v BitAndFunction) error
	VisitOrWithContext(ctx context.Context, v BitOrFunction) error
	VisitXorWithContext(ctx context.Context, v BitXorFunction) error
	VisitShiftRightWithContext(ctx context.Context, v BitShiftRightFunction) error
	VisitShiftLeftWithContext(ctx context.Context, v BitShiftLeftFunction) error
	VisitBitTestWithContext(ctx context.Context, v BitTestFunction) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewBitOperationFunctionFromAnd(v BitAndFunction) BitOperationFunction {
	return BitOperationFunction{typ: "and", and: &v}
}

func NewBitOperationFunctionFromOr(v BitOrFunction) BitOperationFunction {
	return BitOperationFunction{typ: "or", or: &v}
}

func NewBitOperationFunctionFromXor(v BitXorFunction) BitOperationFunction {
	return BitOperationFunction{typ: "xor", xor: &v}
}

func NewBitOperationFunctionFromShiftRight(v BitShiftRightFunction) BitOperationFunction {
	return BitOperationFunction{typ: "shiftRight", shiftRight: &v}
}

func NewBitOperationFunctionFromShiftLeft(v BitShiftLeftFunction) BitOperationFunction {
	return BitOperationFunction{typ: "shiftLeft", shiftLeft: &v}
}

func NewBitOperationFunctionFromBitTest(v BitTestFunction) BitOperationFunction {
	return BitOperationFunction{typ: "bitTest", bitTest: &v}
}

type ChannelSeries struct {
	typ        string
	dataSource *DataSourceChannel
	asset      *AssetChannel
	run        *RunChannel
}

type channelSeriesDeserializer struct {
	Type       string             `json:"type"`
	DataSource *DataSourceChannel `json:"dataSource"`
	Asset      *AssetChannel      `json:"asset"`
	Run        *RunChannel        `json:"run"`
}

func (u *channelSeriesDeserializer) toStruct() ChannelSeries {
	return ChannelSeries{typ: u.Type, dataSource: u.DataSource, asset: u.Asset, run: u.Run}
}

func (u *ChannelSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "dataSource":
		if u.dataSource == nil {
			return nil, fmt.Errorf("field \"dataSource\" is required")
		}
		return struct {
			Type       string            `json:"type"`
			DataSource DataSourceChannel `json:"dataSource"`
		}{Type: "dataSource", DataSource: *u.dataSource}, nil
	case "asset":
		if u.asset == nil {
			return nil, fmt.Errorf("field \"asset\" is required")
		}
		return struct {
			Type  string       `json:"type"`
			Asset AssetChannel `json:"asset"`
		}{Type: "asset", Asset: *u.asset}, nil
	case "run":
		if u.run == nil {
			return nil, fmt.Errorf("field \"run\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Run  RunChannel `json:"run"`
		}{Type: "run", Run: *u.run}, nil
	}
}

func (u ChannelSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ChannelSeries) UnmarshalJSON(data []byte) error {
	var deser channelSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
	}
	return nil
}

func (u ChannelSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ChannelSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ChannelSeries) AcceptFuncs(dataSourceFunc func(DataSourceChannel) error, assetFunc func(AssetChannel) error, runFunc func(RunChannel) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return dataSourceFunc(*u.dataSource)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return assetFunc(*u.asset)
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
		return runFunc(*u.run)
	}
}

func (u *ChannelSeries) DataSourceNoopSuccess(DataSourceChannel) error {
	return nil
}

func (u *ChannelSeries) AssetNoopSuccess(AssetChannel) error {
	return nil
}

func (u *ChannelSeries) RunNoopSuccess(RunChannel) error {
	return nil
}

func (u *ChannelSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ChannelSeries) Accept(v ChannelSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return v.VisitDataSource(*u.dataSource)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAsset(*u.asset)
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
		return v.VisitRun(*u.run)
	}
}

type ChannelSeriesVisitor interface {
	VisitDataSource(v DataSourceChannel) error
	VisitAsset(v AssetChannel) error
	VisitRun(v RunChannel) error
	VisitUnknown(typeName string) error
}

func (u *ChannelSeries) AcceptWithContext(ctx context.Context, v ChannelSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return v.VisitDataSourceWithContext(ctx, *u.dataSource)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAssetWithContext(ctx, *u.asset)
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
		return v.VisitRunWithContext(ctx, *u.run)
	}
}

type ChannelSeriesVisitorWithContext interface {
	VisitDataSourceWithContext(ctx context.Context, v DataSourceChannel) error
	VisitAssetWithContext(ctx context.Context, v AssetChannel) error
	VisitRunWithContext(ctx context.Context, v RunChannel) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewChannelSeriesFromDataSource(v DataSourceChannel) ChannelSeries {
	return ChannelSeries{typ: "dataSource", dataSource: &v}
}

func NewChannelSeriesFromAsset(v AssetChannel) ChannelSeries {
	return ChannelSeries{typ: "asset", asset: &v}
}

func NewChannelSeriesFromRun(v RunChannel) ChannelSeries {
	return ChannelSeries{typ: "run", run: &v}
}

type ComputeNodeResponse struct {
	typ                  string
	range_               *[]Range
	rangesSummary        *RangesSummary
	rangeValue           **Range
	numeric              *NumericPlot
	bucketedNumeric      *BucketedNumericPlot
	numericPoint         **NumericPoint
	singlePoint          **SinglePoint
	arrowNumeric         *ArrowNumericPlot
	arrowBucketedNumeric *ArrowBucketedNumericPlot
	enum                 *EnumPlot
	enumPoint            **EnumPoint
	bucketedEnum         *BucketedEnumPlot
	arrowEnum            *ArrowEnumPlot
	arrowBucketedEnum    *ArrowBucketedEnumPlot
	pagedLog             *PagedLogPlot
	logPoint             **LogPoint
	cartesian            *CartesianPlot
	bucketedCartesian    *BucketedCartesianPlot
	bucketedCartesian3d  *BucketedCartesian3dPlot
	frequencyDomain      *FrequencyDomainPlot
	frequencyDomainV2    *FrequencyDomainPlotV2
	numericHistogram     *NumericHistogramPlot
	enumHistogram        *EnumHistogramPlot
	curveFit             *CurveFitResult
	grouped              *GroupedComputeNodeResponses
	array                *ArrowArrayPlot
	bucketedStruct       *ArrowBucketedStructPlot
	fullResolution       *ArrowFullResolutionPlot
}

type computeNodeResponseDeserializer struct {
	Type                 string                       `json:"type"`
	Range                *[]Range                     `json:"range"`
	RangesSummary        *RangesSummary               `json:"rangesSummary"`
	RangeValue           **Range                      `json:"rangeValue"`
	Numeric              *NumericPlot                 `json:"numeric"`
	BucketedNumeric      *BucketedNumericPlot         `json:"bucketedNumeric"`
	NumericPoint         **NumericPoint               `json:"numericPoint"`
	SinglePoint          **SinglePoint                `json:"singlePoint"`
	ArrowNumeric         *ArrowNumericPlot            `json:"arrowNumeric"`
	ArrowBucketedNumeric *ArrowBucketedNumericPlot    `json:"arrowBucketedNumeric"`
	Enum                 *EnumPlot                    `json:"enum"`
	EnumPoint            **EnumPoint                  `json:"enumPoint"`
	BucketedEnum         *BucketedEnumPlot            `json:"bucketedEnum"`
	ArrowEnum            *ArrowEnumPlot               `json:"arrowEnum"`
	ArrowBucketedEnum    *ArrowBucketedEnumPlot       `json:"arrowBucketedEnum"`
	PagedLog             *PagedLogPlot                `json:"pagedLog"`
	LogPoint             **LogPoint                   `json:"logPoint"`
	Cartesian            *CartesianPlot               `json:"cartesian"`
	BucketedCartesian    *BucketedCartesianPlot       `json:"bucketedCartesian"`
	BucketedCartesian3d  *BucketedCartesian3dPlot     `json:"bucketedCartesian3d"`
	FrequencyDomain      *FrequencyDomainPlot         `json:"frequencyDomain"`
	FrequencyDomainV2    *FrequencyDomainPlotV2       `json:"frequencyDomainV2"`
	NumericHistogram     *NumericHistogramPlot        `json:"numericHistogram"`
	EnumHistogram        *EnumHistogramPlot           `json:"enumHistogram"`
	CurveFit             *CurveFitResult              `json:"curveFit"`
	Grouped              *GroupedComputeNodeResponses `json:"grouped"`
	Array                *ArrowArrayPlot              `json:"array"`
	BucketedStruct       *ArrowBucketedStructPlot     `json:"bucketedStruct"`
	FullResolution       *ArrowFullResolutionPlot     `json:"fullResolution"`
}

func (u *computeNodeResponseDeserializer) toStruct() ComputeNodeResponse {
	return ComputeNodeResponse{typ: u.Type, range_: u.Range, rangesSummary: u.RangesSummary, rangeValue: u.RangeValue, numeric: u.Numeric, bucketedNumeric: u.BucketedNumeric, numericPoint: u.NumericPoint, singlePoint: u.SinglePoint, arrowNumeric: u.ArrowNumeric, arrowBucketedNumeric: u.ArrowBucketedNumeric, enum: u.Enum, enumPoint: u.EnumPoint, bucketedEnum: u.BucketedEnum, arrowEnum: u.ArrowEnum, arrowBucketedEnum: u.ArrowBucketedEnum, pagedLog: u.PagedLog, logPoint: u.LogPoint, cartesian: u.Cartesian, bucketedCartesian: u.BucketedCartesian, bucketedCartesian3d: u.BucketedCartesian3d, frequencyDomain: u.FrequencyDomain, frequencyDomainV2: u.FrequencyDomainV2, numericHistogram: u.NumericHistogram, enumHistogram: u.EnumHistogram, curveFit: u.CurveFit, grouped: u.Grouped, array: u.Array, bucketedStruct: u.BucketedStruct, fullResolution: u.FullResolution}
}

func (u *ComputeNodeResponse) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "range":
		if u.range_ == nil {
			return nil, fmt.Errorf("field \"range\" is required")
		}
		return struct {
			Type  string  `json:"type"`
			Range []Range `json:"range"`
		}{Type: "range", Range: *u.range_}, nil
	case "rangesSummary":
		if u.rangesSummary == nil {
			return nil, fmt.Errorf("field \"rangesSummary\" is required")
		}
		return struct {
			Type          string        `json:"type"`
			RangesSummary RangesSummary `json:"rangesSummary"`
		}{Type: "rangesSummary", RangesSummary: *u.rangesSummary}, nil
	case "rangeValue":
		var rangeValue *Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return struct {
			Type       string `json:"type"`
			RangeValue *Range `json:"rangeValue"`
		}{Type: "rangeValue", RangeValue: rangeValue}, nil
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string      `json:"type"`
			Numeric NumericPlot `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return nil, fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return struct {
			Type            string              `json:"type"`
			BucketedNumeric BucketedNumericPlot `json:"bucketedNumeric"`
		}{Type: "bucketedNumeric", BucketedNumeric: *u.bucketedNumeric}, nil
	case "numericPoint":
		var numericPoint *NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return struct {
			Type         string        `json:"type"`
			NumericPoint *NumericPoint `json:"numericPoint"`
		}{Type: "numericPoint", NumericPoint: numericPoint}, nil
	case "singlePoint":
		var singlePoint *SinglePoint
		if u.singlePoint != nil {
			singlePoint = *u.singlePoint
		}
		return struct {
			Type        string       `json:"type"`
			SinglePoint *SinglePoint `json:"singlePoint"`
		}{Type: "singlePoint", SinglePoint: singlePoint}, nil
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return nil, fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return struct {
			Type         string           `json:"type"`
			ArrowNumeric ArrowNumericPlot `json:"arrowNumeric"`
		}{Type: "arrowNumeric", ArrowNumeric: *u.arrowNumeric}, nil
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return nil, fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return struct {
			Type                 string                   `json:"type"`
			ArrowBucketedNumeric ArrowBucketedNumericPlot `json:"arrowBucketedNumeric"`
		}{Type: "arrowBucketedNumeric", ArrowBucketedNumeric: *u.arrowBucketedNumeric}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string   `json:"type"`
			Enum EnumPlot `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "enumPoint":
		var enumPoint *EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return struct {
			Type      string     `json:"type"`
			EnumPoint *EnumPoint `json:"enumPoint"`
		}{Type: "enumPoint", EnumPoint: enumPoint}, nil
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return nil, fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return struct {
			Type         string           `json:"type"`
			BucketedEnum BucketedEnumPlot `json:"bucketedEnum"`
		}{Type: "bucketedEnum", BucketedEnum: *u.bucketedEnum}, nil
	case "arrowEnum":
		if u.arrowEnum == nil {
			return nil, fmt.Errorf("field \"arrowEnum\" is required")
		}
		return struct {
			Type      string        `json:"type"`
			ArrowEnum ArrowEnumPlot `json:"arrowEnum"`
		}{Type: "arrowEnum", ArrowEnum: *u.arrowEnum}, nil
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return nil, fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return struct {
			Type              string                `json:"type"`
			ArrowBucketedEnum ArrowBucketedEnumPlot `json:"arrowBucketedEnum"`
		}{Type: "arrowBucketedEnum", ArrowBucketedEnum: *u.arrowBucketedEnum}, nil
	case "pagedLog":
		if u.pagedLog == nil {
			return nil, fmt.Errorf("field \"pagedLog\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			PagedLog PagedLogPlot `json:"pagedLog"`
		}{Type: "pagedLog", PagedLog: *u.pagedLog}, nil
	case "logPoint":
		var logPoint *LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return struct {
			Type     string    `json:"type"`
			LogPoint *LogPoint `json:"logPoint"`
		}{Type: "logPoint", LogPoint: logPoint}, nil
	case "cartesian":
		if u.cartesian == nil {
			return nil, fmt.Errorf("field \"cartesian\" is required")
		}
		return struct {
			Type      string        `json:"type"`
			Cartesian CartesianPlot `json:"cartesian"`
		}{Type: "cartesian", Cartesian: *u.cartesian}, nil
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return nil, fmt.Errorf("field \"bucketedCartesian\" is required")
		}
		return struct {
			Type              string                `json:"type"`
			BucketedCartesian BucketedCartesianPlot `json:"bucketedCartesian"`
		}{Type: "bucketedCartesian", BucketedCartesian: *u.bucketedCartesian}, nil
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return nil, fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
		return struct {
			Type                string                  `json:"type"`
			BucketedCartesian3d BucketedCartesian3dPlot `json:"bucketedCartesian3d"`
		}{Type: "bucketedCartesian3d", BucketedCartesian3d: *u.bucketedCartesian3d}, nil
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return nil, fmt.Errorf("field \"frequencyDomain\" is required")
		}
		return struct {
			Type            string              `json:"type"`
			FrequencyDomain FrequencyDomainPlot `json:"frequencyDomain"`
		}{Type: "frequencyDomain", FrequencyDomain: *u.frequencyDomain}, nil
	case "frequencyDomainV2":
		if u.frequencyDomainV2 == nil {
			return nil, fmt.Errorf("field \"frequencyDomainV2\" is required")
		}
		return struct {
			Type              string                `json:"type"`
			FrequencyDomainV2 FrequencyDomainPlotV2 `json:"frequencyDomainV2"`
		}{Type: "frequencyDomainV2", FrequencyDomainV2: *u.frequencyDomainV2}, nil
	case "numericHistogram":
		if u.numericHistogram == nil {
			return nil, fmt.Errorf("field \"numericHistogram\" is required")
		}
		return struct {
			Type             string               `json:"type"`
			NumericHistogram NumericHistogramPlot `json:"numericHistogram"`
		}{Type: "numericHistogram", NumericHistogram: *u.numericHistogram}, nil
	case "enumHistogram":
		if u.enumHistogram == nil {
			return nil, fmt.Errorf("field \"enumHistogram\" is required")
		}
		return struct {
			Type          string            `json:"type"`
			EnumHistogram EnumHistogramPlot `json:"enumHistogram"`
		}{Type: "enumHistogram", EnumHistogram: *u.enumHistogram}, nil
	case "curveFit":
		if u.curveFit == nil {
			return nil, fmt.Errorf("field \"curveFit\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			CurveFit CurveFitResult `json:"curveFit"`
		}{Type: "curveFit", CurveFit: *u.curveFit}, nil
	case "grouped":
		if u.grouped == nil {
			return nil, fmt.Errorf("field \"grouped\" is required")
		}
		return struct {
			Type    string                      `json:"type"`
			Grouped GroupedComputeNodeResponses `json:"grouped"`
		}{Type: "grouped", Grouped: *u.grouped}, nil
	case "array":
		if u.array == nil {
			return nil, fmt.Errorf("field \"array\" is required")
		}
		return struct {
			Type  string         `json:"type"`
			Array ArrowArrayPlot `json:"array"`
		}{Type: "array", Array: *u.array}, nil
	case "bucketedStruct":
		if u.bucketedStruct == nil {
			return nil, fmt.Errorf("field \"bucketedStruct\" is required")
		}
		return struct {
			Type           string                  `json:"type"`
			BucketedStruct ArrowBucketedStructPlot `json:"bucketedStruct"`
		}{Type: "bucketedStruct", BucketedStruct: *u.bucketedStruct}, nil
	case "fullResolution":
		if u.fullResolution == nil {
			return nil, fmt.Errorf("field \"fullResolution\" is required")
		}
		return struct {
			Type           string                  `json:"type"`
			FullResolution ArrowFullResolutionPlot `json:"fullResolution"`
		}{Type: "fullResolution", FullResolution: *u.fullResolution}, nil
	}
}

func (u ComputeNodeResponse) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputeNodeResponse) UnmarshalJSON(data []byte) error {
	var deser computeNodeResponseDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
	case "rangesSummary":
		if u.rangesSummary == nil {
			return fmt.Errorf("field \"rangesSummary\" is required")
		}
	case "rangeValue":
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
	case "numericPoint":
	case "singlePoint":
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "enumPoint":
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
	case "pagedLog":
		if u.pagedLog == nil {
			return fmt.Errorf("field \"pagedLog\" is required")
		}
	case "logPoint":
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return fmt.Errorf("field \"bucketedCartesian\" is required")
		}
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return fmt.Errorf("field \"frequencyDomain\" is required")
		}
	case "frequencyDomainV2":
		if u.frequencyDomainV2 == nil {
			return fmt.Errorf("field \"frequencyDomainV2\" is required")
		}
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
	case "bucketedStruct":
		if u.bucketedStruct == nil {
			return fmt.Errorf("field \"bucketedStruct\" is required")
		}
	case "fullResolution":
		if u.fullResolution == nil {
			return fmt.Errorf("field \"fullResolution\" is required")
		}
	}
	return nil
}

func (u ComputeNodeResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputeNodeResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputeNodeResponse) AcceptFuncs(range_Func func([]Range) error, rangesSummaryFunc func(RangesSummary) error, rangeValueFunc func(*Range) error, numericFunc func(NumericPlot) error, bucketedNumericFunc func(BucketedNumericPlot) error, numericPointFunc func(*NumericPoint) error, singlePointFunc func(*SinglePoint) error, arrowNumericFunc func(ArrowNumericPlot) error, arrowBucketedNumericFunc func(ArrowBucketedNumericPlot) error, enumFunc func(EnumPlot) error, enumPointFunc func(*EnumPoint) error, bucketedEnumFunc func(BucketedEnumPlot) error, arrowEnumFunc func(ArrowEnumPlot) error, arrowBucketedEnumFunc func(ArrowBucketedEnumPlot) error, pagedLogFunc func(PagedLogPlot) error, logPointFunc func(*LogPoint) error, cartesianFunc func(CartesianPlot) error, bucketedCartesianFunc func(BucketedCartesianPlot) error, bucketedCartesian3dFunc func(BucketedCartesian3dPlot) error, frequencyDomainFunc func(FrequencyDomainPlot) error, frequencyDomainV2Func func(FrequencyDomainPlotV2) error, numericHistogramFunc func(NumericHistogramPlot) error, enumHistogramFunc func(EnumHistogramPlot) error, curveFitFunc func(CurveFitResult) error, groupedFunc func(GroupedComputeNodeResponses) error, arrayFunc func(ArrowArrayPlot) error, bucketedStructFunc func(ArrowBucketedStructPlot) error, fullResolutionFunc func(ArrowFullResolutionPlot) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "rangesSummary":
		if u.rangesSummary == nil {
			return fmt.Errorf("field \"rangesSummary\" is required")
		}
		return rangesSummaryFunc(*u.rangesSummary)
	case "rangeValue":
		var rangeValue *Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return rangeValueFunc(rangeValue)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return bucketedNumericFunc(*u.bucketedNumeric)
	case "numericPoint":
		var numericPoint *NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return numericPointFunc(numericPoint)
	case "singlePoint":
		var singlePoint *SinglePoint
		if u.singlePoint != nil {
			singlePoint = *u.singlePoint
		}
		return singlePointFunc(singlePoint)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return arrowNumericFunc(*u.arrowNumeric)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return arrowBucketedNumericFunc(*u.arrowBucketedNumeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "enumPoint":
		var enumPoint *EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return enumPointFunc(enumPoint)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return bucketedEnumFunc(*u.bucketedEnum)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
		return arrowEnumFunc(*u.arrowEnum)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return arrowBucketedEnumFunc(*u.arrowBucketedEnum)
	case "pagedLog":
		if u.pagedLog == nil {
			return fmt.Errorf("field \"pagedLog\" is required")
		}
		return pagedLogFunc(*u.pagedLog)
	case "logPoint":
		var logPoint *LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return logPointFunc(logPoint)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return fmt.Errorf("field \"bucketedCartesian\" is required")
		}
		return bucketedCartesianFunc(*u.bucketedCartesian)
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
		return bucketedCartesian3dFunc(*u.bucketedCartesian3d)
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return fmt.Errorf("field \"frequencyDomain\" is required")
		}
		return frequencyDomainFunc(*u.frequencyDomain)
	case "frequencyDomainV2":
		if u.frequencyDomainV2 == nil {
			return fmt.Errorf("field \"frequencyDomainV2\" is required")
		}
		return frequencyDomainV2Func(*u.frequencyDomainV2)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
		return numericHistogramFunc(*u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
		return enumHistogramFunc(*u.enumHistogram)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return curveFitFunc(*u.curveFit)
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
		return groupedFunc(*u.grouped)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	case "bucketedStruct":
		if u.bucketedStruct == nil {
			return fmt.Errorf("field \"bucketedStruct\" is required")
		}
		return bucketedStructFunc(*u.bucketedStruct)
	case "fullResolution":
		if u.fullResolution == nil {
			return fmt.Errorf("field \"fullResolution\" is required")
		}
		return fullResolutionFunc(*u.fullResolution)
	}
}

func (u *ComputeNodeResponse) RangeNoopSuccess([]Range) error {
	return nil
}

func (u *ComputeNodeResponse) RangesSummaryNoopSuccess(RangesSummary) error {
	return nil
}

func (u *ComputeNodeResponse) RangeValueNoopSuccess(*Range) error {
	return nil
}

func (u *ComputeNodeResponse) NumericNoopSuccess(NumericPlot) error {
	return nil
}

func (u *ComputeNodeResponse) BucketedNumericNoopSuccess(BucketedNumericPlot) error {
	return nil
}

func (u *ComputeNodeResponse) NumericPointNoopSuccess(*NumericPoint) error {
	return nil
}

func (u *ComputeNodeResponse) SinglePointNoopSuccess(*SinglePoint) error {
	return nil
}

func (u *ComputeNodeResponse) ArrowNumericNoopSuccess(ArrowNumericPlot) error {
	return nil
}

func (u *ComputeNodeResponse) ArrowBucketedNumericNoopSuccess(ArrowBucketedNumericPlot) error {
	return nil
}

func (u *ComputeNodeResponse) EnumNoopSuccess(EnumPlot) error {
	return nil
}

func (u *ComputeNodeResponse) EnumPointNoopSuccess(*EnumPoint) error {
	return nil
}

func (u *ComputeNodeResponse) BucketedEnumNoopSuccess(BucketedEnumPlot) error {
	return nil
}

func (u *ComputeNodeResponse) ArrowEnumNoopSuccess(ArrowEnumPlot) error {
	return nil
}

func (u *ComputeNodeResponse) ArrowBucketedEnumNoopSuccess(ArrowBucketedEnumPlot) error {
	return nil
}

func (u *ComputeNodeResponse) PagedLogNoopSuccess(PagedLogPlot) error {
	return nil
}

func (u *ComputeNodeResponse) LogPointNoopSuccess(*LogPoint) error {
	return nil
}

func (u *ComputeNodeResponse) CartesianNoopSuccess(CartesianPlot) error {
	return nil
}

func (u *ComputeNodeResponse) BucketedCartesianNoopSuccess(BucketedCartesianPlot) error {
	return nil
}

func (u *ComputeNodeResponse) BucketedCartesian3dNoopSuccess(BucketedCartesian3dPlot) error {
	return nil
}

func (u *ComputeNodeResponse) FrequencyDomainNoopSuccess(FrequencyDomainPlot) error {
	return nil
}

func (u *ComputeNodeResponse) FrequencyDomainV2NoopSuccess(FrequencyDomainPlotV2) error {
	return nil
}

func (u *ComputeNodeResponse) NumericHistogramNoopSuccess(NumericHistogramPlot) error {
	return nil
}

func (u *ComputeNodeResponse) EnumHistogramNoopSuccess(EnumHistogramPlot) error {
	return nil
}

func (u *ComputeNodeResponse) CurveFitNoopSuccess(CurveFitResult) error {
	return nil
}

func (u *ComputeNodeResponse) GroupedNoopSuccess(GroupedComputeNodeResponses) error {
	return nil
}

func (u *ComputeNodeResponse) ArrayNoopSuccess(ArrowArrayPlot) error {
	return nil
}

func (u *ComputeNodeResponse) BucketedStructNoopSuccess(ArrowBucketedStructPlot) error {
	return nil
}

func (u *ComputeNodeResponse) FullResolutionNoopSuccess(ArrowFullResolutionPlot) error {
	return nil
}

func (u *ComputeNodeResponse) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputeNodeResponse) Accept(v ComputeNodeResponseVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(*u.range_)
	case "rangesSummary":
		if u.rangesSummary == nil {
			return fmt.Errorf("field \"rangesSummary\" is required")
		}
		return v.VisitRangesSummary(*u.rangesSummary)
	case "rangeValue":
		var rangeValue *Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return v.VisitRangeValue(rangeValue)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumeric(*u.bucketedNumeric)
	case "numericPoint":
		var numericPoint *NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return v.VisitNumericPoint(numericPoint)
	case "singlePoint":
		var singlePoint *SinglePoint
		if u.singlePoint != nil {
			singlePoint = *u.singlePoint
		}
		return v.VisitSinglePoint(singlePoint)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return v.VisitArrowNumeric(*u.arrowNumeric)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return v.VisitArrowBucketedNumeric(*u.arrowBucketedNumeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "enumPoint":
		var enumPoint *EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return v.VisitEnumPoint(enumPoint)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnum(*u.bucketedEnum)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
		return v.VisitArrowEnum(*u.arrowEnum)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return v.VisitArrowBucketedEnum(*u.arrowBucketedEnum)
	case "pagedLog":
		if u.pagedLog == nil {
			return fmt.Errorf("field \"pagedLog\" is required")
		}
		return v.VisitPagedLog(*u.pagedLog)
	case "logPoint":
		var logPoint *LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return v.VisitLogPoint(logPoint)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(*u.cartesian)
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return fmt.Errorf("field \"bucketedCartesian\" is required")
		}
		return v.VisitBucketedCartesian(*u.bucketedCartesian)
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
		return v.VisitBucketedCartesian3d(*u.bucketedCartesian3d)
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return fmt.Errorf("field \"frequencyDomain\" is required")
		}
		return v.VisitFrequencyDomain(*u.frequencyDomain)
	case "frequencyDomainV2":
		if u.frequencyDomainV2 == nil {
			return fmt.Errorf("field \"frequencyDomainV2\" is required")
		}
		return v.VisitFrequencyDomainV2(*u.frequencyDomainV2)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
		return v.VisitNumericHistogram(*u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
		return v.VisitEnumHistogram(*u.enumHistogram)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return v.VisitCurveFit(*u.curveFit)
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
		return v.VisitGrouped(*u.grouped)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(*u.array)
	case "bucketedStruct":
		if u.bucketedStruct == nil {
			return fmt.Errorf("field \"bucketedStruct\" is required")
		}
		return v.VisitBucketedStruct(*u.bucketedStruct)
	case "fullResolution":
		if u.fullResolution == nil {
			return fmt.Errorf("field \"fullResolution\" is required")
		}
		return v.VisitFullResolution(*u.fullResolution)
	}
}

type ComputeNodeResponseVisitor interface {
	VisitRange(v []Range) error
	VisitRangesSummary(v RangesSummary) error
	VisitRangeValue(v *Range) error
	VisitNumeric(v NumericPlot) error
	VisitBucketedNumeric(v BucketedNumericPlot) error
	VisitNumericPoint(v *NumericPoint) error
	VisitSinglePoint(v *SinglePoint) error
	VisitArrowNumeric(v ArrowNumericPlot) error
	VisitArrowBucketedNumeric(v ArrowBucketedNumericPlot) error
	VisitEnum(v EnumPlot) error
	VisitEnumPoint(v *EnumPoint) error
	VisitBucketedEnum(v BucketedEnumPlot) error
	VisitArrowEnum(v ArrowEnumPlot) error
	VisitArrowBucketedEnum(v ArrowBucketedEnumPlot) error
	VisitPagedLog(v PagedLogPlot) error
	VisitLogPoint(v *LogPoint) error
	VisitCartesian(v CartesianPlot) error
	VisitBucketedCartesian(v BucketedCartesianPlot) error
	VisitBucketedCartesian3d(v BucketedCartesian3dPlot) error
	VisitFrequencyDomain(v FrequencyDomainPlot) error
	VisitFrequencyDomainV2(v FrequencyDomainPlotV2) error
	VisitNumericHistogram(v NumericHistogramPlot) error
	VisitEnumHistogram(v EnumHistogramPlot) error
	VisitCurveFit(v CurveFitResult) error
	VisitGrouped(v GroupedComputeNodeResponses) error
	VisitArray(v ArrowArrayPlot) error
	VisitBucketedStruct(v ArrowBucketedStructPlot) error
	VisitFullResolution(v ArrowFullResolutionPlot) error
	VisitUnknown(typeName string) error
}

func (u *ComputeNodeResponse) AcceptWithContext(ctx context.Context, v ComputeNodeResponseVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRangeWithContext(ctx, *u.range_)
	case "rangesSummary":
		if u.rangesSummary == nil {
			return fmt.Errorf("field \"rangesSummary\" is required")
		}
		return v.VisitRangesSummaryWithContext(ctx, *u.rangesSummary)
	case "rangeValue":
		var rangeValue *Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return v.VisitRangeValueWithContext(ctx, rangeValue)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumericWithContext(ctx, *u.bucketedNumeric)
	case "numericPoint":
		var numericPoint *NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return v.VisitNumericPointWithContext(ctx, numericPoint)
	case "singlePoint":
		var singlePoint *SinglePoint
		if u.singlePoint != nil {
			singlePoint = *u.singlePoint
		}
		return v.VisitSinglePointWithContext(ctx, singlePoint)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return v.VisitArrowNumericWithContext(ctx, *u.arrowNumeric)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return v.VisitArrowBucketedNumericWithContext(ctx, *u.arrowBucketedNumeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "enumPoint":
		var enumPoint *EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return v.VisitEnumPointWithContext(ctx, enumPoint)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnumWithContext(ctx, *u.bucketedEnum)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
		return v.VisitArrowEnumWithContext(ctx, *u.arrowEnum)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return v.VisitArrowBucketedEnumWithContext(ctx, *u.arrowBucketedEnum)
	case "pagedLog":
		if u.pagedLog == nil {
			return fmt.Errorf("field \"pagedLog\" is required")
		}
		return v.VisitPagedLogWithContext(ctx, *u.pagedLog)
	case "logPoint":
		var logPoint *LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return v.VisitLogPointWithContext(ctx, logPoint)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesianWithContext(ctx, *u.cartesian)
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return fmt.Errorf("field \"bucketedCartesian\" is required")
		}
		return v.VisitBucketedCartesianWithContext(ctx, *u.bucketedCartesian)
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
		return v.VisitBucketedCartesian3dWithContext(ctx, *u.bucketedCartesian3d)
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return fmt.Errorf("field \"frequencyDomain\" is required")
		}
		return v.VisitFrequencyDomainWithContext(ctx, *u.frequencyDomain)
	case "frequencyDomainV2":
		if u.frequencyDomainV2 == nil {
			return fmt.Errorf("field \"frequencyDomainV2\" is required")
		}
		return v.VisitFrequencyDomainV2WithContext(ctx, *u.frequencyDomainV2)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
		return v.VisitNumericHistogramWithContext(ctx, *u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
		return v.VisitEnumHistogramWithContext(ctx, *u.enumHistogram)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return v.VisitCurveFitWithContext(ctx, *u.curveFit)
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
		return v.VisitGroupedWithContext(ctx, *u.grouped)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArrayWithContext(ctx, *u.array)
	case "bucketedStruct":
		if u.bucketedStruct == nil {
			return fmt.Errorf("field \"bucketedStruct\" is required")
		}
		return v.VisitBucketedStructWithContext(ctx, *u.bucketedStruct)
	case "fullResolution":
		if u.fullResolution == nil {
			return fmt.Errorf("field \"fullResolution\" is required")
		}
		return v.VisitFullResolutionWithContext(ctx, *u.fullResolution)
	}
}

type ComputeNodeResponseVisitorWithContext interface {
	VisitRangeWithContext(ctx context.Context, v []Range) error
	VisitRangesSummaryWithContext(ctx context.Context, v RangesSummary) error
	VisitRangeValueWithContext(ctx context.Context, v *Range) error
	VisitNumericWithContext(ctx context.Context, v NumericPlot) error
	VisitBucketedNumericWithContext(ctx context.Context, v BucketedNumericPlot) error
	VisitNumericPointWithContext(ctx context.Context, v *NumericPoint) error
	VisitSinglePointWithContext(ctx context.Context, v *SinglePoint) error
	VisitArrowNumericWithContext(ctx context.Context, v ArrowNumericPlot) error
	VisitArrowBucketedNumericWithContext(ctx context.Context, v ArrowBucketedNumericPlot) error
	VisitEnumWithContext(ctx context.Context, v EnumPlot) error
	VisitEnumPointWithContext(ctx context.Context, v *EnumPoint) error
	VisitBucketedEnumWithContext(ctx context.Context, v BucketedEnumPlot) error
	VisitArrowEnumWithContext(ctx context.Context, v ArrowEnumPlot) error
	VisitArrowBucketedEnumWithContext(ctx context.Context, v ArrowBucketedEnumPlot) error
	VisitPagedLogWithContext(ctx context.Context, v PagedLogPlot) error
	VisitLogPointWithContext(ctx context.Context, v *LogPoint) error
	VisitCartesianWithContext(ctx context.Context, v CartesianPlot) error
	VisitBucketedCartesianWithContext(ctx context.Context, v BucketedCartesianPlot) error
	VisitBucketedCartesian3dWithContext(ctx context.Context, v BucketedCartesian3dPlot) error
	VisitFrequencyDomainWithContext(ctx context.Context, v FrequencyDomainPlot) error
	VisitFrequencyDomainV2WithContext(ctx context.Context, v FrequencyDomainPlotV2) error
	VisitNumericHistogramWithContext(ctx context.Context, v NumericHistogramPlot) error
	VisitEnumHistogramWithContext(ctx context.Context, v EnumHistogramPlot) error
	VisitCurveFitWithContext(ctx context.Context, v CurveFitResult) error
	VisitGroupedWithContext(ctx context.Context, v GroupedComputeNodeResponses) error
	VisitArrayWithContext(ctx context.Context, v ArrowArrayPlot) error
	VisitBucketedStructWithContext(ctx context.Context, v ArrowBucketedStructPlot) error
	VisitFullResolutionWithContext(ctx context.Context, v ArrowFullResolutionPlot) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputeNodeResponseFromRange(v []Range) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "range", range_: &v}
}

func NewComputeNodeResponseFromRangesSummary(v RangesSummary) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "rangesSummary", rangesSummary: &v}
}

func NewComputeNodeResponseFromRangeValue(v *Range) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "rangeValue", rangeValue: &v}
}

func NewComputeNodeResponseFromNumeric(v NumericPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "numeric", numeric: &v}
}

func NewComputeNodeResponseFromBucketedNumeric(v BucketedNumericPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "bucketedNumeric", bucketedNumeric: &v}
}

func NewComputeNodeResponseFromNumericPoint(v *NumericPoint) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "numericPoint", numericPoint: &v}
}

func NewComputeNodeResponseFromSinglePoint(v *SinglePoint) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "singlePoint", singlePoint: &v}
}

func NewComputeNodeResponseFromArrowNumeric(v ArrowNumericPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "arrowNumeric", arrowNumeric: &v}
}

func NewComputeNodeResponseFromArrowBucketedNumeric(v ArrowBucketedNumericPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "arrowBucketedNumeric", arrowBucketedNumeric: &v}
}

func NewComputeNodeResponseFromEnum(v EnumPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "enum", enum: &v}
}

func NewComputeNodeResponseFromEnumPoint(v *EnumPoint) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "enumPoint", enumPoint: &v}
}

func NewComputeNodeResponseFromBucketedEnum(v BucketedEnumPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "bucketedEnum", bucketedEnum: &v}
}

func NewComputeNodeResponseFromArrowEnum(v ArrowEnumPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "arrowEnum", arrowEnum: &v}
}

func NewComputeNodeResponseFromArrowBucketedEnum(v ArrowBucketedEnumPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "arrowBucketedEnum", arrowBucketedEnum: &v}
}

func NewComputeNodeResponseFromPagedLog(v PagedLogPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "pagedLog", pagedLog: &v}
}

func NewComputeNodeResponseFromLogPoint(v *LogPoint) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "logPoint", logPoint: &v}
}

func NewComputeNodeResponseFromCartesian(v CartesianPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "cartesian", cartesian: &v}
}

func NewComputeNodeResponseFromBucketedCartesian(v BucketedCartesianPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "bucketedCartesian", bucketedCartesian: &v}
}

func NewComputeNodeResponseFromBucketedCartesian3d(v BucketedCartesian3dPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "bucketedCartesian3d", bucketedCartesian3d: &v}
}

func NewComputeNodeResponseFromFrequencyDomain(v FrequencyDomainPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "frequencyDomain", frequencyDomain: &v}
}

func NewComputeNodeResponseFromFrequencyDomainV2(v FrequencyDomainPlotV2) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "frequencyDomainV2", frequencyDomainV2: &v}
}

func NewComputeNodeResponseFromNumericHistogram(v NumericHistogramPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "numericHistogram", numericHistogram: &v}
}

func NewComputeNodeResponseFromEnumHistogram(v EnumHistogramPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "enumHistogram", enumHistogram: &v}
}

func NewComputeNodeResponseFromCurveFit(v CurveFitResult) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "curveFit", curveFit: &v}
}

func NewComputeNodeResponseFromGrouped(v GroupedComputeNodeResponses) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "grouped", grouped: &v}
}

func NewComputeNodeResponseFromArray(v ArrowArrayPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "array", array: &v}
}

func NewComputeNodeResponseFromBucketedStruct(v ArrowBucketedStructPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "bucketedStruct", bucketedStruct: &v}
}

func NewComputeNodeResponseFromFullResolution(v ArrowFullResolutionPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "fullResolution", fullResolution: &v}
}

type ComputeNodeResult struct {
	typ     string
	success *ComputeNodeResponse
	error   *ErrorResult
}

type computeNodeResultDeserializer struct {
	Type    string               `json:"type"`
	Success *ComputeNodeResponse `json:"success"`
	Error   *ErrorResult         `json:"error"`
}

func (u *computeNodeResultDeserializer) toStruct() ComputeNodeResult {
	return ComputeNodeResult{typ: u.Type, success: u.Success, error: u.Error}
}

func (u *ComputeNodeResult) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "success":
		if u.success == nil {
			return nil, fmt.Errorf("field \"success\" is required")
		}
		return struct {
			Type    string              `json:"type"`
			Success ComputeNodeResponse `json:"success"`
		}{Type: "success", Success: *u.success}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Error ErrorResult `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	}
}

func (u ComputeNodeResult) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputeNodeResult) UnmarshalJSON(data []byte) error {
	var deser computeNodeResultDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	}
	return nil
}

func (u ComputeNodeResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputeNodeResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputeNodeResult) AcceptFuncs(successFunc func(ComputeNodeResponse) error, errorFunc func(ErrorResult) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *ComputeNodeResult) SuccessNoopSuccess(ComputeNodeResponse) error {
	return nil
}

func (u *ComputeNodeResult) ErrorNoopSuccess(ErrorResult) error {
	return nil
}

func (u *ComputeNodeResult) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputeNodeResult) Accept(v ComputeNodeResultVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	}
}

type ComputeNodeResultVisitor interface {
	VisitSuccess(v ComputeNodeResponse) error
	VisitError(v ErrorResult) error
	VisitUnknown(typeName string) error
}

func (u *ComputeNodeResult) AcceptWithContext(ctx context.Context, v ComputeNodeResultVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccessWithContext(ctx, *u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	}
}

type ComputeNodeResultVisitorWithContext interface {
	VisitSuccessWithContext(ctx context.Context, v ComputeNodeResponse) error
	VisitErrorWithContext(ctx context.Context, v ErrorResult) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputeNodeResultFromSuccess(v ComputeNodeResponse) ComputeNodeResult {
	return ComputeNodeResult{typ: "success", success: &v}
}

func NewComputeNodeResultFromError(v ErrorResult) ComputeNodeResult {
	return ComputeNodeResult{typ: "error", error: &v}
}

type ComputeUnitResult struct {
	typ         string
	single      *UnitResult
	cartesian   *CartesianUnitResult
	cartesian3d *Cartesian3dUnitResult
}

type computeUnitResultDeserializer struct {
	Type        string                 `json:"type"`
	Single      *UnitResult            `json:"single"`
	Cartesian   *CartesianUnitResult   `json:"cartesian"`
	Cartesian3d *Cartesian3dUnitResult `json:"cartesian3d"`
}

func (u *computeUnitResultDeserializer) toStruct() ComputeUnitResult {
	return ComputeUnitResult{typ: u.Type, single: u.Single, cartesian: u.Cartesian, cartesian3d: u.Cartesian3d}
}

func (u *ComputeUnitResult) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "single":
		if u.single == nil {
			return nil, fmt.Errorf("field \"single\" is required")
		}
		return struct {
			Type   string     `json:"type"`
			Single UnitResult `json:"single"`
		}{Type: "single", Single: *u.single}, nil
	case "cartesian":
		if u.cartesian == nil {
			return nil, fmt.Errorf("field \"cartesian\" is required")
		}
		return struct {
			Type      string              `json:"type"`
			Cartesian CartesianUnitResult `json:"cartesian"`
		}{Type: "cartesian", Cartesian: *u.cartesian}, nil
	case "cartesian3d":
		if u.cartesian3d == nil {
			return nil, fmt.Errorf("field \"cartesian3d\" is required")
		}
		return struct {
			Type        string                `json:"type"`
			Cartesian3d Cartesian3dUnitResult `json:"cartesian3d"`
		}{Type: "cartesian3d", Cartesian3d: *u.cartesian3d}, nil
	}
}

func (u ComputeUnitResult) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputeUnitResult) UnmarshalJSON(data []byte) error {
	var deser computeUnitResultDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
	}
	return nil
}

func (u ComputeUnitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputeUnitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputeUnitResult) AcceptFuncs(singleFunc func(UnitResult) error, cartesianFunc func(CartesianUnitResult) error, cartesian3dFunc func(Cartesian3dUnitResult) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return cartesian3dFunc(*u.cartesian3d)
	}
}

func (u *ComputeUnitResult) SingleNoopSuccess(UnitResult) error {
	return nil
}

func (u *ComputeUnitResult) CartesianNoopSuccess(CartesianUnitResult) error {
	return nil
}

func (u *ComputeUnitResult) Cartesian3dNoopSuccess(Cartesian3dUnitResult) error {
	return nil
}

func (u *ComputeUnitResult) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputeUnitResult) Accept(v ComputeUnitResultVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(*u.single)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3d(*u.cartesian3d)
	}
}

type ComputeUnitResultVisitor interface {
	VisitSingle(v UnitResult) error
	VisitCartesian(v CartesianUnitResult) error
	VisitCartesian3d(v Cartesian3dUnitResult) error
	VisitUnknown(typeName string) error
}

func (u *ComputeUnitResult) AcceptWithContext(ctx context.Context, v ComputeUnitResultVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingleWithContext(ctx, *u.single)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesianWithContext(ctx, *u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3dWithContext(ctx, *u.cartesian3d)
	}
}

type ComputeUnitResultVisitorWithContext interface {
	VisitSingleWithContext(ctx context.Context, v UnitResult) error
	VisitCartesianWithContext(ctx context.Context, v CartesianUnitResult) error
	VisitCartesian3dWithContext(ctx context.Context, v Cartesian3dUnitResult) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputeUnitResultFromSingle(v UnitResult) ComputeUnitResult {
	return ComputeUnitResult{typ: "single", single: &v}
}

func NewComputeUnitResultFromCartesian(v CartesianUnitResult) ComputeUnitResult {
	return ComputeUnitResult{typ: "cartesian", cartesian: &v}
}

func NewComputeUnitResultFromCartesian3d(v Cartesian3dUnitResult) ComputeUnitResult {
	return ComputeUnitResult{typ: "cartesian3d", cartesian3d: &v}
}

type CurveFitDetails struct {
	typ         string
	exponential *ExponentialCurve
	logarithmic *LogarithmicCurve
	polynomial  *PolynomialCurve
	power       *PowerCurve
}

type curveFitDetailsDeserializer struct {
	Type        string            `json:"type"`
	Exponential *ExponentialCurve `json:"exponential"`
	Logarithmic *LogarithmicCurve `json:"logarithmic"`
	Polynomial  *PolynomialCurve  `json:"polynomial"`
	Power       *PowerCurve       `json:"power"`
}

func (u *curveFitDetailsDeserializer) toStruct() CurveFitDetails {
	return CurveFitDetails{typ: u.Type, exponential: u.Exponential, logarithmic: u.Logarithmic, polynomial: u.Polynomial, power: u.Power}
}

func (u *CurveFitDetails) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "exponential":
		if u.exponential == nil {
			return nil, fmt.Errorf("field \"exponential\" is required")
		}
		return struct {
			Type        string           `json:"type"`
			Exponential ExponentialCurve `json:"exponential"`
		}{Type: "exponential", Exponential: *u.exponential}, nil
	case "logarithmic":
		if u.logarithmic == nil {
			return nil, fmt.Errorf("field \"logarithmic\" is required")
		}
		return struct {
			Type        string           `json:"type"`
			Logarithmic LogarithmicCurve `json:"logarithmic"`
		}{Type: "logarithmic", Logarithmic: *u.logarithmic}, nil
	case "polynomial":
		if u.polynomial == nil {
			return nil, fmt.Errorf("field \"polynomial\" is required")
		}
		return struct {
			Type       string          `json:"type"`
			Polynomial PolynomialCurve `json:"polynomial"`
		}{Type: "polynomial", Polynomial: *u.polynomial}, nil
	case "power":
		if u.power == nil {
			return nil, fmt.Errorf("field \"power\" is required")
		}
		return struct {
			Type  string     `json:"type"`
			Power PowerCurve `json:"power"`
		}{Type: "power", Power: *u.power}, nil
	}
}

func (u CurveFitDetails) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CurveFitDetails) UnmarshalJSON(data []byte) error {
	var deser curveFitDetailsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
	}
	return nil
}

func (u CurveFitDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CurveFitDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CurveFitDetails) AcceptFuncs(exponentialFunc func(ExponentialCurve) error, logarithmicFunc func(LogarithmicCurve) error, polynomialFunc func(PolynomialCurve) error, powerFunc func(PowerCurve) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return exponentialFunc(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return logarithmicFunc(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return polynomialFunc(*u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return powerFunc(*u.power)
	}
}

func (u *CurveFitDetails) ExponentialNoopSuccess(ExponentialCurve) error {
	return nil
}

func (u *CurveFitDetails) LogarithmicNoopSuccess(LogarithmicCurve) error {
	return nil
}

func (u *CurveFitDetails) PolynomialNoopSuccess(PolynomialCurve) error {
	return nil
}

func (u *CurveFitDetails) PowerNoopSuccess(PowerCurve) error {
	return nil
}

func (u *CurveFitDetails) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CurveFitDetails) Accept(v CurveFitDetailsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponential(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmic(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomial(*u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPower(*u.power)
	}
}

type CurveFitDetailsVisitor interface {
	VisitExponential(v ExponentialCurve) error
	VisitLogarithmic(v LogarithmicCurve) error
	VisitPolynomial(v PolynomialCurve) error
	VisitPower(v PowerCurve) error
	VisitUnknown(typeName string) error
}

func (u *CurveFitDetails) AcceptWithContext(ctx context.Context, v CurveFitDetailsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponentialWithContext(ctx, *u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmicWithContext(ctx, *u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomialWithContext(ctx, *u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPowerWithContext(ctx, *u.power)
	}
}

type CurveFitDetailsVisitorWithContext interface {
	VisitExponentialWithContext(ctx context.Context, v ExponentialCurve) error
	VisitLogarithmicWithContext(ctx context.Context, v LogarithmicCurve) error
	VisitPolynomialWithContext(ctx context.Context, v PolynomialCurve) error
	VisitPowerWithContext(ctx context.Context, v PowerCurve) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCurveFitDetailsFromExponential(v ExponentialCurve) CurveFitDetails {
	return CurveFitDetails{typ: "exponential", exponential: &v}
}

func NewCurveFitDetailsFromLogarithmic(v LogarithmicCurve) CurveFitDetails {
	return CurveFitDetails{typ: "logarithmic", logarithmic: &v}
}

func NewCurveFitDetailsFromPolynomial(v PolynomialCurve) CurveFitDetails {
	return CurveFitDetails{typ: "polynomial", polynomial: &v}
}

func NewCurveFitDetailsFromPower(v PowerCurve) CurveFitDetails {
	return CurveFitDetails{typ: "power", power: &v}
}

type CurveResultDetails struct {
	typ         string
	exponential *ExponentialResultDetails
	logarithmic *LogarithmicResultDetails
	polynomial  *PolynomialResultDetails
	power       *PowerResultDetails
}

type curveResultDetailsDeserializer struct {
	Type        string                    `json:"type"`
	Exponential *ExponentialResultDetails `json:"exponential"`
	Logarithmic *LogarithmicResultDetails `json:"logarithmic"`
	Polynomial  *PolynomialResultDetails  `json:"polynomial"`
	Power       *PowerResultDetails       `json:"power"`
}

func (u *curveResultDetailsDeserializer) toStruct() CurveResultDetails {
	return CurveResultDetails{typ: u.Type, exponential: u.Exponential, logarithmic: u.Logarithmic, polynomial: u.Polynomial, power: u.Power}
}

func (u *CurveResultDetails) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "exponential":
		if u.exponential == nil {
			return nil, fmt.Errorf("field \"exponential\" is required")
		}
		return struct {
			Type        string                   `json:"type"`
			Exponential ExponentialResultDetails `json:"exponential"`
		}{Type: "exponential", Exponential: *u.exponential}, nil
	case "logarithmic":
		if u.logarithmic == nil {
			return nil, fmt.Errorf("field \"logarithmic\" is required")
		}
		return struct {
			Type        string                   `json:"type"`
			Logarithmic LogarithmicResultDetails `json:"logarithmic"`
		}{Type: "logarithmic", Logarithmic: *u.logarithmic}, nil
	case "polynomial":
		if u.polynomial == nil {
			return nil, fmt.Errorf("field \"polynomial\" is required")
		}
		return struct {
			Type       string                  `json:"type"`
			Polynomial PolynomialResultDetails `json:"polynomial"`
		}{Type: "polynomial", Polynomial: *u.polynomial}, nil
	case "power":
		if u.power == nil {
			return nil, fmt.Errorf("field \"power\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Power PowerResultDetails `json:"power"`
		}{Type: "power", Power: *u.power}, nil
	}
}

func (u CurveResultDetails) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CurveResultDetails) UnmarshalJSON(data []byte) error {
	var deser curveResultDetailsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
	}
	return nil
}

func (u CurveResultDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CurveResultDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CurveResultDetails) AcceptFuncs(exponentialFunc func(ExponentialResultDetails) error, logarithmicFunc func(LogarithmicResultDetails) error, polynomialFunc func(PolynomialResultDetails) error, powerFunc func(PowerResultDetails) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return exponentialFunc(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return logarithmicFunc(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return polynomialFunc(*u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return powerFunc(*u.power)
	}
}

func (u *CurveResultDetails) ExponentialNoopSuccess(ExponentialResultDetails) error {
	return nil
}

func (u *CurveResultDetails) LogarithmicNoopSuccess(LogarithmicResultDetails) error {
	return nil
}

func (u *CurveResultDetails) PolynomialNoopSuccess(PolynomialResultDetails) error {
	return nil
}

func (u *CurveResultDetails) PowerNoopSuccess(PowerResultDetails) error {
	return nil
}

func (u *CurveResultDetails) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CurveResultDetails) Accept(v CurveResultDetailsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponential(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmic(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomial(*u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPower(*u.power)
	}
}

type CurveResultDetailsVisitor interface {
	VisitExponential(v ExponentialResultDetails) error
	VisitLogarithmic(v LogarithmicResultDetails) error
	VisitPolynomial(v PolynomialResultDetails) error
	VisitPower(v PowerResultDetails) error
	VisitUnknown(typeName string) error
}

func (u *CurveResultDetails) AcceptWithContext(ctx context.Context, v CurveResultDetailsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponentialWithContext(ctx, *u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmicWithContext(ctx, *u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomialWithContext(ctx, *u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPowerWithContext(ctx, *u.power)
	}
}

type CurveResultDetailsVisitorWithContext interface {
	VisitExponentialWithContext(ctx context.Context, v ExponentialResultDetails) error
	VisitLogarithmicWithContext(ctx context.Context, v LogarithmicResultDetails) error
	VisitPolynomialWithContext(ctx context.Context, v PolynomialResultDetails) error
	VisitPowerWithContext(ctx context.Context, v PowerResultDetails) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCurveResultDetailsFromExponential(v ExponentialResultDetails) CurveResultDetails {
	return CurveResultDetails{typ: "exponential", exponential: &v}
}

func NewCurveResultDetailsFromLogarithmic(v LogarithmicResultDetails) CurveResultDetails {
	return CurveResultDetails{typ: "logarithmic", logarithmic: &v}
}

func NewCurveResultDetailsFromPolynomial(v PolynomialResultDetails) CurveResultDetails {
	return CurveResultDetails{typ: "polynomial", polynomial: &v}
}

func NewCurveResultDetailsFromPower(v PowerResultDetails) CurveResultDetails {
	return CurveResultDetails{typ: "power", power: &v}
}

type DecimateStrategy struct {
	typ        string
	resolution *DecimateWithResolution
	buckets    *DecimateWithBuckets
}

type decimateStrategyDeserializer struct {
	Type       string                  `json:"type"`
	Resolution *DecimateWithResolution `json:"resolution"`
	Buckets    *DecimateWithBuckets    `json:"buckets"`
}

func (u *decimateStrategyDeserializer) toStruct() DecimateStrategy {
	return DecimateStrategy{typ: u.Type, resolution: u.Resolution, buckets: u.Buckets}
}

func (u *DecimateStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "resolution":
		if u.resolution == nil {
			return nil, fmt.Errorf("field \"resolution\" is required")
		}
		return struct {
			Type       string                 `json:"type"`
			Resolution DecimateWithResolution `json:"resolution"`
		}{Type: "resolution", Resolution: *u.resolution}, nil
	case "buckets":
		if u.buckets == nil {
			return nil, fmt.Errorf("field \"buckets\" is required")
		}
		return struct {
			Type    string              `json:"type"`
			Buckets DecimateWithBuckets `json:"buckets"`
		}{Type: "buckets", Buckets: *u.buckets}, nil
	}
}

func (u DecimateStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DecimateStrategy) UnmarshalJSON(data []byte) error {
	var deser decimateStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "resolution":
		if u.resolution == nil {
			return fmt.Errorf("field \"resolution\" is required")
		}
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
	}
	return nil
}

func (u DecimateStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DecimateStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DecimateStrategy) AcceptFuncs(resolutionFunc func(DecimateWithResolution) error, bucketsFunc func(DecimateWithBuckets) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "resolution":
		if u.resolution == nil {
			return fmt.Errorf("field \"resolution\" is required")
		}
		return resolutionFunc(*u.resolution)
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
		return bucketsFunc(*u.buckets)
	}
}

func (u *DecimateStrategy) ResolutionNoopSuccess(DecimateWithResolution) error {
	return nil
}

func (u *DecimateStrategy) BucketsNoopSuccess(DecimateWithBuckets) error {
	return nil
}

func (u *DecimateStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DecimateStrategy) Accept(v DecimateStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "resolution":
		if u.resolution == nil {
			return fmt.Errorf("field \"resolution\" is required")
		}
		return v.VisitResolution(*u.resolution)
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
		return v.VisitBuckets(*u.buckets)
	}
}

type DecimateStrategyVisitor interface {
	VisitResolution(v DecimateWithResolution) error
	VisitBuckets(v DecimateWithBuckets) error
	VisitUnknown(typeName string) error
}

func (u *DecimateStrategy) AcceptWithContext(ctx context.Context, v DecimateStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "resolution":
		if u.resolution == nil {
			return fmt.Errorf("field \"resolution\" is required")
		}
		return v.VisitResolutionWithContext(ctx, *u.resolution)
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
		return v.VisitBucketsWithContext(ctx, *u.buckets)
	}
}

type DecimateStrategyVisitorWithContext interface {
	VisitResolutionWithContext(ctx context.Context, v DecimateWithResolution) error
	VisitBucketsWithContext(ctx context.Context, v DecimateWithBuckets) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDecimateStrategyFromResolution(v DecimateWithResolution) DecimateStrategy {
	return DecimateStrategy{typ: "resolution", resolution: &v}
}

func NewDecimateStrategyFromBuckets(v DecimateWithBuckets) DecimateStrategy {
	return DecimateStrategy{typ: "buckets", buckets: &v}
}

type DoubleConstant struct {
	typ      string
	literal  *float64
	variable *VariableName
}

type doubleConstantDeserializer struct {
	Type     string        `json:"type"`
	Literal  *float64      `json:"literal"`
	Variable *VariableName `json:"variable"`
}

func (u *doubleConstantDeserializer) toStruct() DoubleConstant {
	return DoubleConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *DoubleConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Literal float64 `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Variable VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u DoubleConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DoubleConstant) UnmarshalJSON(data []byte) error {
	var deser doubleConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u DoubleConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DoubleConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DoubleConstant) AcceptFuncs(literalFunc func(float64) error, variableFunc func(VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *DoubleConstant) LiteralNoopSuccess(float64) error {
	return nil
}

func (u *DoubleConstant) VariableNoopSuccess(VariableName) error {
	return nil
}

func (u *DoubleConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DoubleConstant) Accept(v DoubleConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type DoubleConstantVisitor interface {
	VisitLiteral(v float64) error
	VisitVariable(v VariableName) error
	VisitUnknown(typeName string) error
}

func (u *DoubleConstant) AcceptWithContext(ctx context.Context, v DoubleConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type DoubleConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v float64) error
	VisitVariableWithContext(ctx context.Context, v VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDoubleConstantFromLiteral(v float64) DoubleConstant {
	return DoubleConstant{typ: "literal", literal: &v}
}

func NewDoubleConstantFromVariable(v VariableName) DoubleConstant {
	return DoubleConstant{typ: "variable", variable: &v}
}

type EnumResampleInterpolationConfiguration struct {
	typ                                           string
	forwardFillResampleInterpolationConfiguration *ForwardFillResampleInterpolationConfiguration
	constantResampleInterpolationConfiguration    *EnumConstantResampleInterpolationConfiguration
}

type enumResampleInterpolationConfigurationDeserializer struct {
	Type                                          string                                          `json:"type"`
	ForwardFillResampleInterpolationConfiguration *ForwardFillResampleInterpolationConfiguration  `json:"forwardFillResampleInterpolationConfiguration"`
	ConstantResampleInterpolationConfiguration    *EnumConstantResampleInterpolationConfiguration `json:"constantResampleInterpolationConfiguration"`
}

func (u *enumResampleInterpolationConfigurationDeserializer) toStruct() EnumResampleInterpolationConfiguration {
	return EnumResampleInterpolationConfiguration{typ: u.Type, forwardFillResampleInterpolationConfiguration: u.ForwardFillResampleInterpolationConfiguration, constantResampleInterpolationConfiguration: u.ConstantResampleInterpolationConfiguration}
}

func (u *EnumResampleInterpolationConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return nil, fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return struct {
			Type                                          string                                        `json:"type"`
			ForwardFillResampleInterpolationConfiguration ForwardFillResampleInterpolationConfiguration `json:"forwardFillResampleInterpolationConfiguration"`
		}{Type: "forwardFillResampleInterpolationConfiguration", ForwardFillResampleInterpolationConfiguration: *u.forwardFillResampleInterpolationConfiguration}, nil
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return nil, fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return struct {
			Type                                       string                                         `json:"type"`
			ConstantResampleInterpolationConfiguration EnumConstantResampleInterpolationConfiguration `json:"constantResampleInterpolationConfiguration"`
		}{Type: "constantResampleInterpolationConfiguration", ConstantResampleInterpolationConfiguration: *u.constantResampleInterpolationConfiguration}, nil
	}
}

func (u EnumResampleInterpolationConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumResampleInterpolationConfiguration) UnmarshalJSON(data []byte) error {
	var deser enumResampleInterpolationConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
	}
	return nil
}

func (u EnumResampleInterpolationConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumResampleInterpolationConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumResampleInterpolationConfiguration) AcceptFuncs(forwardFillResampleInterpolationConfigurationFunc func(ForwardFillResampleInterpolationConfiguration) error, constantResampleInterpolationConfigurationFunc func(EnumConstantResampleInterpolationConfiguration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return forwardFillResampleInterpolationConfigurationFunc(*u.forwardFillResampleInterpolationConfiguration)
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return constantResampleInterpolationConfigurationFunc(*u.constantResampleInterpolationConfiguration)
	}
}

func (u *EnumResampleInterpolationConfiguration) ForwardFillResampleInterpolationConfigurationNoopSuccess(ForwardFillResampleInterpolationConfiguration) error {
	return nil
}

func (u *EnumResampleInterpolationConfiguration) ConstantResampleInterpolationConfigurationNoopSuccess(EnumConstantResampleInterpolationConfiguration) error {
	return nil
}

func (u *EnumResampleInterpolationConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumResampleInterpolationConfiguration) Accept(v EnumResampleInterpolationConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return v.VisitForwardFillResampleInterpolationConfiguration(*u.forwardFillResampleInterpolationConfiguration)
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return v.VisitConstantResampleInterpolationConfiguration(*u.constantResampleInterpolationConfiguration)
	}
}

type EnumResampleInterpolationConfigurationVisitor interface {
	VisitForwardFillResampleInterpolationConfiguration(v ForwardFillResampleInterpolationConfiguration) error
	VisitConstantResampleInterpolationConfiguration(v EnumConstantResampleInterpolationConfiguration) error
	VisitUnknown(typeName string) error
}

func (u *EnumResampleInterpolationConfiguration) AcceptWithContext(ctx context.Context, v EnumResampleInterpolationConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return v.VisitForwardFillResampleInterpolationConfigurationWithContext(ctx, *u.forwardFillResampleInterpolationConfiguration)
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return v.VisitConstantResampleInterpolationConfigurationWithContext(ctx, *u.constantResampleInterpolationConfiguration)
	}
}

type EnumResampleInterpolationConfigurationVisitorWithContext interface {
	VisitForwardFillResampleInterpolationConfigurationWithContext(ctx context.Context, v ForwardFillResampleInterpolationConfiguration) error
	VisitConstantResampleInterpolationConfigurationWithContext(ctx context.Context, v EnumConstantResampleInterpolationConfiguration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumResampleInterpolationConfigurationFromForwardFillResampleInterpolationConfiguration(v ForwardFillResampleInterpolationConfiguration) EnumResampleInterpolationConfiguration {
	return EnumResampleInterpolationConfiguration{typ: "forwardFillResampleInterpolationConfiguration", forwardFillResampleInterpolationConfiguration: &v}
}

func NewEnumResampleInterpolationConfigurationFromConstantResampleInterpolationConfiguration(v EnumConstantResampleInterpolationConfiguration) EnumResampleInterpolationConfiguration {
	return EnumResampleInterpolationConfiguration{typ: "constantResampleInterpolationConfiguration", constantResampleInterpolationConfiguration: &v}
}

type EventsEnumValueSource struct {
	typ      string
	property *StringConstant
	level    *api.Empty
}

type eventsEnumValueSourceDeserializer struct {
	Type     string          `json:"type"`
	Property *StringConstant `json:"property"`
	Level    *api.Empty      `json:"level"`
}

func (u *eventsEnumValueSourceDeserializer) toStruct() EventsEnumValueSource {
	return EventsEnumValueSource{typ: u.Type, property: u.Property, level: u.Level}
}

func (u *EventsEnumValueSource) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			Property StringConstant `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "level":
		if u.level == nil {
			return nil, fmt.Errorf("field \"level\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Level api.Empty `json:"level"`
		}{Type: "level", Level: *u.level}, nil
	}
}

func (u EventsEnumValueSource) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EventsEnumValueSource) UnmarshalJSON(data []byte) error {
	var deser eventsEnumValueSourceDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "level":
		if u.level == nil {
			return fmt.Errorf("field \"level\" is required")
		}
	}
	return nil
}

func (u EventsEnumValueSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EventsEnumValueSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EventsEnumValueSource) AcceptFuncs(propertyFunc func(StringConstant) error, levelFunc func(api.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "level":
		if u.level == nil {
			return fmt.Errorf("field \"level\" is required")
		}
		return levelFunc(*u.level)
	}
}

func (u *EventsEnumValueSource) PropertyNoopSuccess(StringConstant) error {
	return nil
}

func (u *EventsEnumValueSource) LevelNoopSuccess(api.Empty) error {
	return nil
}

func (u *EventsEnumValueSource) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EventsEnumValueSource) Accept(v EventsEnumValueSourceVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "level":
		if u.level == nil {
			return fmt.Errorf("field \"level\" is required")
		}
		return v.VisitLevel(*u.level)
	}
}

type EventsEnumValueSourceVisitor interface {
	VisitProperty(v StringConstant) error
	VisitLevel(v api.Empty) error
	VisitUnknown(typeName string) error
}

func (u *EventsEnumValueSource) AcceptWithContext(ctx context.Context, v EventsEnumValueSourceVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "level":
		if u.level == nil {
			return fmt.Errorf("field \"level\" is required")
		}
		return v.VisitLevelWithContext(ctx, *u.level)
	}
}

type EventsEnumValueSourceVisitorWithContext interface {
	VisitPropertyWithContext(ctx context.Context, v StringConstant) error
	VisitLevelWithContext(ctx context.Context, v api.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEventsEnumValueSourceFromProperty(v StringConstant) EventsEnumValueSource {
	return EventsEnumValueSource{typ: "property", property: &v}
}

func NewEventsEnumValueSourceFromLevel(v api.Empty) EventsEnumValueSource {
	return EventsEnumValueSource{typ: "level", level: &v}
}

type FrequencyDomainPlotV2 struct {
	typ               string
	real              *FrequencyDomainPlot
	complex           *FrequencyDomainPlotComplex
	magnitudeAndPhase *FrequencyDomainPlotMagnitudeAndPhase
}

type frequencyDomainPlotV2Deserializer struct {
	Type              string                                `json:"type"`
	Real              *FrequencyDomainPlot                  `json:"real"`
	Complex           *FrequencyDomainPlotComplex           `json:"complex"`
	MagnitudeAndPhase *FrequencyDomainPlotMagnitudeAndPhase `json:"magnitudeAndPhase"`
}

func (u *frequencyDomainPlotV2Deserializer) toStruct() FrequencyDomainPlotV2 {
	return FrequencyDomainPlotV2{typ: u.Type, real: u.Real, complex: u.Complex, magnitudeAndPhase: u.MagnitudeAndPhase}
}

func (u *FrequencyDomainPlotV2) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "real":
		if u.real == nil {
			return nil, fmt.Errorf("field \"real\" is required")
		}
		return struct {
			Type string              `json:"type"`
			Real FrequencyDomainPlot `json:"real"`
		}{Type: "real", Real: *u.real}, nil
	case "complex":
		if u.complex == nil {
			return nil, fmt.Errorf("field \"complex\" is required")
		}
		return struct {
			Type    string                     `json:"type"`
			Complex FrequencyDomainPlotComplex `json:"complex"`
		}{Type: "complex", Complex: *u.complex}, nil
	case "magnitudeAndPhase":
		if u.magnitudeAndPhase == nil {
			return nil, fmt.Errorf("field \"magnitudeAndPhase\" is required")
		}
		return struct {
			Type              string                               `json:"type"`
			MagnitudeAndPhase FrequencyDomainPlotMagnitudeAndPhase `json:"magnitudeAndPhase"`
		}{Type: "magnitudeAndPhase", MagnitudeAndPhase: *u.magnitudeAndPhase}, nil
	}
}

func (u FrequencyDomainPlotV2) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FrequencyDomainPlotV2) UnmarshalJSON(data []byte) error {
	var deser frequencyDomainPlotV2Deserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "real":
		if u.real == nil {
			return fmt.Errorf("field \"real\" is required")
		}
	case "complex":
		if u.complex == nil {
			return fmt.Errorf("field \"complex\" is required")
		}
	case "magnitudeAndPhase":
		if u.magnitudeAndPhase == nil {
			return fmt.Errorf("field \"magnitudeAndPhase\" is required")
		}
	}
	return nil
}

func (u FrequencyDomainPlotV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FrequencyDomainPlotV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FrequencyDomainPlotV2) AcceptFuncs(realFunc func(FrequencyDomainPlot) error, complexFunc func(FrequencyDomainPlotComplex) error, magnitudeAndPhaseFunc func(FrequencyDomainPlotMagnitudeAndPhase) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "real":
		if u.real == nil {
			return fmt.Errorf("field \"real\" is required")
		}
		return realFunc(*u.real)
	case "complex":
		if u.complex == nil {
			return fmt.Errorf("field \"complex\" is required")
		}
		return complexFunc(*u.complex)
	case "magnitudeAndPhase":
		if u.magnitudeAndPhase == nil {
			return fmt.Errorf("field \"magnitudeAndPhase\" is required")
		}
		return magnitudeAndPhaseFunc(*u.magnitudeAndPhase)
	}
}

func (u *FrequencyDomainPlotV2) RealNoopSuccess(FrequencyDomainPlot) error {
	return nil
}

func (u *FrequencyDomainPlotV2) ComplexNoopSuccess(FrequencyDomainPlotComplex) error {
	return nil
}

func (u *FrequencyDomainPlotV2) MagnitudeAndPhaseNoopSuccess(FrequencyDomainPlotMagnitudeAndPhase) error {
	return nil
}

func (u *FrequencyDomainPlotV2) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FrequencyDomainPlotV2) Accept(v FrequencyDomainPlotV2Visitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "real":
		if u.real == nil {
			return fmt.Errorf("field \"real\" is required")
		}
		return v.VisitReal(*u.real)
	case "complex":
		if u.complex == nil {
			return fmt.Errorf("field \"complex\" is required")
		}
		return v.VisitComplex(*u.complex)
	case "magnitudeAndPhase":
		if u.magnitudeAndPhase == nil {
			return fmt.Errorf("field \"magnitudeAndPhase\" is required")
		}
		return v.VisitMagnitudeAndPhase(*u.magnitudeAndPhase)
	}
}

type FrequencyDomainPlotV2Visitor interface {
	VisitReal(v FrequencyDomainPlot) error
	VisitComplex(v FrequencyDomainPlotComplex) error
	VisitMagnitudeAndPhase(v FrequencyDomainPlotMagnitudeAndPhase) error
	VisitUnknown(typeName string) error
}

func (u *FrequencyDomainPlotV2) AcceptWithContext(ctx context.Context, v FrequencyDomainPlotV2VisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "real":
		if u.real == nil {
			return fmt.Errorf("field \"real\" is required")
		}
		return v.VisitRealWithContext(ctx, *u.real)
	case "complex":
		if u.complex == nil {
			return fmt.Errorf("field \"complex\" is required")
		}
		return v.VisitComplexWithContext(ctx, *u.complex)
	case "magnitudeAndPhase":
		if u.magnitudeAndPhase == nil {
			return fmt.Errorf("field \"magnitudeAndPhase\" is required")
		}
		return v.VisitMagnitudeAndPhaseWithContext(ctx, *u.magnitudeAndPhase)
	}
}

type FrequencyDomainPlotV2VisitorWithContext interface {
	VisitRealWithContext(ctx context.Context, v FrequencyDomainPlot) error
	VisitComplexWithContext(ctx context.Context, v FrequencyDomainPlotComplex) error
	VisitMagnitudeAndPhaseWithContext(ctx context.Context, v FrequencyDomainPlotMagnitudeAndPhase) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFrequencyDomainPlotV2FromReal(v FrequencyDomainPlot) FrequencyDomainPlotV2 {
	return FrequencyDomainPlotV2{typ: "real", real: &v}
}

func NewFrequencyDomainPlotV2FromComplex(v FrequencyDomainPlotComplex) FrequencyDomainPlotV2 {
	return FrequencyDomainPlotV2{typ: "complex", complex: &v}
}

func NewFrequencyDomainPlotV2FromMagnitudeAndPhase(v FrequencyDomainPlotMagnitudeAndPhase) FrequencyDomainPlotV2 {
	return FrequencyDomainPlotV2{typ: "magnitudeAndPhase", magnitudeAndPhase: &v}
}

type Grouping struct {
	typ            string
	tagsWithValues *map[string]string
}

type groupingDeserializer struct {
	Type           string             `json:"type"`
	TagsWithValues *map[string]string `json:"tagsWithValues"`
}

func (u *groupingDeserializer) toStruct() Grouping {
	return Grouping{typ: u.Type, tagsWithValues: u.TagsWithValues}
}

func (u *Grouping) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return nil, fmt.Errorf("field \"tagsWithValues\" is required")
		}
		return struct {
			Type           string            `json:"type"`
			TagsWithValues map[string]string `json:"tagsWithValues"`
		}{Type: "tagsWithValues", TagsWithValues: *u.tagsWithValues}, nil
	}
}

func (u Grouping) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Grouping) UnmarshalJSON(data []byte) error {
	var deser groupingDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return fmt.Errorf("field \"tagsWithValues\" is required")
		}
	}
	return nil
}

func (u Grouping) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Grouping) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Grouping) AcceptFuncs(tagsWithValuesFunc func(map[string]string) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return fmt.Errorf("field \"tagsWithValues\" is required")
		}
		return tagsWithValuesFunc(*u.tagsWithValues)
	}
}

func (u *Grouping) TagsWithValuesNoopSuccess(map[string]string) error {
	return nil
}

func (u *Grouping) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Grouping) Accept(v GroupingVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return fmt.Errorf("field \"tagsWithValues\" is required")
		}
		return v.VisitTagsWithValues(*u.tagsWithValues)
	}
}

type GroupingVisitor interface {
	VisitTagsWithValues(v map[string]string) error
	VisitUnknown(typeName string) error
}

func (u *Grouping) AcceptWithContext(ctx context.Context, v GroupingVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return fmt.Errorf("field \"tagsWithValues\" is required")
		}
		return v.VisitTagsWithValuesWithContext(ctx, *u.tagsWithValues)
	}
}

type GroupingVisitorWithContext interface {
	VisitTagsWithValuesWithContext(ctx context.Context, v map[string]string) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGroupingFromTagsWithValues(v map[string]string) Grouping {
	return Grouping{typ: "tagsWithValues", tagsWithValues: &v}
}

type IntegerConstant struct {
	typ      string
	literal  *int
	variable *VariableName
}

type integerConstantDeserializer struct {
	Type     string        `json:"type"`
	Literal  *int          `json:"literal"`
	Variable *VariableName `json:"variable"`
}

func (u *integerConstantDeserializer) toStruct() IntegerConstant {
	return IntegerConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *IntegerConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string `json:"type"`
			Literal int    `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Variable VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u IntegerConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *IntegerConstant) UnmarshalJSON(data []byte) error {
	var deser integerConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u IntegerConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *IntegerConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *IntegerConstant) AcceptFuncs(literalFunc func(int) error, variableFunc func(VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *IntegerConstant) LiteralNoopSuccess(int) error {
	return nil
}

func (u *IntegerConstant) VariableNoopSuccess(VariableName) error {
	return nil
}

func (u *IntegerConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *IntegerConstant) Accept(v IntegerConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type IntegerConstantVisitor interface {
	VisitLiteral(v int) error
	VisitVariable(v VariableName) error
	VisitUnknown(typeName string) error
}

func (u *IntegerConstant) AcceptWithContext(ctx context.Context, v IntegerConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type IntegerConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v int) error
	VisitVariableWithContext(ctx context.Context, v VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewIntegerConstantFromLiteral(v int) IntegerConstant {
	return IntegerConstant{typ: "literal", literal: &v}
}

func NewIntegerConstantFromVariable(v VariableName) IntegerConstant {
	return IntegerConstant{typ: "variable", variable: &v}
}

type LogFilterOperator struct {
	typ                             string
	regexFilter                     *LogRegexFilterOperator
	exactMatchCaseInsensitiveFilter *LogExactMatchCaseInsensitiveFilter
}

type logFilterOperatorDeserializer struct {
	Type                            string                              `json:"type"`
	RegexFilter                     *LogRegexFilterOperator             `json:"regexFilter"`
	ExactMatchCaseInsensitiveFilter *LogExactMatchCaseInsensitiveFilter `json:"exactMatchCaseInsensitiveFilter"`
}

func (u *logFilterOperatorDeserializer) toStruct() LogFilterOperator {
	return LogFilterOperator{typ: u.Type, regexFilter: u.RegexFilter, exactMatchCaseInsensitiveFilter: u.ExactMatchCaseInsensitiveFilter}
}

func (u *LogFilterOperator) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "regexFilter":
		if u.regexFilter == nil {
			return nil, fmt.Errorf("field \"regexFilter\" is required")
		}
		return struct {
			Type        string                 `json:"type"`
			RegexFilter LogRegexFilterOperator `json:"regexFilter"`
		}{Type: "regexFilter", RegexFilter: *u.regexFilter}, nil
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return nil, fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
		return struct {
			Type                            string                             `json:"type"`
			ExactMatchCaseInsensitiveFilter LogExactMatchCaseInsensitiveFilter `json:"exactMatchCaseInsensitiveFilter"`
		}{Type: "exactMatchCaseInsensitiveFilter", ExactMatchCaseInsensitiveFilter: *u.exactMatchCaseInsensitiveFilter}, nil
	}
}

func (u LogFilterOperator) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LogFilterOperator) UnmarshalJSON(data []byte) error {
	var deser logFilterOperatorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "regexFilter":
		if u.regexFilter == nil {
			return fmt.Errorf("field \"regexFilter\" is required")
		}
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
	}
	return nil
}

func (u LogFilterOperator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LogFilterOperator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LogFilterOperator) AcceptFuncs(regexFilterFunc func(LogRegexFilterOperator) error, exactMatchCaseInsensitiveFilterFunc func(LogExactMatchCaseInsensitiveFilter) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "regexFilter":
		if u.regexFilter == nil {
			return fmt.Errorf("field \"regexFilter\" is required")
		}
		return regexFilterFunc(*u.regexFilter)
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
		return exactMatchCaseInsensitiveFilterFunc(*u.exactMatchCaseInsensitiveFilter)
	}
}

func (u *LogFilterOperator) RegexFilterNoopSuccess(LogRegexFilterOperator) error {
	return nil
}

func (u *LogFilterOperator) ExactMatchCaseInsensitiveFilterNoopSuccess(LogExactMatchCaseInsensitiveFilter) error {
	return nil
}

func (u *LogFilterOperator) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LogFilterOperator) Accept(v LogFilterOperatorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "regexFilter":
		if u.regexFilter == nil {
			return fmt.Errorf("field \"regexFilter\" is required")
		}
		return v.VisitRegexFilter(*u.regexFilter)
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
		return v.VisitExactMatchCaseInsensitiveFilter(*u.exactMatchCaseInsensitiveFilter)
	}
}

type LogFilterOperatorVisitor interface {
	VisitRegexFilter(v LogRegexFilterOperator) error
	VisitExactMatchCaseInsensitiveFilter(v LogExactMatchCaseInsensitiveFilter) error
	VisitUnknown(typeName string) error
}

func (u *LogFilterOperator) AcceptWithContext(ctx context.Context, v LogFilterOperatorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "regexFilter":
		if u.regexFilter == nil {
			return fmt.Errorf("field \"regexFilter\" is required")
		}
		return v.VisitRegexFilterWithContext(ctx, *u.regexFilter)
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
		return v.VisitExactMatchCaseInsensitiveFilterWithContext(ctx, *u.exactMatchCaseInsensitiveFilter)
	}
}

type LogFilterOperatorVisitorWithContext interface {
	VisitRegexFilterWithContext(ctx context.Context, v LogRegexFilterOperator) error
	VisitExactMatchCaseInsensitiveFilterWithContext(ctx context.Context, v LogExactMatchCaseInsensitiveFilter) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLogFilterOperatorFromRegexFilter(v LogRegexFilterOperator) LogFilterOperator {
	return LogFilterOperator{typ: "regexFilter", regexFilter: &v}
}

func NewLogFilterOperatorFromExactMatchCaseInsensitiveFilter(v LogExactMatchCaseInsensitiveFilter) LogFilterOperator {
	return LogFilterOperator{typ: "exactMatchCaseInsensitiveFilter", exactMatchCaseInsensitiveFilter: &v}
}

type ModuleVersionReference struct {
	typ    string
	pinned *PinnedModuleVersionReference
}

type moduleVersionReferenceDeserializer struct {
	Type   string                        `json:"type"`
	Pinned *PinnedModuleVersionReference `json:"pinned"`
}

func (u *moduleVersionReferenceDeserializer) toStruct() ModuleVersionReference {
	return ModuleVersionReference{typ: u.Type, pinned: u.Pinned}
}

func (u *ModuleVersionReference) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "pinned":
		if u.pinned == nil {
			return nil, fmt.Errorf("field \"pinned\" is required")
		}
		return struct {
			Type   string                       `json:"type"`
			Pinned PinnedModuleVersionReference `json:"pinned"`
		}{Type: "pinned", Pinned: *u.pinned}, nil
	}
}

func (u ModuleVersionReference) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ModuleVersionReference) UnmarshalJSON(data []byte) error {
	var deser moduleVersionReferenceDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "pinned":
		if u.pinned == nil {
			return fmt.Errorf("field \"pinned\" is required")
		}
	}
	return nil
}

func (u ModuleVersionReference) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ModuleVersionReference) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ModuleVersionReference) AcceptFuncs(pinnedFunc func(PinnedModuleVersionReference) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pinned":
		if u.pinned == nil {
			return fmt.Errorf("field \"pinned\" is required")
		}
		return pinnedFunc(*u.pinned)
	}
}

func (u *ModuleVersionReference) PinnedNoopSuccess(PinnedModuleVersionReference) error {
	return nil
}

func (u *ModuleVersionReference) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ModuleVersionReference) Accept(v ModuleVersionReferenceVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "pinned":
		if u.pinned == nil {
			return fmt.Errorf("field \"pinned\" is required")
		}
		return v.VisitPinned(*u.pinned)
	}
}

type ModuleVersionReferenceVisitor interface {
	VisitPinned(v PinnedModuleVersionReference) error
	VisitUnknown(typeName string) error
}

func (u *ModuleVersionReference) AcceptWithContext(ctx context.Context, v ModuleVersionReferenceVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "pinned":
		if u.pinned == nil {
			return fmt.Errorf("field \"pinned\" is required")
		}
		return v.VisitPinnedWithContext(ctx, *u.pinned)
	}
}

type ModuleVersionReferenceVisitorWithContext interface {
	VisitPinnedWithContext(ctx context.Context, v PinnedModuleVersionReference) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewModuleVersionReferenceFromPinned(v PinnedModuleVersionReference) ModuleVersionReference {
	return ModuleVersionReference{typ: "pinned", pinned: &v}
}

type NegativeValueConfiguration struct {
	typ                     string
	allowNegativeValues     *AllowNegativeValues
	setNegativeValuesToZero *SetNegativeValuesToZero
	excludeNegativeValues   *ExcludeNegativeValues
}

type negativeValueConfigurationDeserializer struct {
	Type                    string                   `json:"type"`
	AllowNegativeValues     *AllowNegativeValues     `json:"allowNegativeValues"`
	SetNegativeValuesToZero *SetNegativeValuesToZero `json:"setNegativeValuesToZero"`
	ExcludeNegativeValues   *ExcludeNegativeValues   `json:"excludeNegativeValues"`
}

func (u *negativeValueConfigurationDeserializer) toStruct() NegativeValueConfiguration {
	return NegativeValueConfiguration{typ: u.Type, allowNegativeValues: u.AllowNegativeValues, setNegativeValuesToZero: u.SetNegativeValuesToZero, excludeNegativeValues: u.ExcludeNegativeValues}
}

func (u *NegativeValueConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return nil, fmt.Errorf("field \"allowNegativeValues\" is required")
		}
		return struct {
			Type                string              `json:"type"`
			AllowNegativeValues AllowNegativeValues `json:"allowNegativeValues"`
		}{Type: "allowNegativeValues", AllowNegativeValues: *u.allowNegativeValues}, nil
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return nil, fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
		return struct {
			Type                    string                  `json:"type"`
			SetNegativeValuesToZero SetNegativeValuesToZero `json:"setNegativeValuesToZero"`
		}{Type: "setNegativeValuesToZero", SetNegativeValuesToZero: *u.setNegativeValuesToZero}, nil
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return nil, fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
		return struct {
			Type                  string                `json:"type"`
			ExcludeNegativeValues ExcludeNegativeValues `json:"excludeNegativeValues"`
		}{Type: "excludeNegativeValues", ExcludeNegativeValues: *u.excludeNegativeValues}, nil
	}
}

func (u NegativeValueConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NegativeValueConfiguration) UnmarshalJSON(data []byte) error {
	var deser negativeValueConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return fmt.Errorf("field \"allowNegativeValues\" is required")
		}
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
	}
	return nil
}

func (u NegativeValueConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NegativeValueConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NegativeValueConfiguration) AcceptFuncs(allowNegativeValuesFunc func(AllowNegativeValues) error, setNegativeValuesToZeroFunc func(SetNegativeValuesToZero) error, excludeNegativeValuesFunc func(ExcludeNegativeValues) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return fmt.Errorf("field \"allowNegativeValues\" is required")
		}
		return allowNegativeValuesFunc(*u.allowNegativeValues)
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
		return setNegativeValuesToZeroFunc(*u.setNegativeValuesToZero)
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
		return excludeNegativeValuesFunc(*u.excludeNegativeValues)
	}
}

func (u *NegativeValueConfiguration) AllowNegativeValuesNoopSuccess(AllowNegativeValues) error {
	return nil
}

func (u *NegativeValueConfiguration) SetNegativeValuesToZeroNoopSuccess(SetNegativeValuesToZero) error {
	return nil
}

func (u *NegativeValueConfiguration) ExcludeNegativeValuesNoopSuccess(ExcludeNegativeValues) error {
	return nil
}

func (u *NegativeValueConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NegativeValueConfiguration) Accept(v NegativeValueConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return fmt.Errorf("field \"allowNegativeValues\" is required")
		}
		return v.VisitAllowNegativeValues(*u.allowNegativeValues)
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
		return v.VisitSetNegativeValuesToZero(*u.setNegativeValuesToZero)
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
		return v.VisitExcludeNegativeValues(*u.excludeNegativeValues)
	}
}

type NegativeValueConfigurationVisitor interface {
	VisitAllowNegativeValues(v AllowNegativeValues) error
	VisitSetNegativeValuesToZero(v SetNegativeValuesToZero) error
	VisitExcludeNegativeValues(v ExcludeNegativeValues) error
	VisitUnknown(typeName string) error
}

func (u *NegativeValueConfiguration) AcceptWithContext(ctx context.Context, v NegativeValueConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return fmt.Errorf("field \"allowNegativeValues\" is required")
		}
		return v.VisitAllowNegativeValuesWithContext(ctx, *u.allowNegativeValues)
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
		return v.VisitSetNegativeValuesToZeroWithContext(ctx, *u.setNegativeValuesToZero)
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
		return v.VisitExcludeNegativeValuesWithContext(ctx, *u.excludeNegativeValues)
	}
}

type NegativeValueConfigurationVisitorWithContext interface {
	VisitAllowNegativeValuesWithContext(ctx context.Context, v AllowNegativeValues) error
	VisitSetNegativeValuesToZeroWithContext(ctx context.Context, v SetNegativeValuesToZero) error
	VisitExcludeNegativeValuesWithContext(ctx context.Context, v ExcludeNegativeValues) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNegativeValueConfigurationFromAllowNegativeValues(v AllowNegativeValues) NegativeValueConfiguration {
	return NegativeValueConfiguration{typ: "allowNegativeValues", allowNegativeValues: &v}
}

func NewNegativeValueConfigurationFromSetNegativeValuesToZero(v SetNegativeValuesToZero) NegativeValueConfiguration {
	return NegativeValueConfiguration{typ: "setNegativeValuesToZero", setNegativeValuesToZero: &v}
}

func NewNegativeValueConfigurationFromExcludeNegativeValues(v ExcludeNegativeValues) NegativeValueConfiguration {
	return NegativeValueConfiguration{typ: "excludeNegativeValues", excludeNegativeValues: &v}
}

type NumericHistogramBucketStrategy struct {
	typ                  string
	bucketCount          *IntegerConstant
	bucketWidthAndOffset *NumericHistogramBucketWidthAndOffset
}

type numericHistogramBucketStrategyDeserializer struct {
	Type                 string                                `json:"type"`
	BucketCount          *IntegerConstant                      `json:"bucketCount"`
	BucketWidthAndOffset *NumericHistogramBucketWidthAndOffset `json:"bucketWidthAndOffset"`
}

func (u *numericHistogramBucketStrategyDeserializer) toStruct() NumericHistogramBucketStrategy {
	return NumericHistogramBucketStrategy{typ: u.Type, bucketCount: u.BucketCount, bucketWidthAndOffset: u.BucketWidthAndOffset}
}

func (u *NumericHistogramBucketStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return nil, fmt.Errorf("field \"bucketCount\" is required")
		}
		return struct {
			Type        string          `json:"type"`
			BucketCount IntegerConstant `json:"bucketCount"`
		}{Type: "bucketCount", BucketCount: *u.bucketCount}, nil
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return nil, fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return struct {
			Type                 string                               `json:"type"`
			BucketWidthAndOffset NumericHistogramBucketWidthAndOffset `json:"bucketWidthAndOffset"`
		}{Type: "bucketWidthAndOffset", BucketWidthAndOffset: *u.bucketWidthAndOffset}, nil
	}
}

func (u NumericHistogramBucketStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericHistogramBucketStrategy) UnmarshalJSON(data []byte) error {
	var deser numericHistogramBucketStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
	}
	return nil
}

func (u NumericHistogramBucketStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericHistogramBucketStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericHistogramBucketStrategy) AcceptFuncs(bucketCountFunc func(IntegerConstant) error, bucketWidthAndOffsetFunc func(NumericHistogramBucketWidthAndOffset) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
		return bucketCountFunc(*u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return bucketWidthAndOffsetFunc(*u.bucketWidthAndOffset)
	}
}

func (u *NumericHistogramBucketStrategy) BucketCountNoopSuccess(IntegerConstant) error {
	return nil
}

func (u *NumericHistogramBucketStrategy) BucketWidthAndOffsetNoopSuccess(NumericHistogramBucketWidthAndOffset) error {
	return nil
}

func (u *NumericHistogramBucketStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericHistogramBucketStrategy) Accept(v NumericHistogramBucketStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
		return v.VisitBucketCount(*u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return v.VisitBucketWidthAndOffset(*u.bucketWidthAndOffset)
	}
}

type NumericHistogramBucketStrategyVisitor interface {
	VisitBucketCount(v IntegerConstant) error
	VisitBucketWidthAndOffset(v NumericHistogramBucketWidthAndOffset) error
	VisitUnknown(typeName string) error
}

func (u *NumericHistogramBucketStrategy) AcceptWithContext(ctx context.Context, v NumericHistogramBucketStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
		return v.VisitBucketCountWithContext(ctx, *u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return v.VisitBucketWidthAndOffsetWithContext(ctx, *u.bucketWidthAndOffset)
	}
}

type NumericHistogramBucketStrategyVisitorWithContext interface {
	VisitBucketCountWithContext(ctx context.Context, v IntegerConstant) error
	VisitBucketWidthAndOffsetWithContext(ctx context.Context, v NumericHistogramBucketWidthAndOffset) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericHistogramBucketStrategyFromBucketCount(v IntegerConstant) NumericHistogramBucketStrategy {
	return NumericHistogramBucketStrategy{typ: "bucketCount", bucketCount: &v}
}

func NewNumericHistogramBucketStrategyFromBucketWidthAndOffset(v NumericHistogramBucketWidthAndOffset) NumericHistogramBucketStrategy {
	return NumericHistogramBucketStrategy{typ: "bucketWidthAndOffset", bucketWidthAndOffset: &v}
}

type NumericResampleInterpolationConfiguration struct {
	typ                                           string
	forwardFillResampleInterpolationConfiguration *ForwardFillResampleInterpolationConfiguration
	constantResampleInterpolationConfiguration    *NumericConstantResampleInterpolationConfiguration
}

type numericResampleInterpolationConfigurationDeserializer struct {
	Type                                          string                                             `json:"type"`
	ForwardFillResampleInterpolationConfiguration *ForwardFillResampleInterpolationConfiguration     `json:"forwardFillResampleInterpolationConfiguration"`
	ConstantResampleInterpolationConfiguration    *NumericConstantResampleInterpolationConfiguration `json:"constantResampleInterpolationConfiguration"`
}

func (u *numericResampleInterpolationConfigurationDeserializer) toStruct() NumericResampleInterpolationConfiguration {
	return NumericResampleInterpolationConfiguration{typ: u.Type, forwardFillResampleInterpolationConfiguration: u.ForwardFillResampleInterpolationConfiguration, constantResampleInterpolationConfiguration: u.ConstantResampleInterpolationConfiguration}
}

func (u *NumericResampleInterpolationConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return nil, fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return struct {
			Type                                          string                                        `json:"type"`
			ForwardFillResampleInterpolationConfiguration ForwardFillResampleInterpolationConfiguration `json:"forwardFillResampleInterpolationConfiguration"`
		}{Type: "forwardFillResampleInterpolationConfiguration", ForwardFillResampleInterpolationConfiguration: *u.forwardFillResampleInterpolationConfiguration}, nil
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return nil, fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return struct {
			Type                                       string                                            `json:"type"`
			ConstantResampleInterpolationConfiguration NumericConstantResampleInterpolationConfiguration `json:"constantResampleInterpolationConfiguration"`
		}{Type: "constantResampleInterpolationConfiguration", ConstantResampleInterpolationConfiguration: *u.constantResampleInterpolationConfiguration}, nil
	}
}

func (u NumericResampleInterpolationConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericResampleInterpolationConfiguration) UnmarshalJSON(data []byte) error {
	var deser numericResampleInterpolationConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
	}
	return nil
}

func (u NumericResampleInterpolationConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericResampleInterpolationConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericResampleInterpolationConfiguration) AcceptFuncs(forwardFillResampleInterpolationConfigurationFunc func(ForwardFillResampleInterpolationConfiguration) error, constantResampleInterpolationConfigurationFunc func(NumericConstantResampleInterpolationConfiguration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return forwardFillResampleInterpolationConfigurationFunc(*u.forwardFillResampleInterpolationConfiguration)
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return constantResampleInterpolationConfigurationFunc(*u.constantResampleInterpolationConfiguration)
	}
}

func (u *NumericResampleInterpolationConfiguration) ForwardFillResampleInterpolationConfigurationNoopSuccess(ForwardFillResampleInterpolationConfiguration) error {
	return nil
}

func (u *NumericResampleInterpolationConfiguration) ConstantResampleInterpolationConfigurationNoopSuccess(NumericConstantResampleInterpolationConfiguration) error {
	return nil
}

func (u *NumericResampleInterpolationConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericResampleInterpolationConfiguration) Accept(v NumericResampleInterpolationConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return v.VisitForwardFillResampleInterpolationConfiguration(*u.forwardFillResampleInterpolationConfiguration)
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return v.VisitConstantResampleInterpolationConfiguration(*u.constantResampleInterpolationConfiguration)
	}
}

type NumericResampleInterpolationConfigurationVisitor interface {
	VisitForwardFillResampleInterpolationConfiguration(v ForwardFillResampleInterpolationConfiguration) error
	VisitConstantResampleInterpolationConfiguration(v NumericConstantResampleInterpolationConfiguration) error
	VisitUnknown(typeName string) error
}

func (u *NumericResampleInterpolationConfiguration) AcceptWithContext(ctx context.Context, v NumericResampleInterpolationConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return v.VisitForwardFillResampleInterpolationConfigurationWithContext(ctx, *u.forwardFillResampleInterpolationConfiguration)
	case "constantResampleInterpolationConfiguration":
		if u.constantResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"constantResampleInterpolationConfiguration\" is required")
		}
		return v.VisitConstantResampleInterpolationConfigurationWithContext(ctx, *u.constantResampleInterpolationConfiguration)
	}
}

type NumericResampleInterpolationConfigurationVisitorWithContext interface {
	VisitForwardFillResampleInterpolationConfigurationWithContext(ctx context.Context, v ForwardFillResampleInterpolationConfiguration) error
	VisitConstantResampleInterpolationConfigurationWithContext(ctx context.Context, v NumericConstantResampleInterpolationConfiguration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericResampleInterpolationConfigurationFromForwardFillResampleInterpolationConfiguration(v ForwardFillResampleInterpolationConfiguration) NumericResampleInterpolationConfiguration {
	return NumericResampleInterpolationConfiguration{typ: "forwardFillResampleInterpolationConfiguration", forwardFillResampleInterpolationConfiguration: &v}
}

func NewNumericResampleInterpolationConfigurationFromConstantResampleInterpolationConfiguration(v NumericConstantResampleInterpolationConfiguration) NumericResampleInterpolationConfiguration {
	return NumericResampleInterpolationConfiguration{typ: "constantResampleInterpolationConfiguration", constantResampleInterpolationConfiguration: &v}
}

type OutputRangeStart struct {
	typ                         string
	firstPointMatchingCondition *FirstPointMatchingCondition
	afterPersistenceWindow      *AfterPersistenceWindow
}

type outputRangeStartDeserializer struct {
	Type                        string                       `json:"type"`
	FirstPointMatchingCondition *FirstPointMatchingCondition `json:"firstPointMatchingCondition"`
	AfterPersistenceWindow      *AfterPersistenceWindow      `json:"afterPersistenceWindow"`
}

func (u *outputRangeStartDeserializer) toStruct() OutputRangeStart {
	return OutputRangeStart{typ: u.Type, firstPointMatchingCondition: u.FirstPointMatchingCondition, afterPersistenceWindow: u.AfterPersistenceWindow}
}

func (u *OutputRangeStart) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return nil, fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
		return struct {
			Type                        string                      `json:"type"`
			FirstPointMatchingCondition FirstPointMatchingCondition `json:"firstPointMatchingCondition"`
		}{Type: "firstPointMatchingCondition", FirstPointMatchingCondition: *u.firstPointMatchingCondition}, nil
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return nil, fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
		return struct {
			Type                   string                 `json:"type"`
			AfterPersistenceWindow AfterPersistenceWindow `json:"afterPersistenceWindow"`
		}{Type: "afterPersistenceWindow", AfterPersistenceWindow: *u.afterPersistenceWindow}, nil
	}
}

func (u OutputRangeStart) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *OutputRangeStart) UnmarshalJSON(data []byte) error {
	var deser outputRangeStartDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
	}
	return nil
}

func (u OutputRangeStart) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *OutputRangeStart) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *OutputRangeStart) AcceptFuncs(firstPointMatchingConditionFunc func(FirstPointMatchingCondition) error, afterPersistenceWindowFunc func(AfterPersistenceWindow) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
		return firstPointMatchingConditionFunc(*u.firstPointMatchingCondition)
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
		return afterPersistenceWindowFunc(*u.afterPersistenceWindow)
	}
}

func (u *OutputRangeStart) FirstPointMatchingConditionNoopSuccess(FirstPointMatchingCondition) error {
	return nil
}

func (u *OutputRangeStart) AfterPersistenceWindowNoopSuccess(AfterPersistenceWindow) error {
	return nil
}

func (u *OutputRangeStart) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *OutputRangeStart) Accept(v OutputRangeStartVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
		return v.VisitFirstPointMatchingCondition(*u.firstPointMatchingCondition)
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
		return v.VisitAfterPersistenceWindow(*u.afterPersistenceWindow)
	}
}

type OutputRangeStartVisitor interface {
	VisitFirstPointMatchingCondition(v FirstPointMatchingCondition) error
	VisitAfterPersistenceWindow(v AfterPersistenceWindow) error
	VisitUnknown(typeName string) error
}

func (u *OutputRangeStart) AcceptWithContext(ctx context.Context, v OutputRangeStartVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
		return v.VisitFirstPointMatchingConditionWithContext(ctx, *u.firstPointMatchingCondition)
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
		return v.VisitAfterPersistenceWindowWithContext(ctx, *u.afterPersistenceWindow)
	}
}

type OutputRangeStartVisitorWithContext interface {
	VisitFirstPointMatchingConditionWithContext(ctx context.Context, v FirstPointMatchingCondition) error
	VisitAfterPersistenceWindowWithContext(ctx context.Context, v AfterPersistenceWindow) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewOutputRangeStartFromFirstPointMatchingCondition(v FirstPointMatchingCondition) OutputRangeStart {
	return OutputRangeStart{typ: "firstPointMatchingCondition", firstPointMatchingCondition: &v}
}

func NewOutputRangeStartFromAfterPersistenceWindow(v AfterPersistenceWindow) OutputRangeStart {
	return OutputRangeStart{typ: "afterPersistenceWindow", afterPersistenceWindow: &v}
}

type PageStrategy struct {
	typ      string
	pageInfo *PageInfo
}

type pageStrategyDeserializer struct {
	Type     string    `json:"type"`
	PageInfo *PageInfo `json:"pageInfo"`
}

func (u *pageStrategyDeserializer) toStruct() PageStrategy {
	return PageStrategy{typ: u.Type, pageInfo: u.PageInfo}
}

func (u *PageStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "pageInfo":
		if u.pageInfo == nil {
			return nil, fmt.Errorf("field \"pageInfo\" is required")
		}
		return struct {
			Type     string   `json:"type"`
			PageInfo PageInfo `json:"pageInfo"`
		}{Type: "pageInfo", PageInfo: *u.pageInfo}, nil
	}
}

func (u PageStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PageStrategy) UnmarshalJSON(data []byte) error {
	var deser pageStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "pageInfo":
		if u.pageInfo == nil {
			return fmt.Errorf("field \"pageInfo\" is required")
		}
	}
	return nil
}

func (u PageStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PageStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PageStrategy) AcceptFuncs(pageInfoFunc func(PageInfo) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pageInfo":
		if u.pageInfo == nil {
			return fmt.Errorf("field \"pageInfo\" is required")
		}
		return pageInfoFunc(*u.pageInfo)
	}
}

func (u *PageStrategy) PageInfoNoopSuccess(PageInfo) error {
	return nil
}

func (u *PageStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PageStrategy) Accept(v PageStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "pageInfo":
		if u.pageInfo == nil {
			return fmt.Errorf("field \"pageInfo\" is required")
		}
		return v.VisitPageInfo(*u.pageInfo)
	}
}

type PageStrategyVisitor interface {
	VisitPageInfo(v PageInfo) error
	VisitUnknown(typeName string) error
}

func (u *PageStrategy) AcceptWithContext(ctx context.Context, v PageStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "pageInfo":
		if u.pageInfo == nil {
			return fmt.Errorf("field \"pageInfo\" is required")
		}
		return v.VisitPageInfoWithContext(ctx, *u.pageInfo)
	}
}

type PageStrategyVisitorWithContext interface {
	VisitPageInfoWithContext(ctx context.Context, v PageInfo) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPageStrategyFromPageInfo(v PageInfo) PageStrategy {
	return PageStrategy{typ: "pageInfo", pageInfo: &v}
}

type PageToken struct {
	typ            string
	timestampAndId *TimestampAndId
}

type pageTokenDeserializer struct {
	Type           string          `json:"type"`
	TimestampAndId *TimestampAndId `json:"timestampAndId"`
}

func (u *pageTokenDeserializer) toStruct() PageToken {
	return PageToken{typ: u.Type, timestampAndId: u.TimestampAndId}
}

func (u *PageToken) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timestampAndId":
		if u.timestampAndId == nil {
			return nil, fmt.Errorf("field \"timestampAndId\" is required")
		}
		return struct {
			Type           string         `json:"type"`
			TimestampAndId TimestampAndId `json:"timestampAndId"`
		}{Type: "timestampAndId", TimestampAndId: *u.timestampAndId}, nil
	}
}

func (u PageToken) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PageToken) UnmarshalJSON(data []byte) error {
	var deser pageTokenDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timestampAndId":
		if u.timestampAndId == nil {
			return fmt.Errorf("field \"timestampAndId\" is required")
		}
	}
	return nil
}

func (u PageToken) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PageToken) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PageToken) AcceptFuncs(timestampAndIdFunc func(TimestampAndId) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timestampAndId":
		if u.timestampAndId == nil {
			return fmt.Errorf("field \"timestampAndId\" is required")
		}
		return timestampAndIdFunc(*u.timestampAndId)
	}
}

func (u *PageToken) TimestampAndIdNoopSuccess(TimestampAndId) error {
	return nil
}

func (u *PageToken) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PageToken) Accept(v PageTokenVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timestampAndId":
		if u.timestampAndId == nil {
			return fmt.Errorf("field \"timestampAndId\" is required")
		}
		return v.VisitTimestampAndId(*u.timestampAndId)
	}
}

type PageTokenVisitor interface {
	VisitTimestampAndId(v TimestampAndId) error
	VisitUnknown(typeName string) error
}

func (u *PageToken) AcceptWithContext(ctx context.Context, v PageTokenVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timestampAndId":
		if u.timestampAndId == nil {
			return fmt.Errorf("field \"timestampAndId\" is required")
		}
		return v.VisitTimestampAndIdWithContext(ctx, *u.timestampAndId)
	}
}

type PageTokenVisitorWithContext interface {
	VisitTimestampAndIdWithContext(ctx context.Context, v TimestampAndId) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPageTokenFromTimestampAndId(v TimestampAndId) PageToken {
	return PageToken{typ: "timestampAndId", timestampAndId: &v}
}

type RangeAggregationOperation struct {
	typ               string
	sum               *Summation
	rootMeanSquare    *RootMeanSquare
	average           *Average
	min               *Minimum
	max               *Maximum
	standardDeviation *StandardDeviation
	count             *Count
	all               *api.Empty
}

type rangeAggregationOperationDeserializer struct {
	Type              string             `json:"type"`
	Sum               *Summation         `json:"sum"`
	RootMeanSquare    *RootMeanSquare    `json:"rootMeanSquare"`
	Average           *Average           `json:"average"`
	Min               *Minimum           `json:"min"`
	Max               *Maximum           `json:"max"`
	StandardDeviation *StandardDeviation `json:"standardDeviation"`
	Count             *Count             `json:"count"`
	All               *api.Empty         `json:"all"`
}

func (u *rangeAggregationOperationDeserializer) toStruct() RangeAggregationOperation {
	return RangeAggregationOperation{typ: u.Type, sum: u.Sum, rootMeanSquare: u.RootMeanSquare, average: u.Average, min: u.Min, max: u.Max, standardDeviation: u.StandardDeviation, count: u.Count, all: u.All}
}

func (u *RangeAggregationOperation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "sum":
		if u.sum == nil {
			return nil, fmt.Errorf("field \"sum\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Sum  Summation `json:"sum"`
		}{Type: "sum", Sum: *u.sum}, nil
	case "rootMeanSquare":
		if u.rootMeanSquare == nil {
			return nil, fmt.Errorf("field \"rootMeanSquare\" is required")
		}
		return struct {
			Type           string         `json:"type"`
			RootMeanSquare RootMeanSquare `json:"rootMeanSquare"`
		}{Type: "rootMeanSquare", RootMeanSquare: *u.rootMeanSquare}, nil
	case "average":
		if u.average == nil {
			return nil, fmt.Errorf("field \"average\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Average Average `json:"average"`
		}{Type: "average", Average: *u.average}, nil
	case "min":
		if u.min == nil {
			return nil, fmt.Errorf("field \"min\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Min  Minimum `json:"min"`
		}{Type: "min", Min: *u.min}, nil
	case "max":
		if u.max == nil {
			return nil, fmt.Errorf("field \"max\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Max  Maximum `json:"max"`
		}{Type: "max", Max: *u.max}, nil
	case "standardDeviation":
		if u.standardDeviation == nil {
			return nil, fmt.Errorf("field \"standardDeviation\" is required")
		}
		return struct {
			Type              string            `json:"type"`
			StandardDeviation StandardDeviation `json:"standardDeviation"`
		}{Type: "standardDeviation", StandardDeviation: *u.standardDeviation}, nil
	case "count":
		if u.count == nil {
			return nil, fmt.Errorf("field \"count\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Count Count  `json:"count"`
		}{Type: "count", Count: *u.count}, nil
	case "all":
		if u.all == nil {
			return nil, fmt.Errorf("field \"all\" is required")
		}
		return struct {
			Type string    `json:"type"`
			All  api.Empty `json:"all"`
		}{Type: "all", All: *u.all}, nil
	}
}

func (u RangeAggregationOperation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangeAggregationOperation) UnmarshalJSON(data []byte) error {
	var deser rangeAggregationOperationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
	case "rootMeanSquare":
		if u.rootMeanSquare == nil {
			return fmt.Errorf("field \"rootMeanSquare\" is required")
		}
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
	}
	return nil
}

func (u RangeAggregationOperation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangeAggregationOperation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangeAggregationOperation) AcceptFuncs(sumFunc func(Summation) error, rootMeanSquareFunc func(RootMeanSquare) error, averageFunc func(Average) error, minFunc func(Minimum) error, maxFunc func(Maximum) error, standardDeviationFunc func(StandardDeviation) error, countFunc func(Count) error, allFunc func(api.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return sumFunc(*u.sum)
	case "rootMeanSquare":
		if u.rootMeanSquare == nil {
			return fmt.Errorf("field \"rootMeanSquare\" is required")
		}
		return rootMeanSquareFunc(*u.rootMeanSquare)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return averageFunc(*u.average)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return standardDeviationFunc(*u.standardDeviation)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return countFunc(*u.count)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return allFunc(*u.all)
	}
}

func (u *RangeAggregationOperation) SumNoopSuccess(Summation) error {
	return nil
}

func (u *RangeAggregationOperation) RootMeanSquareNoopSuccess(RootMeanSquare) error {
	return nil
}

func (u *RangeAggregationOperation) AverageNoopSuccess(Average) error {
	return nil
}

func (u *RangeAggregationOperation) MinNoopSuccess(Minimum) error {
	return nil
}

func (u *RangeAggregationOperation) MaxNoopSuccess(Maximum) error {
	return nil
}

func (u *RangeAggregationOperation) StandardDeviationNoopSuccess(StandardDeviation) error {
	return nil
}

func (u *RangeAggregationOperation) CountNoopSuccess(Count) error {
	return nil
}

func (u *RangeAggregationOperation) AllNoopSuccess(api.Empty) error {
	return nil
}

func (u *RangeAggregationOperation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangeAggregationOperation) Accept(v RangeAggregationOperationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSum(*u.sum)
	case "rootMeanSquare":
		if u.rootMeanSquare == nil {
			return fmt.Errorf("field \"rootMeanSquare\" is required")
		}
		return v.VisitRootMeanSquare(*u.rootMeanSquare)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return v.VisitAverage(*u.average)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(*u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(*u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviation(*u.standardDeviation)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCount(*u.count)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAll(*u.all)
	}
}

type RangeAggregationOperationVisitor interface {
	VisitSum(v Summation) error
	VisitRootMeanSquare(v RootMeanSquare) error
	VisitAverage(v Average) error
	VisitMin(v Minimum) error
	VisitMax(v Maximum) error
	VisitStandardDeviation(v StandardDeviation) error
	VisitCount(v Count) error
	VisitAll(v api.Empty) error
	VisitUnknown(typeName string) error
}

func (u *RangeAggregationOperation) AcceptWithContext(ctx context.Context, v RangeAggregationOperationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSumWithContext(ctx, *u.sum)
	case "rootMeanSquare":
		if u.rootMeanSquare == nil {
			return fmt.Errorf("field \"rootMeanSquare\" is required")
		}
		return v.VisitRootMeanSquareWithContext(ctx, *u.rootMeanSquare)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return v.VisitAverageWithContext(ctx, *u.average)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMinWithContext(ctx, *u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMaxWithContext(ctx, *u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviationWithContext(ctx, *u.standardDeviation)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCountWithContext(ctx, *u.count)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAllWithContext(ctx, *u.all)
	}
}

type RangeAggregationOperationVisitorWithContext interface {
	VisitSumWithContext(ctx context.Context, v Summation) error
	VisitRootMeanSquareWithContext(ctx context.Context, v RootMeanSquare) error
	VisitAverageWithContext(ctx context.Context, v Average) error
	VisitMinWithContext(ctx context.Context, v Minimum) error
	VisitMaxWithContext(ctx context.Context, v Maximum) error
	VisitStandardDeviationWithContext(ctx context.Context, v StandardDeviation) error
	VisitCountWithContext(ctx context.Context, v Count) error
	VisitAllWithContext(ctx context.Context, v api.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangeAggregationOperationFromSum(v Summation) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "sum", sum: &v}
}

func NewRangeAggregationOperationFromRootMeanSquare(v RootMeanSquare) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "rootMeanSquare", rootMeanSquare: &v}
}

func NewRangeAggregationOperationFromAverage(v Average) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "average", average: &v}
}

func NewRangeAggregationOperationFromMin(v Minimum) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "min", min: &v}
}

func NewRangeAggregationOperationFromMax(v Maximum) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "max", max: &v}
}

func NewRangeAggregationOperationFromStandardDeviation(v StandardDeviation) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "standardDeviation", standardDeviation: &v}
}

func NewRangeAggregationOperationFromCount(v Count) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "count", count: &v}
}

func NewRangeAggregationOperationFromAll(v api.Empty) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "all", all: &v}
}

/*
A value attached to a range. If there are no relevant data points in the range, this will be noPointsInRange
for the range; otherwise, an Aggregation will be returned if this is produced by getting multiple aggregation
values over a range (i.e. aggregating for all metrics over a range), and will be a double otherwise for
singular values (i.e. aggregating for just the sum of data values over a range).
*/
type RangeValue struct {
	typ             string
	double          *float64
	aggregation     *RangeAggregation
	noPointsInRange *api.Empty
}

type rangeValueDeserializer struct {
	Type            string            `json:"type"`
	Double          *float64          `json:"double"`
	Aggregation     *RangeAggregation `json:"aggregation"`
	NoPointsInRange *api.Empty        `json:"noPointsInRange"`
}

func (u *rangeValueDeserializer) toStruct() RangeValue {
	return RangeValue{typ: u.Type, double: u.Double, aggregation: u.Aggregation, noPointsInRange: u.NoPointsInRange}
}

func (u *RangeValue) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "double":
		if u.double == nil {
			return nil, fmt.Errorf("field \"double\" is required")
		}
		return struct {
			Type   string  `json:"type"`
			Double float64 `json:"double"`
		}{Type: "double", Double: *u.double}, nil
	case "aggregation":
		if u.aggregation == nil {
			return nil, fmt.Errorf("field \"aggregation\" is required")
		}
		return struct {
			Type        string           `json:"type"`
			Aggregation RangeAggregation `json:"aggregation"`
		}{Type: "aggregation", Aggregation: *u.aggregation}, nil
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return nil, fmt.Errorf("field \"noPointsInRange\" is required")
		}
		return struct {
			Type            string    `json:"type"`
			NoPointsInRange api.Empty `json:"noPointsInRange"`
		}{Type: "noPointsInRange", NoPointsInRange: *u.noPointsInRange}, nil
	}
}

func (u RangeValue) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangeValue) UnmarshalJSON(data []byte) error {
	var deser rangeValueDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
	case "aggregation":
		if u.aggregation == nil {
			return fmt.Errorf("field \"aggregation\" is required")
		}
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return fmt.Errorf("field \"noPointsInRange\" is required")
		}
	}
	return nil
}

func (u RangeValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangeValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangeValue) AcceptFuncs(doubleFunc func(float64) error, aggregationFunc func(RangeAggregation) error, noPointsInRangeFunc func(api.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "aggregation":
		if u.aggregation == nil {
			return fmt.Errorf("field \"aggregation\" is required")
		}
		return aggregationFunc(*u.aggregation)
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return fmt.Errorf("field \"noPointsInRange\" is required")
		}
		return noPointsInRangeFunc(*u.noPointsInRange)
	}
}

func (u *RangeValue) DoubleNoopSuccess(float64) error {
	return nil
}

func (u *RangeValue) AggregationNoopSuccess(RangeAggregation) error {
	return nil
}

func (u *RangeValue) NoPointsInRangeNoopSuccess(api.Empty) error {
	return nil
}

func (u *RangeValue) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangeValue) Accept(v RangeValueVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(*u.double)
	case "aggregation":
		if u.aggregation == nil {
			return fmt.Errorf("field \"aggregation\" is required")
		}
		return v.VisitAggregation(*u.aggregation)
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return fmt.Errorf("field \"noPointsInRange\" is required")
		}
		return v.VisitNoPointsInRange(*u.noPointsInRange)
	}
}

type RangeValueVisitor interface {
	VisitDouble(v float64) error
	VisitAggregation(v RangeAggregation) error
	VisitNoPointsInRange(v api.Empty) error
	VisitUnknown(typeName string) error
}

func (u *RangeValue) AcceptWithContext(ctx context.Context, v RangeValueVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDoubleWithContext(ctx, *u.double)
	case "aggregation":
		if u.aggregation == nil {
			return fmt.Errorf("field \"aggregation\" is required")
		}
		return v.VisitAggregationWithContext(ctx, *u.aggregation)
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return fmt.Errorf("field \"noPointsInRange\" is required")
		}
		return v.VisitNoPointsInRangeWithContext(ctx, *u.noPointsInRange)
	}
}

type RangeValueVisitorWithContext interface {
	VisitDoubleWithContext(ctx context.Context, v float64) error
	VisitAggregationWithContext(ctx context.Context, v RangeAggregation) error
	VisitNoPointsInRangeWithContext(ctx context.Context, v api.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangeValueFromDouble(v float64) RangeValue {
	return RangeValue{typ: "double", double: &v}
}

func NewRangeValueFromAggregation(v RangeAggregation) RangeValue {
	return RangeValue{typ: "aggregation", aggregation: &v}
}

func NewRangeValueFromNoPointsInRange(v api.Empty) RangeValue {
	return RangeValue{typ: "noPointsInRange", noPointsInRange: &v}
}

type RollingOperator struct {
	typ               string
	average           *Average
	count             *Count
	min               *Minimum
	max               *Maximum
	standardDeviation *StandardDeviation
	sum               *Sum
}

type rollingOperatorDeserializer struct {
	Type              string             `json:"type"`
	Average           *Average           `json:"average"`
	Count             *Count             `json:"count"`
	Min               *Minimum           `json:"min"`
	Max               *Maximum           `json:"max"`
	StandardDeviation *StandardDeviation `json:"standardDeviation"`
	Sum               *Sum               `json:"sum"`
}

func (u *rollingOperatorDeserializer) toStruct() RollingOperator {
	return RollingOperator{typ: u.Type, average: u.Average, count: u.Count, min: u.Min, max: u.Max, standardDeviation: u.StandardDeviation, sum: u.Sum}
}

func (u *RollingOperator) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "average":
		if u.average == nil {
			return nil, fmt.Errorf("field \"average\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Average Average `json:"average"`
		}{Type: "average", Average: *u.average}, nil
	case "count":
		if u.count == nil {
			return nil, fmt.Errorf("field \"count\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Count Count  `json:"count"`
		}{Type: "count", Count: *u.count}, nil
	case "min":
		if u.min == nil {
			return nil, fmt.Errorf("field \"min\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Min  Minimum `json:"min"`
		}{Type: "min", Min: *u.min}, nil
	case "max":
		if u.max == nil {
			return nil, fmt.Errorf("field \"max\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Max  Maximum `json:"max"`
		}{Type: "max", Max: *u.max}, nil
	case "standardDeviation":
		if u.standardDeviation == nil {
			return nil, fmt.Errorf("field \"standardDeviation\" is required")
		}
		return struct {
			Type              string            `json:"type"`
			StandardDeviation StandardDeviation `json:"standardDeviation"`
		}{Type: "standardDeviation", StandardDeviation: *u.standardDeviation}, nil
	case "sum":
		if u.sum == nil {
			return nil, fmt.Errorf("field \"sum\" is required")
		}
		return struct {
			Type string `json:"type"`
			Sum  Sum    `json:"sum"`
		}{Type: "sum", Sum: *u.sum}, nil
	}
}

func (u RollingOperator) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RollingOperator) UnmarshalJSON(data []byte) error {
	var deser rollingOperatorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
	}
	return nil
}

func (u RollingOperator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RollingOperator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RollingOperator) AcceptFuncs(averageFunc func(Average) error, countFunc func(Count) error, minFunc func(Minimum) error, maxFunc func(Maximum) error, standardDeviationFunc func(StandardDeviation) error, sumFunc func(Sum) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return averageFunc(*u.average)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return countFunc(*u.count)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return standardDeviationFunc(*u.standardDeviation)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return sumFunc(*u.sum)
	}
}

func (u *RollingOperator) AverageNoopSuccess(Average) error {
	return nil
}

func (u *RollingOperator) CountNoopSuccess(Count) error {
	return nil
}

func (u *RollingOperator) MinNoopSuccess(Minimum) error {
	return nil
}

func (u *RollingOperator) MaxNoopSuccess(Maximum) error {
	return nil
}

func (u *RollingOperator) StandardDeviationNoopSuccess(StandardDeviation) error {
	return nil
}

func (u *RollingOperator) SumNoopSuccess(Sum) error {
	return nil
}

func (u *RollingOperator) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RollingOperator) Accept(v RollingOperatorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return v.VisitAverage(*u.average)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCount(*u.count)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(*u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(*u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviation(*u.standardDeviation)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSum(*u.sum)
	}
}

type RollingOperatorVisitor interface {
	VisitAverage(v Average) error
	VisitCount(v Count) error
	VisitMin(v Minimum) error
	VisitMax(v Maximum) error
	VisitStandardDeviation(v StandardDeviation) error
	VisitSum(v Sum) error
	VisitUnknown(typeName string) error
}

func (u *RollingOperator) AcceptWithContext(ctx context.Context, v RollingOperatorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return v.VisitAverageWithContext(ctx, *u.average)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCountWithContext(ctx, *u.count)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMinWithContext(ctx, *u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMaxWithContext(ctx, *u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviationWithContext(ctx, *u.standardDeviation)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSumWithContext(ctx, *u.sum)
	}
}

type RollingOperatorVisitorWithContext interface {
	VisitAverageWithContext(ctx context.Context, v Average) error
	VisitCountWithContext(ctx context.Context, v Count) error
	VisitMinWithContext(ctx context.Context, v Minimum) error
	VisitMaxWithContext(ctx context.Context, v Maximum) error
	VisitStandardDeviationWithContext(ctx context.Context, v StandardDeviation) error
	VisitSumWithContext(ctx context.Context, v Sum) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRollingOperatorFromAverage(v Average) RollingOperator {
	return RollingOperator{typ: "average", average: &v}
}

func NewRollingOperatorFromCount(v Count) RollingOperator {
	return RollingOperator{typ: "count", count: &v}
}

func NewRollingOperatorFromMin(v Minimum) RollingOperator {
	return RollingOperator{typ: "min", min: &v}
}

func NewRollingOperatorFromMax(v Maximum) RollingOperator {
	return RollingOperator{typ: "max", max: &v}
}

func NewRollingOperatorFromStandardDeviation(v StandardDeviation) RollingOperator {
	return RollingOperator{typ: "standardDeviation", standardDeviation: &v}
}

func NewRollingOperatorFromSum(v Sum) RollingOperator {
	return RollingOperator{typ: "sum", sum: &v}
}

type ScatterSummarizationStrategy struct {
	typ      string
	spatial  *SpatialDecimateStrategy
	temporal *TemporalDecimateStrategy
}

type scatterSummarizationStrategyDeserializer struct {
	Type     string                    `json:"type"`
	Spatial  *SpatialDecimateStrategy  `json:"spatial"`
	Temporal *TemporalDecimateStrategy `json:"temporal"`
}

func (u *scatterSummarizationStrategyDeserializer) toStruct() ScatterSummarizationStrategy {
	return ScatterSummarizationStrategy{typ: u.Type, spatial: u.Spatial, temporal: u.Temporal}
}

func (u *ScatterSummarizationStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "spatial":
		if u.spatial == nil {
			return nil, fmt.Errorf("field \"spatial\" is required")
		}
		return struct {
			Type    string                  `json:"type"`
			Spatial SpatialDecimateStrategy `json:"spatial"`
		}{Type: "spatial", Spatial: *u.spatial}, nil
	case "temporal":
		if u.temporal == nil {
			return nil, fmt.Errorf("field \"temporal\" is required")
		}
		return struct {
			Type     string                   `json:"type"`
			Temporal TemporalDecimateStrategy `json:"temporal"`
		}{Type: "temporal", Temporal: *u.temporal}, nil
	}
}

func (u ScatterSummarizationStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ScatterSummarizationStrategy) UnmarshalJSON(data []byte) error {
	var deser scatterSummarizationStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "spatial":
		if u.spatial == nil {
			return fmt.Errorf("field \"spatial\" is required")
		}
	case "temporal":
		if u.temporal == nil {
			return fmt.Errorf("field \"temporal\" is required")
		}
	}
	return nil
}

func (u ScatterSummarizationStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ScatterSummarizationStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ScatterSummarizationStrategy) AcceptFuncs(spatialFunc func(SpatialDecimateStrategy) error, temporalFunc func(TemporalDecimateStrategy) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "spatial":
		if u.spatial == nil {
			return fmt.Errorf("field \"spatial\" is required")
		}
		return spatialFunc(*u.spatial)
	case "temporal":
		if u.temporal == nil {
			return fmt.Errorf("field \"temporal\" is required")
		}
		return temporalFunc(*u.temporal)
	}
}

func (u *ScatterSummarizationStrategy) SpatialNoopSuccess(SpatialDecimateStrategy) error {
	return nil
}

func (u *ScatterSummarizationStrategy) TemporalNoopSuccess(TemporalDecimateStrategy) error {
	return nil
}

func (u *ScatterSummarizationStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ScatterSummarizationStrategy) Accept(v ScatterSummarizationStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "spatial":
		if u.spatial == nil {
			return fmt.Errorf("field \"spatial\" is required")
		}
		return v.VisitSpatial(*u.spatial)
	case "temporal":
		if u.temporal == nil {
			return fmt.Errorf("field \"temporal\" is required")
		}
		return v.VisitTemporal(*u.temporal)
	}
}

type ScatterSummarizationStrategyVisitor interface {
	VisitSpatial(v SpatialDecimateStrategy) error
	VisitTemporal(v TemporalDecimateStrategy) error
	VisitUnknown(typeName string) error
}

func (u *ScatterSummarizationStrategy) AcceptWithContext(ctx context.Context, v ScatterSummarizationStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "spatial":
		if u.spatial == nil {
			return fmt.Errorf("field \"spatial\" is required")
		}
		return v.VisitSpatialWithContext(ctx, *u.spatial)
	case "temporal":
		if u.temporal == nil {
			return fmt.Errorf("field \"temporal\" is required")
		}
		return v.VisitTemporalWithContext(ctx, *u.temporal)
	}
}

type ScatterSummarizationStrategyVisitorWithContext interface {
	VisitSpatialWithContext(ctx context.Context, v SpatialDecimateStrategy) error
	VisitTemporalWithContext(ctx context.Context, v TemporalDecimateStrategy) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewScatterSummarizationStrategyFromSpatial(v SpatialDecimateStrategy) ScatterSummarizationStrategy {
	return ScatterSummarizationStrategy{typ: "spatial", spatial: &v}
}

func NewScatterSummarizationStrategyFromTemporal(v TemporalDecimateStrategy) ScatterSummarizationStrategy {
	return ScatterSummarizationStrategy{typ: "temporal", temporal: &v}
}

type SignalFilterConfiguration struct {
	typ      string
	lowPass  *LowPassConfiguration
	highPass *HighPassConfiguration
	bandPass *BandPassConfiguration
	bandStop *BandStopConfiguration
}

type signalFilterConfigurationDeserializer struct {
	Type     string                 `json:"type"`
	LowPass  *LowPassConfiguration  `json:"lowPass"`
	HighPass *HighPassConfiguration `json:"highPass"`
	BandPass *BandPassConfiguration `json:"bandPass"`
	BandStop *BandStopConfiguration `json:"bandStop"`
}

func (u *signalFilterConfigurationDeserializer) toStruct() SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: u.Type, lowPass: u.LowPass, highPass: u.HighPass, bandPass: u.BandPass, bandStop: u.BandStop}
}

func (u *SignalFilterConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return nil, fmt.Errorf("field \"lowPass\" is required")
		}
		return struct {
			Type    string               `json:"type"`
			LowPass LowPassConfiguration `json:"lowPass"`
		}{Type: "lowPass", LowPass: *u.lowPass}, nil
	case "highPass":
		if u.highPass == nil {
			return nil, fmt.Errorf("field \"highPass\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			HighPass HighPassConfiguration `json:"highPass"`
		}{Type: "highPass", HighPass: *u.highPass}, nil
	case "bandPass":
		if u.bandPass == nil {
			return nil, fmt.Errorf("field \"bandPass\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			BandPass BandPassConfiguration `json:"bandPass"`
		}{Type: "bandPass", BandPass: *u.bandPass}, nil
	case "bandStop":
		if u.bandStop == nil {
			return nil, fmt.Errorf("field \"bandStop\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			BandStop BandStopConfiguration `json:"bandStop"`
		}{Type: "bandStop", BandStop: *u.bandStop}, nil
	}
}

func (u SignalFilterConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SignalFilterConfiguration) UnmarshalJSON(data []byte) error {
	var deser signalFilterConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
	}
	return nil
}

func (u SignalFilterConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SignalFilterConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SignalFilterConfiguration) AcceptFuncs(lowPassFunc func(LowPassConfiguration) error, highPassFunc func(HighPassConfiguration) error, bandPassFunc func(BandPassConfiguration) error, bandStopFunc func(BandStopConfiguration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
		return lowPassFunc(*u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
		return highPassFunc(*u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
		return bandPassFunc(*u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
		return bandStopFunc(*u.bandStop)
	}
}

func (u *SignalFilterConfiguration) LowPassNoopSuccess(LowPassConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) HighPassNoopSuccess(HighPassConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) BandPassNoopSuccess(BandPassConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) BandStopNoopSuccess(BandStopConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SignalFilterConfiguration) Accept(v SignalFilterConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
		return v.VisitLowPass(*u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
		return v.VisitHighPass(*u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
		return v.VisitBandPass(*u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
		return v.VisitBandStop(*u.bandStop)
	}
}

type SignalFilterConfigurationVisitor interface {
	VisitLowPass(v LowPassConfiguration) error
	VisitHighPass(v HighPassConfiguration) error
	VisitBandPass(v BandPassConfiguration) error
	VisitBandStop(v BandStopConfiguration) error
	VisitUnknown(typeName string) error
}

func (u *SignalFilterConfiguration) AcceptWithContext(ctx context.Context, v SignalFilterConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
		return v.VisitLowPassWithContext(ctx, *u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
		return v.VisitHighPassWithContext(ctx, *u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
		return v.VisitBandPassWithContext(ctx, *u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
		return v.VisitBandStopWithContext(ctx, *u.bandStop)
	}
}

type SignalFilterConfigurationVisitorWithContext interface {
	VisitLowPassWithContext(ctx context.Context, v LowPassConfiguration) error
	VisitHighPassWithContext(ctx context.Context, v HighPassConfiguration) error
	VisitBandPassWithContext(ctx context.Context, v BandPassConfiguration) error
	VisitBandStopWithContext(ctx context.Context, v BandStopConfiguration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSignalFilterConfigurationFromLowPass(v LowPassConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "lowPass", lowPass: &v}
}

func NewSignalFilterConfigurationFromHighPass(v HighPassConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "highPass", highPass: &v}
}

func NewSignalFilterConfigurationFromBandPass(v BandPassConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "bandPass", bandPass: &v}
}

func NewSignalFilterConfigurationFromBandStop(v BandStopConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "bandStop", bandStop: &v}
}

type StringConstant struct {
	typ      string
	literal  *string
	variable *VariableName
}

type stringConstantDeserializer struct {
	Type     string        `json:"type"`
	Literal  *string       `json:"literal"`
	Variable *VariableName `json:"variable"`
}

func (u *stringConstantDeserializer) toStruct() StringConstant {
	return StringConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *StringConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string `json:"type"`
			Literal string `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Variable VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u StringConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *StringConstant) UnmarshalJSON(data []byte) error {
	var deser stringConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u StringConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *StringConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *StringConstant) AcceptFuncs(literalFunc func(string) error, variableFunc func(VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *StringConstant) LiteralNoopSuccess(string) error {
	return nil
}

func (u *StringConstant) VariableNoopSuccess(VariableName) error {
	return nil
}

func (u *StringConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *StringConstant) Accept(v StringConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type StringConstantVisitor interface {
	VisitLiteral(v string) error
	VisitVariable(v VariableName) error
	VisitUnknown(typeName string) error
}

func (u *StringConstant) AcceptWithContext(ctx context.Context, v StringConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type StringConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v string) error
	VisitVariableWithContext(ctx context.Context, v VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewStringConstantFromLiteral(v string) StringConstant {
	return StringConstant{typ: "literal", literal: &v}
}

func NewStringConstantFromVariable(v VariableName) StringConstant {
	return StringConstant{typ: "variable", variable: &v}
}

type StringSetConstant struct {
	typ      string
	literal  *[]string
	variable *VariableName
}

type stringSetConstantDeserializer struct {
	Type     string        `json:"type"`
	Literal  *[]string     `json:"literal"`
	Variable *VariableName `json:"variable"`
}

func (u *stringSetConstantDeserializer) toStruct() StringSetConstant {
	return StringSetConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *StringSetConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string   `json:"type"`
			Literal []string `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Variable VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u StringSetConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *StringSetConstant) UnmarshalJSON(data []byte) error {
	var deser stringSetConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u StringSetConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *StringSetConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *StringSetConstant) AcceptFuncs(literalFunc func([]string) error, variableFunc func(VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *StringSetConstant) LiteralNoopSuccess([]string) error {
	return nil
}

func (u *StringSetConstant) VariableNoopSuccess(VariableName) error {
	return nil
}

func (u *StringSetConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *StringSetConstant) Accept(v StringSetConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type StringSetConstantVisitor interface {
	VisitLiteral(v []string) error
	VisitVariable(v VariableName) error
	VisitUnknown(typeName string) error
}

func (u *StringSetConstant) AcceptWithContext(ctx context.Context, v StringSetConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type StringSetConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v []string) error
	VisitVariableWithContext(ctx context.Context, v VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewStringSetConstantFromLiteral(v []string) StringSetConstant {
	return StringSetConstant{typ: "literal", literal: &v}
}

func NewStringSetConstantFromVariable(v VariableName) StringSetConstant {
	return StringSetConstant{typ: "variable", variable: &v}
}

type SummarizationStrategy struct {
	typ      string
	decimate *DecimateStrategy
	page     *PageStrategy
	truncate *TruncateStrategy
}

type summarizationStrategyDeserializer struct {
	Type     string            `json:"type"`
	Decimate *DecimateStrategy `json:"decimate"`
	Page     *PageStrategy     `json:"page"`
	Truncate *TruncateStrategy `json:"truncate"`
}

func (u *summarizationStrategyDeserializer) toStruct() SummarizationStrategy {
	return SummarizationStrategy{typ: u.Type, decimate: u.Decimate, page: u.Page, truncate: u.Truncate}
}

func (u *SummarizationStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "decimate":
		if u.decimate == nil {
			return nil, fmt.Errorf("field \"decimate\" is required")
		}
		return struct {
			Type     string           `json:"type"`
			Decimate DecimateStrategy `json:"decimate"`
		}{Type: "decimate", Decimate: *u.decimate}, nil
	case "page":
		if u.page == nil {
			return nil, fmt.Errorf("field \"page\" is required")
		}
		return struct {
			Type string       `json:"type"`
			Page PageStrategy `json:"page"`
		}{Type: "page", Page: *u.page}, nil
	case "truncate":
		if u.truncate == nil {
			return nil, fmt.Errorf("field \"truncate\" is required")
		}
		return struct {
			Type     string           `json:"type"`
			Truncate TruncateStrategy `json:"truncate"`
		}{Type: "truncate", Truncate: *u.truncate}, nil
	}
}

func (u SummarizationStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SummarizationStrategy) UnmarshalJSON(data []byte) error {
	var deser summarizationStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "decimate":
		if u.decimate == nil {
			return fmt.Errorf("field \"decimate\" is required")
		}
	case "page":
		if u.page == nil {
			return fmt.Errorf("field \"page\" is required")
		}
	case "truncate":
		if u.truncate == nil {
			return fmt.Errorf("field \"truncate\" is required")
		}
	}
	return nil
}

func (u SummarizationStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SummarizationStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SummarizationStrategy) AcceptFuncs(decimateFunc func(DecimateStrategy) error, pageFunc func(PageStrategy) error, truncateFunc func(TruncateStrategy) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "decimate":
		if u.decimate == nil {
			return fmt.Errorf("field \"decimate\" is required")
		}
		return decimateFunc(*u.decimate)
	case "page":
		if u.page == nil {
			return fmt.Errorf("field \"page\" is required")
		}
		return pageFunc(*u.page)
	case "truncate":
		if u.truncate == nil {
			return fmt.Errorf("field \"truncate\" is required")
		}
		return truncateFunc(*u.truncate)
	}
}

func (u *SummarizationStrategy) DecimateNoopSuccess(DecimateStrategy) error {
	return nil
}

func (u *SummarizationStrategy) PageNoopSuccess(PageStrategy) error {
	return nil
}

func (u *SummarizationStrategy) TruncateNoopSuccess(TruncateStrategy) error {
	return nil
}

func (u *SummarizationStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SummarizationStrategy) Accept(v SummarizationStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "decimate":
		if u.decimate == nil {
			return fmt.Errorf("field \"decimate\" is required")
		}
		return v.VisitDecimate(*u.decimate)
	case "page":
		if u.page == nil {
			return fmt.Errorf("field \"page\" is required")
		}
		return v.VisitPage(*u.page)
	case "truncate":
		if u.truncate == nil {
			return fmt.Errorf("field \"truncate\" is required")
		}
		return v.VisitTruncate(*u.truncate)
	}
}

type SummarizationStrategyVisitor interface {
	VisitDecimate(v DecimateStrategy) error
	VisitPage(v PageStrategy) error
	VisitTruncate(v TruncateStrategy) error
	VisitUnknown(typeName string) error
}

func (u *SummarizationStrategy) AcceptWithContext(ctx context.Context, v SummarizationStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "decimate":
		if u.decimate == nil {
			return fmt.Errorf("field \"decimate\" is required")
		}
		return v.VisitDecimateWithContext(ctx, *u.decimate)
	case "page":
		if u.page == nil {
			return fmt.Errorf("field \"page\" is required")
		}
		return v.VisitPageWithContext(ctx, *u.page)
	case "truncate":
		if u.truncate == nil {
			return fmt.Errorf("field \"truncate\" is required")
		}
		return v.VisitTruncateWithContext(ctx, *u.truncate)
	}
}

type SummarizationStrategyVisitorWithContext interface {
	VisitDecimateWithContext(ctx context.Context, v DecimateStrategy) error
	VisitPageWithContext(ctx context.Context, v PageStrategy) error
	VisitTruncateWithContext(ctx context.Context, v TruncateStrategy) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSummarizationStrategyFromDecimate(v DecimateStrategy) SummarizationStrategy {
	return SummarizationStrategy{typ: "decimate", decimate: &v}
}

func NewSummarizationStrategyFromPage(v PageStrategy) SummarizationStrategy {
	return SummarizationStrategy{typ: "page", page: &v}
}

func NewSummarizationStrategyFromTruncate(v TruncateStrategy) SummarizationStrategy {
	return SummarizationStrategy{typ: "truncate", truncate: &v}
}

/*
A set of tag filters to apply to a channel. Allows for combining filters on multiple tag keys, but throws if
any one tag key is specified in more than one filter.
*/
type TagFilters struct {
	typ    string
	single *TagFilter
	and    *[]TagFilters
}

type tagFiltersDeserializer struct {
	Type   string        `json:"type"`
	Single *TagFilter    `json:"single"`
	And    *[]TagFilters `json:"and"`
}

func (u *tagFiltersDeserializer) toStruct() TagFilters {
	return TagFilters{typ: u.Type, single: u.Single, and: u.And}
}

func (u *TagFilters) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "single":
		if u.single == nil {
			return nil, fmt.Errorf("field \"single\" is required")
		}
		return struct {
			Type   string    `json:"type"`
			Single TagFilter `json:"single"`
		}{Type: "single", Single: *u.single}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string       `json:"type"`
			And  []TagFilters `json:"and"`
		}{Type: "and", And: *u.and}, nil
	}
}

func (u TagFilters) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TagFilters) UnmarshalJSON(data []byte) error {
	var deser tagFiltersDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	}
	return nil
}

func (u TagFilters) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TagFilters) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TagFilters) AcceptFuncs(singleFunc func(TagFilter) error, andFunc func([]TagFilters) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	}
}

func (u *TagFilters) SingleNoopSuccess(TagFilter) error {
	return nil
}

func (u *TagFilters) AndNoopSuccess([]TagFilters) error {
	return nil
}

func (u *TagFilters) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TagFilters) Accept(v TagFiltersVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(*u.single)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	}
}

type TagFiltersVisitor interface {
	VisitSingle(v TagFilter) error
	VisitAnd(v []TagFilters) error
	VisitUnknown(typeName string) error
}

func (u *TagFilters) AcceptWithContext(ctx context.Context, v TagFiltersVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingleWithContext(ctx, *u.single)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	}
}

type TagFiltersVisitorWithContext interface {
	VisitSingleWithContext(ctx context.Context, v TagFilter) error
	VisitAndWithContext(ctx context.Context, v []TagFilters) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTagFiltersFromSingle(v TagFilter) TagFilters {
	return TagFilters{typ: "single", single: &v}
}

func NewTagFiltersFromAnd(v []TagFilters) TagFilters {
	return TagFilters{typ: "and", and: &v}
}

type Threshold struct {
	typ        string
	absolute   *AbsoluteThreshold
	percentage *PercentageThreshold
}

type thresholdDeserializer struct {
	Type       string               `json:"type"`
	Absolute   *AbsoluteThreshold   `json:"absolute"`
	Percentage *PercentageThreshold `json:"percentage"`
}

func (u *thresholdDeserializer) toStruct() Threshold {
	return Threshold{typ: u.Type, absolute: u.Absolute, percentage: u.Percentage}
}

func (u *Threshold) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "absolute":
		if u.absolute == nil {
			return nil, fmt.Errorf("field \"absolute\" is required")
		}
		return struct {
			Type     string            `json:"type"`
			Absolute AbsoluteThreshold `json:"absolute"`
		}{Type: "absolute", Absolute: *u.absolute}, nil
	case "percentage":
		if u.percentage == nil {
			return nil, fmt.Errorf("field \"percentage\" is required")
		}
		return struct {
			Type       string              `json:"type"`
			Percentage PercentageThreshold `json:"percentage"`
		}{Type: "percentage", Percentage: *u.percentage}, nil
	}
}

func (u Threshold) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Threshold) UnmarshalJSON(data []byte) error {
	var deser thresholdDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
	}
	return nil
}

func (u Threshold) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Threshold) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Threshold) AcceptFuncs(absoluteFunc func(AbsoluteThreshold) error, percentageFunc func(PercentageThreshold) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return absoluteFunc(*u.absolute)
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
		return percentageFunc(*u.percentage)
	}
}

func (u *Threshold) AbsoluteNoopSuccess(AbsoluteThreshold) error {
	return nil
}

func (u *Threshold) PercentageNoopSuccess(PercentageThreshold) error {
	return nil
}

func (u *Threshold) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Threshold) Accept(v ThresholdVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsolute(*u.absolute)
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
		return v.VisitPercentage(*u.percentage)
	}
}

type ThresholdVisitor interface {
	VisitAbsolute(v AbsoluteThreshold) error
	VisitPercentage(v PercentageThreshold) error
	VisitUnknown(typeName string) error
}

func (u *Threshold) AcceptWithContext(ctx context.Context, v ThresholdVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsoluteWithContext(ctx, *u.absolute)
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
		return v.VisitPercentageWithContext(ctx, *u.percentage)
	}
}

type ThresholdVisitorWithContext interface {
	VisitAbsoluteWithContext(ctx context.Context, v AbsoluteThreshold) error
	VisitPercentageWithContext(ctx context.Context, v PercentageThreshold) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewThresholdFromAbsolute(v AbsoluteThreshold) Threshold {
	return Threshold{typ: "absolute", absolute: &v}
}

func NewThresholdFromPercentage(v PercentageThreshold) Threshold {
	return Threshold{typ: "percentage", percentage: &v}
}

type TimestampConstant struct {
	typ      string
	literal  *api.Timestamp
	variable *VariableName
}

type timestampConstantDeserializer struct {
	Type     string         `json:"type"`
	Literal  *api.Timestamp `json:"literal"`
	Variable *VariableName  `json:"variable"`
}

func (u *timestampConstantDeserializer) toStruct() TimestampConstant {
	return TimestampConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *TimestampConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Literal api.Timestamp `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Variable VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u TimestampConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimestampConstant) UnmarshalJSON(data []byte) error {
	var deser timestampConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u TimestampConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimestampConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimestampConstant) AcceptFuncs(literalFunc func(api.Timestamp) error, variableFunc func(VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *TimestampConstant) LiteralNoopSuccess(api.Timestamp) error {
	return nil
}

func (u *TimestampConstant) VariableNoopSuccess(VariableName) error {
	return nil
}

func (u *TimestampConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimestampConstant) Accept(v TimestampConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type TimestampConstantVisitor interface {
	VisitLiteral(v api.Timestamp) error
	VisitVariable(v VariableName) error
	VisitUnknown(typeName string) error
}

func (u *TimestampConstant) AcceptWithContext(ctx context.Context, v TimestampConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type TimestampConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v api.Timestamp) error
	VisitVariableWithContext(ctx context.Context, v VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimestampConstantFromLiteral(v api.Timestamp) TimestampConstant {
	return TimestampConstant{typ: "literal", literal: &v}
}

func NewTimestampConstantFromVariable(v VariableName) TimestampConstant {
	return TimestampConstant{typ: "variable", variable: &v}
}

type TruncateStrategy struct {
	typ               string
	maxPointsToReturn *int
}

type truncateStrategyDeserializer struct {
	Type              string `json:"type"`
	MaxPointsToReturn *int   `json:"maxPointsToReturn"`
}

func (u *truncateStrategyDeserializer) toStruct() TruncateStrategy {
	return TruncateStrategy{typ: u.Type, maxPointsToReturn: u.MaxPointsToReturn}
}

func (u *TruncateStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "maxPointsToReturn":
		if u.maxPointsToReturn == nil {
			return nil, fmt.Errorf("field \"maxPointsToReturn\" is required")
		}
		return struct {
			Type              string `json:"type"`
			MaxPointsToReturn int    `json:"maxPointsToReturn"`
		}{Type: "maxPointsToReturn", MaxPointsToReturn: *u.maxPointsToReturn}, nil
	}
}

func (u TruncateStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TruncateStrategy) UnmarshalJSON(data []byte) error {
	var deser truncateStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "maxPointsToReturn":
		if u.maxPointsToReturn == nil {
			return fmt.Errorf("field \"maxPointsToReturn\" is required")
		}
	}
	return nil
}

func (u TruncateStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TruncateStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TruncateStrategy) AcceptFuncs(maxPointsToReturnFunc func(int) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "maxPointsToReturn":
		if u.maxPointsToReturn == nil {
			return fmt.Errorf("field \"maxPointsToReturn\" is required")
		}
		return maxPointsToReturnFunc(*u.maxPointsToReturn)
	}
}

func (u *TruncateStrategy) MaxPointsToReturnNoopSuccess(int) error {
	return nil
}

func (u *TruncateStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TruncateStrategy) Accept(v TruncateStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "maxPointsToReturn":
		if u.maxPointsToReturn == nil {
			return fmt.Errorf("field \"maxPointsToReturn\" is required")
		}
		return v.VisitMaxPointsToReturn(*u.maxPointsToReturn)
	}
}

type TruncateStrategyVisitor interface {
	VisitMaxPointsToReturn(v int) error
	VisitUnknown(typeName string) error
}

func (u *TruncateStrategy) AcceptWithContext(ctx context.Context, v TruncateStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "maxPointsToReturn":
		if u.maxPointsToReturn == nil {
			return fmt.Errorf("field \"maxPointsToReturn\" is required")
		}
		return v.VisitMaxPointsToReturnWithContext(ctx, *u.maxPointsToReturn)
	}
}

type TruncateStrategyVisitorWithContext interface {
	VisitMaxPointsToReturnWithContext(ctx context.Context, v int) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTruncateStrategyFromMaxPointsToReturn(v int) TruncateStrategy {
	return TruncateStrategy{typ: "maxPointsToReturn", maxPointsToReturn: &v}
}

type UnitComputationError struct {
	typ                        string
	incompatibleUnitsOperation *IncompatibleUnitOperation
	unitsMissing               *UnitsMissing
	error                      *api.SerializableError
}

type unitComputationErrorDeserializer struct {
	Type                       string                     `json:"type"`
	IncompatibleUnitsOperation *IncompatibleUnitOperation `json:"incompatibleUnitsOperation"`
	UnitsMissing               *UnitsMissing              `json:"unitsMissing"`
	Error                      *api.SerializableError     `json:"error"`
}

func (u *unitComputationErrorDeserializer) toStruct() UnitComputationError {
	return UnitComputationError{typ: u.Type, incompatibleUnitsOperation: u.IncompatibleUnitsOperation, unitsMissing: u.UnitsMissing, error: u.Error}
}

func (u *UnitComputationError) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return nil, fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
		return struct {
			Type                       string                    `json:"type"`
			IncompatibleUnitsOperation IncompatibleUnitOperation `json:"incompatibleUnitsOperation"`
		}{Type: "incompatibleUnitsOperation", IncompatibleUnitsOperation: *u.incompatibleUnitsOperation}, nil
	case "unitsMissing":
		if u.unitsMissing == nil {
			return nil, fmt.Errorf("field \"unitsMissing\" is required")
		}
		return struct {
			Type         string       `json:"type"`
			UnitsMissing UnitsMissing `json:"unitsMissing"`
		}{Type: "unitsMissing", UnitsMissing: *u.unitsMissing}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string                `json:"type"`
			Error api.SerializableError `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	}
}

func (u UnitComputationError) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UnitComputationError) UnmarshalJSON(data []byte) error {
	var deser unitComputationErrorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
	case "unitsMissing":
		if u.unitsMissing == nil {
			return fmt.Errorf("field \"unitsMissing\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	}
	return nil
}

func (u UnitComputationError) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UnitComputationError) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UnitComputationError) AcceptFuncs(incompatibleUnitsOperationFunc func(IncompatibleUnitOperation) error, unitsMissingFunc func(UnitsMissing) error, errorFunc func(api.SerializableError) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
		return incompatibleUnitsOperationFunc(*u.incompatibleUnitsOperation)
	case "unitsMissing":
		if u.unitsMissing == nil {
			return fmt.Errorf("field \"unitsMissing\" is required")
		}
		return unitsMissingFunc(*u.unitsMissing)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *UnitComputationError) IncompatibleUnitsOperationNoopSuccess(IncompatibleUnitOperation) error {
	return nil
}

func (u *UnitComputationError) UnitsMissingNoopSuccess(UnitsMissing) error {
	return nil
}

func (u *UnitComputationError) ErrorNoopSuccess(api.SerializableError) error {
	return nil
}

func (u *UnitComputationError) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UnitComputationError) Accept(v UnitComputationErrorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
		return v.VisitIncompatibleUnitsOperation(*u.incompatibleUnitsOperation)
	case "unitsMissing":
		if u.unitsMissing == nil {
			return fmt.Errorf("field \"unitsMissing\" is required")
		}
		return v.VisitUnitsMissing(*u.unitsMissing)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	}
}

type UnitComputationErrorVisitor interface {
	VisitIncompatibleUnitsOperation(v IncompatibleUnitOperation) error
	VisitUnitsMissing(v UnitsMissing) error
	VisitError(v api.SerializableError) error
	VisitUnknown(typeName string) error
}

func (u *UnitComputationError) AcceptWithContext(ctx context.Context, v UnitComputationErrorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
		return v.VisitIncompatibleUnitsOperationWithContext(ctx, *u.incompatibleUnitsOperation)
	case "unitsMissing":
		if u.unitsMissing == nil {
			return fmt.Errorf("field \"unitsMissing\" is required")
		}
		return v.VisitUnitsMissingWithContext(ctx, *u.unitsMissing)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	}
}

type UnitComputationErrorVisitorWithContext interface {
	VisitIncompatibleUnitsOperationWithContext(ctx context.Context, v IncompatibleUnitOperation) error
	VisitUnitsMissingWithContext(ctx context.Context, v UnitsMissing) error
	VisitErrorWithContext(ctx context.Context, v api.SerializableError) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnitComputationErrorFromIncompatibleUnitsOperation(v IncompatibleUnitOperation) UnitComputationError {
	return UnitComputationError{typ: "incompatibleUnitsOperation", incompatibleUnitsOperation: &v}
}

func NewUnitComputationErrorFromUnitsMissing(v UnitsMissing) UnitComputationError {
	return UnitComputationError{typ: "unitsMissing", unitsMissing: &v}
}

func NewUnitComputationErrorFromError(v api.SerializableError) UnitComputationError {
	return UnitComputationError{typ: "error", error: &v}
}

type UnitResult struct {
	typ             string
	success         *api1.UnitSymbol
	noUnitAvailable *[]UnitComputationError
}

type unitResultDeserializer struct {
	Type            string                  `json:"type"`
	Success         *api1.UnitSymbol        `json:"success"`
	NoUnitAvailable *[]UnitComputationError `json:"noUnitAvailable"`
}

func (u *unitResultDeserializer) toStruct() UnitResult {
	return UnitResult{typ: u.Type, success: u.Success, noUnitAvailable: u.NoUnitAvailable}
}

func (u *UnitResult) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "success":
		if u.success == nil {
			return nil, fmt.Errorf("field \"success\" is required")
		}
		return struct {
			Type    string          `json:"type"`
			Success api1.UnitSymbol `json:"success"`
		}{Type: "success", Success: *u.success}, nil
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return nil, fmt.Errorf("field \"noUnitAvailable\" is required")
		}
		return struct {
			Type            string                 `json:"type"`
			NoUnitAvailable []UnitComputationError `json:"noUnitAvailable"`
		}{Type: "noUnitAvailable", NoUnitAvailable: *u.noUnitAvailable}, nil
	}
}

func (u UnitResult) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UnitResult) UnmarshalJSON(data []byte) error {
	var deser unitResultDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return fmt.Errorf("field \"noUnitAvailable\" is required")
		}
	}
	return nil
}

func (u UnitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UnitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UnitResult) AcceptFuncs(successFunc func(api1.UnitSymbol) error, noUnitAvailableFunc func([]UnitComputationError) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return fmt.Errorf("field \"noUnitAvailable\" is required")
		}
		return noUnitAvailableFunc(*u.noUnitAvailable)
	}
}

func (u *UnitResult) SuccessNoopSuccess(api1.UnitSymbol) error {
	return nil
}

func (u *UnitResult) NoUnitAvailableNoopSuccess([]UnitComputationError) error {
	return nil
}

func (u *UnitResult) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UnitResult) Accept(v UnitResultVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(*u.success)
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return fmt.Errorf("field \"noUnitAvailable\" is required")
		}
		return v.VisitNoUnitAvailable(*u.noUnitAvailable)
	}
}

type UnitResultVisitor interface {
	VisitSuccess(v api1.UnitSymbol) error
	VisitNoUnitAvailable(v []UnitComputationError) error
	VisitUnknown(typeName string) error
}

func (u *UnitResult) AcceptWithContext(ctx context.Context, v UnitResultVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccessWithContext(ctx, *u.success)
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return fmt.Errorf("field \"noUnitAvailable\" is required")
		}
		return v.VisitNoUnitAvailableWithContext(ctx, *u.noUnitAvailable)
	}
}

type UnitResultVisitorWithContext interface {
	VisitSuccessWithContext(ctx context.Context, v api1.UnitSymbol) error
	VisitNoUnitAvailableWithContext(ctx context.Context, v []UnitComputationError) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnitResultFromSuccess(v api1.UnitSymbol) UnitResult {
	return UnitResult{typ: "success", success: &v}
}

func NewUnitResultFromNoUnitAvailable(v []UnitComputationError) UnitResult {
	return UnitResult{typ: "noUnitAvailable", noUnitAvailable: &v}
}

// A single value. The type is dictated by the returned variant
type Value struct {
	typ          string
	stringValue  *string
	float64Value *float64
	int64Value   *string
	arrayValue   *[]*Value
	structValue  *interface{}
}

type valueDeserializer struct {
	Type         string       `json:"type"`
	StringValue  *string      `json:"stringValue"`
	Float64Value *float64     `json:"float64Value"`
	Int64Value   *string      `json:"int64Value"`
	ArrayValue   *[]*Value    `json:"arrayValue"`
	StructValue  *interface{} `json:"structValue"`
}

func (u *valueDeserializer) toStruct() Value {
	return Value{typ: u.Type, stringValue: u.StringValue, float64Value: u.Float64Value, int64Value: u.Int64Value, arrayValue: u.ArrayValue, structValue: u.StructValue}
}

func (u *Value) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "stringValue":
		if u.stringValue == nil {
			return nil, fmt.Errorf("field \"stringValue\" is required")
		}
		return struct {
			Type        string `json:"type"`
			StringValue string `json:"stringValue"`
		}{Type: "stringValue", StringValue: *u.stringValue}, nil
	case "float64Value":
		if u.float64Value == nil {
			return nil, fmt.Errorf("field \"float64Value\" is required")
		}
		return struct {
			Type         string  `json:"type"`
			Float64Value float64 `json:"float64Value"`
		}{Type: "float64Value", Float64Value: *u.float64Value}, nil
	case "int64Value":
		if u.int64Value == nil {
			return nil, fmt.Errorf("field \"int64Value\" is required")
		}
		return struct {
			Type       string `json:"type"`
			Int64Value string `json:"int64Value"`
		}{Type: "int64Value", Int64Value: *u.int64Value}, nil
	case "arrayValue":
		if u.arrayValue == nil {
			return nil, fmt.Errorf("field \"arrayValue\" is required")
		}
		return struct {
			Type       string   `json:"type"`
			ArrayValue []*Value `json:"arrayValue"`
		}{Type: "arrayValue", ArrayValue: *u.arrayValue}, nil
	case "structValue":
		if u.structValue == nil {
			return nil, fmt.Errorf("field \"structValue\" is required")
		}
		return struct {
			Type        string      `json:"type"`
			StructValue interface{} `json:"structValue"`
		}{Type: "structValue", StructValue: *u.structValue}, nil
	}
}

func (u Value) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Value) UnmarshalJSON(data []byte) error {
	var deser valueDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "stringValue":
		if u.stringValue == nil {
			return fmt.Errorf("field \"stringValue\" is required")
		}
	case "float64Value":
		if u.float64Value == nil {
			return fmt.Errorf("field \"float64Value\" is required")
		}
	case "int64Value":
		if u.int64Value == nil {
			return fmt.Errorf("field \"int64Value\" is required")
		}
	case "arrayValue":
		if u.arrayValue == nil {
			return fmt.Errorf("field \"arrayValue\" is required")
		}
	case "structValue":
		if u.structValue == nil {
			return fmt.Errorf("field \"structValue\" is required")
		}
	}
	return nil
}

func (u Value) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Value) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Value) AcceptFuncs(stringValueFunc func(string) error, float64ValueFunc func(float64) error, int64ValueFunc func(string) error, arrayValueFunc func([]*Value) error, structValueFunc func(interface{}) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "stringValue":
		if u.stringValue == nil {
			return fmt.Errorf("field \"stringValue\" is required")
		}
		return stringValueFunc(*u.stringValue)
	case "float64Value":
		if u.float64Value == nil {
			return fmt.Errorf("field \"float64Value\" is required")
		}
		return float64ValueFunc(*u.float64Value)
	case "int64Value":
		if u.int64Value == nil {
			return fmt.Errorf("field \"int64Value\" is required")
		}
		return int64ValueFunc(*u.int64Value)
	case "arrayValue":
		if u.arrayValue == nil {
			return fmt.Errorf("field \"arrayValue\" is required")
		}
		return arrayValueFunc(*u.arrayValue)
	case "structValue":
		if u.structValue == nil {
			return fmt.Errorf("field \"structValue\" is required")
		}
		return structValueFunc(*u.structValue)
	}
}

func (u *Value) StringValueNoopSuccess(string) error {
	return nil
}

func (u *Value) Float64ValueNoopSuccess(float64) error {
	return nil
}

func (u *Value) Int64ValueNoopSuccess(string) error {
	return nil
}

func (u *Value) ArrayValueNoopSuccess([]*Value) error {
	return nil
}

func (u *Value) StructValueNoopSuccess(interface{}) error {
	return nil
}

func (u *Value) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Value) Accept(v ValueVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "stringValue":
		if u.stringValue == nil {
			return fmt.Errorf("field \"stringValue\" is required")
		}
		return v.VisitStringValue(*u.stringValue)
	case "float64Value":
		if u.float64Value == nil {
			return fmt.Errorf("field \"float64Value\" is required")
		}
		return v.VisitFloat64Value(*u.float64Value)
	case "int64Value":
		if u.int64Value == nil {
			return fmt.Errorf("field \"int64Value\" is required")
		}
		return v.VisitInt64Value(*u.int64Value)
	case "arrayValue":
		if u.arrayValue == nil {
			return fmt.Errorf("field \"arrayValue\" is required")
		}
		return v.VisitArrayValue(*u.arrayValue)
	case "structValue":
		if u.structValue == nil {
			return fmt.Errorf("field \"structValue\" is required")
		}
		return v.VisitStructValue(*u.structValue)
	}
}

type ValueVisitor interface {
	VisitStringValue(v string) error
	VisitFloat64Value(v float64) error
	VisitInt64Value(v string) error
	VisitArrayValue(v []*Value) error
	VisitStructValue(v interface{}) error
	VisitUnknown(typeName string) error
}

func (u *Value) AcceptWithContext(ctx context.Context, v ValueVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "stringValue":
		if u.stringValue == nil {
			return fmt.Errorf("field \"stringValue\" is required")
		}
		return v.VisitStringValueWithContext(ctx, *u.stringValue)
	case "float64Value":
		if u.float64Value == nil {
			return fmt.Errorf("field \"float64Value\" is required")
		}
		return v.VisitFloat64ValueWithContext(ctx, *u.float64Value)
	case "int64Value":
		if u.int64Value == nil {
			return fmt.Errorf("field \"int64Value\" is required")
		}
		return v.VisitInt64ValueWithContext(ctx, *u.int64Value)
	case "arrayValue":
		if u.arrayValue == nil {
			return fmt.Errorf("field \"arrayValue\" is required")
		}
		return v.VisitArrayValueWithContext(ctx, *u.arrayValue)
	case "structValue":
		if u.structValue == nil {
			return fmt.Errorf("field \"structValue\" is required")
		}
		return v.VisitStructValueWithContext(ctx, *u.structValue)
	}
}

type ValueVisitorWithContext interface {
	VisitStringValueWithContext(ctx context.Context, v string) error
	VisitFloat64ValueWithContext(ctx context.Context, v float64) error
	VisitInt64ValueWithContext(ctx context.Context, v string) error
	VisitArrayValueWithContext(ctx context.Context, v []*Value) error
	VisitStructValueWithContext(ctx context.Context, v interface{}) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewValueFromStringValue(v string) Value {
	return Value{typ: "stringValue", stringValue: &v}
}

func NewValueFromFloat64Value(v float64) Value {
	return Value{typ: "float64Value", float64Value: &v}
}

func NewValueFromInt64Value(v string) Value {
	return Value{typ: "int64Value", int64Value: &v}
}

func NewValueFromArrayValue(v []*Value) Value {
	return Value{typ: "arrayValue", arrayValue: &v}
}

func NewValueFromStructValue(v interface{}) Value {
	return Value{typ: "structValue", structValue: &v}
}
