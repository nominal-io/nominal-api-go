// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/scout/run/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/units/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type ArraySeries struct {
	typ       string
	numeric1d *Numeric1dArraySeries
	enum1d    *Enum1dArraySeries
}

type arraySeriesDeserializer struct {
	Type      string                `json:"type"`
	Numeric1d *Numeric1dArraySeries `json:"numeric1d"`
	Enum1d    *Enum1dArraySeries    `json:"enum1d"`
}

func (u *arraySeriesDeserializer) toStruct() ArraySeries {
	return ArraySeries{typ: u.Type, numeric1d: u.Numeric1d, enum1d: u.Enum1d}
}

func (u *ArraySeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return nil, fmt.Errorf("field \"numeric1d\" is required")
		}
		return struct {
			Type      string               `json:"type"`
			Numeric1d Numeric1dArraySeries `json:"numeric1d"`
		}{Type: "numeric1d", Numeric1d: *u.numeric1d}, nil
	case "enum1d":
		if u.enum1d == nil {
			return nil, fmt.Errorf("field \"enum1d\" is required")
		}
		return struct {
			Type   string            `json:"type"`
			Enum1d Enum1dArraySeries `json:"enum1d"`
		}{Type: "enum1d", Enum1d: *u.enum1d}, nil
	}
}

func (u ArraySeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ArraySeries) UnmarshalJSON(data []byte) error {
	var deser arraySeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
	}
	return nil
}

func (u ArraySeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ArraySeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ArraySeries) AcceptFuncs(numeric1dFunc func(Numeric1dArraySeries) error, enum1dFunc func(Enum1dArraySeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
		return numeric1dFunc(*u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
		return enum1dFunc(*u.enum1d)
	}
}

func (u *ArraySeries) Numeric1dNoopSuccess(Numeric1dArraySeries) error {
	return nil
}

func (u *ArraySeries) Enum1dNoopSuccess(Enum1dArraySeries) error {
	return nil
}

func (u *ArraySeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ArraySeries) Accept(v ArraySeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
		return v.VisitNumeric1d(*u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
		return v.VisitEnum1d(*u.enum1d)
	}
}

type ArraySeriesVisitor interface {
	VisitNumeric1d(v Numeric1dArraySeries) error
	VisitEnum1d(v Enum1dArraySeries) error
	VisitUnknown(typeName string) error
}

func (u *ArraySeries) AcceptWithContext(ctx context.Context, v ArraySeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
		return v.VisitNumeric1dWithContext(ctx, *u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
		return v.VisitEnum1dWithContext(ctx, *u.enum1d)
	}
}

type ArraySeriesVisitorWithContext interface {
	VisitNumeric1dWithContext(ctx context.Context, v Numeric1dArraySeries) error
	VisitEnum1dWithContext(ctx context.Context, v Enum1dArraySeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewArraySeriesFromNumeric1d(v Numeric1dArraySeries) ArraySeries {
	return ArraySeries{typ: "numeric1d", numeric1d: &v}
}

func NewArraySeriesFromEnum1d(v Enum1dArraySeries) ArraySeries {
	return ArraySeries{typ: "enum1d", enum1d: &v}
}

type ArrowArrayPlot struct {
	typ             string
	pagedNumeric    *PagedNumericArrayPlot
	pagedEnum       *PagedEnumArrayPlot
	bucketedNumeric *BucketedNumericArrayPlot
	bucketedEnum    *BucketedEnumArrayPlot
}

type arrowArrayPlotDeserializer struct {
	Type            string                    `json:"type"`
	PagedNumeric    *PagedNumericArrayPlot    `json:"pagedNumeric"`
	PagedEnum       *PagedEnumArrayPlot       `json:"pagedEnum"`
	BucketedNumeric *BucketedNumericArrayPlot `json:"bucketedNumeric"`
	BucketedEnum    *BucketedEnumArrayPlot    `json:"bucketedEnum"`
}

func (u *arrowArrayPlotDeserializer) toStruct() ArrowArrayPlot {
	return ArrowArrayPlot{typ: u.Type, pagedNumeric: u.PagedNumeric, pagedEnum: u.PagedEnum, bucketedNumeric: u.BucketedNumeric, bucketedEnum: u.BucketedEnum}
}

func (u *ArrowArrayPlot) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "pagedNumeric":
		if u.pagedNumeric == nil {
			return nil, fmt.Errorf("field \"pagedNumeric\" is required")
		}
		return struct {
			Type         string                `json:"type"`
			PagedNumeric PagedNumericArrayPlot `json:"pagedNumeric"`
		}{Type: "pagedNumeric", PagedNumeric: *u.pagedNumeric}, nil
	case "pagedEnum":
		if u.pagedEnum == nil {
			return nil, fmt.Errorf("field \"pagedEnum\" is required")
		}
		return struct {
			Type      string             `json:"type"`
			PagedEnum PagedEnumArrayPlot `json:"pagedEnum"`
		}{Type: "pagedEnum", PagedEnum: *u.pagedEnum}, nil
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return nil, fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return struct {
			Type            string                   `json:"type"`
			BucketedNumeric BucketedNumericArrayPlot `json:"bucketedNumeric"`
		}{Type: "bucketedNumeric", BucketedNumeric: *u.bucketedNumeric}, nil
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return nil, fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return struct {
			Type         string                `json:"type"`
			BucketedEnum BucketedEnumArrayPlot `json:"bucketedEnum"`
		}{Type: "bucketedEnum", BucketedEnum: *u.bucketedEnum}, nil
	}
}

func (u ArrowArrayPlot) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ArrowArrayPlot) UnmarshalJSON(data []byte) error {
	var deser arrowArrayPlotDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "pagedNumeric":
		if u.pagedNumeric == nil {
			return fmt.Errorf("field \"pagedNumeric\" is required")
		}
	case "pagedEnum":
		if u.pagedEnum == nil {
			return fmt.Errorf("field \"pagedEnum\" is required")
		}
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
	}
	return nil
}

func (u ArrowArrayPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ArrowArrayPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ArrowArrayPlot) AcceptFuncs(pagedNumericFunc func(PagedNumericArrayPlot) error, pagedEnumFunc func(PagedEnumArrayPlot) error, bucketedNumericFunc func(BucketedNumericArrayPlot) error, bucketedEnumFunc func(BucketedEnumArrayPlot) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pagedNumeric":
		if u.pagedNumeric == nil {
			return fmt.Errorf("field \"pagedNumeric\" is required")
		}
		return pagedNumericFunc(*u.pagedNumeric)
	case "pagedEnum":
		if u.pagedEnum == nil {
			return fmt.Errorf("field \"pagedEnum\" is required")
		}
		return pagedEnumFunc(*u.pagedEnum)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return bucketedNumericFunc(*u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return bucketedEnumFunc(*u.bucketedEnum)
	}
}

func (u *ArrowArrayPlot) PagedNumericNoopSuccess(PagedNumericArrayPlot) error {
	return nil
}

func (u *ArrowArrayPlot) PagedEnumNoopSuccess(PagedEnumArrayPlot) error {
	return nil
}

func (u *ArrowArrayPlot) BucketedNumericNoopSuccess(BucketedNumericArrayPlot) error {
	return nil
}

func (u *ArrowArrayPlot) BucketedEnumNoopSuccess(BucketedEnumArrayPlot) error {
	return nil
}

func (u *ArrowArrayPlot) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ArrowArrayPlot) Accept(v ArrowArrayPlotVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "pagedNumeric":
		if u.pagedNumeric == nil {
			return fmt.Errorf("field \"pagedNumeric\" is required")
		}
		return v.VisitPagedNumeric(*u.pagedNumeric)
	case "pagedEnum":
		if u.pagedEnum == nil {
			return fmt.Errorf("field \"pagedEnum\" is required")
		}
		return v.VisitPagedEnum(*u.pagedEnum)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumeric(*u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnum(*u.bucketedEnum)
	}
}

type ArrowArrayPlotVisitor interface {
	VisitPagedNumeric(v PagedNumericArrayPlot) error
	VisitPagedEnum(v PagedEnumArrayPlot) error
	VisitBucketedNumeric(v BucketedNumericArrayPlot) error
	VisitBucketedEnum(v BucketedEnumArrayPlot) error
	VisitUnknown(typeName string) error
}

func (u *ArrowArrayPlot) AcceptWithContext(ctx context.Context, v ArrowArrayPlotVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "pagedNumeric":
		if u.pagedNumeric == nil {
			return fmt.Errorf("field \"pagedNumeric\" is required")
		}
		return v.VisitPagedNumericWithContext(ctx, *u.pagedNumeric)
	case "pagedEnum":
		if u.pagedEnum == nil {
			return fmt.Errorf("field \"pagedEnum\" is required")
		}
		return v.VisitPagedEnumWithContext(ctx, *u.pagedEnum)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumericWithContext(ctx, *u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnumWithContext(ctx, *u.bucketedEnum)
	}
}

type ArrowArrayPlotVisitorWithContext interface {
	VisitPagedNumericWithContext(ctx context.Context, v PagedNumericArrayPlot) error
	VisitPagedEnumWithContext(ctx context.Context, v PagedEnumArrayPlot) error
	VisitBucketedNumericWithContext(ctx context.Context, v BucketedNumericArrayPlot) error
	VisitBucketedEnumWithContext(ctx context.Context, v BucketedEnumArrayPlot) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewArrowArrayPlotFromPagedNumeric(v PagedNumericArrayPlot) ArrowArrayPlot {
	return ArrowArrayPlot{typ: "pagedNumeric", pagedNumeric: &v}
}

func NewArrowArrayPlotFromPagedEnum(v PagedEnumArrayPlot) ArrowArrayPlot {
	return ArrowArrayPlot{typ: "pagedEnum", pagedEnum: &v}
}

func NewArrowArrayPlotFromBucketedNumeric(v BucketedNumericArrayPlot) ArrowArrayPlot {
	return ArrowArrayPlot{typ: "bucketedNumeric", bucketedNumeric: &v}
}

func NewArrowArrayPlotFromBucketedEnum(v BucketedEnumArrayPlot) ArrowArrayPlot {
	return ArrowArrayPlot{typ: "bucketedEnum", bucketedEnum: &v}
}

type BitOperationFunction struct {
	typ        string
	and        *BitAndFunction
	or         *BitOrFunction
	xor        *BitXorFunction
	shiftRight *BitShiftRightFunction
	shiftLeft  *BitShiftLeftFunction
	bitTest    *BitTestFunction
}

type bitOperationFunctionDeserializer struct {
	Type       string                 `json:"type"`
	And        *BitAndFunction        `json:"and"`
	Or         *BitOrFunction         `json:"or"`
	Xor        *BitXorFunction        `json:"xor"`
	ShiftRight *BitShiftRightFunction `json:"shiftRight"`
	ShiftLeft  *BitShiftLeftFunction  `json:"shiftLeft"`
	BitTest    *BitTestFunction       `json:"bitTest"`
}

func (u *bitOperationFunctionDeserializer) toStruct() BitOperationFunction {
	return BitOperationFunction{typ: u.Type, and: u.And, or: u.Or, xor: u.Xor, shiftRight: u.ShiftRight, shiftLeft: u.ShiftLeft, bitTest: u.BitTest}
}

func (u *BitOperationFunction) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string         `json:"type"`
			And  BitAndFunction `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Or   BitOrFunction `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "xor":
		if u.xor == nil {
			return nil, fmt.Errorf("field \"xor\" is required")
		}
		return struct {
			Type string         `json:"type"`
			Xor  BitXorFunction `json:"xor"`
		}{Type: "xor", Xor: *u.xor}, nil
	case "shiftRight":
		if u.shiftRight == nil {
			return nil, fmt.Errorf("field \"shiftRight\" is required")
		}
		return struct {
			Type       string                `json:"type"`
			ShiftRight BitShiftRightFunction `json:"shiftRight"`
		}{Type: "shiftRight", ShiftRight: *u.shiftRight}, nil
	case "shiftLeft":
		if u.shiftLeft == nil {
			return nil, fmt.Errorf("field \"shiftLeft\" is required")
		}
		return struct {
			Type      string               `json:"type"`
			ShiftLeft BitShiftLeftFunction `json:"shiftLeft"`
		}{Type: "shiftLeft", ShiftLeft: *u.shiftLeft}, nil
	case "bitTest":
		if u.bitTest == nil {
			return nil, fmt.Errorf("field \"bitTest\" is required")
		}
		return struct {
			Type    string          `json:"type"`
			BitTest BitTestFunction `json:"bitTest"`
		}{Type: "bitTest", BitTest: *u.bitTest}, nil
	}
}

func (u BitOperationFunction) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *BitOperationFunction) UnmarshalJSON(data []byte) error {
	var deser bitOperationFunctionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "xor":
		if u.xor == nil {
			return fmt.Errorf("field \"xor\" is required")
		}
	case "shiftRight":
		if u.shiftRight == nil {
			return fmt.Errorf("field \"shiftRight\" is required")
		}
	case "shiftLeft":
		if u.shiftLeft == nil {
			return fmt.Errorf("field \"shiftLeft\" is required")
		}
	case "bitTest":
		if u.bitTest == nil {
			return fmt.Errorf("field \"bitTest\" is required")
		}
	}
	return nil
}

func (u BitOperationFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *BitOperationFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *BitOperationFunction) AcceptFuncs(andFunc func(BitAndFunction) error, orFunc func(BitOrFunction) error, xorFunc func(BitXorFunction) error, shiftRightFunc func(BitShiftRightFunction) error, shiftLeftFunc func(BitShiftLeftFunction) error, bitTestFunc func(BitTestFunction) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "xor":
		if u.xor == nil {
			return fmt.Errorf("field \"xor\" is required")
		}
		return xorFunc(*u.xor)
	case "shiftRight":
		if u.shiftRight == nil {
			return fmt.Errorf("field \"shiftRight\" is required")
		}
		return shiftRightFunc(*u.shiftRight)
	case "shiftLeft":
		if u.shiftLeft == nil {
			return fmt.Errorf("field \"shiftLeft\" is required")
		}
		return shiftLeftFunc(*u.shiftLeft)
	case "bitTest":
		if u.bitTest == nil {
			return fmt.Errorf("field \"bitTest\" is required")
		}
		return bitTestFunc(*u.bitTest)
	}
}

func (u *BitOperationFunction) AndNoopSuccess(BitAndFunction) error {
	return nil
}

func (u *BitOperationFunction) OrNoopSuccess(BitOrFunction) error {
	return nil
}

func (u *BitOperationFunction) XorNoopSuccess(BitXorFunction) error {
	return nil
}

func (u *BitOperationFunction) ShiftRightNoopSuccess(BitShiftRightFunction) error {
	return nil
}

func (u *BitOperationFunction) ShiftLeftNoopSuccess(BitShiftLeftFunction) error {
	return nil
}

func (u *BitOperationFunction) BitTestNoopSuccess(BitTestFunction) error {
	return nil
}

func (u *BitOperationFunction) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *BitOperationFunction) Accept(v BitOperationFunctionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "xor":
		if u.xor == nil {
			return fmt.Errorf("field \"xor\" is required")
		}
		return v.VisitXor(*u.xor)
	case "shiftRight":
		if u.shiftRight == nil {
			return fmt.Errorf("field \"shiftRight\" is required")
		}
		return v.VisitShiftRight(*u.shiftRight)
	case "shiftLeft":
		if u.shiftLeft == nil {
			return fmt.Errorf("field \"shiftLeft\" is required")
		}
		return v.VisitShiftLeft(*u.shiftLeft)
	case "bitTest":
		if u.bitTest == nil {
			return fmt.Errorf("field \"bitTest\" is required")
		}
		return v.VisitBitTest(*u.bitTest)
	}
}

type BitOperationFunctionVisitor interface {
	VisitAnd(v BitAndFunction) error
	VisitOr(v BitOrFunction) error
	VisitXor(v BitXorFunction) error
	VisitShiftRight(v BitShiftRightFunction) error
	VisitShiftLeft(v BitShiftLeftFunction) error
	VisitBitTest(v BitTestFunction) error
	VisitUnknown(typeName string) error
}

func (u *BitOperationFunction) AcceptWithContext(ctx context.Context, v BitOperationFunctionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "xor":
		if u.xor == nil {
			return fmt.Errorf("field \"xor\" is required")
		}
		return v.VisitXorWithContext(ctx, *u.xor)
	case "shiftRight":
		if u.shiftRight == nil {
			return fmt.Errorf("field \"shiftRight\" is required")
		}
		return v.VisitShiftRightWithContext(ctx, *u.shiftRight)
	case "shiftLeft":
		if u.shiftLeft == nil {
			return fmt.Errorf("field \"shiftLeft\" is required")
		}
		return v.VisitShiftLeftWithContext(ctx, *u.shiftLeft)
	case "bitTest":
		if u.bitTest == nil {
			return fmt.Errorf("field \"bitTest\" is required")
		}
		return v.VisitBitTestWithContext(ctx, *u.bitTest)
	}
}

type BitOperationFunctionVisitorWithContext interface {
	VisitAndWithContext(ctx context.Context, v BitAndFunction) error
	VisitOrWithContext(ctx context.Context, v BitOrFunction) error
	VisitXorWithContext(ctx context.Context, v BitXorFunction) error
	VisitShiftRightWithContext(ctx context.Context, v BitShiftRightFunction) error
	VisitShiftLeftWithContext(ctx context.Context, v BitShiftLeftFunction) error
	VisitBitTestWithContext(ctx context.Context, v BitTestFunction) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewBitOperationFunctionFromAnd(v BitAndFunction) BitOperationFunction {
	return BitOperationFunction{typ: "and", and: &v}
}

func NewBitOperationFunctionFromOr(v BitOrFunction) BitOperationFunction {
	return BitOperationFunction{typ: "or", or: &v}
}

func NewBitOperationFunctionFromXor(v BitXorFunction) BitOperationFunction {
	return BitOperationFunction{typ: "xor", xor: &v}
}

func NewBitOperationFunctionFromShiftRight(v BitShiftRightFunction) BitOperationFunction {
	return BitOperationFunction{typ: "shiftRight", shiftRight: &v}
}

func NewBitOperationFunctionFromShiftLeft(v BitShiftLeftFunction) BitOperationFunction {
	return BitOperationFunction{typ: "shiftLeft", shiftLeft: &v}
}

func NewBitOperationFunctionFromBitTest(v BitTestFunction) BitOperationFunction {
	return BitOperationFunction{typ: "bitTest", bitTest: &v}
}

type BucketedGeoPlot struct {
	typ       string
	timeBased *TimeBucketedGeoPlot
}

type bucketedGeoPlotDeserializer struct {
	Type      string               `json:"type"`
	TimeBased *TimeBucketedGeoPlot `json:"timeBased"`
}

func (u *bucketedGeoPlotDeserializer) toStruct() BucketedGeoPlot {
	return BucketedGeoPlot{typ: u.Type, timeBased: u.TimeBased}
}

func (u *BucketedGeoPlot) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timeBased":
		if u.timeBased == nil {
			return nil, fmt.Errorf("field \"timeBased\" is required")
		}
		return struct {
			Type      string              `json:"type"`
			TimeBased TimeBucketedGeoPlot `json:"timeBased"`
		}{Type: "timeBased", TimeBased: *u.timeBased}, nil
	}
}

func (u BucketedGeoPlot) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *BucketedGeoPlot) UnmarshalJSON(data []byte) error {
	var deser bucketedGeoPlotDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timeBased":
		if u.timeBased == nil {
			return fmt.Errorf("field \"timeBased\" is required")
		}
	}
	return nil
}

func (u BucketedGeoPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *BucketedGeoPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *BucketedGeoPlot) AcceptFuncs(timeBasedFunc func(TimeBucketedGeoPlot) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timeBased":
		if u.timeBased == nil {
			return fmt.Errorf("field \"timeBased\" is required")
		}
		return timeBasedFunc(*u.timeBased)
	}
}

func (u *BucketedGeoPlot) TimeBasedNoopSuccess(TimeBucketedGeoPlot) error {
	return nil
}

func (u *BucketedGeoPlot) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *BucketedGeoPlot) Accept(v BucketedGeoPlotVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timeBased":
		if u.timeBased == nil {
			return fmt.Errorf("field \"timeBased\" is required")
		}
		return v.VisitTimeBased(*u.timeBased)
	}
}

type BucketedGeoPlotVisitor interface {
	VisitTimeBased(v TimeBucketedGeoPlot) error
	VisitUnknown(typeName string) error
}

func (u *BucketedGeoPlot) AcceptWithContext(ctx context.Context, v BucketedGeoPlotVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timeBased":
		if u.timeBased == nil {
			return fmt.Errorf("field \"timeBased\" is required")
		}
		return v.VisitTimeBasedWithContext(ctx, *u.timeBased)
	}
}

type BucketedGeoPlotVisitorWithContext interface {
	VisitTimeBasedWithContext(ctx context.Context, v TimeBucketedGeoPlot) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewBucketedGeoPlotFromTimeBased(v TimeBucketedGeoPlot) BucketedGeoPlot {
	return BucketedGeoPlot{typ: "timeBased", timeBased: &v}
}

type Cartesian struct {
	typ     string
	scatter *Scatter
}

type cartesianDeserializer struct {
	Type    string   `json:"type"`
	Scatter *Scatter `json:"scatter"`
}

func (u *cartesianDeserializer) toStruct() Cartesian {
	return Cartesian{typ: u.Type, scatter: u.Scatter}
}

func (u *Cartesian) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "scatter":
		if u.scatter == nil {
			return nil, fmt.Errorf("field \"scatter\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Scatter Scatter `json:"scatter"`
		}{Type: "scatter", Scatter: *u.scatter}, nil
	}
}

func (u Cartesian) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Cartesian) UnmarshalJSON(data []byte) error {
	var deser cartesianDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
	}
	return nil
}

func (u Cartesian) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Cartesian) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Cartesian) AcceptFuncs(scatterFunc func(Scatter) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *Cartesian) ScatterNoopSuccess(Scatter) error {
	return nil
}

func (u *Cartesian) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Cartesian) Accept(v CartesianVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(*u.scatter)
	}
}

type CartesianVisitor interface {
	VisitScatter(v Scatter) error
	VisitUnknown(typeName string) error
}

func (u *Cartesian) AcceptWithContext(ctx context.Context, v CartesianVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatterWithContext(ctx, *u.scatter)
	}
}

type CartesianVisitorWithContext interface {
	VisitScatterWithContext(ctx context.Context, v Scatter) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCartesianFromScatter(v Scatter) Cartesian {
	return Cartesian{typ: "scatter", scatter: &v}
}

type Cartesian3d struct {
	typ       string
	scatter3d *Scatter3d
}

type cartesian3dDeserializer struct {
	Type      string     `json:"type"`
	Scatter3d *Scatter3d `json:"scatter3d"`
}

func (u *cartesian3dDeserializer) toStruct() Cartesian3d {
	return Cartesian3d{typ: u.Type, scatter3d: u.Scatter3d}
}

func (u *Cartesian3d) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return nil, fmt.Errorf("field \"scatter3d\" is required")
		}
		return struct {
			Type      string    `json:"type"`
			Scatter3d Scatter3d `json:"scatter3d"`
		}{Type: "scatter3d", Scatter3d: *u.scatter3d}, nil
	}
}

func (u Cartesian3d) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Cartesian3d) UnmarshalJSON(data []byte) error {
	var deser cartesian3dDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
	}
	return nil
}

func (u Cartesian3d) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Cartesian3d) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Cartesian3d) AcceptFuncs(scatter3dFunc func(Scatter3d) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return scatter3dFunc(*u.scatter3d)
	}
}

func (u *Cartesian3d) Scatter3dNoopSuccess(Scatter3d) error {
	return nil
}

func (u *Cartesian3d) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Cartesian3d) Accept(v Cartesian3dVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3d(*u.scatter3d)
	}
}

type Cartesian3dVisitor interface {
	VisitScatter3d(v Scatter3d) error
	VisitUnknown(typeName string) error
}

func (u *Cartesian3d) AcceptWithContext(ctx context.Context, v Cartesian3dVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3dWithContext(ctx, *u.scatter3d)
	}
}

type Cartesian3dVisitorWithContext interface {
	VisitScatter3dWithContext(ctx context.Context, v Scatter3d) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCartesian3dFromScatter3d(v Scatter3d) Cartesian3d {
	return Cartesian3d{typ: "scatter3d", scatter3d: &v}
}

type ChannelSeries struct {
	typ        string
	dataSource *DataSourceChannel
	asset      *AssetChannel
	run        *RunChannel
}

type channelSeriesDeserializer struct {
	Type       string             `json:"type"`
	DataSource *DataSourceChannel `json:"dataSource"`
	Asset      *AssetChannel      `json:"asset"`
	Run        *RunChannel        `json:"run"`
}

func (u *channelSeriesDeserializer) toStruct() ChannelSeries {
	return ChannelSeries{typ: u.Type, dataSource: u.DataSource, asset: u.Asset, run: u.Run}
}

func (u *ChannelSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "dataSource":
		if u.dataSource == nil {
			return nil, fmt.Errorf("field \"dataSource\" is required")
		}
		return struct {
			Type       string            `json:"type"`
			DataSource DataSourceChannel `json:"dataSource"`
		}{Type: "dataSource", DataSource: *u.dataSource}, nil
	case "asset":
		if u.asset == nil {
			return nil, fmt.Errorf("field \"asset\" is required")
		}
		return struct {
			Type  string       `json:"type"`
			Asset AssetChannel `json:"asset"`
		}{Type: "asset", Asset: *u.asset}, nil
	case "run":
		if u.run == nil {
			return nil, fmt.Errorf("field \"run\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Run  RunChannel `json:"run"`
		}{Type: "run", Run: *u.run}, nil
	}
}

func (u ChannelSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ChannelSeries) UnmarshalJSON(data []byte) error {
	var deser channelSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
	}
	return nil
}

func (u ChannelSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ChannelSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ChannelSeries) AcceptFuncs(dataSourceFunc func(DataSourceChannel) error, assetFunc func(AssetChannel) error, runFunc func(RunChannel) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return dataSourceFunc(*u.dataSource)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return assetFunc(*u.asset)
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
		return runFunc(*u.run)
	}
}

func (u *ChannelSeries) DataSourceNoopSuccess(DataSourceChannel) error {
	return nil
}

func (u *ChannelSeries) AssetNoopSuccess(AssetChannel) error {
	return nil
}

func (u *ChannelSeries) RunNoopSuccess(RunChannel) error {
	return nil
}

func (u *ChannelSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ChannelSeries) Accept(v ChannelSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return v.VisitDataSource(*u.dataSource)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAsset(*u.asset)
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
		return v.VisitRun(*u.run)
	}
}

type ChannelSeriesVisitor interface {
	VisitDataSource(v DataSourceChannel) error
	VisitAsset(v AssetChannel) error
	VisitRun(v RunChannel) error
	VisitUnknown(typeName string) error
}

func (u *ChannelSeries) AcceptWithContext(ctx context.Context, v ChannelSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return v.VisitDataSourceWithContext(ctx, *u.dataSource)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAssetWithContext(ctx, *u.asset)
	case "run":
		if u.run == nil {
			return fmt.Errorf("field \"run\" is required")
		}
		return v.VisitRunWithContext(ctx, *u.run)
	}
}

type ChannelSeriesVisitorWithContext interface {
	VisitDataSourceWithContext(ctx context.Context, v DataSourceChannel) error
	VisitAssetWithContext(ctx context.Context, v AssetChannel) error
	VisitRunWithContext(ctx context.Context, v RunChannel) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewChannelSeriesFromDataSource(v DataSourceChannel) ChannelSeries {
	return ChannelSeries{typ: "dataSource", dataSource: &v}
}

func NewChannelSeriesFromAsset(v AssetChannel) ChannelSeries {
	return ChannelSeries{typ: "asset", asset: &v}
}

func NewChannelSeriesFromRun(v RunChannel) ChannelSeries {
	return ChannelSeries{typ: "run", run: &v}
}

type ComputableNode struct {
	typ         string
	ranges      *SummarizeRanges
	series      *SummarizeSeries
	value       *SelectValue
	cartesian   *SummarizeCartesian
	cartesian3d *SummarizeCartesian3d
	frequency   *FrequencyDomain
	histogram   *Histogram
	geo         *SummarizeGeo
	curve       *CurveFit
}

type computableNodeDeserializer struct {
	Type        string                `json:"type"`
	Ranges      *SummarizeRanges      `json:"ranges"`
	Series      *SummarizeSeries      `json:"series"`
	Value       *SelectValue          `json:"value"`
	Cartesian   *SummarizeCartesian   `json:"cartesian"`
	Cartesian3d *SummarizeCartesian3d `json:"cartesian3d"`
	Frequency   *FrequencyDomain      `json:"frequency"`
	Histogram   *Histogram            `json:"histogram"`
	Geo         *SummarizeGeo         `json:"geo"`
	Curve       *CurveFit             `json:"curve"`
}

func (u *computableNodeDeserializer) toStruct() ComputableNode {
	return ComputableNode{typ: u.Type, ranges: u.Ranges, series: u.Series, value: u.Value, cartesian: u.Cartesian, cartesian3d: u.Cartesian3d, frequency: u.Frequency, histogram: u.Histogram, geo: u.Geo, curve: u.Curve}
}

func (u *ComputableNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "ranges":
		if u.ranges == nil {
			return nil, fmt.Errorf("field \"ranges\" is required")
		}
		return struct {
			Type   string          `json:"type"`
			Ranges SummarizeRanges `json:"ranges"`
		}{Type: "ranges", Ranges: *u.ranges}, nil
	case "series":
		if u.series == nil {
			return nil, fmt.Errorf("field \"series\" is required")
		}
		return struct {
			Type   string          `json:"type"`
			Series SummarizeSeries `json:"series"`
		}{Type: "series", Series: *u.series}, nil
	case "value":
		if u.value == nil {
			return nil, fmt.Errorf("field \"value\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Value SelectValue `json:"value"`
		}{Type: "value", Value: *u.value}, nil
	case "cartesian":
		if u.cartesian == nil {
			return nil, fmt.Errorf("field \"cartesian\" is required")
		}
		return struct {
			Type      string             `json:"type"`
			Cartesian SummarizeCartesian `json:"cartesian"`
		}{Type: "cartesian", Cartesian: *u.cartesian}, nil
	case "cartesian3d":
		if u.cartesian3d == nil {
			return nil, fmt.Errorf("field \"cartesian3d\" is required")
		}
		return struct {
			Type        string               `json:"type"`
			Cartesian3d SummarizeCartesian3d `json:"cartesian3d"`
		}{Type: "cartesian3d", Cartesian3d: *u.cartesian3d}, nil
	case "frequency":
		if u.frequency == nil {
			return nil, fmt.Errorf("field \"frequency\" is required")
		}
		return struct {
			Type      string          `json:"type"`
			Frequency FrequencyDomain `json:"frequency"`
		}{Type: "frequency", Frequency: *u.frequency}, nil
	case "histogram":
		if u.histogram == nil {
			return nil, fmt.Errorf("field \"histogram\" is required")
		}
		return struct {
			Type      string    `json:"type"`
			Histogram Histogram `json:"histogram"`
		}{Type: "histogram", Histogram: *u.histogram}, nil
	case "geo":
		if u.geo == nil {
			return nil, fmt.Errorf("field \"geo\" is required")
		}
		return struct {
			Type string       `json:"type"`
			Geo  SummarizeGeo `json:"geo"`
		}{Type: "geo", Geo: *u.geo}, nil
	case "curve":
		if u.curve == nil {
			return nil, fmt.Errorf("field \"curve\" is required")
		}
		return struct {
			Type  string   `json:"type"`
			Curve CurveFit `json:"curve"`
		}{Type: "curve", Curve: *u.curve}, nil
	}
}

func (u ComputableNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputableNode) UnmarshalJSON(data []byte) error {
	var deser computableNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
	}
	return nil
}

func (u ComputableNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputableNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputableNode) AcceptFuncs(rangesFunc func(SummarizeRanges) error, seriesFunc func(SummarizeSeries) error, valueFunc func(SelectValue) error, cartesianFunc func(SummarizeCartesian) error, cartesian3dFunc func(SummarizeCartesian3d) error, frequencyFunc func(FrequencyDomain) error, histogramFunc func(Histogram) error, geoFunc func(SummarizeGeo) error, curveFunc func(CurveFit) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return cartesian3dFunc(*u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return frequencyFunc(*u.frequency)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return histogramFunc(*u.histogram)
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
		return geoFunc(*u.geo)
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
		return curveFunc(*u.curve)
	}
}

func (u *ComputableNode) RangesNoopSuccess(SummarizeRanges) error {
	return nil
}

func (u *ComputableNode) SeriesNoopSuccess(SummarizeSeries) error {
	return nil
}

func (u *ComputableNode) ValueNoopSuccess(SelectValue) error {
	return nil
}

func (u *ComputableNode) CartesianNoopSuccess(SummarizeCartesian) error {
	return nil
}

func (u *ComputableNode) Cartesian3dNoopSuccess(SummarizeCartesian3d) error {
	return nil
}

func (u *ComputableNode) FrequencyNoopSuccess(FrequencyDomain) error {
	return nil
}

func (u *ComputableNode) HistogramNoopSuccess(Histogram) error {
	return nil
}

func (u *ComputableNode) GeoNoopSuccess(SummarizeGeo) error {
	return nil
}

func (u *ComputableNode) CurveNoopSuccess(CurveFit) error {
	return nil
}

func (u *ComputableNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputableNode) Accept(v ComputableNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(*u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(*u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(*u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3d(*u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequency(*u.frequency)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogram(*u.histogram)
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
		return v.VisitGeo(*u.geo)
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
		return v.VisitCurve(*u.curve)
	}
}

type ComputableNodeVisitor interface {
	VisitRanges(v SummarizeRanges) error
	VisitSeries(v SummarizeSeries) error
	VisitValue(v SelectValue) error
	VisitCartesian(v SummarizeCartesian) error
	VisitCartesian3d(v SummarizeCartesian3d) error
	VisitFrequency(v FrequencyDomain) error
	VisitHistogram(v Histogram) error
	VisitGeo(v SummarizeGeo) error
	VisitCurve(v CurveFit) error
	VisitUnknown(typeName string) error
}

func (u *ComputableNode) AcceptWithContext(ctx context.Context, v ComputableNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRangesWithContext(ctx, *u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeriesWithContext(ctx, *u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValueWithContext(ctx, *u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesianWithContext(ctx, *u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3dWithContext(ctx, *u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequencyWithContext(ctx, *u.frequency)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogramWithContext(ctx, *u.histogram)
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
		return v.VisitGeoWithContext(ctx, *u.geo)
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
		return v.VisitCurveWithContext(ctx, *u.curve)
	}
}

type ComputableNodeVisitorWithContext interface {
	VisitRangesWithContext(ctx context.Context, v SummarizeRanges) error
	VisitSeriesWithContext(ctx context.Context, v SummarizeSeries) error
	VisitValueWithContext(ctx context.Context, v SelectValue) error
	VisitCartesianWithContext(ctx context.Context, v SummarizeCartesian) error
	VisitCartesian3dWithContext(ctx context.Context, v SummarizeCartesian3d) error
	VisitFrequencyWithContext(ctx context.Context, v FrequencyDomain) error
	VisitHistogramWithContext(ctx context.Context, v Histogram) error
	VisitGeoWithContext(ctx context.Context, v SummarizeGeo) error
	VisitCurveWithContext(ctx context.Context, v CurveFit) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputableNodeFromRanges(v SummarizeRanges) ComputableNode {
	return ComputableNode{typ: "ranges", ranges: &v}
}

func NewComputableNodeFromSeries(v SummarizeSeries) ComputableNode {
	return ComputableNode{typ: "series", series: &v}
}

func NewComputableNodeFromValue(v SelectValue) ComputableNode {
	return ComputableNode{typ: "value", value: &v}
}

func NewComputableNodeFromCartesian(v SummarizeCartesian) ComputableNode {
	return ComputableNode{typ: "cartesian", cartesian: &v}
}

func NewComputableNodeFromCartesian3d(v SummarizeCartesian3d) ComputableNode {
	return ComputableNode{typ: "cartesian3d", cartesian3d: &v}
}

func NewComputableNodeFromFrequency(v FrequencyDomain) ComputableNode {
	return ComputableNode{typ: "frequency", frequency: &v}
}

func NewComputableNodeFromHistogram(v Histogram) ComputableNode {
	return ComputableNode{typ: "histogram", histogram: &v}
}

func NewComputableNodeFromGeo(v SummarizeGeo) ComputableNode {
	return ComputableNode{typ: "geo", geo: &v}
}

func NewComputableNodeFromCurve(v CurveFit) ComputableNode {
	return ComputableNode{typ: "curve", curve: &v}
}

type ComputeEventQuery struct {
	typ                string
	searchText         *StringConstant
	after              *TimestampConstant
	before             *TimestampConstant
	advancedTimeFilter *EventTimeFilter
	asset              *StringConstant
	template           *StringConstant
	workbook           *StringConstant
	dataReview         *StringConstant
	originType         *SearchEventOriginType
	dataReviewCheck    *StringConstant
	dispositionStatus  *EventDispositionStatus
	priority           *StringConstant
	assignee           *StringConstant
	eventType          *EventType
	createdBy          *StringConstant
	label              *StringConstant
	property           *Property
	and                *[]ComputeEventQuery
	or                 *[]ComputeEventQuery
	not                *ComputeEventQuery
	workspace          *StringConstant
	procedure          *StringConstant
	procedureExecution *StringConstant
	stepId             *StringConstant
}

type computeEventQueryDeserializer struct {
	Type               string                  `json:"type"`
	SearchText         *StringConstant         `json:"searchText"`
	After              *TimestampConstant      `json:"after"`
	Before             *TimestampConstant      `json:"before"`
	AdvancedTimeFilter *EventTimeFilter        `json:"advancedTimeFilter"`
	Asset              *StringConstant         `json:"asset"`
	Template           *StringConstant         `json:"template"`
	Workbook           *StringConstant         `json:"workbook"`
	DataReview         *StringConstant         `json:"dataReview"`
	OriginType         *SearchEventOriginType  `json:"originType"`
	DataReviewCheck    *StringConstant         `json:"dataReviewCheck"`
	DispositionStatus  *EventDispositionStatus `json:"dispositionStatus"`
	Priority           *StringConstant         `json:"priority"`
	Assignee           *StringConstant         `json:"assignee"`
	EventType          *EventType              `json:"eventType"`
	CreatedBy          *StringConstant         `json:"createdBy"`
	Label              *StringConstant         `json:"label"`
	Property           *Property               `json:"property"`
	And                *[]ComputeEventQuery    `json:"and"`
	Or                 *[]ComputeEventQuery    `json:"or"`
	Not                *ComputeEventQuery      `json:"not"`
	Workspace          *StringConstant         `json:"workspace"`
	Procedure          *StringConstant         `json:"procedure"`
	ProcedureExecution *StringConstant         `json:"procedureExecution"`
	StepId             *StringConstant         `json:"stepId"`
}

func (u *computeEventQueryDeserializer) toStruct() ComputeEventQuery {
	return ComputeEventQuery{typ: u.Type, searchText: u.SearchText, after: u.After, before: u.Before, advancedTimeFilter: u.AdvancedTimeFilter, asset: u.Asset, template: u.Template, workbook: u.Workbook, dataReview: u.DataReview, originType: u.OriginType, dataReviewCheck: u.DataReviewCheck, dispositionStatus: u.DispositionStatus, priority: u.Priority, assignee: u.Assignee, eventType: u.EventType, createdBy: u.CreatedBy, label: u.Label, property: u.Property, and: u.And, or: u.Or, not: u.Not, workspace: u.Workspace, procedure: u.Procedure, procedureExecution: u.ProcedureExecution, stepId: u.StepId}
}

func (u *ComputeEventQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string         `json:"type"`
			SearchText StringConstant `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "after":
		if u.after == nil {
			return nil, fmt.Errorf("field \"after\" is required")
		}
		return struct {
			Type  string            `json:"type"`
			After TimestampConstant `json:"after"`
		}{Type: "after", After: *u.after}, nil
	case "before":
		if u.before == nil {
			return nil, fmt.Errorf("field \"before\" is required")
		}
		return struct {
			Type   string            `json:"type"`
			Before TimestampConstant `json:"before"`
		}{Type: "before", Before: *u.before}, nil
	case "advancedTimeFilter":
		if u.advancedTimeFilter == nil {
			return nil, fmt.Errorf("field \"advancedTimeFilter\" is required")
		}
		return struct {
			Type               string          `json:"type"`
			AdvancedTimeFilter EventTimeFilter `json:"advancedTimeFilter"`
		}{Type: "advancedTimeFilter", AdvancedTimeFilter: *u.advancedTimeFilter}, nil
	case "asset":
		if u.asset == nil {
			return nil, fmt.Errorf("field \"asset\" is required")
		}
		return struct {
			Type  string         `json:"type"`
			Asset StringConstant `json:"asset"`
		}{Type: "asset", Asset: *u.asset}, nil
	case "template":
		if u.template == nil {
			return nil, fmt.Errorf("field \"template\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			Template StringConstant `json:"template"`
		}{Type: "template", Template: *u.template}, nil
	case "workbook":
		if u.workbook == nil {
			return nil, fmt.Errorf("field \"workbook\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			Workbook StringConstant `json:"workbook"`
		}{Type: "workbook", Workbook: *u.workbook}, nil
	case "dataReview":
		if u.dataReview == nil {
			return nil, fmt.Errorf("field \"dataReview\" is required")
		}
		return struct {
			Type       string         `json:"type"`
			DataReview StringConstant `json:"dataReview"`
		}{Type: "dataReview", DataReview: *u.dataReview}, nil
	case "originType":
		if u.originType == nil {
			return nil, fmt.Errorf("field \"originType\" is required")
		}
		return struct {
			Type       string                `json:"type"`
			OriginType SearchEventOriginType `json:"originType"`
		}{Type: "originType", OriginType: *u.originType}, nil
	case "dataReviewCheck":
		if u.dataReviewCheck == nil {
			return nil, fmt.Errorf("field \"dataReviewCheck\" is required")
		}
		return struct {
			Type            string         `json:"type"`
			DataReviewCheck StringConstant `json:"dataReviewCheck"`
		}{Type: "dataReviewCheck", DataReviewCheck: *u.dataReviewCheck}, nil
	case "dispositionStatus":
		if u.dispositionStatus == nil {
			return nil, fmt.Errorf("field \"dispositionStatus\" is required")
		}
		return struct {
			Type              string                 `json:"type"`
			DispositionStatus EventDispositionStatus `json:"dispositionStatus"`
		}{Type: "dispositionStatus", DispositionStatus: *u.dispositionStatus}, nil
	case "priority":
		if u.priority == nil {
			return nil, fmt.Errorf("field \"priority\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			Priority StringConstant `json:"priority"`
		}{Type: "priority", Priority: *u.priority}, nil
	case "assignee":
		if u.assignee == nil {
			return nil, fmt.Errorf("field \"assignee\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			Assignee StringConstant `json:"assignee"`
		}{Type: "assignee", Assignee: *u.assignee}, nil
	case "eventType":
		if u.eventType == nil {
			return nil, fmt.Errorf("field \"eventType\" is required")
		}
		return struct {
			Type      string    `json:"type"`
			EventType EventType `json:"eventType"`
		}{Type: "eventType", EventType: *u.eventType}, nil
	case "createdBy":
		if u.createdBy == nil {
			return nil, fmt.Errorf("field \"createdBy\" is required")
		}
		return struct {
			Type      string         `json:"type"`
			CreatedBy StringConstant `json:"createdBy"`
		}{Type: "createdBy", CreatedBy: *u.createdBy}, nil
	case "label":
		if u.label == nil {
			return nil, fmt.Errorf("field \"label\" is required")
		}
		return struct {
			Type  string         `json:"type"`
			Label StringConstant `json:"label"`
		}{Type: "label", Label: *u.label}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string   `json:"type"`
			Property Property `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string              `json:"type"`
			And  []ComputeEventQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string              `json:"type"`
			Or   []ComputeEventQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string            `json:"type"`
			Not  ComputeEventQuery `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string         `json:"type"`
			Workspace StringConstant `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	case "procedure":
		if u.procedure == nil {
			return nil, fmt.Errorf("field \"procedure\" is required")
		}
		return struct {
			Type      string         `json:"type"`
			Procedure StringConstant `json:"procedure"`
		}{Type: "procedure", Procedure: *u.procedure}, nil
	case "procedureExecution":
		if u.procedureExecution == nil {
			return nil, fmt.Errorf("field \"procedureExecution\" is required")
		}
		return struct {
			Type               string         `json:"type"`
			ProcedureExecution StringConstant `json:"procedureExecution"`
		}{Type: "procedureExecution", ProcedureExecution: *u.procedureExecution}, nil
	case "stepId":
		if u.stepId == nil {
			return nil, fmt.Errorf("field \"stepId\" is required")
		}
		return struct {
			Type   string         `json:"type"`
			StepId StringConstant `json:"stepId"`
		}{Type: "stepId", StepId: *u.stepId}, nil
	}
}

func (u ComputeEventQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputeEventQuery) UnmarshalJSON(data []byte) error {
	var deser computeEventQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "after":
		if u.after == nil {
			return fmt.Errorf("field \"after\" is required")
		}
	case "before":
		if u.before == nil {
			return fmt.Errorf("field \"before\" is required")
		}
	case "advancedTimeFilter":
		if u.advancedTimeFilter == nil {
			return fmt.Errorf("field \"advancedTimeFilter\" is required")
		}
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
	case "template":
		if u.template == nil {
			return fmt.Errorf("field \"template\" is required")
		}
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
	case "dataReview":
		if u.dataReview == nil {
			return fmt.Errorf("field \"dataReview\" is required")
		}
	case "originType":
		if u.originType == nil {
			return fmt.Errorf("field \"originType\" is required")
		}
	case "dataReviewCheck":
		if u.dataReviewCheck == nil {
			return fmt.Errorf("field \"dataReviewCheck\" is required")
		}
	case "dispositionStatus":
		if u.dispositionStatus == nil {
			return fmt.Errorf("field \"dispositionStatus\" is required")
		}
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
	case "assignee":
		if u.assignee == nil {
			return fmt.Errorf("field \"assignee\" is required")
		}
	case "eventType":
		if u.eventType == nil {
			return fmt.Errorf("field \"eventType\" is required")
		}
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
	case "procedureExecution":
		if u.procedureExecution == nil {
			return fmt.Errorf("field \"procedureExecution\" is required")
		}
	case "stepId":
		if u.stepId == nil {
			return fmt.Errorf("field \"stepId\" is required")
		}
	}
	return nil
}

func (u ComputeEventQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputeEventQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputeEventQuery) AcceptFuncs(searchTextFunc func(StringConstant) error, afterFunc func(TimestampConstant) error, beforeFunc func(TimestampConstant) error, advancedTimeFilterFunc func(EventTimeFilter) error, assetFunc func(StringConstant) error, templateFunc func(StringConstant) error, workbookFunc func(StringConstant) error, dataReviewFunc func(StringConstant) error, originTypeFunc func(SearchEventOriginType) error, dataReviewCheckFunc func(StringConstant) error, dispositionStatusFunc func(EventDispositionStatus) error, priorityFunc func(StringConstant) error, assigneeFunc func(StringConstant) error, eventTypeFunc func(EventType) error, createdByFunc func(StringConstant) error, labelFunc func(StringConstant) error, propertyFunc func(Property) error, andFunc func([]ComputeEventQuery) error, orFunc func([]ComputeEventQuery) error, notFunc func(ComputeEventQuery) error, workspaceFunc func(StringConstant) error, procedureFunc func(StringConstant) error, procedureExecutionFunc func(StringConstant) error, stepIdFunc func(StringConstant) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "after":
		if u.after == nil {
			return fmt.Errorf("field \"after\" is required")
		}
		return afterFunc(*u.after)
	case "before":
		if u.before == nil {
			return fmt.Errorf("field \"before\" is required")
		}
		return beforeFunc(*u.before)
	case "advancedTimeFilter":
		if u.advancedTimeFilter == nil {
			return fmt.Errorf("field \"advancedTimeFilter\" is required")
		}
		return advancedTimeFilterFunc(*u.advancedTimeFilter)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return assetFunc(*u.asset)
	case "template":
		if u.template == nil {
			return fmt.Errorf("field \"template\" is required")
		}
		return templateFunc(*u.template)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return workbookFunc(*u.workbook)
	case "dataReview":
		if u.dataReview == nil {
			return fmt.Errorf("field \"dataReview\" is required")
		}
		return dataReviewFunc(*u.dataReview)
	case "originType":
		if u.originType == nil {
			return fmt.Errorf("field \"originType\" is required")
		}
		return originTypeFunc(*u.originType)
	case "dataReviewCheck":
		if u.dataReviewCheck == nil {
			return fmt.Errorf("field \"dataReviewCheck\" is required")
		}
		return dataReviewCheckFunc(*u.dataReviewCheck)
	case "dispositionStatus":
		if u.dispositionStatus == nil {
			return fmt.Errorf("field \"dispositionStatus\" is required")
		}
		return dispositionStatusFunc(*u.dispositionStatus)
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
		return priorityFunc(*u.priority)
	case "assignee":
		if u.assignee == nil {
			return fmt.Errorf("field \"assignee\" is required")
		}
		return assigneeFunc(*u.assignee)
	case "eventType":
		if u.eventType == nil {
			return fmt.Errorf("field \"eventType\" is required")
		}
		return eventTypeFunc(*u.eventType)
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
		return createdByFunc(*u.createdBy)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
		return procedureFunc(*u.procedure)
	case "procedureExecution":
		if u.procedureExecution == nil {
			return fmt.Errorf("field \"procedureExecution\" is required")
		}
		return procedureExecutionFunc(*u.procedureExecution)
	case "stepId":
		if u.stepId == nil {
			return fmt.Errorf("field \"stepId\" is required")
		}
		return stepIdFunc(*u.stepId)
	}
}

func (u *ComputeEventQuery) SearchTextNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) AfterNoopSuccess(TimestampConstant) error {
	return nil
}

func (u *ComputeEventQuery) BeforeNoopSuccess(TimestampConstant) error {
	return nil
}

func (u *ComputeEventQuery) AdvancedTimeFilterNoopSuccess(EventTimeFilter) error {
	return nil
}

func (u *ComputeEventQuery) AssetNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) TemplateNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) WorkbookNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) DataReviewNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) OriginTypeNoopSuccess(SearchEventOriginType) error {
	return nil
}

func (u *ComputeEventQuery) DataReviewCheckNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) DispositionStatusNoopSuccess(EventDispositionStatus) error {
	return nil
}

func (u *ComputeEventQuery) PriorityNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) AssigneeNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) EventTypeNoopSuccess(EventType) error {
	return nil
}

func (u *ComputeEventQuery) CreatedByNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) LabelNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) PropertyNoopSuccess(Property) error {
	return nil
}

func (u *ComputeEventQuery) AndNoopSuccess([]ComputeEventQuery) error {
	return nil
}

func (u *ComputeEventQuery) OrNoopSuccess([]ComputeEventQuery) error {
	return nil
}

func (u *ComputeEventQuery) NotNoopSuccess(ComputeEventQuery) error {
	return nil
}

func (u *ComputeEventQuery) WorkspaceNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) ProcedureNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) ProcedureExecutionNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) StepIdNoopSuccess(StringConstant) error {
	return nil
}

func (u *ComputeEventQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputeEventQuery) Accept(v ComputeEventQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "after":
		if u.after == nil {
			return fmt.Errorf("field \"after\" is required")
		}
		return v.VisitAfter(*u.after)
	case "before":
		if u.before == nil {
			return fmt.Errorf("field \"before\" is required")
		}
		return v.VisitBefore(*u.before)
	case "advancedTimeFilter":
		if u.advancedTimeFilter == nil {
			return fmt.Errorf("field \"advancedTimeFilter\" is required")
		}
		return v.VisitAdvancedTimeFilter(*u.advancedTimeFilter)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAsset(*u.asset)
	case "template":
		if u.template == nil {
			return fmt.Errorf("field \"template\" is required")
		}
		return v.VisitTemplate(*u.template)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return v.VisitWorkbook(*u.workbook)
	case "dataReview":
		if u.dataReview == nil {
			return fmt.Errorf("field \"dataReview\" is required")
		}
		return v.VisitDataReview(*u.dataReview)
	case "originType":
		if u.originType == nil {
			return fmt.Errorf("field \"originType\" is required")
		}
		return v.VisitOriginType(*u.originType)
	case "dataReviewCheck":
		if u.dataReviewCheck == nil {
			return fmt.Errorf("field \"dataReviewCheck\" is required")
		}
		return v.VisitDataReviewCheck(*u.dataReviewCheck)
	case "dispositionStatus":
		if u.dispositionStatus == nil {
			return fmt.Errorf("field \"dispositionStatus\" is required")
		}
		return v.VisitDispositionStatus(*u.dispositionStatus)
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
		return v.VisitPriority(*u.priority)
	case "assignee":
		if u.assignee == nil {
			return fmt.Errorf("field \"assignee\" is required")
		}
		return v.VisitAssignee(*u.assignee)
	case "eventType":
		if u.eventType == nil {
			return fmt.Errorf("field \"eventType\" is required")
		}
		return v.VisitEventType(*u.eventType)
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
		return v.VisitCreatedBy(*u.createdBy)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
		return v.VisitProcedure(*u.procedure)
	case "procedureExecution":
		if u.procedureExecution == nil {
			return fmt.Errorf("field \"procedureExecution\" is required")
		}
		return v.VisitProcedureExecution(*u.procedureExecution)
	case "stepId":
		if u.stepId == nil {
			return fmt.Errorf("field \"stepId\" is required")
		}
		return v.VisitStepId(*u.stepId)
	}
}

type ComputeEventQueryVisitor interface {
	VisitSearchText(v StringConstant) error
	VisitAfter(v TimestampConstant) error
	VisitBefore(v TimestampConstant) error
	VisitAdvancedTimeFilter(v EventTimeFilter) error
	VisitAsset(v StringConstant) error
	VisitTemplate(v StringConstant) error
	VisitWorkbook(v StringConstant) error
	VisitDataReview(v StringConstant) error
	VisitOriginType(v SearchEventOriginType) error
	VisitDataReviewCheck(v StringConstant) error
	VisitDispositionStatus(v EventDispositionStatus) error
	VisitPriority(v StringConstant) error
	VisitAssignee(v StringConstant) error
	VisitEventType(v EventType) error
	VisitCreatedBy(v StringConstant) error
	VisitLabel(v StringConstant) error
	VisitProperty(v Property) error
	VisitAnd(v []ComputeEventQuery) error
	VisitOr(v []ComputeEventQuery) error
	VisitNot(v ComputeEventQuery) error
	VisitWorkspace(v StringConstant) error
	VisitProcedure(v StringConstant) error
	VisitProcedureExecution(v StringConstant) error
	VisitStepId(v StringConstant) error
	VisitUnknown(typeName string) error
}

func (u *ComputeEventQuery) AcceptWithContext(ctx context.Context, v ComputeEventQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "after":
		if u.after == nil {
			return fmt.Errorf("field \"after\" is required")
		}
		return v.VisitAfterWithContext(ctx, *u.after)
	case "before":
		if u.before == nil {
			return fmt.Errorf("field \"before\" is required")
		}
		return v.VisitBeforeWithContext(ctx, *u.before)
	case "advancedTimeFilter":
		if u.advancedTimeFilter == nil {
			return fmt.Errorf("field \"advancedTimeFilter\" is required")
		}
		return v.VisitAdvancedTimeFilterWithContext(ctx, *u.advancedTimeFilter)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAssetWithContext(ctx, *u.asset)
	case "template":
		if u.template == nil {
			return fmt.Errorf("field \"template\" is required")
		}
		return v.VisitTemplateWithContext(ctx, *u.template)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return v.VisitWorkbookWithContext(ctx, *u.workbook)
	case "dataReview":
		if u.dataReview == nil {
			return fmt.Errorf("field \"dataReview\" is required")
		}
		return v.VisitDataReviewWithContext(ctx, *u.dataReview)
	case "originType":
		if u.originType == nil {
			return fmt.Errorf("field \"originType\" is required")
		}
		return v.VisitOriginTypeWithContext(ctx, *u.originType)
	case "dataReviewCheck":
		if u.dataReviewCheck == nil {
			return fmt.Errorf("field \"dataReviewCheck\" is required")
		}
		return v.VisitDataReviewCheckWithContext(ctx, *u.dataReviewCheck)
	case "dispositionStatus":
		if u.dispositionStatus == nil {
			return fmt.Errorf("field \"dispositionStatus\" is required")
		}
		return v.VisitDispositionStatusWithContext(ctx, *u.dispositionStatus)
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
		return v.VisitPriorityWithContext(ctx, *u.priority)
	case "assignee":
		if u.assignee == nil {
			return fmt.Errorf("field \"assignee\" is required")
		}
		return v.VisitAssigneeWithContext(ctx, *u.assignee)
	case "eventType":
		if u.eventType == nil {
			return fmt.Errorf("field \"eventType\" is required")
		}
		return v.VisitEventTypeWithContext(ctx, *u.eventType)
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
		return v.VisitCreatedByWithContext(ctx, *u.createdBy)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabelWithContext(ctx, *u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
		return v.VisitProcedureWithContext(ctx, *u.procedure)
	case "procedureExecution":
		if u.procedureExecution == nil {
			return fmt.Errorf("field \"procedureExecution\" is required")
		}
		return v.VisitProcedureExecutionWithContext(ctx, *u.procedureExecution)
	case "stepId":
		if u.stepId == nil {
			return fmt.Errorf("field \"stepId\" is required")
		}
		return v.VisitStepIdWithContext(ctx, *u.stepId)
	}
}

type ComputeEventQueryVisitorWithContext interface {
	VisitSearchTextWithContext(ctx context.Context, v StringConstant) error
	VisitAfterWithContext(ctx context.Context, v TimestampConstant) error
	VisitBeforeWithContext(ctx context.Context, v TimestampConstant) error
	VisitAdvancedTimeFilterWithContext(ctx context.Context, v EventTimeFilter) error
	VisitAssetWithContext(ctx context.Context, v StringConstant) error
	VisitTemplateWithContext(ctx context.Context, v StringConstant) error
	VisitWorkbookWithContext(ctx context.Context, v StringConstant) error
	VisitDataReviewWithContext(ctx context.Context, v StringConstant) error
	VisitOriginTypeWithContext(ctx context.Context, v SearchEventOriginType) error
	VisitDataReviewCheckWithContext(ctx context.Context, v StringConstant) error
	VisitDispositionStatusWithContext(ctx context.Context, v EventDispositionStatus) error
	VisitPriorityWithContext(ctx context.Context, v StringConstant) error
	VisitAssigneeWithContext(ctx context.Context, v StringConstant) error
	VisitEventTypeWithContext(ctx context.Context, v EventType) error
	VisitCreatedByWithContext(ctx context.Context, v StringConstant) error
	VisitLabelWithContext(ctx context.Context, v StringConstant) error
	VisitPropertyWithContext(ctx context.Context, v Property) error
	VisitAndWithContext(ctx context.Context, v []ComputeEventQuery) error
	VisitOrWithContext(ctx context.Context, v []ComputeEventQuery) error
	VisitNotWithContext(ctx context.Context, v ComputeEventQuery) error
	VisitWorkspaceWithContext(ctx context.Context, v StringConstant) error
	VisitProcedureWithContext(ctx context.Context, v StringConstant) error
	VisitProcedureExecutionWithContext(ctx context.Context, v StringConstant) error
	VisitStepIdWithContext(ctx context.Context, v StringConstant) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputeEventQueryFromSearchText(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "searchText", searchText: &v}
}

func NewComputeEventQueryFromAfter(v TimestampConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "after", after: &v}
}

func NewComputeEventQueryFromBefore(v TimestampConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "before", before: &v}
}

func NewComputeEventQueryFromAdvancedTimeFilter(v EventTimeFilter) ComputeEventQuery {
	return ComputeEventQuery{typ: "advancedTimeFilter", advancedTimeFilter: &v}
}

func NewComputeEventQueryFromAsset(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "asset", asset: &v}
}

func NewComputeEventQueryFromTemplate(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "template", template: &v}
}

func NewComputeEventQueryFromWorkbook(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "workbook", workbook: &v}
}

func NewComputeEventQueryFromDataReview(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "dataReview", dataReview: &v}
}

func NewComputeEventQueryFromOriginType(v SearchEventOriginType) ComputeEventQuery {
	return ComputeEventQuery{typ: "originType", originType: &v}
}

func NewComputeEventQueryFromDataReviewCheck(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "dataReviewCheck", dataReviewCheck: &v}
}

func NewComputeEventQueryFromDispositionStatus(v EventDispositionStatus) ComputeEventQuery {
	return ComputeEventQuery{typ: "dispositionStatus", dispositionStatus: &v}
}

func NewComputeEventQueryFromPriority(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "priority", priority: &v}
}

func NewComputeEventQueryFromAssignee(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "assignee", assignee: &v}
}

func NewComputeEventQueryFromEventType(v EventType) ComputeEventQuery {
	return ComputeEventQuery{typ: "eventType", eventType: &v}
}

func NewComputeEventQueryFromCreatedBy(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "createdBy", createdBy: &v}
}

func NewComputeEventQueryFromLabel(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "label", label: &v}
}

func NewComputeEventQueryFromProperty(v Property) ComputeEventQuery {
	return ComputeEventQuery{typ: "property", property: &v}
}

func NewComputeEventQueryFromAnd(v []ComputeEventQuery) ComputeEventQuery {
	return ComputeEventQuery{typ: "and", and: &v}
}

func NewComputeEventQueryFromOr(v []ComputeEventQuery) ComputeEventQuery {
	return ComputeEventQuery{typ: "or", or: &v}
}

func NewComputeEventQueryFromNot(v ComputeEventQuery) ComputeEventQuery {
	return ComputeEventQuery{typ: "not", not: &v}
}

func NewComputeEventQueryFromWorkspace(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "workspace", workspace: &v}
}

func NewComputeEventQueryFromProcedure(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "procedure", procedure: &v}
}

func NewComputeEventQueryFromProcedureExecution(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "procedureExecution", procedureExecution: &v}
}

func NewComputeEventQueryFromStepId(v StringConstant) ComputeEventQuery {
	return ComputeEventQuery{typ: "stepId", stepId: &v}
}

type ComputeNode struct {
	typ      string
	enum     *EnumSeries
	numeric  *NumericSeries
	log      *LogSeries
	ranges   *RangeSeries
	array    *ArraySeries
	curveFit *CurveFit
	raw      *Reference
}

type computeNodeDeserializer struct {
	Type     string         `json:"type"`
	Enum     *EnumSeries    `json:"enum"`
	Numeric  *NumericSeries `json:"numeric"`
	Log      *LogSeries     `json:"log"`
	Ranges   *RangeSeries   `json:"ranges"`
	Array    *ArraySeries   `json:"array"`
	CurveFit *CurveFit      `json:"curveFit"`
	Raw      *Reference     `json:"raw"`
}

func (u *computeNodeDeserializer) toStruct() ComputeNode {
	return ComputeNode{typ: u.Type, enum: u.Enum, numeric: u.Numeric, log: u.Log, ranges: u.Ranges, array: u.Array, curveFit: u.CurveFit, raw: u.Raw}
}

func (u *ComputeNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Enum EnumSeries `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Numeric NumericSeries `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "log":
		if u.log == nil {
			return nil, fmt.Errorf("field \"log\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Log  LogSeries `json:"log"`
		}{Type: "log", Log: *u.log}, nil
	case "ranges":
		if u.ranges == nil {
			return nil, fmt.Errorf("field \"ranges\" is required")
		}
		return struct {
			Type   string      `json:"type"`
			Ranges RangeSeries `json:"ranges"`
		}{Type: "ranges", Ranges: *u.ranges}, nil
	case "array":
		if u.array == nil {
			return nil, fmt.Errorf("field \"array\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Array ArraySeries `json:"array"`
		}{Type: "array", Array: *u.array}, nil
	case "curveFit":
		if u.curveFit == nil {
			return nil, fmt.Errorf("field \"curveFit\" is required")
		}
		return struct {
			Type     string   `json:"type"`
			CurveFit CurveFit `json:"curveFit"`
		}{Type: "curveFit", CurveFit: *u.curveFit}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Raw  Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u ComputeNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputeNode) UnmarshalJSON(data []byte) error {
	var deser computeNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u ComputeNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputeNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputeNode) AcceptFuncs(enumFunc func(EnumSeries) error, numericFunc func(NumericSeries) error, logFunc func(LogSeries) error, rangesFunc func(RangeSeries) error, arrayFunc func(ArraySeries) error, curveFitFunc func(CurveFit) error, rawFunc func(Reference) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return curveFitFunc(*u.curveFit)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *ComputeNode) EnumNoopSuccess(EnumSeries) error {
	return nil
}

func (u *ComputeNode) NumericNoopSuccess(NumericSeries) error {
	return nil
}

func (u *ComputeNode) LogNoopSuccess(LogSeries) error {
	return nil
}

func (u *ComputeNode) RangesNoopSuccess(RangeSeries) error {
	return nil
}

func (u *ComputeNode) ArrayNoopSuccess(ArraySeries) error {
	return nil
}

func (u *ComputeNode) CurveFitNoopSuccess(CurveFit) error {
	return nil
}

func (u *ComputeNode) RawNoopSuccess(Reference) error {
	return nil
}

func (u *ComputeNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputeNode) Accept(v ComputeNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(*u.log)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(*u.ranges)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(*u.array)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return v.VisitCurveFit(*u.curveFit)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type ComputeNodeVisitor interface {
	VisitEnum(v EnumSeries) error
	VisitNumeric(v NumericSeries) error
	VisitLog(v LogSeries) error
	VisitRanges(v RangeSeries) error
	VisitArray(v ArraySeries) error
	VisitCurveFit(v CurveFit) error
	VisitRaw(v Reference) error
	VisitUnknown(typeName string) error
}

func (u *ComputeNode) AcceptWithContext(ctx context.Context, v ComputeNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLogWithContext(ctx, *u.log)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRangesWithContext(ctx, *u.ranges)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArrayWithContext(ctx, *u.array)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return v.VisitCurveFitWithContext(ctx, *u.curveFit)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type ComputeNodeVisitorWithContext interface {
	VisitEnumWithContext(ctx context.Context, v EnumSeries) error
	VisitNumericWithContext(ctx context.Context, v NumericSeries) error
	VisitLogWithContext(ctx context.Context, v LogSeries) error
	VisitRangesWithContext(ctx context.Context, v RangeSeries) error
	VisitArrayWithContext(ctx context.Context, v ArraySeries) error
	VisitCurveFitWithContext(ctx context.Context, v CurveFit) error
	VisitRawWithContext(ctx context.Context, v Reference) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputeNodeFromEnum(v EnumSeries) ComputeNode {
	return ComputeNode{typ: "enum", enum: &v}
}

func NewComputeNodeFromNumeric(v NumericSeries) ComputeNode {
	return ComputeNode{typ: "numeric", numeric: &v}
}

func NewComputeNodeFromLog(v LogSeries) ComputeNode {
	return ComputeNode{typ: "log", log: &v}
}

func NewComputeNodeFromRanges(v RangeSeries) ComputeNode {
	return ComputeNode{typ: "ranges", ranges: &v}
}

func NewComputeNodeFromArray(v ArraySeries) ComputeNode {
	return ComputeNode{typ: "array", array: &v}
}

func NewComputeNodeFromCurveFit(v CurveFit) ComputeNode {
	return ComputeNode{typ: "curveFit", curveFit: &v}
}

func NewComputeNodeFromRaw(v Reference) ComputeNode {
	return ComputeNode{typ: "raw", raw: &v}
}

type ComputeNodeResponse struct {
	typ                  string
	range_               *[]Range
	rangesSummary        *RangesSummary
	rangeValue           **Range
	numeric              *NumericPlot
	bucketedNumeric      *BucketedNumericPlot
	numericPoint         **NumericPoint
	arrowNumeric         *ArrowNumericPlot
	arrowBucketedNumeric *ArrowBucketedNumericPlot
	enum                 *EnumPlot
	enumPoint            **EnumPoint
	bucketedEnum         *BucketedEnumPlot
	arrowEnum            *ArrowEnumPlot
	arrowBucketedEnum    *ArrowBucketedEnumPlot
	pagedLog             *PagedLogPlot
	logPoint             **LogPoint
	cartesian            *CartesianPlot
	bucketedCartesian    *BucketedCartesianPlot
	bucketedCartesian3d  *BucketedCartesian3dPlot
	bucketedGeo          *BucketedGeoPlot
	frequencyDomain      *FrequencyDomainPlot
	numericHistogram     *NumericHistogramPlot
	enumHistogram        *EnumHistogramPlot
	curveFit             *CurveFitResult
	grouped              *GroupedComputeNodeResponses
	array                *ArrowArrayPlot
}

type computeNodeResponseDeserializer struct {
	Type                 string                       `json:"type"`
	Range                *[]Range                     `json:"range"`
	RangesSummary        *RangesSummary               `json:"rangesSummary"`
	RangeValue           **Range                      `json:"rangeValue"`
	Numeric              *NumericPlot                 `json:"numeric"`
	BucketedNumeric      *BucketedNumericPlot         `json:"bucketedNumeric"`
	NumericPoint         **NumericPoint               `json:"numericPoint"`
	ArrowNumeric         *ArrowNumericPlot            `json:"arrowNumeric"`
	ArrowBucketedNumeric *ArrowBucketedNumericPlot    `json:"arrowBucketedNumeric"`
	Enum                 *EnumPlot                    `json:"enum"`
	EnumPoint            **EnumPoint                  `json:"enumPoint"`
	BucketedEnum         *BucketedEnumPlot            `json:"bucketedEnum"`
	ArrowEnum            *ArrowEnumPlot               `json:"arrowEnum"`
	ArrowBucketedEnum    *ArrowBucketedEnumPlot       `json:"arrowBucketedEnum"`
	PagedLog             *PagedLogPlot                `json:"pagedLog"`
	LogPoint             **LogPoint                   `json:"logPoint"`
	Cartesian            *CartesianPlot               `json:"cartesian"`
	BucketedCartesian    *BucketedCartesianPlot       `json:"bucketedCartesian"`
	BucketedCartesian3d  *BucketedCartesian3dPlot     `json:"bucketedCartesian3d"`
	BucketedGeo          *BucketedGeoPlot             `json:"bucketedGeo"`
	FrequencyDomain      *FrequencyDomainPlot         `json:"frequencyDomain"`
	NumericHistogram     *NumericHistogramPlot        `json:"numericHistogram"`
	EnumHistogram        *EnumHistogramPlot           `json:"enumHistogram"`
	CurveFit             *CurveFitResult              `json:"curveFit"`
	Grouped              *GroupedComputeNodeResponses `json:"grouped"`
	Array                *ArrowArrayPlot              `json:"array"`
}

func (u *computeNodeResponseDeserializer) toStruct() ComputeNodeResponse {
	return ComputeNodeResponse{typ: u.Type, range_: u.Range, rangesSummary: u.RangesSummary, rangeValue: u.RangeValue, numeric: u.Numeric, bucketedNumeric: u.BucketedNumeric, numericPoint: u.NumericPoint, arrowNumeric: u.ArrowNumeric, arrowBucketedNumeric: u.ArrowBucketedNumeric, enum: u.Enum, enumPoint: u.EnumPoint, bucketedEnum: u.BucketedEnum, arrowEnum: u.ArrowEnum, arrowBucketedEnum: u.ArrowBucketedEnum, pagedLog: u.PagedLog, logPoint: u.LogPoint, cartesian: u.Cartesian, bucketedCartesian: u.BucketedCartesian, bucketedCartesian3d: u.BucketedCartesian3d, bucketedGeo: u.BucketedGeo, frequencyDomain: u.FrequencyDomain, numericHistogram: u.NumericHistogram, enumHistogram: u.EnumHistogram, curveFit: u.CurveFit, grouped: u.Grouped, array: u.Array}
}

func (u *ComputeNodeResponse) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "range":
		if u.range_ == nil {
			return nil, fmt.Errorf("field \"range\" is required")
		}
		return struct {
			Type  string  `json:"type"`
			Range []Range `json:"range"`
		}{Type: "range", Range: *u.range_}, nil
	case "rangesSummary":
		if u.rangesSummary == nil {
			return nil, fmt.Errorf("field \"rangesSummary\" is required")
		}
		return struct {
			Type          string        `json:"type"`
			RangesSummary RangesSummary `json:"rangesSummary"`
		}{Type: "rangesSummary", RangesSummary: *u.rangesSummary}, nil
	case "rangeValue":
		var rangeValue *Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return struct {
			Type       string `json:"type"`
			RangeValue *Range `json:"rangeValue"`
		}{Type: "rangeValue", RangeValue: rangeValue}, nil
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string      `json:"type"`
			Numeric NumericPlot `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return nil, fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return struct {
			Type            string              `json:"type"`
			BucketedNumeric BucketedNumericPlot `json:"bucketedNumeric"`
		}{Type: "bucketedNumeric", BucketedNumeric: *u.bucketedNumeric}, nil
	case "numericPoint":
		var numericPoint *NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return struct {
			Type         string        `json:"type"`
			NumericPoint *NumericPoint `json:"numericPoint"`
		}{Type: "numericPoint", NumericPoint: numericPoint}, nil
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return nil, fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return struct {
			Type         string           `json:"type"`
			ArrowNumeric ArrowNumericPlot `json:"arrowNumeric"`
		}{Type: "arrowNumeric", ArrowNumeric: *u.arrowNumeric}, nil
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return nil, fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return struct {
			Type                 string                   `json:"type"`
			ArrowBucketedNumeric ArrowBucketedNumericPlot `json:"arrowBucketedNumeric"`
		}{Type: "arrowBucketedNumeric", ArrowBucketedNumeric: *u.arrowBucketedNumeric}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string   `json:"type"`
			Enum EnumPlot `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "enumPoint":
		var enumPoint *EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return struct {
			Type      string     `json:"type"`
			EnumPoint *EnumPoint `json:"enumPoint"`
		}{Type: "enumPoint", EnumPoint: enumPoint}, nil
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return nil, fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return struct {
			Type         string           `json:"type"`
			BucketedEnum BucketedEnumPlot `json:"bucketedEnum"`
		}{Type: "bucketedEnum", BucketedEnum: *u.bucketedEnum}, nil
	case "arrowEnum":
		if u.arrowEnum == nil {
			return nil, fmt.Errorf("field \"arrowEnum\" is required")
		}
		return struct {
			Type      string        `json:"type"`
			ArrowEnum ArrowEnumPlot `json:"arrowEnum"`
		}{Type: "arrowEnum", ArrowEnum: *u.arrowEnum}, nil
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return nil, fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return struct {
			Type              string                `json:"type"`
			ArrowBucketedEnum ArrowBucketedEnumPlot `json:"arrowBucketedEnum"`
		}{Type: "arrowBucketedEnum", ArrowBucketedEnum: *u.arrowBucketedEnum}, nil
	case "pagedLog":
		if u.pagedLog == nil {
			return nil, fmt.Errorf("field \"pagedLog\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			PagedLog PagedLogPlot `json:"pagedLog"`
		}{Type: "pagedLog", PagedLog: *u.pagedLog}, nil
	case "logPoint":
		var logPoint *LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return struct {
			Type     string    `json:"type"`
			LogPoint *LogPoint `json:"logPoint"`
		}{Type: "logPoint", LogPoint: logPoint}, nil
	case "cartesian":
		if u.cartesian == nil {
			return nil, fmt.Errorf("field \"cartesian\" is required")
		}
		return struct {
			Type      string        `json:"type"`
			Cartesian CartesianPlot `json:"cartesian"`
		}{Type: "cartesian", Cartesian: *u.cartesian}, nil
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return nil, fmt.Errorf("field \"bucketedCartesian\" is required")
		}
		return struct {
			Type              string                `json:"type"`
			BucketedCartesian BucketedCartesianPlot `json:"bucketedCartesian"`
		}{Type: "bucketedCartesian", BucketedCartesian: *u.bucketedCartesian}, nil
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return nil, fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
		return struct {
			Type                string                  `json:"type"`
			BucketedCartesian3d BucketedCartesian3dPlot `json:"bucketedCartesian3d"`
		}{Type: "bucketedCartesian3d", BucketedCartesian3d: *u.bucketedCartesian3d}, nil
	case "bucketedGeo":
		if u.bucketedGeo == nil {
			return nil, fmt.Errorf("field \"bucketedGeo\" is required")
		}
		return struct {
			Type        string          `json:"type"`
			BucketedGeo BucketedGeoPlot `json:"bucketedGeo"`
		}{Type: "bucketedGeo", BucketedGeo: *u.bucketedGeo}, nil
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return nil, fmt.Errorf("field \"frequencyDomain\" is required")
		}
		return struct {
			Type            string              `json:"type"`
			FrequencyDomain FrequencyDomainPlot `json:"frequencyDomain"`
		}{Type: "frequencyDomain", FrequencyDomain: *u.frequencyDomain}, nil
	case "numericHistogram":
		if u.numericHistogram == nil {
			return nil, fmt.Errorf("field \"numericHistogram\" is required")
		}
		return struct {
			Type             string               `json:"type"`
			NumericHistogram NumericHistogramPlot `json:"numericHistogram"`
		}{Type: "numericHistogram", NumericHistogram: *u.numericHistogram}, nil
	case "enumHistogram":
		if u.enumHistogram == nil {
			return nil, fmt.Errorf("field \"enumHistogram\" is required")
		}
		return struct {
			Type          string            `json:"type"`
			EnumHistogram EnumHistogramPlot `json:"enumHistogram"`
		}{Type: "enumHistogram", EnumHistogram: *u.enumHistogram}, nil
	case "curveFit":
		if u.curveFit == nil {
			return nil, fmt.Errorf("field \"curveFit\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			CurveFit CurveFitResult `json:"curveFit"`
		}{Type: "curveFit", CurveFit: *u.curveFit}, nil
	case "grouped":
		if u.grouped == nil {
			return nil, fmt.Errorf("field \"grouped\" is required")
		}
		return struct {
			Type    string                      `json:"type"`
			Grouped GroupedComputeNodeResponses `json:"grouped"`
		}{Type: "grouped", Grouped: *u.grouped}, nil
	case "array":
		if u.array == nil {
			return nil, fmt.Errorf("field \"array\" is required")
		}
		return struct {
			Type  string         `json:"type"`
			Array ArrowArrayPlot `json:"array"`
		}{Type: "array", Array: *u.array}, nil
	}
}

func (u ComputeNodeResponse) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputeNodeResponse) UnmarshalJSON(data []byte) error {
	var deser computeNodeResponseDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
	case "rangesSummary":
		if u.rangesSummary == nil {
			return fmt.Errorf("field \"rangesSummary\" is required")
		}
	case "rangeValue":
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
	case "numericPoint":
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "enumPoint":
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
	case "pagedLog":
		if u.pagedLog == nil {
			return fmt.Errorf("field \"pagedLog\" is required")
		}
	case "logPoint":
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return fmt.Errorf("field \"bucketedCartesian\" is required")
		}
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
	case "bucketedGeo":
		if u.bucketedGeo == nil {
			return fmt.Errorf("field \"bucketedGeo\" is required")
		}
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return fmt.Errorf("field \"frequencyDomain\" is required")
		}
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
	}
	return nil
}

func (u ComputeNodeResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputeNodeResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputeNodeResponse) AcceptFuncs(range_Func func([]Range) error, rangesSummaryFunc func(RangesSummary) error, rangeValueFunc func(*Range) error, numericFunc func(NumericPlot) error, bucketedNumericFunc func(BucketedNumericPlot) error, numericPointFunc func(*NumericPoint) error, arrowNumericFunc func(ArrowNumericPlot) error, arrowBucketedNumericFunc func(ArrowBucketedNumericPlot) error, enumFunc func(EnumPlot) error, enumPointFunc func(*EnumPoint) error, bucketedEnumFunc func(BucketedEnumPlot) error, arrowEnumFunc func(ArrowEnumPlot) error, arrowBucketedEnumFunc func(ArrowBucketedEnumPlot) error, pagedLogFunc func(PagedLogPlot) error, logPointFunc func(*LogPoint) error, cartesianFunc func(CartesianPlot) error, bucketedCartesianFunc func(BucketedCartesianPlot) error, bucketedCartesian3dFunc func(BucketedCartesian3dPlot) error, bucketedGeoFunc func(BucketedGeoPlot) error, frequencyDomainFunc func(FrequencyDomainPlot) error, numericHistogramFunc func(NumericHistogramPlot) error, enumHistogramFunc func(EnumHistogramPlot) error, curveFitFunc func(CurveFitResult) error, groupedFunc func(GroupedComputeNodeResponses) error, arrayFunc func(ArrowArrayPlot) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "rangesSummary":
		if u.rangesSummary == nil {
			return fmt.Errorf("field \"rangesSummary\" is required")
		}
		return rangesSummaryFunc(*u.rangesSummary)
	case "rangeValue":
		var rangeValue *Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return rangeValueFunc(rangeValue)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return bucketedNumericFunc(*u.bucketedNumeric)
	case "numericPoint":
		var numericPoint *NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return numericPointFunc(numericPoint)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return arrowNumericFunc(*u.arrowNumeric)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return arrowBucketedNumericFunc(*u.arrowBucketedNumeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "enumPoint":
		var enumPoint *EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return enumPointFunc(enumPoint)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return bucketedEnumFunc(*u.bucketedEnum)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
		return arrowEnumFunc(*u.arrowEnum)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return arrowBucketedEnumFunc(*u.arrowBucketedEnum)
	case "pagedLog":
		if u.pagedLog == nil {
			return fmt.Errorf("field \"pagedLog\" is required")
		}
		return pagedLogFunc(*u.pagedLog)
	case "logPoint":
		var logPoint *LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return logPointFunc(logPoint)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return fmt.Errorf("field \"bucketedCartesian\" is required")
		}
		return bucketedCartesianFunc(*u.bucketedCartesian)
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
		return bucketedCartesian3dFunc(*u.bucketedCartesian3d)
	case "bucketedGeo":
		if u.bucketedGeo == nil {
			return fmt.Errorf("field \"bucketedGeo\" is required")
		}
		return bucketedGeoFunc(*u.bucketedGeo)
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return fmt.Errorf("field \"frequencyDomain\" is required")
		}
		return frequencyDomainFunc(*u.frequencyDomain)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
		return numericHistogramFunc(*u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
		return enumHistogramFunc(*u.enumHistogram)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return curveFitFunc(*u.curveFit)
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
		return groupedFunc(*u.grouped)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	}
}

func (u *ComputeNodeResponse) RangeNoopSuccess([]Range) error {
	return nil
}

func (u *ComputeNodeResponse) RangesSummaryNoopSuccess(RangesSummary) error {
	return nil
}

func (u *ComputeNodeResponse) RangeValueNoopSuccess(*Range) error {
	return nil
}

func (u *ComputeNodeResponse) NumericNoopSuccess(NumericPlot) error {
	return nil
}

func (u *ComputeNodeResponse) BucketedNumericNoopSuccess(BucketedNumericPlot) error {
	return nil
}

func (u *ComputeNodeResponse) NumericPointNoopSuccess(*NumericPoint) error {
	return nil
}

func (u *ComputeNodeResponse) ArrowNumericNoopSuccess(ArrowNumericPlot) error {
	return nil
}

func (u *ComputeNodeResponse) ArrowBucketedNumericNoopSuccess(ArrowBucketedNumericPlot) error {
	return nil
}

func (u *ComputeNodeResponse) EnumNoopSuccess(EnumPlot) error {
	return nil
}

func (u *ComputeNodeResponse) EnumPointNoopSuccess(*EnumPoint) error {
	return nil
}

func (u *ComputeNodeResponse) BucketedEnumNoopSuccess(BucketedEnumPlot) error {
	return nil
}

func (u *ComputeNodeResponse) ArrowEnumNoopSuccess(ArrowEnumPlot) error {
	return nil
}

func (u *ComputeNodeResponse) ArrowBucketedEnumNoopSuccess(ArrowBucketedEnumPlot) error {
	return nil
}

func (u *ComputeNodeResponse) PagedLogNoopSuccess(PagedLogPlot) error {
	return nil
}

func (u *ComputeNodeResponse) LogPointNoopSuccess(*LogPoint) error {
	return nil
}

func (u *ComputeNodeResponse) CartesianNoopSuccess(CartesianPlot) error {
	return nil
}

func (u *ComputeNodeResponse) BucketedCartesianNoopSuccess(BucketedCartesianPlot) error {
	return nil
}

func (u *ComputeNodeResponse) BucketedCartesian3dNoopSuccess(BucketedCartesian3dPlot) error {
	return nil
}

func (u *ComputeNodeResponse) BucketedGeoNoopSuccess(BucketedGeoPlot) error {
	return nil
}

func (u *ComputeNodeResponse) FrequencyDomainNoopSuccess(FrequencyDomainPlot) error {
	return nil
}

func (u *ComputeNodeResponse) NumericHistogramNoopSuccess(NumericHistogramPlot) error {
	return nil
}

func (u *ComputeNodeResponse) EnumHistogramNoopSuccess(EnumHistogramPlot) error {
	return nil
}

func (u *ComputeNodeResponse) CurveFitNoopSuccess(CurveFitResult) error {
	return nil
}

func (u *ComputeNodeResponse) GroupedNoopSuccess(GroupedComputeNodeResponses) error {
	return nil
}

func (u *ComputeNodeResponse) ArrayNoopSuccess(ArrowArrayPlot) error {
	return nil
}

func (u *ComputeNodeResponse) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputeNodeResponse) Accept(v ComputeNodeResponseVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(*u.range_)
	case "rangesSummary":
		if u.rangesSummary == nil {
			return fmt.Errorf("field \"rangesSummary\" is required")
		}
		return v.VisitRangesSummary(*u.rangesSummary)
	case "rangeValue":
		var rangeValue *Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return v.VisitRangeValue(rangeValue)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumeric(*u.bucketedNumeric)
	case "numericPoint":
		var numericPoint *NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return v.VisitNumericPoint(numericPoint)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return v.VisitArrowNumeric(*u.arrowNumeric)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return v.VisitArrowBucketedNumeric(*u.arrowBucketedNumeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "enumPoint":
		var enumPoint *EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return v.VisitEnumPoint(enumPoint)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnum(*u.bucketedEnum)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
		return v.VisitArrowEnum(*u.arrowEnum)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return v.VisitArrowBucketedEnum(*u.arrowBucketedEnum)
	case "pagedLog":
		if u.pagedLog == nil {
			return fmt.Errorf("field \"pagedLog\" is required")
		}
		return v.VisitPagedLog(*u.pagedLog)
	case "logPoint":
		var logPoint *LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return v.VisitLogPoint(logPoint)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(*u.cartesian)
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return fmt.Errorf("field \"bucketedCartesian\" is required")
		}
		return v.VisitBucketedCartesian(*u.bucketedCartesian)
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
		return v.VisitBucketedCartesian3d(*u.bucketedCartesian3d)
	case "bucketedGeo":
		if u.bucketedGeo == nil {
			return fmt.Errorf("field \"bucketedGeo\" is required")
		}
		return v.VisitBucketedGeo(*u.bucketedGeo)
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return fmt.Errorf("field \"frequencyDomain\" is required")
		}
		return v.VisitFrequencyDomain(*u.frequencyDomain)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
		return v.VisitNumericHistogram(*u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
		return v.VisitEnumHistogram(*u.enumHistogram)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return v.VisitCurveFit(*u.curveFit)
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
		return v.VisitGrouped(*u.grouped)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(*u.array)
	}
}

type ComputeNodeResponseVisitor interface {
	VisitRange(v []Range) error
	VisitRangesSummary(v RangesSummary) error
	VisitRangeValue(v *Range) error
	VisitNumeric(v NumericPlot) error
	VisitBucketedNumeric(v BucketedNumericPlot) error
	VisitNumericPoint(v *NumericPoint) error
	VisitArrowNumeric(v ArrowNumericPlot) error
	VisitArrowBucketedNumeric(v ArrowBucketedNumericPlot) error
	VisitEnum(v EnumPlot) error
	VisitEnumPoint(v *EnumPoint) error
	VisitBucketedEnum(v BucketedEnumPlot) error
	VisitArrowEnum(v ArrowEnumPlot) error
	VisitArrowBucketedEnum(v ArrowBucketedEnumPlot) error
	VisitPagedLog(v PagedLogPlot) error
	VisitLogPoint(v *LogPoint) error
	VisitCartesian(v CartesianPlot) error
	VisitBucketedCartesian(v BucketedCartesianPlot) error
	VisitBucketedCartesian3d(v BucketedCartesian3dPlot) error
	VisitBucketedGeo(v BucketedGeoPlot) error
	VisitFrequencyDomain(v FrequencyDomainPlot) error
	VisitNumericHistogram(v NumericHistogramPlot) error
	VisitEnumHistogram(v EnumHistogramPlot) error
	VisitCurveFit(v CurveFitResult) error
	VisitGrouped(v GroupedComputeNodeResponses) error
	VisitArray(v ArrowArrayPlot) error
	VisitUnknown(typeName string) error
}

func (u *ComputeNodeResponse) AcceptWithContext(ctx context.Context, v ComputeNodeResponseVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRangeWithContext(ctx, *u.range_)
	case "rangesSummary":
		if u.rangesSummary == nil {
			return fmt.Errorf("field \"rangesSummary\" is required")
		}
		return v.VisitRangesSummaryWithContext(ctx, *u.rangesSummary)
	case "rangeValue":
		var rangeValue *Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return v.VisitRangeValueWithContext(ctx, rangeValue)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumericWithContext(ctx, *u.bucketedNumeric)
	case "numericPoint":
		var numericPoint *NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return v.VisitNumericPointWithContext(ctx, numericPoint)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return v.VisitArrowNumericWithContext(ctx, *u.arrowNumeric)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return v.VisitArrowBucketedNumericWithContext(ctx, *u.arrowBucketedNumeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "enumPoint":
		var enumPoint *EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return v.VisitEnumPointWithContext(ctx, enumPoint)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnumWithContext(ctx, *u.bucketedEnum)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
		return v.VisitArrowEnumWithContext(ctx, *u.arrowEnum)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return v.VisitArrowBucketedEnumWithContext(ctx, *u.arrowBucketedEnum)
	case "pagedLog":
		if u.pagedLog == nil {
			return fmt.Errorf("field \"pagedLog\" is required")
		}
		return v.VisitPagedLogWithContext(ctx, *u.pagedLog)
	case "logPoint":
		var logPoint *LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return v.VisitLogPointWithContext(ctx, logPoint)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesianWithContext(ctx, *u.cartesian)
	case "bucketedCartesian":
		if u.bucketedCartesian == nil {
			return fmt.Errorf("field \"bucketedCartesian\" is required")
		}
		return v.VisitBucketedCartesianWithContext(ctx, *u.bucketedCartesian)
	case "bucketedCartesian3d":
		if u.bucketedCartesian3d == nil {
			return fmt.Errorf("field \"bucketedCartesian3d\" is required")
		}
		return v.VisitBucketedCartesian3dWithContext(ctx, *u.bucketedCartesian3d)
	case "bucketedGeo":
		if u.bucketedGeo == nil {
			return fmt.Errorf("field \"bucketedGeo\" is required")
		}
		return v.VisitBucketedGeoWithContext(ctx, *u.bucketedGeo)
	case "frequencyDomain":
		if u.frequencyDomain == nil {
			return fmt.Errorf("field \"frequencyDomain\" is required")
		}
		return v.VisitFrequencyDomainWithContext(ctx, *u.frequencyDomain)
	case "numericHistogram":
		if u.numericHistogram == nil {
			return fmt.Errorf("field \"numericHistogram\" is required")
		}
		return v.VisitNumericHistogramWithContext(ctx, *u.numericHistogram)
	case "enumHistogram":
		if u.enumHistogram == nil {
			return fmt.Errorf("field \"enumHistogram\" is required")
		}
		return v.VisitEnumHistogramWithContext(ctx, *u.enumHistogram)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return v.VisitCurveFitWithContext(ctx, *u.curveFit)
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
		return v.VisitGroupedWithContext(ctx, *u.grouped)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArrayWithContext(ctx, *u.array)
	}
}

type ComputeNodeResponseVisitorWithContext interface {
	VisitRangeWithContext(ctx context.Context, v []Range) error
	VisitRangesSummaryWithContext(ctx context.Context, v RangesSummary) error
	VisitRangeValueWithContext(ctx context.Context, v *Range) error
	VisitNumericWithContext(ctx context.Context, v NumericPlot) error
	VisitBucketedNumericWithContext(ctx context.Context, v BucketedNumericPlot) error
	VisitNumericPointWithContext(ctx context.Context, v *NumericPoint) error
	VisitArrowNumericWithContext(ctx context.Context, v ArrowNumericPlot) error
	VisitArrowBucketedNumericWithContext(ctx context.Context, v ArrowBucketedNumericPlot) error
	VisitEnumWithContext(ctx context.Context, v EnumPlot) error
	VisitEnumPointWithContext(ctx context.Context, v *EnumPoint) error
	VisitBucketedEnumWithContext(ctx context.Context, v BucketedEnumPlot) error
	VisitArrowEnumWithContext(ctx context.Context, v ArrowEnumPlot) error
	VisitArrowBucketedEnumWithContext(ctx context.Context, v ArrowBucketedEnumPlot) error
	VisitPagedLogWithContext(ctx context.Context, v PagedLogPlot) error
	VisitLogPointWithContext(ctx context.Context, v *LogPoint) error
	VisitCartesianWithContext(ctx context.Context, v CartesianPlot) error
	VisitBucketedCartesianWithContext(ctx context.Context, v BucketedCartesianPlot) error
	VisitBucketedCartesian3dWithContext(ctx context.Context, v BucketedCartesian3dPlot) error
	VisitBucketedGeoWithContext(ctx context.Context, v BucketedGeoPlot) error
	VisitFrequencyDomainWithContext(ctx context.Context, v FrequencyDomainPlot) error
	VisitNumericHistogramWithContext(ctx context.Context, v NumericHistogramPlot) error
	VisitEnumHistogramWithContext(ctx context.Context, v EnumHistogramPlot) error
	VisitCurveFitWithContext(ctx context.Context, v CurveFitResult) error
	VisitGroupedWithContext(ctx context.Context, v GroupedComputeNodeResponses) error
	VisitArrayWithContext(ctx context.Context, v ArrowArrayPlot) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputeNodeResponseFromRange(v []Range) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "range", range_: &v}
}

func NewComputeNodeResponseFromRangesSummary(v RangesSummary) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "rangesSummary", rangesSummary: &v}
}

func NewComputeNodeResponseFromRangeValue(v *Range) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "rangeValue", rangeValue: &v}
}

func NewComputeNodeResponseFromNumeric(v NumericPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "numeric", numeric: &v}
}

func NewComputeNodeResponseFromBucketedNumeric(v BucketedNumericPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "bucketedNumeric", bucketedNumeric: &v}
}

func NewComputeNodeResponseFromNumericPoint(v *NumericPoint) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "numericPoint", numericPoint: &v}
}

func NewComputeNodeResponseFromArrowNumeric(v ArrowNumericPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "arrowNumeric", arrowNumeric: &v}
}

func NewComputeNodeResponseFromArrowBucketedNumeric(v ArrowBucketedNumericPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "arrowBucketedNumeric", arrowBucketedNumeric: &v}
}

func NewComputeNodeResponseFromEnum(v EnumPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "enum", enum: &v}
}

func NewComputeNodeResponseFromEnumPoint(v *EnumPoint) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "enumPoint", enumPoint: &v}
}

func NewComputeNodeResponseFromBucketedEnum(v BucketedEnumPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "bucketedEnum", bucketedEnum: &v}
}

func NewComputeNodeResponseFromArrowEnum(v ArrowEnumPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "arrowEnum", arrowEnum: &v}
}

func NewComputeNodeResponseFromArrowBucketedEnum(v ArrowBucketedEnumPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "arrowBucketedEnum", arrowBucketedEnum: &v}
}

func NewComputeNodeResponseFromPagedLog(v PagedLogPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "pagedLog", pagedLog: &v}
}

func NewComputeNodeResponseFromLogPoint(v *LogPoint) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "logPoint", logPoint: &v}
}

func NewComputeNodeResponseFromCartesian(v CartesianPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "cartesian", cartesian: &v}
}

func NewComputeNodeResponseFromBucketedCartesian(v BucketedCartesianPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "bucketedCartesian", bucketedCartesian: &v}
}

func NewComputeNodeResponseFromBucketedCartesian3d(v BucketedCartesian3dPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "bucketedCartesian3d", bucketedCartesian3d: &v}
}

func NewComputeNodeResponseFromBucketedGeo(v BucketedGeoPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "bucketedGeo", bucketedGeo: &v}
}

func NewComputeNodeResponseFromFrequencyDomain(v FrequencyDomainPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "frequencyDomain", frequencyDomain: &v}
}

func NewComputeNodeResponseFromNumericHistogram(v NumericHistogramPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "numericHistogram", numericHistogram: &v}
}

func NewComputeNodeResponseFromEnumHistogram(v EnumHistogramPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "enumHistogram", enumHistogram: &v}
}

func NewComputeNodeResponseFromCurveFit(v CurveFitResult) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "curveFit", curveFit: &v}
}

func NewComputeNodeResponseFromGrouped(v GroupedComputeNodeResponses) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "grouped", grouped: &v}
}

func NewComputeNodeResponseFromArray(v ArrowArrayPlot) ComputeNodeResponse {
	return ComputeNodeResponse{typ: "array", array: &v}
}

type ComputeNodeResult struct {
	typ     string
	success *ComputeNodeResponse
	error   *ErrorResult
}

type computeNodeResultDeserializer struct {
	Type    string               `json:"type"`
	Success *ComputeNodeResponse `json:"success"`
	Error   *ErrorResult         `json:"error"`
}

func (u *computeNodeResultDeserializer) toStruct() ComputeNodeResult {
	return ComputeNodeResult{typ: u.Type, success: u.Success, error: u.Error}
}

func (u *ComputeNodeResult) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "success":
		if u.success == nil {
			return nil, fmt.Errorf("field \"success\" is required")
		}
		return struct {
			Type    string              `json:"type"`
			Success ComputeNodeResponse `json:"success"`
		}{Type: "success", Success: *u.success}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Error ErrorResult `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	}
}

func (u ComputeNodeResult) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputeNodeResult) UnmarshalJSON(data []byte) error {
	var deser computeNodeResultDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	}
	return nil
}

func (u ComputeNodeResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputeNodeResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputeNodeResult) AcceptFuncs(successFunc func(ComputeNodeResponse) error, errorFunc func(ErrorResult) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *ComputeNodeResult) SuccessNoopSuccess(ComputeNodeResponse) error {
	return nil
}

func (u *ComputeNodeResult) ErrorNoopSuccess(ErrorResult) error {
	return nil
}

func (u *ComputeNodeResult) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputeNodeResult) Accept(v ComputeNodeResultVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	}
}

type ComputeNodeResultVisitor interface {
	VisitSuccess(v ComputeNodeResponse) error
	VisitError(v ErrorResult) error
	VisitUnknown(typeName string) error
}

func (u *ComputeNodeResult) AcceptWithContext(ctx context.Context, v ComputeNodeResultVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccessWithContext(ctx, *u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	}
}

type ComputeNodeResultVisitorWithContext interface {
	VisitSuccessWithContext(ctx context.Context, v ComputeNodeResponse) error
	VisitErrorWithContext(ctx context.Context, v ErrorResult) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputeNodeResultFromSuccess(v ComputeNodeResponse) ComputeNodeResult {
	return ComputeNodeResult{typ: "success", success: &v}
}

func NewComputeNodeResultFromError(v ErrorResult) ComputeNodeResult {
	return ComputeNodeResult{typ: "error", error: &v}
}

type ComputeUnitResult struct {
	typ         string
	single      *UnitResult
	cartesian   *CartesianUnitResult
	cartesian3d *Cartesian3dUnitResult
}

type computeUnitResultDeserializer struct {
	Type        string                 `json:"type"`
	Single      *UnitResult            `json:"single"`
	Cartesian   *CartesianUnitResult   `json:"cartesian"`
	Cartesian3d *Cartesian3dUnitResult `json:"cartesian3d"`
}

func (u *computeUnitResultDeserializer) toStruct() ComputeUnitResult {
	return ComputeUnitResult{typ: u.Type, single: u.Single, cartesian: u.Cartesian, cartesian3d: u.Cartesian3d}
}

func (u *ComputeUnitResult) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "single":
		if u.single == nil {
			return nil, fmt.Errorf("field \"single\" is required")
		}
		return struct {
			Type   string     `json:"type"`
			Single UnitResult `json:"single"`
		}{Type: "single", Single: *u.single}, nil
	case "cartesian":
		if u.cartesian == nil {
			return nil, fmt.Errorf("field \"cartesian\" is required")
		}
		return struct {
			Type      string              `json:"type"`
			Cartesian CartesianUnitResult `json:"cartesian"`
		}{Type: "cartesian", Cartesian: *u.cartesian}, nil
	case "cartesian3d":
		if u.cartesian3d == nil {
			return nil, fmt.Errorf("field \"cartesian3d\" is required")
		}
		return struct {
			Type        string                `json:"type"`
			Cartesian3d Cartesian3dUnitResult `json:"cartesian3d"`
		}{Type: "cartesian3d", Cartesian3d: *u.cartesian3d}, nil
	}
}

func (u ComputeUnitResult) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputeUnitResult) UnmarshalJSON(data []byte) error {
	var deser computeUnitResultDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
	}
	return nil
}

func (u ComputeUnitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputeUnitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputeUnitResult) AcceptFuncs(singleFunc func(UnitResult) error, cartesianFunc func(CartesianUnitResult) error, cartesian3dFunc func(Cartesian3dUnitResult) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return cartesian3dFunc(*u.cartesian3d)
	}
}

func (u *ComputeUnitResult) SingleNoopSuccess(UnitResult) error {
	return nil
}

func (u *ComputeUnitResult) CartesianNoopSuccess(CartesianUnitResult) error {
	return nil
}

func (u *ComputeUnitResult) Cartesian3dNoopSuccess(Cartesian3dUnitResult) error {
	return nil
}

func (u *ComputeUnitResult) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputeUnitResult) Accept(v ComputeUnitResultVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(*u.single)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3d(*u.cartesian3d)
	}
}

type ComputeUnitResultVisitor interface {
	VisitSingle(v UnitResult) error
	VisitCartesian(v CartesianUnitResult) error
	VisitCartesian3d(v Cartesian3dUnitResult) error
	VisitUnknown(typeName string) error
}

func (u *ComputeUnitResult) AcceptWithContext(ctx context.Context, v ComputeUnitResultVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingleWithContext(ctx, *u.single)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesianWithContext(ctx, *u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3dWithContext(ctx, *u.cartesian3d)
	}
}

type ComputeUnitResultVisitorWithContext interface {
	VisitSingleWithContext(ctx context.Context, v UnitResult) error
	VisitCartesianWithContext(ctx context.Context, v CartesianUnitResult) error
	VisitCartesian3dWithContext(ctx context.Context, v Cartesian3dUnitResult) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputeUnitResultFromSingle(v UnitResult) ComputeUnitResult {
	return ComputeUnitResult{typ: "single", single: &v}
}

func NewComputeUnitResultFromCartesian(v CartesianUnitResult) ComputeUnitResult {
	return ComputeUnitResult{typ: "cartesian", cartesian: &v}
}

func NewComputeUnitResultFromCartesian3d(v Cartesian3dUnitResult) ComputeUnitResult {
	return ComputeUnitResult{typ: "cartesian3d", cartesian3d: &v}
}

type CurveFitDetails struct {
	typ         string
	exponential *ExponentialCurve
	logarithmic *LogarithmicCurve
	polynomial  *PolynomialCurve
	power       *PowerCurve
}

type curveFitDetailsDeserializer struct {
	Type        string            `json:"type"`
	Exponential *ExponentialCurve `json:"exponential"`
	Logarithmic *LogarithmicCurve `json:"logarithmic"`
	Polynomial  *PolynomialCurve  `json:"polynomial"`
	Power       *PowerCurve       `json:"power"`
}

func (u *curveFitDetailsDeserializer) toStruct() CurveFitDetails {
	return CurveFitDetails{typ: u.Type, exponential: u.Exponential, logarithmic: u.Logarithmic, polynomial: u.Polynomial, power: u.Power}
}

func (u *CurveFitDetails) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "exponential":
		if u.exponential == nil {
			return nil, fmt.Errorf("field \"exponential\" is required")
		}
		return struct {
			Type        string           `json:"type"`
			Exponential ExponentialCurve `json:"exponential"`
		}{Type: "exponential", Exponential: *u.exponential}, nil
	case "logarithmic":
		if u.logarithmic == nil {
			return nil, fmt.Errorf("field \"logarithmic\" is required")
		}
		return struct {
			Type        string           `json:"type"`
			Logarithmic LogarithmicCurve `json:"logarithmic"`
		}{Type: "logarithmic", Logarithmic: *u.logarithmic}, nil
	case "polynomial":
		if u.polynomial == nil {
			return nil, fmt.Errorf("field \"polynomial\" is required")
		}
		return struct {
			Type       string          `json:"type"`
			Polynomial PolynomialCurve `json:"polynomial"`
		}{Type: "polynomial", Polynomial: *u.polynomial}, nil
	case "power":
		if u.power == nil {
			return nil, fmt.Errorf("field \"power\" is required")
		}
		return struct {
			Type  string     `json:"type"`
			Power PowerCurve `json:"power"`
		}{Type: "power", Power: *u.power}, nil
	}
}

func (u CurveFitDetails) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CurveFitDetails) UnmarshalJSON(data []byte) error {
	var deser curveFitDetailsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
	}
	return nil
}

func (u CurveFitDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CurveFitDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CurveFitDetails) AcceptFuncs(exponentialFunc func(ExponentialCurve) error, logarithmicFunc func(LogarithmicCurve) error, polynomialFunc func(PolynomialCurve) error, powerFunc func(PowerCurve) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return exponentialFunc(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return logarithmicFunc(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return polynomialFunc(*u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return powerFunc(*u.power)
	}
}

func (u *CurveFitDetails) ExponentialNoopSuccess(ExponentialCurve) error {
	return nil
}

func (u *CurveFitDetails) LogarithmicNoopSuccess(LogarithmicCurve) error {
	return nil
}

func (u *CurveFitDetails) PolynomialNoopSuccess(PolynomialCurve) error {
	return nil
}

func (u *CurveFitDetails) PowerNoopSuccess(PowerCurve) error {
	return nil
}

func (u *CurveFitDetails) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CurveFitDetails) Accept(v CurveFitDetailsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponential(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmic(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomial(*u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPower(*u.power)
	}
}

type CurveFitDetailsVisitor interface {
	VisitExponential(v ExponentialCurve) error
	VisitLogarithmic(v LogarithmicCurve) error
	VisitPolynomial(v PolynomialCurve) error
	VisitPower(v PowerCurve) error
	VisitUnknown(typeName string) error
}

func (u *CurveFitDetails) AcceptWithContext(ctx context.Context, v CurveFitDetailsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponentialWithContext(ctx, *u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmicWithContext(ctx, *u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomialWithContext(ctx, *u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPowerWithContext(ctx, *u.power)
	}
}

type CurveFitDetailsVisitorWithContext interface {
	VisitExponentialWithContext(ctx context.Context, v ExponentialCurve) error
	VisitLogarithmicWithContext(ctx context.Context, v LogarithmicCurve) error
	VisitPolynomialWithContext(ctx context.Context, v PolynomialCurve) error
	VisitPowerWithContext(ctx context.Context, v PowerCurve) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCurveFitDetailsFromExponential(v ExponentialCurve) CurveFitDetails {
	return CurveFitDetails{typ: "exponential", exponential: &v}
}

func NewCurveFitDetailsFromLogarithmic(v LogarithmicCurve) CurveFitDetails {
	return CurveFitDetails{typ: "logarithmic", logarithmic: &v}
}

func NewCurveFitDetailsFromPolynomial(v PolynomialCurve) CurveFitDetails {
	return CurveFitDetails{typ: "polynomial", polynomial: &v}
}

func NewCurveFitDetailsFromPower(v PowerCurve) CurveFitDetails {
	return CurveFitDetails{typ: "power", power: &v}
}

type CurveFitPlotType struct {
	typ        string
	timeSeries *TimeSeriesCurveFit
	scatter    *ScatterCurveFit
}

type curveFitPlotTypeDeserializer struct {
	Type       string              `json:"type"`
	TimeSeries *TimeSeriesCurveFit `json:"timeSeries"`
	Scatter    *ScatterCurveFit    `json:"scatter"`
}

func (u *curveFitPlotTypeDeserializer) toStruct() CurveFitPlotType {
	return CurveFitPlotType{typ: u.Type, timeSeries: u.TimeSeries, scatter: u.Scatter}
}

func (u *CurveFitPlotType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return nil, fmt.Errorf("field \"timeSeries\" is required")
		}
		return struct {
			Type       string             `json:"type"`
			TimeSeries TimeSeriesCurveFit `json:"timeSeries"`
		}{Type: "timeSeries", TimeSeries: *u.timeSeries}, nil
	case "scatter":
		if u.scatter == nil {
			return nil, fmt.Errorf("field \"scatter\" is required")
		}
		return struct {
			Type    string          `json:"type"`
			Scatter ScatterCurveFit `json:"scatter"`
		}{Type: "scatter", Scatter: *u.scatter}, nil
	}
}

func (u CurveFitPlotType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CurveFitPlotType) UnmarshalJSON(data []byte) error {
	var deser curveFitPlotTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
	}
	return nil
}

func (u CurveFitPlotType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CurveFitPlotType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CurveFitPlotType) AcceptFuncs(timeSeriesFunc func(TimeSeriesCurveFit) error, scatterFunc func(ScatterCurveFit) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return timeSeriesFunc(*u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *CurveFitPlotType) TimeSeriesNoopSuccess(TimeSeriesCurveFit) error {
	return nil
}

func (u *CurveFitPlotType) ScatterNoopSuccess(ScatterCurveFit) error {
	return nil
}

func (u *CurveFitPlotType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CurveFitPlotType) Accept(v CurveFitPlotTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeries(*u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(*u.scatter)
	}
}

type CurveFitPlotTypeVisitor interface {
	VisitTimeSeries(v TimeSeriesCurveFit) error
	VisitScatter(v ScatterCurveFit) error
	VisitUnknown(typeName string) error
}

func (u *CurveFitPlotType) AcceptWithContext(ctx context.Context, v CurveFitPlotTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeriesWithContext(ctx, *u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatterWithContext(ctx, *u.scatter)
	}
}

type CurveFitPlotTypeVisitorWithContext interface {
	VisitTimeSeriesWithContext(ctx context.Context, v TimeSeriesCurveFit) error
	VisitScatterWithContext(ctx context.Context, v ScatterCurveFit) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCurveFitPlotTypeFromTimeSeries(v TimeSeriesCurveFit) CurveFitPlotType {
	return CurveFitPlotType{typ: "timeSeries", timeSeries: &v}
}

func NewCurveFitPlotTypeFromScatter(v ScatterCurveFit) CurveFitPlotType {
	return CurveFitPlotType{typ: "scatter", scatter: &v}
}

type CurveResultDetails struct {
	typ         string
	exponential *ExponentialResultDetails
	logarithmic *LogarithmicResultDetails
	polynomial  *PolynomialResultDetails
	power       *PowerResultDetails
}

type curveResultDetailsDeserializer struct {
	Type        string                    `json:"type"`
	Exponential *ExponentialResultDetails `json:"exponential"`
	Logarithmic *LogarithmicResultDetails `json:"logarithmic"`
	Polynomial  *PolynomialResultDetails  `json:"polynomial"`
	Power       *PowerResultDetails       `json:"power"`
}

func (u *curveResultDetailsDeserializer) toStruct() CurveResultDetails {
	return CurveResultDetails{typ: u.Type, exponential: u.Exponential, logarithmic: u.Logarithmic, polynomial: u.Polynomial, power: u.Power}
}

func (u *CurveResultDetails) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "exponential":
		if u.exponential == nil {
			return nil, fmt.Errorf("field \"exponential\" is required")
		}
		return struct {
			Type        string                   `json:"type"`
			Exponential ExponentialResultDetails `json:"exponential"`
		}{Type: "exponential", Exponential: *u.exponential}, nil
	case "logarithmic":
		if u.logarithmic == nil {
			return nil, fmt.Errorf("field \"logarithmic\" is required")
		}
		return struct {
			Type        string                   `json:"type"`
			Logarithmic LogarithmicResultDetails `json:"logarithmic"`
		}{Type: "logarithmic", Logarithmic: *u.logarithmic}, nil
	case "polynomial":
		if u.polynomial == nil {
			return nil, fmt.Errorf("field \"polynomial\" is required")
		}
		return struct {
			Type       string                  `json:"type"`
			Polynomial PolynomialResultDetails `json:"polynomial"`
		}{Type: "polynomial", Polynomial: *u.polynomial}, nil
	case "power":
		if u.power == nil {
			return nil, fmt.Errorf("field \"power\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Power PowerResultDetails `json:"power"`
		}{Type: "power", Power: *u.power}, nil
	}
}

func (u CurveResultDetails) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CurveResultDetails) UnmarshalJSON(data []byte) error {
	var deser curveResultDetailsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
	}
	return nil
}

func (u CurveResultDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CurveResultDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CurveResultDetails) AcceptFuncs(exponentialFunc func(ExponentialResultDetails) error, logarithmicFunc func(LogarithmicResultDetails) error, polynomialFunc func(PolynomialResultDetails) error, powerFunc func(PowerResultDetails) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return exponentialFunc(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return logarithmicFunc(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return polynomialFunc(*u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return powerFunc(*u.power)
	}
}

func (u *CurveResultDetails) ExponentialNoopSuccess(ExponentialResultDetails) error {
	return nil
}

func (u *CurveResultDetails) LogarithmicNoopSuccess(LogarithmicResultDetails) error {
	return nil
}

func (u *CurveResultDetails) PolynomialNoopSuccess(PolynomialResultDetails) error {
	return nil
}

func (u *CurveResultDetails) PowerNoopSuccess(PowerResultDetails) error {
	return nil
}

func (u *CurveResultDetails) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CurveResultDetails) Accept(v CurveResultDetailsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponential(*u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmic(*u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomial(*u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPower(*u.power)
	}
}

type CurveResultDetailsVisitor interface {
	VisitExponential(v ExponentialResultDetails) error
	VisitLogarithmic(v LogarithmicResultDetails) error
	VisitPolynomial(v PolynomialResultDetails) error
	VisitPower(v PowerResultDetails) error
	VisitUnknown(typeName string) error
}

func (u *CurveResultDetails) AcceptWithContext(ctx context.Context, v CurveResultDetailsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "exponential":
		if u.exponential == nil {
			return fmt.Errorf("field \"exponential\" is required")
		}
		return v.VisitExponentialWithContext(ctx, *u.exponential)
	case "logarithmic":
		if u.logarithmic == nil {
			return fmt.Errorf("field \"logarithmic\" is required")
		}
		return v.VisitLogarithmicWithContext(ctx, *u.logarithmic)
	case "polynomial":
		if u.polynomial == nil {
			return fmt.Errorf("field \"polynomial\" is required")
		}
		return v.VisitPolynomialWithContext(ctx, *u.polynomial)
	case "power":
		if u.power == nil {
			return fmt.Errorf("field \"power\" is required")
		}
		return v.VisitPowerWithContext(ctx, *u.power)
	}
}

type CurveResultDetailsVisitorWithContext interface {
	VisitExponentialWithContext(ctx context.Context, v ExponentialResultDetails) error
	VisitLogarithmicWithContext(ctx context.Context, v LogarithmicResultDetails) error
	VisitPolynomialWithContext(ctx context.Context, v PolynomialResultDetails) error
	VisitPowerWithContext(ctx context.Context, v PowerResultDetails) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCurveResultDetailsFromExponential(v ExponentialResultDetails) CurveResultDetails {
	return CurveResultDetails{typ: "exponential", exponential: &v}
}

func NewCurveResultDetailsFromLogarithmic(v LogarithmicResultDetails) CurveResultDetails {
	return CurveResultDetails{typ: "logarithmic", logarithmic: &v}
}

func NewCurveResultDetailsFromPolynomial(v PolynomialResultDetails) CurveResultDetails {
	return CurveResultDetails{typ: "polynomial", polynomial: &v}
}

func NewCurveResultDetailsFromPower(v PowerResultDetails) CurveResultDetails {
	return CurveResultDetails{typ: "power", power: &v}
}

type DecimateStrategy struct {
	typ        string
	resolution *DecimateWithResolution
	buckets    *DecimateWithBuckets
}

type decimateStrategyDeserializer struct {
	Type       string                  `json:"type"`
	Resolution *DecimateWithResolution `json:"resolution"`
	Buckets    *DecimateWithBuckets    `json:"buckets"`
}

func (u *decimateStrategyDeserializer) toStruct() DecimateStrategy {
	return DecimateStrategy{typ: u.Type, resolution: u.Resolution, buckets: u.Buckets}
}

func (u *DecimateStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "resolution":
		if u.resolution == nil {
			return nil, fmt.Errorf("field \"resolution\" is required")
		}
		return struct {
			Type       string                 `json:"type"`
			Resolution DecimateWithResolution `json:"resolution"`
		}{Type: "resolution", Resolution: *u.resolution}, nil
	case "buckets":
		if u.buckets == nil {
			return nil, fmt.Errorf("field \"buckets\" is required")
		}
		return struct {
			Type    string              `json:"type"`
			Buckets DecimateWithBuckets `json:"buckets"`
		}{Type: "buckets", Buckets: *u.buckets}, nil
	}
}

func (u DecimateStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DecimateStrategy) UnmarshalJSON(data []byte) error {
	var deser decimateStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "resolution":
		if u.resolution == nil {
			return fmt.Errorf("field \"resolution\" is required")
		}
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
	}
	return nil
}

func (u DecimateStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DecimateStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DecimateStrategy) AcceptFuncs(resolutionFunc func(DecimateWithResolution) error, bucketsFunc func(DecimateWithBuckets) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "resolution":
		if u.resolution == nil {
			return fmt.Errorf("field \"resolution\" is required")
		}
		return resolutionFunc(*u.resolution)
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
		return bucketsFunc(*u.buckets)
	}
}

func (u *DecimateStrategy) ResolutionNoopSuccess(DecimateWithResolution) error {
	return nil
}

func (u *DecimateStrategy) BucketsNoopSuccess(DecimateWithBuckets) error {
	return nil
}

func (u *DecimateStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DecimateStrategy) Accept(v DecimateStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "resolution":
		if u.resolution == nil {
			return fmt.Errorf("field \"resolution\" is required")
		}
		return v.VisitResolution(*u.resolution)
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
		return v.VisitBuckets(*u.buckets)
	}
}

type DecimateStrategyVisitor interface {
	VisitResolution(v DecimateWithResolution) error
	VisitBuckets(v DecimateWithBuckets) error
	VisitUnknown(typeName string) error
}

func (u *DecimateStrategy) AcceptWithContext(ctx context.Context, v DecimateStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "resolution":
		if u.resolution == nil {
			return fmt.Errorf("field \"resolution\" is required")
		}
		return v.VisitResolutionWithContext(ctx, *u.resolution)
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
		return v.VisitBucketsWithContext(ctx, *u.buckets)
	}
}

type DecimateStrategyVisitorWithContext interface {
	VisitResolutionWithContext(ctx context.Context, v DecimateWithResolution) error
	VisitBucketsWithContext(ctx context.Context, v DecimateWithBuckets) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDecimateStrategyFromResolution(v DecimateWithResolution) DecimateStrategy {
	return DecimateStrategy{typ: "resolution", resolution: &v}
}

func NewDecimateStrategyFromBuckets(v DecimateWithBuckets) DecimateStrategy {
	return DecimateStrategy{typ: "buckets", buckets: &v}
}

/*
Represents a derived series within a compute graph.
This is a series that is derived from a function within a module.
*/
type DerivedSeries struct {
	typ               string
	moduleApplication *ModuleApplicationDerivedSeries
}

type derivedSeriesDeserializer struct {
	Type              string                          `json:"type"`
	ModuleApplication *ModuleApplicationDerivedSeries `json:"moduleApplication"`
}

func (u *derivedSeriesDeserializer) toStruct() DerivedSeries {
	return DerivedSeries{typ: u.Type, moduleApplication: u.ModuleApplication}
}

func (u *DerivedSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "moduleApplication":
		if u.moduleApplication == nil {
			return nil, fmt.Errorf("field \"moduleApplication\" is required")
		}
		return struct {
			Type              string                         `json:"type"`
			ModuleApplication ModuleApplicationDerivedSeries `json:"moduleApplication"`
		}{Type: "moduleApplication", ModuleApplication: *u.moduleApplication}, nil
	}
}

func (u DerivedSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DerivedSeries) UnmarshalJSON(data []byte) error {
	var deser derivedSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "moduleApplication":
		if u.moduleApplication == nil {
			return fmt.Errorf("field \"moduleApplication\" is required")
		}
	}
	return nil
}

func (u DerivedSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DerivedSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DerivedSeries) AcceptFuncs(moduleApplicationFunc func(ModuleApplicationDerivedSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "moduleApplication":
		if u.moduleApplication == nil {
			return fmt.Errorf("field \"moduleApplication\" is required")
		}
		return moduleApplicationFunc(*u.moduleApplication)
	}
}

func (u *DerivedSeries) ModuleApplicationNoopSuccess(ModuleApplicationDerivedSeries) error {
	return nil
}

func (u *DerivedSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DerivedSeries) Accept(v DerivedSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "moduleApplication":
		if u.moduleApplication == nil {
			return fmt.Errorf("field \"moduleApplication\" is required")
		}
		return v.VisitModuleApplication(*u.moduleApplication)
	}
}

type DerivedSeriesVisitor interface {
	VisitModuleApplication(v ModuleApplicationDerivedSeries) error
	VisitUnknown(typeName string) error
}

func (u *DerivedSeries) AcceptWithContext(ctx context.Context, v DerivedSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "moduleApplication":
		if u.moduleApplication == nil {
			return fmt.Errorf("field \"moduleApplication\" is required")
		}
		return v.VisitModuleApplicationWithContext(ctx, *u.moduleApplication)
	}
}

type DerivedSeriesVisitorWithContext interface {
	VisitModuleApplicationWithContext(ctx context.Context, v ModuleApplicationDerivedSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDerivedSeriesFromModuleApplication(v ModuleApplicationDerivedSeries) DerivedSeries {
	return DerivedSeries{typ: "moduleApplication", moduleApplication: &v}
}

type DoubleConstant struct {
	typ      string
	literal  *float64
	variable *VariableName
}

type doubleConstantDeserializer struct {
	Type     string        `json:"type"`
	Literal  *float64      `json:"literal"`
	Variable *VariableName `json:"variable"`
}

func (u *doubleConstantDeserializer) toStruct() DoubleConstant {
	return DoubleConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *DoubleConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Literal float64 `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Variable VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u DoubleConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DoubleConstant) UnmarshalJSON(data []byte) error {
	var deser doubleConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u DoubleConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DoubleConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DoubleConstant) AcceptFuncs(literalFunc func(float64) error, variableFunc func(VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *DoubleConstant) LiteralNoopSuccess(float64) error {
	return nil
}

func (u *DoubleConstant) VariableNoopSuccess(VariableName) error {
	return nil
}

func (u *DoubleConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DoubleConstant) Accept(v DoubleConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type DoubleConstantVisitor interface {
	VisitLiteral(v float64) error
	VisitVariable(v VariableName) error
	VisitUnknown(typeName string) error
}

func (u *DoubleConstant) AcceptWithContext(ctx context.Context, v DoubleConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type DoubleConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v float64) error
	VisitVariableWithContext(ctx context.Context, v VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDoubleConstantFromLiteral(v float64) DoubleConstant {
	return DoubleConstant{typ: "literal", literal: &v}
}

func NewDoubleConstantFromVariable(v VariableName) DoubleConstant {
	return DoubleConstant{typ: "variable", variable: &v}
}

type DurationConstant struct {
	typ      string
	literal  *api.Duration
	variable *VariableName
}

type durationConstantDeserializer struct {
	Type     string        `json:"type"`
	Literal  *api.Duration `json:"literal"`
	Variable *VariableName `json:"variable"`
}

func (u *durationConstantDeserializer) toStruct() DurationConstant {
	return DurationConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *DurationConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string       `json:"type"`
			Literal api.Duration `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Variable VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u DurationConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DurationConstant) UnmarshalJSON(data []byte) error {
	var deser durationConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u DurationConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DurationConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DurationConstant) AcceptFuncs(literalFunc func(api.Duration) error, variableFunc func(VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *DurationConstant) LiteralNoopSuccess(api.Duration) error {
	return nil
}

func (u *DurationConstant) VariableNoopSuccess(VariableName) error {
	return nil
}

func (u *DurationConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DurationConstant) Accept(v DurationConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type DurationConstantVisitor interface {
	VisitLiteral(v api.Duration) error
	VisitVariable(v VariableName) error
	VisitUnknown(typeName string) error
}

func (u *DurationConstant) AcceptWithContext(ctx context.Context, v DurationConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type DurationConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v api.Duration) error
	VisitVariableWithContext(ctx context.Context, v VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDurationConstantFromLiteral(v api.Duration) DurationConstant {
	return DurationConstant{typ: "literal", literal: &v}
}

func NewDurationConstantFromVariable(v VariableName) DurationConstant {
	return DurationConstant{typ: "variable", variable: &v}
}

type Enum1dArraySeries struct {
	typ     string
	channel *ChannelSeries
	raw     *Reference
	derived *DerivedSeries
}

type enum1dArraySeriesDeserializer struct {
	Type    string         `json:"type"`
	Channel *ChannelSeries `json:"channel"`
	Raw     *Reference     `json:"raw"`
	Derived *DerivedSeries `json:"derived"`
}

func (u *enum1dArraySeriesDeserializer) toStruct() Enum1dArraySeries {
	return Enum1dArraySeries{typ: u.Type, channel: u.Channel, raw: u.Raw, derived: u.Derived}
}

func (u *Enum1dArraySeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Channel ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Raw  Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	}
}

func (u Enum1dArraySeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Enum1dArraySeries) UnmarshalJSON(data []byte) error {
	var deser enum1dArraySeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	}
	return nil
}

func (u Enum1dArraySeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Enum1dArraySeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Enum1dArraySeries) AcceptFuncs(channelFunc func(ChannelSeries) error, rawFunc func(Reference) error, derivedFunc func(DerivedSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	}
}

func (u *Enum1dArraySeries) ChannelNoopSuccess(ChannelSeries) error {
	return nil
}

func (u *Enum1dArraySeries) RawNoopSuccess(Reference) error {
	return nil
}

func (u *Enum1dArraySeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *Enum1dArraySeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Enum1dArraySeries) Accept(v Enum1dArraySeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	}
}

type Enum1dArraySeriesVisitor interface {
	VisitChannel(v ChannelSeries) error
	VisitRaw(v Reference) error
	VisitDerived(v DerivedSeries) error
	VisitUnknown(typeName string) error
}

func (u *Enum1dArraySeries) AcceptWithContext(ctx context.Context, v Enum1dArraySeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	}
}

type Enum1dArraySeriesVisitorWithContext interface {
	VisitChannelWithContext(ctx context.Context, v ChannelSeries) error
	VisitRawWithContext(ctx context.Context, v Reference) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnum1dArraySeriesFromChannel(v ChannelSeries) Enum1dArraySeries {
	return Enum1dArraySeries{typ: "channel", channel: &v}
}

func NewEnum1dArraySeriesFromRaw(v Reference) Enum1dArraySeries {
	return Enum1dArraySeries{typ: "raw", raw: &v}
}

func NewEnum1dArraySeriesFromDerived(v DerivedSeries) Enum1dArraySeries {
	return Enum1dArraySeries{typ: "derived", derived: &v}
}

type EnumSeries struct {
	typ                  string
	aggregate            *AggregateEnumSeries
	raw                  *Reference
	channel              *ChannelSeries
	derived              *DerivedSeries
	resample             *EnumResampleSeries
	timeRangeFilter      *EnumTimeRangeFilterSeries
	timeShift            *EnumTimeShiftSeries
	union                *EnumUnionSeries
	filterTransformation *EnumFilterTransformationSeries
	valueMap             *ValueMapSeries
	select1dArrayIndex   *SelectIndexFrom1dEnumArraySeries
}

type enumSeriesDeserializer struct {
	Type                 string                            `json:"type"`
	Aggregate            *AggregateEnumSeries              `json:"aggregate"`
	Raw                  *Reference                        `json:"raw"`
	Channel              *ChannelSeries                    `json:"channel"`
	Derived              *DerivedSeries                    `json:"derived"`
	Resample             *EnumResampleSeries               `json:"resample"`
	TimeRangeFilter      *EnumTimeRangeFilterSeries        `json:"timeRangeFilter"`
	TimeShift            *EnumTimeShiftSeries              `json:"timeShift"`
	Union                *EnumUnionSeries                  `json:"union"`
	FilterTransformation *EnumFilterTransformationSeries   `json:"filterTransformation"`
	ValueMap             *ValueMapSeries                   `json:"valueMap"`
	Select1dArrayIndex   *SelectIndexFrom1dEnumArraySeries `json:"select1dArrayIndex"`
}

func (u *enumSeriesDeserializer) toStruct() EnumSeries {
	return EnumSeries{typ: u.Type, aggregate: u.Aggregate, raw: u.Raw, channel: u.Channel, derived: u.Derived, resample: u.Resample, timeRangeFilter: u.TimeRangeFilter, timeShift: u.TimeShift, union: u.Union, filterTransformation: u.FilterTransformation, valueMap: u.ValueMap, select1dArrayIndex: u.Select1dArrayIndex}
}

func (u *EnumSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return nil, fmt.Errorf("field \"aggregate\" is required")
		}
		return struct {
			Type      string              `json:"type"`
			Aggregate AggregateEnumSeries `json:"aggregate"`
		}{Type: "aggregate", Aggregate: *u.aggregate}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Raw  Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Channel ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	case "resample":
		if u.resample == nil {
			return nil, fmt.Errorf("field \"resample\" is required")
		}
		return struct {
			Type     string             `json:"type"`
			Resample EnumResampleSeries `json:"resample"`
		}{Type: "resample", Resample: *u.resample}, nil
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return nil, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return struct {
			Type            string                    `json:"type"`
			TimeRangeFilter EnumTimeRangeFilterSeries `json:"timeRangeFilter"`
		}{Type: "timeRangeFilter", TimeRangeFilter: *u.timeRangeFilter}, nil
	case "timeShift":
		if u.timeShift == nil {
			return nil, fmt.Errorf("field \"timeShift\" is required")
		}
		return struct {
			Type      string              `json:"type"`
			TimeShift EnumTimeShiftSeries `json:"timeShift"`
		}{Type: "timeShift", TimeShift: *u.timeShift}, nil
	case "union":
		if u.union == nil {
			return nil, fmt.Errorf("field \"union\" is required")
		}
		return struct {
			Type  string          `json:"type"`
			Union EnumUnionSeries `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	case "filterTransformation":
		if u.filterTransformation == nil {
			return nil, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return struct {
			Type                 string                         `json:"type"`
			FilterTransformation EnumFilterTransformationSeries `json:"filterTransformation"`
		}{Type: "filterTransformation", FilterTransformation: *u.filterTransformation}, nil
	case "valueMap":
		if u.valueMap == nil {
			return nil, fmt.Errorf("field \"valueMap\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			ValueMap ValueMapSeries `json:"valueMap"`
		}{Type: "valueMap", ValueMap: *u.valueMap}, nil
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return nil, fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return struct {
			Type               string                           `json:"type"`
			Select1dArrayIndex SelectIndexFrom1dEnumArraySeries `json:"select1dArrayIndex"`
		}{Type: "select1dArrayIndex", Select1dArrayIndex: *u.select1dArrayIndex}, nil
	}
}

func (u EnumSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumSeries) UnmarshalJSON(data []byte) error {
	var deser enumSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
	}
	return nil
}

func (u EnumSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumSeries) AcceptFuncs(aggregateFunc func(AggregateEnumSeries) error, rawFunc func(Reference) error, channelFunc func(ChannelSeries) error, derivedFunc func(DerivedSeries) error, resampleFunc func(EnumResampleSeries) error, timeRangeFilterFunc func(EnumTimeRangeFilterSeries) error, timeShiftFunc func(EnumTimeShiftSeries) error, unionFunc func(EnumUnionSeries) error, filterTransformationFunc func(EnumFilterTransformationSeries) error, valueMapFunc func(ValueMapSeries) error, select1dArrayIndexFunc func(SelectIndexFrom1dEnumArraySeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return aggregateFunc(*u.aggregate)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return resampleFunc(*u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return filterTransformationFunc(*u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
		return valueMapFunc(*u.valueMap)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return select1dArrayIndexFunc(*u.select1dArrayIndex)
	}
}

func (u *EnumSeries) AggregateNoopSuccess(AggregateEnumSeries) error {
	return nil
}

func (u *EnumSeries) RawNoopSuccess(Reference) error {
	return nil
}

func (u *EnumSeries) ChannelNoopSuccess(ChannelSeries) error {
	return nil
}

func (u *EnumSeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *EnumSeries) ResampleNoopSuccess(EnumResampleSeries) error {
	return nil
}

func (u *EnumSeries) TimeRangeFilterNoopSuccess(EnumTimeRangeFilterSeries) error {
	return nil
}

func (u *EnumSeries) TimeShiftNoopSuccess(EnumTimeShiftSeries) error {
	return nil
}

func (u *EnumSeries) UnionNoopSuccess(EnumUnionSeries) error {
	return nil
}

func (u *EnumSeries) FilterTransformationNoopSuccess(EnumFilterTransformationSeries) error {
	return nil
}

func (u *EnumSeries) ValueMapNoopSuccess(ValueMapSeries) error {
	return nil
}

func (u *EnumSeries) Select1dArrayIndexNoopSuccess(SelectIndexFrom1dEnumArraySeries) error {
	return nil
}

func (u *EnumSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumSeries) Accept(v EnumSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregate(*u.aggregate)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResample(*u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(*u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformation(*u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
		return v.VisitValueMap(*u.valueMap)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return v.VisitSelect1dArrayIndex(*u.select1dArrayIndex)
	}
}

type EnumSeriesVisitor interface {
	VisitAggregate(v AggregateEnumSeries) error
	VisitRaw(v Reference) error
	VisitChannel(v ChannelSeries) error
	VisitDerived(v DerivedSeries) error
	VisitResample(v EnumResampleSeries) error
	VisitTimeRangeFilter(v EnumTimeRangeFilterSeries) error
	VisitTimeShift(v EnumTimeShiftSeries) error
	VisitUnion(v EnumUnionSeries) error
	VisitFilterTransformation(v EnumFilterTransformationSeries) error
	VisitValueMap(v ValueMapSeries) error
	VisitSelect1dArrayIndex(v SelectIndexFrom1dEnumArraySeries) error
	VisitUnknown(typeName string) error
}

func (u *EnumSeries) AcceptWithContext(ctx context.Context, v EnumSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregateWithContext(ctx, *u.aggregate)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResampleWithContext(ctx, *u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilterWithContext(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShiftWithContext(ctx, *u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformationWithContext(ctx, *u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
		return v.VisitValueMapWithContext(ctx, *u.valueMap)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return v.VisitSelect1dArrayIndexWithContext(ctx, *u.select1dArrayIndex)
	}
}

type EnumSeriesVisitorWithContext interface {
	VisitAggregateWithContext(ctx context.Context, v AggregateEnumSeries) error
	VisitRawWithContext(ctx context.Context, v Reference) error
	VisitChannelWithContext(ctx context.Context, v ChannelSeries) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitResampleWithContext(ctx context.Context, v EnumResampleSeries) error
	VisitTimeRangeFilterWithContext(ctx context.Context, v EnumTimeRangeFilterSeries) error
	VisitTimeShiftWithContext(ctx context.Context, v EnumTimeShiftSeries) error
	VisitUnionWithContext(ctx context.Context, v EnumUnionSeries) error
	VisitFilterTransformationWithContext(ctx context.Context, v EnumFilterTransformationSeries) error
	VisitValueMapWithContext(ctx context.Context, v ValueMapSeries) error
	VisitSelect1dArrayIndexWithContext(ctx context.Context, v SelectIndexFrom1dEnumArraySeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumSeriesFromAggregate(v AggregateEnumSeries) EnumSeries {
	return EnumSeries{typ: "aggregate", aggregate: &v}
}

func NewEnumSeriesFromRaw(v Reference) EnumSeries {
	return EnumSeries{typ: "raw", raw: &v}
}

func NewEnumSeriesFromChannel(v ChannelSeries) EnumSeries {
	return EnumSeries{typ: "channel", channel: &v}
}

func NewEnumSeriesFromDerived(v DerivedSeries) EnumSeries {
	return EnumSeries{typ: "derived", derived: &v}
}

func NewEnumSeriesFromResample(v EnumResampleSeries) EnumSeries {
	return EnumSeries{typ: "resample", resample: &v}
}

func NewEnumSeriesFromTimeRangeFilter(v EnumTimeRangeFilterSeries) EnumSeries {
	return EnumSeries{typ: "timeRangeFilter", timeRangeFilter: &v}
}

func NewEnumSeriesFromTimeShift(v EnumTimeShiftSeries) EnumSeries {
	return EnumSeries{typ: "timeShift", timeShift: &v}
}

func NewEnumSeriesFromUnion(v EnumUnionSeries) EnumSeries {
	return EnumSeries{typ: "union", union: &v}
}

func NewEnumSeriesFromFilterTransformation(v EnumFilterTransformationSeries) EnumSeries {
	return EnumSeries{typ: "filterTransformation", filterTransformation: &v}
}

func NewEnumSeriesFromValueMap(v ValueMapSeries) EnumSeries {
	return EnumSeries{typ: "valueMap", valueMap: &v}
}

func NewEnumSeriesFromSelect1dArrayIndex(v SelectIndexFrom1dEnumArraySeries) EnumSeries {
	return EnumSeries{typ: "select1dArrayIndex", select1dArrayIndex: &v}
}

type FrequencyDomain struct {
	typ string
	fft *Fft
}

type frequencyDomainDeserializer struct {
	Type string `json:"type"`
	Fft  *Fft   `json:"fft"`
}

func (u *frequencyDomainDeserializer) toStruct() FrequencyDomain {
	return FrequencyDomain{typ: u.Type, fft: u.Fft}
}

func (u *FrequencyDomain) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "fft":
		if u.fft == nil {
			return nil, fmt.Errorf("field \"fft\" is required")
		}
		return struct {
			Type string `json:"type"`
			Fft  Fft    `json:"fft"`
		}{Type: "fft", Fft: *u.fft}, nil
	}
}

func (u FrequencyDomain) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FrequencyDomain) UnmarshalJSON(data []byte) error {
	var deser frequencyDomainDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
	}
	return nil
}

func (u FrequencyDomain) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FrequencyDomain) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FrequencyDomain) AcceptFuncs(fftFunc func(Fft) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	}
}

func (u *FrequencyDomain) FftNoopSuccess(Fft) error {
	return nil
}

func (u *FrequencyDomain) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FrequencyDomain) Accept(v FrequencyDomainVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(*u.fft)
	}
}

type FrequencyDomainVisitor interface {
	VisitFft(v Fft) error
	VisitUnknown(typeName string) error
}

func (u *FrequencyDomain) AcceptWithContext(ctx context.Context, v FrequencyDomainVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFftWithContext(ctx, *u.fft)
	}
}

type FrequencyDomainVisitorWithContext interface {
	VisitFftWithContext(ctx context.Context, v Fft) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFrequencyDomainFromFft(v Fft) FrequencyDomain {
	return FrequencyDomain{typ: "fft", fft: &v}
}

// Represents a geographic point. Flexible to handle multiple types of geographic coordinate systems.
type GeoPoint struct {
	typ     string
	latLong *LatLongPoint
}

type geoPointDeserializer struct {
	Type    string        `json:"type"`
	LatLong *LatLongPoint `json:"latLong"`
}

func (u *geoPointDeserializer) toStruct() GeoPoint {
	return GeoPoint{typ: u.Type, latLong: u.LatLong}
}

func (u *GeoPoint) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "latLong":
		if u.latLong == nil {
			return nil, fmt.Errorf("field \"latLong\" is required")
		}
		return struct {
			Type    string       `json:"type"`
			LatLong LatLongPoint `json:"latLong"`
		}{Type: "latLong", LatLong: *u.latLong}, nil
	}
}

func (u GeoPoint) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *GeoPoint) UnmarshalJSON(data []byte) error {
	var deser geoPointDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "latLong":
		if u.latLong == nil {
			return fmt.Errorf("field \"latLong\" is required")
		}
	}
	return nil
}

func (u GeoPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *GeoPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *GeoPoint) AcceptFuncs(latLongFunc func(LatLongPoint) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "latLong":
		if u.latLong == nil {
			return fmt.Errorf("field \"latLong\" is required")
		}
		return latLongFunc(*u.latLong)
	}
}

func (u *GeoPoint) LatLongNoopSuccess(LatLongPoint) error {
	return nil
}

func (u *GeoPoint) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *GeoPoint) Accept(v GeoPointVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "latLong":
		if u.latLong == nil {
			return fmt.Errorf("field \"latLong\" is required")
		}
		return v.VisitLatLong(*u.latLong)
	}
}

type GeoPointVisitor interface {
	VisitLatLong(v LatLongPoint) error
	VisitUnknown(typeName string) error
}

func (u *GeoPoint) AcceptWithContext(ctx context.Context, v GeoPointVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "latLong":
		if u.latLong == nil {
			return fmt.Errorf("field \"latLong\" is required")
		}
		return v.VisitLatLongWithContext(ctx, *u.latLong)
	}
}

type GeoPointVisitorWithContext interface {
	VisitLatLongWithContext(ctx context.Context, v LatLongPoint) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeoPointFromLatLong(v LatLongPoint) GeoPoint {
	return GeoPoint{typ: "latLong", latLong: &v}
}

type GeoSeries struct {
	typ            string
	latLongGeoNode *LatLongGeo
}

type geoSeriesDeserializer struct {
	Type           string      `json:"type"`
	LatLongGeoNode *LatLongGeo `json:"latLongGeoNode"`
}

func (u *geoSeriesDeserializer) toStruct() GeoSeries {
	return GeoSeries{typ: u.Type, latLongGeoNode: u.LatLongGeoNode}
}

func (u *GeoSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "latLongGeoNode":
		if u.latLongGeoNode == nil {
			return nil, fmt.Errorf("field \"latLongGeoNode\" is required")
		}
		return struct {
			Type           string     `json:"type"`
			LatLongGeoNode LatLongGeo `json:"latLongGeoNode"`
		}{Type: "latLongGeoNode", LatLongGeoNode: *u.latLongGeoNode}, nil
	}
}

func (u GeoSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *GeoSeries) UnmarshalJSON(data []byte) error {
	var deser geoSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "latLongGeoNode":
		if u.latLongGeoNode == nil {
			return fmt.Errorf("field \"latLongGeoNode\" is required")
		}
	}
	return nil
}

func (u GeoSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *GeoSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *GeoSeries) AcceptFuncs(latLongGeoNodeFunc func(LatLongGeo) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "latLongGeoNode":
		if u.latLongGeoNode == nil {
			return fmt.Errorf("field \"latLongGeoNode\" is required")
		}
		return latLongGeoNodeFunc(*u.latLongGeoNode)
	}
}

func (u *GeoSeries) LatLongGeoNodeNoopSuccess(LatLongGeo) error {
	return nil
}

func (u *GeoSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *GeoSeries) Accept(v GeoSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "latLongGeoNode":
		if u.latLongGeoNode == nil {
			return fmt.Errorf("field \"latLongGeoNode\" is required")
		}
		return v.VisitLatLongGeoNode(*u.latLongGeoNode)
	}
}

type GeoSeriesVisitor interface {
	VisitLatLongGeoNode(v LatLongGeo) error
	VisitUnknown(typeName string) error
}

func (u *GeoSeries) AcceptWithContext(ctx context.Context, v GeoSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "latLongGeoNode":
		if u.latLongGeoNode == nil {
			return fmt.Errorf("field \"latLongGeoNode\" is required")
		}
		return v.VisitLatLongGeoNodeWithContext(ctx, *u.latLongGeoNode)
	}
}

type GeoSeriesVisitorWithContext interface {
	VisitLatLongGeoNodeWithContext(ctx context.Context, v LatLongGeo) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeoSeriesFromLatLongGeoNode(v LatLongGeo) GeoSeries {
	return GeoSeries{typ: "latLongGeoNode", latLongGeoNode: &v}
}

type GeoSummaryStrategy struct {
	typ      string
	temporal *GeoTemporalSummary
}

type geoSummaryStrategyDeserializer struct {
	Type     string              `json:"type"`
	Temporal *GeoTemporalSummary `json:"temporal"`
}

func (u *geoSummaryStrategyDeserializer) toStruct() GeoSummaryStrategy {
	return GeoSummaryStrategy{typ: u.Type, temporal: u.Temporal}
}

func (u *GeoSummaryStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "temporal":
		if u.temporal == nil {
			return nil, fmt.Errorf("field \"temporal\" is required")
		}
		return struct {
			Type     string             `json:"type"`
			Temporal GeoTemporalSummary `json:"temporal"`
		}{Type: "temporal", Temporal: *u.temporal}, nil
	}
}

func (u GeoSummaryStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *GeoSummaryStrategy) UnmarshalJSON(data []byte) error {
	var deser geoSummaryStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "temporal":
		if u.temporal == nil {
			return fmt.Errorf("field \"temporal\" is required")
		}
	}
	return nil
}

func (u GeoSummaryStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *GeoSummaryStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *GeoSummaryStrategy) AcceptFuncs(temporalFunc func(GeoTemporalSummary) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "temporal":
		if u.temporal == nil {
			return fmt.Errorf("field \"temporal\" is required")
		}
		return temporalFunc(*u.temporal)
	}
}

func (u *GeoSummaryStrategy) TemporalNoopSuccess(GeoTemporalSummary) error {
	return nil
}

func (u *GeoSummaryStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *GeoSummaryStrategy) Accept(v GeoSummaryStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "temporal":
		if u.temporal == nil {
			return fmt.Errorf("field \"temporal\" is required")
		}
		return v.VisitTemporal(*u.temporal)
	}
}

type GeoSummaryStrategyVisitor interface {
	VisitTemporal(v GeoTemporalSummary) error
	VisitUnknown(typeName string) error
}

func (u *GeoSummaryStrategy) AcceptWithContext(ctx context.Context, v GeoSummaryStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "temporal":
		if u.temporal == nil {
			return fmt.Errorf("field \"temporal\" is required")
		}
		return v.VisitTemporalWithContext(ctx, *u.temporal)
	}
}

type GeoSummaryStrategyVisitorWithContext interface {
	VisitTemporalWithContext(ctx context.Context, v GeoTemporalSummary) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeoSummaryStrategyFromTemporal(v GeoTemporalSummary) GeoSummaryStrategy {
	return GeoSummaryStrategy{typ: "temporal", temporal: &v}
}

type Grouping struct {
	typ            string
	tagsWithValues *map[string]string
}

type groupingDeserializer struct {
	Type           string             `json:"type"`
	TagsWithValues *map[string]string `json:"tagsWithValues"`
}

func (u *groupingDeserializer) toStruct() Grouping {
	return Grouping{typ: u.Type, tagsWithValues: u.TagsWithValues}
}

func (u *Grouping) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return nil, fmt.Errorf("field \"tagsWithValues\" is required")
		}
		return struct {
			Type           string            `json:"type"`
			TagsWithValues map[string]string `json:"tagsWithValues"`
		}{Type: "tagsWithValues", TagsWithValues: *u.tagsWithValues}, nil
	}
}

func (u Grouping) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Grouping) UnmarshalJSON(data []byte) error {
	var deser groupingDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return fmt.Errorf("field \"tagsWithValues\" is required")
		}
	}
	return nil
}

func (u Grouping) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Grouping) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Grouping) AcceptFuncs(tagsWithValuesFunc func(map[string]string) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return fmt.Errorf("field \"tagsWithValues\" is required")
		}
		return tagsWithValuesFunc(*u.tagsWithValues)
	}
}

func (u *Grouping) TagsWithValuesNoopSuccess(map[string]string) error {
	return nil
}

func (u *Grouping) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Grouping) Accept(v GroupingVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return fmt.Errorf("field \"tagsWithValues\" is required")
		}
		return v.VisitTagsWithValues(*u.tagsWithValues)
	}
}

type GroupingVisitor interface {
	VisitTagsWithValues(v map[string]string) error
	VisitUnknown(typeName string) error
}

func (u *Grouping) AcceptWithContext(ctx context.Context, v GroupingVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "tagsWithValues":
		if u.tagsWithValues == nil {
			return fmt.Errorf("field \"tagsWithValues\" is required")
		}
		return v.VisitTagsWithValuesWithContext(ctx, *u.tagsWithValues)
	}
}

type GroupingVisitorWithContext interface {
	VisitTagsWithValuesWithContext(ctx context.Context, v map[string]string) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGroupingFromTagsWithValues(v map[string]string) Grouping {
	return Grouping{typ: "tagsWithValues", tagsWithValues: &v}
}

type Histogram struct {
	typ     string
	numeric *NumericHistogramNode
	enum    *EnumHistogramNode
}

type histogramDeserializer struct {
	Type    string                `json:"type"`
	Numeric *NumericHistogramNode `json:"numeric"`
	Enum    *EnumHistogramNode    `json:"enum"`
}

func (u *histogramDeserializer) toStruct() Histogram {
	return Histogram{typ: u.Type, numeric: u.Numeric, enum: u.Enum}
}

func (u *Histogram) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string               `json:"type"`
			Numeric NumericHistogramNode `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string            `json:"type"`
			Enum EnumHistogramNode `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	}
}

func (u Histogram) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Histogram) UnmarshalJSON(data []byte) error {
	var deser histogramDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	}
	return nil
}

func (u Histogram) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Histogram) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Histogram) AcceptFuncs(numericFunc func(NumericHistogramNode) error, enumFunc func(EnumHistogramNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	}
}

func (u *Histogram) NumericNoopSuccess(NumericHistogramNode) error {
	return nil
}

func (u *Histogram) EnumNoopSuccess(EnumHistogramNode) error {
	return nil
}

func (u *Histogram) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Histogram) Accept(v HistogramVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	}
}

type HistogramVisitor interface {
	VisitNumeric(v NumericHistogramNode) error
	VisitEnum(v EnumHistogramNode) error
	VisitUnknown(typeName string) error
}

func (u *Histogram) AcceptWithContext(ctx context.Context, v HistogramVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	}
}

type HistogramVisitorWithContext interface {
	VisitNumericWithContext(ctx context.Context, v NumericHistogramNode) error
	VisitEnumWithContext(ctx context.Context, v EnumHistogramNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewHistogramFromNumeric(v NumericHistogramNode) Histogram {
	return Histogram{typ: "numeric", numeric: &v}
}

func NewHistogramFromEnum(v EnumHistogramNode) Histogram {
	return Histogram{typ: "enum", enum: &v}
}

type IntegerConstant struct {
	typ      string
	literal  *int
	variable *VariableName
}

type integerConstantDeserializer struct {
	Type     string        `json:"type"`
	Literal  *int          `json:"literal"`
	Variable *VariableName `json:"variable"`
}

func (u *integerConstantDeserializer) toStruct() IntegerConstant {
	return IntegerConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *IntegerConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string `json:"type"`
			Literal int    `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Variable VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u IntegerConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *IntegerConstant) UnmarshalJSON(data []byte) error {
	var deser integerConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u IntegerConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *IntegerConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *IntegerConstant) AcceptFuncs(literalFunc func(int) error, variableFunc func(VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *IntegerConstant) LiteralNoopSuccess(int) error {
	return nil
}

func (u *IntegerConstant) VariableNoopSuccess(VariableName) error {
	return nil
}

func (u *IntegerConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *IntegerConstant) Accept(v IntegerConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type IntegerConstantVisitor interface {
	VisitLiteral(v int) error
	VisitVariable(v VariableName) error
	VisitUnknown(typeName string) error
}

func (u *IntegerConstant) AcceptWithContext(ctx context.Context, v IntegerConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type IntegerConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v int) error
	VisitVariableWithContext(ctx context.Context, v VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewIntegerConstantFromLiteral(v int) IntegerConstant {
	return IntegerConstant{typ: "literal", literal: &v}
}

func NewIntegerConstantFromVariable(v VariableName) IntegerConstant {
	return IntegerConstant{typ: "variable", variable: &v}
}

type InterpolationConfiguration struct {
	typ                      string
	forwardFillInterpolation *ForwardFillInterpolation
}

type interpolationConfigurationDeserializer struct {
	Type                     string                    `json:"type"`
	ForwardFillInterpolation *ForwardFillInterpolation `json:"forwardFillInterpolation"`
}

func (u *interpolationConfigurationDeserializer) toStruct() InterpolationConfiguration {
	return InterpolationConfiguration{typ: u.Type, forwardFillInterpolation: u.ForwardFillInterpolation}
}

func (u *InterpolationConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return nil, fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return struct {
			Type                     string                   `json:"type"`
			ForwardFillInterpolation ForwardFillInterpolation `json:"forwardFillInterpolation"`
		}{Type: "forwardFillInterpolation", ForwardFillInterpolation: *u.forwardFillInterpolation}, nil
	}
}

func (u InterpolationConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *InterpolationConfiguration) UnmarshalJSON(data []byte) error {
	var deser interpolationConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
	}
	return nil
}

func (u InterpolationConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *InterpolationConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *InterpolationConfiguration) AcceptFuncs(forwardFillInterpolationFunc func(ForwardFillInterpolation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return forwardFillInterpolationFunc(*u.forwardFillInterpolation)
	}
}

func (u *InterpolationConfiguration) ForwardFillInterpolationNoopSuccess(ForwardFillInterpolation) error {
	return nil
}

func (u *InterpolationConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *InterpolationConfiguration) Accept(v InterpolationConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return v.VisitForwardFillInterpolation(*u.forwardFillInterpolation)
	}
}

type InterpolationConfigurationVisitor interface {
	VisitForwardFillInterpolation(v ForwardFillInterpolation) error
	VisitUnknown(typeName string) error
}

func (u *InterpolationConfiguration) AcceptWithContext(ctx context.Context, v InterpolationConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return v.VisitForwardFillInterpolationWithContext(ctx, *u.forwardFillInterpolation)
	}
}

type InterpolationConfigurationVisitorWithContext interface {
	VisitForwardFillInterpolationWithContext(ctx context.Context, v ForwardFillInterpolation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewInterpolationConfigurationFromForwardFillInterpolation(v ForwardFillInterpolation) InterpolationConfiguration {
	return InterpolationConfiguration{typ: "forwardFillInterpolation", forwardFillInterpolation: &v}
}

type LogFilterOperator struct {
	typ                             string
	regexFilter                     *LogRegexFilterOperator
	exactMatchCaseInsensitiveFilter *LogExactMatchCaseInsensitiveFilter
}

type logFilterOperatorDeserializer struct {
	Type                            string                              `json:"type"`
	RegexFilter                     *LogRegexFilterOperator             `json:"regexFilter"`
	ExactMatchCaseInsensitiveFilter *LogExactMatchCaseInsensitiveFilter `json:"exactMatchCaseInsensitiveFilter"`
}

func (u *logFilterOperatorDeserializer) toStruct() LogFilterOperator {
	return LogFilterOperator{typ: u.Type, regexFilter: u.RegexFilter, exactMatchCaseInsensitiveFilter: u.ExactMatchCaseInsensitiveFilter}
}

func (u *LogFilterOperator) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "regexFilter":
		if u.regexFilter == nil {
			return nil, fmt.Errorf("field \"regexFilter\" is required")
		}
		return struct {
			Type        string                 `json:"type"`
			RegexFilter LogRegexFilterOperator `json:"regexFilter"`
		}{Type: "regexFilter", RegexFilter: *u.regexFilter}, nil
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return nil, fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
		return struct {
			Type                            string                             `json:"type"`
			ExactMatchCaseInsensitiveFilter LogExactMatchCaseInsensitiveFilter `json:"exactMatchCaseInsensitiveFilter"`
		}{Type: "exactMatchCaseInsensitiveFilter", ExactMatchCaseInsensitiveFilter: *u.exactMatchCaseInsensitiveFilter}, nil
	}
}

func (u LogFilterOperator) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LogFilterOperator) UnmarshalJSON(data []byte) error {
	var deser logFilterOperatorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "regexFilter":
		if u.regexFilter == nil {
			return fmt.Errorf("field \"regexFilter\" is required")
		}
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
	}
	return nil
}

func (u LogFilterOperator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LogFilterOperator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LogFilterOperator) AcceptFuncs(regexFilterFunc func(LogRegexFilterOperator) error, exactMatchCaseInsensitiveFilterFunc func(LogExactMatchCaseInsensitiveFilter) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "regexFilter":
		if u.regexFilter == nil {
			return fmt.Errorf("field \"regexFilter\" is required")
		}
		return regexFilterFunc(*u.regexFilter)
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
		return exactMatchCaseInsensitiveFilterFunc(*u.exactMatchCaseInsensitiveFilter)
	}
}

func (u *LogFilterOperator) RegexFilterNoopSuccess(LogRegexFilterOperator) error {
	return nil
}

func (u *LogFilterOperator) ExactMatchCaseInsensitiveFilterNoopSuccess(LogExactMatchCaseInsensitiveFilter) error {
	return nil
}

func (u *LogFilterOperator) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LogFilterOperator) Accept(v LogFilterOperatorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "regexFilter":
		if u.regexFilter == nil {
			return fmt.Errorf("field \"regexFilter\" is required")
		}
		return v.VisitRegexFilter(*u.regexFilter)
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
		return v.VisitExactMatchCaseInsensitiveFilter(*u.exactMatchCaseInsensitiveFilter)
	}
}

type LogFilterOperatorVisitor interface {
	VisitRegexFilter(v LogRegexFilterOperator) error
	VisitExactMatchCaseInsensitiveFilter(v LogExactMatchCaseInsensitiveFilter) error
	VisitUnknown(typeName string) error
}

func (u *LogFilterOperator) AcceptWithContext(ctx context.Context, v LogFilterOperatorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "regexFilter":
		if u.regexFilter == nil {
			return fmt.Errorf("field \"regexFilter\" is required")
		}
		return v.VisitRegexFilterWithContext(ctx, *u.regexFilter)
	case "exactMatchCaseInsensitiveFilter":
		if u.exactMatchCaseInsensitiveFilter == nil {
			return fmt.Errorf("field \"exactMatchCaseInsensitiveFilter\" is required")
		}
		return v.VisitExactMatchCaseInsensitiveFilterWithContext(ctx, *u.exactMatchCaseInsensitiveFilter)
	}
}

type LogFilterOperatorVisitorWithContext interface {
	VisitRegexFilterWithContext(ctx context.Context, v LogRegexFilterOperator) error
	VisitExactMatchCaseInsensitiveFilterWithContext(ctx context.Context, v LogExactMatchCaseInsensitiveFilter) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLogFilterOperatorFromRegexFilter(v LogRegexFilterOperator) LogFilterOperator {
	return LogFilterOperator{typ: "regexFilter", regexFilter: &v}
}

func NewLogFilterOperatorFromExactMatchCaseInsensitiveFilter(v LogExactMatchCaseInsensitiveFilter) LogFilterOperator {
	return LogFilterOperator{typ: "exactMatchCaseInsensitiveFilter", exactMatchCaseInsensitiveFilter: &v}
}

type LogSeries struct {
	typ       string
	raw       *Reference
	channel   *ChannelSeries
	derived   *DerivedSeries
	union     *LogUnionSeries
	filter    *LogFilterSeries
	timeShift *LogTimeShiftSeries
}

type logSeriesDeserializer struct {
	Type      string              `json:"type"`
	Raw       *Reference          `json:"raw"`
	Channel   *ChannelSeries      `json:"channel"`
	Derived   *DerivedSeries      `json:"derived"`
	Union     *LogUnionSeries     `json:"union"`
	Filter    *LogFilterSeries    `json:"filter"`
	TimeShift *LogTimeShiftSeries `json:"timeShift"`
}

func (u *logSeriesDeserializer) toStruct() LogSeries {
	return LogSeries{typ: u.Type, raw: u.Raw, channel: u.Channel, derived: u.Derived, union: u.Union, filter: u.Filter, timeShift: u.TimeShift}
}

func (u *LogSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Raw  Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Channel ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	case "union":
		if u.union == nil {
			return nil, fmt.Errorf("field \"union\" is required")
		}
		return struct {
			Type  string         `json:"type"`
			Union LogUnionSeries `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	case "filter":
		if u.filter == nil {
			return nil, fmt.Errorf("field \"filter\" is required")
		}
		return struct {
			Type   string          `json:"type"`
			Filter LogFilterSeries `json:"filter"`
		}{Type: "filter", Filter: *u.filter}, nil
	case "timeShift":
		if u.timeShift == nil {
			return nil, fmt.Errorf("field \"timeShift\" is required")
		}
		return struct {
			Type      string             `json:"type"`
			TimeShift LogTimeShiftSeries `json:"timeShift"`
		}{Type: "timeShift", TimeShift: *u.timeShift}, nil
	}
}

func (u LogSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LogSeries) UnmarshalJSON(data []byte) error {
	var deser logSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
	}
	return nil
}

func (u LogSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LogSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LogSeries) AcceptFuncs(rawFunc func(Reference) error, channelFunc func(ChannelSeries) error, derivedFunc func(DerivedSeries) error, unionFunc func(LogUnionSeries) error, filterFunc func(LogFilterSeries) error, timeShiftFunc func(LogTimeShiftSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
		return filterFunc(*u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	}
}

func (u *LogSeries) RawNoopSuccess(Reference) error {
	return nil
}

func (u *LogSeries) ChannelNoopSuccess(ChannelSeries) error {
	return nil
}

func (u *LogSeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *LogSeries) UnionNoopSuccess(LogUnionSeries) error {
	return nil
}

func (u *LogSeries) FilterNoopSuccess(LogFilterSeries) error {
	return nil
}

func (u *LogSeries) TimeShiftNoopSuccess(LogTimeShiftSeries) error {
	return nil
}

func (u *LogSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LogSeries) Accept(v LogSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
		return v.VisitFilter(*u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(*u.timeShift)
	}
}

type LogSeriesVisitor interface {
	VisitRaw(v Reference) error
	VisitChannel(v ChannelSeries) error
	VisitDerived(v DerivedSeries) error
	VisitUnion(v LogUnionSeries) error
	VisitFilter(v LogFilterSeries) error
	VisitTimeShift(v LogTimeShiftSeries) error
	VisitUnknown(typeName string) error
}

func (u *LogSeries) AcceptWithContext(ctx context.Context, v LogSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
		return v.VisitFilterWithContext(ctx, *u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShiftWithContext(ctx, *u.timeShift)
	}
}

type LogSeriesVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v Reference) error
	VisitChannelWithContext(ctx context.Context, v ChannelSeries) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitUnionWithContext(ctx context.Context, v LogUnionSeries) error
	VisitFilterWithContext(ctx context.Context, v LogFilterSeries) error
	VisitTimeShiftWithContext(ctx context.Context, v LogTimeShiftSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLogSeriesFromRaw(v Reference) LogSeries {
	return LogSeries{typ: "raw", raw: &v}
}

func NewLogSeriesFromChannel(v ChannelSeries) LogSeries {
	return LogSeries{typ: "channel", channel: &v}
}

func NewLogSeriesFromDerived(v DerivedSeries) LogSeries {
	return LogSeries{typ: "derived", derived: &v}
}

func NewLogSeriesFromUnion(v LogUnionSeries) LogSeries {
	return LogSeries{typ: "union", union: &v}
}

func NewLogSeriesFromFilter(v LogFilterSeries) LogSeries {
	return LogSeries{typ: "filter", filter: &v}
}

func NewLogSeriesFromTimeShift(v LogTimeShiftSeries) LogSeries {
	return LogSeries{typ: "timeShift", timeShift: &v}
}

type NegativeValueConfiguration struct {
	typ                     string
	allowNegativeValues     *AllowNegativeValues
	setNegativeValuesToZero *SetNegativeValuesToZero
	excludeNegativeValues   *ExcludeNegativeValues
}

type negativeValueConfigurationDeserializer struct {
	Type                    string                   `json:"type"`
	AllowNegativeValues     *AllowNegativeValues     `json:"allowNegativeValues"`
	SetNegativeValuesToZero *SetNegativeValuesToZero `json:"setNegativeValuesToZero"`
	ExcludeNegativeValues   *ExcludeNegativeValues   `json:"excludeNegativeValues"`
}

func (u *negativeValueConfigurationDeserializer) toStruct() NegativeValueConfiguration {
	return NegativeValueConfiguration{typ: u.Type, allowNegativeValues: u.AllowNegativeValues, setNegativeValuesToZero: u.SetNegativeValuesToZero, excludeNegativeValues: u.ExcludeNegativeValues}
}

func (u *NegativeValueConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return nil, fmt.Errorf("field \"allowNegativeValues\" is required")
		}
		return struct {
			Type                string              `json:"type"`
			AllowNegativeValues AllowNegativeValues `json:"allowNegativeValues"`
		}{Type: "allowNegativeValues", AllowNegativeValues: *u.allowNegativeValues}, nil
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return nil, fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
		return struct {
			Type                    string                  `json:"type"`
			SetNegativeValuesToZero SetNegativeValuesToZero `json:"setNegativeValuesToZero"`
		}{Type: "setNegativeValuesToZero", SetNegativeValuesToZero: *u.setNegativeValuesToZero}, nil
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return nil, fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
		return struct {
			Type                  string                `json:"type"`
			ExcludeNegativeValues ExcludeNegativeValues `json:"excludeNegativeValues"`
		}{Type: "excludeNegativeValues", ExcludeNegativeValues: *u.excludeNegativeValues}, nil
	}
}

func (u NegativeValueConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NegativeValueConfiguration) UnmarshalJSON(data []byte) error {
	var deser negativeValueConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return fmt.Errorf("field \"allowNegativeValues\" is required")
		}
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
	}
	return nil
}

func (u NegativeValueConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NegativeValueConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NegativeValueConfiguration) AcceptFuncs(allowNegativeValuesFunc func(AllowNegativeValues) error, setNegativeValuesToZeroFunc func(SetNegativeValuesToZero) error, excludeNegativeValuesFunc func(ExcludeNegativeValues) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return fmt.Errorf("field \"allowNegativeValues\" is required")
		}
		return allowNegativeValuesFunc(*u.allowNegativeValues)
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
		return setNegativeValuesToZeroFunc(*u.setNegativeValuesToZero)
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
		return excludeNegativeValuesFunc(*u.excludeNegativeValues)
	}
}

func (u *NegativeValueConfiguration) AllowNegativeValuesNoopSuccess(AllowNegativeValues) error {
	return nil
}

func (u *NegativeValueConfiguration) SetNegativeValuesToZeroNoopSuccess(SetNegativeValuesToZero) error {
	return nil
}

func (u *NegativeValueConfiguration) ExcludeNegativeValuesNoopSuccess(ExcludeNegativeValues) error {
	return nil
}

func (u *NegativeValueConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NegativeValueConfiguration) Accept(v NegativeValueConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return fmt.Errorf("field \"allowNegativeValues\" is required")
		}
		return v.VisitAllowNegativeValues(*u.allowNegativeValues)
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
		return v.VisitSetNegativeValuesToZero(*u.setNegativeValuesToZero)
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
		return v.VisitExcludeNegativeValues(*u.excludeNegativeValues)
	}
}

type NegativeValueConfigurationVisitor interface {
	VisitAllowNegativeValues(v AllowNegativeValues) error
	VisitSetNegativeValuesToZero(v SetNegativeValuesToZero) error
	VisitExcludeNegativeValues(v ExcludeNegativeValues) error
	VisitUnknown(typeName string) error
}

func (u *NegativeValueConfiguration) AcceptWithContext(ctx context.Context, v NegativeValueConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "allowNegativeValues":
		if u.allowNegativeValues == nil {
			return fmt.Errorf("field \"allowNegativeValues\" is required")
		}
		return v.VisitAllowNegativeValuesWithContext(ctx, *u.allowNegativeValues)
	case "setNegativeValuesToZero":
		if u.setNegativeValuesToZero == nil {
			return fmt.Errorf("field \"setNegativeValuesToZero\" is required")
		}
		return v.VisitSetNegativeValuesToZeroWithContext(ctx, *u.setNegativeValuesToZero)
	case "excludeNegativeValues":
		if u.excludeNegativeValues == nil {
			return fmt.Errorf("field \"excludeNegativeValues\" is required")
		}
		return v.VisitExcludeNegativeValuesWithContext(ctx, *u.excludeNegativeValues)
	}
}

type NegativeValueConfigurationVisitorWithContext interface {
	VisitAllowNegativeValuesWithContext(ctx context.Context, v AllowNegativeValues) error
	VisitSetNegativeValuesToZeroWithContext(ctx context.Context, v SetNegativeValuesToZero) error
	VisitExcludeNegativeValuesWithContext(ctx context.Context, v ExcludeNegativeValues) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNegativeValueConfigurationFromAllowNegativeValues(v AllowNegativeValues) NegativeValueConfiguration {
	return NegativeValueConfiguration{typ: "allowNegativeValues", allowNegativeValues: &v}
}

func NewNegativeValueConfigurationFromSetNegativeValuesToZero(v SetNegativeValuesToZero) NegativeValueConfiguration {
	return NegativeValueConfiguration{typ: "setNegativeValuesToZero", setNegativeValuesToZero: &v}
}

func NewNegativeValueConfigurationFromExcludeNegativeValues(v ExcludeNegativeValues) NegativeValueConfiguration {
	return NegativeValueConfiguration{typ: "excludeNegativeValues", excludeNegativeValues: &v}
}

type Numeric1dArraySeries struct {
	typ     string
	channel *ChannelSeries
	raw     *Reference
	derived *DerivedSeries
}

type numeric1dArraySeriesDeserializer struct {
	Type    string         `json:"type"`
	Channel *ChannelSeries `json:"channel"`
	Raw     *Reference     `json:"raw"`
	Derived *DerivedSeries `json:"derived"`
}

func (u *numeric1dArraySeriesDeserializer) toStruct() Numeric1dArraySeries {
	return Numeric1dArraySeries{typ: u.Type, channel: u.Channel, raw: u.Raw, derived: u.Derived}
}

func (u *Numeric1dArraySeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Channel ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Raw  Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	}
}

func (u Numeric1dArraySeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Numeric1dArraySeries) UnmarshalJSON(data []byte) error {
	var deser numeric1dArraySeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	}
	return nil
}

func (u Numeric1dArraySeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Numeric1dArraySeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Numeric1dArraySeries) AcceptFuncs(channelFunc func(ChannelSeries) error, rawFunc func(Reference) error, derivedFunc func(DerivedSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	}
}

func (u *Numeric1dArraySeries) ChannelNoopSuccess(ChannelSeries) error {
	return nil
}

func (u *Numeric1dArraySeries) RawNoopSuccess(Reference) error {
	return nil
}

func (u *Numeric1dArraySeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *Numeric1dArraySeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Numeric1dArraySeries) Accept(v Numeric1dArraySeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	}
}

type Numeric1dArraySeriesVisitor interface {
	VisitChannel(v ChannelSeries) error
	VisitRaw(v Reference) error
	VisitDerived(v DerivedSeries) error
	VisitUnknown(typeName string) error
}

func (u *Numeric1dArraySeries) AcceptWithContext(ctx context.Context, v Numeric1dArraySeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	}
}

type Numeric1dArraySeriesVisitorWithContext interface {
	VisitChannelWithContext(ctx context.Context, v ChannelSeries) error
	VisitRawWithContext(ctx context.Context, v Reference) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumeric1dArraySeriesFromChannel(v ChannelSeries) Numeric1dArraySeries {
	return Numeric1dArraySeries{typ: "channel", channel: &v}
}

func NewNumeric1dArraySeriesFromRaw(v Reference) Numeric1dArraySeries {
	return Numeric1dArraySeries{typ: "raw", raw: &v}
}

func NewNumeric1dArraySeriesFromDerived(v DerivedSeries) Numeric1dArraySeries {
	return Numeric1dArraySeries{typ: "derived", derived: &v}
}

type NumericHistogramBucketStrategy struct {
	typ                  string
	bucketCount          *IntegerConstant
	bucketWidthAndOffset *NumericHistogramBucketWidthAndOffset
}

type numericHistogramBucketStrategyDeserializer struct {
	Type                 string                                `json:"type"`
	BucketCount          *IntegerConstant                      `json:"bucketCount"`
	BucketWidthAndOffset *NumericHistogramBucketWidthAndOffset `json:"bucketWidthAndOffset"`
}

func (u *numericHistogramBucketStrategyDeserializer) toStruct() NumericHistogramBucketStrategy {
	return NumericHistogramBucketStrategy{typ: u.Type, bucketCount: u.BucketCount, bucketWidthAndOffset: u.BucketWidthAndOffset}
}

func (u *NumericHistogramBucketStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return nil, fmt.Errorf("field \"bucketCount\" is required")
		}
		return struct {
			Type        string          `json:"type"`
			BucketCount IntegerConstant `json:"bucketCount"`
		}{Type: "bucketCount", BucketCount: *u.bucketCount}, nil
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return nil, fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return struct {
			Type                 string                               `json:"type"`
			BucketWidthAndOffset NumericHistogramBucketWidthAndOffset `json:"bucketWidthAndOffset"`
		}{Type: "bucketWidthAndOffset", BucketWidthAndOffset: *u.bucketWidthAndOffset}, nil
	}
}

func (u NumericHistogramBucketStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericHistogramBucketStrategy) UnmarshalJSON(data []byte) error {
	var deser numericHistogramBucketStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
	}
	return nil
}

func (u NumericHistogramBucketStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericHistogramBucketStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericHistogramBucketStrategy) AcceptFuncs(bucketCountFunc func(IntegerConstant) error, bucketWidthAndOffsetFunc func(NumericHistogramBucketWidthAndOffset) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
		return bucketCountFunc(*u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return bucketWidthAndOffsetFunc(*u.bucketWidthAndOffset)
	}
}

func (u *NumericHistogramBucketStrategy) BucketCountNoopSuccess(IntegerConstant) error {
	return nil
}

func (u *NumericHistogramBucketStrategy) BucketWidthAndOffsetNoopSuccess(NumericHistogramBucketWidthAndOffset) error {
	return nil
}

func (u *NumericHistogramBucketStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericHistogramBucketStrategy) Accept(v NumericHistogramBucketStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
		return v.VisitBucketCount(*u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return v.VisitBucketWidthAndOffset(*u.bucketWidthAndOffset)
	}
}

type NumericHistogramBucketStrategyVisitor interface {
	VisitBucketCount(v IntegerConstant) error
	VisitBucketWidthAndOffset(v NumericHistogramBucketWidthAndOffset) error
	VisitUnknown(typeName string) error
}

func (u *NumericHistogramBucketStrategy) AcceptWithContext(ctx context.Context, v NumericHistogramBucketStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "bucketCount":
		if u.bucketCount == nil {
			return fmt.Errorf("field \"bucketCount\" is required")
		}
		return v.VisitBucketCountWithContext(ctx, *u.bucketCount)
	case "bucketWidthAndOffset":
		if u.bucketWidthAndOffset == nil {
			return fmt.Errorf("field \"bucketWidthAndOffset\" is required")
		}
		return v.VisitBucketWidthAndOffsetWithContext(ctx, *u.bucketWidthAndOffset)
	}
}

type NumericHistogramBucketStrategyVisitorWithContext interface {
	VisitBucketCountWithContext(ctx context.Context, v IntegerConstant) error
	VisitBucketWidthAndOffsetWithContext(ctx context.Context, v NumericHistogramBucketWidthAndOffset) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericHistogramBucketStrategyFromBucketCount(v IntegerConstant) NumericHistogramBucketStrategy {
	return NumericHistogramBucketStrategy{typ: "bucketCount", bucketCount: &v}
}

func NewNumericHistogramBucketStrategyFromBucketWidthAndOffset(v NumericHistogramBucketWidthAndOffset) NumericHistogramBucketStrategy {
	return NumericHistogramBucketStrategy{typ: "bucketWidthAndOffset", bucketWidthAndOffset: &v}
}

type NumericSeries struct {
	typ                  string
	aggregate            *AggregateNumericSeries
	arithmetic           *ArithmeticSeries
	bitOperation         *BitOperationSeries
	countDuplicate       *EnumCountDuplicateSeries
	cumulativeSum        *CumulativeSumSeries
	derivative           *DerivativeSeries
	integral             *IntegralSeries
	max                  *MaxSeries
	mean                 *MeanSeries
	min                  *MinSeries
	offset               *OffsetSeries
	product              *ProductSeries
	raw                  *Reference
	channel              *ChannelSeries
	derived              *DerivedSeries
	resample             *NumericResampleSeries
	rollingOperation     *RollingOperationSeries
	signalFilter         *SignalFilterSeries
	sum                  *SumSeries
	scale                *ScaleSeries
	timeDifference       *TimeDifferenceSeries
	absoluteTimestamp    *AbsoluteTimestampSeries
	timeRangeFilter      *NumericTimeRangeFilterSeries
	timeShift            *NumericTimeShiftSeries
	unaryArithmetic      *UnaryArithmeticSeries
	binaryArithmetic     *BinaryArithmeticSeries
	union                *NumericUnionSeries
	unitConversion       *UnitConversionSeries
	valueDifference      *ValueDifferenceSeries
	filterTransformation *NumericFilterTransformationSeries
	thresholdFilter      *NumericThresholdFilterSeries
	approximateFilter    *NumericApproximateFilterSeries
	select1dArrayIndex   *SelectIndexFrom1dNumericArraySeries
	selectNewestPoints   *SelectNewestPointsSeries
}

type numericSeriesDeserializer struct {
	Type                 string                               `json:"type"`
	Aggregate            *AggregateNumericSeries              `json:"aggregate"`
	Arithmetic           *ArithmeticSeries                    `json:"arithmetic"`
	BitOperation         *BitOperationSeries                  `json:"bitOperation"`
	CountDuplicate       *EnumCountDuplicateSeries            `json:"countDuplicate"`
	CumulativeSum        *CumulativeSumSeries                 `json:"cumulativeSum"`
	Derivative           *DerivativeSeries                    `json:"derivative"`
	Integral             *IntegralSeries                      `json:"integral"`
	Max                  *MaxSeries                           `json:"max"`
	Mean                 *MeanSeries                          `json:"mean"`
	Min                  *MinSeries                           `json:"min"`
	Offset               *OffsetSeries                        `json:"offset"`
	Product              *ProductSeries                       `json:"product"`
	Raw                  *Reference                           `json:"raw"`
	Channel              *ChannelSeries                       `json:"channel"`
	Derived              *DerivedSeries                       `json:"derived"`
	Resample             *NumericResampleSeries               `json:"resample"`
	RollingOperation     *RollingOperationSeries              `json:"rollingOperation"`
	SignalFilter         *SignalFilterSeries                  `json:"signalFilter"`
	Sum                  *SumSeries                           `json:"sum"`
	Scale                *ScaleSeries                         `json:"scale"`
	TimeDifference       *TimeDifferenceSeries                `json:"timeDifference"`
	AbsoluteTimestamp    *AbsoluteTimestampSeries             `json:"absoluteTimestamp"`
	TimeRangeFilter      *NumericTimeRangeFilterSeries        `json:"timeRangeFilter"`
	TimeShift            *NumericTimeShiftSeries              `json:"timeShift"`
	UnaryArithmetic      *UnaryArithmeticSeries               `json:"unaryArithmetic"`
	BinaryArithmetic     *BinaryArithmeticSeries              `json:"binaryArithmetic"`
	Union                *NumericUnionSeries                  `json:"union"`
	UnitConversion       *UnitConversionSeries                `json:"unitConversion"`
	ValueDifference      *ValueDifferenceSeries               `json:"valueDifference"`
	FilterTransformation *NumericFilterTransformationSeries   `json:"filterTransformation"`
	ThresholdFilter      *NumericThresholdFilterSeries        `json:"thresholdFilter"`
	ApproximateFilter    *NumericApproximateFilterSeries      `json:"approximateFilter"`
	Select1dArrayIndex   *SelectIndexFrom1dNumericArraySeries `json:"select1dArrayIndex"`
	SelectNewestPoints   *SelectNewestPointsSeries            `json:"selectNewestPoints"`
}

func (u *numericSeriesDeserializer) toStruct() NumericSeries {
	return NumericSeries{typ: u.Type, aggregate: u.Aggregate, arithmetic: u.Arithmetic, bitOperation: u.BitOperation, countDuplicate: u.CountDuplicate, cumulativeSum: u.CumulativeSum, derivative: u.Derivative, integral: u.Integral, max: u.Max, mean: u.Mean, min: u.Min, offset: u.Offset, product: u.Product, raw: u.Raw, channel: u.Channel, derived: u.Derived, resample: u.Resample, rollingOperation: u.RollingOperation, signalFilter: u.SignalFilter, sum: u.Sum, scale: u.Scale, timeDifference: u.TimeDifference, absoluteTimestamp: u.AbsoluteTimestamp, timeRangeFilter: u.TimeRangeFilter, timeShift: u.TimeShift, unaryArithmetic: u.UnaryArithmetic, binaryArithmetic: u.BinaryArithmetic, union: u.Union, unitConversion: u.UnitConversion, valueDifference: u.ValueDifference, filterTransformation: u.FilterTransformation, thresholdFilter: u.ThresholdFilter, approximateFilter: u.ApproximateFilter, select1dArrayIndex: u.Select1dArrayIndex, selectNewestPoints: u.SelectNewestPoints}
}

func (u *NumericSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return nil, fmt.Errorf("field \"aggregate\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			Aggregate AggregateNumericSeries `json:"aggregate"`
		}{Type: "aggregate", Aggregate: *u.aggregate}, nil
	case "arithmetic":
		if u.arithmetic == nil {
			return nil, fmt.Errorf("field \"arithmetic\" is required")
		}
		return struct {
			Type       string           `json:"type"`
			Arithmetic ArithmeticSeries `json:"arithmetic"`
		}{Type: "arithmetic", Arithmetic: *u.arithmetic}, nil
	case "bitOperation":
		if u.bitOperation == nil {
			return nil, fmt.Errorf("field \"bitOperation\" is required")
		}
		return struct {
			Type         string             `json:"type"`
			BitOperation BitOperationSeries `json:"bitOperation"`
		}{Type: "bitOperation", BitOperation: *u.bitOperation}, nil
	case "countDuplicate":
		if u.countDuplicate == nil {
			return nil, fmt.Errorf("field \"countDuplicate\" is required")
		}
		return struct {
			Type           string                   `json:"type"`
			CountDuplicate EnumCountDuplicateSeries `json:"countDuplicate"`
		}{Type: "countDuplicate", CountDuplicate: *u.countDuplicate}, nil
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return nil, fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return struct {
			Type          string              `json:"type"`
			CumulativeSum CumulativeSumSeries `json:"cumulativeSum"`
		}{Type: "cumulativeSum", CumulativeSum: *u.cumulativeSum}, nil
	case "derivative":
		if u.derivative == nil {
			return nil, fmt.Errorf("field \"derivative\" is required")
		}
		return struct {
			Type       string           `json:"type"`
			Derivative DerivativeSeries `json:"derivative"`
		}{Type: "derivative", Derivative: *u.derivative}, nil
	case "integral":
		if u.integral == nil {
			return nil, fmt.Errorf("field \"integral\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			Integral IntegralSeries `json:"integral"`
		}{Type: "integral", Integral: *u.integral}, nil
	case "max":
		if u.max == nil {
			return nil, fmt.Errorf("field \"max\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Max  MaxSeries `json:"max"`
		}{Type: "max", Max: *u.max}, nil
	case "mean":
		if u.mean == nil {
			return nil, fmt.Errorf("field \"mean\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Mean MeanSeries `json:"mean"`
		}{Type: "mean", Mean: *u.mean}, nil
	case "min":
		if u.min == nil {
			return nil, fmt.Errorf("field \"min\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Min  MinSeries `json:"min"`
		}{Type: "min", Min: *u.min}, nil
	case "offset":
		if u.offset == nil {
			return nil, fmt.Errorf("field \"offset\" is required")
		}
		return struct {
			Type   string       `json:"type"`
			Offset OffsetSeries `json:"offset"`
		}{Type: "offset", Offset: *u.offset}, nil
	case "product":
		if u.product == nil {
			return nil, fmt.Errorf("field \"product\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Product ProductSeries `json:"product"`
		}{Type: "product", Product: *u.product}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Raw  Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Channel ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	case "resample":
		if u.resample == nil {
			return nil, fmt.Errorf("field \"resample\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			Resample NumericResampleSeries `json:"resample"`
		}{Type: "resample", Resample: *u.resample}, nil
	case "rollingOperation":
		if u.rollingOperation == nil {
			return nil, fmt.Errorf("field \"rollingOperation\" is required")
		}
		return struct {
			Type             string                 `json:"type"`
			RollingOperation RollingOperationSeries `json:"rollingOperation"`
		}{Type: "rollingOperation", RollingOperation: *u.rollingOperation}, nil
	case "signalFilter":
		if u.signalFilter == nil {
			return nil, fmt.Errorf("field \"signalFilter\" is required")
		}
		return struct {
			Type         string             `json:"type"`
			SignalFilter SignalFilterSeries `json:"signalFilter"`
		}{Type: "signalFilter", SignalFilter: *u.signalFilter}, nil
	case "sum":
		if u.sum == nil {
			return nil, fmt.Errorf("field \"sum\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Sum  SumSeries `json:"sum"`
		}{Type: "sum", Sum: *u.sum}, nil
	case "scale":
		if u.scale == nil {
			return nil, fmt.Errorf("field \"scale\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Scale ScaleSeries `json:"scale"`
		}{Type: "scale", Scale: *u.scale}, nil
	case "timeDifference":
		if u.timeDifference == nil {
			return nil, fmt.Errorf("field \"timeDifference\" is required")
		}
		return struct {
			Type           string               `json:"type"`
			TimeDifference TimeDifferenceSeries `json:"timeDifference"`
		}{Type: "timeDifference", TimeDifference: *u.timeDifference}, nil
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return nil, fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return struct {
			Type              string                  `json:"type"`
			AbsoluteTimestamp AbsoluteTimestampSeries `json:"absoluteTimestamp"`
		}{Type: "absoluteTimestamp", AbsoluteTimestamp: *u.absoluteTimestamp}, nil
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return nil, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return struct {
			Type            string                       `json:"type"`
			TimeRangeFilter NumericTimeRangeFilterSeries `json:"timeRangeFilter"`
		}{Type: "timeRangeFilter", TimeRangeFilter: *u.timeRangeFilter}, nil
	case "timeShift":
		if u.timeShift == nil {
			return nil, fmt.Errorf("field \"timeShift\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			TimeShift NumericTimeShiftSeries `json:"timeShift"`
		}{Type: "timeShift", TimeShift: *u.timeShift}, nil
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return nil, fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return struct {
			Type            string                `json:"type"`
			UnaryArithmetic UnaryArithmeticSeries `json:"unaryArithmetic"`
		}{Type: "unaryArithmetic", UnaryArithmetic: *u.unaryArithmetic}, nil
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return nil, fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return struct {
			Type             string                 `json:"type"`
			BinaryArithmetic BinaryArithmeticSeries `json:"binaryArithmetic"`
		}{Type: "binaryArithmetic", BinaryArithmetic: *u.binaryArithmetic}, nil
	case "union":
		if u.union == nil {
			return nil, fmt.Errorf("field \"union\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Union NumericUnionSeries `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	case "unitConversion":
		if u.unitConversion == nil {
			return nil, fmt.Errorf("field \"unitConversion\" is required")
		}
		return struct {
			Type           string               `json:"type"`
			UnitConversion UnitConversionSeries `json:"unitConversion"`
		}{Type: "unitConversion", UnitConversion: *u.unitConversion}, nil
	case "valueDifference":
		if u.valueDifference == nil {
			return nil, fmt.Errorf("field \"valueDifference\" is required")
		}
		return struct {
			Type            string                `json:"type"`
			ValueDifference ValueDifferenceSeries `json:"valueDifference"`
		}{Type: "valueDifference", ValueDifference: *u.valueDifference}, nil
	case "filterTransformation":
		if u.filterTransformation == nil {
			return nil, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return struct {
			Type                 string                            `json:"type"`
			FilterTransformation NumericFilterTransformationSeries `json:"filterTransformation"`
		}{Type: "filterTransformation", FilterTransformation: *u.filterTransformation}, nil
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return nil, fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return struct {
			Type            string                       `json:"type"`
			ThresholdFilter NumericThresholdFilterSeries `json:"thresholdFilter"`
		}{Type: "thresholdFilter", ThresholdFilter: *u.thresholdFilter}, nil
	case "approximateFilter":
		if u.approximateFilter == nil {
			return nil, fmt.Errorf("field \"approximateFilter\" is required")
		}
		return struct {
			Type              string                         `json:"type"`
			ApproximateFilter NumericApproximateFilterSeries `json:"approximateFilter"`
		}{Type: "approximateFilter", ApproximateFilter: *u.approximateFilter}, nil
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return nil, fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return struct {
			Type               string                              `json:"type"`
			Select1dArrayIndex SelectIndexFrom1dNumericArraySeries `json:"select1dArrayIndex"`
		}{Type: "select1dArrayIndex", Select1dArrayIndex: *u.select1dArrayIndex}, nil
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return nil, fmt.Errorf("field \"selectNewestPoints\" is required")
		}
		return struct {
			Type               string                   `json:"type"`
			SelectNewestPoints SelectNewestPointsSeries `json:"selectNewestPoints"`
		}{Type: "selectNewestPoints", SelectNewestPoints: *u.selectNewestPoints}, nil
	}
}

func (u NumericSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericSeries) UnmarshalJSON(data []byte) error {
	var deser numericSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
	case "approximateFilter":
		if u.approximateFilter == nil {
			return fmt.Errorf("field \"approximateFilter\" is required")
		}
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return fmt.Errorf("field \"selectNewestPoints\" is required")
		}
	}
	return nil
}

func (u NumericSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericSeries) AcceptFuncs(aggregateFunc func(AggregateNumericSeries) error, arithmeticFunc func(ArithmeticSeries) error, bitOperationFunc func(BitOperationSeries) error, countDuplicateFunc func(EnumCountDuplicateSeries) error, cumulativeSumFunc func(CumulativeSumSeries) error, derivativeFunc func(DerivativeSeries) error, integralFunc func(IntegralSeries) error, maxFunc func(MaxSeries) error, meanFunc func(MeanSeries) error, minFunc func(MinSeries) error, offsetFunc func(OffsetSeries) error, productFunc func(ProductSeries) error, rawFunc func(Reference) error, channelFunc func(ChannelSeries) error, derivedFunc func(DerivedSeries) error, resampleFunc func(NumericResampleSeries) error, rollingOperationFunc func(RollingOperationSeries) error, signalFilterFunc func(SignalFilterSeries) error, sumFunc func(SumSeries) error, scaleFunc func(ScaleSeries) error, timeDifferenceFunc func(TimeDifferenceSeries) error, absoluteTimestampFunc func(AbsoluteTimestampSeries) error, timeRangeFilterFunc func(NumericTimeRangeFilterSeries) error, timeShiftFunc func(NumericTimeShiftSeries) error, unaryArithmeticFunc func(UnaryArithmeticSeries) error, binaryArithmeticFunc func(BinaryArithmeticSeries) error, unionFunc func(NumericUnionSeries) error, unitConversionFunc func(UnitConversionSeries) error, valueDifferenceFunc func(ValueDifferenceSeries) error, filterTransformationFunc func(NumericFilterTransformationSeries) error, thresholdFilterFunc func(NumericThresholdFilterSeries) error, approximateFilterFunc func(NumericApproximateFilterSeries) error, select1dArrayIndexFunc func(SelectIndexFrom1dNumericArraySeries) error, selectNewestPointsFunc func(SelectNewestPointsSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return aggregateFunc(*u.aggregate)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return arithmeticFunc(*u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return bitOperationFunc(*u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
		return countDuplicateFunc(*u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return cumulativeSumFunc(*u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return derivativeFunc(*u.derivative)
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
		return integralFunc(*u.integral)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return meanFunc(*u.mean)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
		return offsetFunc(*u.offset)
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
		return productFunc(*u.product)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return resampleFunc(*u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return rollingOperationFunc(*u.rollingOperation)
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
		return signalFilterFunc(*u.signalFilter)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return sumFunc(*u.sum)
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
		return scaleFunc(*u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return timeDifferenceFunc(*u.timeDifference)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return absoluteTimestampFunc(*u.absoluteTimestamp)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return unaryArithmeticFunc(*u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return binaryArithmeticFunc(*u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
		return unitConversionFunc(*u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return valueDifferenceFunc(*u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return filterTransformationFunc(*u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return thresholdFilterFunc(*u.thresholdFilter)
	case "approximateFilter":
		if u.approximateFilter == nil {
			return fmt.Errorf("field \"approximateFilter\" is required")
		}
		return approximateFilterFunc(*u.approximateFilter)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return select1dArrayIndexFunc(*u.select1dArrayIndex)
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return fmt.Errorf("field \"selectNewestPoints\" is required")
		}
		return selectNewestPointsFunc(*u.selectNewestPoints)
	}
}

func (u *NumericSeries) AggregateNoopSuccess(AggregateNumericSeries) error {
	return nil
}

func (u *NumericSeries) ArithmeticNoopSuccess(ArithmeticSeries) error {
	return nil
}

func (u *NumericSeries) BitOperationNoopSuccess(BitOperationSeries) error {
	return nil
}

func (u *NumericSeries) CountDuplicateNoopSuccess(EnumCountDuplicateSeries) error {
	return nil
}

func (u *NumericSeries) CumulativeSumNoopSuccess(CumulativeSumSeries) error {
	return nil
}

func (u *NumericSeries) DerivativeNoopSuccess(DerivativeSeries) error {
	return nil
}

func (u *NumericSeries) IntegralNoopSuccess(IntegralSeries) error {
	return nil
}

func (u *NumericSeries) MaxNoopSuccess(MaxSeries) error {
	return nil
}

func (u *NumericSeries) MeanNoopSuccess(MeanSeries) error {
	return nil
}

func (u *NumericSeries) MinNoopSuccess(MinSeries) error {
	return nil
}

func (u *NumericSeries) OffsetNoopSuccess(OffsetSeries) error {
	return nil
}

func (u *NumericSeries) ProductNoopSuccess(ProductSeries) error {
	return nil
}

func (u *NumericSeries) RawNoopSuccess(Reference) error {
	return nil
}

func (u *NumericSeries) ChannelNoopSuccess(ChannelSeries) error {
	return nil
}

func (u *NumericSeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *NumericSeries) ResampleNoopSuccess(NumericResampleSeries) error {
	return nil
}

func (u *NumericSeries) RollingOperationNoopSuccess(RollingOperationSeries) error {
	return nil
}

func (u *NumericSeries) SignalFilterNoopSuccess(SignalFilterSeries) error {
	return nil
}

func (u *NumericSeries) SumNoopSuccess(SumSeries) error {
	return nil
}

func (u *NumericSeries) ScaleNoopSuccess(ScaleSeries) error {
	return nil
}

func (u *NumericSeries) TimeDifferenceNoopSuccess(TimeDifferenceSeries) error {
	return nil
}

func (u *NumericSeries) AbsoluteTimestampNoopSuccess(AbsoluteTimestampSeries) error {
	return nil
}

func (u *NumericSeries) TimeRangeFilterNoopSuccess(NumericTimeRangeFilterSeries) error {
	return nil
}

func (u *NumericSeries) TimeShiftNoopSuccess(NumericTimeShiftSeries) error {
	return nil
}

func (u *NumericSeries) UnaryArithmeticNoopSuccess(UnaryArithmeticSeries) error {
	return nil
}

func (u *NumericSeries) BinaryArithmeticNoopSuccess(BinaryArithmeticSeries) error {
	return nil
}

func (u *NumericSeries) UnionNoopSuccess(NumericUnionSeries) error {
	return nil
}

func (u *NumericSeries) UnitConversionNoopSuccess(UnitConversionSeries) error {
	return nil
}

func (u *NumericSeries) ValueDifferenceNoopSuccess(ValueDifferenceSeries) error {
	return nil
}

func (u *NumericSeries) FilterTransformationNoopSuccess(NumericFilterTransformationSeries) error {
	return nil
}

func (u *NumericSeries) ThresholdFilterNoopSuccess(NumericThresholdFilterSeries) error {
	return nil
}

func (u *NumericSeries) ApproximateFilterNoopSuccess(NumericApproximateFilterSeries) error {
	return nil
}

func (u *NumericSeries) Select1dArrayIndexNoopSuccess(SelectIndexFrom1dNumericArraySeries) error {
	return nil
}

func (u *NumericSeries) SelectNewestPointsNoopSuccess(SelectNewestPointsSeries) error {
	return nil
}

func (u *NumericSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericSeries) Accept(v NumericSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregate(*u.aggregate)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return v.VisitArithmetic(*u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return v.VisitBitOperation(*u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
		return v.VisitCountDuplicate(*u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return v.VisitCumulativeSum(*u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return v.VisitDerivative(*u.derivative)
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
		return v.VisitIntegral(*u.integral)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(*u.max)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return v.VisitMean(*u.mean)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(*u.min)
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
		return v.VisitOffset(*u.offset)
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
		return v.VisitProduct(*u.product)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResample(*u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return v.VisitRollingOperation(*u.rollingOperation)
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
		return v.VisitSignalFilter(*u.signalFilter)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSum(*u.sum)
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
		return v.VisitScale(*u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return v.VisitTimeDifference(*u.timeDifference)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return v.VisitAbsoluteTimestamp(*u.absoluteTimestamp)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(*u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return v.VisitUnaryArithmetic(*u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return v.VisitBinaryArithmetic(*u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
		return v.VisitUnitConversion(*u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return v.VisitValueDifference(*u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformation(*u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return v.VisitThresholdFilter(*u.thresholdFilter)
	case "approximateFilter":
		if u.approximateFilter == nil {
			return fmt.Errorf("field \"approximateFilter\" is required")
		}
		return v.VisitApproximateFilter(*u.approximateFilter)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return v.VisitSelect1dArrayIndex(*u.select1dArrayIndex)
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return fmt.Errorf("field \"selectNewestPoints\" is required")
		}
		return v.VisitSelectNewestPoints(*u.selectNewestPoints)
	}
}

type NumericSeriesVisitor interface {
	VisitAggregate(v AggregateNumericSeries) error
	VisitArithmetic(v ArithmeticSeries) error
	VisitBitOperation(v BitOperationSeries) error
	VisitCountDuplicate(v EnumCountDuplicateSeries) error
	VisitCumulativeSum(v CumulativeSumSeries) error
	VisitDerivative(v DerivativeSeries) error
	VisitIntegral(v IntegralSeries) error
	VisitMax(v MaxSeries) error
	VisitMean(v MeanSeries) error
	VisitMin(v MinSeries) error
	VisitOffset(v OffsetSeries) error
	VisitProduct(v ProductSeries) error
	VisitRaw(v Reference) error
	VisitChannel(v ChannelSeries) error
	VisitDerived(v DerivedSeries) error
	VisitResample(v NumericResampleSeries) error
	VisitRollingOperation(v RollingOperationSeries) error
	VisitSignalFilter(v SignalFilterSeries) error
	VisitSum(v SumSeries) error
	VisitScale(v ScaleSeries) error
	VisitTimeDifference(v TimeDifferenceSeries) error
	VisitAbsoluteTimestamp(v AbsoluteTimestampSeries) error
	VisitTimeRangeFilter(v NumericTimeRangeFilterSeries) error
	VisitTimeShift(v NumericTimeShiftSeries) error
	VisitUnaryArithmetic(v UnaryArithmeticSeries) error
	VisitBinaryArithmetic(v BinaryArithmeticSeries) error
	VisitUnion(v NumericUnionSeries) error
	VisitUnitConversion(v UnitConversionSeries) error
	VisitValueDifference(v ValueDifferenceSeries) error
	VisitFilterTransformation(v NumericFilterTransformationSeries) error
	VisitThresholdFilter(v NumericThresholdFilterSeries) error
	VisitApproximateFilter(v NumericApproximateFilterSeries) error
	VisitSelect1dArrayIndex(v SelectIndexFrom1dNumericArraySeries) error
	VisitSelectNewestPoints(v SelectNewestPointsSeries) error
	VisitUnknown(typeName string) error
}

func (u *NumericSeries) AcceptWithContext(ctx context.Context, v NumericSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregateWithContext(ctx, *u.aggregate)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return v.VisitArithmeticWithContext(ctx, *u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return v.VisitBitOperationWithContext(ctx, *u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
		return v.VisitCountDuplicateWithContext(ctx, *u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return v.VisitCumulativeSumWithContext(ctx, *u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return v.VisitDerivativeWithContext(ctx, *u.derivative)
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
		return v.VisitIntegralWithContext(ctx, *u.integral)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMaxWithContext(ctx, *u.max)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return v.VisitMeanWithContext(ctx, *u.mean)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMinWithContext(ctx, *u.min)
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
		return v.VisitOffsetWithContext(ctx, *u.offset)
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
		return v.VisitProductWithContext(ctx, *u.product)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResampleWithContext(ctx, *u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return v.VisitRollingOperationWithContext(ctx, *u.rollingOperation)
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
		return v.VisitSignalFilterWithContext(ctx, *u.signalFilter)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSumWithContext(ctx, *u.sum)
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
		return v.VisitScaleWithContext(ctx, *u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return v.VisitTimeDifferenceWithContext(ctx, *u.timeDifference)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return v.VisitAbsoluteTimestampWithContext(ctx, *u.absoluteTimestamp)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilterWithContext(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShiftWithContext(ctx, *u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return v.VisitUnaryArithmeticWithContext(ctx, *u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return v.VisitBinaryArithmeticWithContext(ctx, *u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
		return v.VisitUnitConversionWithContext(ctx, *u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return v.VisitValueDifferenceWithContext(ctx, *u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformationWithContext(ctx, *u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return v.VisitThresholdFilterWithContext(ctx, *u.thresholdFilter)
	case "approximateFilter":
		if u.approximateFilter == nil {
			return fmt.Errorf("field \"approximateFilter\" is required")
		}
		return v.VisitApproximateFilterWithContext(ctx, *u.approximateFilter)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return v.VisitSelect1dArrayIndexWithContext(ctx, *u.select1dArrayIndex)
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return fmt.Errorf("field \"selectNewestPoints\" is required")
		}
		return v.VisitSelectNewestPointsWithContext(ctx, *u.selectNewestPoints)
	}
}

type NumericSeriesVisitorWithContext interface {
	VisitAggregateWithContext(ctx context.Context, v AggregateNumericSeries) error
	VisitArithmeticWithContext(ctx context.Context, v ArithmeticSeries) error
	VisitBitOperationWithContext(ctx context.Context, v BitOperationSeries) error
	VisitCountDuplicateWithContext(ctx context.Context, v EnumCountDuplicateSeries) error
	VisitCumulativeSumWithContext(ctx context.Context, v CumulativeSumSeries) error
	VisitDerivativeWithContext(ctx context.Context, v DerivativeSeries) error
	VisitIntegralWithContext(ctx context.Context, v IntegralSeries) error
	VisitMaxWithContext(ctx context.Context, v MaxSeries) error
	VisitMeanWithContext(ctx context.Context, v MeanSeries) error
	VisitMinWithContext(ctx context.Context, v MinSeries) error
	VisitOffsetWithContext(ctx context.Context, v OffsetSeries) error
	VisitProductWithContext(ctx context.Context, v ProductSeries) error
	VisitRawWithContext(ctx context.Context, v Reference) error
	VisitChannelWithContext(ctx context.Context, v ChannelSeries) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitResampleWithContext(ctx context.Context, v NumericResampleSeries) error
	VisitRollingOperationWithContext(ctx context.Context, v RollingOperationSeries) error
	VisitSignalFilterWithContext(ctx context.Context, v SignalFilterSeries) error
	VisitSumWithContext(ctx context.Context, v SumSeries) error
	VisitScaleWithContext(ctx context.Context, v ScaleSeries) error
	VisitTimeDifferenceWithContext(ctx context.Context, v TimeDifferenceSeries) error
	VisitAbsoluteTimestampWithContext(ctx context.Context, v AbsoluteTimestampSeries) error
	VisitTimeRangeFilterWithContext(ctx context.Context, v NumericTimeRangeFilterSeries) error
	VisitTimeShiftWithContext(ctx context.Context, v NumericTimeShiftSeries) error
	VisitUnaryArithmeticWithContext(ctx context.Context, v UnaryArithmeticSeries) error
	VisitBinaryArithmeticWithContext(ctx context.Context, v BinaryArithmeticSeries) error
	VisitUnionWithContext(ctx context.Context, v NumericUnionSeries) error
	VisitUnitConversionWithContext(ctx context.Context, v UnitConversionSeries) error
	VisitValueDifferenceWithContext(ctx context.Context, v ValueDifferenceSeries) error
	VisitFilterTransformationWithContext(ctx context.Context, v NumericFilterTransformationSeries) error
	VisitThresholdFilterWithContext(ctx context.Context, v NumericThresholdFilterSeries) error
	VisitApproximateFilterWithContext(ctx context.Context, v NumericApproximateFilterSeries) error
	VisitSelect1dArrayIndexWithContext(ctx context.Context, v SelectIndexFrom1dNumericArraySeries) error
	VisitSelectNewestPointsWithContext(ctx context.Context, v SelectNewestPointsSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericSeriesFromAggregate(v AggregateNumericSeries) NumericSeries {
	return NumericSeries{typ: "aggregate", aggregate: &v}
}

func NewNumericSeriesFromArithmetic(v ArithmeticSeries) NumericSeries {
	return NumericSeries{typ: "arithmetic", arithmetic: &v}
}

func NewNumericSeriesFromBitOperation(v BitOperationSeries) NumericSeries {
	return NumericSeries{typ: "bitOperation", bitOperation: &v}
}

func NewNumericSeriesFromCountDuplicate(v EnumCountDuplicateSeries) NumericSeries {
	return NumericSeries{typ: "countDuplicate", countDuplicate: &v}
}

func NewNumericSeriesFromCumulativeSum(v CumulativeSumSeries) NumericSeries {
	return NumericSeries{typ: "cumulativeSum", cumulativeSum: &v}
}

func NewNumericSeriesFromDerivative(v DerivativeSeries) NumericSeries {
	return NumericSeries{typ: "derivative", derivative: &v}
}

func NewNumericSeriesFromIntegral(v IntegralSeries) NumericSeries {
	return NumericSeries{typ: "integral", integral: &v}
}

func NewNumericSeriesFromMax(v MaxSeries) NumericSeries {
	return NumericSeries{typ: "max", max: &v}
}

func NewNumericSeriesFromMean(v MeanSeries) NumericSeries {
	return NumericSeries{typ: "mean", mean: &v}
}

func NewNumericSeriesFromMin(v MinSeries) NumericSeries {
	return NumericSeries{typ: "min", min: &v}
}

func NewNumericSeriesFromOffset(v OffsetSeries) NumericSeries {
	return NumericSeries{typ: "offset", offset: &v}
}

func NewNumericSeriesFromProduct(v ProductSeries) NumericSeries {
	return NumericSeries{typ: "product", product: &v}
}

func NewNumericSeriesFromRaw(v Reference) NumericSeries {
	return NumericSeries{typ: "raw", raw: &v}
}

func NewNumericSeriesFromChannel(v ChannelSeries) NumericSeries {
	return NumericSeries{typ: "channel", channel: &v}
}

func NewNumericSeriesFromDerived(v DerivedSeries) NumericSeries {
	return NumericSeries{typ: "derived", derived: &v}
}

func NewNumericSeriesFromResample(v NumericResampleSeries) NumericSeries {
	return NumericSeries{typ: "resample", resample: &v}
}

func NewNumericSeriesFromRollingOperation(v RollingOperationSeries) NumericSeries {
	return NumericSeries{typ: "rollingOperation", rollingOperation: &v}
}

func NewNumericSeriesFromSignalFilter(v SignalFilterSeries) NumericSeries {
	return NumericSeries{typ: "signalFilter", signalFilter: &v}
}

func NewNumericSeriesFromSum(v SumSeries) NumericSeries {
	return NumericSeries{typ: "sum", sum: &v}
}

func NewNumericSeriesFromScale(v ScaleSeries) NumericSeries {
	return NumericSeries{typ: "scale", scale: &v}
}

func NewNumericSeriesFromTimeDifference(v TimeDifferenceSeries) NumericSeries {
	return NumericSeries{typ: "timeDifference", timeDifference: &v}
}

func NewNumericSeriesFromAbsoluteTimestamp(v AbsoluteTimestampSeries) NumericSeries {
	return NumericSeries{typ: "absoluteTimestamp", absoluteTimestamp: &v}
}

func NewNumericSeriesFromTimeRangeFilter(v NumericTimeRangeFilterSeries) NumericSeries {
	return NumericSeries{typ: "timeRangeFilter", timeRangeFilter: &v}
}

func NewNumericSeriesFromTimeShift(v NumericTimeShiftSeries) NumericSeries {
	return NumericSeries{typ: "timeShift", timeShift: &v}
}

func NewNumericSeriesFromUnaryArithmetic(v UnaryArithmeticSeries) NumericSeries {
	return NumericSeries{typ: "unaryArithmetic", unaryArithmetic: &v}
}

func NewNumericSeriesFromBinaryArithmetic(v BinaryArithmeticSeries) NumericSeries {
	return NumericSeries{typ: "binaryArithmetic", binaryArithmetic: &v}
}

func NewNumericSeriesFromUnion(v NumericUnionSeries) NumericSeries {
	return NumericSeries{typ: "union", union: &v}
}

func NewNumericSeriesFromUnitConversion(v UnitConversionSeries) NumericSeries {
	return NumericSeries{typ: "unitConversion", unitConversion: &v}
}

func NewNumericSeriesFromValueDifference(v ValueDifferenceSeries) NumericSeries {
	return NumericSeries{typ: "valueDifference", valueDifference: &v}
}

func NewNumericSeriesFromFilterTransformation(v NumericFilterTransformationSeries) NumericSeries {
	return NumericSeries{typ: "filterTransformation", filterTransformation: &v}
}

func NewNumericSeriesFromThresholdFilter(v NumericThresholdFilterSeries) NumericSeries {
	return NumericSeries{typ: "thresholdFilter", thresholdFilter: &v}
}

func NewNumericSeriesFromApproximateFilter(v NumericApproximateFilterSeries) NumericSeries {
	return NumericSeries{typ: "approximateFilter", approximateFilter: &v}
}

func NewNumericSeriesFromSelect1dArrayIndex(v SelectIndexFrom1dNumericArraySeries) NumericSeries {
	return NumericSeries{typ: "select1dArrayIndex", select1dArrayIndex: &v}
}

func NewNumericSeriesFromSelectNewestPoints(v SelectNewestPointsSeries) NumericSeries {
	return NumericSeries{typ: "selectNewestPoints", selectNewestPoints: &v}
}

type OutputRangeStart struct {
	typ                         string
	firstPointMatchingCondition *FirstPointMatchingCondition
	afterPersistenceWindow      *AfterPersistenceWindow
}

type outputRangeStartDeserializer struct {
	Type                        string                       `json:"type"`
	FirstPointMatchingCondition *FirstPointMatchingCondition `json:"firstPointMatchingCondition"`
	AfterPersistenceWindow      *AfterPersistenceWindow      `json:"afterPersistenceWindow"`
}

func (u *outputRangeStartDeserializer) toStruct() OutputRangeStart {
	return OutputRangeStart{typ: u.Type, firstPointMatchingCondition: u.FirstPointMatchingCondition, afterPersistenceWindow: u.AfterPersistenceWindow}
}

func (u *OutputRangeStart) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return nil, fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
		return struct {
			Type                        string                      `json:"type"`
			FirstPointMatchingCondition FirstPointMatchingCondition `json:"firstPointMatchingCondition"`
		}{Type: "firstPointMatchingCondition", FirstPointMatchingCondition: *u.firstPointMatchingCondition}, nil
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return nil, fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
		return struct {
			Type                   string                 `json:"type"`
			AfterPersistenceWindow AfterPersistenceWindow `json:"afterPersistenceWindow"`
		}{Type: "afterPersistenceWindow", AfterPersistenceWindow: *u.afterPersistenceWindow}, nil
	}
}

func (u OutputRangeStart) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *OutputRangeStart) UnmarshalJSON(data []byte) error {
	var deser outputRangeStartDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
	}
	return nil
}

func (u OutputRangeStart) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *OutputRangeStart) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *OutputRangeStart) AcceptFuncs(firstPointMatchingConditionFunc func(FirstPointMatchingCondition) error, afterPersistenceWindowFunc func(AfterPersistenceWindow) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
		return firstPointMatchingConditionFunc(*u.firstPointMatchingCondition)
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
		return afterPersistenceWindowFunc(*u.afterPersistenceWindow)
	}
}

func (u *OutputRangeStart) FirstPointMatchingConditionNoopSuccess(FirstPointMatchingCondition) error {
	return nil
}

func (u *OutputRangeStart) AfterPersistenceWindowNoopSuccess(AfterPersistenceWindow) error {
	return nil
}

func (u *OutputRangeStart) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *OutputRangeStart) Accept(v OutputRangeStartVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
		return v.VisitFirstPointMatchingCondition(*u.firstPointMatchingCondition)
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
		return v.VisitAfterPersistenceWindow(*u.afterPersistenceWindow)
	}
}

type OutputRangeStartVisitor interface {
	VisitFirstPointMatchingCondition(v FirstPointMatchingCondition) error
	VisitAfterPersistenceWindow(v AfterPersistenceWindow) error
	VisitUnknown(typeName string) error
}

func (u *OutputRangeStart) AcceptWithContext(ctx context.Context, v OutputRangeStartVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "firstPointMatchingCondition":
		if u.firstPointMatchingCondition == nil {
			return fmt.Errorf("field \"firstPointMatchingCondition\" is required")
		}
		return v.VisitFirstPointMatchingConditionWithContext(ctx, *u.firstPointMatchingCondition)
	case "afterPersistenceWindow":
		if u.afterPersistenceWindow == nil {
			return fmt.Errorf("field \"afterPersistenceWindow\" is required")
		}
		return v.VisitAfterPersistenceWindowWithContext(ctx, *u.afterPersistenceWindow)
	}
}

type OutputRangeStartVisitorWithContext interface {
	VisitFirstPointMatchingConditionWithContext(ctx context.Context, v FirstPointMatchingCondition) error
	VisitAfterPersistenceWindowWithContext(ctx context.Context, v AfterPersistenceWindow) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewOutputRangeStartFromFirstPointMatchingCondition(v FirstPointMatchingCondition) OutputRangeStart {
	return OutputRangeStart{typ: "firstPointMatchingCondition", firstPointMatchingCondition: &v}
}

func NewOutputRangeStartFromAfterPersistenceWindow(v AfterPersistenceWindow) OutputRangeStart {
	return OutputRangeStart{typ: "afterPersistenceWindow", afterPersistenceWindow: &v}
}

type PageStrategy struct {
	typ      string
	pageInfo *PageInfo
}

type pageStrategyDeserializer struct {
	Type     string    `json:"type"`
	PageInfo *PageInfo `json:"pageInfo"`
}

func (u *pageStrategyDeserializer) toStruct() PageStrategy {
	return PageStrategy{typ: u.Type, pageInfo: u.PageInfo}
}

func (u *PageStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "pageInfo":
		if u.pageInfo == nil {
			return nil, fmt.Errorf("field \"pageInfo\" is required")
		}
		return struct {
			Type     string   `json:"type"`
			PageInfo PageInfo `json:"pageInfo"`
		}{Type: "pageInfo", PageInfo: *u.pageInfo}, nil
	}
}

func (u PageStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PageStrategy) UnmarshalJSON(data []byte) error {
	var deser pageStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "pageInfo":
		if u.pageInfo == nil {
			return fmt.Errorf("field \"pageInfo\" is required")
		}
	}
	return nil
}

func (u PageStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PageStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PageStrategy) AcceptFuncs(pageInfoFunc func(PageInfo) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pageInfo":
		if u.pageInfo == nil {
			return fmt.Errorf("field \"pageInfo\" is required")
		}
		return pageInfoFunc(*u.pageInfo)
	}
}

func (u *PageStrategy) PageInfoNoopSuccess(PageInfo) error {
	return nil
}

func (u *PageStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PageStrategy) Accept(v PageStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "pageInfo":
		if u.pageInfo == nil {
			return fmt.Errorf("field \"pageInfo\" is required")
		}
		return v.VisitPageInfo(*u.pageInfo)
	}
}

type PageStrategyVisitor interface {
	VisitPageInfo(v PageInfo) error
	VisitUnknown(typeName string) error
}

func (u *PageStrategy) AcceptWithContext(ctx context.Context, v PageStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "pageInfo":
		if u.pageInfo == nil {
			return fmt.Errorf("field \"pageInfo\" is required")
		}
		return v.VisitPageInfoWithContext(ctx, *u.pageInfo)
	}
}

type PageStrategyVisitorWithContext interface {
	VisitPageInfoWithContext(ctx context.Context, v PageInfo) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPageStrategyFromPageInfo(v PageInfo) PageStrategy {
	return PageStrategy{typ: "pageInfo", pageInfo: &v}
}

type PageToken struct {
	typ            string
	timestampAndId *TimestampAndId
}

type pageTokenDeserializer struct {
	Type           string          `json:"type"`
	TimestampAndId *TimestampAndId `json:"timestampAndId"`
}

func (u *pageTokenDeserializer) toStruct() PageToken {
	return PageToken{typ: u.Type, timestampAndId: u.TimestampAndId}
}

func (u *PageToken) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timestampAndId":
		if u.timestampAndId == nil {
			return nil, fmt.Errorf("field \"timestampAndId\" is required")
		}
		return struct {
			Type           string         `json:"type"`
			TimestampAndId TimestampAndId `json:"timestampAndId"`
		}{Type: "timestampAndId", TimestampAndId: *u.timestampAndId}, nil
	}
}

func (u PageToken) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PageToken) UnmarshalJSON(data []byte) error {
	var deser pageTokenDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timestampAndId":
		if u.timestampAndId == nil {
			return fmt.Errorf("field \"timestampAndId\" is required")
		}
	}
	return nil
}

func (u PageToken) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PageToken) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PageToken) AcceptFuncs(timestampAndIdFunc func(TimestampAndId) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timestampAndId":
		if u.timestampAndId == nil {
			return fmt.Errorf("field \"timestampAndId\" is required")
		}
		return timestampAndIdFunc(*u.timestampAndId)
	}
}

func (u *PageToken) TimestampAndIdNoopSuccess(TimestampAndId) error {
	return nil
}

func (u *PageToken) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PageToken) Accept(v PageTokenVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timestampAndId":
		if u.timestampAndId == nil {
			return fmt.Errorf("field \"timestampAndId\" is required")
		}
		return v.VisitTimestampAndId(*u.timestampAndId)
	}
}

type PageTokenVisitor interface {
	VisitTimestampAndId(v TimestampAndId) error
	VisitUnknown(typeName string) error
}

func (u *PageToken) AcceptWithContext(ctx context.Context, v PageTokenVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timestampAndId":
		if u.timestampAndId == nil {
			return fmt.Errorf("field \"timestampAndId\" is required")
		}
		return v.VisitTimestampAndIdWithContext(ctx, *u.timestampAndId)
	}
}

type PageTokenVisitorWithContext interface {
	VisitTimestampAndIdWithContext(ctx context.Context, v TimestampAndId) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPageTokenFromTimestampAndId(v TimestampAndId) PageToken {
	return PageToken{typ: "timestampAndId", timestampAndId: &v}
}

type RangeAggregationOperation struct {
	typ               string
	average           *Average
	min               *Minimum
	max               *Maximum
	standardDeviation *StandardDeviation
	count             *Count
	all               *api1.Empty
}

type rangeAggregationOperationDeserializer struct {
	Type              string             `json:"type"`
	Average           *Average           `json:"average"`
	Min               *Minimum           `json:"min"`
	Max               *Maximum           `json:"max"`
	StandardDeviation *StandardDeviation `json:"standardDeviation"`
	Count             *Count             `json:"count"`
	All               *api1.Empty        `json:"all"`
}

func (u *rangeAggregationOperationDeserializer) toStruct() RangeAggregationOperation {
	return RangeAggregationOperation{typ: u.Type, average: u.Average, min: u.Min, max: u.Max, standardDeviation: u.StandardDeviation, count: u.Count, all: u.All}
}

func (u *RangeAggregationOperation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "average":
		if u.average == nil {
			return nil, fmt.Errorf("field \"average\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Average Average `json:"average"`
		}{Type: "average", Average: *u.average}, nil
	case "min":
		if u.min == nil {
			return nil, fmt.Errorf("field \"min\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Min  Minimum `json:"min"`
		}{Type: "min", Min: *u.min}, nil
	case "max":
		if u.max == nil {
			return nil, fmt.Errorf("field \"max\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Max  Maximum `json:"max"`
		}{Type: "max", Max: *u.max}, nil
	case "standardDeviation":
		if u.standardDeviation == nil {
			return nil, fmt.Errorf("field \"standardDeviation\" is required")
		}
		return struct {
			Type              string            `json:"type"`
			StandardDeviation StandardDeviation `json:"standardDeviation"`
		}{Type: "standardDeviation", StandardDeviation: *u.standardDeviation}, nil
	case "count":
		if u.count == nil {
			return nil, fmt.Errorf("field \"count\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Count Count  `json:"count"`
		}{Type: "count", Count: *u.count}, nil
	case "all":
		if u.all == nil {
			return nil, fmt.Errorf("field \"all\" is required")
		}
		return struct {
			Type string     `json:"type"`
			All  api1.Empty `json:"all"`
		}{Type: "all", All: *u.all}, nil
	}
}

func (u RangeAggregationOperation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangeAggregationOperation) UnmarshalJSON(data []byte) error {
	var deser rangeAggregationOperationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
	}
	return nil
}

func (u RangeAggregationOperation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangeAggregationOperation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangeAggregationOperation) AcceptFuncs(averageFunc func(Average) error, minFunc func(Minimum) error, maxFunc func(Maximum) error, standardDeviationFunc func(StandardDeviation) error, countFunc func(Count) error, allFunc func(api1.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return averageFunc(*u.average)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return standardDeviationFunc(*u.standardDeviation)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return countFunc(*u.count)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return allFunc(*u.all)
	}
}

func (u *RangeAggregationOperation) AverageNoopSuccess(Average) error {
	return nil
}

func (u *RangeAggregationOperation) MinNoopSuccess(Minimum) error {
	return nil
}

func (u *RangeAggregationOperation) MaxNoopSuccess(Maximum) error {
	return nil
}

func (u *RangeAggregationOperation) StandardDeviationNoopSuccess(StandardDeviation) error {
	return nil
}

func (u *RangeAggregationOperation) CountNoopSuccess(Count) error {
	return nil
}

func (u *RangeAggregationOperation) AllNoopSuccess(api1.Empty) error {
	return nil
}

func (u *RangeAggregationOperation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangeAggregationOperation) Accept(v RangeAggregationOperationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return v.VisitAverage(*u.average)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(*u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(*u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviation(*u.standardDeviation)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCount(*u.count)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAll(*u.all)
	}
}

type RangeAggregationOperationVisitor interface {
	VisitAverage(v Average) error
	VisitMin(v Minimum) error
	VisitMax(v Maximum) error
	VisitStandardDeviation(v StandardDeviation) error
	VisitCount(v Count) error
	VisitAll(v api1.Empty) error
	VisitUnknown(typeName string) error
}

func (u *RangeAggregationOperation) AcceptWithContext(ctx context.Context, v RangeAggregationOperationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return v.VisitAverageWithContext(ctx, *u.average)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMinWithContext(ctx, *u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMaxWithContext(ctx, *u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviationWithContext(ctx, *u.standardDeviation)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCountWithContext(ctx, *u.count)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAllWithContext(ctx, *u.all)
	}
}

type RangeAggregationOperationVisitorWithContext interface {
	VisitAverageWithContext(ctx context.Context, v Average) error
	VisitMinWithContext(ctx context.Context, v Minimum) error
	VisitMaxWithContext(ctx context.Context, v Maximum) error
	VisitStandardDeviationWithContext(ctx context.Context, v StandardDeviation) error
	VisitCountWithContext(ctx context.Context, v Count) error
	VisitAllWithContext(ctx context.Context, v api1.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangeAggregationOperationFromAverage(v Average) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "average", average: &v}
}

func NewRangeAggregationOperationFromMin(v Minimum) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "min", min: &v}
}

func NewRangeAggregationOperationFromMax(v Maximum) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "max", max: &v}
}

func NewRangeAggregationOperationFromStandardDeviation(v StandardDeviation) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "standardDeviation", standardDeviation: &v}
}

func NewRangeAggregationOperationFromCount(v Count) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "count", count: &v}
}

func NewRangeAggregationOperationFromAll(v api1.Empty) RangeAggregationOperation {
	return RangeAggregationOperation{typ: "all", all: &v}
}

type RangeSeries struct {
	typ                          string
	approximateThreshold         *ApproximateThresholdRanges
	durationFilter               *DurationFilterRanges
	enumFilter                   *EnumFilterRanges
	enumSeriesEqualityRangesNode *EnumSeriesEqualityRanges
	eventsSearch                 *EventsSearchRanges
	intersectRange               *IntersectRanges
	literalRanges                *LiteralRanges
	minMaxThreshold              *MinMaxThresholdRanges
	not                          *NotRanges
	onChange                     *OnChangeRanges
	peak                         *PeakRanges
	rangeNumericAggregation      *RangesNumericAggregation
	raw                          *Reference
	derived                      *DerivedSeries
	seriesCrossoverRangesNode    *SeriesCrossoverRanges
	seriesEqualityRangesNode     *SeriesEqualityRanges
	stabilityDetection           *StabilityDetectionRanges
	staleRange                   *StaleRanges
	threshold                    *ThresholdingRanges
	unionRange                   *UnionRanges
}

type rangeSeriesDeserializer struct {
	Type                         string                      `json:"type"`
	ApproximateThreshold         *ApproximateThresholdRanges `json:"approximateThreshold"`
	DurationFilter               *DurationFilterRanges       `json:"durationFilter"`
	EnumFilter                   *EnumFilterRanges           `json:"enumFilter"`
	EnumSeriesEqualityRangesNode *EnumSeriesEqualityRanges   `json:"enumSeriesEqualityRangesNode"`
	EventsSearch                 *EventsSearchRanges         `json:"eventsSearch"`
	IntersectRange               *IntersectRanges            `json:"intersectRange"`
	LiteralRanges                *LiteralRanges              `json:"literalRanges"`
	MinMaxThreshold              *MinMaxThresholdRanges      `json:"minMaxThreshold"`
	Not                          *NotRanges                  `json:"not"`
	OnChange                     *OnChangeRanges             `json:"onChange"`
	Peak                         *PeakRanges                 `json:"peak"`
	RangeNumericAggregation      *RangesNumericAggregation   `json:"rangeNumericAggregation"`
	Raw                          *Reference                  `json:"raw"`
	Derived                      *DerivedSeries              `json:"derived"`
	SeriesCrossoverRangesNode    *SeriesCrossoverRanges      `json:"seriesCrossoverRangesNode"`
	SeriesEqualityRangesNode     *SeriesEqualityRanges       `json:"seriesEqualityRangesNode"`
	StabilityDetection           *StabilityDetectionRanges   `json:"stabilityDetection"`
	StaleRange                   *StaleRanges                `json:"staleRange"`
	Threshold                    *ThresholdingRanges         `json:"threshold"`
	UnionRange                   *UnionRanges                `json:"unionRange"`
}

func (u *rangeSeriesDeserializer) toStruct() RangeSeries {
	return RangeSeries{typ: u.Type, approximateThreshold: u.ApproximateThreshold, durationFilter: u.DurationFilter, enumFilter: u.EnumFilter, enumSeriesEqualityRangesNode: u.EnumSeriesEqualityRangesNode, eventsSearch: u.EventsSearch, intersectRange: u.IntersectRange, literalRanges: u.LiteralRanges, minMaxThreshold: u.MinMaxThreshold, not: u.Not, onChange: u.OnChange, peak: u.Peak, rangeNumericAggregation: u.RangeNumericAggregation, raw: u.Raw, derived: u.Derived, seriesCrossoverRangesNode: u.SeriesCrossoverRangesNode, seriesEqualityRangesNode: u.SeriesEqualityRangesNode, stabilityDetection: u.StabilityDetection, staleRange: u.StaleRange, threshold: u.Threshold, unionRange: u.UnionRange}
}

func (u *RangeSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return nil, fmt.Errorf("field \"approximateThreshold\" is required")
		}
		return struct {
			Type                 string                     `json:"type"`
			ApproximateThreshold ApproximateThresholdRanges `json:"approximateThreshold"`
		}{Type: "approximateThreshold", ApproximateThreshold: *u.approximateThreshold}, nil
	case "durationFilter":
		if u.durationFilter == nil {
			return nil, fmt.Errorf("field \"durationFilter\" is required")
		}
		return struct {
			Type           string               `json:"type"`
			DurationFilter DurationFilterRanges `json:"durationFilter"`
		}{Type: "durationFilter", DurationFilter: *u.durationFilter}, nil
	case "enumFilter":
		if u.enumFilter == nil {
			return nil, fmt.Errorf("field \"enumFilter\" is required")
		}
		return struct {
			Type       string           `json:"type"`
			EnumFilter EnumFilterRanges `json:"enumFilter"`
		}{Type: "enumFilter", EnumFilter: *u.enumFilter}, nil
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return nil, fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
		return struct {
			Type                         string                   `json:"type"`
			EnumSeriesEqualityRangesNode EnumSeriesEqualityRanges `json:"enumSeriesEqualityRangesNode"`
		}{Type: "enumSeriesEqualityRangesNode", EnumSeriesEqualityRangesNode: *u.enumSeriesEqualityRangesNode}, nil
	case "eventsSearch":
		if u.eventsSearch == nil {
			return nil, fmt.Errorf("field \"eventsSearch\" is required")
		}
		return struct {
			Type         string             `json:"type"`
			EventsSearch EventsSearchRanges `json:"eventsSearch"`
		}{Type: "eventsSearch", EventsSearch: *u.eventsSearch}, nil
	case "intersectRange":
		if u.intersectRange == nil {
			return nil, fmt.Errorf("field \"intersectRange\" is required")
		}
		return struct {
			Type           string          `json:"type"`
			IntersectRange IntersectRanges `json:"intersectRange"`
		}{Type: "intersectRange", IntersectRange: *u.intersectRange}, nil
	case "literalRanges":
		if u.literalRanges == nil {
			return nil, fmt.Errorf("field \"literalRanges\" is required")
		}
		return struct {
			Type          string        `json:"type"`
			LiteralRanges LiteralRanges `json:"literalRanges"`
		}{Type: "literalRanges", LiteralRanges: *u.literalRanges}, nil
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return nil, fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return struct {
			Type            string                `json:"type"`
			MinMaxThreshold MinMaxThresholdRanges `json:"minMaxThreshold"`
		}{Type: "minMaxThreshold", MinMaxThreshold: *u.minMaxThreshold}, nil
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Not  NotRanges `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	case "onChange":
		if u.onChange == nil {
			return nil, fmt.Errorf("field \"onChange\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			OnChange OnChangeRanges `json:"onChange"`
		}{Type: "onChange", OnChange: *u.onChange}, nil
	case "peak":
		if u.peak == nil {
			return nil, fmt.Errorf("field \"peak\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Peak PeakRanges `json:"peak"`
		}{Type: "peak", Peak: *u.peak}, nil
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return nil, fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return struct {
			Type                    string                   `json:"type"`
			RangeNumericAggregation RangesNumericAggregation `json:"rangeNumericAggregation"`
		}{Type: "rangeNumericAggregation", RangeNumericAggregation: *u.rangeNumericAggregation}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Raw  Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return nil, fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return struct {
			Type                      string                `json:"type"`
			SeriesCrossoverRangesNode SeriesCrossoverRanges `json:"seriesCrossoverRangesNode"`
		}{Type: "seriesCrossoverRangesNode", SeriesCrossoverRangesNode: *u.seriesCrossoverRangesNode}, nil
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return nil, fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
		return struct {
			Type                     string               `json:"type"`
			SeriesEqualityRangesNode SeriesEqualityRanges `json:"seriesEqualityRangesNode"`
		}{Type: "seriesEqualityRangesNode", SeriesEqualityRangesNode: *u.seriesEqualityRangesNode}, nil
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return nil, fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return struct {
			Type               string                   `json:"type"`
			StabilityDetection StabilityDetectionRanges `json:"stabilityDetection"`
		}{Type: "stabilityDetection", StabilityDetection: *u.stabilityDetection}, nil
	case "staleRange":
		if u.staleRange == nil {
			return nil, fmt.Errorf("field \"staleRange\" is required")
		}
		return struct {
			Type       string      `json:"type"`
			StaleRange StaleRanges `json:"staleRange"`
		}{Type: "staleRange", StaleRange: *u.staleRange}, nil
	case "threshold":
		if u.threshold == nil {
			return nil, fmt.Errorf("field \"threshold\" is required")
		}
		return struct {
			Type      string             `json:"type"`
			Threshold ThresholdingRanges `json:"threshold"`
		}{Type: "threshold", Threshold: *u.threshold}, nil
	case "unionRange":
		if u.unionRange == nil {
			return nil, fmt.Errorf("field \"unionRange\" is required")
		}
		return struct {
			Type       string      `json:"type"`
			UnionRange UnionRanges `json:"unionRange"`
		}{Type: "unionRange", UnionRange: *u.unionRange}, nil
	}
}

func (u RangeSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangeSeries) UnmarshalJSON(data []byte) error {
	var deser rangeSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return fmt.Errorf("field \"approximateThreshold\" is required")
		}
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
	case "eventsSearch":
		if u.eventsSearch == nil {
			return fmt.Errorf("field \"eventsSearch\" is required")
		}
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
	case "peak":
		if u.peak == nil {
			return fmt.Errorf("field \"peak\" is required")
		}
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
	}
	return nil
}

func (u RangeSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangeSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangeSeries) AcceptFuncs(approximateThresholdFunc func(ApproximateThresholdRanges) error, durationFilterFunc func(DurationFilterRanges) error, enumFilterFunc func(EnumFilterRanges) error, enumSeriesEqualityRangesNodeFunc func(EnumSeriesEqualityRanges) error, eventsSearchFunc func(EventsSearchRanges) error, intersectRangeFunc func(IntersectRanges) error, literalRangesFunc func(LiteralRanges) error, minMaxThresholdFunc func(MinMaxThresholdRanges) error, notFunc func(NotRanges) error, onChangeFunc func(OnChangeRanges) error, peakFunc func(PeakRanges) error, rangeNumericAggregationFunc func(RangesNumericAggregation) error, rawFunc func(Reference) error, derivedFunc func(DerivedSeries) error, seriesCrossoverRangesNodeFunc func(SeriesCrossoverRanges) error, seriesEqualityRangesNodeFunc func(SeriesEqualityRanges) error, stabilityDetectionFunc func(StabilityDetectionRanges) error, staleRangeFunc func(StaleRanges) error, thresholdFunc func(ThresholdingRanges) error, unionRangeFunc func(UnionRanges) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return fmt.Errorf("field \"approximateThreshold\" is required")
		}
		return approximateThresholdFunc(*u.approximateThreshold)
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
		return durationFilterFunc(*u.durationFilter)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return enumFilterFunc(*u.enumFilter)
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
		return enumSeriesEqualityRangesNodeFunc(*u.enumSeriesEqualityRangesNode)
	case "eventsSearch":
		if u.eventsSearch == nil {
			return fmt.Errorf("field \"eventsSearch\" is required")
		}
		return eventsSearchFunc(*u.eventsSearch)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return intersectRangeFunc(*u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
		return literalRangesFunc(*u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return minMaxThresholdFunc(*u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return onChangeFunc(*u.onChange)
	case "peak":
		if u.peak == nil {
			return fmt.Errorf("field \"peak\" is required")
		}
		return peakFunc(*u.peak)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return rangeNumericAggregationFunc(*u.rangeNumericAggregation)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return seriesCrossoverRangesNodeFunc(*u.seriesCrossoverRangesNode)
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
		return seriesEqualityRangesNodeFunc(*u.seriesEqualityRangesNode)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return stabilityDetectionFunc(*u.stabilityDetection)
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
		return staleRangeFunc(*u.staleRange)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return thresholdFunc(*u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return unionRangeFunc(*u.unionRange)
	}
}

func (u *RangeSeries) ApproximateThresholdNoopSuccess(ApproximateThresholdRanges) error {
	return nil
}

func (u *RangeSeries) DurationFilterNoopSuccess(DurationFilterRanges) error {
	return nil
}

func (u *RangeSeries) EnumFilterNoopSuccess(EnumFilterRanges) error {
	return nil
}

func (u *RangeSeries) EnumSeriesEqualityRangesNodeNoopSuccess(EnumSeriesEqualityRanges) error {
	return nil
}

func (u *RangeSeries) EventsSearchNoopSuccess(EventsSearchRanges) error {
	return nil
}

func (u *RangeSeries) IntersectRangeNoopSuccess(IntersectRanges) error {
	return nil
}

func (u *RangeSeries) LiteralRangesNoopSuccess(LiteralRanges) error {
	return nil
}

func (u *RangeSeries) MinMaxThresholdNoopSuccess(MinMaxThresholdRanges) error {
	return nil
}

func (u *RangeSeries) NotNoopSuccess(NotRanges) error {
	return nil
}

func (u *RangeSeries) OnChangeNoopSuccess(OnChangeRanges) error {
	return nil
}

func (u *RangeSeries) PeakNoopSuccess(PeakRanges) error {
	return nil
}

func (u *RangeSeries) RangeNumericAggregationNoopSuccess(RangesNumericAggregation) error {
	return nil
}

func (u *RangeSeries) RawNoopSuccess(Reference) error {
	return nil
}

func (u *RangeSeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *RangeSeries) SeriesCrossoverRangesNodeNoopSuccess(SeriesCrossoverRanges) error {
	return nil
}

func (u *RangeSeries) SeriesEqualityRangesNodeNoopSuccess(SeriesEqualityRanges) error {
	return nil
}

func (u *RangeSeries) StabilityDetectionNoopSuccess(StabilityDetectionRanges) error {
	return nil
}

func (u *RangeSeries) StaleRangeNoopSuccess(StaleRanges) error {
	return nil
}

func (u *RangeSeries) ThresholdNoopSuccess(ThresholdingRanges) error {
	return nil
}

func (u *RangeSeries) UnionRangeNoopSuccess(UnionRanges) error {
	return nil
}

func (u *RangeSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangeSeries) Accept(v RangeSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return fmt.Errorf("field \"approximateThreshold\" is required")
		}
		return v.VisitApproximateThreshold(*u.approximateThreshold)
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
		return v.VisitDurationFilter(*u.durationFilter)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return v.VisitEnumFilter(*u.enumFilter)
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
		return v.VisitEnumSeriesEqualityRangesNode(*u.enumSeriesEqualityRangesNode)
	case "eventsSearch":
		if u.eventsSearch == nil {
			return fmt.Errorf("field \"eventsSearch\" is required")
		}
		return v.VisitEventsSearch(*u.eventsSearch)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return v.VisitIntersectRange(*u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
		return v.VisitLiteralRanges(*u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return v.VisitMinMaxThreshold(*u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return v.VisitOnChange(*u.onChange)
	case "peak":
		if u.peak == nil {
			return fmt.Errorf("field \"peak\" is required")
		}
		return v.VisitPeak(*u.peak)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return v.VisitRangeNumericAggregation(*u.rangeNumericAggregation)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return v.VisitSeriesCrossoverRangesNode(*u.seriesCrossoverRangesNode)
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
		return v.VisitSeriesEqualityRangesNode(*u.seriesEqualityRangesNode)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return v.VisitStabilityDetection(*u.stabilityDetection)
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
		return v.VisitStaleRange(*u.staleRange)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThreshold(*u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return v.VisitUnionRange(*u.unionRange)
	}
}

type RangeSeriesVisitor interface {
	VisitApproximateThreshold(v ApproximateThresholdRanges) error
	VisitDurationFilter(v DurationFilterRanges) error
	VisitEnumFilter(v EnumFilterRanges) error
	VisitEnumSeriesEqualityRangesNode(v EnumSeriesEqualityRanges) error
	VisitEventsSearch(v EventsSearchRanges) error
	VisitIntersectRange(v IntersectRanges) error
	VisitLiteralRanges(v LiteralRanges) error
	VisitMinMaxThreshold(v MinMaxThresholdRanges) error
	VisitNot(v NotRanges) error
	VisitOnChange(v OnChangeRanges) error
	VisitPeak(v PeakRanges) error
	VisitRangeNumericAggregation(v RangesNumericAggregation) error
	VisitRaw(v Reference) error
	VisitDerived(v DerivedSeries) error
	VisitSeriesCrossoverRangesNode(v SeriesCrossoverRanges) error
	VisitSeriesEqualityRangesNode(v SeriesEqualityRanges) error
	VisitStabilityDetection(v StabilityDetectionRanges) error
	VisitStaleRange(v StaleRanges) error
	VisitThreshold(v ThresholdingRanges) error
	VisitUnionRange(v UnionRanges) error
	VisitUnknown(typeName string) error
}

func (u *RangeSeries) AcceptWithContext(ctx context.Context, v RangeSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return fmt.Errorf("field \"approximateThreshold\" is required")
		}
		return v.VisitApproximateThresholdWithContext(ctx, *u.approximateThreshold)
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
		return v.VisitDurationFilterWithContext(ctx, *u.durationFilter)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return v.VisitEnumFilterWithContext(ctx, *u.enumFilter)
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
		return v.VisitEnumSeriesEqualityRangesNodeWithContext(ctx, *u.enumSeriesEqualityRangesNode)
	case "eventsSearch":
		if u.eventsSearch == nil {
			return fmt.Errorf("field \"eventsSearch\" is required")
		}
		return v.VisitEventsSearchWithContext(ctx, *u.eventsSearch)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return v.VisitIntersectRangeWithContext(ctx, *u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
		return v.VisitLiteralRangesWithContext(ctx, *u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return v.VisitMinMaxThresholdWithContext(ctx, *u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return v.VisitOnChangeWithContext(ctx, *u.onChange)
	case "peak":
		if u.peak == nil {
			return fmt.Errorf("field \"peak\" is required")
		}
		return v.VisitPeakWithContext(ctx, *u.peak)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return v.VisitRangeNumericAggregationWithContext(ctx, *u.rangeNumericAggregation)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return v.VisitSeriesCrossoverRangesNodeWithContext(ctx, *u.seriesCrossoverRangesNode)
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
		return v.VisitSeriesEqualityRangesNodeWithContext(ctx, *u.seriesEqualityRangesNode)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return v.VisitStabilityDetectionWithContext(ctx, *u.stabilityDetection)
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
		return v.VisitStaleRangeWithContext(ctx, *u.staleRange)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThresholdWithContext(ctx, *u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return v.VisitUnionRangeWithContext(ctx, *u.unionRange)
	}
}

type RangeSeriesVisitorWithContext interface {
	VisitApproximateThresholdWithContext(ctx context.Context, v ApproximateThresholdRanges) error
	VisitDurationFilterWithContext(ctx context.Context, v DurationFilterRanges) error
	VisitEnumFilterWithContext(ctx context.Context, v EnumFilterRanges) error
	VisitEnumSeriesEqualityRangesNodeWithContext(ctx context.Context, v EnumSeriesEqualityRanges) error
	VisitEventsSearchWithContext(ctx context.Context, v EventsSearchRanges) error
	VisitIntersectRangeWithContext(ctx context.Context, v IntersectRanges) error
	VisitLiteralRangesWithContext(ctx context.Context, v LiteralRanges) error
	VisitMinMaxThresholdWithContext(ctx context.Context, v MinMaxThresholdRanges) error
	VisitNotWithContext(ctx context.Context, v NotRanges) error
	VisitOnChangeWithContext(ctx context.Context, v OnChangeRanges) error
	VisitPeakWithContext(ctx context.Context, v PeakRanges) error
	VisitRangeNumericAggregationWithContext(ctx context.Context, v RangesNumericAggregation) error
	VisitRawWithContext(ctx context.Context, v Reference) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitSeriesCrossoverRangesNodeWithContext(ctx context.Context, v SeriesCrossoverRanges) error
	VisitSeriesEqualityRangesNodeWithContext(ctx context.Context, v SeriesEqualityRanges) error
	VisitStabilityDetectionWithContext(ctx context.Context, v StabilityDetectionRanges) error
	VisitStaleRangeWithContext(ctx context.Context, v StaleRanges) error
	VisitThresholdWithContext(ctx context.Context, v ThresholdingRanges) error
	VisitUnionRangeWithContext(ctx context.Context, v UnionRanges) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangeSeriesFromApproximateThreshold(v ApproximateThresholdRanges) RangeSeries {
	return RangeSeries{typ: "approximateThreshold", approximateThreshold: &v}
}

func NewRangeSeriesFromDurationFilter(v DurationFilterRanges) RangeSeries {
	return RangeSeries{typ: "durationFilter", durationFilter: &v}
}

func NewRangeSeriesFromEnumFilter(v EnumFilterRanges) RangeSeries {
	return RangeSeries{typ: "enumFilter", enumFilter: &v}
}

func NewRangeSeriesFromEnumSeriesEqualityRangesNode(v EnumSeriesEqualityRanges) RangeSeries {
	return RangeSeries{typ: "enumSeriesEqualityRangesNode", enumSeriesEqualityRangesNode: &v}
}

func NewRangeSeriesFromEventsSearch(v EventsSearchRanges) RangeSeries {
	return RangeSeries{typ: "eventsSearch", eventsSearch: &v}
}

func NewRangeSeriesFromIntersectRange(v IntersectRanges) RangeSeries {
	return RangeSeries{typ: "intersectRange", intersectRange: &v}
}

func NewRangeSeriesFromLiteralRanges(v LiteralRanges) RangeSeries {
	return RangeSeries{typ: "literalRanges", literalRanges: &v}
}

func NewRangeSeriesFromMinMaxThreshold(v MinMaxThresholdRanges) RangeSeries {
	return RangeSeries{typ: "minMaxThreshold", minMaxThreshold: &v}
}

func NewRangeSeriesFromNot(v NotRanges) RangeSeries {
	return RangeSeries{typ: "not", not: &v}
}

func NewRangeSeriesFromOnChange(v OnChangeRanges) RangeSeries {
	return RangeSeries{typ: "onChange", onChange: &v}
}

func NewRangeSeriesFromPeak(v PeakRanges) RangeSeries {
	return RangeSeries{typ: "peak", peak: &v}
}

func NewRangeSeriesFromRangeNumericAggregation(v RangesNumericAggregation) RangeSeries {
	return RangeSeries{typ: "rangeNumericAggregation", rangeNumericAggregation: &v}
}

func NewRangeSeriesFromRaw(v Reference) RangeSeries {
	return RangeSeries{typ: "raw", raw: &v}
}

func NewRangeSeriesFromDerived(v DerivedSeries) RangeSeries {
	return RangeSeries{typ: "derived", derived: &v}
}

func NewRangeSeriesFromSeriesCrossoverRangesNode(v SeriesCrossoverRanges) RangeSeries {
	return RangeSeries{typ: "seriesCrossoverRangesNode", seriesCrossoverRangesNode: &v}
}

func NewRangeSeriesFromSeriesEqualityRangesNode(v SeriesEqualityRanges) RangeSeries {
	return RangeSeries{typ: "seriesEqualityRangesNode", seriesEqualityRangesNode: &v}
}

func NewRangeSeriesFromStabilityDetection(v StabilityDetectionRanges) RangeSeries {
	return RangeSeries{typ: "stabilityDetection", stabilityDetection: &v}
}

func NewRangeSeriesFromStaleRange(v StaleRanges) RangeSeries {
	return RangeSeries{typ: "staleRange", staleRange: &v}
}

func NewRangeSeriesFromThreshold(v ThresholdingRanges) RangeSeries {
	return RangeSeries{typ: "threshold", threshold: &v}
}

func NewRangeSeriesFromUnionRange(v UnionRanges) RangeSeries {
	return RangeSeries{typ: "unionRange", unionRange: &v}
}

type RangeValue struct {
	typ             string
	double          *float64
	aggregation     *RangeAggregation
	noPointsInRange *api1.Empty
}

type rangeValueDeserializer struct {
	Type            string            `json:"type"`
	Double          *float64          `json:"double"`
	Aggregation     *RangeAggregation `json:"aggregation"`
	NoPointsInRange *api1.Empty       `json:"noPointsInRange"`
}

func (u *rangeValueDeserializer) toStruct() RangeValue {
	return RangeValue{typ: u.Type, double: u.Double, aggregation: u.Aggregation, noPointsInRange: u.NoPointsInRange}
}

func (u *RangeValue) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "double":
		if u.double == nil {
			return nil, fmt.Errorf("field \"double\" is required")
		}
		return struct {
			Type   string  `json:"type"`
			Double float64 `json:"double"`
		}{Type: "double", Double: *u.double}, nil
	case "aggregation":
		if u.aggregation == nil {
			return nil, fmt.Errorf("field \"aggregation\" is required")
		}
		return struct {
			Type        string           `json:"type"`
			Aggregation RangeAggregation `json:"aggregation"`
		}{Type: "aggregation", Aggregation: *u.aggregation}, nil
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return nil, fmt.Errorf("field \"noPointsInRange\" is required")
		}
		return struct {
			Type            string     `json:"type"`
			NoPointsInRange api1.Empty `json:"noPointsInRange"`
		}{Type: "noPointsInRange", NoPointsInRange: *u.noPointsInRange}, nil
	}
}

func (u RangeValue) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangeValue) UnmarshalJSON(data []byte) error {
	var deser rangeValueDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
	case "aggregation":
		if u.aggregation == nil {
			return fmt.Errorf("field \"aggregation\" is required")
		}
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return fmt.Errorf("field \"noPointsInRange\" is required")
		}
	}
	return nil
}

func (u RangeValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangeValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangeValue) AcceptFuncs(doubleFunc func(float64) error, aggregationFunc func(RangeAggregation) error, noPointsInRangeFunc func(api1.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "aggregation":
		if u.aggregation == nil {
			return fmt.Errorf("field \"aggregation\" is required")
		}
		return aggregationFunc(*u.aggregation)
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return fmt.Errorf("field \"noPointsInRange\" is required")
		}
		return noPointsInRangeFunc(*u.noPointsInRange)
	}
}

func (u *RangeValue) DoubleNoopSuccess(float64) error {
	return nil
}

func (u *RangeValue) AggregationNoopSuccess(RangeAggregation) error {
	return nil
}

func (u *RangeValue) NoPointsInRangeNoopSuccess(api1.Empty) error {
	return nil
}

func (u *RangeValue) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangeValue) Accept(v RangeValueVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(*u.double)
	case "aggregation":
		if u.aggregation == nil {
			return fmt.Errorf("field \"aggregation\" is required")
		}
		return v.VisitAggregation(*u.aggregation)
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return fmt.Errorf("field \"noPointsInRange\" is required")
		}
		return v.VisitNoPointsInRange(*u.noPointsInRange)
	}
}

type RangeValueVisitor interface {
	VisitDouble(v float64) error
	VisitAggregation(v RangeAggregation) error
	VisitNoPointsInRange(v api1.Empty) error
	VisitUnknown(typeName string) error
}

func (u *RangeValue) AcceptWithContext(ctx context.Context, v RangeValueVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDoubleWithContext(ctx, *u.double)
	case "aggregation":
		if u.aggregation == nil {
			return fmt.Errorf("field \"aggregation\" is required")
		}
		return v.VisitAggregationWithContext(ctx, *u.aggregation)
	case "noPointsInRange":
		if u.noPointsInRange == nil {
			return fmt.Errorf("field \"noPointsInRange\" is required")
		}
		return v.VisitNoPointsInRangeWithContext(ctx, *u.noPointsInRange)
	}
}

type RangeValueVisitorWithContext interface {
	VisitDoubleWithContext(ctx context.Context, v float64) error
	VisitAggregationWithContext(ctx context.Context, v RangeAggregation) error
	VisitNoPointsInRangeWithContext(ctx context.Context, v api1.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangeValueFromDouble(v float64) RangeValue {
	return RangeValue{typ: "double", double: &v}
}

func NewRangeValueFromAggregation(v RangeAggregation) RangeValue {
	return RangeValue{typ: "aggregation", aggregation: &v}
}

func NewRangeValueFromNoPointsInRange(v api1.Empty) RangeValue {
	return RangeValue{typ: "noPointsInRange", noPointsInRange: &v}
}

type ResampleInterpolationConfiguration struct {
	typ                                           string
	forwardFillResampleInterpolationConfiguration *ForwardFillResampleInterpolationConfiguration
}

type resampleInterpolationConfigurationDeserializer struct {
	Type                                          string                                         `json:"type"`
	ForwardFillResampleInterpolationConfiguration *ForwardFillResampleInterpolationConfiguration `json:"forwardFillResampleInterpolationConfiguration"`
}

func (u *resampleInterpolationConfigurationDeserializer) toStruct() ResampleInterpolationConfiguration {
	return ResampleInterpolationConfiguration{typ: u.Type, forwardFillResampleInterpolationConfiguration: u.ForwardFillResampleInterpolationConfiguration}
}

func (u *ResampleInterpolationConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return nil, fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return struct {
			Type                                          string                                        `json:"type"`
			ForwardFillResampleInterpolationConfiguration ForwardFillResampleInterpolationConfiguration `json:"forwardFillResampleInterpolationConfiguration"`
		}{Type: "forwardFillResampleInterpolationConfiguration", ForwardFillResampleInterpolationConfiguration: *u.forwardFillResampleInterpolationConfiguration}, nil
	}
}

func (u ResampleInterpolationConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ResampleInterpolationConfiguration) UnmarshalJSON(data []byte) error {
	var deser resampleInterpolationConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
	}
	return nil
}

func (u ResampleInterpolationConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ResampleInterpolationConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ResampleInterpolationConfiguration) AcceptFuncs(forwardFillResampleInterpolationConfigurationFunc func(ForwardFillResampleInterpolationConfiguration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return forwardFillResampleInterpolationConfigurationFunc(*u.forwardFillResampleInterpolationConfiguration)
	}
}

func (u *ResampleInterpolationConfiguration) ForwardFillResampleInterpolationConfigurationNoopSuccess(ForwardFillResampleInterpolationConfiguration) error {
	return nil
}

func (u *ResampleInterpolationConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ResampleInterpolationConfiguration) Accept(v ResampleInterpolationConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return v.VisitForwardFillResampleInterpolationConfiguration(*u.forwardFillResampleInterpolationConfiguration)
	}
}

type ResampleInterpolationConfigurationVisitor interface {
	VisitForwardFillResampleInterpolationConfiguration(v ForwardFillResampleInterpolationConfiguration) error
	VisitUnknown(typeName string) error
}

func (u *ResampleInterpolationConfiguration) AcceptWithContext(ctx context.Context, v ResampleInterpolationConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "forwardFillResampleInterpolationConfiguration":
		if u.forwardFillResampleInterpolationConfiguration == nil {
			return fmt.Errorf("field \"forwardFillResampleInterpolationConfiguration\" is required")
		}
		return v.VisitForwardFillResampleInterpolationConfigurationWithContext(ctx, *u.forwardFillResampleInterpolationConfiguration)
	}
}

type ResampleInterpolationConfigurationVisitorWithContext interface {
	VisitForwardFillResampleInterpolationConfigurationWithContext(ctx context.Context, v ForwardFillResampleInterpolationConfiguration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewResampleInterpolationConfigurationFromForwardFillResampleInterpolationConfiguration(v ForwardFillResampleInterpolationConfiguration) ResampleInterpolationConfiguration {
	return ResampleInterpolationConfiguration{typ: "forwardFillResampleInterpolationConfiguration", forwardFillResampleInterpolationConfiguration: &v}
}

type RollingOperator struct {
	typ               string
	average           *Average
	count             *Count
	min               *Minimum
	max               *Maximum
	standardDeviation *StandardDeviation
	sum               *Sum
}

type rollingOperatorDeserializer struct {
	Type              string             `json:"type"`
	Average           *Average           `json:"average"`
	Count             *Count             `json:"count"`
	Min               *Minimum           `json:"min"`
	Max               *Maximum           `json:"max"`
	StandardDeviation *StandardDeviation `json:"standardDeviation"`
	Sum               *Sum               `json:"sum"`
}

func (u *rollingOperatorDeserializer) toStruct() RollingOperator {
	return RollingOperator{typ: u.Type, average: u.Average, count: u.Count, min: u.Min, max: u.Max, standardDeviation: u.StandardDeviation, sum: u.Sum}
}

func (u *RollingOperator) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "average":
		if u.average == nil {
			return nil, fmt.Errorf("field \"average\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Average Average `json:"average"`
		}{Type: "average", Average: *u.average}, nil
	case "count":
		if u.count == nil {
			return nil, fmt.Errorf("field \"count\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Count Count  `json:"count"`
		}{Type: "count", Count: *u.count}, nil
	case "min":
		if u.min == nil {
			return nil, fmt.Errorf("field \"min\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Min  Minimum `json:"min"`
		}{Type: "min", Min: *u.min}, nil
	case "max":
		if u.max == nil {
			return nil, fmt.Errorf("field \"max\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Max  Maximum `json:"max"`
		}{Type: "max", Max: *u.max}, nil
	case "standardDeviation":
		if u.standardDeviation == nil {
			return nil, fmt.Errorf("field \"standardDeviation\" is required")
		}
		return struct {
			Type              string            `json:"type"`
			StandardDeviation StandardDeviation `json:"standardDeviation"`
		}{Type: "standardDeviation", StandardDeviation: *u.standardDeviation}, nil
	case "sum":
		if u.sum == nil {
			return nil, fmt.Errorf("field \"sum\" is required")
		}
		return struct {
			Type string `json:"type"`
			Sum  Sum    `json:"sum"`
		}{Type: "sum", Sum: *u.sum}, nil
	}
}

func (u RollingOperator) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RollingOperator) UnmarshalJSON(data []byte) error {
	var deser rollingOperatorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
	}
	return nil
}

func (u RollingOperator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RollingOperator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RollingOperator) AcceptFuncs(averageFunc func(Average) error, countFunc func(Count) error, minFunc func(Minimum) error, maxFunc func(Maximum) error, standardDeviationFunc func(StandardDeviation) error, sumFunc func(Sum) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return averageFunc(*u.average)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return countFunc(*u.count)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return standardDeviationFunc(*u.standardDeviation)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return sumFunc(*u.sum)
	}
}

func (u *RollingOperator) AverageNoopSuccess(Average) error {
	return nil
}

func (u *RollingOperator) CountNoopSuccess(Count) error {
	return nil
}

func (u *RollingOperator) MinNoopSuccess(Minimum) error {
	return nil
}

func (u *RollingOperator) MaxNoopSuccess(Maximum) error {
	return nil
}

func (u *RollingOperator) StandardDeviationNoopSuccess(StandardDeviation) error {
	return nil
}

func (u *RollingOperator) SumNoopSuccess(Sum) error {
	return nil
}

func (u *RollingOperator) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RollingOperator) Accept(v RollingOperatorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return v.VisitAverage(*u.average)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCount(*u.count)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(*u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(*u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviation(*u.standardDeviation)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSum(*u.sum)
	}
}

type RollingOperatorVisitor interface {
	VisitAverage(v Average) error
	VisitCount(v Count) error
	VisitMin(v Minimum) error
	VisitMax(v Maximum) error
	VisitStandardDeviation(v StandardDeviation) error
	VisitSum(v Sum) error
	VisitUnknown(typeName string) error
}

func (u *RollingOperator) AcceptWithContext(ctx context.Context, v RollingOperatorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "average":
		if u.average == nil {
			return fmt.Errorf("field \"average\" is required")
		}
		return v.VisitAverageWithContext(ctx, *u.average)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCountWithContext(ctx, *u.count)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMinWithContext(ctx, *u.min)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMaxWithContext(ctx, *u.max)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviationWithContext(ctx, *u.standardDeviation)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSumWithContext(ctx, *u.sum)
	}
}

type RollingOperatorVisitorWithContext interface {
	VisitAverageWithContext(ctx context.Context, v Average) error
	VisitCountWithContext(ctx context.Context, v Count) error
	VisitMinWithContext(ctx context.Context, v Minimum) error
	VisitMaxWithContext(ctx context.Context, v Maximum) error
	VisitStandardDeviationWithContext(ctx context.Context, v StandardDeviation) error
	VisitSumWithContext(ctx context.Context, v Sum) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRollingOperatorFromAverage(v Average) RollingOperator {
	return RollingOperator{typ: "average", average: &v}
}

func NewRollingOperatorFromCount(v Count) RollingOperator {
	return RollingOperator{typ: "count", count: &v}
}

func NewRollingOperatorFromMin(v Minimum) RollingOperator {
	return RollingOperator{typ: "min", min: &v}
}

func NewRollingOperatorFromMax(v Maximum) RollingOperator {
	return RollingOperator{typ: "max", max: &v}
}

func NewRollingOperatorFromStandardDeviation(v StandardDeviation) RollingOperator {
	return RollingOperator{typ: "standardDeviation", standardDeviation: &v}
}

func NewRollingOperatorFromSum(v Sum) RollingOperator {
	return RollingOperator{typ: "sum", sum: &v}
}

type ScatterSummarizationStrategy struct {
	typ     string
	spatial *SpatialDecimateStrategy
}

type scatterSummarizationStrategyDeserializer struct {
	Type    string                   `json:"type"`
	Spatial *SpatialDecimateStrategy `json:"spatial"`
}

func (u *scatterSummarizationStrategyDeserializer) toStruct() ScatterSummarizationStrategy {
	return ScatterSummarizationStrategy{typ: u.Type, spatial: u.Spatial}
}

func (u *ScatterSummarizationStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "spatial":
		if u.spatial == nil {
			return nil, fmt.Errorf("field \"spatial\" is required")
		}
		return struct {
			Type    string                  `json:"type"`
			Spatial SpatialDecimateStrategy `json:"spatial"`
		}{Type: "spatial", Spatial: *u.spatial}, nil
	}
}

func (u ScatterSummarizationStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ScatterSummarizationStrategy) UnmarshalJSON(data []byte) error {
	var deser scatterSummarizationStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "spatial":
		if u.spatial == nil {
			return fmt.Errorf("field \"spatial\" is required")
		}
	}
	return nil
}

func (u ScatterSummarizationStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ScatterSummarizationStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ScatterSummarizationStrategy) AcceptFuncs(spatialFunc func(SpatialDecimateStrategy) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "spatial":
		if u.spatial == nil {
			return fmt.Errorf("field \"spatial\" is required")
		}
		return spatialFunc(*u.spatial)
	}
}

func (u *ScatterSummarizationStrategy) SpatialNoopSuccess(SpatialDecimateStrategy) error {
	return nil
}

func (u *ScatterSummarizationStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ScatterSummarizationStrategy) Accept(v ScatterSummarizationStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "spatial":
		if u.spatial == nil {
			return fmt.Errorf("field \"spatial\" is required")
		}
		return v.VisitSpatial(*u.spatial)
	}
}

type ScatterSummarizationStrategyVisitor interface {
	VisitSpatial(v SpatialDecimateStrategy) error
	VisitUnknown(typeName string) error
}

func (u *ScatterSummarizationStrategy) AcceptWithContext(ctx context.Context, v ScatterSummarizationStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "spatial":
		if u.spatial == nil {
			return fmt.Errorf("field \"spatial\" is required")
		}
		return v.VisitSpatialWithContext(ctx, *u.spatial)
	}
}

type ScatterSummarizationStrategyVisitorWithContext interface {
	VisitSpatialWithContext(ctx context.Context, v SpatialDecimateStrategy) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewScatterSummarizationStrategyFromSpatial(v SpatialDecimateStrategy) ScatterSummarizationStrategy {
	return ScatterSummarizationStrategy{typ: "spatial", spatial: &v}
}

type SelectValue struct {
	typ        string
	firstPoint *Series
	firstRange *RangeSeries
	lastPoint  *Series
	lastRange  *RangeSeries
}

type selectValueDeserializer struct {
	Type       string       `json:"type"`
	FirstPoint *Series      `json:"firstPoint"`
	FirstRange *RangeSeries `json:"firstRange"`
	LastPoint  *Series      `json:"lastPoint"`
	LastRange  *RangeSeries `json:"lastRange"`
}

func (u *selectValueDeserializer) toStruct() SelectValue {
	return SelectValue{typ: u.Type, firstPoint: u.FirstPoint, firstRange: u.FirstRange, lastPoint: u.LastPoint, lastRange: u.LastRange}
}

func (u *SelectValue) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return nil, fmt.Errorf("field \"firstPoint\" is required")
		}
		return struct {
			Type       string `json:"type"`
			FirstPoint Series `json:"firstPoint"`
		}{Type: "firstPoint", FirstPoint: *u.firstPoint}, nil
	case "firstRange":
		if u.firstRange == nil {
			return nil, fmt.Errorf("field \"firstRange\" is required")
		}
		return struct {
			Type       string      `json:"type"`
			FirstRange RangeSeries `json:"firstRange"`
		}{Type: "firstRange", FirstRange: *u.firstRange}, nil
	case "lastPoint":
		if u.lastPoint == nil {
			return nil, fmt.Errorf("field \"lastPoint\" is required")
		}
		return struct {
			Type      string `json:"type"`
			LastPoint Series `json:"lastPoint"`
		}{Type: "lastPoint", LastPoint: *u.lastPoint}, nil
	case "lastRange":
		if u.lastRange == nil {
			return nil, fmt.Errorf("field \"lastRange\" is required")
		}
		return struct {
			Type      string      `json:"type"`
			LastRange RangeSeries `json:"lastRange"`
		}{Type: "lastRange", LastRange: *u.lastRange}, nil
	}
}

func (u SelectValue) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SelectValue) UnmarshalJSON(data []byte) error {
	var deser selectValueDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
	}
	return nil
}

func (u SelectValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SelectValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SelectValue) AcceptFuncs(firstPointFunc func(Series) error, firstRangeFunc func(RangeSeries) error, lastPointFunc func(Series) error, lastRangeFunc func(RangeSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return firstPointFunc(*u.firstPoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return firstRangeFunc(*u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
		return lastPointFunc(*u.lastPoint)
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
		return lastRangeFunc(*u.lastRange)
	}
}

func (u *SelectValue) FirstPointNoopSuccess(Series) error {
	return nil
}

func (u *SelectValue) FirstRangeNoopSuccess(RangeSeries) error {
	return nil
}

func (u *SelectValue) LastPointNoopSuccess(Series) error {
	return nil
}

func (u *SelectValue) LastRangeNoopSuccess(RangeSeries) error {
	return nil
}

func (u *SelectValue) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SelectValue) Accept(v SelectValueVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return v.VisitFirstPoint(*u.firstPoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return v.VisitFirstRange(*u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
		return v.VisitLastPoint(*u.lastPoint)
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
		return v.VisitLastRange(*u.lastRange)
	}
}

type SelectValueVisitor interface {
	VisitFirstPoint(v Series) error
	VisitFirstRange(v RangeSeries) error
	VisitLastPoint(v Series) error
	VisitLastRange(v RangeSeries) error
	VisitUnknown(typeName string) error
}

func (u *SelectValue) AcceptWithContext(ctx context.Context, v SelectValueVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return v.VisitFirstPointWithContext(ctx, *u.firstPoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return v.VisitFirstRangeWithContext(ctx, *u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
		return v.VisitLastPointWithContext(ctx, *u.lastPoint)
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
		return v.VisitLastRangeWithContext(ctx, *u.lastRange)
	}
}

type SelectValueVisitorWithContext interface {
	VisitFirstPointWithContext(ctx context.Context, v Series) error
	VisitFirstRangeWithContext(ctx context.Context, v RangeSeries) error
	VisitLastPointWithContext(ctx context.Context, v Series) error
	VisitLastRangeWithContext(ctx context.Context, v RangeSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSelectValueFromFirstPoint(v Series) SelectValue {
	return SelectValue{typ: "firstPoint", firstPoint: &v}
}

func NewSelectValueFromFirstRange(v RangeSeries) SelectValue {
	return SelectValue{typ: "firstRange", firstRange: &v}
}

func NewSelectValueFromLastPoint(v Series) SelectValue {
	return SelectValue{typ: "lastPoint", lastPoint: &v}
}

func NewSelectValueFromLastRange(v RangeSeries) SelectValue {
	return SelectValue{typ: "lastRange", lastRange: &v}
}

type Series struct {
	typ     string
	raw     *Reference
	enum    *EnumSeries
	numeric *NumericSeries
	log     *LogSeries
	array   *ArraySeries
}

type seriesDeserializer struct {
	Type    string         `json:"type"`
	Raw     *Reference     `json:"raw"`
	Enum    *EnumSeries    `json:"enum"`
	Numeric *NumericSeries `json:"numeric"`
	Log     *LogSeries     `json:"log"`
	Array   *ArraySeries   `json:"array"`
}

func (u *seriesDeserializer) toStruct() Series {
	return Series{typ: u.Type, raw: u.Raw, enum: u.Enum, numeric: u.Numeric, log: u.Log, array: u.Array}
}

func (u *Series) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Raw  Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Enum EnumSeries `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Numeric NumericSeries `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "log":
		if u.log == nil {
			return nil, fmt.Errorf("field \"log\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Log  LogSeries `json:"log"`
		}{Type: "log", Log: *u.log}, nil
	case "array":
		if u.array == nil {
			return nil, fmt.Errorf("field \"array\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Array ArraySeries `json:"array"`
		}{Type: "array", Array: *u.array}, nil
	}
}

func (u Series) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Series) UnmarshalJSON(data []byte) error {
	var deser seriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
	}
	return nil
}

func (u Series) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Series) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Series) AcceptFuncs(rawFunc func(Reference) error, enumFunc func(EnumSeries) error, numericFunc func(NumericSeries) error, logFunc func(LogSeries) error, arrayFunc func(ArraySeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	}
}

func (u *Series) RawNoopSuccess(Reference) error {
	return nil
}

func (u *Series) EnumNoopSuccess(EnumSeries) error {
	return nil
}

func (u *Series) NumericNoopSuccess(NumericSeries) error {
	return nil
}

func (u *Series) LogNoopSuccess(LogSeries) error {
	return nil
}

func (u *Series) ArrayNoopSuccess(ArraySeries) error {
	return nil
}

func (u *Series) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Series) Accept(v SeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(*u.log)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(*u.array)
	}
}

type SeriesVisitor interface {
	VisitRaw(v Reference) error
	VisitEnum(v EnumSeries) error
	VisitNumeric(v NumericSeries) error
	VisitLog(v LogSeries) error
	VisitArray(v ArraySeries) error
	VisitUnknown(typeName string) error
}

func (u *Series) AcceptWithContext(ctx context.Context, v SeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLogWithContext(ctx, *u.log)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArrayWithContext(ctx, *u.array)
	}
}

type SeriesVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v Reference) error
	VisitEnumWithContext(ctx context.Context, v EnumSeries) error
	VisitNumericWithContext(ctx context.Context, v NumericSeries) error
	VisitLogWithContext(ctx context.Context, v LogSeries) error
	VisitArrayWithContext(ctx context.Context, v ArraySeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSeriesFromRaw(v Reference) Series {
	return Series{typ: "raw", raw: &v}
}

func NewSeriesFromEnum(v EnumSeries) Series {
	return Series{typ: "enum", enum: &v}
}

func NewSeriesFromNumeric(v NumericSeries) Series {
	return Series{typ: "numeric", numeric: &v}
}

func NewSeriesFromLog(v LogSeries) Series {
	return Series{typ: "log", log: &v}
}

func NewSeriesFromArray(v ArraySeries) Series {
	return Series{typ: "array", array: &v}
}

type SignalFilterConfiguration struct {
	typ      string
	lowPass  *LowPassConfiguration
	highPass *HighPassConfiguration
	bandPass *BandPassConfiguration
	bandStop *BandStopConfiguration
}

type signalFilterConfigurationDeserializer struct {
	Type     string                 `json:"type"`
	LowPass  *LowPassConfiguration  `json:"lowPass"`
	HighPass *HighPassConfiguration `json:"highPass"`
	BandPass *BandPassConfiguration `json:"bandPass"`
	BandStop *BandStopConfiguration `json:"bandStop"`
}

func (u *signalFilterConfigurationDeserializer) toStruct() SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: u.Type, lowPass: u.LowPass, highPass: u.HighPass, bandPass: u.BandPass, bandStop: u.BandStop}
}

func (u *SignalFilterConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return nil, fmt.Errorf("field \"lowPass\" is required")
		}
		return struct {
			Type    string               `json:"type"`
			LowPass LowPassConfiguration `json:"lowPass"`
		}{Type: "lowPass", LowPass: *u.lowPass}, nil
	case "highPass":
		if u.highPass == nil {
			return nil, fmt.Errorf("field \"highPass\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			HighPass HighPassConfiguration `json:"highPass"`
		}{Type: "highPass", HighPass: *u.highPass}, nil
	case "bandPass":
		if u.bandPass == nil {
			return nil, fmt.Errorf("field \"bandPass\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			BandPass BandPassConfiguration `json:"bandPass"`
		}{Type: "bandPass", BandPass: *u.bandPass}, nil
	case "bandStop":
		if u.bandStop == nil {
			return nil, fmt.Errorf("field \"bandStop\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			BandStop BandStopConfiguration `json:"bandStop"`
		}{Type: "bandStop", BandStop: *u.bandStop}, nil
	}
}

func (u SignalFilterConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SignalFilterConfiguration) UnmarshalJSON(data []byte) error {
	var deser signalFilterConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
	}
	return nil
}

func (u SignalFilterConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SignalFilterConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SignalFilterConfiguration) AcceptFuncs(lowPassFunc func(LowPassConfiguration) error, highPassFunc func(HighPassConfiguration) error, bandPassFunc func(BandPassConfiguration) error, bandStopFunc func(BandStopConfiguration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
		return lowPassFunc(*u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
		return highPassFunc(*u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
		return bandPassFunc(*u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
		return bandStopFunc(*u.bandStop)
	}
}

func (u *SignalFilterConfiguration) LowPassNoopSuccess(LowPassConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) HighPassNoopSuccess(HighPassConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) BandPassNoopSuccess(BandPassConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) BandStopNoopSuccess(BandStopConfiguration) error {
	return nil
}

func (u *SignalFilterConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SignalFilterConfiguration) Accept(v SignalFilterConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
		return v.VisitLowPass(*u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
		return v.VisitHighPass(*u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
		return v.VisitBandPass(*u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
		return v.VisitBandStop(*u.bandStop)
	}
}

type SignalFilterConfigurationVisitor interface {
	VisitLowPass(v LowPassConfiguration) error
	VisitHighPass(v HighPassConfiguration) error
	VisitBandPass(v BandPassConfiguration) error
	VisitBandStop(v BandStopConfiguration) error
	VisitUnknown(typeName string) error
}

func (u *SignalFilterConfiguration) AcceptWithContext(ctx context.Context, v SignalFilterConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "lowPass":
		if u.lowPass == nil {
			return fmt.Errorf("field \"lowPass\" is required")
		}
		return v.VisitLowPassWithContext(ctx, *u.lowPass)
	case "highPass":
		if u.highPass == nil {
			return fmt.Errorf("field \"highPass\" is required")
		}
		return v.VisitHighPassWithContext(ctx, *u.highPass)
	case "bandPass":
		if u.bandPass == nil {
			return fmt.Errorf("field \"bandPass\" is required")
		}
		return v.VisitBandPassWithContext(ctx, *u.bandPass)
	case "bandStop":
		if u.bandStop == nil {
			return fmt.Errorf("field \"bandStop\" is required")
		}
		return v.VisitBandStopWithContext(ctx, *u.bandStop)
	}
}

type SignalFilterConfigurationVisitorWithContext interface {
	VisitLowPassWithContext(ctx context.Context, v LowPassConfiguration) error
	VisitHighPassWithContext(ctx context.Context, v HighPassConfiguration) error
	VisitBandPassWithContext(ctx context.Context, v BandPassConfiguration) error
	VisitBandStopWithContext(ctx context.Context, v BandStopConfiguration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSignalFilterConfigurationFromLowPass(v LowPassConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "lowPass", lowPass: &v}
}

func NewSignalFilterConfigurationFromHighPass(v HighPassConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "highPass", highPass: &v}
}

func NewSignalFilterConfigurationFromBandPass(v BandPassConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "bandPass", bandPass: &v}
}

func NewSignalFilterConfigurationFromBandStop(v BandStopConfiguration) SignalFilterConfiguration {
	return SignalFilterConfiguration{typ: "bandStop", bandStop: &v}
}

type StringConstant struct {
	typ      string
	literal  *string
	variable *VariableName
}

type stringConstantDeserializer struct {
	Type     string        `json:"type"`
	Literal  *string       `json:"literal"`
	Variable *VariableName `json:"variable"`
}

func (u *stringConstantDeserializer) toStruct() StringConstant {
	return StringConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *StringConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string `json:"type"`
			Literal string `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Variable VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u StringConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *StringConstant) UnmarshalJSON(data []byte) error {
	var deser stringConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u StringConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *StringConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *StringConstant) AcceptFuncs(literalFunc func(string) error, variableFunc func(VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *StringConstant) LiteralNoopSuccess(string) error {
	return nil
}

func (u *StringConstant) VariableNoopSuccess(VariableName) error {
	return nil
}

func (u *StringConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *StringConstant) Accept(v StringConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type StringConstantVisitor interface {
	VisitLiteral(v string) error
	VisitVariable(v VariableName) error
	VisitUnknown(typeName string) error
}

func (u *StringConstant) AcceptWithContext(ctx context.Context, v StringConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type StringConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v string) error
	VisitVariableWithContext(ctx context.Context, v VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewStringConstantFromLiteral(v string) StringConstant {
	return StringConstant{typ: "literal", literal: &v}
}

func NewStringConstantFromVariable(v VariableName) StringConstant {
	return StringConstant{typ: "variable", variable: &v}
}

type StringSetConstant struct {
	typ      string
	literal  *[]string
	variable *VariableName
}

type stringSetConstantDeserializer struct {
	Type     string        `json:"type"`
	Literal  *[]string     `json:"literal"`
	Variable *VariableName `json:"variable"`
}

func (u *stringSetConstantDeserializer) toStruct() StringSetConstant {
	return StringSetConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *StringSetConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string   `json:"type"`
			Literal []string `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Variable VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u StringSetConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *StringSetConstant) UnmarshalJSON(data []byte) error {
	var deser stringSetConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u StringSetConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *StringSetConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *StringSetConstant) AcceptFuncs(literalFunc func([]string) error, variableFunc func(VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *StringSetConstant) LiteralNoopSuccess([]string) error {
	return nil
}

func (u *StringSetConstant) VariableNoopSuccess(VariableName) error {
	return nil
}

func (u *StringSetConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *StringSetConstant) Accept(v StringSetConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type StringSetConstantVisitor interface {
	VisitLiteral(v []string) error
	VisitVariable(v VariableName) error
	VisitUnknown(typeName string) error
}

func (u *StringSetConstant) AcceptWithContext(ctx context.Context, v StringSetConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type StringSetConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v []string) error
	VisitVariableWithContext(ctx context.Context, v VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewStringSetConstantFromLiteral(v []string) StringSetConstant {
	return StringSetConstant{typ: "literal", literal: &v}
}

func NewStringSetConstantFromVariable(v VariableName) StringSetConstant {
	return StringSetConstant{typ: "variable", variable: &v}
}

type SummarizationStrategy struct {
	typ      string
	decimate *DecimateStrategy
	page     *PageStrategy
}

type summarizationStrategyDeserializer struct {
	Type     string            `json:"type"`
	Decimate *DecimateStrategy `json:"decimate"`
	Page     *PageStrategy     `json:"page"`
}

func (u *summarizationStrategyDeserializer) toStruct() SummarizationStrategy {
	return SummarizationStrategy{typ: u.Type, decimate: u.Decimate, page: u.Page}
}

func (u *SummarizationStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "decimate":
		if u.decimate == nil {
			return nil, fmt.Errorf("field \"decimate\" is required")
		}
		return struct {
			Type     string           `json:"type"`
			Decimate DecimateStrategy `json:"decimate"`
		}{Type: "decimate", Decimate: *u.decimate}, nil
	case "page":
		if u.page == nil {
			return nil, fmt.Errorf("field \"page\" is required")
		}
		return struct {
			Type string       `json:"type"`
			Page PageStrategy `json:"page"`
		}{Type: "page", Page: *u.page}, nil
	}
}

func (u SummarizationStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SummarizationStrategy) UnmarshalJSON(data []byte) error {
	var deser summarizationStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "decimate":
		if u.decimate == nil {
			return fmt.Errorf("field \"decimate\" is required")
		}
	case "page":
		if u.page == nil {
			return fmt.Errorf("field \"page\" is required")
		}
	}
	return nil
}

func (u SummarizationStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SummarizationStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SummarizationStrategy) AcceptFuncs(decimateFunc func(DecimateStrategy) error, pageFunc func(PageStrategy) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "decimate":
		if u.decimate == nil {
			return fmt.Errorf("field \"decimate\" is required")
		}
		return decimateFunc(*u.decimate)
	case "page":
		if u.page == nil {
			return fmt.Errorf("field \"page\" is required")
		}
		return pageFunc(*u.page)
	}
}

func (u *SummarizationStrategy) DecimateNoopSuccess(DecimateStrategy) error {
	return nil
}

func (u *SummarizationStrategy) PageNoopSuccess(PageStrategy) error {
	return nil
}

func (u *SummarizationStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SummarizationStrategy) Accept(v SummarizationStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "decimate":
		if u.decimate == nil {
			return fmt.Errorf("field \"decimate\" is required")
		}
		return v.VisitDecimate(*u.decimate)
	case "page":
		if u.page == nil {
			return fmt.Errorf("field \"page\" is required")
		}
		return v.VisitPage(*u.page)
	}
}

type SummarizationStrategyVisitor interface {
	VisitDecimate(v DecimateStrategy) error
	VisitPage(v PageStrategy) error
	VisitUnknown(typeName string) error
}

func (u *SummarizationStrategy) AcceptWithContext(ctx context.Context, v SummarizationStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "decimate":
		if u.decimate == nil {
			return fmt.Errorf("field \"decimate\" is required")
		}
		return v.VisitDecimateWithContext(ctx, *u.decimate)
	case "page":
		if u.page == nil {
			return fmt.Errorf("field \"page\" is required")
		}
		return v.VisitPageWithContext(ctx, *u.page)
	}
}

type SummarizationStrategyVisitorWithContext interface {
	VisitDecimateWithContext(ctx context.Context, v DecimateStrategy) error
	VisitPageWithContext(ctx context.Context, v PageStrategy) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSummarizationStrategyFromDecimate(v DecimateStrategy) SummarizationStrategy {
	return SummarizationStrategy{typ: "decimate", decimate: &v}
}

func NewSummarizationStrategyFromPage(v PageStrategy) SummarizationStrategy {
	return SummarizationStrategy{typ: "page", page: &v}
}

/*
A set of tag filters to apply to a channel. Allows for combining filters on multiple tag keys, but throws if
any one tag key is specified in more than one filter.
*/
type TagFilters struct {
	typ    string
	single *TagFilter
	and    *[]TagFilters
}

type tagFiltersDeserializer struct {
	Type   string        `json:"type"`
	Single *TagFilter    `json:"single"`
	And    *[]TagFilters `json:"and"`
}

func (u *tagFiltersDeserializer) toStruct() TagFilters {
	return TagFilters{typ: u.Type, single: u.Single, and: u.And}
}

func (u *TagFilters) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "single":
		if u.single == nil {
			return nil, fmt.Errorf("field \"single\" is required")
		}
		return struct {
			Type   string    `json:"type"`
			Single TagFilter `json:"single"`
		}{Type: "single", Single: *u.single}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string       `json:"type"`
			And  []TagFilters `json:"and"`
		}{Type: "and", And: *u.and}, nil
	}
}

func (u TagFilters) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TagFilters) UnmarshalJSON(data []byte) error {
	var deser tagFiltersDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	}
	return nil
}

func (u TagFilters) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TagFilters) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TagFilters) AcceptFuncs(singleFunc func(TagFilter) error, andFunc func([]TagFilters) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	}
}

func (u *TagFilters) SingleNoopSuccess(TagFilter) error {
	return nil
}

func (u *TagFilters) AndNoopSuccess([]TagFilters) error {
	return nil
}

func (u *TagFilters) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TagFilters) Accept(v TagFiltersVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(*u.single)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	}
}

type TagFiltersVisitor interface {
	VisitSingle(v TagFilter) error
	VisitAnd(v []TagFilters) error
	VisitUnknown(typeName string) error
}

func (u *TagFilters) AcceptWithContext(ctx context.Context, v TagFiltersVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingleWithContext(ctx, *u.single)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	}
}

type TagFiltersVisitorWithContext interface {
	VisitSingleWithContext(ctx context.Context, v TagFilter) error
	VisitAndWithContext(ctx context.Context, v []TagFilters) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTagFiltersFromSingle(v TagFilter) TagFilters {
	return TagFilters{typ: "single", single: &v}
}

func NewTagFiltersFromAnd(v []TagFilters) TagFilters {
	return TagFilters{typ: "and", and: &v}
}

type Threshold struct {
	typ        string
	absolute   *AbsoluteThreshold
	percentage *PercentageThreshold
}

type thresholdDeserializer struct {
	Type       string               `json:"type"`
	Absolute   *AbsoluteThreshold   `json:"absolute"`
	Percentage *PercentageThreshold `json:"percentage"`
}

func (u *thresholdDeserializer) toStruct() Threshold {
	return Threshold{typ: u.Type, absolute: u.Absolute, percentage: u.Percentage}
}

func (u *Threshold) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "absolute":
		if u.absolute == nil {
			return nil, fmt.Errorf("field \"absolute\" is required")
		}
		return struct {
			Type     string            `json:"type"`
			Absolute AbsoluteThreshold `json:"absolute"`
		}{Type: "absolute", Absolute: *u.absolute}, nil
	case "percentage":
		if u.percentage == nil {
			return nil, fmt.Errorf("field \"percentage\" is required")
		}
		return struct {
			Type       string              `json:"type"`
			Percentage PercentageThreshold `json:"percentage"`
		}{Type: "percentage", Percentage: *u.percentage}, nil
	}
}

func (u Threshold) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Threshold) UnmarshalJSON(data []byte) error {
	var deser thresholdDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
	}
	return nil
}

func (u Threshold) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Threshold) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Threshold) AcceptFuncs(absoluteFunc func(AbsoluteThreshold) error, percentageFunc func(PercentageThreshold) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return absoluteFunc(*u.absolute)
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
		return percentageFunc(*u.percentage)
	}
}

func (u *Threshold) AbsoluteNoopSuccess(AbsoluteThreshold) error {
	return nil
}

func (u *Threshold) PercentageNoopSuccess(PercentageThreshold) error {
	return nil
}

func (u *Threshold) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Threshold) Accept(v ThresholdVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsolute(*u.absolute)
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
		return v.VisitPercentage(*u.percentage)
	}
}

type ThresholdVisitor interface {
	VisitAbsolute(v AbsoluteThreshold) error
	VisitPercentage(v PercentageThreshold) error
	VisitUnknown(typeName string) error
}

func (u *Threshold) AcceptWithContext(ctx context.Context, v ThresholdVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsoluteWithContext(ctx, *u.absolute)
	case "percentage":
		if u.percentage == nil {
			return fmt.Errorf("field \"percentage\" is required")
		}
		return v.VisitPercentageWithContext(ctx, *u.percentage)
	}
}

type ThresholdVisitorWithContext interface {
	VisitAbsoluteWithContext(ctx context.Context, v AbsoluteThreshold) error
	VisitPercentageWithContext(ctx context.Context, v PercentageThreshold) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewThresholdFromAbsolute(v AbsoluteThreshold) Threshold {
	return Threshold{typ: "absolute", absolute: &v}
}

func NewThresholdFromPercentage(v PercentageThreshold) Threshold {
	return Threshold{typ: "percentage", percentage: &v}
}

type TimestampConstant struct {
	typ      string
	literal  *api1.Timestamp
	variable *VariableName
}

type timestampConstantDeserializer struct {
	Type     string          `json:"type"`
	Literal  *api1.Timestamp `json:"literal"`
	Variable *VariableName   `json:"variable"`
}

func (u *timestampConstantDeserializer) toStruct() TimestampConstant {
	return TimestampConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *TimestampConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string         `json:"type"`
			Literal api1.Timestamp `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Variable VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u TimestampConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimestampConstant) UnmarshalJSON(data []byte) error {
	var deser timestampConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u TimestampConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimestampConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimestampConstant) AcceptFuncs(literalFunc func(api1.Timestamp) error, variableFunc func(VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *TimestampConstant) LiteralNoopSuccess(api1.Timestamp) error {
	return nil
}

func (u *TimestampConstant) VariableNoopSuccess(VariableName) error {
	return nil
}

func (u *TimestampConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimestampConstant) Accept(v TimestampConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type TimestampConstantVisitor interface {
	VisitLiteral(v api1.Timestamp) error
	VisitVariable(v VariableName) error
	VisitUnknown(typeName string) error
}

func (u *TimestampConstant) AcceptWithContext(ctx context.Context, v TimestampConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type TimestampConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v api1.Timestamp) error
	VisitVariableWithContext(ctx context.Context, v VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimestampConstantFromLiteral(v api1.Timestamp) TimestampConstant {
	return TimestampConstant{typ: "literal", literal: &v}
}

func NewTimestampConstantFromVariable(v VariableName) TimestampConstant {
	return TimestampConstant{typ: "variable", variable: &v}
}

type UnitComputationError struct {
	typ                        string
	incompatibleUnitsOperation *IncompatibleUnitOperation
	unitsMissing               *UnitsMissing
	error                      *api1.SerializableError
}

type unitComputationErrorDeserializer struct {
	Type                       string                     `json:"type"`
	IncompatibleUnitsOperation *IncompatibleUnitOperation `json:"incompatibleUnitsOperation"`
	UnitsMissing               *UnitsMissing              `json:"unitsMissing"`
	Error                      *api1.SerializableError    `json:"error"`
}

func (u *unitComputationErrorDeserializer) toStruct() UnitComputationError {
	return UnitComputationError{typ: u.Type, incompatibleUnitsOperation: u.IncompatibleUnitsOperation, unitsMissing: u.UnitsMissing, error: u.Error}
}

func (u *UnitComputationError) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return nil, fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
		return struct {
			Type                       string                    `json:"type"`
			IncompatibleUnitsOperation IncompatibleUnitOperation `json:"incompatibleUnitsOperation"`
		}{Type: "incompatibleUnitsOperation", IncompatibleUnitsOperation: *u.incompatibleUnitsOperation}, nil
	case "unitsMissing":
		if u.unitsMissing == nil {
			return nil, fmt.Errorf("field \"unitsMissing\" is required")
		}
		return struct {
			Type         string       `json:"type"`
			UnitsMissing UnitsMissing `json:"unitsMissing"`
		}{Type: "unitsMissing", UnitsMissing: *u.unitsMissing}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string                 `json:"type"`
			Error api1.SerializableError `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	}
}

func (u UnitComputationError) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UnitComputationError) UnmarshalJSON(data []byte) error {
	var deser unitComputationErrorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
	case "unitsMissing":
		if u.unitsMissing == nil {
			return fmt.Errorf("field \"unitsMissing\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	}
	return nil
}

func (u UnitComputationError) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UnitComputationError) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UnitComputationError) AcceptFuncs(incompatibleUnitsOperationFunc func(IncompatibleUnitOperation) error, unitsMissingFunc func(UnitsMissing) error, errorFunc func(api1.SerializableError) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
		return incompatibleUnitsOperationFunc(*u.incompatibleUnitsOperation)
	case "unitsMissing":
		if u.unitsMissing == nil {
			return fmt.Errorf("field \"unitsMissing\" is required")
		}
		return unitsMissingFunc(*u.unitsMissing)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *UnitComputationError) IncompatibleUnitsOperationNoopSuccess(IncompatibleUnitOperation) error {
	return nil
}

func (u *UnitComputationError) UnitsMissingNoopSuccess(UnitsMissing) error {
	return nil
}

func (u *UnitComputationError) ErrorNoopSuccess(api1.SerializableError) error {
	return nil
}

func (u *UnitComputationError) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UnitComputationError) Accept(v UnitComputationErrorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
		return v.VisitIncompatibleUnitsOperation(*u.incompatibleUnitsOperation)
	case "unitsMissing":
		if u.unitsMissing == nil {
			return fmt.Errorf("field \"unitsMissing\" is required")
		}
		return v.VisitUnitsMissing(*u.unitsMissing)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	}
}

type UnitComputationErrorVisitor interface {
	VisitIncompatibleUnitsOperation(v IncompatibleUnitOperation) error
	VisitUnitsMissing(v UnitsMissing) error
	VisitError(v api1.SerializableError) error
	VisitUnknown(typeName string) error
}

func (u *UnitComputationError) AcceptWithContext(ctx context.Context, v UnitComputationErrorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "incompatibleUnitsOperation":
		if u.incompatibleUnitsOperation == nil {
			return fmt.Errorf("field \"incompatibleUnitsOperation\" is required")
		}
		return v.VisitIncompatibleUnitsOperationWithContext(ctx, *u.incompatibleUnitsOperation)
	case "unitsMissing":
		if u.unitsMissing == nil {
			return fmt.Errorf("field \"unitsMissing\" is required")
		}
		return v.VisitUnitsMissingWithContext(ctx, *u.unitsMissing)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	}
}

type UnitComputationErrorVisitorWithContext interface {
	VisitIncompatibleUnitsOperationWithContext(ctx context.Context, v IncompatibleUnitOperation) error
	VisitUnitsMissingWithContext(ctx context.Context, v UnitsMissing) error
	VisitErrorWithContext(ctx context.Context, v api1.SerializableError) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnitComputationErrorFromIncompatibleUnitsOperation(v IncompatibleUnitOperation) UnitComputationError {
	return UnitComputationError{typ: "incompatibleUnitsOperation", incompatibleUnitsOperation: &v}
}

func NewUnitComputationErrorFromUnitsMissing(v UnitsMissing) UnitComputationError {
	return UnitComputationError{typ: "unitsMissing", unitsMissing: &v}
}

func NewUnitComputationErrorFromError(v api1.SerializableError) UnitComputationError {
	return UnitComputationError{typ: "error", error: &v}
}

type UnitResult struct {
	typ             string
	success         *api2.UnitSymbol
	noUnitAvailable *[]UnitComputationError
}

type unitResultDeserializer struct {
	Type            string                  `json:"type"`
	Success         *api2.UnitSymbol        `json:"success"`
	NoUnitAvailable *[]UnitComputationError `json:"noUnitAvailable"`
}

func (u *unitResultDeserializer) toStruct() UnitResult {
	return UnitResult{typ: u.Type, success: u.Success, noUnitAvailable: u.NoUnitAvailable}
}

func (u *UnitResult) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "success":
		if u.success == nil {
			return nil, fmt.Errorf("field \"success\" is required")
		}
		return struct {
			Type    string          `json:"type"`
			Success api2.UnitSymbol `json:"success"`
		}{Type: "success", Success: *u.success}, nil
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return nil, fmt.Errorf("field \"noUnitAvailable\" is required")
		}
		return struct {
			Type            string                 `json:"type"`
			NoUnitAvailable []UnitComputationError `json:"noUnitAvailable"`
		}{Type: "noUnitAvailable", NoUnitAvailable: *u.noUnitAvailable}, nil
	}
}

func (u UnitResult) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UnitResult) UnmarshalJSON(data []byte) error {
	var deser unitResultDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return fmt.Errorf("field \"noUnitAvailable\" is required")
		}
	}
	return nil
}

func (u UnitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UnitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UnitResult) AcceptFuncs(successFunc func(api2.UnitSymbol) error, noUnitAvailableFunc func([]UnitComputationError) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return fmt.Errorf("field \"noUnitAvailable\" is required")
		}
		return noUnitAvailableFunc(*u.noUnitAvailable)
	}
}

func (u *UnitResult) SuccessNoopSuccess(api2.UnitSymbol) error {
	return nil
}

func (u *UnitResult) NoUnitAvailableNoopSuccess([]UnitComputationError) error {
	return nil
}

func (u *UnitResult) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UnitResult) Accept(v UnitResultVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(*u.success)
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return fmt.Errorf("field \"noUnitAvailable\" is required")
		}
		return v.VisitNoUnitAvailable(*u.noUnitAvailable)
	}
}

type UnitResultVisitor interface {
	VisitSuccess(v api2.UnitSymbol) error
	VisitNoUnitAvailable(v []UnitComputationError) error
	VisitUnknown(typeName string) error
}

func (u *UnitResult) AcceptWithContext(ctx context.Context, v UnitResultVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccessWithContext(ctx, *u.success)
	case "noUnitAvailable":
		if u.noUnitAvailable == nil {
			return fmt.Errorf("field \"noUnitAvailable\" is required")
		}
		return v.VisitNoUnitAvailableWithContext(ctx, *u.noUnitAvailable)
	}
}

type UnitResultVisitorWithContext interface {
	VisitSuccessWithContext(ctx context.Context, v api2.UnitSymbol) error
	VisitNoUnitAvailableWithContext(ctx context.Context, v []UnitComputationError) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnitResultFromSuccess(v api2.UnitSymbol) UnitResult {
	return UnitResult{typ: "success", success: &v}
}

func NewUnitResultFromNoUnitAvailable(v []UnitComputationError) UnitResult {
	return UnitResult{typ: "noUnitAvailable", noUnitAvailable: &v}
}

type VariableValue struct {
	typ         string
	double      *float64
	computeNode *ComputeNodeWithContext
	duration    *api.Duration
	integer     *int
	channel     *ChannelSeries
	derived     *DerivedSeries
	series      *SeriesSpec
	string      *string
	stringSet   *[]string
	timestamp   *api1.Timestamp
}

type variableValueDeserializer struct {
	Type        string                  `json:"type"`
	Double      *float64                `json:"double"`
	ComputeNode *ComputeNodeWithContext `json:"computeNode"`
	Duration    *api.Duration           `json:"duration"`
	Integer     *int                    `json:"integer"`
	Channel     *ChannelSeries          `json:"channel"`
	Derived     *DerivedSeries          `json:"derived"`
	Series      *SeriesSpec             `json:"series"`
	String      *string                 `json:"string"`
	StringSet   *[]string               `json:"stringSet"`
	Timestamp   *api1.Timestamp         `json:"timestamp"`
}

func (u *variableValueDeserializer) toStruct() VariableValue {
	return VariableValue{typ: u.Type, double: u.Double, computeNode: u.ComputeNode, duration: u.Duration, integer: u.Integer, channel: u.Channel, derived: u.Derived, series: u.Series, string: u.String, stringSet: u.StringSet, timestamp: u.Timestamp}
}

func (u *VariableValue) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "double":
		if u.double == nil {
			return nil, fmt.Errorf("field \"double\" is required")
		}
		return struct {
			Type   string  `json:"type"`
			Double float64 `json:"double"`
		}{Type: "double", Double: *u.double}, nil
	case "computeNode":
		if u.computeNode == nil {
			return nil, fmt.Errorf("field \"computeNode\" is required")
		}
		return struct {
			Type        string                 `json:"type"`
			ComputeNode ComputeNodeWithContext `json:"computeNode"`
		}{Type: "computeNode", ComputeNode: *u.computeNode}, nil
	case "duration":
		if u.duration == nil {
			return nil, fmt.Errorf("field \"duration\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Duration api.Duration `json:"duration"`
		}{Type: "duration", Duration: *u.duration}, nil
	case "integer":
		if u.integer == nil {
			return nil, fmt.Errorf("field \"integer\" is required")
		}
		return struct {
			Type    string `json:"type"`
			Integer int    `json:"integer"`
		}{Type: "integer", Integer: *u.integer}, nil
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Channel ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	case "series":
		if u.series == nil {
			return nil, fmt.Errorf("field \"series\" is required")
		}
		return struct {
			Type   string     `json:"type"`
			Series SeriesSpec `json:"series"`
		}{Type: "series", Series: *u.series}, nil
	case "string":
		if u.string == nil {
			return nil, fmt.Errorf("field \"string\" is required")
		}
		return struct {
			Type   string `json:"type"`
			String string `json:"string"`
		}{Type: "string", String: *u.string}, nil
	case "stringSet":
		if u.stringSet == nil {
			return nil, fmt.Errorf("field \"stringSet\" is required")
		}
		return struct {
			Type      string   `json:"type"`
			StringSet []string `json:"stringSet"`
		}{Type: "stringSet", StringSet: *u.stringSet}, nil
	case "timestamp":
		if u.timestamp == nil {
			return nil, fmt.Errorf("field \"timestamp\" is required")
		}
		return struct {
			Type      string         `json:"type"`
			Timestamp api1.Timestamp `json:"timestamp"`
		}{Type: "timestamp", Timestamp: *u.timestamp}, nil
	}
}

func (u VariableValue) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VariableValue) UnmarshalJSON(data []byte) error {
	var deser variableValueDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
	case "integer":
		if u.integer == nil {
			return fmt.Errorf("field \"integer\" is required")
		}
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
	case "stringSet":
		if u.stringSet == nil {
			return fmt.Errorf("field \"stringSet\" is required")
		}
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
	}
	return nil
}

func (u VariableValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VariableValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VariableValue) AcceptFuncs(doubleFunc func(float64) error, computeNodeFunc func(ComputeNodeWithContext) error, durationFunc func(api.Duration) error, integerFunc func(int) error, channelFunc func(ChannelSeries) error, derivedFunc func(DerivedSeries) error, seriesFunc func(SeriesSpec) error, stringFunc func(string) error, stringSetFunc func([]string) error, timestampFunc func(api1.Timestamp) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return computeNodeFunc(*u.computeNode)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return durationFunc(*u.duration)
	case "integer":
		if u.integer == nil {
			return fmt.Errorf("field \"integer\" is required")
		}
		return integerFunc(*u.integer)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return stringFunc(*u.string)
	case "stringSet":
		if u.stringSet == nil {
			return fmt.Errorf("field \"stringSet\" is required")
		}
		return stringSetFunc(*u.stringSet)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return timestampFunc(*u.timestamp)
	}
}

func (u *VariableValue) DoubleNoopSuccess(float64) error {
	return nil
}

func (u *VariableValue) ComputeNodeNoopSuccess(ComputeNodeWithContext) error {
	return nil
}

func (u *VariableValue) DurationNoopSuccess(api.Duration) error {
	return nil
}

func (u *VariableValue) IntegerNoopSuccess(int) error {
	return nil
}

func (u *VariableValue) ChannelNoopSuccess(ChannelSeries) error {
	return nil
}

func (u *VariableValue) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *VariableValue) SeriesNoopSuccess(SeriesSpec) error {
	return nil
}

func (u *VariableValue) StringNoopSuccess(string) error {
	return nil
}

func (u *VariableValue) StringSetNoopSuccess([]string) error {
	return nil
}

func (u *VariableValue) TimestampNoopSuccess(api1.Timestamp) error {
	return nil
}

func (u *VariableValue) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VariableValue) Accept(v VariableValueVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(*u.double)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return v.VisitComputeNode(*u.computeNode)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDuration(*u.duration)
	case "integer":
		if u.integer == nil {
			return fmt.Errorf("field \"integer\" is required")
		}
		return v.VisitInteger(*u.integer)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(*u.series)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitString(*u.string)
	case "stringSet":
		if u.stringSet == nil {
			return fmt.Errorf("field \"stringSet\" is required")
		}
		return v.VisitStringSet(*u.stringSet)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestamp(*u.timestamp)
	}
}

type VariableValueVisitor interface {
	VisitDouble(v float64) error
	VisitComputeNode(v ComputeNodeWithContext) error
	VisitDuration(v api.Duration) error
	VisitInteger(v int) error
	VisitChannel(v ChannelSeries) error
	VisitDerived(v DerivedSeries) error
	VisitSeries(v SeriesSpec) error
	VisitString(v string) error
	VisitStringSet(v []string) error
	VisitTimestamp(v api1.Timestamp) error
	VisitUnknown(typeName string) error
}

func (u *VariableValue) AcceptWithContext(ctx context.Context, v VariableValueVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDoubleWithContext(ctx, *u.double)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return v.VisitComputeNodeWithContext(ctx, *u.computeNode)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDurationWithContext(ctx, *u.duration)
	case "integer":
		if u.integer == nil {
			return fmt.Errorf("field \"integer\" is required")
		}
		return v.VisitIntegerWithContext(ctx, *u.integer)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeriesWithContext(ctx, *u.series)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitStringWithContext(ctx, *u.string)
	case "stringSet":
		if u.stringSet == nil {
			return fmt.Errorf("field \"stringSet\" is required")
		}
		return v.VisitStringSetWithContext(ctx, *u.stringSet)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestampWithContext(ctx, *u.timestamp)
	}
}

type VariableValueVisitorWithContext interface {
	VisitDoubleWithContext(ctx context.Context, v float64) error
	VisitComputeNodeWithContext(ctx context.Context, v ComputeNodeWithContext) error
	VisitDurationWithContext(ctx context.Context, v api.Duration) error
	VisitIntegerWithContext(ctx context.Context, v int) error
	VisitChannelWithContext(ctx context.Context, v ChannelSeries) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitSeriesWithContext(ctx context.Context, v SeriesSpec) error
	VisitStringWithContext(ctx context.Context, v string) error
	VisitStringSetWithContext(ctx context.Context, v []string) error
	VisitTimestampWithContext(ctx context.Context, v api1.Timestamp) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVariableValueFromDouble(v float64) VariableValue {
	return VariableValue{typ: "double", double: &v}
}

func NewVariableValueFromComputeNode(v ComputeNodeWithContext) VariableValue {
	return VariableValue{typ: "computeNode", computeNode: &v}
}

func NewVariableValueFromDuration(v api.Duration) VariableValue {
	return VariableValue{typ: "duration", duration: &v}
}

func NewVariableValueFromInteger(v int) VariableValue {
	return VariableValue{typ: "integer", integer: &v}
}

func NewVariableValueFromChannel(v ChannelSeries) VariableValue {
	return VariableValue{typ: "channel", channel: &v}
}

func NewVariableValueFromDerived(v DerivedSeries) VariableValue {
	return VariableValue{typ: "derived", derived: &v}
}

func NewVariableValueFromSeries(v SeriesSpec) VariableValue {
	return VariableValue{typ: "series", series: &v}
}

func NewVariableValueFromString(v string) VariableValue {
	return VariableValue{typ: "string", string: &v}
}

func NewVariableValueFromStringSet(v []string) VariableValue {
	return VariableValue{typ: "stringSet", stringSet: &v}
}

func NewVariableValueFromTimestamp(v api1.Timestamp) VariableValue {
	return VariableValue{typ: "timestamp", timestamp: &v}
}

type Window struct {
	typ      string
	duration *DurationConstant
}

type windowDeserializer struct {
	Type     string            `json:"type"`
	Duration *DurationConstant `json:"duration"`
}

func (u *windowDeserializer) toStruct() Window {
	return Window{typ: u.Type, duration: u.Duration}
}

func (u *Window) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "duration":
		if u.duration == nil {
			return nil, fmt.Errorf("field \"duration\" is required")
		}
		return struct {
			Type     string           `json:"type"`
			Duration DurationConstant `json:"duration"`
		}{Type: "duration", Duration: *u.duration}, nil
	}
}

func (u Window) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Window) UnmarshalJSON(data []byte) error {
	var deser windowDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
	}
	return nil
}

func (u Window) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Window) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Window) AcceptFuncs(durationFunc func(DurationConstant) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return durationFunc(*u.duration)
	}
}

func (u *Window) DurationNoopSuccess(DurationConstant) error {
	return nil
}

func (u *Window) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Window) Accept(v WindowVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDuration(*u.duration)
	}
}

type WindowVisitor interface {
	VisitDuration(v DurationConstant) error
	VisitUnknown(typeName string) error
}

func (u *Window) AcceptWithContext(ctx context.Context, v WindowVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDurationWithContext(ctx, *u.duration)
	}
}

type WindowVisitorWithContext interface {
	VisitDurationWithContext(ctx context.Context, v DurationConstant) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewWindowFromDuration(v DurationConstant) Window {
	return Window{typ: "duration", duration: &v}
}
