// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/internal/conjureerrors"
	api2 "github.com/nominal-io/nominal-api/io/nominal/api"
	api3 "github.com/nominal-io/nominal-api/modules/api"
	api4 "github.com/nominal-io/nominal-api/scout/run/api"
	api1 "github.com/nominal-io/nominal-api/scout/units/api"
	"github.com/nominal-io/nominal-api/storage/series/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type cannotAggregateEnumPlot struct {
	AggregationType string `json:"aggregationType"`
}

func (o cannotAggregateEnumPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *cannotAggregateEnumPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCannotAggregateEnumPlot returns new instance of CannotAggregateEnumPlot error.
func NewCannotAggregateEnumPlot(aggregationTypeArg string) *CannotAggregateEnumPlot {
	return &CannotAggregateEnumPlot{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cannotAggregateEnumPlot: cannotAggregateEnumPlot{AggregationType: aggregationTypeArg}}
}

// WrapWithCannotAggregateEnumPlot returns new instance of CannotAggregateEnumPlot error wrapping an existing error.
func WrapWithCannotAggregateEnumPlot(err error, aggregationTypeArg string) *CannotAggregateEnumPlot {
	return &CannotAggregateEnumPlot{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, cannotAggregateEnumPlot: cannotAggregateEnumPlot{AggregationType: aggregationTypeArg}}
}

// CannotAggregateEnumPlot is an error type.
type CannotAggregateEnumPlot struct {
	errorInstanceID uuid.UUID
	cannotAggregateEnumPlot
	cause error
	stack werror.StackTrace
}

// IsCannotAggregateEnumPlot returns true if err is an instance of CannotAggregateEnumPlot.
func IsCannotAggregateEnumPlot(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CannotAggregateEnumPlot)
	return ok
}

func (e *CannotAggregateEnumPlot) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:CannotAggregateEnumPlot (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CannotAggregateEnumPlot) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CannotAggregateEnumPlot) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CannotAggregateEnumPlot) Message() string {
	return "INVALID_ARGUMENT Compute:CannotAggregateEnumPlot"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CannotAggregateEnumPlot) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CannotAggregateEnumPlot) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CannotAggregateEnumPlot) Name() string {
	return "Compute:CannotAggregateEnumPlot"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CannotAggregateEnumPlot) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CannotAggregateEnumPlot) Parameters() map[string]interface{} {
	return map[string]interface{}{"aggregationType": e.AggregationType}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CannotAggregateEnumPlot) safeParams() map[string]interface{} {
	return map[string]interface{}{"aggregationType": e.AggregationType, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotAggregateEnumPlot) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CannotAggregateEnumPlot) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotAggregateEnumPlot) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CannotAggregateEnumPlot) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.cannotAggregateEnumPlot)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:CannotAggregateEnumPlot", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CannotAggregateEnumPlot) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters cannotAggregateEnumPlot
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.cannotAggregateEnumPlot = parameters
	return nil
}

type cannotCompileRegexp struct {
	QueryId *uuid.UUID `json:"queryId,omitempty"`
}

func (o cannotCompileRegexp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *cannotCompileRegexp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCannotCompileRegexp returns new instance of CannotCompileRegexp error.
func NewCannotCompileRegexp(queryIdArg *uuid.UUID) *CannotCompileRegexp {
	return &CannotCompileRegexp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cannotCompileRegexp: cannotCompileRegexp{QueryId: queryIdArg}}
}

// WrapWithCannotCompileRegexp returns new instance of CannotCompileRegexp error wrapping an existing error.
func WrapWithCannotCompileRegexp(err error, queryIdArg *uuid.UUID) *CannotCompileRegexp {
	return &CannotCompileRegexp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, cannotCompileRegexp: cannotCompileRegexp{QueryId: queryIdArg}}
}

// CannotCompileRegexp is an error type.
// The regular expression could not be compiled.
type CannotCompileRegexp struct {
	errorInstanceID uuid.UUID
	cannotCompileRegexp
	cause error
	stack werror.StackTrace
}

// IsCannotCompileRegexp returns true if err is an instance of CannotCompileRegexp.
func IsCannotCompileRegexp(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CannotCompileRegexp)
	return ok
}

func (e *CannotCompileRegexp) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:CannotCompileRegexp (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CannotCompileRegexp) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CannotCompileRegexp) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CannotCompileRegexp) Message() string {
	return "INVALID_ARGUMENT Compute:CannotCompileRegexp"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CannotCompileRegexp) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CannotCompileRegexp) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CannotCompileRegexp) Name() string {
	return "Compute:CannotCompileRegexp"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CannotCompileRegexp) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CannotCompileRegexp) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CannotCompileRegexp) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotCompileRegexp) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CannotCompileRegexp) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotCompileRegexp) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CannotCompileRegexp) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.cannotCompileRegexp)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:CannotCompileRegexp", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CannotCompileRegexp) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters cannotCompileRegexp
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.cannotCompileRegexp = parameters
	return nil
}

type channelHasWrongType struct {
	SeriesType api.NominalDataType `json:"seriesType"`
	// The set of types that would have been compatible with the rest of the compute graph.
	ValidTypes []api.NominalDataType `conjure-docs:"The set of types that would have been compatible with the rest of the compute graph." json:"validTypes"`
	Channel    DataSourceAndChannel  `json:"channel"`
}

func (o channelHasWrongType) MarshalJSON() ([]byte, error) {
	if o.ValidTypes == nil {
		o.ValidTypes = make([]api.NominalDataType, 0)
	}
	type _tmpchannelHasWrongType channelHasWrongType
	return safejson.Marshal(_tmpchannelHasWrongType(o))
}

func (o *channelHasWrongType) UnmarshalJSON(data []byte) error {
	type _tmpchannelHasWrongType channelHasWrongType
	var rawchannelHasWrongType _tmpchannelHasWrongType
	if err := safejson.Unmarshal(data, &rawchannelHasWrongType); err != nil {
		return err
	}
	if rawchannelHasWrongType.ValidTypes == nil {
		rawchannelHasWrongType.ValidTypes = make([]api.NominalDataType, 0)
	}
	*o = channelHasWrongType(rawchannelHasWrongType)
	return nil
}

func (o channelHasWrongType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *channelHasWrongType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewChannelHasWrongType returns new instance of ChannelHasWrongType error.
func NewChannelHasWrongType(seriesTypeArg api.NominalDataType, validTypesArg []api.NominalDataType, channelArg DataSourceAndChannel) *ChannelHasWrongType {
	return &ChannelHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), channelHasWrongType: channelHasWrongType{SeriesType: seriesTypeArg, ValidTypes: validTypesArg, Channel: channelArg}}
}

// WrapWithChannelHasWrongType returns new instance of ChannelHasWrongType error wrapping an existing error.
func WrapWithChannelHasWrongType(err error, seriesTypeArg api.NominalDataType, validTypesArg []api.NominalDataType, channelArg DataSourceAndChannel) *ChannelHasWrongType {
	return &ChannelHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, channelHasWrongType: channelHasWrongType{SeriesType: seriesTypeArg, ValidTypes: validTypesArg, Channel: channelArg}}
}

// ChannelHasWrongType is an error type.
type ChannelHasWrongType struct {
	errorInstanceID uuid.UUID
	channelHasWrongType
	cause error
	stack werror.StackTrace
}

// IsChannelHasWrongType returns true if err is an instance of ChannelHasWrongType.
func IsChannelHasWrongType(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ChannelHasWrongType)
	return ok
}

func (e *ChannelHasWrongType) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:ChannelHasWrongType (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ChannelHasWrongType) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ChannelHasWrongType) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ChannelHasWrongType) Message() string {
	return "INVALID_ARGUMENT Compute:ChannelHasWrongType"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ChannelHasWrongType) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ChannelHasWrongType) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ChannelHasWrongType) Name() string {
	return "Compute:ChannelHasWrongType"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ChannelHasWrongType) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ChannelHasWrongType) Parameters() map[string]interface{} {
	return map[string]interface{}{"seriesType": e.SeriesType, "validTypes": e.ValidTypes, "channel": e.Channel}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ChannelHasWrongType) safeParams() map[string]interface{} {
	return map[string]interface{}{"seriesType": e.SeriesType, "validTypes": e.ValidTypes, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChannelHasWrongType) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ChannelHasWrongType) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"channel": e.Channel}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChannelHasWrongType) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ChannelHasWrongType) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.channelHasWrongType)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:ChannelHasWrongType", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ChannelHasWrongType) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters channelHasWrongType
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.channelHasWrongType = parameters
	return nil
}

type concurrentQueriesExceeded struct {
	QueryId uuid.UUID `json:"queryId"`
}

func (o concurrentQueriesExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *concurrentQueriesExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConcurrentQueriesExceeded returns new instance of ConcurrentQueriesExceeded error.
func NewConcurrentQueriesExceeded(queryIdArg uuid.UUID) *ConcurrentQueriesExceeded {
	return &ConcurrentQueriesExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), concurrentQueriesExceeded: concurrentQueriesExceeded{QueryId: queryIdArg}}
}

// WrapWithConcurrentQueriesExceeded returns new instance of ConcurrentQueriesExceeded error wrapping an existing error.
func WrapWithConcurrentQueriesExceeded(err error, queryIdArg uuid.UUID) *ConcurrentQueriesExceeded {
	return &ConcurrentQueriesExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, concurrentQueriesExceeded: concurrentQueriesExceeded{QueryId: queryIdArg}}
}

// ConcurrentQueriesExceeded is an error type.
// There are too many concurrent queries running.
type ConcurrentQueriesExceeded struct {
	errorInstanceID uuid.UUID
	concurrentQueriesExceeded
	cause error
	stack werror.StackTrace
}

// IsConcurrentQueriesExceeded returns true if err is an instance of ConcurrentQueriesExceeded.
func IsConcurrentQueriesExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConcurrentQueriesExceeded)
	return ok
}

func (e *ConcurrentQueriesExceeded) Error() string {
	return fmt.Sprintf("INTERNAL Compute:ConcurrentQueriesExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConcurrentQueriesExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConcurrentQueriesExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConcurrentQueriesExceeded) Message() string {
	return "INTERNAL Compute:ConcurrentQueriesExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConcurrentQueriesExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConcurrentQueriesExceeded) Code() errors.ErrorCode {
	return errors.Internal
}

// Name returns an error name identifying error type.
func (e *ConcurrentQueriesExceeded) Name() string {
	return "Compute:ConcurrentQueriesExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConcurrentQueriesExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConcurrentQueriesExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConcurrentQueriesExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConcurrentQueriesExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConcurrentQueriesExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConcurrentQueriesExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConcurrentQueriesExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.concurrentQueriesExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Internal, ErrorName: "Compute:ConcurrentQueriesExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConcurrentQueriesExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters concurrentQueriesExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.concurrentQueriesExceeded = parameters
	return nil
}

type converterInputUnitNotFound struct {
	InputUnit *api1.UnitSymbol `json:"inputUnit,omitempty"`
}

func (o converterInputUnitNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *converterInputUnitNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConverterInputUnitNotFound returns new instance of ConverterInputUnitNotFound error.
func NewConverterInputUnitNotFound(inputUnitArg *api1.UnitSymbol) *ConverterInputUnitNotFound {
	return &ConverterInputUnitNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), converterInputUnitNotFound: converterInputUnitNotFound{InputUnit: inputUnitArg}}
}

// WrapWithConverterInputUnitNotFound returns new instance of ConverterInputUnitNotFound error wrapping an existing error.
func WrapWithConverterInputUnitNotFound(err error, inputUnitArg *api1.UnitSymbol) *ConverterInputUnitNotFound {
	return &ConverterInputUnitNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, converterInputUnitNotFound: converterInputUnitNotFound{InputUnit: inputUnitArg}}
}

// ConverterInputUnitNotFound is an error type.
/*
A unit could not be found for the input series, or it did not exist in the unit system. The conversion could
not be computed.
*/
type ConverterInputUnitNotFound struct {
	errorInstanceID uuid.UUID
	converterInputUnitNotFound
	cause error
	stack werror.StackTrace
}

// IsConverterInputUnitNotFound returns true if err is an instance of ConverterInputUnitNotFound.
func IsConverterInputUnitNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConverterInputUnitNotFound)
	return ok
}

func (e *ConverterInputUnitNotFound) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:ConverterInputUnitNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConverterInputUnitNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConverterInputUnitNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConverterInputUnitNotFound) Message() string {
	return "INVALID_ARGUMENT Compute:ConverterInputUnitNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConverterInputUnitNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConverterInputUnitNotFound) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ConverterInputUnitNotFound) Name() string {
	return "Compute:ConverterInputUnitNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConverterInputUnitNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConverterInputUnitNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConverterInputUnitNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConverterInputUnitNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConverterInputUnitNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConverterInputUnitNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConverterInputUnitNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.converterInputUnitNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:ConverterInputUnitNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConverterInputUnitNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters converterInputUnitNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.converterInputUnitNotFound = parameters
	return nil
}

type converterOutputUnitNotFound struct {
	InputUnit api1.UnitSymbol `json:"inputUnit"`
}

func (o converterOutputUnitNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *converterOutputUnitNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConverterOutputUnitNotFound returns new instance of ConverterOutputUnitNotFound error.
func NewConverterOutputUnitNotFound(inputUnitArg api1.UnitSymbol) *ConverterOutputUnitNotFound {
	return &ConverterOutputUnitNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), converterOutputUnitNotFound: converterOutputUnitNotFound{InputUnit: inputUnitArg}}
}

// WrapWithConverterOutputUnitNotFound returns new instance of ConverterOutputUnitNotFound error wrapping an existing error.
func WrapWithConverterOutputUnitNotFound(err error, inputUnitArg api1.UnitSymbol) *ConverterOutputUnitNotFound {
	return &ConverterOutputUnitNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, converterOutputUnitNotFound: converterOutputUnitNotFound{InputUnit: inputUnitArg}}
}

// ConverterOutputUnitNotFound is an error type.
// The output unit symbol could not be found in the unit system. The conversion could not be computed.
type ConverterOutputUnitNotFound struct {
	errorInstanceID uuid.UUID
	converterOutputUnitNotFound
	cause error
	stack werror.StackTrace
}

// IsConverterOutputUnitNotFound returns true if err is an instance of ConverterOutputUnitNotFound.
func IsConverterOutputUnitNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConverterOutputUnitNotFound)
	return ok
}

func (e *ConverterOutputUnitNotFound) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:ConverterOutputUnitNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConverterOutputUnitNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConverterOutputUnitNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConverterOutputUnitNotFound) Message() string {
	return "INVALID_ARGUMENT Compute:ConverterOutputUnitNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConverterOutputUnitNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConverterOutputUnitNotFound) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ConverterOutputUnitNotFound) Name() string {
	return "Compute:ConverterOutputUnitNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConverterOutputUnitNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConverterOutputUnitNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConverterOutputUnitNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConverterOutputUnitNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConverterOutputUnitNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConverterOutputUnitNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConverterOutputUnitNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.converterOutputUnitNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:ConverterOutputUnitNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConverterOutputUnitNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters converterOutputUnitNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.converterOutputUnitNotFound = parameters
	return nil
}

type curveInvalidNegativeInputs struct{}

func (o curveInvalidNegativeInputs) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *curveInvalidNegativeInputs) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCurveInvalidNegativeInputs returns new instance of CurveInvalidNegativeInputs error.
func NewCurveInvalidNegativeInputs() *CurveInvalidNegativeInputs {
	return &CurveInvalidNegativeInputs{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), curveInvalidNegativeInputs: curveInvalidNegativeInputs{}}
}

// WrapWithCurveInvalidNegativeInputs returns new instance of CurveInvalidNegativeInputs error wrapping an existing error.
func WrapWithCurveInvalidNegativeInputs(err error) *CurveInvalidNegativeInputs {
	return &CurveInvalidNegativeInputs{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, curveInvalidNegativeInputs: curveInvalidNegativeInputs{}}
}

// CurveInvalidNegativeInputs is an error type.
/*
Some points in the input had negative (or zero) x-values. Power and logarithmic curve fits
do not allow negative (or zero) x-valued points.
*/
type CurveInvalidNegativeInputs struct {
	errorInstanceID uuid.UUID
	curveInvalidNegativeInputs
	cause error
	stack werror.StackTrace
}

// IsCurveInvalidNegativeInputs returns true if err is an instance of CurveInvalidNegativeInputs.
func IsCurveInvalidNegativeInputs(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CurveInvalidNegativeInputs)
	return ok
}

func (e *CurveInvalidNegativeInputs) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:CurveInvalidNegativeInputs (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CurveInvalidNegativeInputs) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CurveInvalidNegativeInputs) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CurveInvalidNegativeInputs) Message() string {
	return "INVALID_ARGUMENT Compute:CurveInvalidNegativeInputs"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CurveInvalidNegativeInputs) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CurveInvalidNegativeInputs) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CurveInvalidNegativeInputs) Name() string {
	return "Compute:CurveInvalidNegativeInputs"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CurveInvalidNegativeInputs) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CurveInvalidNegativeInputs) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CurveInvalidNegativeInputs) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CurveInvalidNegativeInputs) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CurveInvalidNegativeInputs) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CurveInvalidNegativeInputs) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CurveInvalidNegativeInputs) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.curveInvalidNegativeInputs)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:CurveInvalidNegativeInputs", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CurveInvalidNegativeInputs) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters curveInvalidNegativeInputs
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.curveInvalidNegativeInputs = parameters
	return nil
}

type curveUnequalInputLength struct{}

func (o curveUnequalInputLength) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *curveUnequalInputLength) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCurveUnequalInputLength returns new instance of CurveUnequalInputLength error.
func NewCurveUnequalInputLength() *CurveUnequalInputLength {
	return &CurveUnequalInputLength{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), curveUnequalInputLength: curveUnequalInputLength{}}
}

// WrapWithCurveUnequalInputLength returns new instance of CurveUnequalInputLength error wrapping an existing error.
func WrapWithCurveUnequalInputLength(err error) *CurveUnequalInputLength {
	return &CurveUnequalInputLength{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, curveUnequalInputLength: curveUnequalInputLength{}}
}

// CurveUnequalInputLength is an error type.
// The x and y inputs to fit a curve to do not have the same length.
type CurveUnequalInputLength struct {
	errorInstanceID uuid.UUID
	curveUnequalInputLength
	cause error
	stack werror.StackTrace
}

// IsCurveUnequalInputLength returns true if err is an instance of CurveUnequalInputLength.
func IsCurveUnequalInputLength(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CurveUnequalInputLength)
	return ok
}

func (e *CurveUnequalInputLength) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:CurveUnequalInputLength (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CurveUnequalInputLength) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CurveUnequalInputLength) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CurveUnequalInputLength) Message() string {
	return "INVALID_ARGUMENT Compute:CurveUnequalInputLength"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CurveUnequalInputLength) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CurveUnequalInputLength) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CurveUnequalInputLength) Name() string {
	return "Compute:CurveUnequalInputLength"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CurveUnequalInputLength) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CurveUnequalInputLength) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CurveUnequalInputLength) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CurveUnequalInputLength) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CurveUnequalInputLength) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CurveUnequalInputLength) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CurveUnequalInputLength) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.curveUnequalInputLength)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:CurveUnequalInputLength", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CurveUnequalInputLength) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters curveUnequalInputLength
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.curveUnequalInputLength = parameters
	return nil
}

type derivedSeriesHasWrongType struct {
	ExpectedType  string        `json:"expectedType"`
	DerivedSeries DerivedSeries `json:"derivedSeries"`
}

func (o derivedSeriesHasWrongType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *derivedSeriesHasWrongType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDerivedSeriesHasWrongType returns new instance of DerivedSeriesHasWrongType error.
func NewDerivedSeriesHasWrongType(expectedTypeArg string, derivedSeriesArg DerivedSeries) *DerivedSeriesHasWrongType {
	return &DerivedSeriesHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), derivedSeriesHasWrongType: derivedSeriesHasWrongType{ExpectedType: expectedTypeArg, DerivedSeries: derivedSeriesArg}}
}

// WrapWithDerivedSeriesHasWrongType returns new instance of DerivedSeriesHasWrongType error wrapping an existing error.
func WrapWithDerivedSeriesHasWrongType(err error, expectedTypeArg string, derivedSeriesArg DerivedSeries) *DerivedSeriesHasWrongType {
	return &DerivedSeriesHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, derivedSeriesHasWrongType: derivedSeriesHasWrongType{ExpectedType: expectedTypeArg, DerivedSeries: derivedSeriesArg}}
}

// DerivedSeriesHasWrongType is an error type.
type DerivedSeriesHasWrongType struct {
	errorInstanceID uuid.UUID
	derivedSeriesHasWrongType
	cause error
	stack werror.StackTrace
}

// IsDerivedSeriesHasWrongType returns true if err is an instance of DerivedSeriesHasWrongType.
func IsDerivedSeriesHasWrongType(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DerivedSeriesHasWrongType)
	return ok
}

func (e *DerivedSeriesHasWrongType) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:DerivedSeriesHasWrongType (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DerivedSeriesHasWrongType) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DerivedSeriesHasWrongType) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DerivedSeriesHasWrongType) Message() string {
	return "INVALID_ARGUMENT Compute:DerivedSeriesHasWrongType"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DerivedSeriesHasWrongType) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DerivedSeriesHasWrongType) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *DerivedSeriesHasWrongType) Name() string {
	return "Compute:DerivedSeriesHasWrongType"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DerivedSeriesHasWrongType) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DerivedSeriesHasWrongType) Parameters() map[string]interface{} {
	return map[string]interface{}{"expectedType": e.ExpectedType, "derivedSeries": e.DerivedSeries}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DerivedSeriesHasWrongType) safeParams() map[string]interface{} {
	return map[string]interface{}{"expectedType": e.ExpectedType, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DerivedSeriesHasWrongType) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DerivedSeriesHasWrongType) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"derivedSeries": e.DerivedSeries}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DerivedSeriesHasWrongType) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DerivedSeriesHasWrongType) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.derivedSeriesHasWrongType)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:DerivedSeriesHasWrongType", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DerivedSeriesHasWrongType) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters derivedSeriesHasWrongType
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.derivedSeriesHasWrongType = parameters
	return nil
}

type duplicateTimestamp struct {
	Timestamp api2.Timestamp `json:"timestamp"`
}

func (o duplicateTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *duplicateTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDuplicateTimestamp returns new instance of DuplicateTimestamp error.
func NewDuplicateTimestamp(timestampArg api2.Timestamp) *DuplicateTimestamp {
	return &DuplicateTimestamp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), duplicateTimestamp: duplicateTimestamp{Timestamp: timestampArg}}
}

// WrapWithDuplicateTimestamp returns new instance of DuplicateTimestamp error wrapping an existing error.
func WrapWithDuplicateTimestamp(err error, timestampArg api2.Timestamp) *DuplicateTimestamp {
	return &DuplicateTimestamp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, duplicateTimestamp: duplicateTimestamp{Timestamp: timestampArg}}
}

// DuplicateTimestamp is an error type.
type DuplicateTimestamp struct {
	errorInstanceID uuid.UUID
	duplicateTimestamp
	cause error
	stack werror.StackTrace
}

// IsDuplicateTimestamp returns true if err is an instance of DuplicateTimestamp.
func IsDuplicateTimestamp(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DuplicateTimestamp)
	return ok
}

func (e *DuplicateTimestamp) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:DuplicateTimestamp (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DuplicateTimestamp) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DuplicateTimestamp) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DuplicateTimestamp) Message() string {
	return "INVALID_ARGUMENT Compute:DuplicateTimestamp"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DuplicateTimestamp) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DuplicateTimestamp) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *DuplicateTimestamp) Name() string {
	return "Compute:DuplicateTimestamp"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DuplicateTimestamp) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DuplicateTimestamp) Parameters() map[string]interface{} {
	return map[string]interface{}{"timestamp": e.Timestamp}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DuplicateTimestamp) safeParams() map[string]interface{} {
	return map[string]interface{}{"timestamp": e.Timestamp, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DuplicateTimestamp) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DuplicateTimestamp) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DuplicateTimestamp) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DuplicateTimestamp) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.duplicateTimestamp)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:DuplicateTimestamp", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DuplicateTimestamp) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters duplicateTimestamp
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.duplicateTimestamp = parameters
	return nil
}

type exponentialCurveInputTooLarge struct{}

func (o exponentialCurveInputTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *exponentialCurveInputTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewExponentialCurveInputTooLarge returns new instance of ExponentialCurveInputTooLarge error.
func NewExponentialCurveInputTooLarge() *ExponentialCurveInputTooLarge {
	return &ExponentialCurveInputTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), exponentialCurveInputTooLarge: exponentialCurveInputTooLarge{}}
}

// WrapWithExponentialCurveInputTooLarge returns new instance of ExponentialCurveInputTooLarge error wrapping an existing error.
func WrapWithExponentialCurveInputTooLarge(err error) *ExponentialCurveInputTooLarge {
	return &ExponentialCurveInputTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, exponentialCurveInputTooLarge: exponentialCurveInputTooLarge{}}
}

// ExponentialCurveInputTooLarge is an error type.
/*
Due to limits in how numbers are represented by computers, exponential fits cannot be performed
on data with x-values that are too large (> 650). This includes timestamp data based on the Time Unit
parameter to the curve fit - e.g. 1 second at millisecond scale is too large, as it is 1000 milliseconds.
*/
type ExponentialCurveInputTooLarge struct {
	errorInstanceID uuid.UUID
	exponentialCurveInputTooLarge
	cause error
	stack werror.StackTrace
}

// IsExponentialCurveInputTooLarge returns true if err is an instance of ExponentialCurveInputTooLarge.
func IsExponentialCurveInputTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ExponentialCurveInputTooLarge)
	return ok
}

func (e *ExponentialCurveInputTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:ExponentialCurveInputTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ExponentialCurveInputTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ExponentialCurveInputTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ExponentialCurveInputTooLarge) Message() string {
	return "INVALID_ARGUMENT Compute:ExponentialCurveInputTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ExponentialCurveInputTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ExponentialCurveInputTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ExponentialCurveInputTooLarge) Name() string {
	return "Compute:ExponentialCurveInputTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ExponentialCurveInputTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ExponentialCurveInputTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ExponentialCurveInputTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExponentialCurveInputTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ExponentialCurveInputTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExponentialCurveInputTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ExponentialCurveInputTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.exponentialCurveInputTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:ExponentialCurveInputTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ExponentialCurveInputTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters exponentialCurveInputTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.exponentialCurveInputTooLarge = parameters
	return nil
}

type externalDatabaseBadGateway struct {
	Type string `json:"type"`
}

func (o externalDatabaseBadGateway) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *externalDatabaseBadGateway) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewExternalDatabaseBadGateway returns new instance of ExternalDatabaseBadGateway error.
func NewExternalDatabaseBadGateway(typeArg string) *ExternalDatabaseBadGateway {
	return &ExternalDatabaseBadGateway{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), externalDatabaseBadGateway: externalDatabaseBadGateway{Type: typeArg}}
}

// WrapWithExternalDatabaseBadGateway returns new instance of ExternalDatabaseBadGateway error wrapping an existing error.
func WrapWithExternalDatabaseBadGateway(err error, typeArg string) *ExternalDatabaseBadGateway {
	return &ExternalDatabaseBadGateway{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, externalDatabaseBadGateway: externalDatabaseBadGateway{Type: typeArg}}
}

// ExternalDatabaseBadGateway is an error type.
// A bad gateway result was encountered while trying to fetch data from the external database.
type ExternalDatabaseBadGateway struct {
	errorInstanceID uuid.UUID
	externalDatabaseBadGateway
	cause error
	stack werror.StackTrace
}

// IsExternalDatabaseBadGateway returns true if err is an instance of ExternalDatabaseBadGateway.
func IsExternalDatabaseBadGateway(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ExternalDatabaseBadGateway)
	return ok
}

func (e *ExternalDatabaseBadGateway) Error() string {
	return fmt.Sprintf("CUSTOM_SERVER ExternalDatabase:ExternalDatabaseBadGateway (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ExternalDatabaseBadGateway) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ExternalDatabaseBadGateway) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ExternalDatabaseBadGateway) Message() string {
	return "CUSTOM_SERVER ExternalDatabase:ExternalDatabaseBadGateway"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ExternalDatabaseBadGateway) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ExternalDatabaseBadGateway) Code() errors.ErrorCode {
	return errors.CustomServer
}

// Name returns an error name identifying error type.
func (e *ExternalDatabaseBadGateway) Name() string {
	return "ExternalDatabase:ExternalDatabaseBadGateway"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ExternalDatabaseBadGateway) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ExternalDatabaseBadGateway) Parameters() map[string]interface{} {
	return map[string]interface{}{"type": e.Type}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ExternalDatabaseBadGateway) safeParams() map[string]interface{} {
	return map[string]interface{}{"type": e.Type, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExternalDatabaseBadGateway) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ExternalDatabaseBadGateway) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExternalDatabaseBadGateway) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ExternalDatabaseBadGateway) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.externalDatabaseBadGateway)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.CustomServer, ErrorName: "ExternalDatabase:ExternalDatabaseBadGateway", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ExternalDatabaseBadGateway) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters externalDatabaseBadGateway
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.externalDatabaseBadGateway = parameters
	return nil
}

type externalDatabaseGatewayTimeout struct {
	Type string `json:"type"`
}

func (o externalDatabaseGatewayTimeout) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *externalDatabaseGatewayTimeout) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewExternalDatabaseGatewayTimeout returns new instance of ExternalDatabaseGatewayTimeout error.
func NewExternalDatabaseGatewayTimeout(typeArg string) *ExternalDatabaseGatewayTimeout {
	return &ExternalDatabaseGatewayTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), externalDatabaseGatewayTimeout: externalDatabaseGatewayTimeout{Type: typeArg}}
}

// WrapWithExternalDatabaseGatewayTimeout returns new instance of ExternalDatabaseGatewayTimeout error wrapping an existing error.
func WrapWithExternalDatabaseGatewayTimeout(err error, typeArg string) *ExternalDatabaseGatewayTimeout {
	return &ExternalDatabaseGatewayTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, externalDatabaseGatewayTimeout: externalDatabaseGatewayTimeout{Type: typeArg}}
}

// ExternalDatabaseGatewayTimeout is an error type.
// A gateway timeout was encountered while trying to fetch data from the external database.
type ExternalDatabaseGatewayTimeout struct {
	errorInstanceID uuid.UUID
	externalDatabaseGatewayTimeout
	cause error
	stack werror.StackTrace
}

// IsExternalDatabaseGatewayTimeout returns true if err is an instance of ExternalDatabaseGatewayTimeout.
func IsExternalDatabaseGatewayTimeout(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ExternalDatabaseGatewayTimeout)
	return ok
}

func (e *ExternalDatabaseGatewayTimeout) Error() string {
	return fmt.Sprintf("CUSTOM_SERVER ExternalDatabase:ExternalDatabaseGatewayTimeout (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ExternalDatabaseGatewayTimeout) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ExternalDatabaseGatewayTimeout) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ExternalDatabaseGatewayTimeout) Message() string {
	return "CUSTOM_SERVER ExternalDatabase:ExternalDatabaseGatewayTimeout"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ExternalDatabaseGatewayTimeout) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ExternalDatabaseGatewayTimeout) Code() errors.ErrorCode {
	return errors.CustomServer
}

// Name returns an error name identifying error type.
func (e *ExternalDatabaseGatewayTimeout) Name() string {
	return "ExternalDatabase:ExternalDatabaseGatewayTimeout"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ExternalDatabaseGatewayTimeout) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ExternalDatabaseGatewayTimeout) Parameters() map[string]interface{} {
	return map[string]interface{}{"type": e.Type}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ExternalDatabaseGatewayTimeout) safeParams() map[string]interface{} {
	return map[string]interface{}{"type": e.Type, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExternalDatabaseGatewayTimeout) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ExternalDatabaseGatewayTimeout) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExternalDatabaseGatewayTimeout) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ExternalDatabaseGatewayTimeout) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.externalDatabaseGatewayTimeout)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.CustomServer, ErrorName: "ExternalDatabase:ExternalDatabaseGatewayTimeout", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ExternalDatabaseGatewayTimeout) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters externalDatabaseGatewayTimeout
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.externalDatabaseGatewayTimeout = parameters
	return nil
}

type fftWindowEmpty struct{}

func (o fftWindowEmpty) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *fftWindowEmpty) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewFftWindowEmpty returns new instance of FftWindowEmpty error.
func NewFftWindowEmpty() *FftWindowEmpty {
	return &FftWindowEmpty{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), fftWindowEmpty: fftWindowEmpty{}}
}

// WrapWithFftWindowEmpty returns new instance of FftWindowEmpty error wrapping an existing error.
func WrapWithFftWindowEmpty(err error) *FftWindowEmpty {
	return &FftWindowEmpty{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, fftWindowEmpty: fftWindowEmpty{}}
}

// FftWindowEmpty is an error type.
// The selected window for the FFT is empty. Try again with a larger time range.
type FftWindowEmpty struct {
	errorInstanceID uuid.UUID
	fftWindowEmpty
	cause error
	stack werror.StackTrace
}

// IsFftWindowEmpty returns true if err is an instance of FftWindowEmpty.
func IsFftWindowEmpty(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*FftWindowEmpty)
	return ok
}

func (e *FftWindowEmpty) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:FftWindowEmpty (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *FftWindowEmpty) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *FftWindowEmpty) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *FftWindowEmpty) Message() string {
	return "INVALID_ARGUMENT Compute:FftWindowEmpty"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *FftWindowEmpty) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *FftWindowEmpty) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *FftWindowEmpty) Name() string {
	return "Compute:FftWindowEmpty"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *FftWindowEmpty) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *FftWindowEmpty) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *FftWindowEmpty) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *FftWindowEmpty) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *FftWindowEmpty) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *FftWindowEmpty) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e FftWindowEmpty) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.fftWindowEmpty)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:FftWindowEmpty", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *FftWindowEmpty) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters fftWindowEmpty
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.fftWindowEmpty = parameters
	return nil
}

type fftWindowTooLarge struct{}

func (o fftWindowTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *fftWindowTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewFftWindowTooLarge returns new instance of FftWindowTooLarge error.
func NewFftWindowTooLarge() *FftWindowTooLarge {
	return &FftWindowTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), fftWindowTooLarge: fftWindowTooLarge{}}
}

// WrapWithFftWindowTooLarge returns new instance of FftWindowTooLarge error wrapping an existing error.
func WrapWithFftWindowTooLarge(err error) *FftWindowTooLarge {
	return &FftWindowTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, fftWindowTooLarge: fftWindowTooLarge{}}
}

// FftWindowTooLarge is an error type.
// The selected window for the FFT is too large. Try again with a smaller time range.
type FftWindowTooLarge struct {
	errorInstanceID uuid.UUID
	fftWindowTooLarge
	cause error
	stack werror.StackTrace
}

// IsFftWindowTooLarge returns true if err is an instance of FftWindowTooLarge.
func IsFftWindowTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*FftWindowTooLarge)
	return ok
}

func (e *FftWindowTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:FftWindowTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *FftWindowTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *FftWindowTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *FftWindowTooLarge) Message() string {
	return "INVALID_ARGUMENT Compute:FftWindowTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *FftWindowTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *FftWindowTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *FftWindowTooLarge) Name() string {
	return "Compute:FftWindowTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *FftWindowTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *FftWindowTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *FftWindowTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *FftWindowTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *FftWindowTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *FftWindowTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e FftWindowTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.fftWindowTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:FftWindowTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *FftWindowTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters fftWindowTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.fftWindowTooLarge = parameters
	return nil
}

type granularityMismatch struct{}

func (o granularityMismatch) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *granularityMismatch) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewGranularityMismatch returns new instance of GranularityMismatch error.
func NewGranularityMismatch() *GranularityMismatch {
	return &GranularityMismatch{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), granularityMismatch: granularityMismatch{}}
}

// WrapWithGranularityMismatch returns new instance of GranularityMismatch error wrapping an existing error.
func WrapWithGranularityMismatch(err error) *GranularityMismatch {
	return &GranularityMismatch{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, granularityMismatch: granularityMismatch{}}
}

// GranularityMismatch is an error type.
// Some operations that require matching granularity did not have matching granularity.
type GranularityMismatch struct {
	errorInstanceID uuid.UUID
	granularityMismatch
	cause error
	stack werror.StackTrace
}

// IsGranularityMismatch returns true if err is an instance of GranularityMismatch.
func IsGranularityMismatch(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*GranularityMismatch)
	return ok
}

func (e *GranularityMismatch) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:GranularityMismatch (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *GranularityMismatch) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *GranularityMismatch) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *GranularityMismatch) Message() string {
	return "INVALID_ARGUMENT Compute:GranularityMismatch"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *GranularityMismatch) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *GranularityMismatch) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *GranularityMismatch) Name() string {
	return "Compute:GranularityMismatch"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *GranularityMismatch) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *GranularityMismatch) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *GranularityMismatch) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *GranularityMismatch) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *GranularityMismatch) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *GranularityMismatch) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e GranularityMismatch) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.granularityMismatch)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:GranularityMismatch", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *GranularityMismatch) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters granularityMismatch
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.granularityMismatch = parameters
	return nil
}

type groupByTagsNotSubset struct {
	Group1 []string `json:"group1"`
	Group2 []string `json:"group2"`
}

func (o groupByTagsNotSubset) MarshalJSON() ([]byte, error) {
	if o.Group1 == nil {
		o.Group1 = make([]string, 0)
	}
	if o.Group2 == nil {
		o.Group2 = make([]string, 0)
	}
	type _tmpgroupByTagsNotSubset groupByTagsNotSubset
	return safejson.Marshal(_tmpgroupByTagsNotSubset(o))
}

func (o *groupByTagsNotSubset) UnmarshalJSON(data []byte) error {
	type _tmpgroupByTagsNotSubset groupByTagsNotSubset
	var rawgroupByTagsNotSubset _tmpgroupByTagsNotSubset
	if err := safejson.Unmarshal(data, &rawgroupByTagsNotSubset); err != nil {
		return err
	}
	if rawgroupByTagsNotSubset.Group1 == nil {
		rawgroupByTagsNotSubset.Group1 = make([]string, 0)
	}
	if rawgroupByTagsNotSubset.Group2 == nil {
		rawgroupByTagsNotSubset.Group2 = make([]string, 0)
	}
	*o = groupByTagsNotSubset(rawgroupByTagsNotSubset)
	return nil
}

func (o groupByTagsNotSubset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *groupByTagsNotSubset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewGroupByTagsNotSubset returns new instance of GroupByTagsNotSubset error.
func NewGroupByTagsNotSubset(group1Arg []string, group2Arg []string) *GroupByTagsNotSubset {
	return &GroupByTagsNotSubset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), groupByTagsNotSubset: groupByTagsNotSubset{Group1: group1Arg, Group2: group2Arg}}
}

// WrapWithGroupByTagsNotSubset returns new instance of GroupByTagsNotSubset error wrapping an existing error.
func WrapWithGroupByTagsNotSubset(err error, group1Arg []string, group2Arg []string) *GroupByTagsNotSubset {
	return &GroupByTagsNotSubset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, groupByTagsNotSubset: groupByTagsNotSubset{Group1: group1Arg, Group2: group2Arg}}
}

// GroupByTagsNotSubset is an error type.
// Group by tags must be equal, or one set must be a subset of the other.
type GroupByTagsNotSubset struct {
	errorInstanceID uuid.UUID
	groupByTagsNotSubset
	cause error
	stack werror.StackTrace
}

// IsGroupByTagsNotSubset returns true if err is an instance of GroupByTagsNotSubset.
func IsGroupByTagsNotSubset(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*GroupByTagsNotSubset)
	return ok
}

func (e *GroupByTagsNotSubset) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:GroupByTagsNotSubset (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *GroupByTagsNotSubset) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *GroupByTagsNotSubset) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *GroupByTagsNotSubset) Message() string {
	return "INVALID_ARGUMENT Compute:GroupByTagsNotSubset"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *GroupByTagsNotSubset) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *GroupByTagsNotSubset) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *GroupByTagsNotSubset) Name() string {
	return "Compute:GroupByTagsNotSubset"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *GroupByTagsNotSubset) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *GroupByTagsNotSubset) Parameters() map[string]interface{} {
	return map[string]interface{}{"group1": e.Group1, "group2": e.Group2}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *GroupByTagsNotSubset) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *GroupByTagsNotSubset) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *GroupByTagsNotSubset) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"group1": e.Group1, "group2": e.Group2}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *GroupByTagsNotSubset) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e GroupByTagsNotSubset) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.groupByTagsNotSubset)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:GroupByTagsNotSubset", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *GroupByTagsNotSubset) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters groupByTagsNotSubset
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.groupByTagsNotSubset = parameters
	return nil
}

type groupBysNotSupportedForQuery struct {
	ComputeNode string `json:"computeNode"`
}

func (o groupBysNotSupportedForQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *groupBysNotSupportedForQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewGroupBysNotSupportedForQuery returns new instance of GroupBysNotSupportedForQuery error.
func NewGroupBysNotSupportedForQuery(computeNodeArg string) *GroupBysNotSupportedForQuery {
	return &GroupBysNotSupportedForQuery{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), groupBysNotSupportedForQuery: groupBysNotSupportedForQuery{ComputeNode: computeNodeArg}}
}

// WrapWithGroupBysNotSupportedForQuery returns new instance of GroupBysNotSupportedForQuery error wrapping an existing error.
func WrapWithGroupBysNotSupportedForQuery(err error, computeNodeArg string) *GroupBysNotSupportedForQuery {
	return &GroupBysNotSupportedForQuery{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, groupBysNotSupportedForQuery: groupBysNotSupportedForQuery{ComputeNode: computeNodeArg}}
}

// GroupBysNotSupportedForQuery is an error type.
// Group by queries are not supported for the compute node supplied
type GroupBysNotSupportedForQuery struct {
	errorInstanceID uuid.UUID
	groupBysNotSupportedForQuery
	cause error
	stack werror.StackTrace
}

// IsGroupBysNotSupportedForQuery returns true if err is an instance of GroupBysNotSupportedForQuery.
func IsGroupBysNotSupportedForQuery(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*GroupBysNotSupportedForQuery)
	return ok
}

func (e *GroupBysNotSupportedForQuery) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:GroupBysNotSupportedForQuery (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *GroupBysNotSupportedForQuery) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *GroupBysNotSupportedForQuery) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *GroupBysNotSupportedForQuery) Message() string {
	return "INVALID_ARGUMENT Compute:GroupBysNotSupportedForQuery"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *GroupBysNotSupportedForQuery) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *GroupBysNotSupportedForQuery) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *GroupBysNotSupportedForQuery) Name() string {
	return "Compute:GroupBysNotSupportedForQuery"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *GroupBysNotSupportedForQuery) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *GroupBysNotSupportedForQuery) Parameters() map[string]interface{} {
	return map[string]interface{}{"computeNode": e.ComputeNode}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *GroupBysNotSupportedForQuery) safeParams() map[string]interface{} {
	return map[string]interface{}{"computeNode": e.ComputeNode, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *GroupBysNotSupportedForQuery) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *GroupBysNotSupportedForQuery) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *GroupBysNotSupportedForQuery) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e GroupBysNotSupportedForQuery) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.groupBysNotSupportedForQuery)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:GroupBysNotSupportedForQuery", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *GroupBysNotSupportedForQuery) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters groupBysNotSupportedForQuery
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.groupBysNotSupportedForQuery = parameters
	return nil
}

type invalidExpression struct {
	Expression string `json:"expression"`
}

func (o invalidExpression) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidExpression) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidExpression returns new instance of InvalidExpression error.
func NewInvalidExpression(expressionArg string) *InvalidExpression {
	return &InvalidExpression{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidExpression: invalidExpression{Expression: expressionArg}}
}

// WrapWithInvalidExpression returns new instance of InvalidExpression error wrapping an existing error.
func WrapWithInvalidExpression(err error, expressionArg string) *InvalidExpression {
	return &InvalidExpression{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidExpression: invalidExpression{Expression: expressionArg}}
}

// InvalidExpression is an error type.
type InvalidExpression struct {
	errorInstanceID uuid.UUID
	invalidExpression
	cause error
	stack werror.StackTrace
}

// IsInvalidExpression returns true if err is an instance of InvalidExpression.
func IsInvalidExpression(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidExpression)
	return ok
}

func (e *InvalidExpression) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidExpression (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidExpression) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidExpression) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidExpression) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidExpression"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidExpression) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidExpression) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidExpression) Name() string {
	return "Compute:InvalidExpression"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidExpression) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidExpression) Parameters() map[string]interface{} {
	return map[string]interface{}{"expression": e.Expression}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidExpression) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidExpression) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidExpression) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"expression": e.Expression}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidExpression) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidExpression) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidExpression)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidExpression", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidExpression) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidExpression
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidExpression = parameters
	return nil
}

type invalidLiteralRange struct {
	Start *api2.Timestamp `json:"start,omitempty"`
	End   *api2.Timestamp `json:"end,omitempty"`
}

func (o invalidLiteralRange) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidLiteralRange) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidLiteralRange returns new instance of InvalidLiteralRange error.
func NewInvalidLiteralRange(startArg *api2.Timestamp, endArg *api2.Timestamp) *InvalidLiteralRange {
	return &InvalidLiteralRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidLiteralRange: invalidLiteralRange{Start: startArg, End: endArg}}
}

// WrapWithInvalidLiteralRange returns new instance of InvalidLiteralRange error wrapping an existing error.
func WrapWithInvalidLiteralRange(err error, startArg *api2.Timestamp, endArg *api2.Timestamp) *InvalidLiteralRange {
	return &InvalidLiteralRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidLiteralRange: invalidLiteralRange{Start: startArg, End: endArg}}
}

// InvalidLiteralRange is an error type.
/*
The starting timestamp of a range cannot be greater than or equal to the end timestamp.
At least one of start and end timestamps must be present.
Only the first range when sorted may omit the start, and only the last may omit the end.
*/
type InvalidLiteralRange struct {
	errorInstanceID uuid.UUID
	invalidLiteralRange
	cause error
	stack werror.StackTrace
}

// IsInvalidLiteralRange returns true if err is an instance of InvalidLiteralRange.
func IsInvalidLiteralRange(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidLiteralRange)
	return ok
}

func (e *InvalidLiteralRange) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidLiteralRange (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidLiteralRange) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidLiteralRange) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidLiteralRange) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidLiteralRange"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidLiteralRange) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidLiteralRange) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidLiteralRange) Name() string {
	return "Compute:InvalidLiteralRange"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidLiteralRange) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidLiteralRange) Parameters() map[string]interface{} {
	return map[string]interface{}{"start": e.Start, "end": e.End}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidLiteralRange) safeParams() map[string]interface{} {
	return map[string]interface{}{"start": e.Start, "end": e.End, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidLiteralRange) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidLiteralRange) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidLiteralRange) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidLiteralRange) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidLiteralRange)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidLiteralRange", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidLiteralRange) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidLiteralRange
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidLiteralRange = parameters
	return nil
}

type invalidNumericOutputFields struct{}

func (o invalidNumericOutputFields) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidNumericOutputFields) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidNumericOutputFields returns new instance of InvalidNumericOutputFields error.
func NewInvalidNumericOutputFields() *InvalidNumericOutputFields {
	return &InvalidNumericOutputFields{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidNumericOutputFields: invalidNumericOutputFields{}}
}

// WrapWithInvalidNumericOutputFields returns new instance of InvalidNumericOutputFields error wrapping an existing error.
func WrapWithInvalidNumericOutputFields(err error) *InvalidNumericOutputFields {
	return &InvalidNumericOutputFields{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidNumericOutputFields: invalidNumericOutputFields{}}
}

// InvalidNumericOutputFields is an error type.
/*
Numeric output fields can only be specified on Arrow format numeric series requests.
At least one field must be specified.
*/
type InvalidNumericOutputFields struct {
	errorInstanceID uuid.UUID
	invalidNumericOutputFields
	cause error
	stack werror.StackTrace
}

// IsInvalidNumericOutputFields returns true if err is an instance of InvalidNumericOutputFields.
func IsInvalidNumericOutputFields(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidNumericOutputFields)
	return ok
}

func (e *InvalidNumericOutputFields) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidNumericOutputFields (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidNumericOutputFields) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidNumericOutputFields) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidNumericOutputFields) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidNumericOutputFields"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidNumericOutputFields) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidNumericOutputFields) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidNumericOutputFields) Name() string {
	return "Compute:InvalidNumericOutputFields"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidNumericOutputFields) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidNumericOutputFields) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidNumericOutputFields) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidNumericOutputFields) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidNumericOutputFields) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidNumericOutputFields) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidNumericOutputFields) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidNumericOutputFields)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidNumericOutputFields", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidNumericOutputFields) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidNumericOutputFields
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidNumericOutputFields = parameters
	return nil
}

type invalidPlotType struct {
	ExpectedType string `json:"expectedType"`
}

func (o invalidPlotType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidPlotType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidPlotType returns new instance of InvalidPlotType error.
func NewInvalidPlotType(expectedTypeArg string) *InvalidPlotType {
	return &InvalidPlotType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidPlotType: invalidPlotType{ExpectedType: expectedTypeArg}}
}

// WrapWithInvalidPlotType returns new instance of InvalidPlotType error wrapping an existing error.
func WrapWithInvalidPlotType(err error, expectedTypeArg string) *InvalidPlotType {
	return &InvalidPlotType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidPlotType: invalidPlotType{ExpectedType: expectedTypeArg}}
}

// InvalidPlotType is an error type.
type InvalidPlotType struct {
	errorInstanceID uuid.UUID
	invalidPlotType
	cause error
	stack werror.StackTrace
}

// IsInvalidPlotType returns true if err is an instance of InvalidPlotType.
func IsInvalidPlotType(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidPlotType)
	return ok
}

func (e *InvalidPlotType) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidPlotType (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidPlotType) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidPlotType) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidPlotType) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidPlotType"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidPlotType) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidPlotType) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidPlotType) Name() string {
	return "Compute:InvalidPlotType"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidPlotType) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidPlotType) Parameters() map[string]interface{} {
	return map[string]interface{}{"expectedType": e.ExpectedType}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidPlotType) safeParams() map[string]interface{} {
	return map[string]interface{}{"expectedType": e.ExpectedType, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidPlotType) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidPlotType) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidPlotType) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidPlotType) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidPlotType)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidPlotType", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidPlotType) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidPlotType
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidPlotType = parameters
	return nil
}

type invalidRangeNodeStartAfterViewRange struct {
	NodeStart api2.Timestamp `json:"nodeStart"`
	RangeEnd  api2.Timestamp `json:"rangeEnd"`
}

func (o invalidRangeNodeStartAfterViewRange) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidRangeNodeStartAfterViewRange) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidRangeNodeStartAfterViewRange returns new instance of InvalidRangeNodeStartAfterViewRange error.
func NewInvalidRangeNodeStartAfterViewRange(nodeStartArg api2.Timestamp, rangeEndArg api2.Timestamp) *InvalidRangeNodeStartAfterViewRange {
	return &InvalidRangeNodeStartAfterViewRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidRangeNodeStartAfterViewRange: invalidRangeNodeStartAfterViewRange{NodeStart: nodeStartArg, RangeEnd: rangeEndArg}}
}

// WrapWithInvalidRangeNodeStartAfterViewRange returns new instance of InvalidRangeNodeStartAfterViewRange error wrapping an existing error.
func WrapWithInvalidRangeNodeStartAfterViewRange(err error, nodeStartArg api2.Timestamp, rangeEndArg api2.Timestamp) *InvalidRangeNodeStartAfterViewRange {
	return &InvalidRangeNodeStartAfterViewRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidRangeNodeStartAfterViewRange: invalidRangeNodeStartAfterViewRange{NodeStart: nodeStartArg, RangeEnd: rangeEndArg}}
}

// InvalidRangeNodeStartAfterViewRange is an error type.
// The compute node was given a starting timestamp after the end of the view range window.
type InvalidRangeNodeStartAfterViewRange struct {
	errorInstanceID uuid.UUID
	invalidRangeNodeStartAfterViewRange
	cause error
	stack werror.StackTrace
}

// IsInvalidRangeNodeStartAfterViewRange returns true if err is an instance of InvalidRangeNodeStartAfterViewRange.
func IsInvalidRangeNodeStartAfterViewRange(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidRangeNodeStartAfterViewRange)
	return ok
}

func (e *InvalidRangeNodeStartAfterViewRange) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidRangeNodeStartAfterViewRange (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidRangeNodeStartAfterViewRange) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidRangeNodeStartAfterViewRange) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidRangeNodeStartAfterViewRange) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidRangeNodeStartAfterViewRange"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidRangeNodeStartAfterViewRange) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidRangeNodeStartAfterViewRange) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidRangeNodeStartAfterViewRange) Name() string {
	return "Compute:InvalidRangeNodeStartAfterViewRange"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidRangeNodeStartAfterViewRange) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidRangeNodeStartAfterViewRange) Parameters() map[string]interface{} {
	return map[string]interface{}{"nodeStart": e.NodeStart, "rangeEnd": e.RangeEnd}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidRangeNodeStartAfterViewRange) safeParams() map[string]interface{} {
	return map[string]interface{}{"nodeStart": e.NodeStart, "rangeEnd": e.RangeEnd, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidRangeNodeStartAfterViewRange) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidRangeNodeStartAfterViewRange) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidRangeNodeStartAfterViewRange) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidRangeNodeStartAfterViewRange) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidRangeNodeStartAfterViewRange)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidRangeNodeStartAfterViewRange", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidRangeNodeStartAfterViewRange) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidRangeNodeStartAfterViewRange
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidRangeNodeStartAfterViewRange = parameters
	return nil
}

type invalidSeriesLocator struct {
	SeriesRid api2.LogicalSeriesRid `json:"seriesRid"`
}

func (o invalidSeriesLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidSeriesLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidSeriesLocator returns new instance of InvalidSeriesLocator error.
func NewInvalidSeriesLocator(seriesRidArg api2.LogicalSeriesRid) *InvalidSeriesLocator {
	return &InvalidSeriesLocator{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidSeriesLocator: invalidSeriesLocator{SeriesRid: seriesRidArg}}
}

// WrapWithInvalidSeriesLocator returns new instance of InvalidSeriesLocator error wrapping an existing error.
func WrapWithInvalidSeriesLocator(err error, seriesRidArg api2.LogicalSeriesRid) *InvalidSeriesLocator {
	return &InvalidSeriesLocator{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidSeriesLocator: invalidSeriesLocator{SeriesRid: seriesRidArg}}
}

// InvalidSeriesLocator is an error type.
type InvalidSeriesLocator struct {
	errorInstanceID uuid.UUID
	invalidSeriesLocator
	cause error
	stack werror.StackTrace
}

// IsInvalidSeriesLocator returns true if err is an instance of InvalidSeriesLocator.
func IsInvalidSeriesLocator(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidSeriesLocator)
	return ok
}

func (e *InvalidSeriesLocator) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidSeriesLocator (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidSeriesLocator) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidSeriesLocator) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidSeriesLocator) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidSeriesLocator"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidSeriesLocator) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidSeriesLocator) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidSeriesLocator) Name() string {
	return "Compute:InvalidSeriesLocator"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidSeriesLocator) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidSeriesLocator) Parameters() map[string]interface{} {
	return map[string]interface{}{"seriesRid": e.SeriesRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidSeriesLocator) safeParams() map[string]interface{} {
	return map[string]interface{}{"seriesRid": e.SeriesRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidSeriesLocator) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidSeriesLocator) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidSeriesLocator) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidSeriesLocator) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidSeriesLocator)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidSeriesLocator", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidSeriesLocator) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidSeriesLocator
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidSeriesLocator = parameters
	return nil
}

type invalidTagFilterConfiguration struct {
	ErrorType TagFilterValidationErrorType `json:"errorType"`
	Message   string                       `json:"message"`
}

func (o invalidTagFilterConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidTagFilterConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidTagFilterConfiguration returns new instance of InvalidTagFilterConfiguration error.
func NewInvalidTagFilterConfiguration(errorTypeArg TagFilterValidationErrorType, messageArg string) *InvalidTagFilterConfiguration {
	return &InvalidTagFilterConfiguration{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidTagFilterConfiguration: invalidTagFilterConfiguration{ErrorType: errorTypeArg, Message: messageArg}}
}

// WrapWithInvalidTagFilterConfiguration returns new instance of InvalidTagFilterConfiguration error wrapping an existing error.
func WrapWithInvalidTagFilterConfiguration(err error, errorTypeArg TagFilterValidationErrorType, messageArg string) *InvalidTagFilterConfiguration {
	return &InvalidTagFilterConfiguration{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidTagFilterConfiguration: invalidTagFilterConfiguration{ErrorType: errorTypeArg, Message: messageArg}}
}

// InvalidTagFilterConfiguration is an error type.
// Invalid tag filter configuration was provided.
type InvalidTagFilterConfiguration struct {
	errorInstanceID uuid.UUID
	invalidTagFilterConfiguration
	cause error
	stack werror.StackTrace
}

// IsInvalidTagFilterConfiguration returns true if err is an instance of InvalidTagFilterConfiguration.
func IsInvalidTagFilterConfiguration(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidTagFilterConfiguration)
	return ok
}

func (e *InvalidTagFilterConfiguration) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidTagFilterConfiguration (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidTagFilterConfiguration) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidTagFilterConfiguration) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidTagFilterConfiguration) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidTagFilterConfiguration"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidTagFilterConfiguration) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidTagFilterConfiguration) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidTagFilterConfiguration) Name() string {
	return "Compute:InvalidTagFilterConfiguration"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidTagFilterConfiguration) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidTagFilterConfiguration) Parameters() map[string]interface{} {
	return map[string]interface{}{"errorType": e.ErrorType, "message": e.Message}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidTagFilterConfiguration) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorType": e.ErrorType, "message": e.Message, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTagFilterConfiguration) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidTagFilterConfiguration) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTagFilterConfiguration) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidTagFilterConfiguration) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidTagFilterConfiguration)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidTagFilterConfiguration", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidTagFilterConfiguration) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidTagFilterConfiguration
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidTagFilterConfiguration = parameters
	return nil
}

type invalidTimeUnit struct{}

func (o invalidTimeUnit) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidTimeUnit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidTimeUnit returns new instance of InvalidTimeUnit error.
func NewInvalidTimeUnit() *InvalidTimeUnit {
	return &InvalidTimeUnit{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidTimeUnit: invalidTimeUnit{}}
}

// WrapWithInvalidTimeUnit returns new instance of InvalidTimeUnit error wrapping an existing error.
func WrapWithInvalidTimeUnit(err error) *InvalidTimeUnit {
	return &InvalidTimeUnit{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidTimeUnit: invalidTimeUnit{}}
}

// InvalidTimeUnit is an error type.
// The time unit associated with the series is incompatible with the current transform.
type InvalidTimeUnit struct {
	errorInstanceID uuid.UUID
	invalidTimeUnit
	cause error
	stack werror.StackTrace
}

// IsInvalidTimeUnit returns true if err is an instance of InvalidTimeUnit.
func IsInvalidTimeUnit(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidTimeUnit)
	return ok
}

func (e *InvalidTimeUnit) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidTimeUnit (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidTimeUnit) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidTimeUnit) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidTimeUnit) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidTimeUnit"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidTimeUnit) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidTimeUnit) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidTimeUnit) Name() string {
	return "Compute:InvalidTimeUnit"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidTimeUnit) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidTimeUnit) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidTimeUnit) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTimeUnit) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidTimeUnit) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTimeUnit) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidTimeUnit) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidTimeUnit)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidTimeUnit", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidTimeUnit) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidTimeUnit
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidTimeUnit = parameters
	return nil
}

type invalidValueMap struct{}

func (o invalidValueMap) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidValueMap) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidValueMap returns new instance of InvalidValueMap error.
func NewInvalidValueMap() *InvalidValueMap {
	return &InvalidValueMap{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidValueMap: invalidValueMap{}}
}

// WrapWithInvalidValueMap returns new instance of InvalidValueMap error wrapping an existing error.
func WrapWithInvalidValueMap(err error) *InvalidValueMap {
	return &InvalidValueMap{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidValueMap: invalidValueMap{}}
}

// InvalidValueMap is an error type.
/*
Range end must be greater than range start. Range start may only be undefined if in the first range, or the prior end is defined and less.
Range end may only be undefined if in the last range, or the next start is defined and greater. Ranges must be in increasing order.
*/
type InvalidValueMap struct {
	errorInstanceID uuid.UUID
	invalidValueMap
	cause error
	stack werror.StackTrace
}

// IsInvalidValueMap returns true if err is an instance of InvalidValueMap.
func IsInvalidValueMap(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidValueMap)
	return ok
}

func (e *InvalidValueMap) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidValueMap (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidValueMap) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidValueMap) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidValueMap) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidValueMap"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidValueMap) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidValueMap) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidValueMap) Name() string {
	return "Compute:InvalidValueMap"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidValueMap) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidValueMap) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidValueMap) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidValueMap) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidValueMap) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidValueMap) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidValueMap) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidValueMap)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidValueMap", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidValueMap) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidValueMap
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidValueMap = parameters
	return nil
}

type maxQuerySizeExceeded struct {
	QueryId uuid.UUID `json:"queryId"`
}

func (o maxQuerySizeExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *maxQuerySizeExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMaxQuerySizeExceeded returns new instance of MaxQuerySizeExceeded error.
func NewMaxQuerySizeExceeded(queryIdArg uuid.UUID) *MaxQuerySizeExceeded {
	return &MaxQuerySizeExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), maxQuerySizeExceeded: maxQuerySizeExceeded{QueryId: queryIdArg}}
}

// WrapWithMaxQuerySizeExceeded returns new instance of MaxQuerySizeExceeded error wrapping an existing error.
func WrapWithMaxQuerySizeExceeded(err error, queryIdArg uuid.UUID) *MaxQuerySizeExceeded {
	return &MaxQuerySizeExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, maxQuerySizeExceeded: maxQuerySizeExceeded{QueryId: queryIdArg}}
}

// MaxQuerySizeExceeded is an error type.
// The maximum query size was exceeded.
type MaxQuerySizeExceeded struct {
	errorInstanceID uuid.UUID
	maxQuerySizeExceeded
	cause error
	stack werror.StackTrace
}

// IsMaxQuerySizeExceeded returns true if err is an instance of MaxQuerySizeExceeded.
func IsMaxQuerySizeExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MaxQuerySizeExceeded)
	return ok
}

func (e *MaxQuerySizeExceeded) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MaxQuerySizeExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MaxQuerySizeExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MaxQuerySizeExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MaxQuerySizeExceeded) Message() string {
	return "INVALID_ARGUMENT Compute:MaxQuerySizeExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MaxQuerySizeExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MaxQuerySizeExceeded) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MaxQuerySizeExceeded) Name() string {
	return "Compute:MaxQuerySizeExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MaxQuerySizeExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MaxQuerySizeExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MaxQuerySizeExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MaxQuerySizeExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MaxQuerySizeExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MaxQuerySizeExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MaxQuerySizeExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.maxQuerySizeExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MaxQuerySizeExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MaxQuerySizeExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters maxQuerySizeExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.maxQuerySizeExceeded = parameters
	return nil
}

type memoryLimitExceeded struct {
	QueryId uuid.UUID `json:"queryId"`
}

func (o memoryLimitExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *memoryLimitExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMemoryLimitExceeded returns new instance of MemoryLimitExceeded error.
func NewMemoryLimitExceeded(queryIdArg uuid.UUID) *MemoryLimitExceeded {
	return &MemoryLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), memoryLimitExceeded: memoryLimitExceeded{QueryId: queryIdArg}}
}

// WrapWithMemoryLimitExceeded returns new instance of MemoryLimitExceeded error wrapping an existing error.
func WrapWithMemoryLimitExceeded(err error, queryIdArg uuid.UUID) *MemoryLimitExceeded {
	return &MemoryLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, memoryLimitExceeded: memoryLimitExceeded{QueryId: queryIdArg}}
}

// MemoryLimitExceeded is an error type.
// The query exceeded the memory limit. Try querying a smaller time range or fewer series.
type MemoryLimitExceeded struct {
	errorInstanceID uuid.UUID
	memoryLimitExceeded
	cause error
	stack werror.StackTrace
}

// IsMemoryLimitExceeded returns true if err is an instance of MemoryLimitExceeded.
func IsMemoryLimitExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MemoryLimitExceeded)
	return ok
}

func (e *MemoryLimitExceeded) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MemoryLimitExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MemoryLimitExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MemoryLimitExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MemoryLimitExceeded) Message() string {
	return "INVALID_ARGUMENT Compute:MemoryLimitExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MemoryLimitExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MemoryLimitExceeded) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MemoryLimitExceeded) Name() string {
	return "Compute:MemoryLimitExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MemoryLimitExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MemoryLimitExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MemoryLimitExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MemoryLimitExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MemoryLimitExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MemoryLimitExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MemoryLimitExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.memoryLimitExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MemoryLimitExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MemoryLimitExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters memoryLimitExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.memoryLimitExceeded = parameters
	return nil
}

type missingFunctionInModuleApplication struct {
	ModuleApplicationRid api3.ModuleApplicationRid `json:"moduleApplicationRid"`
	FunctionName         string                    `json:"functionName"`
}

func (o missingFunctionInModuleApplication) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *missingFunctionInModuleApplication) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMissingFunctionInModuleApplication returns new instance of MissingFunctionInModuleApplication error.
func NewMissingFunctionInModuleApplication(moduleApplicationRidArg api3.ModuleApplicationRid, functionNameArg string) *MissingFunctionInModuleApplication {
	return &MissingFunctionInModuleApplication{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), missingFunctionInModuleApplication: missingFunctionInModuleApplication{ModuleApplicationRid: moduleApplicationRidArg, FunctionName: functionNameArg}}
}

// WrapWithMissingFunctionInModuleApplication returns new instance of MissingFunctionInModuleApplication error wrapping an existing error.
func WrapWithMissingFunctionInModuleApplication(err error, moduleApplicationRidArg api3.ModuleApplicationRid, functionNameArg string) *MissingFunctionInModuleApplication {
	return &MissingFunctionInModuleApplication{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, missingFunctionInModuleApplication: missingFunctionInModuleApplication{ModuleApplicationRid: moduleApplicationRidArg, FunctionName: functionNameArg}}
}

// MissingFunctionInModuleApplication is an error type.
type MissingFunctionInModuleApplication struct {
	errorInstanceID uuid.UUID
	missingFunctionInModuleApplication
	cause error
	stack werror.StackTrace
}

// IsMissingFunctionInModuleApplication returns true if err is an instance of MissingFunctionInModuleApplication.
func IsMissingFunctionInModuleApplication(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MissingFunctionInModuleApplication)
	return ok
}

func (e *MissingFunctionInModuleApplication) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MissingFunctionInModuleApplication (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MissingFunctionInModuleApplication) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MissingFunctionInModuleApplication) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MissingFunctionInModuleApplication) Message() string {
	return "INVALID_ARGUMENT Compute:MissingFunctionInModuleApplication"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MissingFunctionInModuleApplication) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MissingFunctionInModuleApplication) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MissingFunctionInModuleApplication) Name() string {
	return "Compute:MissingFunctionInModuleApplication"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MissingFunctionInModuleApplication) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MissingFunctionInModuleApplication) Parameters() map[string]interface{} {
	return map[string]interface{}{"moduleApplicationRid": e.ModuleApplicationRid, "functionName": e.FunctionName}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MissingFunctionInModuleApplication) safeParams() map[string]interface{} {
	return map[string]interface{}{"moduleApplicationRid": e.ModuleApplicationRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingFunctionInModuleApplication) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MissingFunctionInModuleApplication) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"functionName": e.FunctionName}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingFunctionInModuleApplication) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MissingFunctionInModuleApplication) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.missingFunctionInModuleApplication)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MissingFunctionInModuleApplication", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MissingFunctionInModuleApplication) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters missingFunctionInModuleApplication
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.missingFunctionInModuleApplication = parameters
	return nil
}

type missingModuleVariable struct {
	VariableName VariableName `json:"variableName"`
	Context      *Context     `json:"context,omitempty"`
}

func (o missingModuleVariable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *missingModuleVariable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMissingModuleVariable returns new instance of MissingModuleVariable error.
func NewMissingModuleVariable(variableNameArg VariableName, contextArg *Context) *MissingModuleVariable {
	return &MissingModuleVariable{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), missingModuleVariable: missingModuleVariable{VariableName: variableNameArg, Context: contextArg}}
}

// WrapWithMissingModuleVariable returns new instance of MissingModuleVariable error wrapping an existing error.
func WrapWithMissingModuleVariable(err error, variableNameArg VariableName, contextArg *Context) *MissingModuleVariable {
	return &MissingModuleVariable{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, missingModuleVariable: missingModuleVariable{VariableName: variableNameArg, Context: contextArg}}
}

// MissingModuleVariable is an error type.
type MissingModuleVariable struct {
	errorInstanceID uuid.UUID
	missingModuleVariable
	cause error
	stack werror.StackTrace
}

// IsMissingModuleVariable returns true if err is an instance of MissingModuleVariable.
func IsMissingModuleVariable(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MissingModuleVariable)
	return ok
}

func (e *MissingModuleVariable) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MissingModuleVariable (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MissingModuleVariable) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MissingModuleVariable) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MissingModuleVariable) Message() string {
	return "INVALID_ARGUMENT Compute:MissingModuleVariable"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MissingModuleVariable) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MissingModuleVariable) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MissingModuleVariable) Name() string {
	return "Compute:MissingModuleVariable"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MissingModuleVariable) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MissingModuleVariable) Parameters() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "context": e.Context}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MissingModuleVariable) safeParams() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingModuleVariable) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MissingModuleVariable) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"context": e.Context}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingModuleVariable) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MissingModuleVariable) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.missingModuleVariable)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MissingModuleVariable", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MissingModuleVariable) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters missingModuleVariable
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.missingModuleVariable = parameters
	return nil
}

type missingVariable struct {
	VariableName VariableName `json:"variableName"`
	Context      *Context     `json:"context,omitempty"`
}

func (o missingVariable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *missingVariable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMissingVariable returns new instance of MissingVariable error.
func NewMissingVariable(variableNameArg VariableName, contextArg *Context) *MissingVariable {
	return &MissingVariable{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), missingVariable: missingVariable{VariableName: variableNameArg, Context: contextArg}}
}

// WrapWithMissingVariable returns new instance of MissingVariable error wrapping an existing error.
func WrapWithMissingVariable(err error, variableNameArg VariableName, contextArg *Context) *MissingVariable {
	return &MissingVariable{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, missingVariable: missingVariable{VariableName: variableNameArg, Context: contextArg}}
}

// MissingVariable is an error type.
type MissingVariable struct {
	errorInstanceID uuid.UUID
	missingVariable
	cause error
	stack werror.StackTrace
}

// IsMissingVariable returns true if err is an instance of MissingVariable.
func IsMissingVariable(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MissingVariable)
	return ok
}

func (e *MissingVariable) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MissingVariable (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MissingVariable) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MissingVariable) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MissingVariable) Message() string {
	return "INVALID_ARGUMENT Compute:MissingVariable"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MissingVariable) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MissingVariable) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MissingVariable) Name() string {
	return "Compute:MissingVariable"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MissingVariable) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MissingVariable) Parameters() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "context": e.Context}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MissingVariable) safeParams() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingVariable) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MissingVariable) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"context": e.Context}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingVariable) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MissingVariable) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.missingVariable)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MissingVariable", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MissingVariable) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters missingVariable
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.missingVariable = parameters
	return nil
}

type nonPositiveDuration struct {
	Duration api4.Duration `json:"duration"`
}

func (o nonPositiveDuration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *nonPositiveDuration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNonPositiveDuration returns new instance of NonPositiveDuration error.
func NewNonPositiveDuration(durationArg api4.Duration) *NonPositiveDuration {
	return &NonPositiveDuration{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), nonPositiveDuration: nonPositiveDuration{Duration: durationArg}}
}

// WrapWithNonPositiveDuration returns new instance of NonPositiveDuration error wrapping an existing error.
func WrapWithNonPositiveDuration(err error, durationArg api4.Duration) *NonPositiveDuration {
	return &NonPositiveDuration{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, nonPositiveDuration: nonPositiveDuration{Duration: durationArg}}
}

// NonPositiveDuration is an error type.
// Duration must be strictly positive.
type NonPositiveDuration struct {
	errorInstanceID uuid.UUID
	nonPositiveDuration
	cause error
	stack werror.StackTrace
}

// IsNonPositiveDuration returns true if err is an instance of NonPositiveDuration.
func IsNonPositiveDuration(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NonPositiveDuration)
	return ok
}

func (e *NonPositiveDuration) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:NonPositiveDuration (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NonPositiveDuration) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NonPositiveDuration) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NonPositiveDuration) Message() string {
	return "INVALID_ARGUMENT Compute:NonPositiveDuration"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NonPositiveDuration) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NonPositiveDuration) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *NonPositiveDuration) Name() string {
	return "Compute:NonPositiveDuration"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NonPositiveDuration) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NonPositiveDuration) Parameters() map[string]interface{} {
	return map[string]interface{}{"duration": e.Duration}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NonPositiveDuration) safeParams() map[string]interface{} {
	return map[string]interface{}{"duration": e.Duration, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NonPositiveDuration) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NonPositiveDuration) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NonPositiveDuration) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NonPositiveDuration) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.nonPositiveDuration)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:NonPositiveDuration", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NonPositiveDuration) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters nonPositiveDuration
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.nonPositiveDuration = parameters
	return nil
}

type nonPositiveResampleInterval struct {
	ResampleInterval api4.Duration `json:"resampleInterval"`
}

func (o nonPositiveResampleInterval) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *nonPositiveResampleInterval) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNonPositiveResampleInterval returns new instance of NonPositiveResampleInterval error.
func NewNonPositiveResampleInterval(resampleIntervalArg api4.Duration) *NonPositiveResampleInterval {
	return &NonPositiveResampleInterval{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), nonPositiveResampleInterval: nonPositiveResampleInterval{ResampleInterval: resampleIntervalArg}}
}

// WrapWithNonPositiveResampleInterval returns new instance of NonPositiveResampleInterval error wrapping an existing error.
func WrapWithNonPositiveResampleInterval(err error, resampleIntervalArg api4.Duration) *NonPositiveResampleInterval {
	return &NonPositiveResampleInterval{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, nonPositiveResampleInterval: nonPositiveResampleInterval{ResampleInterval: resampleIntervalArg}}
}

// NonPositiveResampleInterval is an error type.
// The resample interval must be strictly positive.
type NonPositiveResampleInterval struct {
	errorInstanceID uuid.UUID
	nonPositiveResampleInterval
	cause error
	stack werror.StackTrace
}

// IsNonPositiveResampleInterval returns true if err is an instance of NonPositiveResampleInterval.
func IsNonPositiveResampleInterval(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NonPositiveResampleInterval)
	return ok
}

func (e *NonPositiveResampleInterval) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:NonPositiveResampleInterval (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NonPositiveResampleInterval) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NonPositiveResampleInterval) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NonPositiveResampleInterval) Message() string {
	return "INVALID_ARGUMENT Compute:NonPositiveResampleInterval"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NonPositiveResampleInterval) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NonPositiveResampleInterval) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *NonPositiveResampleInterval) Name() string {
	return "Compute:NonPositiveResampleInterval"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NonPositiveResampleInterval) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NonPositiveResampleInterval) Parameters() map[string]interface{} {
	return map[string]interface{}{"resampleInterval": e.ResampleInterval}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NonPositiveResampleInterval) safeParams() map[string]interface{} {
	return map[string]interface{}{"resampleInterval": e.ResampleInterval, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NonPositiveResampleInterval) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NonPositiveResampleInterval) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NonPositiveResampleInterval) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NonPositiveResampleInterval) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.nonPositiveResampleInterval)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:NonPositiveResampleInterval", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NonPositiveResampleInterval) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters nonPositiveResampleInterval
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.nonPositiveResampleInterval = parameters
	return nil
}

type notAuthorized struct {
	DataSourceRids []rids.DataSourceRid `json:"dataSourceRids"`
}

func (o notAuthorized) MarshalJSON() ([]byte, error) {
	if o.DataSourceRids == nil {
		o.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	type _tmpnotAuthorized notAuthorized
	return safejson.Marshal(_tmpnotAuthorized(o))
}

func (o *notAuthorized) UnmarshalJSON(data []byte) error {
	type _tmpnotAuthorized notAuthorized
	var rawnotAuthorized _tmpnotAuthorized
	if err := safejson.Unmarshal(data, &rawnotAuthorized); err != nil {
		return err
	}
	if rawnotAuthorized.DataSourceRids == nil {
		rawnotAuthorized.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	*o = notAuthorized(rawnotAuthorized)
	return nil
}

func (o notAuthorized) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *notAuthorized) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNotAuthorized returns new instance of NotAuthorized error.
func NewNotAuthorized(dataSourceRidsArg []rids.DataSourceRid) *NotAuthorized {
	return &NotAuthorized{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), notAuthorized: notAuthorized{DataSourceRids: dataSourceRidsArg}}
}

// WrapWithNotAuthorized returns new instance of NotAuthorized error wrapping an existing error.
func WrapWithNotAuthorized(err error, dataSourceRidsArg []rids.DataSourceRid) *NotAuthorized {
	return &NotAuthorized{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, notAuthorized: notAuthorized{DataSourceRids: dataSourceRidsArg}}
}

// NotAuthorized is an error type.
type NotAuthorized struct {
	errorInstanceID uuid.UUID
	notAuthorized
	cause error
	stack werror.StackTrace
}

// IsNotAuthorized returns true if err is an instance of NotAuthorized.
func IsNotAuthorized(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NotAuthorized)
	return ok
}

func (e *NotAuthorized) Error() string {
	return fmt.Sprintf("PERMISSION_DENIED Compute:NotAuthorized (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NotAuthorized) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NotAuthorized) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NotAuthorized) Message() string {
	return "PERMISSION_DENIED Compute:NotAuthorized"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NotAuthorized) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NotAuthorized) Code() errors.ErrorCode {
	return errors.PermissionDenied
}

// Name returns an error name identifying error type.
func (e *NotAuthorized) Name() string {
	return "Compute:NotAuthorized"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NotAuthorized) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NotAuthorized) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NotAuthorized) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NotAuthorized) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NotAuthorized) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NotAuthorized) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NotAuthorized) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.notAuthorized)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.PermissionDenied, ErrorName: "Compute:NotAuthorized", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NotAuthorized) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters notAuthorized
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.notAuthorized = parameters
	return nil
}

type notEnoughPointsForCurve struct{}

func (o notEnoughPointsForCurve) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *notEnoughPointsForCurve) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNotEnoughPointsForCurve returns new instance of NotEnoughPointsForCurve error.
func NewNotEnoughPointsForCurve() *NotEnoughPointsForCurve {
	return &NotEnoughPointsForCurve{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), notEnoughPointsForCurve: notEnoughPointsForCurve{}}
}

// WrapWithNotEnoughPointsForCurve returns new instance of NotEnoughPointsForCurve error wrapping an existing error.
func WrapWithNotEnoughPointsForCurve(err error) *NotEnoughPointsForCurve {
	return &NotEnoughPointsForCurve{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, notEnoughPointsForCurve: notEnoughPointsForCurve{}}
}

// NotEnoughPointsForCurve is an error type.
// There were not enough points to fit the curve requested.
type NotEnoughPointsForCurve struct {
	errorInstanceID uuid.UUID
	notEnoughPointsForCurve
	cause error
	stack werror.StackTrace
}

// IsNotEnoughPointsForCurve returns true if err is an instance of NotEnoughPointsForCurve.
func IsNotEnoughPointsForCurve(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NotEnoughPointsForCurve)
	return ok
}

func (e *NotEnoughPointsForCurve) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:NotEnoughPointsForCurve (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NotEnoughPointsForCurve) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NotEnoughPointsForCurve) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NotEnoughPointsForCurve) Message() string {
	return "INVALID_ARGUMENT Compute:NotEnoughPointsForCurve"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NotEnoughPointsForCurve) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NotEnoughPointsForCurve) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *NotEnoughPointsForCurve) Name() string {
	return "Compute:NotEnoughPointsForCurve"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NotEnoughPointsForCurve) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NotEnoughPointsForCurve) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NotEnoughPointsForCurve) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NotEnoughPointsForCurve) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NotEnoughPointsForCurve) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NotEnoughPointsForCurve) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NotEnoughPointsForCurve) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.notEnoughPointsForCurve)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:NotEnoughPointsForCurve", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NotEnoughPointsForCurve) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters notEnoughPointsForCurve
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.notEnoughPointsForCurve = parameters
	return nil
}

type overlappingLiteralRanges struct{}

func (o overlappingLiteralRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *overlappingLiteralRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewOverlappingLiteralRanges returns new instance of OverlappingLiteralRanges error.
func NewOverlappingLiteralRanges() *OverlappingLiteralRanges {
	return &OverlappingLiteralRanges{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), overlappingLiteralRanges: overlappingLiteralRanges{}}
}

// WrapWithOverlappingLiteralRanges returns new instance of OverlappingLiteralRanges error wrapping an existing error.
func WrapWithOverlappingLiteralRanges(err error) *OverlappingLiteralRanges {
	return &OverlappingLiteralRanges{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, overlappingLiteralRanges: overlappingLiteralRanges{}}
}

// OverlappingLiteralRanges is an error type.
/*
Ranges cannot overlap. Only the first range when sorted may omit the start,
and only the last may omit the end.
*/
type OverlappingLiteralRanges struct {
	errorInstanceID uuid.UUID
	overlappingLiteralRanges
	cause error
	stack werror.StackTrace
}

// IsOverlappingLiteralRanges returns true if err is an instance of OverlappingLiteralRanges.
func IsOverlappingLiteralRanges(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*OverlappingLiteralRanges)
	return ok
}

func (e *OverlappingLiteralRanges) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:OverlappingLiteralRanges (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *OverlappingLiteralRanges) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *OverlappingLiteralRanges) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *OverlappingLiteralRanges) Message() string {
	return "INVALID_ARGUMENT Compute:OverlappingLiteralRanges"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *OverlappingLiteralRanges) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *OverlappingLiteralRanges) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *OverlappingLiteralRanges) Name() string {
	return "Compute:OverlappingLiteralRanges"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *OverlappingLiteralRanges) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *OverlappingLiteralRanges) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *OverlappingLiteralRanges) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *OverlappingLiteralRanges) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *OverlappingLiteralRanges) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *OverlappingLiteralRanges) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e OverlappingLiteralRanges) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.overlappingLiteralRanges)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:OverlappingLiteralRanges", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *OverlappingLiteralRanges) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters overlappingLiteralRanges
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.overlappingLiteralRanges = parameters
	return nil
}

type picosRangeTooLarge struct{}

func (o picosRangeTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *picosRangeTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewPicosRangeTooLarge returns new instance of PicosRangeTooLarge error.
func NewPicosRangeTooLarge() *PicosRangeTooLarge {
	return &PicosRangeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), picosRangeTooLarge: picosRangeTooLarge{}}
}

// WrapWithPicosRangeTooLarge returns new instance of PicosRangeTooLarge error wrapping an existing error.
func WrapWithPicosRangeTooLarge(err error) *PicosRangeTooLarge {
	return &PicosRangeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, picosRangeTooLarge: picosRangeTooLarge{}}
}

// PicosRangeTooLarge is an error type.
/*
Time range is too large to fit in 64 bits for picosecond granularity data.
Try again with a smaller time range.
*/
type PicosRangeTooLarge struct {
	errorInstanceID uuid.UUID
	picosRangeTooLarge
	cause error
	stack werror.StackTrace
}

// IsPicosRangeTooLarge returns true if err is an instance of PicosRangeTooLarge.
func IsPicosRangeTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*PicosRangeTooLarge)
	return ok
}

func (e *PicosRangeTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:PicosRangeTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *PicosRangeTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *PicosRangeTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *PicosRangeTooLarge) Message() string {
	return "INVALID_ARGUMENT Compute:PicosRangeTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *PicosRangeTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *PicosRangeTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *PicosRangeTooLarge) Name() string {
	return "Compute:PicosRangeTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *PicosRangeTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *PicosRangeTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *PicosRangeTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *PicosRangeTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *PicosRangeTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *PicosRangeTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e PicosRangeTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.picosRangeTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:PicosRangeTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *PicosRangeTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters picosRangeTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.picosRangeTooLarge = parameters
	return nil
}

type queryRangeTooLarge struct{}

func (o queryRangeTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *queryRangeTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewQueryRangeTooLarge returns new instance of QueryRangeTooLarge error.
func NewQueryRangeTooLarge() *QueryRangeTooLarge {
	return &QueryRangeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), queryRangeTooLarge: queryRangeTooLarge{}}
}

// WrapWithQueryRangeTooLarge returns new instance of QueryRangeTooLarge error wrapping an existing error.
func WrapWithQueryRangeTooLarge(err error) *QueryRangeTooLarge {
	return &QueryRangeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, queryRangeTooLarge: queryRangeTooLarge{}}
}

// QueryRangeTooLarge is an error type.
// The requested time range is too large. Try again with a smaller time range.
type QueryRangeTooLarge struct {
	errorInstanceID uuid.UUID
	queryRangeTooLarge
	cause error
	stack werror.StackTrace
}

// IsQueryRangeTooLarge returns true if err is an instance of QueryRangeTooLarge.
func IsQueryRangeTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*QueryRangeTooLarge)
	return ok
}

func (e *QueryRangeTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:QueryRangeTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *QueryRangeTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *QueryRangeTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *QueryRangeTooLarge) Message() string {
	return "INVALID_ARGUMENT Compute:QueryRangeTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *QueryRangeTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *QueryRangeTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *QueryRangeTooLarge) Name() string {
	return "Compute:QueryRangeTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *QueryRangeTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *QueryRangeTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *QueryRangeTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *QueryRangeTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *QueryRangeTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *QueryRangeTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e QueryRangeTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.queryRangeTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:QueryRangeTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *QueryRangeTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters queryRangeTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.queryRangeTooLarge = parameters
	return nil
}

type resolutionIntervalTooSmallForRange struct {
	RequestedResolution api4.Duration  `json:"requestedResolution"`
	Start               api2.Timestamp `json:"start"`
	End                 api2.Timestamp `json:"end"`
}

func (o resolutionIntervalTooSmallForRange) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *resolutionIntervalTooSmallForRange) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewResolutionIntervalTooSmallForRange returns new instance of ResolutionIntervalTooSmallForRange error.
func NewResolutionIntervalTooSmallForRange(requestedResolutionArg api4.Duration, startArg api2.Timestamp, endArg api2.Timestamp) *ResolutionIntervalTooSmallForRange {
	return &ResolutionIntervalTooSmallForRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), resolutionIntervalTooSmallForRange: resolutionIntervalTooSmallForRange{RequestedResolution: requestedResolutionArg, Start: startArg, End: endArg}}
}

// WrapWithResolutionIntervalTooSmallForRange returns new instance of ResolutionIntervalTooSmallForRange error wrapping an existing error.
func WrapWithResolutionIntervalTooSmallForRange(err error, requestedResolutionArg api4.Duration, startArg api2.Timestamp, endArg api2.Timestamp) *ResolutionIntervalTooSmallForRange {
	return &ResolutionIntervalTooSmallForRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, resolutionIntervalTooSmallForRange: resolutionIntervalTooSmallForRange{RequestedResolution: requestedResolutionArg, Start: startArg, End: endArg}}
}

// ResolutionIntervalTooSmallForRange is an error type.
type ResolutionIntervalTooSmallForRange struct {
	errorInstanceID uuid.UUID
	resolutionIntervalTooSmallForRange
	cause error
	stack werror.StackTrace
}

// IsResolutionIntervalTooSmallForRange returns true if err is an instance of ResolutionIntervalTooSmallForRange.
func IsResolutionIntervalTooSmallForRange(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ResolutionIntervalTooSmallForRange)
	return ok
}

func (e *ResolutionIntervalTooSmallForRange) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:ResolutionIntervalTooSmallForRange (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ResolutionIntervalTooSmallForRange) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ResolutionIntervalTooSmallForRange) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ResolutionIntervalTooSmallForRange) Message() string {
	return "INVALID_ARGUMENT Compute:ResolutionIntervalTooSmallForRange"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ResolutionIntervalTooSmallForRange) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ResolutionIntervalTooSmallForRange) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ResolutionIntervalTooSmallForRange) Name() string {
	return "Compute:ResolutionIntervalTooSmallForRange"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ResolutionIntervalTooSmallForRange) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ResolutionIntervalTooSmallForRange) Parameters() map[string]interface{} {
	return map[string]interface{}{"requestedResolution": e.RequestedResolution, "start": e.Start, "end": e.End}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ResolutionIntervalTooSmallForRange) safeParams() map[string]interface{} {
	return map[string]interface{}{"requestedResolution": e.RequestedResolution, "start": e.Start, "end": e.End, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ResolutionIntervalTooSmallForRange) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ResolutionIntervalTooSmallForRange) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ResolutionIntervalTooSmallForRange) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ResolutionIntervalTooSmallForRange) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.resolutionIntervalTooSmallForRange)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:ResolutionIntervalTooSmallForRange", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ResolutionIntervalTooSmallForRange) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters resolutionIntervalTooSmallForRange
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.resolutionIntervalTooSmallForRange = parameters
	return nil
}

type rowLimitExceeded struct {
	QueryId uuid.UUID         `json:"queryId"`
	Limit   safelong.SafeLong `json:"limit"`
}

func (o rowLimitExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *rowLimitExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewRowLimitExceeded returns new instance of RowLimitExceeded error.
func NewRowLimitExceeded(queryIdArg uuid.UUID, limitArg safelong.SafeLong) *RowLimitExceeded {
	return &RowLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), rowLimitExceeded: rowLimitExceeded{QueryId: queryIdArg, Limit: limitArg}}
}

// WrapWithRowLimitExceeded returns new instance of RowLimitExceeded error wrapping an existing error.
func WrapWithRowLimitExceeded(err error, queryIdArg uuid.UUID, limitArg safelong.SafeLong) *RowLimitExceeded {
	return &RowLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, rowLimitExceeded: rowLimitExceeded{QueryId: queryIdArg, Limit: limitArg}}
}

// RowLimitExceeded is an error type.
/*
The query exceeded that limit for number of rows returned. For the query to complete,
either zoom in or downsample.
*/
type RowLimitExceeded struct {
	errorInstanceID uuid.UUID
	rowLimitExceeded
	cause error
	stack werror.StackTrace
}

// IsRowLimitExceeded returns true if err is an instance of RowLimitExceeded.
func IsRowLimitExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*RowLimitExceeded)
	return ok
}

func (e *RowLimitExceeded) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:RowLimitExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *RowLimitExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *RowLimitExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *RowLimitExceeded) Message() string {
	return "INVALID_ARGUMENT Compute:RowLimitExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *RowLimitExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *RowLimitExceeded) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *RowLimitExceeded) Name() string {
	return "Compute:RowLimitExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *RowLimitExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *RowLimitExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "limit": e.Limit}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *RowLimitExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "limit": e.Limit, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *RowLimitExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *RowLimitExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *RowLimitExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e RowLimitExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.rowLimitExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:RowLimitExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *RowLimitExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters rowLimitExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.rowLimitExceeded = parameters
	return nil
}

type signalFilterInvalidCutoffBand struct {
	LowCutoffFrequency  float64 `json:"lowCutoffFrequency"`
	HighCutoffFrequency float64 `json:"highCutoffFrequency"`
}

func (o signalFilterInvalidCutoffBand) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *signalFilterInvalidCutoffBand) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSignalFilterInvalidCutoffBand returns new instance of SignalFilterInvalidCutoffBand error.
func NewSignalFilterInvalidCutoffBand(lowCutoffFrequencyArg float64, highCutoffFrequencyArg float64) *SignalFilterInvalidCutoffBand {
	return &SignalFilterInvalidCutoffBand{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), signalFilterInvalidCutoffBand: signalFilterInvalidCutoffBand{LowCutoffFrequency: lowCutoffFrequencyArg, HighCutoffFrequency: highCutoffFrequencyArg}}
}

// WrapWithSignalFilterInvalidCutoffBand returns new instance of SignalFilterInvalidCutoffBand error wrapping an existing error.
func WrapWithSignalFilterInvalidCutoffBand(err error, lowCutoffFrequencyArg float64, highCutoffFrequencyArg float64) *SignalFilterInvalidCutoffBand {
	return &SignalFilterInvalidCutoffBand{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, signalFilterInvalidCutoffBand: signalFilterInvalidCutoffBand{LowCutoffFrequency: lowCutoffFrequencyArg, HighCutoffFrequency: highCutoffFrequencyArg}}
}

// SignalFilterInvalidCutoffBand is an error type.
// Lower band cutoff frequency must be less than or equal to upper band cutoff frequency.
type SignalFilterInvalidCutoffBand struct {
	errorInstanceID uuid.UUID
	signalFilterInvalidCutoffBand
	cause error
	stack werror.StackTrace
}

// IsSignalFilterInvalidCutoffBand returns true if err is an instance of SignalFilterInvalidCutoffBand.
func IsSignalFilterInvalidCutoffBand(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SignalFilterInvalidCutoffBand)
	return ok
}

func (e *SignalFilterInvalidCutoffBand) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:SignalFilterInvalidCutoffBand (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SignalFilterInvalidCutoffBand) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SignalFilterInvalidCutoffBand) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SignalFilterInvalidCutoffBand) Message() string {
	return "INVALID_ARGUMENT Compute:SignalFilterInvalidCutoffBand"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SignalFilterInvalidCutoffBand) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SignalFilterInvalidCutoffBand) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SignalFilterInvalidCutoffBand) Name() string {
	return "Compute:SignalFilterInvalidCutoffBand"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SignalFilterInvalidCutoffBand) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffBand) Parameters() map[string]interface{} {
	return map[string]interface{}{"lowCutoffFrequency": e.LowCutoffFrequency, "highCutoffFrequency": e.HighCutoffFrequency}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffBand) safeParams() map[string]interface{} {
	return map[string]interface{}{"lowCutoffFrequency": e.LowCutoffFrequency, "highCutoffFrequency": e.HighCutoffFrequency, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidCutoffBand) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffBand) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidCutoffBand) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SignalFilterInvalidCutoffBand) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.signalFilterInvalidCutoffBand)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:SignalFilterInvalidCutoffBand", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SignalFilterInvalidCutoffBand) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters signalFilterInvalidCutoffBand
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.signalFilterInvalidCutoffBand = parameters
	return nil
}

type signalFilterInvalidCutoffFrequency struct {
	InvalidCutoffFrequency float64 `json:"invalidCutoffFrequency"`
	SamplingFrequency      float64 `json:"samplingFrequency"`
}

func (o signalFilterInvalidCutoffFrequency) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *signalFilterInvalidCutoffFrequency) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSignalFilterInvalidCutoffFrequency returns new instance of SignalFilterInvalidCutoffFrequency error.
func NewSignalFilterInvalidCutoffFrequency(invalidCutoffFrequencyArg float64, samplingFrequencyArg float64) *SignalFilterInvalidCutoffFrequency {
	return &SignalFilterInvalidCutoffFrequency{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), signalFilterInvalidCutoffFrequency: signalFilterInvalidCutoffFrequency{InvalidCutoffFrequency: invalidCutoffFrequencyArg, SamplingFrequency: samplingFrequencyArg}}
}

// WrapWithSignalFilterInvalidCutoffFrequency returns new instance of SignalFilterInvalidCutoffFrequency error wrapping an existing error.
func WrapWithSignalFilterInvalidCutoffFrequency(err error, invalidCutoffFrequencyArg float64, samplingFrequencyArg float64) *SignalFilterInvalidCutoffFrequency {
	return &SignalFilterInvalidCutoffFrequency{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, signalFilterInvalidCutoffFrequency: signalFilterInvalidCutoffFrequency{InvalidCutoffFrequency: invalidCutoffFrequencyArg, SamplingFrequency: samplingFrequencyArg}}
}

// SignalFilterInvalidCutoffFrequency is an error type.
// Cutoff frequency must be less than half the sampling frequency.
type SignalFilterInvalidCutoffFrequency struct {
	errorInstanceID uuid.UUID
	signalFilterInvalidCutoffFrequency
	cause error
	stack werror.StackTrace
}

// IsSignalFilterInvalidCutoffFrequency returns true if err is an instance of SignalFilterInvalidCutoffFrequency.
func IsSignalFilterInvalidCutoffFrequency(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SignalFilterInvalidCutoffFrequency)
	return ok
}

func (e *SignalFilterInvalidCutoffFrequency) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:SignalFilterInvalidCutoffFrequency (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SignalFilterInvalidCutoffFrequency) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SignalFilterInvalidCutoffFrequency) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SignalFilterInvalidCutoffFrequency) Message() string {
	return "INVALID_ARGUMENT Compute:SignalFilterInvalidCutoffFrequency"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SignalFilterInvalidCutoffFrequency) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SignalFilterInvalidCutoffFrequency) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SignalFilterInvalidCutoffFrequency) Name() string {
	return "Compute:SignalFilterInvalidCutoffFrequency"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SignalFilterInvalidCutoffFrequency) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffFrequency) Parameters() map[string]interface{} {
	return map[string]interface{}{"invalidCutoffFrequency": e.InvalidCutoffFrequency, "samplingFrequency": e.SamplingFrequency}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffFrequency) safeParams() map[string]interface{} {
	return map[string]interface{}{"invalidCutoffFrequency": e.InvalidCutoffFrequency, "samplingFrequency": e.SamplingFrequency, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidCutoffFrequency) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffFrequency) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidCutoffFrequency) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SignalFilterInvalidCutoffFrequency) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.signalFilterInvalidCutoffFrequency)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:SignalFilterInvalidCutoffFrequency", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SignalFilterInvalidCutoffFrequency) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters signalFilterInvalidCutoffFrequency
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.signalFilterInvalidCutoffFrequency = parameters
	return nil
}

type signalFilterInvalidOrder struct {
	Order int `json:"order"`
}

func (o signalFilterInvalidOrder) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *signalFilterInvalidOrder) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSignalFilterInvalidOrder returns new instance of SignalFilterInvalidOrder error.
func NewSignalFilterInvalidOrder(orderArg int) *SignalFilterInvalidOrder {
	return &SignalFilterInvalidOrder{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), signalFilterInvalidOrder: signalFilterInvalidOrder{Order: orderArg}}
}

// WrapWithSignalFilterInvalidOrder returns new instance of SignalFilterInvalidOrder error wrapping an existing error.
func WrapWithSignalFilterInvalidOrder(err error, orderArg int) *SignalFilterInvalidOrder {
	return &SignalFilterInvalidOrder{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, signalFilterInvalidOrder: signalFilterInvalidOrder{Order: orderArg}}
}

// SignalFilterInvalidOrder is an error type.
/*
Order must be positive even numbers for bidirectional filters.
Bidirectional filters are applied once forwards and once backwards, effectively doubling order.
Doubled again for bandpass/bandstop filters, requiring a multiple of 4 for filter order.
*/
type SignalFilterInvalidOrder struct {
	errorInstanceID uuid.UUID
	signalFilterInvalidOrder
	cause error
	stack werror.StackTrace
}

// IsSignalFilterInvalidOrder returns true if err is an instance of SignalFilterInvalidOrder.
func IsSignalFilterInvalidOrder(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SignalFilterInvalidOrder)
	return ok
}

func (e *SignalFilterInvalidOrder) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:SignalFilterInvalidOrder (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SignalFilterInvalidOrder) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SignalFilterInvalidOrder) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SignalFilterInvalidOrder) Message() string {
	return "INVALID_ARGUMENT Compute:SignalFilterInvalidOrder"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SignalFilterInvalidOrder) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SignalFilterInvalidOrder) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SignalFilterInvalidOrder) Name() string {
	return "Compute:SignalFilterInvalidOrder"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SignalFilterInvalidOrder) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SignalFilterInvalidOrder) Parameters() map[string]interface{} {
	return map[string]interface{}{"order": e.Order}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SignalFilterInvalidOrder) safeParams() map[string]interface{} {
	return map[string]interface{}{"order": e.Order, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidOrder) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SignalFilterInvalidOrder) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidOrder) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SignalFilterInvalidOrder) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.signalFilterInvalidOrder)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:SignalFilterInvalidOrder", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SignalFilterInvalidOrder) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters signalFilterInvalidOrder
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.signalFilterInvalidOrder = parameters
	return nil
}

type signalFilterNonPositiveCutoffFrequency struct {
	CutoffFrequency float64 `json:"cutoffFrequency"`
}

func (o signalFilterNonPositiveCutoffFrequency) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *signalFilterNonPositiveCutoffFrequency) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSignalFilterNonPositiveCutoffFrequency returns new instance of SignalFilterNonPositiveCutoffFrequency error.
func NewSignalFilterNonPositiveCutoffFrequency(cutoffFrequencyArg float64) *SignalFilterNonPositiveCutoffFrequency {
	return &SignalFilterNonPositiveCutoffFrequency{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), signalFilterNonPositiveCutoffFrequency: signalFilterNonPositiveCutoffFrequency{CutoffFrequency: cutoffFrequencyArg}}
}

// WrapWithSignalFilterNonPositiveCutoffFrequency returns new instance of SignalFilterNonPositiveCutoffFrequency error wrapping an existing error.
func WrapWithSignalFilterNonPositiveCutoffFrequency(err error, cutoffFrequencyArg float64) *SignalFilterNonPositiveCutoffFrequency {
	return &SignalFilterNonPositiveCutoffFrequency{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, signalFilterNonPositiveCutoffFrequency: signalFilterNonPositiveCutoffFrequency{CutoffFrequency: cutoffFrequencyArg}}
}

// SignalFilterNonPositiveCutoffFrequency is an error type.
// Cutoff frequency must be strictly positive.
type SignalFilterNonPositiveCutoffFrequency struct {
	errorInstanceID uuid.UUID
	signalFilterNonPositiveCutoffFrequency
	cause error
	stack werror.StackTrace
}

// IsSignalFilterNonPositiveCutoffFrequency returns true if err is an instance of SignalFilterNonPositiveCutoffFrequency.
func IsSignalFilterNonPositiveCutoffFrequency(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SignalFilterNonPositiveCutoffFrequency)
	return ok
}

func (e *SignalFilterNonPositiveCutoffFrequency) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:SignalFilterNonPositiveCutoffFrequency (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SignalFilterNonPositiveCutoffFrequency) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SignalFilterNonPositiveCutoffFrequency) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SignalFilterNonPositiveCutoffFrequency) Message() string {
	return "INVALID_ARGUMENT Compute:SignalFilterNonPositiveCutoffFrequency"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SignalFilterNonPositiveCutoffFrequency) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SignalFilterNonPositiveCutoffFrequency) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SignalFilterNonPositiveCutoffFrequency) Name() string {
	return "Compute:SignalFilterNonPositiveCutoffFrequency"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SignalFilterNonPositiveCutoffFrequency) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SignalFilterNonPositiveCutoffFrequency) Parameters() map[string]interface{} {
	return map[string]interface{}{"cutoffFrequency": e.CutoffFrequency}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SignalFilterNonPositiveCutoffFrequency) safeParams() map[string]interface{} {
	return map[string]interface{}{"cutoffFrequency": e.CutoffFrequency, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterNonPositiveCutoffFrequency) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SignalFilterNonPositiveCutoffFrequency) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterNonPositiveCutoffFrequency) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SignalFilterNonPositiveCutoffFrequency) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.signalFilterNonPositiveCutoffFrequency)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:SignalFilterNonPositiveCutoffFrequency", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SignalFilterNonPositiveCutoffFrequency) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters signalFilterNonPositiveCutoffFrequency
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.signalFilterNonPositiveCutoffFrequency = parameters
	return nil
}

type signalFilterNotEnoughData struct {
	RequiredMinPoints int `json:"requiredMinPoints"`
	LenPoints         int `json:"lenPoints"`
}

func (o signalFilterNotEnoughData) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *signalFilterNotEnoughData) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSignalFilterNotEnoughData returns new instance of SignalFilterNotEnoughData error.
func NewSignalFilterNotEnoughData(requiredMinPointsArg int, lenPointsArg int) *SignalFilterNotEnoughData {
	return &SignalFilterNotEnoughData{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), signalFilterNotEnoughData: signalFilterNotEnoughData{RequiredMinPoints: requiredMinPointsArg, LenPoints: lenPointsArg}}
}

// WrapWithSignalFilterNotEnoughData returns new instance of SignalFilterNotEnoughData error wrapping an existing error.
func WrapWithSignalFilterNotEnoughData(err error, requiredMinPointsArg int, lenPointsArg int) *SignalFilterNotEnoughData {
	return &SignalFilterNotEnoughData{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, signalFilterNotEnoughData: signalFilterNotEnoughData{RequiredMinPoints: requiredMinPointsArg, LenPoints: lenPointsArg}}
}

// SignalFilterNotEnoughData is an error type.
/*
Not enough data to apply the filter. Required data scales with filter order.
Try again with a larger time range.
*/
type SignalFilterNotEnoughData struct {
	errorInstanceID uuid.UUID
	signalFilterNotEnoughData
	cause error
	stack werror.StackTrace
}

// IsSignalFilterNotEnoughData returns true if err is an instance of SignalFilterNotEnoughData.
func IsSignalFilterNotEnoughData(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SignalFilterNotEnoughData)
	return ok
}

func (e *SignalFilterNotEnoughData) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:SignalFilterNotEnoughData (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SignalFilterNotEnoughData) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SignalFilterNotEnoughData) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SignalFilterNotEnoughData) Message() string {
	return "INVALID_ARGUMENT Compute:SignalFilterNotEnoughData"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SignalFilterNotEnoughData) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SignalFilterNotEnoughData) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SignalFilterNotEnoughData) Name() string {
	return "Compute:SignalFilterNotEnoughData"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SignalFilterNotEnoughData) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SignalFilterNotEnoughData) Parameters() map[string]interface{} {
	return map[string]interface{}{"requiredMinPoints": e.RequiredMinPoints, "lenPoints": e.LenPoints}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SignalFilterNotEnoughData) safeParams() map[string]interface{} {
	return map[string]interface{}{"requiredMinPoints": e.RequiredMinPoints, "lenPoints": e.LenPoints, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterNotEnoughData) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SignalFilterNotEnoughData) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterNotEnoughData) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SignalFilterNotEnoughData) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.signalFilterNotEnoughData)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:SignalFilterNotEnoughData", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SignalFilterNotEnoughData) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters signalFilterNotEnoughData
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.signalFilterNotEnoughData = parameters
	return nil
}

type timeoutExceeded struct {
	QueryId uuid.UUID `json:"queryId"`
}

func (o timeoutExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *timeoutExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTimeoutExceeded returns new instance of TimeoutExceeded error.
func NewTimeoutExceeded(queryIdArg uuid.UUID) *TimeoutExceeded {
	return &TimeoutExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), timeoutExceeded: timeoutExceeded{QueryId: queryIdArg}}
}

// WrapWithTimeoutExceeded returns new instance of TimeoutExceeded error wrapping an existing error.
func WrapWithTimeoutExceeded(err error, queryIdArg uuid.UUID) *TimeoutExceeded {
	return &TimeoutExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, timeoutExceeded: timeoutExceeded{QueryId: queryIdArg}}
}

// TimeoutExceeded is an error type.
// The query timed out. Try querying a smaller time range or fewer series.
type TimeoutExceeded struct {
	errorInstanceID uuid.UUID
	timeoutExceeded
	cause error
	stack werror.StackTrace
}

// IsTimeoutExceeded returns true if err is an instance of TimeoutExceeded.
func IsTimeoutExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TimeoutExceeded)
	return ok
}

func (e *TimeoutExceeded) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TimeoutExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TimeoutExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TimeoutExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TimeoutExceeded) Message() string {
	return "INVALID_ARGUMENT Compute:TimeoutExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TimeoutExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TimeoutExceeded) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TimeoutExceeded) Name() string {
	return "Compute:TimeoutExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TimeoutExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TimeoutExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TimeoutExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TimeoutExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TimeoutExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TimeoutExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TimeoutExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.timeoutExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TimeoutExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TimeoutExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters timeoutExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.timeoutExceeded = parameters
	return nil
}

type tooManyBuckets struct{}

func (o tooManyBuckets) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyBuckets) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyBuckets returns new instance of TooManyBuckets error.
func NewTooManyBuckets() *TooManyBuckets {
	return &TooManyBuckets{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyBuckets: tooManyBuckets{}}
}

// WrapWithTooManyBuckets returns new instance of TooManyBuckets error wrapping an existing error.
func WrapWithTooManyBuckets(err error) *TooManyBuckets {
	return &TooManyBuckets{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyBuckets: tooManyBuckets{}}
}

// TooManyBuckets is an error type.
/*
The number of buckets returned is greater than the max allowed (1000). Try again by specifying a larger bucket width or
fewer bucket counts.
*/
type TooManyBuckets struct {
	errorInstanceID uuid.UUID
	tooManyBuckets
	cause error
	stack werror.StackTrace
}

// IsTooManyBuckets returns true if err is an instance of TooManyBuckets.
func IsTooManyBuckets(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyBuckets)
	return ok
}

func (e *TooManyBuckets) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyBuckets (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyBuckets) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyBuckets) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyBuckets) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyBuckets"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyBuckets) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyBuckets) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyBuckets) Name() string {
	return "Compute:TooManyBuckets"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyBuckets) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyBuckets) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyBuckets) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyBuckets) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyBuckets) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyBuckets) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyBuckets) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyBuckets)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyBuckets", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyBuckets) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyBuckets
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyBuckets = parameters
	return nil
}

type tooManyCategories struct {
	NumCategories int `json:"numCategories"`
}

func (o tooManyCategories) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyCategories) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyCategories returns new instance of TooManyCategories error.
func NewTooManyCategories(numCategoriesArg int) *TooManyCategories {
	return &TooManyCategories{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyCategories: tooManyCategories{NumCategories: numCategoriesArg}}
}

// WrapWithTooManyCategories returns new instance of TooManyCategories error wrapping an existing error.
func WrapWithTooManyCategories(err error, numCategoriesArg int) *TooManyCategories {
	return &TooManyCategories{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyCategories: tooManyCategories{NumCategories: numCategoriesArg}}
}

// TooManyCategories is an error type.
// An enum series has more categories than the max allowed (200).
type TooManyCategories struct {
	errorInstanceID uuid.UUID
	tooManyCategories
	cause error
	stack werror.StackTrace
}

// IsTooManyCategories returns true if err is an instance of TooManyCategories.
func IsTooManyCategories(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyCategories)
	return ok
}

func (e *TooManyCategories) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyCategories (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyCategories) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyCategories) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyCategories) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyCategories"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyCategories) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyCategories) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyCategories) Name() string {
	return "Compute:TooManyCategories"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyCategories) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyCategories) Parameters() map[string]interface{} {
	return map[string]interface{}{"numCategories": e.NumCategories}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyCategories) safeParams() map[string]interface{} {
	return map[string]interface{}{"numCategories": e.NumCategories, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyCategories) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyCategories) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyCategories) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyCategories) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyCategories)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyCategories", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyCategories) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyCategories
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyCategories = parameters
	return nil
}

type tooManyEvents struct{}

func (o tooManyEvents) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyEvents) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyEvents returns new instance of TooManyEvents error.
func NewTooManyEvents() *TooManyEvents {
	return &TooManyEvents{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyEvents: tooManyEvents{}}
}

// WrapWithTooManyEvents returns new instance of TooManyEvents error wrapping an existing error.
func WrapWithTooManyEvents(err error) *TooManyEvents {
	return &TooManyEvents{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyEvents: tooManyEvents{}}
}

// TooManyEvents is an error type.
// Number of events is greater than the max allowed (1000).
type TooManyEvents struct {
	errorInstanceID uuid.UUID
	tooManyEvents
	cause error
	stack werror.StackTrace
}

// IsTooManyEvents returns true if err is an instance of TooManyEvents.
func IsTooManyEvents(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyEvents)
	return ok
}

func (e *TooManyEvents) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyEvents (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyEvents) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyEvents) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyEvents) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyEvents"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyEvents) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyEvents) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyEvents) Name() string {
	return "Compute:TooManyEvents"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyEvents) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyEvents) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyEvents) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyEvents) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyEvents) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyEvents) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyEvents) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyEvents)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyEvents", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyEvents) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyEvents
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyEvents = parameters
	return nil
}

type tooManyLiterals struct {
	Count int `json:"count"`
}

func (o tooManyLiterals) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyLiterals) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyLiterals returns new instance of TooManyLiterals error.
func NewTooManyLiterals(countArg int) *TooManyLiterals {
	return &TooManyLiterals{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyLiterals: tooManyLiterals{Count: countArg}}
}

// WrapWithTooManyLiterals returns new instance of TooManyLiterals error wrapping an existing error.
func WrapWithTooManyLiterals(err error, countArg int) *TooManyLiterals {
	return &TooManyLiterals{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyLiterals: tooManyLiterals{Count: countArg}}
}

// TooManyLiterals is an error type.
// Too many literals provided in a literal node.
type TooManyLiterals struct {
	errorInstanceID uuid.UUID
	tooManyLiterals
	cause error
	stack werror.StackTrace
}

// IsTooManyLiterals returns true if err is an instance of TooManyLiterals.
func IsTooManyLiterals(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyLiterals)
	return ok
}

func (e *TooManyLiterals) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyLiterals (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyLiterals) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyLiterals) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyLiterals) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyLiterals"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyLiterals) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyLiterals) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyLiterals) Name() string {
	return "Compute:TooManyLiterals"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyLiterals) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyLiterals) Parameters() map[string]interface{} {
	return map[string]interface{}{"count": e.Count}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyLiterals) safeParams() map[string]interface{} {
	return map[string]interface{}{"count": e.Count, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyLiterals) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyLiterals) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyLiterals) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyLiterals) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyLiterals)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyLiterals", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyLiterals) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyLiterals
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyLiterals = parameters
	return nil
}

type tooManyPoints struct{}

func (o tooManyPoints) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyPoints) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyPoints returns new instance of TooManyPoints error.
func NewTooManyPoints() *TooManyPoints {
	return &TooManyPoints{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyPoints: tooManyPoints{}}
}

// WrapWithTooManyPoints returns new instance of TooManyPoints error wrapping an existing error.
func WrapWithTooManyPoints(err error) *TooManyPoints {
	return &TooManyPoints{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyPoints: tooManyPoints{}}
}

// TooManyPoints is an error type.
/*
The number of points returned is greater than the max allowed. Try again with a smaller time
range, or a larger resolution.
*/
type TooManyPoints struct {
	errorInstanceID uuid.UUID
	tooManyPoints
	cause error
	stack werror.StackTrace
}

// IsTooManyPoints returns true if err is an instance of TooManyPoints.
func IsTooManyPoints(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyPoints)
	return ok
}

func (e *TooManyPoints) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyPoints (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyPoints) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyPoints) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyPoints) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyPoints"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyPoints) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyPoints) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyPoints) Name() string {
	return "Compute:TooManyPoints"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyPoints) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyPoints) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyPoints) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyPoints) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyPoints) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyPoints) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyPoints) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyPoints)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyPoints", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyPoints) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyPoints
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyPoints = parameters
	return nil
}

type tooManyRanges struct{}

func (o tooManyRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyRanges returns new instance of TooManyRanges error.
func NewTooManyRanges() *TooManyRanges {
	return &TooManyRanges{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyRanges: tooManyRanges{}}
}

// WrapWithTooManyRanges returns new instance of TooManyRanges error wrapping an existing error.
func WrapWithTooManyRanges(err error) *TooManyRanges {
	return &TooManyRanges{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyRanges: tooManyRanges{}}
}

// TooManyRanges is an error type.
// Ranges is greater than the max allowed (2000).
type TooManyRanges struct {
	errorInstanceID uuid.UUID
	tooManyRanges
	cause error
	stack werror.StackTrace
}

// IsTooManyRanges returns true if err is an instance of TooManyRanges.
func IsTooManyRanges(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyRanges)
	return ok
}

func (e *TooManyRanges) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyRanges (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyRanges) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyRanges) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyRanges) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyRanges"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyRanges) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyRanges) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyRanges) Name() string {
	return "Compute:TooManyRanges"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyRanges) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyRanges) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyRanges) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyRanges) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyRanges) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyRanges) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyRanges) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyRanges)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyRanges", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyRanges) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyRanges
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyRanges = parameters
	return nil
}

type tooManyResamplePoints struct{}

func (o tooManyResamplePoints) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyResamplePoints) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyResamplePoints returns new instance of TooManyResamplePoints error.
func NewTooManyResamplePoints() *TooManyResamplePoints {
	return &TooManyResamplePoints{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyResamplePoints: tooManyResamplePoints{}}
}

// WrapWithTooManyResamplePoints returns new instance of TooManyResamplePoints error wrapping an existing error.
func WrapWithTooManyResamplePoints(err error) *TooManyResamplePoints {
	return &TooManyResamplePoints{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyResamplePoints: tooManyResamplePoints{}}
}

// TooManyResamplePoints is an error type.
// The resample interval is too short and would produce more than the max points (10,000,000). Try again by specifying a larger interval.
type TooManyResamplePoints struct {
	errorInstanceID uuid.UUID
	tooManyResamplePoints
	cause error
	stack werror.StackTrace
}

// IsTooManyResamplePoints returns true if err is an instance of TooManyResamplePoints.
func IsTooManyResamplePoints(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyResamplePoints)
	return ok
}

func (e *TooManyResamplePoints) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyResamplePoints (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyResamplePoints) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyResamplePoints) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyResamplePoints) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyResamplePoints"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyResamplePoints) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyResamplePoints) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyResamplePoints) Name() string {
	return "Compute:TooManyResamplePoints"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyResamplePoints) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyResamplePoints) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyResamplePoints) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyResamplePoints) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyResamplePoints) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyResamplePoints) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyResamplePoints) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyResamplePoints)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyResamplePoints", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyResamplePoints) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyResamplePoints
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyResamplePoints = parameters
	return nil
}

type tooManySubrequests struct{}

func (o tooManySubrequests) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManySubrequests) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManySubrequests returns new instance of TooManySubrequests error.
func NewTooManySubrequests() *TooManySubrequests {
	return &TooManySubrequests{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManySubrequests: tooManySubrequests{}}
}

// WrapWithTooManySubrequests returns new instance of TooManySubrequests error wrapping an existing error.
func WrapWithTooManySubrequests(err error) *TooManySubrequests {
	return &TooManySubrequests{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManySubrequests: tooManySubrequests{}}
}

// TooManySubrequests is an error type.
// Number of parameterized subrequests is greater than the max allowed (300).
type TooManySubrequests struct {
	errorInstanceID uuid.UUID
	tooManySubrequests
	cause error
	stack werror.StackTrace
}

// IsTooManySubrequests returns true if err is an instance of TooManySubrequests.
func IsTooManySubrequests(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManySubrequests)
	return ok
}

func (e *TooManySubrequests) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManySubrequests (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManySubrequests) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManySubrequests) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManySubrequests) Message() string {
	return "INVALID_ARGUMENT Compute:TooManySubrequests"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManySubrequests) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManySubrequests) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManySubrequests) Name() string {
	return "Compute:TooManySubrequests"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManySubrequests) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManySubrequests) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManySubrequests) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManySubrequests) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManySubrequests) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManySubrequests) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManySubrequests) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManySubrequests)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManySubrequests", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManySubrequests) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManySubrequests
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManySubrequests = parameters
	return nil
}

type unitConversionInvalid struct {
	InputUnit  api1.UnitSymbol `json:"inputUnit"`
	OutputUnit api1.UnitSymbol `json:"outputUnit"`
}

func (o unitConversionInvalid) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *unitConversionInvalid) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUnitConversionInvalid returns new instance of UnitConversionInvalid error.
func NewUnitConversionInvalid(inputUnitArg api1.UnitSymbol, outputUnitArg api1.UnitSymbol) *UnitConversionInvalid {
	return &UnitConversionInvalid{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), unitConversionInvalid: unitConversionInvalid{InputUnit: inputUnitArg, OutputUnit: outputUnitArg}}
}

// WrapWithUnitConversionInvalid returns new instance of UnitConversionInvalid error wrapping an existing error.
func WrapWithUnitConversionInvalid(err error, inputUnitArg api1.UnitSymbol, outputUnitArg api1.UnitSymbol) *UnitConversionInvalid {
	return &UnitConversionInvalid{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, unitConversionInvalid: unitConversionInvalid{InputUnit: inputUnitArg, OutputUnit: outputUnitArg}}
}

// UnitConversionInvalid is an error type.
/*
The unit conversion could not be computed because the input unit cannot be converted
to the output unit.
*/
type UnitConversionInvalid struct {
	errorInstanceID uuid.UUID
	unitConversionInvalid
	cause error
	stack werror.StackTrace
}

// IsUnitConversionInvalid returns true if err is an instance of UnitConversionInvalid.
func IsUnitConversionInvalid(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*UnitConversionInvalid)
	return ok
}

func (e *UnitConversionInvalid) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:UnitConversionInvalid (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *UnitConversionInvalid) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *UnitConversionInvalid) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *UnitConversionInvalid) Message() string {
	return "INVALID_ARGUMENT Compute:UnitConversionInvalid"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *UnitConversionInvalid) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *UnitConversionInvalid) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *UnitConversionInvalid) Name() string {
	return "Compute:UnitConversionInvalid"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *UnitConversionInvalid) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *UnitConversionInvalid) Parameters() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit, "outputUnit": e.OutputUnit}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *UnitConversionInvalid) safeParams() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit, "outputUnit": e.OutputUnit, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnitConversionInvalid) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *UnitConversionInvalid) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnitConversionInvalid) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e UnitConversionInvalid) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.unitConversionInvalid)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:UnitConversionInvalid", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *UnitConversionInvalid) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters unitConversionInvalid
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.unitConversionInvalid = parameters
	return nil
}

type variableHasWrongType struct {
	VariableName VariableName `json:"variableName"`
	ExpectedType string       `json:"expectedType"`
}

func (o variableHasWrongType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *variableHasWrongType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewVariableHasWrongType returns new instance of VariableHasWrongType error.
func NewVariableHasWrongType(variableNameArg VariableName, expectedTypeArg string) *VariableHasWrongType {
	return &VariableHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), variableHasWrongType: variableHasWrongType{VariableName: variableNameArg, ExpectedType: expectedTypeArg}}
}

// WrapWithVariableHasWrongType returns new instance of VariableHasWrongType error wrapping an existing error.
func WrapWithVariableHasWrongType(err error, variableNameArg VariableName, expectedTypeArg string) *VariableHasWrongType {
	return &VariableHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, variableHasWrongType: variableHasWrongType{VariableName: variableNameArg, ExpectedType: expectedTypeArg}}
}

// VariableHasWrongType is an error type.
type VariableHasWrongType struct {
	errorInstanceID uuid.UUID
	variableHasWrongType
	cause error
	stack werror.StackTrace
}

// IsVariableHasWrongType returns true if err is an instance of VariableHasWrongType.
func IsVariableHasWrongType(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*VariableHasWrongType)
	return ok
}

func (e *VariableHasWrongType) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:VariableHasWrongType (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *VariableHasWrongType) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *VariableHasWrongType) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *VariableHasWrongType) Message() string {
	return "INVALID_ARGUMENT Compute:VariableHasWrongType"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *VariableHasWrongType) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *VariableHasWrongType) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *VariableHasWrongType) Name() string {
	return "Compute:VariableHasWrongType"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *VariableHasWrongType) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *VariableHasWrongType) Parameters() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "expectedType": e.ExpectedType}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *VariableHasWrongType) safeParams() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "expectedType": e.ExpectedType, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *VariableHasWrongType) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *VariableHasWrongType) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *VariableHasWrongType) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e VariableHasWrongType) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.variableHasWrongType)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:VariableHasWrongType", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *VariableHasWrongType) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters variableHasWrongType
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.variableHasWrongType = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Compute:CannotAggregateEnumPlot", reflect.TypeOf(CannotAggregateEnumPlot{}))
	conjureerrors.RegisterErrorType("Compute:CannotCompileRegexp", reflect.TypeOf(CannotCompileRegexp{}))
	conjureerrors.RegisterErrorType("Compute:ChannelHasWrongType", reflect.TypeOf(ChannelHasWrongType{}))
	conjureerrors.RegisterErrorType("Compute:ConcurrentQueriesExceeded", reflect.TypeOf(ConcurrentQueriesExceeded{}))
	conjureerrors.RegisterErrorType("Compute:ConverterInputUnitNotFound", reflect.TypeOf(ConverterInputUnitNotFound{}))
	conjureerrors.RegisterErrorType("Compute:ConverterOutputUnitNotFound", reflect.TypeOf(ConverterOutputUnitNotFound{}))
	conjureerrors.RegisterErrorType("Compute:CurveInvalidNegativeInputs", reflect.TypeOf(CurveInvalidNegativeInputs{}))
	conjureerrors.RegisterErrorType("Compute:CurveUnequalInputLength", reflect.TypeOf(CurveUnequalInputLength{}))
	conjureerrors.RegisterErrorType("Compute:DerivedSeriesHasWrongType", reflect.TypeOf(DerivedSeriesHasWrongType{}))
	conjureerrors.RegisterErrorType("Compute:DuplicateTimestamp", reflect.TypeOf(DuplicateTimestamp{}))
	conjureerrors.RegisterErrorType("Compute:ExponentialCurveInputTooLarge", reflect.TypeOf(ExponentialCurveInputTooLarge{}))
	conjureerrors.RegisterErrorType("ExternalDatabase:ExternalDatabaseBadGateway", reflect.TypeOf(ExternalDatabaseBadGateway{}))
	conjureerrors.RegisterErrorType("ExternalDatabase:ExternalDatabaseGatewayTimeout", reflect.TypeOf(ExternalDatabaseGatewayTimeout{}))
	conjureerrors.RegisterErrorType("Compute:FftWindowEmpty", reflect.TypeOf(FftWindowEmpty{}))
	conjureerrors.RegisterErrorType("Compute:FftWindowTooLarge", reflect.TypeOf(FftWindowTooLarge{}))
	conjureerrors.RegisterErrorType("Compute:GranularityMismatch", reflect.TypeOf(GranularityMismatch{}))
	conjureerrors.RegisterErrorType("Compute:GroupByTagsNotSubset", reflect.TypeOf(GroupByTagsNotSubset{}))
	conjureerrors.RegisterErrorType("Compute:GroupBysNotSupportedForQuery", reflect.TypeOf(GroupBysNotSupportedForQuery{}))
	conjureerrors.RegisterErrorType("Compute:InvalidExpression", reflect.TypeOf(InvalidExpression{}))
	conjureerrors.RegisterErrorType("Compute:InvalidLiteralRange", reflect.TypeOf(InvalidLiteralRange{}))
	conjureerrors.RegisterErrorType("Compute:InvalidNumericOutputFields", reflect.TypeOf(InvalidNumericOutputFields{}))
	conjureerrors.RegisterErrorType("Compute:InvalidPlotType", reflect.TypeOf(InvalidPlotType{}))
	conjureerrors.RegisterErrorType("Compute:InvalidRangeNodeStartAfterViewRange", reflect.TypeOf(InvalidRangeNodeStartAfterViewRange{}))
	conjureerrors.RegisterErrorType("Compute:InvalidSeriesLocator", reflect.TypeOf(InvalidSeriesLocator{}))
	conjureerrors.RegisterErrorType("Compute:InvalidTagFilterConfiguration", reflect.TypeOf(InvalidTagFilterConfiguration{}))
	conjureerrors.RegisterErrorType("Compute:InvalidTimeUnit", reflect.TypeOf(InvalidTimeUnit{}))
	conjureerrors.RegisterErrorType("Compute:InvalidValueMap", reflect.TypeOf(InvalidValueMap{}))
	conjureerrors.RegisterErrorType("Compute:MaxQuerySizeExceeded", reflect.TypeOf(MaxQuerySizeExceeded{}))
	conjureerrors.RegisterErrorType("Compute:MemoryLimitExceeded", reflect.TypeOf(MemoryLimitExceeded{}))
	conjureerrors.RegisterErrorType("Compute:MissingFunctionInModuleApplication", reflect.TypeOf(MissingFunctionInModuleApplication{}))
	conjureerrors.RegisterErrorType("Compute:MissingModuleVariable", reflect.TypeOf(MissingModuleVariable{}))
	conjureerrors.RegisterErrorType("Compute:MissingVariable", reflect.TypeOf(MissingVariable{}))
	conjureerrors.RegisterErrorType("Compute:NonPositiveDuration", reflect.TypeOf(NonPositiveDuration{}))
	conjureerrors.RegisterErrorType("Compute:NonPositiveResampleInterval", reflect.TypeOf(NonPositiveResampleInterval{}))
	conjureerrors.RegisterErrorType("Compute:NotAuthorized", reflect.TypeOf(NotAuthorized{}))
	conjureerrors.RegisterErrorType("Compute:NotEnoughPointsForCurve", reflect.TypeOf(NotEnoughPointsForCurve{}))
	conjureerrors.RegisterErrorType("Compute:OverlappingLiteralRanges", reflect.TypeOf(OverlappingLiteralRanges{}))
	conjureerrors.RegisterErrorType("Compute:PicosRangeTooLarge", reflect.TypeOf(PicosRangeTooLarge{}))
	conjureerrors.RegisterErrorType("Compute:QueryRangeTooLarge", reflect.TypeOf(QueryRangeTooLarge{}))
	conjureerrors.RegisterErrorType("Compute:ResolutionIntervalTooSmallForRange", reflect.TypeOf(ResolutionIntervalTooSmallForRange{}))
	conjureerrors.RegisterErrorType("Compute:RowLimitExceeded", reflect.TypeOf(RowLimitExceeded{}))
	conjureerrors.RegisterErrorType("Compute:SignalFilterInvalidCutoffBand", reflect.TypeOf(SignalFilterInvalidCutoffBand{}))
	conjureerrors.RegisterErrorType("Compute:SignalFilterInvalidCutoffFrequency", reflect.TypeOf(SignalFilterInvalidCutoffFrequency{}))
	conjureerrors.RegisterErrorType("Compute:SignalFilterInvalidOrder", reflect.TypeOf(SignalFilterInvalidOrder{}))
	conjureerrors.RegisterErrorType("Compute:SignalFilterNonPositiveCutoffFrequency", reflect.TypeOf(SignalFilterNonPositiveCutoffFrequency{}))
	conjureerrors.RegisterErrorType("Compute:SignalFilterNotEnoughData", reflect.TypeOf(SignalFilterNotEnoughData{}))
	conjureerrors.RegisterErrorType("Compute:TimeoutExceeded", reflect.TypeOf(TimeoutExceeded{}))
	conjureerrors.RegisterErrorType("Compute:TooManyBuckets", reflect.TypeOf(TooManyBuckets{}))
	conjureerrors.RegisterErrorType("Compute:TooManyCategories", reflect.TypeOf(TooManyCategories{}))
	conjureerrors.RegisterErrorType("Compute:TooManyEvents", reflect.TypeOf(TooManyEvents{}))
	conjureerrors.RegisterErrorType("Compute:TooManyLiterals", reflect.TypeOf(TooManyLiterals{}))
	conjureerrors.RegisterErrorType("Compute:TooManyPoints", reflect.TypeOf(TooManyPoints{}))
	conjureerrors.RegisterErrorType("Compute:TooManyRanges", reflect.TypeOf(TooManyRanges{}))
	conjureerrors.RegisterErrorType("Compute:TooManyResamplePoints", reflect.TypeOf(TooManyResamplePoints{}))
	conjureerrors.RegisterErrorType("Compute:TooManySubrequests", reflect.TypeOf(TooManySubrequests{}))
	conjureerrors.RegisterErrorType("Compute:UnitConversionInvalid", reflect.TypeOf(UnitConversionInvalid{}))
	conjureerrors.RegisterErrorType("Compute:VariableHasWrongType", reflect.TypeOf(VariableHasWrongType{}))
}
