// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	api2 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	api3 "github.com/nominal-io/nominal-api-go/modules/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/units/api"
	"github.com/nominal-io/nominal-api-go/storage/series/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type cannotAggregateEnumPlot struct {
	AggregationType string `json:"aggregationType"`
}

func (o cannotAggregateEnumPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *cannotAggregateEnumPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCannotAggregateEnumPlot returns new instance of CannotAggregateEnumPlot error.
func NewCannotAggregateEnumPlot(aggregationTypeArg string) *CannotAggregateEnumPlot {
	return &CannotAggregateEnumPlot{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cannotAggregateEnumPlot: cannotAggregateEnumPlot{AggregationType: aggregationTypeArg}}
}

// WrapWithCannotAggregateEnumPlot returns new instance of CannotAggregateEnumPlot error wrapping an existing error.
func WrapWithCannotAggregateEnumPlot(err error, aggregationTypeArg string) *CannotAggregateEnumPlot {
	return &CannotAggregateEnumPlot{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, cannotAggregateEnumPlot: cannotAggregateEnumPlot{AggregationType: aggregationTypeArg}}
}

// CannotAggregateEnumPlot is an error type.
type CannotAggregateEnumPlot struct {
	errorInstanceID uuid.UUID
	cannotAggregateEnumPlot
	cause error
	stack werror.StackTrace
}

// IsCannotAggregateEnumPlot returns true if err is an instance of CannotAggregateEnumPlot.
func IsCannotAggregateEnumPlot(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CannotAggregateEnumPlot)
	return ok
}

func (e *CannotAggregateEnumPlot) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:CannotAggregateEnumPlot (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CannotAggregateEnumPlot) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CannotAggregateEnumPlot) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CannotAggregateEnumPlot) Message() string {
	return "INVALID_ARGUMENT Compute:CannotAggregateEnumPlot"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CannotAggregateEnumPlot) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CannotAggregateEnumPlot) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CannotAggregateEnumPlot) Name() string {
	return "Compute:CannotAggregateEnumPlot"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CannotAggregateEnumPlot) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CannotAggregateEnumPlot) Parameters() map[string]interface{} {
	return map[string]interface{}{"aggregationType": e.AggregationType}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CannotAggregateEnumPlot) safeParams() map[string]interface{} {
	return map[string]interface{}{"aggregationType": e.AggregationType, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotAggregateEnumPlot) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CannotAggregateEnumPlot) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotAggregateEnumPlot) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CannotAggregateEnumPlot) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.cannotAggregateEnumPlot)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:CannotAggregateEnumPlot", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CannotAggregateEnumPlot) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters cannotAggregateEnumPlot
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.cannotAggregateEnumPlot = parameters
	return nil
}

type cannotCompileRegexp struct {
	QueryId *uuid.UUID `json:"queryId,omitempty"`
}

func (o cannotCompileRegexp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *cannotCompileRegexp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCannotCompileRegexp returns new instance of CannotCompileRegexp error.
func NewCannotCompileRegexp(queryIdArg *uuid.UUID) *CannotCompileRegexp {
	return &CannotCompileRegexp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cannotCompileRegexp: cannotCompileRegexp{QueryId: queryIdArg}}
}

// WrapWithCannotCompileRegexp returns new instance of CannotCompileRegexp error wrapping an existing error.
func WrapWithCannotCompileRegexp(err error, queryIdArg *uuid.UUID) *CannotCompileRegexp {
	return &CannotCompileRegexp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, cannotCompileRegexp: cannotCompileRegexp{QueryId: queryIdArg}}
}

// CannotCompileRegexp is an error type.
// The regular expression could not be compiled.
type CannotCompileRegexp struct {
	errorInstanceID uuid.UUID
	cannotCompileRegexp
	cause error
	stack werror.StackTrace
}

// IsCannotCompileRegexp returns true if err is an instance of CannotCompileRegexp.
func IsCannotCompileRegexp(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CannotCompileRegexp)
	return ok
}

func (e *CannotCompileRegexp) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:CannotCompileRegexp (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CannotCompileRegexp) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CannotCompileRegexp) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CannotCompileRegexp) Message() string {
	return "INVALID_ARGUMENT Compute:CannotCompileRegexp"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CannotCompileRegexp) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CannotCompileRegexp) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CannotCompileRegexp) Name() string {
	return "Compute:CannotCompileRegexp"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CannotCompileRegexp) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CannotCompileRegexp) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CannotCompileRegexp) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotCompileRegexp) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CannotCompileRegexp) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotCompileRegexp) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CannotCompileRegexp) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.cannotCompileRegexp)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:CannotCompileRegexp", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CannotCompileRegexp) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters cannotCompileRegexp
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.cannotCompileRegexp = parameters
	return nil
}

type channelHasWrongType struct {
	SeriesType api.NominalDataType `json:"seriesType"`
	// The set of types that would have been compatible with the rest of the compute graph.
	ValidTypes []api.NominalDataType `conjure-docs:"The set of types that would have been compatible with the rest of the compute graph." json:"validTypes"`
	Channel    DataSourceAndChannel  `json:"channel"`
}

func (o channelHasWrongType) MarshalJSON() ([]byte, error) {
	if o.ValidTypes == nil {
		o.ValidTypes = make([]api.NominalDataType, 0)
	}
	type _tmpchannelHasWrongType channelHasWrongType
	return safejson.Marshal(_tmpchannelHasWrongType(o))
}

func (o *channelHasWrongType) UnmarshalJSON(data []byte) error {
	type _tmpchannelHasWrongType channelHasWrongType
	var rawchannelHasWrongType _tmpchannelHasWrongType
	if err := safejson.Unmarshal(data, &rawchannelHasWrongType); err != nil {
		return err
	}
	if rawchannelHasWrongType.ValidTypes == nil {
		rawchannelHasWrongType.ValidTypes = make([]api.NominalDataType, 0)
	}
	*o = channelHasWrongType(rawchannelHasWrongType)
	return nil
}

func (o channelHasWrongType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *channelHasWrongType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewChannelHasWrongType returns new instance of ChannelHasWrongType error.
func NewChannelHasWrongType(seriesTypeArg api.NominalDataType, validTypesArg []api.NominalDataType, channelArg DataSourceAndChannel) *ChannelHasWrongType {
	return &ChannelHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), channelHasWrongType: channelHasWrongType{SeriesType: seriesTypeArg, ValidTypes: validTypesArg, Channel: channelArg}}
}

// WrapWithChannelHasWrongType returns new instance of ChannelHasWrongType error wrapping an existing error.
func WrapWithChannelHasWrongType(err error, seriesTypeArg api.NominalDataType, validTypesArg []api.NominalDataType, channelArg DataSourceAndChannel) *ChannelHasWrongType {
	return &ChannelHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, channelHasWrongType: channelHasWrongType{SeriesType: seriesTypeArg, ValidTypes: validTypesArg, Channel: channelArg}}
}

// ChannelHasWrongType is an error type.
type ChannelHasWrongType struct {
	errorInstanceID uuid.UUID
	channelHasWrongType
	cause error
	stack werror.StackTrace
}

// IsChannelHasWrongType returns true if err is an instance of ChannelHasWrongType.
func IsChannelHasWrongType(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ChannelHasWrongType)
	return ok
}

func (e *ChannelHasWrongType) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:ChannelHasWrongType (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ChannelHasWrongType) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ChannelHasWrongType) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ChannelHasWrongType) Message() string {
	return "INVALID_ARGUMENT Compute:ChannelHasWrongType"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ChannelHasWrongType) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ChannelHasWrongType) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ChannelHasWrongType) Name() string {
	return "Compute:ChannelHasWrongType"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ChannelHasWrongType) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ChannelHasWrongType) Parameters() map[string]interface{} {
	return map[string]interface{}{"seriesType": e.SeriesType, "validTypes": e.ValidTypes, "channel": e.Channel}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ChannelHasWrongType) safeParams() map[string]interface{} {
	return map[string]interface{}{"seriesType": e.SeriesType, "validTypes": e.ValidTypes, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChannelHasWrongType) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ChannelHasWrongType) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"channel": e.Channel}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChannelHasWrongType) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ChannelHasWrongType) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.channelHasWrongType)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:ChannelHasWrongType", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ChannelHasWrongType) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters channelHasWrongType
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.channelHasWrongType = parameters
	return nil
}

type concurrentQueriesExceeded struct {
	QueryId uuid.UUID `json:"queryId"`
}

func (o concurrentQueriesExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *concurrentQueriesExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConcurrentQueriesExceeded returns new instance of ConcurrentQueriesExceeded error.
func NewConcurrentQueriesExceeded(queryIdArg uuid.UUID) *ConcurrentQueriesExceeded {
	return &ConcurrentQueriesExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), concurrentQueriesExceeded: concurrentQueriesExceeded{QueryId: queryIdArg}}
}

// WrapWithConcurrentQueriesExceeded returns new instance of ConcurrentQueriesExceeded error wrapping an existing error.
func WrapWithConcurrentQueriesExceeded(err error, queryIdArg uuid.UUID) *ConcurrentQueriesExceeded {
	return &ConcurrentQueriesExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, concurrentQueriesExceeded: concurrentQueriesExceeded{QueryId: queryIdArg}}
}

// ConcurrentQueriesExceeded is an error type.
// There are too many concurrent queries running.
type ConcurrentQueriesExceeded struct {
	errorInstanceID uuid.UUID
	concurrentQueriesExceeded
	cause error
	stack werror.StackTrace
}

// IsConcurrentQueriesExceeded returns true if err is an instance of ConcurrentQueriesExceeded.
func IsConcurrentQueriesExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConcurrentQueriesExceeded)
	return ok
}

func (e *ConcurrentQueriesExceeded) Error() string {
	return fmt.Sprintf("INTERNAL Compute:ConcurrentQueriesExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConcurrentQueriesExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConcurrentQueriesExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConcurrentQueriesExceeded) Message() string {
	return "INTERNAL Compute:ConcurrentQueriesExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConcurrentQueriesExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConcurrentQueriesExceeded) Code() errors.ErrorCode {
	return errors.Internal
}

// Name returns an error name identifying error type.
func (e *ConcurrentQueriesExceeded) Name() string {
	return "Compute:ConcurrentQueriesExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConcurrentQueriesExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConcurrentQueriesExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConcurrentQueriesExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConcurrentQueriesExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConcurrentQueriesExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConcurrentQueriesExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConcurrentQueriesExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.concurrentQueriesExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Internal, ErrorName: "Compute:ConcurrentQueriesExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConcurrentQueriesExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters concurrentQueriesExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.concurrentQueriesExceeded = parameters
	return nil
}

type converterInputUnitNotFound struct {
	InputUnit *api1.UnitSymbol `json:"inputUnit,omitempty"`
}

func (o converterInputUnitNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *converterInputUnitNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConverterInputUnitNotFound returns new instance of ConverterInputUnitNotFound error.
func NewConverterInputUnitNotFound(inputUnitArg *api1.UnitSymbol) *ConverterInputUnitNotFound {
	return &ConverterInputUnitNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), converterInputUnitNotFound: converterInputUnitNotFound{InputUnit: inputUnitArg}}
}

// WrapWithConverterInputUnitNotFound returns new instance of ConverterInputUnitNotFound error wrapping an existing error.
func WrapWithConverterInputUnitNotFound(err error, inputUnitArg *api1.UnitSymbol) *ConverterInputUnitNotFound {
	return &ConverterInputUnitNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, converterInputUnitNotFound: converterInputUnitNotFound{InputUnit: inputUnitArg}}
}

// ConverterInputUnitNotFound is an error type.
/*
A unit could not be found for the input series, or it did not exist in the unit system. The conversion could
not be computed.
*/
type ConverterInputUnitNotFound struct {
	errorInstanceID uuid.UUID
	converterInputUnitNotFound
	cause error
	stack werror.StackTrace
}

// IsConverterInputUnitNotFound returns true if err is an instance of ConverterInputUnitNotFound.
func IsConverterInputUnitNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConverterInputUnitNotFound)
	return ok
}

func (e *ConverterInputUnitNotFound) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:ConverterInputUnitNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConverterInputUnitNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConverterInputUnitNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConverterInputUnitNotFound) Message() string {
	return "INVALID_ARGUMENT Compute:ConverterInputUnitNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConverterInputUnitNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConverterInputUnitNotFound) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ConverterInputUnitNotFound) Name() string {
	return "Compute:ConverterInputUnitNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConverterInputUnitNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConverterInputUnitNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConverterInputUnitNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConverterInputUnitNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConverterInputUnitNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConverterInputUnitNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConverterInputUnitNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.converterInputUnitNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:ConverterInputUnitNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConverterInputUnitNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters converterInputUnitNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.converterInputUnitNotFound = parameters
	return nil
}

type converterOutputUnitNotFound struct {
	InputUnit api1.UnitSymbol `json:"inputUnit"`
}

func (o converterOutputUnitNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *converterOutputUnitNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConverterOutputUnitNotFound returns new instance of ConverterOutputUnitNotFound error.
func NewConverterOutputUnitNotFound(inputUnitArg api1.UnitSymbol) *ConverterOutputUnitNotFound {
	return &ConverterOutputUnitNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), converterOutputUnitNotFound: converterOutputUnitNotFound{InputUnit: inputUnitArg}}
}

// WrapWithConverterOutputUnitNotFound returns new instance of ConverterOutputUnitNotFound error wrapping an existing error.
func WrapWithConverterOutputUnitNotFound(err error, inputUnitArg api1.UnitSymbol) *ConverterOutputUnitNotFound {
	return &ConverterOutputUnitNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, converterOutputUnitNotFound: converterOutputUnitNotFound{InputUnit: inputUnitArg}}
}

// ConverterOutputUnitNotFound is an error type.
// The output unit symbol could not be found in the unit system. The conversion could not be computed.
type ConverterOutputUnitNotFound struct {
	errorInstanceID uuid.UUID
	converterOutputUnitNotFound
	cause error
	stack werror.StackTrace
}

// IsConverterOutputUnitNotFound returns true if err is an instance of ConverterOutputUnitNotFound.
func IsConverterOutputUnitNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConverterOutputUnitNotFound)
	return ok
}

func (e *ConverterOutputUnitNotFound) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:ConverterOutputUnitNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConverterOutputUnitNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConverterOutputUnitNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConverterOutputUnitNotFound) Message() string {
	return "INVALID_ARGUMENT Compute:ConverterOutputUnitNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConverterOutputUnitNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConverterOutputUnitNotFound) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ConverterOutputUnitNotFound) Name() string {
	return "Compute:ConverterOutputUnitNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConverterOutputUnitNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConverterOutputUnitNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConverterOutputUnitNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConverterOutputUnitNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConverterOutputUnitNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConverterOutputUnitNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConverterOutputUnitNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.converterOutputUnitNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:ConverterOutputUnitNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConverterOutputUnitNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters converterOutputUnitNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.converterOutputUnitNotFound = parameters
	return nil
}

type curveInvalidNegativeInputs struct{}

func (o curveInvalidNegativeInputs) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *curveInvalidNegativeInputs) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCurveInvalidNegativeInputs returns new instance of CurveInvalidNegativeInputs error.
func NewCurveInvalidNegativeInputs() *CurveInvalidNegativeInputs {
	return &CurveInvalidNegativeInputs{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), curveInvalidNegativeInputs: curveInvalidNegativeInputs{}}
}

// WrapWithCurveInvalidNegativeInputs returns new instance of CurveInvalidNegativeInputs error wrapping an existing error.
func WrapWithCurveInvalidNegativeInputs(err error) *CurveInvalidNegativeInputs {
	return &CurveInvalidNegativeInputs{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, curveInvalidNegativeInputs: curveInvalidNegativeInputs{}}
}

// CurveInvalidNegativeInputs is an error type.
/*
Some points in the input had negative (or zero) x-values. Power and logarithmic curve fits
do not allow negative (or zero) x-valued points.
*/
type CurveInvalidNegativeInputs struct {
	errorInstanceID uuid.UUID
	curveInvalidNegativeInputs
	cause error
	stack werror.StackTrace
}

// IsCurveInvalidNegativeInputs returns true if err is an instance of CurveInvalidNegativeInputs.
func IsCurveInvalidNegativeInputs(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CurveInvalidNegativeInputs)
	return ok
}

func (e *CurveInvalidNegativeInputs) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:CurveInvalidNegativeInputs (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CurveInvalidNegativeInputs) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CurveInvalidNegativeInputs) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CurveInvalidNegativeInputs) Message() string {
	return "INVALID_ARGUMENT Compute:CurveInvalidNegativeInputs"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CurveInvalidNegativeInputs) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CurveInvalidNegativeInputs) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CurveInvalidNegativeInputs) Name() string {
	return "Compute:CurveInvalidNegativeInputs"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CurveInvalidNegativeInputs) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CurveInvalidNegativeInputs) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CurveInvalidNegativeInputs) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CurveInvalidNegativeInputs) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CurveInvalidNegativeInputs) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CurveInvalidNegativeInputs) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CurveInvalidNegativeInputs) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.curveInvalidNegativeInputs)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:CurveInvalidNegativeInputs", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CurveInvalidNegativeInputs) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters curveInvalidNegativeInputs
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.curveInvalidNegativeInputs = parameters
	return nil
}

type curveUnequalInputLength struct{}

func (o curveUnequalInputLength) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *curveUnequalInputLength) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCurveUnequalInputLength returns new instance of CurveUnequalInputLength error.
func NewCurveUnequalInputLength() *CurveUnequalInputLength {
	return &CurveUnequalInputLength{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), curveUnequalInputLength: curveUnequalInputLength{}}
}

// WrapWithCurveUnequalInputLength returns new instance of CurveUnequalInputLength error wrapping an existing error.
func WrapWithCurveUnequalInputLength(err error) *CurveUnequalInputLength {
	return &CurveUnequalInputLength{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, curveUnequalInputLength: curveUnequalInputLength{}}
}

// CurveUnequalInputLength is an error type.
// The x and y inputs to fit a curve to do not have the same length.
type CurveUnequalInputLength struct {
	errorInstanceID uuid.UUID
	curveUnequalInputLength
	cause error
	stack werror.StackTrace
}

// IsCurveUnequalInputLength returns true if err is an instance of CurveUnequalInputLength.
func IsCurveUnequalInputLength(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CurveUnequalInputLength)
	return ok
}

func (e *CurveUnequalInputLength) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:CurveUnequalInputLength (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CurveUnequalInputLength) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CurveUnequalInputLength) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CurveUnequalInputLength) Message() string {
	return "INVALID_ARGUMENT Compute:CurveUnequalInputLength"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CurveUnequalInputLength) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CurveUnequalInputLength) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CurveUnequalInputLength) Name() string {
	return "Compute:CurveUnequalInputLength"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CurveUnequalInputLength) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CurveUnequalInputLength) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CurveUnequalInputLength) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CurveUnequalInputLength) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CurveUnequalInputLength) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CurveUnequalInputLength) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CurveUnequalInputLength) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.curveUnequalInputLength)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:CurveUnequalInputLength", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CurveUnequalInputLength) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters curveUnequalInputLength
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.curveUnequalInputLength = parameters
	return nil
}

type duplicateTimestamp struct {
	Timestamp api2.Timestamp `json:"timestamp"`
}

func (o duplicateTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *duplicateTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDuplicateTimestamp returns new instance of DuplicateTimestamp error.
func NewDuplicateTimestamp(timestampArg api2.Timestamp) *DuplicateTimestamp {
	return &DuplicateTimestamp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), duplicateTimestamp: duplicateTimestamp{Timestamp: timestampArg}}
}

// WrapWithDuplicateTimestamp returns new instance of DuplicateTimestamp error wrapping an existing error.
func WrapWithDuplicateTimestamp(err error, timestampArg api2.Timestamp) *DuplicateTimestamp {
	return &DuplicateTimestamp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, duplicateTimestamp: duplicateTimestamp{Timestamp: timestampArg}}
}

// DuplicateTimestamp is an error type.
type DuplicateTimestamp struct {
	errorInstanceID uuid.UUID
	duplicateTimestamp
	cause error
	stack werror.StackTrace
}

// IsDuplicateTimestamp returns true if err is an instance of DuplicateTimestamp.
func IsDuplicateTimestamp(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DuplicateTimestamp)
	return ok
}

func (e *DuplicateTimestamp) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:DuplicateTimestamp (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DuplicateTimestamp) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DuplicateTimestamp) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DuplicateTimestamp) Message() string {
	return "INVALID_ARGUMENT Compute:DuplicateTimestamp"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DuplicateTimestamp) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DuplicateTimestamp) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *DuplicateTimestamp) Name() string {
	return "Compute:DuplicateTimestamp"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DuplicateTimestamp) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DuplicateTimestamp) Parameters() map[string]interface{} {
	return map[string]interface{}{"timestamp": e.Timestamp}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DuplicateTimestamp) safeParams() map[string]interface{} {
	return map[string]interface{}{"timestamp": e.Timestamp, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DuplicateTimestamp) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DuplicateTimestamp) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DuplicateTimestamp) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DuplicateTimestamp) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.duplicateTimestamp)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:DuplicateTimestamp", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DuplicateTimestamp) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters duplicateTimestamp
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.duplicateTimestamp = parameters
	return nil
}

type emptyInput struct{}

func (o emptyInput) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *emptyInput) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewEmptyInput returns new instance of EmptyInput error.
func NewEmptyInput() *EmptyInput {
	return &EmptyInput{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), emptyInput: emptyInput{}}
}

// WrapWithEmptyInput returns new instance of EmptyInput error wrapping an existing error.
func WrapWithEmptyInput(err error) *EmptyInput {
	return &EmptyInput{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, emptyInput: emptyInput{}}
}

// EmptyInput is an error type.
// At least one input must be provided.
type EmptyInput struct {
	errorInstanceID uuid.UUID
	emptyInput
	cause error
	stack werror.StackTrace
}

// IsEmptyInput returns true if err is an instance of EmptyInput.
func IsEmptyInput(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*EmptyInput)
	return ok
}

func (e *EmptyInput) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:EmptyInput (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *EmptyInput) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *EmptyInput) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *EmptyInput) Message() string {
	return "INVALID_ARGUMENT Compute:EmptyInput"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *EmptyInput) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *EmptyInput) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *EmptyInput) Name() string {
	return "Compute:EmptyInput"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *EmptyInput) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *EmptyInput) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *EmptyInput) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *EmptyInput) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *EmptyInput) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *EmptyInput) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e EmptyInput) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.emptyInput)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:EmptyInput", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *EmptyInput) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters emptyInput
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.emptyInput = parameters
	return nil
}

type emptySet struct{}

func (o emptySet) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *emptySet) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewEmptySet returns new instance of EmptySet error.
func NewEmptySet() *EmptySet {
	return &EmptySet{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), emptySet: emptySet{}}
}

// WrapWithEmptySet returns new instance of EmptySet error wrapping an existing error.
func WrapWithEmptySet(err error) *EmptySet {
	return &EmptySet{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, emptySet: emptySet{}}
}

// EmptySet is an error type.
// The provided set must contain at least one element.
type EmptySet struct {
	errorInstanceID uuid.UUID
	emptySet
	cause error
	stack werror.StackTrace
}

// IsEmptySet returns true if err is an instance of EmptySet.
func IsEmptySet(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*EmptySet)
	return ok
}

func (e *EmptySet) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:EmptySet (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *EmptySet) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *EmptySet) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *EmptySet) Message() string {
	return "INVALID_ARGUMENT Compute:EmptySet"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *EmptySet) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *EmptySet) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *EmptySet) Name() string {
	return "Compute:EmptySet"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *EmptySet) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *EmptySet) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *EmptySet) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *EmptySet) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *EmptySet) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *EmptySet) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e EmptySet) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.emptySet)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:EmptySet", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *EmptySet) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters emptySet
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.emptySet = parameters
	return nil
}

type exponentialCurveInputTooLarge struct{}

func (o exponentialCurveInputTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *exponentialCurveInputTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewExponentialCurveInputTooLarge returns new instance of ExponentialCurveInputTooLarge error.
func NewExponentialCurveInputTooLarge() *ExponentialCurveInputTooLarge {
	return &ExponentialCurveInputTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), exponentialCurveInputTooLarge: exponentialCurveInputTooLarge{}}
}

// WrapWithExponentialCurveInputTooLarge returns new instance of ExponentialCurveInputTooLarge error wrapping an existing error.
func WrapWithExponentialCurveInputTooLarge(err error) *ExponentialCurveInputTooLarge {
	return &ExponentialCurveInputTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, exponentialCurveInputTooLarge: exponentialCurveInputTooLarge{}}
}

// ExponentialCurveInputTooLarge is an error type.
/*
Due to limits in how numbers are represented by computers, exponential fits cannot be performed
on data with x-values that are too large (> 650). This includes timestamp data based on the Time Unit
parameter to the curve fit - e.g. 1 second at millisecond scale is too large, as it is 1000 milliseconds.
*/
type ExponentialCurveInputTooLarge struct {
	errorInstanceID uuid.UUID
	exponentialCurveInputTooLarge
	cause error
	stack werror.StackTrace
}

// IsExponentialCurveInputTooLarge returns true if err is an instance of ExponentialCurveInputTooLarge.
func IsExponentialCurveInputTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ExponentialCurveInputTooLarge)
	return ok
}

func (e *ExponentialCurveInputTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:ExponentialCurveInputTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ExponentialCurveInputTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ExponentialCurveInputTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ExponentialCurveInputTooLarge) Message() string {
	return "INVALID_ARGUMENT Compute:ExponentialCurveInputTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ExponentialCurveInputTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ExponentialCurveInputTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ExponentialCurveInputTooLarge) Name() string {
	return "Compute:ExponentialCurveInputTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ExponentialCurveInputTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ExponentialCurveInputTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ExponentialCurveInputTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExponentialCurveInputTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ExponentialCurveInputTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExponentialCurveInputTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ExponentialCurveInputTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.exponentialCurveInputTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:ExponentialCurveInputTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ExponentialCurveInputTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters exponentialCurveInputTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.exponentialCurveInputTooLarge = parameters
	return nil
}

type externalDatabaseBadGateway struct {
	Type string `json:"type"`
}

func (o externalDatabaseBadGateway) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *externalDatabaseBadGateway) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewExternalDatabaseBadGateway returns new instance of ExternalDatabaseBadGateway error.
func NewExternalDatabaseBadGateway(typeArg string) *ExternalDatabaseBadGateway {
	return &ExternalDatabaseBadGateway{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), externalDatabaseBadGateway: externalDatabaseBadGateway{Type: typeArg}}
}

// WrapWithExternalDatabaseBadGateway returns new instance of ExternalDatabaseBadGateway error wrapping an existing error.
func WrapWithExternalDatabaseBadGateway(err error, typeArg string) *ExternalDatabaseBadGateway {
	return &ExternalDatabaseBadGateway{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, externalDatabaseBadGateway: externalDatabaseBadGateway{Type: typeArg}}
}

// ExternalDatabaseBadGateway is an error type.
// A bad gateway result was encountered while trying to fetch data from the external database.
type ExternalDatabaseBadGateway struct {
	errorInstanceID uuid.UUID
	externalDatabaseBadGateway
	cause error
	stack werror.StackTrace
}

// IsExternalDatabaseBadGateway returns true if err is an instance of ExternalDatabaseBadGateway.
func IsExternalDatabaseBadGateway(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ExternalDatabaseBadGateway)
	return ok
}

func (e *ExternalDatabaseBadGateway) Error() string {
	return fmt.Sprintf("CUSTOM_SERVER ExternalDatabase:ExternalDatabaseBadGateway (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ExternalDatabaseBadGateway) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ExternalDatabaseBadGateway) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ExternalDatabaseBadGateway) Message() string {
	return "CUSTOM_SERVER ExternalDatabase:ExternalDatabaseBadGateway"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ExternalDatabaseBadGateway) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ExternalDatabaseBadGateway) Code() errors.ErrorCode {
	return errors.CustomServer
}

// Name returns an error name identifying error type.
func (e *ExternalDatabaseBadGateway) Name() string {
	return "ExternalDatabase:ExternalDatabaseBadGateway"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ExternalDatabaseBadGateway) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ExternalDatabaseBadGateway) Parameters() map[string]interface{} {
	return map[string]interface{}{"type": e.Type}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ExternalDatabaseBadGateway) safeParams() map[string]interface{} {
	return map[string]interface{}{"type": e.Type, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExternalDatabaseBadGateway) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ExternalDatabaseBadGateway) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExternalDatabaseBadGateway) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ExternalDatabaseBadGateway) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.externalDatabaseBadGateway)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.CustomServer, ErrorName: "ExternalDatabase:ExternalDatabaseBadGateway", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ExternalDatabaseBadGateway) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters externalDatabaseBadGateway
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.externalDatabaseBadGateway = parameters
	return nil
}

type externalDatabaseGatewayTimeout struct {
	Type string `json:"type"`
}

func (o externalDatabaseGatewayTimeout) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *externalDatabaseGatewayTimeout) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewExternalDatabaseGatewayTimeout returns new instance of ExternalDatabaseGatewayTimeout error.
func NewExternalDatabaseGatewayTimeout(typeArg string) *ExternalDatabaseGatewayTimeout {
	return &ExternalDatabaseGatewayTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), externalDatabaseGatewayTimeout: externalDatabaseGatewayTimeout{Type: typeArg}}
}

// WrapWithExternalDatabaseGatewayTimeout returns new instance of ExternalDatabaseGatewayTimeout error wrapping an existing error.
func WrapWithExternalDatabaseGatewayTimeout(err error, typeArg string) *ExternalDatabaseGatewayTimeout {
	return &ExternalDatabaseGatewayTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, externalDatabaseGatewayTimeout: externalDatabaseGatewayTimeout{Type: typeArg}}
}

// ExternalDatabaseGatewayTimeout is an error type.
// A gateway timeout was encountered while trying to fetch data from the external database.
type ExternalDatabaseGatewayTimeout struct {
	errorInstanceID uuid.UUID
	externalDatabaseGatewayTimeout
	cause error
	stack werror.StackTrace
}

// IsExternalDatabaseGatewayTimeout returns true if err is an instance of ExternalDatabaseGatewayTimeout.
func IsExternalDatabaseGatewayTimeout(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ExternalDatabaseGatewayTimeout)
	return ok
}

func (e *ExternalDatabaseGatewayTimeout) Error() string {
	return fmt.Sprintf("CUSTOM_SERVER ExternalDatabase:ExternalDatabaseGatewayTimeout (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ExternalDatabaseGatewayTimeout) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ExternalDatabaseGatewayTimeout) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ExternalDatabaseGatewayTimeout) Message() string {
	return "CUSTOM_SERVER ExternalDatabase:ExternalDatabaseGatewayTimeout"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ExternalDatabaseGatewayTimeout) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ExternalDatabaseGatewayTimeout) Code() errors.ErrorCode {
	return errors.CustomServer
}

// Name returns an error name identifying error type.
func (e *ExternalDatabaseGatewayTimeout) Name() string {
	return "ExternalDatabase:ExternalDatabaseGatewayTimeout"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ExternalDatabaseGatewayTimeout) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ExternalDatabaseGatewayTimeout) Parameters() map[string]interface{} {
	return map[string]interface{}{"type": e.Type}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ExternalDatabaseGatewayTimeout) safeParams() map[string]interface{} {
	return map[string]interface{}{"type": e.Type, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExternalDatabaseGatewayTimeout) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ExternalDatabaseGatewayTimeout) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExternalDatabaseGatewayTimeout) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ExternalDatabaseGatewayTimeout) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.externalDatabaseGatewayTimeout)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.CustomServer, ErrorName: "ExternalDatabase:ExternalDatabaseGatewayTimeout", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ExternalDatabaseGatewayTimeout) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters externalDatabaseGatewayTimeout
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.externalDatabaseGatewayTimeout = parameters
	return nil
}

type externalDatabaseSocketTimeout struct {
	Type string `json:"type"`
}

func (o externalDatabaseSocketTimeout) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *externalDatabaseSocketTimeout) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewExternalDatabaseSocketTimeout returns new instance of ExternalDatabaseSocketTimeout error.
func NewExternalDatabaseSocketTimeout(typeArg string) *ExternalDatabaseSocketTimeout {
	return &ExternalDatabaseSocketTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), externalDatabaseSocketTimeout: externalDatabaseSocketTimeout{Type: typeArg}}
}

// WrapWithExternalDatabaseSocketTimeout returns new instance of ExternalDatabaseSocketTimeout error wrapping an existing error.
func WrapWithExternalDatabaseSocketTimeout(err error, typeArg string) *ExternalDatabaseSocketTimeout {
	return &ExternalDatabaseSocketTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, externalDatabaseSocketTimeout: externalDatabaseSocketTimeout{Type: typeArg}}
}

// ExternalDatabaseSocketTimeout is an error type.
// A socket timeout was encountered while trying to fetch data from the external database.
type ExternalDatabaseSocketTimeout struct {
	errorInstanceID uuid.UUID
	externalDatabaseSocketTimeout
	cause error
	stack werror.StackTrace
}

// IsExternalDatabaseSocketTimeout returns true if err is an instance of ExternalDatabaseSocketTimeout.
func IsExternalDatabaseSocketTimeout(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ExternalDatabaseSocketTimeout)
	return ok
}

func (e *ExternalDatabaseSocketTimeout) Error() string {
	return fmt.Sprintf("CUSTOM_SERVER ExternalDatabase:ExternalDatabaseSocketTimeout (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ExternalDatabaseSocketTimeout) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ExternalDatabaseSocketTimeout) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ExternalDatabaseSocketTimeout) Message() string {
	return "CUSTOM_SERVER ExternalDatabase:ExternalDatabaseSocketTimeout"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ExternalDatabaseSocketTimeout) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ExternalDatabaseSocketTimeout) Code() errors.ErrorCode {
	return errors.CustomServer
}

// Name returns an error name identifying error type.
func (e *ExternalDatabaseSocketTimeout) Name() string {
	return "ExternalDatabase:ExternalDatabaseSocketTimeout"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ExternalDatabaseSocketTimeout) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ExternalDatabaseSocketTimeout) Parameters() map[string]interface{} {
	return map[string]interface{}{"type": e.Type}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ExternalDatabaseSocketTimeout) safeParams() map[string]interface{} {
	return map[string]interface{}{"type": e.Type, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExternalDatabaseSocketTimeout) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ExternalDatabaseSocketTimeout) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ExternalDatabaseSocketTimeout) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ExternalDatabaseSocketTimeout) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.externalDatabaseSocketTimeout)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.CustomServer, ErrorName: "ExternalDatabase:ExternalDatabaseSocketTimeout", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ExternalDatabaseSocketTimeout) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters externalDatabaseSocketTimeout
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.externalDatabaseSocketTimeout = parameters
	return nil
}

type frequencyDomainWindowEmpty struct{}

func (o frequencyDomainWindowEmpty) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *frequencyDomainWindowEmpty) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewFrequencyDomainWindowEmpty returns new instance of FrequencyDomainWindowEmpty error.
func NewFrequencyDomainWindowEmpty() *FrequencyDomainWindowEmpty {
	return &FrequencyDomainWindowEmpty{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), frequencyDomainWindowEmpty: frequencyDomainWindowEmpty{}}
}

// WrapWithFrequencyDomainWindowEmpty returns new instance of FrequencyDomainWindowEmpty error wrapping an existing error.
func WrapWithFrequencyDomainWindowEmpty(err error) *FrequencyDomainWindowEmpty {
	return &FrequencyDomainWindowEmpty{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, frequencyDomainWindowEmpty: frequencyDomainWindowEmpty{}}
}

// FrequencyDomainWindowEmpty is an error type.
// The selected window for the frequency domain is empty. Try again with a larger time range.
type FrequencyDomainWindowEmpty struct {
	errorInstanceID uuid.UUID
	frequencyDomainWindowEmpty
	cause error
	stack werror.StackTrace
}

// IsFrequencyDomainWindowEmpty returns true if err is an instance of FrequencyDomainWindowEmpty.
func IsFrequencyDomainWindowEmpty(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*FrequencyDomainWindowEmpty)
	return ok
}

func (e *FrequencyDomainWindowEmpty) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:FrequencyDomainWindowEmpty (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *FrequencyDomainWindowEmpty) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *FrequencyDomainWindowEmpty) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *FrequencyDomainWindowEmpty) Message() string {
	return "INVALID_ARGUMENT Compute:FrequencyDomainWindowEmpty"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *FrequencyDomainWindowEmpty) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *FrequencyDomainWindowEmpty) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *FrequencyDomainWindowEmpty) Name() string {
	return "Compute:FrequencyDomainWindowEmpty"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *FrequencyDomainWindowEmpty) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *FrequencyDomainWindowEmpty) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *FrequencyDomainWindowEmpty) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *FrequencyDomainWindowEmpty) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *FrequencyDomainWindowEmpty) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *FrequencyDomainWindowEmpty) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e FrequencyDomainWindowEmpty) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.frequencyDomainWindowEmpty)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:FrequencyDomainWindowEmpty", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *FrequencyDomainWindowEmpty) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters frequencyDomainWindowEmpty
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.frequencyDomainWindowEmpty = parameters
	return nil
}

type frequencyDomainWindowTooLarge struct{}

func (o frequencyDomainWindowTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *frequencyDomainWindowTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewFrequencyDomainWindowTooLarge returns new instance of FrequencyDomainWindowTooLarge error.
func NewFrequencyDomainWindowTooLarge() *FrequencyDomainWindowTooLarge {
	return &FrequencyDomainWindowTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), frequencyDomainWindowTooLarge: frequencyDomainWindowTooLarge{}}
}

// WrapWithFrequencyDomainWindowTooLarge returns new instance of FrequencyDomainWindowTooLarge error wrapping an existing error.
func WrapWithFrequencyDomainWindowTooLarge(err error) *FrequencyDomainWindowTooLarge {
	return &FrequencyDomainWindowTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, frequencyDomainWindowTooLarge: frequencyDomainWindowTooLarge{}}
}

// FrequencyDomainWindowTooLarge is an error type.
// The selected window for the frequency domain is too large. Try again with a smaller time range.
type FrequencyDomainWindowTooLarge struct {
	errorInstanceID uuid.UUID
	frequencyDomainWindowTooLarge
	cause error
	stack werror.StackTrace
}

// IsFrequencyDomainWindowTooLarge returns true if err is an instance of FrequencyDomainWindowTooLarge.
func IsFrequencyDomainWindowTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*FrequencyDomainWindowTooLarge)
	return ok
}

func (e *FrequencyDomainWindowTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:FrequencyDomainWindowTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *FrequencyDomainWindowTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *FrequencyDomainWindowTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *FrequencyDomainWindowTooLarge) Message() string {
	return "INVALID_ARGUMENT Compute:FrequencyDomainWindowTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *FrequencyDomainWindowTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *FrequencyDomainWindowTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *FrequencyDomainWindowTooLarge) Name() string {
	return "Compute:FrequencyDomainWindowTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *FrequencyDomainWindowTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *FrequencyDomainWindowTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *FrequencyDomainWindowTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *FrequencyDomainWindowTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *FrequencyDomainWindowTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *FrequencyDomainWindowTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e FrequencyDomainWindowTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.frequencyDomainWindowTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:FrequencyDomainWindowTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *FrequencyDomainWindowTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters frequencyDomainWindowTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.frequencyDomainWindowTooLarge = parameters
	return nil
}

type granularityMismatch struct{}

func (o granularityMismatch) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *granularityMismatch) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewGranularityMismatch returns new instance of GranularityMismatch error.
func NewGranularityMismatch() *GranularityMismatch {
	return &GranularityMismatch{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), granularityMismatch: granularityMismatch{}}
}

// WrapWithGranularityMismatch returns new instance of GranularityMismatch error wrapping an existing error.
func WrapWithGranularityMismatch(err error) *GranularityMismatch {
	return &GranularityMismatch{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, granularityMismatch: granularityMismatch{}}
}

// GranularityMismatch is an error type.
// Some operations that require matching granularity did not have matching granularity.
type GranularityMismatch struct {
	errorInstanceID uuid.UUID
	granularityMismatch
	cause error
	stack werror.StackTrace
}

// IsGranularityMismatch returns true if err is an instance of GranularityMismatch.
func IsGranularityMismatch(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*GranularityMismatch)
	return ok
}

func (e *GranularityMismatch) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:GranularityMismatch (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *GranularityMismatch) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *GranularityMismatch) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *GranularityMismatch) Message() string {
	return "INVALID_ARGUMENT Compute:GranularityMismatch"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *GranularityMismatch) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *GranularityMismatch) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *GranularityMismatch) Name() string {
	return "Compute:GranularityMismatch"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *GranularityMismatch) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *GranularityMismatch) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *GranularityMismatch) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *GranularityMismatch) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *GranularityMismatch) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *GranularityMismatch) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e GranularityMismatch) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.granularityMismatch)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:GranularityMismatch", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *GranularityMismatch) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters granularityMismatch
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.granularityMismatch = parameters
	return nil
}

type groupByMissingTag struct{}

func (o groupByMissingTag) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *groupByMissingTag) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewGroupByMissingTag returns new instance of GroupByMissingTag error.
func NewGroupByMissingTag() *GroupByMissingTag {
	return &GroupByMissingTag{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), groupByMissingTag: groupByMissingTag{}}
}

// WrapWithGroupByMissingTag returns new instance of GroupByMissingTag error wrapping an existing error.
func WrapWithGroupByMissingTag(err error) *GroupByMissingTag {
	return &GroupByMissingTag{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, groupByMissingTag: groupByMissingTag{}}
}

// GroupByMissingTag is an error type.
// Attempted to group by a tag that does not exist.
type GroupByMissingTag struct {
	errorInstanceID uuid.UUID
	groupByMissingTag
	cause error
	stack werror.StackTrace
}

// IsGroupByMissingTag returns true if err is an instance of GroupByMissingTag.
func IsGroupByMissingTag(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*GroupByMissingTag)
	return ok
}

func (e *GroupByMissingTag) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:GroupByMissingTag (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *GroupByMissingTag) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *GroupByMissingTag) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *GroupByMissingTag) Message() string {
	return "INVALID_ARGUMENT Compute:GroupByMissingTag"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *GroupByMissingTag) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *GroupByMissingTag) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *GroupByMissingTag) Name() string {
	return "Compute:GroupByMissingTag"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *GroupByMissingTag) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *GroupByMissingTag) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *GroupByMissingTag) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *GroupByMissingTag) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *GroupByMissingTag) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *GroupByMissingTag) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e GroupByMissingTag) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.groupByMissingTag)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:GroupByMissingTag", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *GroupByMissingTag) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters groupByMissingTag
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.groupByMissingTag = parameters
	return nil
}

type groupByTagsNotSubset struct {
	Group1 []string `json:"group1"`
	Group2 []string `json:"group2"`
}

func (o groupByTagsNotSubset) MarshalJSON() ([]byte, error) {
	if o.Group1 == nil {
		o.Group1 = make([]string, 0)
	}
	if o.Group2 == nil {
		o.Group2 = make([]string, 0)
	}
	type _tmpgroupByTagsNotSubset groupByTagsNotSubset
	return safejson.Marshal(_tmpgroupByTagsNotSubset(o))
}

func (o *groupByTagsNotSubset) UnmarshalJSON(data []byte) error {
	type _tmpgroupByTagsNotSubset groupByTagsNotSubset
	var rawgroupByTagsNotSubset _tmpgroupByTagsNotSubset
	if err := safejson.Unmarshal(data, &rawgroupByTagsNotSubset); err != nil {
		return err
	}
	if rawgroupByTagsNotSubset.Group1 == nil {
		rawgroupByTagsNotSubset.Group1 = make([]string, 0)
	}
	if rawgroupByTagsNotSubset.Group2 == nil {
		rawgroupByTagsNotSubset.Group2 = make([]string, 0)
	}
	*o = groupByTagsNotSubset(rawgroupByTagsNotSubset)
	return nil
}

func (o groupByTagsNotSubset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *groupByTagsNotSubset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewGroupByTagsNotSubset returns new instance of GroupByTagsNotSubset error.
func NewGroupByTagsNotSubset(group1Arg []string, group2Arg []string) *GroupByTagsNotSubset {
	return &GroupByTagsNotSubset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), groupByTagsNotSubset: groupByTagsNotSubset{Group1: group1Arg, Group2: group2Arg}}
}

// WrapWithGroupByTagsNotSubset returns new instance of GroupByTagsNotSubset error wrapping an existing error.
func WrapWithGroupByTagsNotSubset(err error, group1Arg []string, group2Arg []string) *GroupByTagsNotSubset {
	return &GroupByTagsNotSubset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, groupByTagsNotSubset: groupByTagsNotSubset{Group1: group1Arg, Group2: group2Arg}}
}

// GroupByTagsNotSubset is an error type.
// Group by tags must be equal, or one set must be a subset of the other.
type GroupByTagsNotSubset struct {
	errorInstanceID uuid.UUID
	groupByTagsNotSubset
	cause error
	stack werror.StackTrace
}

// IsGroupByTagsNotSubset returns true if err is an instance of GroupByTagsNotSubset.
func IsGroupByTagsNotSubset(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*GroupByTagsNotSubset)
	return ok
}

func (e *GroupByTagsNotSubset) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:GroupByTagsNotSubset (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *GroupByTagsNotSubset) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *GroupByTagsNotSubset) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *GroupByTagsNotSubset) Message() string {
	return "INVALID_ARGUMENT Compute:GroupByTagsNotSubset"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *GroupByTagsNotSubset) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *GroupByTagsNotSubset) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *GroupByTagsNotSubset) Name() string {
	return "Compute:GroupByTagsNotSubset"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *GroupByTagsNotSubset) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *GroupByTagsNotSubset) Parameters() map[string]interface{} {
	return map[string]interface{}{"group1": e.Group1, "group2": e.Group2}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *GroupByTagsNotSubset) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *GroupByTagsNotSubset) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *GroupByTagsNotSubset) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"group1": e.Group1, "group2": e.Group2}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *GroupByTagsNotSubset) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e GroupByTagsNotSubset) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.groupByTagsNotSubset)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:GroupByTagsNotSubset", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *GroupByTagsNotSubset) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters groupByTagsNotSubset
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.groupByTagsNotSubset = parameters
	return nil
}

type groupBysNotSupportedForQuery struct {
	ComputeNode string `json:"computeNode"`
}

func (o groupBysNotSupportedForQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *groupBysNotSupportedForQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewGroupBysNotSupportedForQuery returns new instance of GroupBysNotSupportedForQuery error.
func NewGroupBysNotSupportedForQuery(computeNodeArg string) *GroupBysNotSupportedForQuery {
	return &GroupBysNotSupportedForQuery{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), groupBysNotSupportedForQuery: groupBysNotSupportedForQuery{ComputeNode: computeNodeArg}}
}

// WrapWithGroupBysNotSupportedForQuery returns new instance of GroupBysNotSupportedForQuery error wrapping an existing error.
func WrapWithGroupBysNotSupportedForQuery(err error, computeNodeArg string) *GroupBysNotSupportedForQuery {
	return &GroupBysNotSupportedForQuery{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, groupBysNotSupportedForQuery: groupBysNotSupportedForQuery{ComputeNode: computeNodeArg}}
}

// GroupBysNotSupportedForQuery is an error type.
// Group by queries are not supported for the compute node supplied
type GroupBysNotSupportedForQuery struct {
	errorInstanceID uuid.UUID
	groupBysNotSupportedForQuery
	cause error
	stack werror.StackTrace
}

// IsGroupBysNotSupportedForQuery returns true if err is an instance of GroupBysNotSupportedForQuery.
func IsGroupBysNotSupportedForQuery(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*GroupBysNotSupportedForQuery)
	return ok
}

func (e *GroupBysNotSupportedForQuery) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:GroupBysNotSupportedForQuery (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *GroupBysNotSupportedForQuery) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *GroupBysNotSupportedForQuery) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *GroupBysNotSupportedForQuery) Message() string {
	return "INVALID_ARGUMENT Compute:GroupBysNotSupportedForQuery"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *GroupBysNotSupportedForQuery) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *GroupBysNotSupportedForQuery) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *GroupBysNotSupportedForQuery) Name() string {
	return "Compute:GroupBysNotSupportedForQuery"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *GroupBysNotSupportedForQuery) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *GroupBysNotSupportedForQuery) Parameters() map[string]interface{} {
	return map[string]interface{}{"computeNode": e.ComputeNode}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *GroupBysNotSupportedForQuery) safeParams() map[string]interface{} {
	return map[string]interface{}{"computeNode": e.ComputeNode, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *GroupBysNotSupportedForQuery) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *GroupBysNotSupportedForQuery) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *GroupBysNotSupportedForQuery) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e GroupBysNotSupportedForQuery) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.groupBysNotSupportedForQuery)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:GroupBysNotSupportedForQuery", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *GroupBysNotSupportedForQuery) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters groupBysNotSupportedForQuery
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.groupBysNotSupportedForQuery = parameters
	return nil
}

type invalidBitOperation struct {
	OperationType string `json:"operationType"`
	Value         int    `json:"value"`
}

func (o invalidBitOperation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidBitOperation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidBitOperation returns new instance of InvalidBitOperation error.
func NewInvalidBitOperation(operationTypeArg string, valueArg int) *InvalidBitOperation {
	return &InvalidBitOperation{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidBitOperation: invalidBitOperation{OperationType: operationTypeArg, Value: valueArg}}
}

// WrapWithInvalidBitOperation returns new instance of InvalidBitOperation error wrapping an existing error.
func WrapWithInvalidBitOperation(err error, operationTypeArg string, valueArg int) *InvalidBitOperation {
	return &InvalidBitOperation{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidBitOperation: invalidBitOperation{OperationType: operationTypeArg, Value: valueArg}}
}

// InvalidBitOperation is an error type.
// The bit operation is invalid due to the index or operand being out of range. Valid range - [0, 63].
type InvalidBitOperation struct {
	errorInstanceID uuid.UUID
	invalidBitOperation
	cause error
	stack werror.StackTrace
}

// IsInvalidBitOperation returns true if err is an instance of InvalidBitOperation.
func IsInvalidBitOperation(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidBitOperation)
	return ok
}

func (e *InvalidBitOperation) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidBitOperation (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidBitOperation) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidBitOperation) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidBitOperation) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidBitOperation"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidBitOperation) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidBitOperation) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidBitOperation) Name() string {
	return "Compute:InvalidBitOperation"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidBitOperation) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidBitOperation) Parameters() map[string]interface{} {
	return map[string]interface{}{"operationType": e.OperationType, "value": e.Value}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidBitOperation) safeParams() map[string]interface{} {
	return map[string]interface{}{"operationType": e.OperationType, "value": e.Value, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidBitOperation) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidBitOperation) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidBitOperation) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidBitOperation) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidBitOperation)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidBitOperation", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidBitOperation) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidBitOperation
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidBitOperation = parameters
	return nil
}

type invalidExpression struct {
	Expression string `json:"expression"`
}

func (o invalidExpression) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidExpression) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidExpression returns new instance of InvalidExpression error.
func NewInvalidExpression(expressionArg string) *InvalidExpression {
	return &InvalidExpression{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidExpression: invalidExpression{Expression: expressionArg}}
}

// WrapWithInvalidExpression returns new instance of InvalidExpression error wrapping an existing error.
func WrapWithInvalidExpression(err error, expressionArg string) *InvalidExpression {
	return &InvalidExpression{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidExpression: invalidExpression{Expression: expressionArg}}
}

// InvalidExpression is an error type.
type InvalidExpression struct {
	errorInstanceID uuid.UUID
	invalidExpression
	cause error
	stack werror.StackTrace
}

// IsInvalidExpression returns true if err is an instance of InvalidExpression.
func IsInvalidExpression(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidExpression)
	return ok
}

func (e *InvalidExpression) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidExpression (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidExpression) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidExpression) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidExpression) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidExpression"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidExpression) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidExpression) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidExpression) Name() string {
	return "Compute:InvalidExpression"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidExpression) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidExpression) Parameters() map[string]interface{} {
	return map[string]interface{}{"expression": e.Expression}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidExpression) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidExpression) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidExpression) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"expression": e.Expression}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidExpression) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidExpression) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidExpression)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidExpression", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidExpression) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidExpression
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidExpression = parameters
	return nil
}

type invalidFieldName struct {
	FieldName string `json:"fieldName"`
}

func (o invalidFieldName) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidFieldName) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidFieldName returns new instance of InvalidFieldName error.
func NewInvalidFieldName(fieldNameArg string) *InvalidFieldName {
	return &InvalidFieldName{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidFieldName: invalidFieldName{FieldName: fieldNameArg}}
}

// WrapWithInvalidFieldName returns new instance of InvalidFieldName error wrapping an existing error.
func WrapWithInvalidFieldName(err error, fieldNameArg string) *InvalidFieldName {
	return &InvalidFieldName{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidFieldName: invalidFieldName{FieldName: fieldNameArg}}
}

// InvalidFieldName is an error type.
// Struct field names cannot contain '.'
type InvalidFieldName struct {
	errorInstanceID uuid.UUID
	invalidFieldName
	cause error
	stack werror.StackTrace
}

// IsInvalidFieldName returns true if err is an instance of InvalidFieldName.
func IsInvalidFieldName(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidFieldName)
	return ok
}

func (e *InvalidFieldName) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidFieldName (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidFieldName) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidFieldName) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidFieldName) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidFieldName"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidFieldName) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidFieldName) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidFieldName) Name() string {
	return "Compute:InvalidFieldName"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidFieldName) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidFieldName) Parameters() map[string]interface{} {
	return map[string]interface{}{"fieldName": e.FieldName}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidFieldName) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidFieldName) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidFieldName) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"fieldName": e.FieldName}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidFieldName) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidFieldName) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidFieldName)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidFieldName", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidFieldName) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidFieldName
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidFieldName = parameters
	return nil
}

type invalidLiteralRange struct {
	Start *api2.Timestamp `json:"start,omitempty"`
	End   *api2.Timestamp `json:"end,omitempty"`
}

func (o invalidLiteralRange) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidLiteralRange) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidLiteralRange returns new instance of InvalidLiteralRange error.
func NewInvalidLiteralRange(startArg *api2.Timestamp, endArg *api2.Timestamp) *InvalidLiteralRange {
	return &InvalidLiteralRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidLiteralRange: invalidLiteralRange{Start: startArg, End: endArg}}
}

// WrapWithInvalidLiteralRange returns new instance of InvalidLiteralRange error wrapping an existing error.
func WrapWithInvalidLiteralRange(err error, startArg *api2.Timestamp, endArg *api2.Timestamp) *InvalidLiteralRange {
	return &InvalidLiteralRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidLiteralRange: invalidLiteralRange{Start: startArg, End: endArg}}
}

// InvalidLiteralRange is an error type.
/*
The starting timestamp of a range cannot be greater than or equal to the end timestamp.
At least one of start and end timestamps must be present.
Only the first range when sorted may omit the start, and only the last may omit the end.
*/
type InvalidLiteralRange struct {
	errorInstanceID uuid.UUID
	invalidLiteralRange
	cause error
	stack werror.StackTrace
}

// IsInvalidLiteralRange returns true if err is an instance of InvalidLiteralRange.
func IsInvalidLiteralRange(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidLiteralRange)
	return ok
}

func (e *InvalidLiteralRange) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidLiteralRange (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidLiteralRange) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidLiteralRange) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidLiteralRange) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidLiteralRange"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidLiteralRange) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidLiteralRange) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidLiteralRange) Name() string {
	return "Compute:InvalidLiteralRange"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidLiteralRange) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidLiteralRange) Parameters() map[string]interface{} {
	return map[string]interface{}{"start": e.Start, "end": e.End}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidLiteralRange) safeParams() map[string]interface{} {
	return map[string]interface{}{"start": e.Start, "end": e.End, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidLiteralRange) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidLiteralRange) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidLiteralRange) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidLiteralRange) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidLiteralRange)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidLiteralRange", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidLiteralRange) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidLiteralRange
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidLiteralRange = parameters
	return nil
}

type invalidNumericOutputFields struct{}

func (o invalidNumericOutputFields) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidNumericOutputFields) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidNumericOutputFields returns new instance of InvalidNumericOutputFields error.
func NewInvalidNumericOutputFields() *InvalidNumericOutputFields {
	return &InvalidNumericOutputFields{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidNumericOutputFields: invalidNumericOutputFields{}}
}

// WrapWithInvalidNumericOutputFields returns new instance of InvalidNumericOutputFields error wrapping an existing error.
func WrapWithInvalidNumericOutputFields(err error) *InvalidNumericOutputFields {
	return &InvalidNumericOutputFields{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidNumericOutputFields: invalidNumericOutputFields{}}
}

// InvalidNumericOutputFields is an error type.
/*
Numeric output fields can only be specified on Arrow format numeric series requests.
At least one field must be specified.
*/
type InvalidNumericOutputFields struct {
	errorInstanceID uuid.UUID
	invalidNumericOutputFields
	cause error
	stack werror.StackTrace
}

// IsInvalidNumericOutputFields returns true if err is an instance of InvalidNumericOutputFields.
func IsInvalidNumericOutputFields(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidNumericOutputFields)
	return ok
}

func (e *InvalidNumericOutputFields) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidNumericOutputFields (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidNumericOutputFields) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidNumericOutputFields) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidNumericOutputFields) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidNumericOutputFields"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidNumericOutputFields) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidNumericOutputFields) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidNumericOutputFields) Name() string {
	return "Compute:InvalidNumericOutputFields"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidNumericOutputFields) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidNumericOutputFields) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidNumericOutputFields) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidNumericOutputFields) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidNumericOutputFields) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidNumericOutputFields) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidNumericOutputFields) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidNumericOutputFields)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidNumericOutputFields", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidNumericOutputFields) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidNumericOutputFields
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidNumericOutputFields = parameters
	return nil
}

type invalidPlotType struct {
	ExpectedType string `json:"expectedType"`
}

func (o invalidPlotType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidPlotType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidPlotType returns new instance of InvalidPlotType error.
func NewInvalidPlotType(expectedTypeArg string) *InvalidPlotType {
	return &InvalidPlotType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidPlotType: invalidPlotType{ExpectedType: expectedTypeArg}}
}

// WrapWithInvalidPlotType returns new instance of InvalidPlotType error wrapping an existing error.
func WrapWithInvalidPlotType(err error, expectedTypeArg string) *InvalidPlotType {
	return &InvalidPlotType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidPlotType: invalidPlotType{ExpectedType: expectedTypeArg}}
}

// InvalidPlotType is an error type.
type InvalidPlotType struct {
	errorInstanceID uuid.UUID
	invalidPlotType
	cause error
	stack werror.StackTrace
}

// IsInvalidPlotType returns true if err is an instance of InvalidPlotType.
func IsInvalidPlotType(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidPlotType)
	return ok
}

func (e *InvalidPlotType) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidPlotType (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidPlotType) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidPlotType) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidPlotType) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidPlotType"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidPlotType) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidPlotType) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidPlotType) Name() string {
	return "Compute:InvalidPlotType"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidPlotType) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidPlotType) Parameters() map[string]interface{} {
	return map[string]interface{}{"expectedType": e.ExpectedType}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidPlotType) safeParams() map[string]interface{} {
	return map[string]interface{}{"expectedType": e.ExpectedType, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidPlotType) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidPlotType) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidPlotType) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidPlotType) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidPlotType)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidPlotType", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidPlotType) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidPlotType
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidPlotType = parameters
	return nil
}

type invalidRangeNodeStartAfterViewRange struct {
	NodeStart api2.Timestamp `json:"nodeStart"`
	RangeEnd  api2.Timestamp `json:"rangeEnd"`
}

func (o invalidRangeNodeStartAfterViewRange) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidRangeNodeStartAfterViewRange) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidRangeNodeStartAfterViewRange returns new instance of InvalidRangeNodeStartAfterViewRange error.
func NewInvalidRangeNodeStartAfterViewRange(nodeStartArg api2.Timestamp, rangeEndArg api2.Timestamp) *InvalidRangeNodeStartAfterViewRange {
	return &InvalidRangeNodeStartAfterViewRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidRangeNodeStartAfterViewRange: invalidRangeNodeStartAfterViewRange{NodeStart: nodeStartArg, RangeEnd: rangeEndArg}}
}

// WrapWithInvalidRangeNodeStartAfterViewRange returns new instance of InvalidRangeNodeStartAfterViewRange error wrapping an existing error.
func WrapWithInvalidRangeNodeStartAfterViewRange(err error, nodeStartArg api2.Timestamp, rangeEndArg api2.Timestamp) *InvalidRangeNodeStartAfterViewRange {
	return &InvalidRangeNodeStartAfterViewRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidRangeNodeStartAfterViewRange: invalidRangeNodeStartAfterViewRange{NodeStart: nodeStartArg, RangeEnd: rangeEndArg}}
}

// InvalidRangeNodeStartAfterViewRange is an error type.
// The compute node was given a starting timestamp after the end of the view range window.
type InvalidRangeNodeStartAfterViewRange struct {
	errorInstanceID uuid.UUID
	invalidRangeNodeStartAfterViewRange
	cause error
	stack werror.StackTrace
}

// IsInvalidRangeNodeStartAfterViewRange returns true if err is an instance of InvalidRangeNodeStartAfterViewRange.
func IsInvalidRangeNodeStartAfterViewRange(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidRangeNodeStartAfterViewRange)
	return ok
}

func (e *InvalidRangeNodeStartAfterViewRange) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidRangeNodeStartAfterViewRange (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidRangeNodeStartAfterViewRange) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidRangeNodeStartAfterViewRange) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidRangeNodeStartAfterViewRange) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidRangeNodeStartAfterViewRange"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidRangeNodeStartAfterViewRange) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidRangeNodeStartAfterViewRange) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidRangeNodeStartAfterViewRange) Name() string {
	return "Compute:InvalidRangeNodeStartAfterViewRange"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidRangeNodeStartAfterViewRange) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidRangeNodeStartAfterViewRange) Parameters() map[string]interface{} {
	return map[string]interface{}{"nodeStart": e.NodeStart, "rangeEnd": e.RangeEnd}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidRangeNodeStartAfterViewRange) safeParams() map[string]interface{} {
	return map[string]interface{}{"nodeStart": e.NodeStart, "rangeEnd": e.RangeEnd, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidRangeNodeStartAfterViewRange) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidRangeNodeStartAfterViewRange) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidRangeNodeStartAfterViewRange) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidRangeNodeStartAfterViewRange) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidRangeNodeStartAfterViewRange)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidRangeNodeStartAfterViewRange", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidRangeNodeStartAfterViewRange) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidRangeNodeStartAfterViewRange
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidRangeNodeStartAfterViewRange = parameters
	return nil
}

type invalidRefpropInputCount struct {
	InputCount int `json:"inputCount"`
}

func (o invalidRefpropInputCount) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidRefpropInputCount) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidRefpropInputCount returns new instance of InvalidRefpropInputCount error.
func NewInvalidRefpropInputCount(inputCountArg int) *InvalidRefpropInputCount {
	return &InvalidRefpropInputCount{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidRefpropInputCount: invalidRefpropInputCount{InputCount: inputCountArg}}
}

// WrapWithInvalidRefpropInputCount returns new instance of InvalidRefpropInputCount error wrapping an existing error.
func WrapWithInvalidRefpropInputCount(err error, inputCountArg int) *InvalidRefpropInputCount {
	return &InvalidRefpropInputCount{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidRefpropInputCount: invalidRefpropInputCount{InputCount: inputCountArg}}
}

// InvalidRefpropInputCount is an error type.
// REFPROP requires exactly two input series.
type InvalidRefpropInputCount struct {
	errorInstanceID uuid.UUID
	invalidRefpropInputCount
	cause error
	stack werror.StackTrace
}

// IsInvalidRefpropInputCount returns true if err is an instance of InvalidRefpropInputCount.
func IsInvalidRefpropInputCount(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidRefpropInputCount)
	return ok
}

func (e *InvalidRefpropInputCount) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidRefpropInputCount (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidRefpropInputCount) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidRefpropInputCount) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidRefpropInputCount) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidRefpropInputCount"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidRefpropInputCount) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidRefpropInputCount) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidRefpropInputCount) Name() string {
	return "Compute:InvalidRefpropInputCount"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidRefpropInputCount) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidRefpropInputCount) Parameters() map[string]interface{} {
	return map[string]interface{}{"inputCount": e.InputCount}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidRefpropInputCount) safeParams() map[string]interface{} {
	return map[string]interface{}{"inputCount": e.InputCount, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidRefpropInputCount) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidRefpropInputCount) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidRefpropInputCount) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidRefpropInputCount) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidRefpropInputCount)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidRefpropInputCount", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidRefpropInputCount) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidRefpropInputCount
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidRefpropInputCount = parameters
	return nil
}

type invalidSeriesLocator struct {
	SeriesRid api2.LogicalSeriesRid `json:"seriesRid"`
}

func (o invalidSeriesLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidSeriesLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidSeriesLocator returns new instance of InvalidSeriesLocator error.
func NewInvalidSeriesLocator(seriesRidArg api2.LogicalSeriesRid) *InvalidSeriesLocator {
	return &InvalidSeriesLocator{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidSeriesLocator: invalidSeriesLocator{SeriesRid: seriesRidArg}}
}

// WrapWithInvalidSeriesLocator returns new instance of InvalidSeriesLocator error wrapping an existing error.
func WrapWithInvalidSeriesLocator(err error, seriesRidArg api2.LogicalSeriesRid) *InvalidSeriesLocator {
	return &InvalidSeriesLocator{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidSeriesLocator: invalidSeriesLocator{SeriesRid: seriesRidArg}}
}

// InvalidSeriesLocator is an error type.
type InvalidSeriesLocator struct {
	errorInstanceID uuid.UUID
	invalidSeriesLocator
	cause error
	stack werror.StackTrace
}

// IsInvalidSeriesLocator returns true if err is an instance of InvalidSeriesLocator.
func IsInvalidSeriesLocator(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidSeriesLocator)
	return ok
}

func (e *InvalidSeriesLocator) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidSeriesLocator (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidSeriesLocator) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidSeriesLocator) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidSeriesLocator) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidSeriesLocator"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidSeriesLocator) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidSeriesLocator) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidSeriesLocator) Name() string {
	return "Compute:InvalidSeriesLocator"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidSeriesLocator) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidSeriesLocator) Parameters() map[string]interface{} {
	return map[string]interface{}{"seriesRid": e.SeriesRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidSeriesLocator) safeParams() map[string]interface{} {
	return map[string]interface{}{"seriesRid": e.SeriesRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidSeriesLocator) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidSeriesLocator) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidSeriesLocator) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidSeriesLocator) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidSeriesLocator)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidSeriesLocator", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidSeriesLocator) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidSeriesLocator
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidSeriesLocator = parameters
	return nil
}

type invalidTagFilterConfiguration struct {
	ErrorType TagFilterValidationErrorType `json:"errorType"`
	Message   string                       `json:"message"`
}

func (o invalidTagFilterConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidTagFilterConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidTagFilterConfiguration returns new instance of InvalidTagFilterConfiguration error.
func NewInvalidTagFilterConfiguration(errorTypeArg TagFilterValidationErrorType, messageArg string) *InvalidTagFilterConfiguration {
	return &InvalidTagFilterConfiguration{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidTagFilterConfiguration: invalidTagFilterConfiguration{ErrorType: errorTypeArg, Message: messageArg}}
}

// WrapWithInvalidTagFilterConfiguration returns new instance of InvalidTagFilterConfiguration error wrapping an existing error.
func WrapWithInvalidTagFilterConfiguration(err error, errorTypeArg TagFilterValidationErrorType, messageArg string) *InvalidTagFilterConfiguration {
	return &InvalidTagFilterConfiguration{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidTagFilterConfiguration: invalidTagFilterConfiguration{ErrorType: errorTypeArg, Message: messageArg}}
}

// InvalidTagFilterConfiguration is an error type.
// Invalid tag filter configuration was provided.
type InvalidTagFilterConfiguration struct {
	errorInstanceID uuid.UUID
	invalidTagFilterConfiguration
	cause error
	stack werror.StackTrace
}

// IsInvalidTagFilterConfiguration returns true if err is an instance of InvalidTagFilterConfiguration.
func IsInvalidTagFilterConfiguration(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidTagFilterConfiguration)
	return ok
}

func (e *InvalidTagFilterConfiguration) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidTagFilterConfiguration (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidTagFilterConfiguration) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidTagFilterConfiguration) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidTagFilterConfiguration) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidTagFilterConfiguration"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidTagFilterConfiguration) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidTagFilterConfiguration) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidTagFilterConfiguration) Name() string {
	return "Compute:InvalidTagFilterConfiguration"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidTagFilterConfiguration) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidTagFilterConfiguration) Parameters() map[string]interface{} {
	return map[string]interface{}{"errorType": e.ErrorType, "message": e.Message}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidTagFilterConfiguration) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorType": e.ErrorType, "message": e.Message, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTagFilterConfiguration) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidTagFilterConfiguration) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTagFilterConfiguration) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidTagFilterConfiguration) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidTagFilterConfiguration)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidTagFilterConfiguration", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidTagFilterConfiguration) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidTagFilterConfiguration
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidTagFilterConfiguration = parameters
	return nil
}

type invalidTimeUnit struct{}

func (o invalidTimeUnit) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidTimeUnit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidTimeUnit returns new instance of InvalidTimeUnit error.
func NewInvalidTimeUnit() *InvalidTimeUnit {
	return &InvalidTimeUnit{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidTimeUnit: invalidTimeUnit{}}
}

// WrapWithInvalidTimeUnit returns new instance of InvalidTimeUnit error wrapping an existing error.
func WrapWithInvalidTimeUnit(err error) *InvalidTimeUnit {
	return &InvalidTimeUnit{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidTimeUnit: invalidTimeUnit{}}
}

// InvalidTimeUnit is an error type.
// The time unit associated with the series is incompatible with the current transform.
type InvalidTimeUnit struct {
	errorInstanceID uuid.UUID
	invalidTimeUnit
	cause error
	stack werror.StackTrace
}

// IsInvalidTimeUnit returns true if err is an instance of InvalidTimeUnit.
func IsInvalidTimeUnit(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidTimeUnit)
	return ok
}

func (e *InvalidTimeUnit) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidTimeUnit (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidTimeUnit) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidTimeUnit) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidTimeUnit) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidTimeUnit"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidTimeUnit) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidTimeUnit) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidTimeUnit) Name() string {
	return "Compute:InvalidTimeUnit"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidTimeUnit) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidTimeUnit) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidTimeUnit) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTimeUnit) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidTimeUnit) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTimeUnit) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidTimeUnit) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidTimeUnit)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidTimeUnit", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidTimeUnit) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidTimeUnit
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidTimeUnit = parameters
	return nil
}

type invalidValueMap struct{}

func (o invalidValueMap) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidValueMap) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidValueMap returns new instance of InvalidValueMap error.
func NewInvalidValueMap() *InvalidValueMap {
	return &InvalidValueMap{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidValueMap: invalidValueMap{}}
}

// WrapWithInvalidValueMap returns new instance of InvalidValueMap error wrapping an existing error.
func WrapWithInvalidValueMap(err error) *InvalidValueMap {
	return &InvalidValueMap{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidValueMap: invalidValueMap{}}
}

// InvalidValueMap is an error type.
/*
Range end must be greater than range start. Range start may only be undefined if in the first range, or the prior end is defined and less.
Range end may only be undefined if in the last range, or the next start is defined and greater. Ranges must be in increasing order.
*/
type InvalidValueMap struct {
	errorInstanceID uuid.UUID
	invalidValueMap
	cause error
	stack werror.StackTrace
}

// IsInvalidValueMap returns true if err is an instance of InvalidValueMap.
func IsInvalidValueMap(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidValueMap)
	return ok
}

func (e *InvalidValueMap) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:InvalidValueMap (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidValueMap) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidValueMap) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidValueMap) Message() string {
	return "INVALID_ARGUMENT Compute:InvalidValueMap"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidValueMap) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidValueMap) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidValueMap) Name() string {
	return "Compute:InvalidValueMap"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidValueMap) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidValueMap) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidValueMap) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidValueMap) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidValueMap) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidValueMap) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidValueMap) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidValueMap)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:InvalidValueMap", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidValueMap) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidValueMap
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidValueMap = parameters
	return nil
}

type maxQuerySizeExceeded struct {
	QueryId uuid.UUID `json:"queryId"`
}

func (o maxQuerySizeExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *maxQuerySizeExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMaxQuerySizeExceeded returns new instance of MaxQuerySizeExceeded error.
func NewMaxQuerySizeExceeded(queryIdArg uuid.UUID) *MaxQuerySizeExceeded {
	return &MaxQuerySizeExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), maxQuerySizeExceeded: maxQuerySizeExceeded{QueryId: queryIdArg}}
}

// WrapWithMaxQuerySizeExceeded returns new instance of MaxQuerySizeExceeded error wrapping an existing error.
func WrapWithMaxQuerySizeExceeded(err error, queryIdArg uuid.UUID) *MaxQuerySizeExceeded {
	return &MaxQuerySizeExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, maxQuerySizeExceeded: maxQuerySizeExceeded{QueryId: queryIdArg}}
}

// MaxQuerySizeExceeded is an error type.
// The maximum query size was exceeded.
type MaxQuerySizeExceeded struct {
	errorInstanceID uuid.UUID
	maxQuerySizeExceeded
	cause error
	stack werror.StackTrace
}

// IsMaxQuerySizeExceeded returns true if err is an instance of MaxQuerySizeExceeded.
func IsMaxQuerySizeExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MaxQuerySizeExceeded)
	return ok
}

func (e *MaxQuerySizeExceeded) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MaxQuerySizeExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MaxQuerySizeExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MaxQuerySizeExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MaxQuerySizeExceeded) Message() string {
	return "INVALID_ARGUMENT Compute:MaxQuerySizeExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MaxQuerySizeExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MaxQuerySizeExceeded) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MaxQuerySizeExceeded) Name() string {
	return "Compute:MaxQuerySizeExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MaxQuerySizeExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MaxQuerySizeExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MaxQuerySizeExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MaxQuerySizeExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MaxQuerySizeExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MaxQuerySizeExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MaxQuerySizeExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.maxQuerySizeExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MaxQuerySizeExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MaxQuerySizeExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters maxQuerySizeExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.maxQuerySizeExceeded = parameters
	return nil
}

type memoryLimitExceeded struct {
	QueryId uuid.UUID `json:"queryId"`
}

func (o memoryLimitExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *memoryLimitExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMemoryLimitExceeded returns new instance of MemoryLimitExceeded error.
func NewMemoryLimitExceeded(queryIdArg uuid.UUID) *MemoryLimitExceeded {
	return &MemoryLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), memoryLimitExceeded: memoryLimitExceeded{QueryId: queryIdArg}}
}

// WrapWithMemoryLimitExceeded returns new instance of MemoryLimitExceeded error wrapping an existing error.
func WrapWithMemoryLimitExceeded(err error, queryIdArg uuid.UUID) *MemoryLimitExceeded {
	return &MemoryLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, memoryLimitExceeded: memoryLimitExceeded{QueryId: queryIdArg}}
}

// MemoryLimitExceeded is an error type.
// The query exceeded the memory limit. Try querying a smaller time range or fewer series.
type MemoryLimitExceeded struct {
	errorInstanceID uuid.UUID
	memoryLimitExceeded
	cause error
	stack werror.StackTrace
}

// IsMemoryLimitExceeded returns true if err is an instance of MemoryLimitExceeded.
func IsMemoryLimitExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MemoryLimitExceeded)
	return ok
}

func (e *MemoryLimitExceeded) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MemoryLimitExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MemoryLimitExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MemoryLimitExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MemoryLimitExceeded) Message() string {
	return "INVALID_ARGUMENT Compute:MemoryLimitExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MemoryLimitExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MemoryLimitExceeded) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MemoryLimitExceeded) Name() string {
	return "Compute:MemoryLimitExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MemoryLimitExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MemoryLimitExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MemoryLimitExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MemoryLimitExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MemoryLimitExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MemoryLimitExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MemoryLimitExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.memoryLimitExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MemoryLimitExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MemoryLimitExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters memoryLimitExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.memoryLimitExceeded = parameters
	return nil
}

type missingFunctionParameter struct {
	ModuleName    string `json:"moduleName"`
	ModuleVersion string `json:"moduleVersion"`
	FunctionName  string `json:"functionName"`
	ParameterName string `json:"parameterName"`
}

func (o missingFunctionParameter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *missingFunctionParameter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMissingFunctionParameter returns new instance of MissingFunctionParameter error.
func NewMissingFunctionParameter(moduleNameArg string, moduleVersionArg string, functionNameArg string, parameterNameArg string) *MissingFunctionParameter {
	return &MissingFunctionParameter{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), missingFunctionParameter: missingFunctionParameter{ModuleName: moduleNameArg, ModuleVersion: moduleVersionArg, FunctionName: functionNameArg, ParameterName: parameterNameArg}}
}

// WrapWithMissingFunctionParameter returns new instance of MissingFunctionParameter error wrapping an existing error.
func WrapWithMissingFunctionParameter(err error, moduleNameArg string, moduleVersionArg string, functionNameArg string, parameterNameArg string) *MissingFunctionParameter {
	return &MissingFunctionParameter{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, missingFunctionParameter: missingFunctionParameter{ModuleName: moduleNameArg, ModuleVersion: moduleVersionArg, FunctionName: functionNameArg, ParameterName: parameterNameArg}}
}

// MissingFunctionParameter is an error type.
// The requested module function could not be executed because a required parameter was not provided.
type MissingFunctionParameter struct {
	errorInstanceID uuid.UUID
	missingFunctionParameter
	cause error
	stack werror.StackTrace
}

// IsMissingFunctionParameter returns true if err is an instance of MissingFunctionParameter.
func IsMissingFunctionParameter(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MissingFunctionParameter)
	return ok
}

func (e *MissingFunctionParameter) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MissingFunctionParameter (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MissingFunctionParameter) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MissingFunctionParameter) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MissingFunctionParameter) Message() string {
	return "INVALID_ARGUMENT Compute:MissingFunctionParameter"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MissingFunctionParameter) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MissingFunctionParameter) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MissingFunctionParameter) Name() string {
	return "Compute:MissingFunctionParameter"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MissingFunctionParameter) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MissingFunctionParameter) Parameters() map[string]interface{} {
	return map[string]interface{}{"moduleName": e.ModuleName, "moduleVersion": e.ModuleVersion, "functionName": e.FunctionName, "parameterName": e.ParameterName}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MissingFunctionParameter) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingFunctionParameter) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MissingFunctionParameter) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"moduleName": e.ModuleName, "moduleVersion": e.ModuleVersion, "functionName": e.FunctionName, "parameterName": e.ParameterName}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingFunctionParameter) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MissingFunctionParameter) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.missingFunctionParameter)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MissingFunctionParameter", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MissingFunctionParameter) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters missingFunctionParameter
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.missingFunctionParameter = parameters
	return nil
}

type missingModuleApplication struct {
	ModuleApplicationRid api3.ModuleApplicationRid `json:"moduleApplicationRid"`
}

func (o missingModuleApplication) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *missingModuleApplication) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMissingModuleApplication returns new instance of MissingModuleApplication error.
func NewMissingModuleApplication(moduleApplicationRidArg api3.ModuleApplicationRid) *MissingModuleApplication {
	return &MissingModuleApplication{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), missingModuleApplication: missingModuleApplication{ModuleApplicationRid: moduleApplicationRidArg}}
}

// WrapWithMissingModuleApplication returns new instance of MissingModuleApplication error wrapping an existing error.
func WrapWithMissingModuleApplication(err error, moduleApplicationRidArg api3.ModuleApplicationRid) *MissingModuleApplication {
	return &MissingModuleApplication{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, missingModuleApplication: missingModuleApplication{ModuleApplicationRid: moduleApplicationRidArg}}
}

// MissingModuleApplication is an error type.
/*
The requested module application could not be found.
This may be because the reference is incorrect or the application is unavailable in the current execution context.
*/
type MissingModuleApplication struct {
	errorInstanceID uuid.UUID
	missingModuleApplication
	cause error
	stack werror.StackTrace
}

// IsMissingModuleApplication returns true if err is an instance of MissingModuleApplication.
func IsMissingModuleApplication(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MissingModuleApplication)
	return ok
}

func (e *MissingModuleApplication) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MissingModuleApplication (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MissingModuleApplication) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MissingModuleApplication) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MissingModuleApplication) Message() string {
	return "INVALID_ARGUMENT Compute:MissingModuleApplication"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MissingModuleApplication) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MissingModuleApplication) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MissingModuleApplication) Name() string {
	return "Compute:MissingModuleApplication"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MissingModuleApplication) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MissingModuleApplication) Parameters() map[string]interface{} {
	return map[string]interface{}{"moduleApplicationRid": e.ModuleApplicationRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MissingModuleApplication) safeParams() map[string]interface{} {
	return map[string]interface{}{"moduleApplicationRid": e.ModuleApplicationRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingModuleApplication) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MissingModuleApplication) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingModuleApplication) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MissingModuleApplication) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.missingModuleApplication)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MissingModuleApplication", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MissingModuleApplication) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters missingModuleApplication
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.missingModuleApplication = parameters
	return nil
}

type missingModuleFunction struct {
	ModuleName    string `json:"moduleName"`
	ModuleVersion string `json:"moduleVersion"`
	FunctionName  string `json:"functionName"`
}

func (o missingModuleFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *missingModuleFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMissingModuleFunction returns new instance of MissingModuleFunction error.
func NewMissingModuleFunction(moduleNameArg string, moduleVersionArg string, functionNameArg string) *MissingModuleFunction {
	return &MissingModuleFunction{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), missingModuleFunction: missingModuleFunction{ModuleName: moduleNameArg, ModuleVersion: moduleVersionArg, FunctionName: functionNameArg}}
}

// WrapWithMissingModuleFunction returns new instance of MissingModuleFunction error wrapping an existing error.
func WrapWithMissingModuleFunction(err error, moduleNameArg string, moduleVersionArg string, functionNameArg string) *MissingModuleFunction {
	return &MissingModuleFunction{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, missingModuleFunction: missingModuleFunction{ModuleName: moduleNameArg, ModuleVersion: moduleVersionArg, FunctionName: functionNameArg}}
}

// MissingModuleFunction is an error type.
/*
The requested module function could not be found.
This may be because the reference is incorrect or the function is unavailable in the current execution context.
*/
type MissingModuleFunction struct {
	errorInstanceID uuid.UUID
	missingModuleFunction
	cause error
	stack werror.StackTrace
}

// IsMissingModuleFunction returns true if err is an instance of MissingModuleFunction.
func IsMissingModuleFunction(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MissingModuleFunction)
	return ok
}

func (e *MissingModuleFunction) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MissingModuleFunction (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MissingModuleFunction) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MissingModuleFunction) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MissingModuleFunction) Message() string {
	return "INVALID_ARGUMENT Compute:MissingModuleFunction"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MissingModuleFunction) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MissingModuleFunction) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MissingModuleFunction) Name() string {
	return "Compute:MissingModuleFunction"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MissingModuleFunction) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MissingModuleFunction) Parameters() map[string]interface{} {
	return map[string]interface{}{"moduleName": e.ModuleName, "moduleVersion": e.ModuleVersion, "functionName": e.FunctionName}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MissingModuleFunction) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingModuleFunction) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MissingModuleFunction) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"moduleName": e.ModuleName, "moduleVersion": e.ModuleVersion, "functionName": e.FunctionName}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingModuleFunction) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MissingModuleFunction) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.missingModuleFunction)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MissingModuleFunction", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MissingModuleFunction) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters missingModuleFunction
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.missingModuleFunction = parameters
	return nil
}

type notAuthorized struct {
	DataSourceRids []rids.DataSourceRid `json:"dataSourceRids"`
}

func (o notAuthorized) MarshalJSON() ([]byte, error) {
	if o.DataSourceRids == nil {
		o.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	type _tmpnotAuthorized notAuthorized
	return safejson.Marshal(_tmpnotAuthorized(o))
}

func (o *notAuthorized) UnmarshalJSON(data []byte) error {
	type _tmpnotAuthorized notAuthorized
	var rawnotAuthorized _tmpnotAuthorized
	if err := safejson.Unmarshal(data, &rawnotAuthorized); err != nil {
		return err
	}
	if rawnotAuthorized.DataSourceRids == nil {
		rawnotAuthorized.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	*o = notAuthorized(rawnotAuthorized)
	return nil
}

func (o notAuthorized) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *notAuthorized) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNotAuthorized returns new instance of NotAuthorized error.
func NewNotAuthorized(dataSourceRidsArg []rids.DataSourceRid) *NotAuthorized {
	return &NotAuthorized{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), notAuthorized: notAuthorized{DataSourceRids: dataSourceRidsArg}}
}

// WrapWithNotAuthorized returns new instance of NotAuthorized error wrapping an existing error.
func WrapWithNotAuthorized(err error, dataSourceRidsArg []rids.DataSourceRid) *NotAuthorized {
	return &NotAuthorized{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, notAuthorized: notAuthorized{DataSourceRids: dataSourceRidsArg}}
}

// NotAuthorized is an error type.
type NotAuthorized struct {
	errorInstanceID uuid.UUID
	notAuthorized
	cause error
	stack werror.StackTrace
}

// IsNotAuthorized returns true if err is an instance of NotAuthorized.
func IsNotAuthorized(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NotAuthorized)
	return ok
}

func (e *NotAuthorized) Error() string {
	return fmt.Sprintf("PERMISSION_DENIED Compute:NotAuthorized (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NotAuthorized) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NotAuthorized) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NotAuthorized) Message() string {
	return "PERMISSION_DENIED Compute:NotAuthorized"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NotAuthorized) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NotAuthorized) Code() errors.ErrorCode {
	return errors.PermissionDenied
}

// Name returns an error name identifying error type.
func (e *NotAuthorized) Name() string {
	return "Compute:NotAuthorized"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NotAuthorized) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NotAuthorized) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NotAuthorized) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NotAuthorized) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NotAuthorized) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NotAuthorized) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NotAuthorized) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.notAuthorized)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.PermissionDenied, ErrorName: "Compute:NotAuthorized", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NotAuthorized) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters notAuthorized
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.notAuthorized = parameters
	return nil
}

type notEnoughPointsForCurve struct{}

func (o notEnoughPointsForCurve) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *notEnoughPointsForCurve) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNotEnoughPointsForCurve returns new instance of NotEnoughPointsForCurve error.
func NewNotEnoughPointsForCurve() *NotEnoughPointsForCurve {
	return &NotEnoughPointsForCurve{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), notEnoughPointsForCurve: notEnoughPointsForCurve{}}
}

// WrapWithNotEnoughPointsForCurve returns new instance of NotEnoughPointsForCurve error wrapping an existing error.
func WrapWithNotEnoughPointsForCurve(err error) *NotEnoughPointsForCurve {
	return &NotEnoughPointsForCurve{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, notEnoughPointsForCurve: notEnoughPointsForCurve{}}
}

// NotEnoughPointsForCurve is an error type.
// There were not enough points to fit the curve requested.
type NotEnoughPointsForCurve struct {
	errorInstanceID uuid.UUID
	notEnoughPointsForCurve
	cause error
	stack werror.StackTrace
}

// IsNotEnoughPointsForCurve returns true if err is an instance of NotEnoughPointsForCurve.
func IsNotEnoughPointsForCurve(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NotEnoughPointsForCurve)
	return ok
}

func (e *NotEnoughPointsForCurve) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:NotEnoughPointsForCurve (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NotEnoughPointsForCurve) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NotEnoughPointsForCurve) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NotEnoughPointsForCurve) Message() string {
	return "INVALID_ARGUMENT Compute:NotEnoughPointsForCurve"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NotEnoughPointsForCurve) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NotEnoughPointsForCurve) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *NotEnoughPointsForCurve) Name() string {
	return "Compute:NotEnoughPointsForCurve"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NotEnoughPointsForCurve) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NotEnoughPointsForCurve) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NotEnoughPointsForCurve) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NotEnoughPointsForCurve) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NotEnoughPointsForCurve) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NotEnoughPointsForCurve) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NotEnoughPointsForCurve) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.notEnoughPointsForCurve)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:NotEnoughPointsForCurve", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NotEnoughPointsForCurve) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters notEnoughPointsForCurve
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.notEnoughPointsForCurve = parameters
	return nil
}

type overlappingLiteralRanges struct{}

func (o overlappingLiteralRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *overlappingLiteralRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewOverlappingLiteralRanges returns new instance of OverlappingLiteralRanges error.
func NewOverlappingLiteralRanges() *OverlappingLiteralRanges {
	return &OverlappingLiteralRanges{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), overlappingLiteralRanges: overlappingLiteralRanges{}}
}

// WrapWithOverlappingLiteralRanges returns new instance of OverlappingLiteralRanges error wrapping an existing error.
func WrapWithOverlappingLiteralRanges(err error) *OverlappingLiteralRanges {
	return &OverlappingLiteralRanges{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, overlappingLiteralRanges: overlappingLiteralRanges{}}
}

// OverlappingLiteralRanges is an error type.
/*
Ranges cannot overlap. Only the first range when sorted may omit the start,
and only the last may omit the end.
*/
type OverlappingLiteralRanges struct {
	errorInstanceID uuid.UUID
	overlappingLiteralRanges
	cause error
	stack werror.StackTrace
}

// IsOverlappingLiteralRanges returns true if err is an instance of OverlappingLiteralRanges.
func IsOverlappingLiteralRanges(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*OverlappingLiteralRanges)
	return ok
}

func (e *OverlappingLiteralRanges) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:OverlappingLiteralRanges (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *OverlappingLiteralRanges) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *OverlappingLiteralRanges) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *OverlappingLiteralRanges) Message() string {
	return "INVALID_ARGUMENT Compute:OverlappingLiteralRanges"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *OverlappingLiteralRanges) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *OverlappingLiteralRanges) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *OverlappingLiteralRanges) Name() string {
	return "Compute:OverlappingLiteralRanges"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *OverlappingLiteralRanges) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *OverlappingLiteralRanges) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *OverlappingLiteralRanges) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *OverlappingLiteralRanges) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *OverlappingLiteralRanges) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *OverlappingLiteralRanges) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e OverlappingLiteralRanges) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.overlappingLiteralRanges)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:OverlappingLiteralRanges", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *OverlappingLiteralRanges) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters overlappingLiteralRanges
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.overlappingLiteralRanges = parameters
	return nil
}

type picosRangeTooLarge struct{}

func (o picosRangeTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *picosRangeTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewPicosRangeTooLarge returns new instance of PicosRangeTooLarge error.
func NewPicosRangeTooLarge() *PicosRangeTooLarge {
	return &PicosRangeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), picosRangeTooLarge: picosRangeTooLarge{}}
}

// WrapWithPicosRangeTooLarge returns new instance of PicosRangeTooLarge error wrapping an existing error.
func WrapWithPicosRangeTooLarge(err error) *PicosRangeTooLarge {
	return &PicosRangeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, picosRangeTooLarge: picosRangeTooLarge{}}
}

// PicosRangeTooLarge is an error type.
/*
Time range is too large to fit in 64 bits for picosecond granularity data.
Try again with a smaller time range.
*/
type PicosRangeTooLarge struct {
	errorInstanceID uuid.UUID
	picosRangeTooLarge
	cause error
	stack werror.StackTrace
}

// IsPicosRangeTooLarge returns true if err is an instance of PicosRangeTooLarge.
func IsPicosRangeTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*PicosRangeTooLarge)
	return ok
}

func (e *PicosRangeTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:PicosRangeTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *PicosRangeTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *PicosRangeTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *PicosRangeTooLarge) Message() string {
	return "INVALID_ARGUMENT Compute:PicosRangeTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *PicosRangeTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *PicosRangeTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *PicosRangeTooLarge) Name() string {
	return "Compute:PicosRangeTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *PicosRangeTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *PicosRangeTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *PicosRangeTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *PicosRangeTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *PicosRangeTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *PicosRangeTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e PicosRangeTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.picosRangeTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:PicosRangeTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *PicosRangeTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters picosRangeTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.picosRangeTooLarge = parameters
	return nil
}

type queryRangeTooLarge struct{}

func (o queryRangeTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *queryRangeTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewQueryRangeTooLarge returns new instance of QueryRangeTooLarge error.
func NewQueryRangeTooLarge() *QueryRangeTooLarge {
	return &QueryRangeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), queryRangeTooLarge: queryRangeTooLarge{}}
}

// WrapWithQueryRangeTooLarge returns new instance of QueryRangeTooLarge error wrapping an existing error.
func WrapWithQueryRangeTooLarge(err error) *QueryRangeTooLarge {
	return &QueryRangeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, queryRangeTooLarge: queryRangeTooLarge{}}
}

// QueryRangeTooLarge is an error type.
// The requested time range is too large. Try again with a smaller time range.
type QueryRangeTooLarge struct {
	errorInstanceID uuid.UUID
	queryRangeTooLarge
	cause error
	stack werror.StackTrace
}

// IsQueryRangeTooLarge returns true if err is an instance of QueryRangeTooLarge.
func IsQueryRangeTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*QueryRangeTooLarge)
	return ok
}

func (e *QueryRangeTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:QueryRangeTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *QueryRangeTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *QueryRangeTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *QueryRangeTooLarge) Message() string {
	return "INVALID_ARGUMENT Compute:QueryRangeTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *QueryRangeTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *QueryRangeTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *QueryRangeTooLarge) Name() string {
	return "Compute:QueryRangeTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *QueryRangeTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *QueryRangeTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *QueryRangeTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *QueryRangeTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *QueryRangeTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *QueryRangeTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e QueryRangeTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.queryRangeTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:QueryRangeTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *QueryRangeTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters queryRangeTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.queryRangeTooLarge = parameters
	return nil
}

type refpropInputTooLarge struct {
	AlignedSeriesSize int `json:"alignedSeriesSize"`
}

func (o refpropInputTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *refpropInputTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewRefpropInputTooLarge returns new instance of RefpropInputTooLarge error.
func NewRefpropInputTooLarge(alignedSeriesSizeArg int) *RefpropInputTooLarge {
	return &RefpropInputTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), refpropInputTooLarge: refpropInputTooLarge{AlignedSeriesSize: alignedSeriesSizeArg}}
}

// WrapWithRefpropInputTooLarge returns new instance of RefpropInputTooLarge error wrapping an existing error.
func WrapWithRefpropInputTooLarge(err error, alignedSeriesSizeArg int) *RefpropInputTooLarge {
	return &RefpropInputTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, refpropInputTooLarge: refpropInputTooLarge{AlignedSeriesSize: alignedSeriesSizeArg}}
}

// RefpropInputTooLarge is an error type.
// The number of points in the REFPROP inputs is too large.
type RefpropInputTooLarge struct {
	errorInstanceID uuid.UUID
	refpropInputTooLarge
	cause error
	stack werror.StackTrace
}

// IsRefpropInputTooLarge returns true if err is an instance of RefpropInputTooLarge.
func IsRefpropInputTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*RefpropInputTooLarge)
	return ok
}

func (e *RefpropInputTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:RefpropInputTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *RefpropInputTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *RefpropInputTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *RefpropInputTooLarge) Message() string {
	return "INVALID_ARGUMENT Compute:RefpropInputTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *RefpropInputTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *RefpropInputTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *RefpropInputTooLarge) Name() string {
	return "Compute:RefpropInputTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *RefpropInputTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *RefpropInputTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{"alignedSeriesSize": e.AlignedSeriesSize}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *RefpropInputTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"alignedSeriesSize": e.AlignedSeriesSize, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *RefpropInputTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *RefpropInputTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *RefpropInputTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e RefpropInputTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.refpropInputTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:RefpropInputTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *RefpropInputTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters refpropInputTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.refpropInputTooLarge = parameters
	return nil
}

type refpropOutputPropertyIsInput struct {
	OutputProperty string `json:"outputProperty"`
	FirstProperty  string `json:"firstProperty"`
	SecondProperty string `json:"secondProperty"`
}

func (o refpropOutputPropertyIsInput) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *refpropOutputPropertyIsInput) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewRefpropOutputPropertyIsInput returns new instance of RefpropOutputPropertyIsInput error.
func NewRefpropOutputPropertyIsInput(outputPropertyArg string, firstPropertyArg string, secondPropertyArg string) *RefpropOutputPropertyIsInput {
	return &RefpropOutputPropertyIsInput{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), refpropOutputPropertyIsInput: refpropOutputPropertyIsInput{OutputProperty: outputPropertyArg, FirstProperty: firstPropertyArg, SecondProperty: secondPropertyArg}}
}

// WrapWithRefpropOutputPropertyIsInput returns new instance of RefpropOutputPropertyIsInput error wrapping an existing error.
func WrapWithRefpropOutputPropertyIsInput(err error, outputPropertyArg string, firstPropertyArg string, secondPropertyArg string) *RefpropOutputPropertyIsInput {
	return &RefpropOutputPropertyIsInput{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, refpropOutputPropertyIsInput: refpropOutputPropertyIsInput{OutputProperty: outputPropertyArg, FirstProperty: firstPropertyArg, SecondProperty: secondPropertyArg}}
}

// RefpropOutputPropertyIsInput is an error type.
// The output property cannot be one of the input properties for REFPROP.
type RefpropOutputPropertyIsInput struct {
	errorInstanceID uuid.UUID
	refpropOutputPropertyIsInput
	cause error
	stack werror.StackTrace
}

// IsRefpropOutputPropertyIsInput returns true if err is an instance of RefpropOutputPropertyIsInput.
func IsRefpropOutputPropertyIsInput(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*RefpropOutputPropertyIsInput)
	return ok
}

func (e *RefpropOutputPropertyIsInput) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:RefpropOutputPropertyIsInput (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *RefpropOutputPropertyIsInput) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *RefpropOutputPropertyIsInput) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *RefpropOutputPropertyIsInput) Message() string {
	return "INVALID_ARGUMENT Compute:RefpropOutputPropertyIsInput"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *RefpropOutputPropertyIsInput) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *RefpropOutputPropertyIsInput) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *RefpropOutputPropertyIsInput) Name() string {
	return "Compute:RefpropOutputPropertyIsInput"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *RefpropOutputPropertyIsInput) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *RefpropOutputPropertyIsInput) Parameters() map[string]interface{} {
	return map[string]interface{}{"outputProperty": e.OutputProperty, "firstProperty": e.FirstProperty, "secondProperty": e.SecondProperty}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *RefpropOutputPropertyIsInput) safeParams() map[string]interface{} {
	return map[string]interface{}{"outputProperty": e.OutputProperty, "firstProperty": e.FirstProperty, "secondProperty": e.SecondProperty, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *RefpropOutputPropertyIsInput) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *RefpropOutputPropertyIsInput) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *RefpropOutputPropertyIsInput) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e RefpropOutputPropertyIsInput) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.refpropOutputPropertyIsInput)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:RefpropOutputPropertyIsInput", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *RefpropOutputPropertyIsInput) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters refpropOutputPropertyIsInput
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.refpropOutputPropertyIsInput = parameters
	return nil
}

type requestedRowsLimitExceeded struct {
	MaxRowsReturned int `json:"maxRowsReturned"`
}

func (o requestedRowsLimitExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *requestedRowsLimitExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewRequestedRowsLimitExceeded returns new instance of RequestedRowsLimitExceeded error.
func NewRequestedRowsLimitExceeded(maxRowsReturnedArg int) *RequestedRowsLimitExceeded {
	return &RequestedRowsLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), requestedRowsLimitExceeded: requestedRowsLimitExceeded{MaxRowsReturned: maxRowsReturnedArg}}
}

// WrapWithRequestedRowsLimitExceeded returns new instance of RequestedRowsLimitExceeded error wrapping an existing error.
func WrapWithRequestedRowsLimitExceeded(err error, maxRowsReturnedArg int) *RequestedRowsLimitExceeded {
	return &RequestedRowsLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, requestedRowsLimitExceeded: requestedRowsLimitExceeded{MaxRowsReturned: maxRowsReturnedArg}}
}

// RequestedRowsLimitExceeded is an error type.
// The maximum number of points that can be returned is 10,000.
type RequestedRowsLimitExceeded struct {
	errorInstanceID uuid.UUID
	requestedRowsLimitExceeded
	cause error
	stack werror.StackTrace
}

// IsRequestedRowsLimitExceeded returns true if err is an instance of RequestedRowsLimitExceeded.
func IsRequestedRowsLimitExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*RequestedRowsLimitExceeded)
	return ok
}

func (e *RequestedRowsLimitExceeded) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:RequestedRowsLimitExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *RequestedRowsLimitExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *RequestedRowsLimitExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *RequestedRowsLimitExceeded) Message() string {
	return "INVALID_ARGUMENT Compute:RequestedRowsLimitExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *RequestedRowsLimitExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *RequestedRowsLimitExceeded) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *RequestedRowsLimitExceeded) Name() string {
	return "Compute:RequestedRowsLimitExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *RequestedRowsLimitExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *RequestedRowsLimitExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"maxRowsReturned": e.MaxRowsReturned}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *RequestedRowsLimitExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"maxRowsReturned": e.MaxRowsReturned, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *RequestedRowsLimitExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *RequestedRowsLimitExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *RequestedRowsLimitExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e RequestedRowsLimitExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.requestedRowsLimitExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:RequestedRowsLimitExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *RequestedRowsLimitExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters requestedRowsLimitExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.requestedRowsLimitExceeded = parameters
	return nil
}

type resampleDefaultValueTypeMismatchesSeriesType struct {
	DefaultValueType string `json:"defaultValueType"`
	ExpectedType     string `json:"expectedType"`
}

func (o resampleDefaultValueTypeMismatchesSeriesType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *resampleDefaultValueTypeMismatchesSeriesType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewResampleDefaultValueTypeMismatchesSeriesType returns new instance of ResampleDefaultValueTypeMismatchesSeriesType error.
func NewResampleDefaultValueTypeMismatchesSeriesType(defaultValueTypeArg string, expectedTypeArg string) *ResampleDefaultValueTypeMismatchesSeriesType {
	return &ResampleDefaultValueTypeMismatchesSeriesType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), resampleDefaultValueTypeMismatchesSeriesType: resampleDefaultValueTypeMismatchesSeriesType{DefaultValueType: defaultValueTypeArg, ExpectedType: expectedTypeArg}}
}

// WrapWithResampleDefaultValueTypeMismatchesSeriesType returns new instance of ResampleDefaultValueTypeMismatchesSeriesType error wrapping an existing error.
func WrapWithResampleDefaultValueTypeMismatchesSeriesType(err error, defaultValueTypeArg string, expectedTypeArg string) *ResampleDefaultValueTypeMismatchesSeriesType {
	return &ResampleDefaultValueTypeMismatchesSeriesType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, resampleDefaultValueTypeMismatchesSeriesType: resampleDefaultValueTypeMismatchesSeriesType{DefaultValueType: defaultValueTypeArg, ExpectedType: expectedTypeArg}}
}

// ResampleDefaultValueTypeMismatchesSeriesType is an error type.
// The default value provided for resampling does not match the type of the series being resampled.
type ResampleDefaultValueTypeMismatchesSeriesType struct {
	errorInstanceID uuid.UUID
	resampleDefaultValueTypeMismatchesSeriesType
	cause error
	stack werror.StackTrace
}

// IsResampleDefaultValueTypeMismatchesSeriesType returns true if err is an instance of ResampleDefaultValueTypeMismatchesSeriesType.
func IsResampleDefaultValueTypeMismatchesSeriesType(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ResampleDefaultValueTypeMismatchesSeriesType)
	return ok
}

func (e *ResampleDefaultValueTypeMismatchesSeriesType) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:ResampleDefaultValueTypeMismatchesSeriesType (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) Message() string {
	return "INVALID_ARGUMENT Compute:ResampleDefaultValueTypeMismatchesSeriesType"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) Name() string {
	return "Compute:ResampleDefaultValueTypeMismatchesSeriesType"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) Parameters() map[string]interface{} {
	return map[string]interface{}{"defaultValueType": e.DefaultValueType, "expectedType": e.ExpectedType}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) safeParams() map[string]interface{} {
	return map[string]interface{}{"defaultValueType": e.DefaultValueType, "expectedType": e.ExpectedType, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ResampleDefaultValueTypeMismatchesSeriesType) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ResampleDefaultValueTypeMismatchesSeriesType) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.resampleDefaultValueTypeMismatchesSeriesType)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:ResampleDefaultValueTypeMismatchesSeriesType", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ResampleDefaultValueTypeMismatchesSeriesType) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters resampleDefaultValueTypeMismatchesSeriesType
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.resampleDefaultValueTypeMismatchesSeriesType = parameters
	return nil
}

type rowLimitExceeded struct {
	QueryId uuid.UUID         `json:"queryId"`
	Limit   safelong.SafeLong `json:"limit"`
}

func (o rowLimitExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *rowLimitExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewRowLimitExceeded returns new instance of RowLimitExceeded error.
func NewRowLimitExceeded(queryIdArg uuid.UUID, limitArg safelong.SafeLong) *RowLimitExceeded {
	return &RowLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), rowLimitExceeded: rowLimitExceeded{QueryId: queryIdArg, Limit: limitArg}}
}

// WrapWithRowLimitExceeded returns new instance of RowLimitExceeded error wrapping an existing error.
func WrapWithRowLimitExceeded(err error, queryIdArg uuid.UUID, limitArg safelong.SafeLong) *RowLimitExceeded {
	return &RowLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, rowLimitExceeded: rowLimitExceeded{QueryId: queryIdArg, Limit: limitArg}}
}

// RowLimitExceeded is an error type.
/*
The query exceeded that limit for number of rows returned. For the query to complete,
either zoom in or downsample.
*/
type RowLimitExceeded struct {
	errorInstanceID uuid.UUID
	rowLimitExceeded
	cause error
	stack werror.StackTrace
}

// IsRowLimitExceeded returns true if err is an instance of RowLimitExceeded.
func IsRowLimitExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*RowLimitExceeded)
	return ok
}

func (e *RowLimitExceeded) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:RowLimitExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *RowLimitExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *RowLimitExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *RowLimitExceeded) Message() string {
	return "INVALID_ARGUMENT Compute:RowLimitExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *RowLimitExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *RowLimitExceeded) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *RowLimitExceeded) Name() string {
	return "Compute:RowLimitExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *RowLimitExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *RowLimitExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "limit": e.Limit}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *RowLimitExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "limit": e.Limit, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *RowLimitExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *RowLimitExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *RowLimitExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e RowLimitExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.rowLimitExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:RowLimitExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *RowLimitExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters rowLimitExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.rowLimitExceeded = parameters
	return nil
}

type signalFilterInvalidCutoffBand struct {
	LowCutoffFrequency  float64 `json:"lowCutoffFrequency"`
	HighCutoffFrequency float64 `json:"highCutoffFrequency"`
}

func (o signalFilterInvalidCutoffBand) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *signalFilterInvalidCutoffBand) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSignalFilterInvalidCutoffBand returns new instance of SignalFilterInvalidCutoffBand error.
func NewSignalFilterInvalidCutoffBand(lowCutoffFrequencyArg float64, highCutoffFrequencyArg float64) *SignalFilterInvalidCutoffBand {
	return &SignalFilterInvalidCutoffBand{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), signalFilterInvalidCutoffBand: signalFilterInvalidCutoffBand{LowCutoffFrequency: lowCutoffFrequencyArg, HighCutoffFrequency: highCutoffFrequencyArg}}
}

// WrapWithSignalFilterInvalidCutoffBand returns new instance of SignalFilterInvalidCutoffBand error wrapping an existing error.
func WrapWithSignalFilterInvalidCutoffBand(err error, lowCutoffFrequencyArg float64, highCutoffFrequencyArg float64) *SignalFilterInvalidCutoffBand {
	return &SignalFilterInvalidCutoffBand{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, signalFilterInvalidCutoffBand: signalFilterInvalidCutoffBand{LowCutoffFrequency: lowCutoffFrequencyArg, HighCutoffFrequency: highCutoffFrequencyArg}}
}

// SignalFilterInvalidCutoffBand is an error type.
// Lower band cutoff frequency must be less than or equal to upper band cutoff frequency.
type SignalFilterInvalidCutoffBand struct {
	errorInstanceID uuid.UUID
	signalFilterInvalidCutoffBand
	cause error
	stack werror.StackTrace
}

// IsSignalFilterInvalidCutoffBand returns true if err is an instance of SignalFilterInvalidCutoffBand.
func IsSignalFilterInvalidCutoffBand(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SignalFilterInvalidCutoffBand)
	return ok
}

func (e *SignalFilterInvalidCutoffBand) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:SignalFilterInvalidCutoffBand (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SignalFilterInvalidCutoffBand) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SignalFilterInvalidCutoffBand) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SignalFilterInvalidCutoffBand) Message() string {
	return "INVALID_ARGUMENT Compute:SignalFilterInvalidCutoffBand"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SignalFilterInvalidCutoffBand) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SignalFilterInvalidCutoffBand) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SignalFilterInvalidCutoffBand) Name() string {
	return "Compute:SignalFilterInvalidCutoffBand"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SignalFilterInvalidCutoffBand) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffBand) Parameters() map[string]interface{} {
	return map[string]interface{}{"lowCutoffFrequency": e.LowCutoffFrequency, "highCutoffFrequency": e.HighCutoffFrequency}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffBand) safeParams() map[string]interface{} {
	return map[string]interface{}{"lowCutoffFrequency": e.LowCutoffFrequency, "highCutoffFrequency": e.HighCutoffFrequency, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidCutoffBand) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffBand) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidCutoffBand) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SignalFilterInvalidCutoffBand) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.signalFilterInvalidCutoffBand)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:SignalFilterInvalidCutoffBand", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SignalFilterInvalidCutoffBand) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters signalFilterInvalidCutoffBand
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.signalFilterInvalidCutoffBand = parameters
	return nil
}

type signalFilterInvalidCutoffFrequency struct {
	InvalidCutoffFrequency float64 `json:"invalidCutoffFrequency"`
	SamplingFrequency      float64 `json:"samplingFrequency"`
}

func (o signalFilterInvalidCutoffFrequency) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *signalFilterInvalidCutoffFrequency) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSignalFilterInvalidCutoffFrequency returns new instance of SignalFilterInvalidCutoffFrequency error.
func NewSignalFilterInvalidCutoffFrequency(invalidCutoffFrequencyArg float64, samplingFrequencyArg float64) *SignalFilterInvalidCutoffFrequency {
	return &SignalFilterInvalidCutoffFrequency{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), signalFilterInvalidCutoffFrequency: signalFilterInvalidCutoffFrequency{InvalidCutoffFrequency: invalidCutoffFrequencyArg, SamplingFrequency: samplingFrequencyArg}}
}

// WrapWithSignalFilterInvalidCutoffFrequency returns new instance of SignalFilterInvalidCutoffFrequency error wrapping an existing error.
func WrapWithSignalFilterInvalidCutoffFrequency(err error, invalidCutoffFrequencyArg float64, samplingFrequencyArg float64) *SignalFilterInvalidCutoffFrequency {
	return &SignalFilterInvalidCutoffFrequency{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, signalFilterInvalidCutoffFrequency: signalFilterInvalidCutoffFrequency{InvalidCutoffFrequency: invalidCutoffFrequencyArg, SamplingFrequency: samplingFrequencyArg}}
}

// SignalFilterInvalidCutoffFrequency is an error type.
// Cutoff frequency must be less than half the sampling frequency.
type SignalFilterInvalidCutoffFrequency struct {
	errorInstanceID uuid.UUID
	signalFilterInvalidCutoffFrequency
	cause error
	stack werror.StackTrace
}

// IsSignalFilterInvalidCutoffFrequency returns true if err is an instance of SignalFilterInvalidCutoffFrequency.
func IsSignalFilterInvalidCutoffFrequency(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SignalFilterInvalidCutoffFrequency)
	return ok
}

func (e *SignalFilterInvalidCutoffFrequency) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:SignalFilterInvalidCutoffFrequency (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SignalFilterInvalidCutoffFrequency) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SignalFilterInvalidCutoffFrequency) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SignalFilterInvalidCutoffFrequency) Message() string {
	return "INVALID_ARGUMENT Compute:SignalFilterInvalidCutoffFrequency"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SignalFilterInvalidCutoffFrequency) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SignalFilterInvalidCutoffFrequency) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SignalFilterInvalidCutoffFrequency) Name() string {
	return "Compute:SignalFilterInvalidCutoffFrequency"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SignalFilterInvalidCutoffFrequency) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffFrequency) Parameters() map[string]interface{} {
	return map[string]interface{}{"invalidCutoffFrequency": e.InvalidCutoffFrequency, "samplingFrequency": e.SamplingFrequency}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffFrequency) safeParams() map[string]interface{} {
	return map[string]interface{}{"invalidCutoffFrequency": e.InvalidCutoffFrequency, "samplingFrequency": e.SamplingFrequency, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidCutoffFrequency) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SignalFilterInvalidCutoffFrequency) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidCutoffFrequency) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SignalFilterInvalidCutoffFrequency) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.signalFilterInvalidCutoffFrequency)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:SignalFilterInvalidCutoffFrequency", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SignalFilterInvalidCutoffFrequency) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters signalFilterInvalidCutoffFrequency
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.signalFilterInvalidCutoffFrequency = parameters
	return nil
}

type signalFilterInvalidOrder struct {
	Order int `json:"order"`
}

func (o signalFilterInvalidOrder) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *signalFilterInvalidOrder) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSignalFilterInvalidOrder returns new instance of SignalFilterInvalidOrder error.
func NewSignalFilterInvalidOrder(orderArg int) *SignalFilterInvalidOrder {
	return &SignalFilterInvalidOrder{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), signalFilterInvalidOrder: signalFilterInvalidOrder{Order: orderArg}}
}

// WrapWithSignalFilterInvalidOrder returns new instance of SignalFilterInvalidOrder error wrapping an existing error.
func WrapWithSignalFilterInvalidOrder(err error, orderArg int) *SignalFilterInvalidOrder {
	return &SignalFilterInvalidOrder{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, signalFilterInvalidOrder: signalFilterInvalidOrder{Order: orderArg}}
}

// SignalFilterInvalidOrder is an error type.
/*
Order must be positive even numbers for bidirectional filters.
Bidirectional filters are applied once forwards and once backwards, effectively doubling order.
Doubled again for bandpass/bandstop filters, requiring a multiple of 4 for filter order.
*/
type SignalFilterInvalidOrder struct {
	errorInstanceID uuid.UUID
	signalFilterInvalidOrder
	cause error
	stack werror.StackTrace
}

// IsSignalFilterInvalidOrder returns true if err is an instance of SignalFilterInvalidOrder.
func IsSignalFilterInvalidOrder(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SignalFilterInvalidOrder)
	return ok
}

func (e *SignalFilterInvalidOrder) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:SignalFilterInvalidOrder (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SignalFilterInvalidOrder) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SignalFilterInvalidOrder) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SignalFilterInvalidOrder) Message() string {
	return "INVALID_ARGUMENT Compute:SignalFilterInvalidOrder"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SignalFilterInvalidOrder) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SignalFilterInvalidOrder) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SignalFilterInvalidOrder) Name() string {
	return "Compute:SignalFilterInvalidOrder"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SignalFilterInvalidOrder) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SignalFilterInvalidOrder) Parameters() map[string]interface{} {
	return map[string]interface{}{"order": e.Order}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SignalFilterInvalidOrder) safeParams() map[string]interface{} {
	return map[string]interface{}{"order": e.Order, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidOrder) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SignalFilterInvalidOrder) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterInvalidOrder) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SignalFilterInvalidOrder) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.signalFilterInvalidOrder)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:SignalFilterInvalidOrder", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SignalFilterInvalidOrder) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters signalFilterInvalidOrder
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.signalFilterInvalidOrder = parameters
	return nil
}

type signalFilterNonPositiveCutoffFrequency struct {
	CutoffFrequency float64 `json:"cutoffFrequency"`
}

func (o signalFilterNonPositiveCutoffFrequency) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *signalFilterNonPositiveCutoffFrequency) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSignalFilterNonPositiveCutoffFrequency returns new instance of SignalFilterNonPositiveCutoffFrequency error.
func NewSignalFilterNonPositiveCutoffFrequency(cutoffFrequencyArg float64) *SignalFilterNonPositiveCutoffFrequency {
	return &SignalFilterNonPositiveCutoffFrequency{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), signalFilterNonPositiveCutoffFrequency: signalFilterNonPositiveCutoffFrequency{CutoffFrequency: cutoffFrequencyArg}}
}

// WrapWithSignalFilterNonPositiveCutoffFrequency returns new instance of SignalFilterNonPositiveCutoffFrequency error wrapping an existing error.
func WrapWithSignalFilterNonPositiveCutoffFrequency(err error, cutoffFrequencyArg float64) *SignalFilterNonPositiveCutoffFrequency {
	return &SignalFilterNonPositiveCutoffFrequency{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, signalFilterNonPositiveCutoffFrequency: signalFilterNonPositiveCutoffFrequency{CutoffFrequency: cutoffFrequencyArg}}
}

// SignalFilterNonPositiveCutoffFrequency is an error type.
// Cutoff frequency must be strictly positive.
type SignalFilterNonPositiveCutoffFrequency struct {
	errorInstanceID uuid.UUID
	signalFilterNonPositiveCutoffFrequency
	cause error
	stack werror.StackTrace
}

// IsSignalFilterNonPositiveCutoffFrequency returns true if err is an instance of SignalFilterNonPositiveCutoffFrequency.
func IsSignalFilterNonPositiveCutoffFrequency(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SignalFilterNonPositiveCutoffFrequency)
	return ok
}

func (e *SignalFilterNonPositiveCutoffFrequency) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:SignalFilterNonPositiveCutoffFrequency (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SignalFilterNonPositiveCutoffFrequency) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SignalFilterNonPositiveCutoffFrequency) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SignalFilterNonPositiveCutoffFrequency) Message() string {
	return "INVALID_ARGUMENT Compute:SignalFilterNonPositiveCutoffFrequency"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SignalFilterNonPositiveCutoffFrequency) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SignalFilterNonPositiveCutoffFrequency) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SignalFilterNonPositiveCutoffFrequency) Name() string {
	return "Compute:SignalFilterNonPositiveCutoffFrequency"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SignalFilterNonPositiveCutoffFrequency) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SignalFilterNonPositiveCutoffFrequency) Parameters() map[string]interface{} {
	return map[string]interface{}{"cutoffFrequency": e.CutoffFrequency}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SignalFilterNonPositiveCutoffFrequency) safeParams() map[string]interface{} {
	return map[string]interface{}{"cutoffFrequency": e.CutoffFrequency, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterNonPositiveCutoffFrequency) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SignalFilterNonPositiveCutoffFrequency) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterNonPositiveCutoffFrequency) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SignalFilterNonPositiveCutoffFrequency) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.signalFilterNonPositiveCutoffFrequency)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:SignalFilterNonPositiveCutoffFrequency", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SignalFilterNonPositiveCutoffFrequency) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters signalFilterNonPositiveCutoffFrequency
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.signalFilterNonPositiveCutoffFrequency = parameters
	return nil
}

type signalFilterNotEnoughData struct {
	RequiredMinPoints int `json:"requiredMinPoints"`
	LenPoints         int `json:"lenPoints"`
}

func (o signalFilterNotEnoughData) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *signalFilterNotEnoughData) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSignalFilterNotEnoughData returns new instance of SignalFilterNotEnoughData error.
func NewSignalFilterNotEnoughData(requiredMinPointsArg int, lenPointsArg int) *SignalFilterNotEnoughData {
	return &SignalFilterNotEnoughData{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), signalFilterNotEnoughData: signalFilterNotEnoughData{RequiredMinPoints: requiredMinPointsArg, LenPoints: lenPointsArg}}
}

// WrapWithSignalFilterNotEnoughData returns new instance of SignalFilterNotEnoughData error wrapping an existing error.
func WrapWithSignalFilterNotEnoughData(err error, requiredMinPointsArg int, lenPointsArg int) *SignalFilterNotEnoughData {
	return &SignalFilterNotEnoughData{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, signalFilterNotEnoughData: signalFilterNotEnoughData{RequiredMinPoints: requiredMinPointsArg, LenPoints: lenPointsArg}}
}

// SignalFilterNotEnoughData is an error type.
/*
Not enough data to apply the filter. Required data scales with filter order.
Try again with a larger time range.
*/
type SignalFilterNotEnoughData struct {
	errorInstanceID uuid.UUID
	signalFilterNotEnoughData
	cause error
	stack werror.StackTrace
}

// IsSignalFilterNotEnoughData returns true if err is an instance of SignalFilterNotEnoughData.
func IsSignalFilterNotEnoughData(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SignalFilterNotEnoughData)
	return ok
}

func (e *SignalFilterNotEnoughData) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:SignalFilterNotEnoughData (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SignalFilterNotEnoughData) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SignalFilterNotEnoughData) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SignalFilterNotEnoughData) Message() string {
	return "INVALID_ARGUMENT Compute:SignalFilterNotEnoughData"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SignalFilterNotEnoughData) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SignalFilterNotEnoughData) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SignalFilterNotEnoughData) Name() string {
	return "Compute:SignalFilterNotEnoughData"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SignalFilterNotEnoughData) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SignalFilterNotEnoughData) Parameters() map[string]interface{} {
	return map[string]interface{}{"requiredMinPoints": e.RequiredMinPoints, "lenPoints": e.LenPoints}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SignalFilterNotEnoughData) safeParams() map[string]interface{} {
	return map[string]interface{}{"requiredMinPoints": e.RequiredMinPoints, "lenPoints": e.LenPoints, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterNotEnoughData) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SignalFilterNotEnoughData) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SignalFilterNotEnoughData) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SignalFilterNotEnoughData) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.signalFilterNotEnoughData)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:SignalFilterNotEnoughData", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SignalFilterNotEnoughData) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters signalFilterNotEnoughData
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.signalFilterNotEnoughData = parameters
	return nil
}

type timeoutExceeded struct {
	QueryId uuid.UUID `json:"queryId"`
}

func (o timeoutExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *timeoutExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTimeoutExceeded returns new instance of TimeoutExceeded error.
func NewTimeoutExceeded(queryIdArg uuid.UUID) *TimeoutExceeded {
	return &TimeoutExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), timeoutExceeded: timeoutExceeded{QueryId: queryIdArg}}
}

// WrapWithTimeoutExceeded returns new instance of TimeoutExceeded error wrapping an existing error.
func WrapWithTimeoutExceeded(err error, queryIdArg uuid.UUID) *TimeoutExceeded {
	return &TimeoutExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, timeoutExceeded: timeoutExceeded{QueryId: queryIdArg}}
}

// TimeoutExceeded is an error type.
// The query timed out. Try querying a smaller time range or fewer series.
type TimeoutExceeded struct {
	errorInstanceID uuid.UUID
	timeoutExceeded
	cause error
	stack werror.StackTrace
}

// IsTimeoutExceeded returns true if err is an instance of TimeoutExceeded.
func IsTimeoutExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TimeoutExceeded)
	return ok
}

func (e *TimeoutExceeded) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TimeoutExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TimeoutExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TimeoutExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TimeoutExceeded) Message() string {
	return "INVALID_ARGUMENT Compute:TimeoutExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TimeoutExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TimeoutExceeded) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TimeoutExceeded) Name() string {
	return "Compute:TimeoutExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TimeoutExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TimeoutExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TimeoutExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TimeoutExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TimeoutExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TimeoutExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TimeoutExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.timeoutExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TimeoutExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TimeoutExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters timeoutExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.timeoutExceeded = parameters
	return nil
}

type tooFewInputs struct {
	RequiredInputCount int `json:"requiredInputCount"`
	ProvidedInputCount int `json:"providedInputCount"`
}

func (o tooFewInputs) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooFewInputs) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooFewInputs returns new instance of TooFewInputs error.
func NewTooFewInputs(requiredInputCountArg int, providedInputCountArg int) *TooFewInputs {
	return &TooFewInputs{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooFewInputs: tooFewInputs{RequiredInputCount: requiredInputCountArg, ProvidedInputCount: providedInputCountArg}}
}

// WrapWithTooFewInputs returns new instance of TooFewInputs error wrapping an existing error.
func WrapWithTooFewInputs(err error, requiredInputCountArg int, providedInputCountArg int) *TooFewInputs {
	return &TooFewInputs{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooFewInputs: tooFewInputs{RequiredInputCount: requiredInputCountArg, ProvidedInputCount: providedInputCountArg}}
}

// TooFewInputs is an error type.
// The operation requires more input series than were provided.
type TooFewInputs struct {
	errorInstanceID uuid.UUID
	tooFewInputs
	cause error
	stack werror.StackTrace
}

// IsTooFewInputs returns true if err is an instance of TooFewInputs.
func IsTooFewInputs(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooFewInputs)
	return ok
}

func (e *TooFewInputs) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooFewInputs (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooFewInputs) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooFewInputs) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooFewInputs) Message() string {
	return "INVALID_ARGUMENT Compute:TooFewInputs"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooFewInputs) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooFewInputs) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooFewInputs) Name() string {
	return "Compute:TooFewInputs"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooFewInputs) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooFewInputs) Parameters() map[string]interface{} {
	return map[string]interface{}{"requiredInputCount": e.RequiredInputCount, "providedInputCount": e.ProvidedInputCount}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooFewInputs) safeParams() map[string]interface{} {
	return map[string]interface{}{"requiredInputCount": e.RequiredInputCount, "providedInputCount": e.ProvidedInputCount, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooFewInputs) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooFewInputs) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooFewInputs) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooFewInputs) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooFewInputs)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooFewInputs", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooFewInputs) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooFewInputs
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooFewInputs = parameters
	return nil
}

type tooManyBuckets struct{}

func (o tooManyBuckets) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyBuckets) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyBuckets returns new instance of TooManyBuckets error.
func NewTooManyBuckets() *TooManyBuckets {
	return &TooManyBuckets{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyBuckets: tooManyBuckets{}}
}

// WrapWithTooManyBuckets returns new instance of TooManyBuckets error wrapping an existing error.
func WrapWithTooManyBuckets(err error) *TooManyBuckets {
	return &TooManyBuckets{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyBuckets: tooManyBuckets{}}
}

// TooManyBuckets is an error type.
/*
The number of buckets returned is greater than the max allowed (1000). Try again by specifying a larger bucket width or
fewer bucket counts.
*/
type TooManyBuckets struct {
	errorInstanceID uuid.UUID
	tooManyBuckets
	cause error
	stack werror.StackTrace
}

// IsTooManyBuckets returns true if err is an instance of TooManyBuckets.
func IsTooManyBuckets(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyBuckets)
	return ok
}

func (e *TooManyBuckets) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyBuckets (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyBuckets) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyBuckets) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyBuckets) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyBuckets"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyBuckets) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyBuckets) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyBuckets) Name() string {
	return "Compute:TooManyBuckets"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyBuckets) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyBuckets) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyBuckets) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyBuckets) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyBuckets) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyBuckets) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyBuckets) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyBuckets)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyBuckets", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyBuckets) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyBuckets
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyBuckets = parameters
	return nil
}

type tooManyCategories struct {
	NumCategories int `json:"numCategories"`
	MaxAllowed    int `json:"maxAllowed"`
}

func (o tooManyCategories) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyCategories) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyCategories returns new instance of TooManyCategories error.
func NewTooManyCategories(numCategoriesArg int, maxAllowedArg int) *TooManyCategories {
	return &TooManyCategories{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyCategories: tooManyCategories{NumCategories: numCategoriesArg, MaxAllowed: maxAllowedArg}}
}

// WrapWithTooManyCategories returns new instance of TooManyCategories error wrapping an existing error.
func WrapWithTooManyCategories(err error, numCategoriesArg int, maxAllowedArg int) *TooManyCategories {
	return &TooManyCategories{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyCategories: tooManyCategories{NumCategories: numCategoriesArg, MaxAllowed: maxAllowedArg}}
}

// TooManyCategories is an error type.
// An enum series has more categories than the max allowed.
type TooManyCategories struct {
	errorInstanceID uuid.UUID
	tooManyCategories
	cause error
	stack werror.StackTrace
}

// IsTooManyCategories returns true if err is an instance of TooManyCategories.
func IsTooManyCategories(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyCategories)
	return ok
}

func (e *TooManyCategories) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyCategories (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyCategories) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyCategories) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyCategories) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyCategories"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyCategories) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyCategories) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyCategories) Name() string {
	return "Compute:TooManyCategories"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyCategories) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyCategories) Parameters() map[string]interface{} {
	return map[string]interface{}{"numCategories": e.NumCategories, "maxAllowed": e.MaxAllowed}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyCategories) safeParams() map[string]interface{} {
	return map[string]interface{}{"numCategories": e.NumCategories, "maxAllowed": e.MaxAllowed, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyCategories) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyCategories) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyCategories) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyCategories) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyCategories)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyCategories", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyCategories) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyCategories
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyCategories = parameters
	return nil
}

type tooManyEvents struct{}

func (o tooManyEvents) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyEvents) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyEvents returns new instance of TooManyEvents error.
func NewTooManyEvents() *TooManyEvents {
	return &TooManyEvents{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyEvents: tooManyEvents{}}
}

// WrapWithTooManyEvents returns new instance of TooManyEvents error wrapping an existing error.
func WrapWithTooManyEvents(err error) *TooManyEvents {
	return &TooManyEvents{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyEvents: tooManyEvents{}}
}

// TooManyEvents is an error type.
// Number of events is greater than the max allowed (1000).
type TooManyEvents struct {
	errorInstanceID uuid.UUID
	tooManyEvents
	cause error
	stack werror.StackTrace
}

// IsTooManyEvents returns true if err is an instance of TooManyEvents.
func IsTooManyEvents(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyEvents)
	return ok
}

func (e *TooManyEvents) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyEvents (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyEvents) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyEvents) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyEvents) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyEvents"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyEvents) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyEvents) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyEvents) Name() string {
	return "Compute:TooManyEvents"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyEvents) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyEvents) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyEvents) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyEvents) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyEvents) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyEvents) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyEvents) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyEvents)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyEvents", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyEvents) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyEvents
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyEvents = parameters
	return nil
}

type tooManyLiterals struct {
	Count int `json:"count"`
}

func (o tooManyLiterals) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyLiterals) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyLiterals returns new instance of TooManyLiterals error.
func NewTooManyLiterals(countArg int) *TooManyLiterals {
	return &TooManyLiterals{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyLiterals: tooManyLiterals{Count: countArg}}
}

// WrapWithTooManyLiterals returns new instance of TooManyLiterals error wrapping an existing error.
func WrapWithTooManyLiterals(err error, countArg int) *TooManyLiterals {
	return &TooManyLiterals{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyLiterals: tooManyLiterals{Count: countArg}}
}

// TooManyLiterals is an error type.
// Too many literals provided in a literal node.
type TooManyLiterals struct {
	errorInstanceID uuid.UUID
	tooManyLiterals
	cause error
	stack werror.StackTrace
}

// IsTooManyLiterals returns true if err is an instance of TooManyLiterals.
func IsTooManyLiterals(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyLiterals)
	return ok
}

func (e *TooManyLiterals) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyLiterals (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyLiterals) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyLiterals) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyLiterals) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyLiterals"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyLiterals) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyLiterals) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyLiterals) Name() string {
	return "Compute:TooManyLiterals"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyLiterals) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyLiterals) Parameters() map[string]interface{} {
	return map[string]interface{}{"count": e.Count}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyLiterals) safeParams() map[string]interface{} {
	return map[string]interface{}{"count": e.Count, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyLiterals) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyLiterals) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyLiterals) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyLiterals) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyLiterals)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyLiterals", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyLiterals) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyLiterals
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyLiterals = parameters
	return nil
}

type tooManyPoints struct{}

func (o tooManyPoints) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyPoints) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyPoints returns new instance of TooManyPoints error.
func NewTooManyPoints() *TooManyPoints {
	return &TooManyPoints{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyPoints: tooManyPoints{}}
}

// WrapWithTooManyPoints returns new instance of TooManyPoints error wrapping an existing error.
func WrapWithTooManyPoints(err error) *TooManyPoints {
	return &TooManyPoints{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyPoints: tooManyPoints{}}
}

// TooManyPoints is an error type.
/*
The number of points returned is greater than the max allowed. Try again with a smaller time
range, or a larger resolution.
*/
type TooManyPoints struct {
	errorInstanceID uuid.UUID
	tooManyPoints
	cause error
	stack werror.StackTrace
}

// IsTooManyPoints returns true if err is an instance of TooManyPoints.
func IsTooManyPoints(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyPoints)
	return ok
}

func (e *TooManyPoints) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyPoints (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyPoints) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyPoints) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyPoints) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyPoints"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyPoints) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyPoints) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyPoints) Name() string {
	return "Compute:TooManyPoints"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyPoints) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyPoints) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyPoints) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyPoints) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyPoints) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyPoints) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyPoints) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyPoints)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyPoints", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyPoints) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyPoints
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyPoints = parameters
	return nil
}

type tooManyRanges struct{}

func (o tooManyRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyRanges returns new instance of TooManyRanges error.
func NewTooManyRanges() *TooManyRanges {
	return &TooManyRanges{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyRanges: tooManyRanges{}}
}

// WrapWithTooManyRanges returns new instance of TooManyRanges error wrapping an existing error.
func WrapWithTooManyRanges(err error) *TooManyRanges {
	return &TooManyRanges{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyRanges: tooManyRanges{}}
}

// TooManyRanges is an error type.
// Ranges is greater than the max allowed (2000).
type TooManyRanges struct {
	errorInstanceID uuid.UUID
	tooManyRanges
	cause error
	stack werror.StackTrace
}

// IsTooManyRanges returns true if err is an instance of TooManyRanges.
func IsTooManyRanges(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyRanges)
	return ok
}

func (e *TooManyRanges) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyRanges (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyRanges) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyRanges) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyRanges) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyRanges"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyRanges) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyRanges) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyRanges) Name() string {
	return "Compute:TooManyRanges"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyRanges) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyRanges) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyRanges) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyRanges) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyRanges) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyRanges) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyRanges) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyRanges)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyRanges", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyRanges) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyRanges
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyRanges = parameters
	return nil
}

type tooManyResamplePoints struct{}

func (o tooManyResamplePoints) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyResamplePoints) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyResamplePoints returns new instance of TooManyResamplePoints error.
func NewTooManyResamplePoints() *TooManyResamplePoints {
	return &TooManyResamplePoints{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyResamplePoints: tooManyResamplePoints{}}
}

// WrapWithTooManyResamplePoints returns new instance of TooManyResamplePoints error wrapping an existing error.
func WrapWithTooManyResamplePoints(err error) *TooManyResamplePoints {
	return &TooManyResamplePoints{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyResamplePoints: tooManyResamplePoints{}}
}

// TooManyResamplePoints is an error type.
// The resample interval is too short and would produce more than the max points (10,000,000). Try again by specifying a larger interval.
type TooManyResamplePoints struct {
	errorInstanceID uuid.UUID
	tooManyResamplePoints
	cause error
	stack werror.StackTrace
}

// IsTooManyResamplePoints returns true if err is an instance of TooManyResamplePoints.
func IsTooManyResamplePoints(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyResamplePoints)
	return ok
}

func (e *TooManyResamplePoints) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManyResamplePoints (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyResamplePoints) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyResamplePoints) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyResamplePoints) Message() string {
	return "INVALID_ARGUMENT Compute:TooManyResamplePoints"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyResamplePoints) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyResamplePoints) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyResamplePoints) Name() string {
	return "Compute:TooManyResamplePoints"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyResamplePoints) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyResamplePoints) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyResamplePoints) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyResamplePoints) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyResamplePoints) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyResamplePoints) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyResamplePoints) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyResamplePoints)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManyResamplePoints", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyResamplePoints) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyResamplePoints
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyResamplePoints = parameters
	return nil
}

type tooManySubrequests struct{}

func (o tooManySubrequests) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManySubrequests) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManySubrequests returns new instance of TooManySubrequests error.
func NewTooManySubrequests() *TooManySubrequests {
	return &TooManySubrequests{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManySubrequests: tooManySubrequests{}}
}

// WrapWithTooManySubrequests returns new instance of TooManySubrequests error wrapping an existing error.
func WrapWithTooManySubrequests(err error) *TooManySubrequests {
	return &TooManySubrequests{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManySubrequests: tooManySubrequests{}}
}

// TooManySubrequests is an error type.
// Number of parameterized subrequests is greater than the max allowed (300).
type TooManySubrequests struct {
	errorInstanceID uuid.UUID
	tooManySubrequests
	cause error
	stack werror.StackTrace
}

// IsTooManySubrequests returns true if err is an instance of TooManySubrequests.
func IsTooManySubrequests(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManySubrequests)
	return ok
}

func (e *TooManySubrequests) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:TooManySubrequests (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManySubrequests) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManySubrequests) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManySubrequests) Message() string {
	return "INVALID_ARGUMENT Compute:TooManySubrequests"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManySubrequests) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManySubrequests) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManySubrequests) Name() string {
	return "Compute:TooManySubrequests"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManySubrequests) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManySubrequests) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManySubrequests) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManySubrequests) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManySubrequests) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManySubrequests) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManySubrequests) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManySubrequests)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:TooManySubrequests", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManySubrequests) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManySubrequests
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManySubrequests = parameters
	return nil
}

type unexpectedTimeout struct {
	QueryId uuid.UUID `json:"queryId"`
}

func (o unexpectedTimeout) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *unexpectedTimeout) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUnexpectedTimeout returns new instance of UnexpectedTimeout error.
func NewUnexpectedTimeout(queryIdArg uuid.UUID) *UnexpectedTimeout {
	return &UnexpectedTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), unexpectedTimeout: unexpectedTimeout{QueryId: queryIdArg}}
}

// WrapWithUnexpectedTimeout returns new instance of UnexpectedTimeout error wrapping an existing error.
func WrapWithUnexpectedTimeout(err error, queryIdArg uuid.UUID) *UnexpectedTimeout {
	return &UnexpectedTimeout{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, unexpectedTimeout: unexpectedTimeout{QueryId: queryIdArg}}
}

// UnexpectedTimeout is an error type.
/*
An unexpected timeout occurred when executing a query. This indicates an internal error
where the query may have succeeded but the response did not reach the client.
*/
type UnexpectedTimeout struct {
	errorInstanceID uuid.UUID
	unexpectedTimeout
	cause error
	stack werror.StackTrace
}

// IsUnexpectedTimeout returns true if err is an instance of UnexpectedTimeout.
func IsUnexpectedTimeout(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*UnexpectedTimeout)
	return ok
}

func (e *UnexpectedTimeout) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:UnexpectedTimeout (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *UnexpectedTimeout) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *UnexpectedTimeout) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *UnexpectedTimeout) Message() string {
	return "INVALID_ARGUMENT Compute:UnexpectedTimeout"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *UnexpectedTimeout) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *UnexpectedTimeout) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *UnexpectedTimeout) Name() string {
	return "Compute:UnexpectedTimeout"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *UnexpectedTimeout) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *UnexpectedTimeout) Parameters() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *UnexpectedTimeout) safeParams() map[string]interface{} {
	return map[string]interface{}{"queryId": e.QueryId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnexpectedTimeout) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *UnexpectedTimeout) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnexpectedTimeout) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e UnexpectedTimeout) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.unexpectedTimeout)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:UnexpectedTimeout", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *UnexpectedTimeout) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters unexpectedTimeout
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.unexpectedTimeout = parameters
	return nil
}

type unitConversionInvalid struct {
	InputUnit  api1.UnitSymbol `json:"inputUnit"`
	OutputUnit api1.UnitSymbol `json:"outputUnit"`
}

func (o unitConversionInvalid) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *unitConversionInvalid) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUnitConversionInvalid returns new instance of UnitConversionInvalid error.
func NewUnitConversionInvalid(inputUnitArg api1.UnitSymbol, outputUnitArg api1.UnitSymbol) *UnitConversionInvalid {
	return &UnitConversionInvalid{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), unitConversionInvalid: unitConversionInvalid{InputUnit: inputUnitArg, OutputUnit: outputUnitArg}}
}

// WrapWithUnitConversionInvalid returns new instance of UnitConversionInvalid error wrapping an existing error.
func WrapWithUnitConversionInvalid(err error, inputUnitArg api1.UnitSymbol, outputUnitArg api1.UnitSymbol) *UnitConversionInvalid {
	return &UnitConversionInvalid{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, unitConversionInvalid: unitConversionInvalid{InputUnit: inputUnitArg, OutputUnit: outputUnitArg}}
}

// UnitConversionInvalid is an error type.
/*
The unit conversion could not be computed because the input unit cannot be converted
to the output unit.
*/
type UnitConversionInvalid struct {
	errorInstanceID uuid.UUID
	unitConversionInvalid
	cause error
	stack werror.StackTrace
}

// IsUnitConversionInvalid returns true if err is an instance of UnitConversionInvalid.
func IsUnitConversionInvalid(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*UnitConversionInvalid)
	return ok
}

func (e *UnitConversionInvalid) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:UnitConversionInvalid (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *UnitConversionInvalid) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *UnitConversionInvalid) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *UnitConversionInvalid) Message() string {
	return "INVALID_ARGUMENT Compute:UnitConversionInvalid"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *UnitConversionInvalid) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *UnitConversionInvalid) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *UnitConversionInvalid) Name() string {
	return "Compute:UnitConversionInvalid"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *UnitConversionInvalid) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *UnitConversionInvalid) Parameters() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit, "outputUnit": e.OutputUnit}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *UnitConversionInvalid) safeParams() map[string]interface{} {
	return map[string]interface{}{"inputUnit": e.InputUnit, "outputUnit": e.OutputUnit, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnitConversionInvalid) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *UnitConversionInvalid) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnitConversionInvalid) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e UnitConversionInvalid) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.unitConversionInvalid)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:UnitConversionInvalid", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *UnitConversionInvalid) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters unitConversionInvalid
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.unitConversionInvalid = parameters
	return nil
}

type unsupportedRefpropProperty struct {
	Property     string `json:"property"`
	PropertyType string `json:"propertyType"`
}

func (o unsupportedRefpropProperty) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *unsupportedRefpropProperty) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUnsupportedRefpropProperty returns new instance of UnsupportedRefpropProperty error.
func NewUnsupportedRefpropProperty(propertyArg string, propertyTypeArg string) *UnsupportedRefpropProperty {
	return &UnsupportedRefpropProperty{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), unsupportedRefpropProperty: unsupportedRefpropProperty{Property: propertyArg, PropertyType: propertyTypeArg}}
}

// WrapWithUnsupportedRefpropProperty returns new instance of UnsupportedRefpropProperty error wrapping an existing error.
func WrapWithUnsupportedRefpropProperty(err error, propertyArg string, propertyTypeArg string) *UnsupportedRefpropProperty {
	return &UnsupportedRefpropProperty{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, unsupportedRefpropProperty: unsupportedRefpropProperty{Property: propertyArg, PropertyType: propertyTypeArg}}
}

// UnsupportedRefpropProperty is an error type.
// The specified REFPROP property is not supported or not available in the current configuration.
type UnsupportedRefpropProperty struct {
	errorInstanceID uuid.UUID
	unsupportedRefpropProperty
	cause error
	stack werror.StackTrace
}

// IsUnsupportedRefpropProperty returns true if err is an instance of UnsupportedRefpropProperty.
func IsUnsupportedRefpropProperty(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*UnsupportedRefpropProperty)
	return ok
}

func (e *UnsupportedRefpropProperty) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:UnsupportedRefpropProperty (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *UnsupportedRefpropProperty) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *UnsupportedRefpropProperty) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *UnsupportedRefpropProperty) Message() string {
	return "INVALID_ARGUMENT Compute:UnsupportedRefpropProperty"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *UnsupportedRefpropProperty) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *UnsupportedRefpropProperty) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *UnsupportedRefpropProperty) Name() string {
	return "Compute:UnsupportedRefpropProperty"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *UnsupportedRefpropProperty) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *UnsupportedRefpropProperty) Parameters() map[string]interface{} {
	return map[string]interface{}{"property": e.Property, "propertyType": e.PropertyType}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *UnsupportedRefpropProperty) safeParams() map[string]interface{} {
	return map[string]interface{}{"property": e.Property, "propertyType": e.PropertyType, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnsupportedRefpropProperty) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *UnsupportedRefpropProperty) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnsupportedRefpropProperty) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e UnsupportedRefpropProperty) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.unsupportedRefpropProperty)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:UnsupportedRefpropProperty", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *UnsupportedRefpropProperty) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters unsupportedRefpropProperty
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.unsupportedRefpropProperty = parameters
	return nil
}

type variableHasWrongType struct {
	VariableName VariableName `json:"variableName"`
	ExpectedType string       `json:"expectedType"`
}

func (o variableHasWrongType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *variableHasWrongType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewVariableHasWrongType returns new instance of VariableHasWrongType error.
func NewVariableHasWrongType(variableNameArg VariableName, expectedTypeArg string) *VariableHasWrongType {
	return &VariableHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), variableHasWrongType: variableHasWrongType{VariableName: variableNameArg, ExpectedType: expectedTypeArg}}
}

// WrapWithVariableHasWrongType returns new instance of VariableHasWrongType error wrapping an existing error.
func WrapWithVariableHasWrongType(err error, variableNameArg VariableName, expectedTypeArg string) *VariableHasWrongType {
	return &VariableHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, variableHasWrongType: variableHasWrongType{VariableName: variableNameArg, ExpectedType: expectedTypeArg}}
}

// VariableHasWrongType is an error type.
type VariableHasWrongType struct {
	errorInstanceID uuid.UUID
	variableHasWrongType
	cause error
	stack werror.StackTrace
}

// IsVariableHasWrongType returns true if err is an instance of VariableHasWrongType.
func IsVariableHasWrongType(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*VariableHasWrongType)
	return ok
}

func (e *VariableHasWrongType) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:VariableHasWrongType (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *VariableHasWrongType) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *VariableHasWrongType) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *VariableHasWrongType) Message() string {
	return "INVALID_ARGUMENT Compute:VariableHasWrongType"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *VariableHasWrongType) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *VariableHasWrongType) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *VariableHasWrongType) Name() string {
	return "Compute:VariableHasWrongType"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *VariableHasWrongType) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *VariableHasWrongType) Parameters() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "expectedType": e.ExpectedType}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *VariableHasWrongType) safeParams() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "expectedType": e.ExpectedType, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *VariableHasWrongType) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *VariableHasWrongType) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *VariableHasWrongType) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e VariableHasWrongType) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.variableHasWrongType)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:VariableHasWrongType", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *VariableHasWrongType) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters variableHasWrongType
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.variableHasWrongType = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Compute:CannotAggregateEnumPlot", reflect.TypeOf(CannotAggregateEnumPlot{}))
	conjureerrors.RegisterErrorType("Compute:CannotCompileRegexp", reflect.TypeOf(CannotCompileRegexp{}))
	conjureerrors.RegisterErrorType("Compute:ChannelHasWrongType", reflect.TypeOf(ChannelHasWrongType{}))
	conjureerrors.RegisterErrorType("Compute:ConcurrentQueriesExceeded", reflect.TypeOf(ConcurrentQueriesExceeded{}))
	conjureerrors.RegisterErrorType("Compute:ConverterInputUnitNotFound", reflect.TypeOf(ConverterInputUnitNotFound{}))
	conjureerrors.RegisterErrorType("Compute:ConverterOutputUnitNotFound", reflect.TypeOf(ConverterOutputUnitNotFound{}))
	conjureerrors.RegisterErrorType("Compute:CurveInvalidNegativeInputs", reflect.TypeOf(CurveInvalidNegativeInputs{}))
	conjureerrors.RegisterErrorType("Compute:CurveUnequalInputLength", reflect.TypeOf(CurveUnequalInputLength{}))
	conjureerrors.RegisterErrorType("Compute:DuplicateTimestamp", reflect.TypeOf(DuplicateTimestamp{}))
	conjureerrors.RegisterErrorType("Compute:EmptyInput", reflect.TypeOf(EmptyInput{}))
	conjureerrors.RegisterErrorType("Compute:EmptySet", reflect.TypeOf(EmptySet{}))
	conjureerrors.RegisterErrorType("Compute:ExponentialCurveInputTooLarge", reflect.TypeOf(ExponentialCurveInputTooLarge{}))
	conjureerrors.RegisterErrorType("ExternalDatabase:ExternalDatabaseBadGateway", reflect.TypeOf(ExternalDatabaseBadGateway{}))
	conjureerrors.RegisterErrorType("ExternalDatabase:ExternalDatabaseGatewayTimeout", reflect.TypeOf(ExternalDatabaseGatewayTimeout{}))
	conjureerrors.RegisterErrorType("ExternalDatabase:ExternalDatabaseSocketTimeout", reflect.TypeOf(ExternalDatabaseSocketTimeout{}))
	conjureerrors.RegisterErrorType("Compute:FrequencyDomainWindowEmpty", reflect.TypeOf(FrequencyDomainWindowEmpty{}))
	conjureerrors.RegisterErrorType("Compute:FrequencyDomainWindowTooLarge", reflect.TypeOf(FrequencyDomainWindowTooLarge{}))
	conjureerrors.RegisterErrorType("Compute:GranularityMismatch", reflect.TypeOf(GranularityMismatch{}))
	conjureerrors.RegisterErrorType("Compute:GroupByMissingTag", reflect.TypeOf(GroupByMissingTag{}))
	conjureerrors.RegisterErrorType("Compute:GroupByTagsNotSubset", reflect.TypeOf(GroupByTagsNotSubset{}))
	conjureerrors.RegisterErrorType("Compute:GroupBysNotSupportedForQuery", reflect.TypeOf(GroupBysNotSupportedForQuery{}))
	conjureerrors.RegisterErrorType("Compute:InvalidBitOperation", reflect.TypeOf(InvalidBitOperation{}))
	conjureerrors.RegisterErrorType("Compute:InvalidExpression", reflect.TypeOf(InvalidExpression{}))
	conjureerrors.RegisterErrorType("Compute:InvalidFieldName", reflect.TypeOf(InvalidFieldName{}))
	conjureerrors.RegisterErrorType("Compute:InvalidLiteralRange", reflect.TypeOf(InvalidLiteralRange{}))
	conjureerrors.RegisterErrorType("Compute:InvalidNumericOutputFields", reflect.TypeOf(InvalidNumericOutputFields{}))
	conjureerrors.RegisterErrorType("Compute:InvalidPlotType", reflect.TypeOf(InvalidPlotType{}))
	conjureerrors.RegisterErrorType("Compute:InvalidRangeNodeStartAfterViewRange", reflect.TypeOf(InvalidRangeNodeStartAfterViewRange{}))
	conjureerrors.RegisterErrorType("Compute:InvalidRefpropInputCount", reflect.TypeOf(InvalidRefpropInputCount{}))
	conjureerrors.RegisterErrorType("Compute:InvalidSeriesLocator", reflect.TypeOf(InvalidSeriesLocator{}))
	conjureerrors.RegisterErrorType("Compute:InvalidTagFilterConfiguration", reflect.TypeOf(InvalidTagFilterConfiguration{}))
	conjureerrors.RegisterErrorType("Compute:InvalidTimeUnit", reflect.TypeOf(InvalidTimeUnit{}))
	conjureerrors.RegisterErrorType("Compute:InvalidValueMap", reflect.TypeOf(InvalidValueMap{}))
	conjureerrors.RegisterErrorType("Compute:MaxQuerySizeExceeded", reflect.TypeOf(MaxQuerySizeExceeded{}))
	conjureerrors.RegisterErrorType("Compute:MemoryLimitExceeded", reflect.TypeOf(MemoryLimitExceeded{}))
	conjureerrors.RegisterErrorType("Compute:MissingFunctionParameter", reflect.TypeOf(MissingFunctionParameter{}))
	conjureerrors.RegisterErrorType("Compute:MissingModuleApplication", reflect.TypeOf(MissingModuleApplication{}))
	conjureerrors.RegisterErrorType("Compute:MissingModuleFunction", reflect.TypeOf(MissingModuleFunction{}))
	conjureerrors.RegisterErrorType("Compute:NotAuthorized", reflect.TypeOf(NotAuthorized{}))
	conjureerrors.RegisterErrorType("Compute:NotEnoughPointsForCurve", reflect.TypeOf(NotEnoughPointsForCurve{}))
	conjureerrors.RegisterErrorType("Compute:OverlappingLiteralRanges", reflect.TypeOf(OverlappingLiteralRanges{}))
	conjureerrors.RegisterErrorType("Compute:PicosRangeTooLarge", reflect.TypeOf(PicosRangeTooLarge{}))
	conjureerrors.RegisterErrorType("Compute:QueryRangeTooLarge", reflect.TypeOf(QueryRangeTooLarge{}))
	conjureerrors.RegisterErrorType("Compute:RefpropInputTooLarge", reflect.TypeOf(RefpropInputTooLarge{}))
	conjureerrors.RegisterErrorType("Compute:RefpropOutputPropertyIsInput", reflect.TypeOf(RefpropOutputPropertyIsInput{}))
	conjureerrors.RegisterErrorType("Compute:RequestedRowsLimitExceeded", reflect.TypeOf(RequestedRowsLimitExceeded{}))
	conjureerrors.RegisterErrorType("Compute:ResampleDefaultValueTypeMismatchesSeriesType", reflect.TypeOf(ResampleDefaultValueTypeMismatchesSeriesType{}))
	conjureerrors.RegisterErrorType("Compute:RowLimitExceeded", reflect.TypeOf(RowLimitExceeded{}))
	conjureerrors.RegisterErrorType("Compute:SignalFilterInvalidCutoffBand", reflect.TypeOf(SignalFilterInvalidCutoffBand{}))
	conjureerrors.RegisterErrorType("Compute:SignalFilterInvalidCutoffFrequency", reflect.TypeOf(SignalFilterInvalidCutoffFrequency{}))
	conjureerrors.RegisterErrorType("Compute:SignalFilterInvalidOrder", reflect.TypeOf(SignalFilterInvalidOrder{}))
	conjureerrors.RegisterErrorType("Compute:SignalFilterNonPositiveCutoffFrequency", reflect.TypeOf(SignalFilterNonPositiveCutoffFrequency{}))
	conjureerrors.RegisterErrorType("Compute:SignalFilterNotEnoughData", reflect.TypeOf(SignalFilterNotEnoughData{}))
	conjureerrors.RegisterErrorType("Compute:TimeoutExceeded", reflect.TypeOf(TimeoutExceeded{}))
	conjureerrors.RegisterErrorType("Compute:TooFewInputs", reflect.TypeOf(TooFewInputs{}))
	conjureerrors.RegisterErrorType("Compute:TooManyBuckets", reflect.TypeOf(TooManyBuckets{}))
	conjureerrors.RegisterErrorType("Compute:TooManyCategories", reflect.TypeOf(TooManyCategories{}))
	conjureerrors.RegisterErrorType("Compute:TooManyEvents", reflect.TypeOf(TooManyEvents{}))
	conjureerrors.RegisterErrorType("Compute:TooManyLiterals", reflect.TypeOf(TooManyLiterals{}))
	conjureerrors.RegisterErrorType("Compute:TooManyPoints", reflect.TypeOf(TooManyPoints{}))
	conjureerrors.RegisterErrorType("Compute:TooManyRanges", reflect.TypeOf(TooManyRanges{}))
	conjureerrors.RegisterErrorType("Compute:TooManyResamplePoints", reflect.TypeOf(TooManyResamplePoints{}))
	conjureerrors.RegisterErrorType("Compute:TooManySubrequests", reflect.TypeOf(TooManySubrequests{}))
	conjureerrors.RegisterErrorType("Compute:UnexpectedTimeout", reflect.TypeOf(UnexpectedTimeout{}))
	conjureerrors.RegisterErrorType("Compute:UnitConversionInvalid", reflect.TypeOf(UnitConversionInvalid{}))
	conjureerrors.RegisterErrorType("Compute:UnsupportedRefpropProperty", reflect.TypeOf(UnsupportedRefpropProperty{}))
	conjureerrors.RegisterErrorType("Compute:VariableHasWrongType", reflect.TypeOf(VariableHasWrongType{}))
}
