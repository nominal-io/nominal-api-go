// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/io/nominal/api"
	api2 "github.com/nominal-io/nominal-api/scout/run/api"
	api1 "github.com/nominal-io/nominal-api/scout/units/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
)

// Threshold defined as a real number corresponding the unit of a series.
type AbsoluteThreshold struct {
	Value DoubleConstant `json:"value"`
}

func (o AbsoluteThreshold) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AbsoluteThreshold) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Replaces values in a series with the absolute timestamps.
type AbsoluteTimestampSeries struct {
	Input Series `json:"input"`
	// The time unit used to define the output values. Throws an error if nanosecond or finer.
	TimeUnit api.TimeUnit `conjure-docs:"The time unit used to define the output values. Throws an error if nanosecond or finer." json:"timeUnit"`
}

func (o AbsoluteTimestampSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AbsoluteTimestampSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The first point in the output range will be the first point after the condition has been true
for the min duration and min points.
*/
type AfterPersistenceWindow struct{}

func (o AfterPersistenceWindow) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AfterPersistenceWindow) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Aggregates values with duplicate timestamps in the input series values into a single value using the specified aggregation function.
type AggregateEnumSeries struct {
	Input    EnumSeries              `json:"input"`
	Function EnumAggregationFunction `json:"function"`
}

func (o AggregateEnumSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AggregateEnumSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Aggregates values with duplicate timestamps in the input series values into a single value using the specified aggregation function.
type AggregateNumericSeries struct {
	Input    NumericSeries              `json:"input"`
	Function NumericAggregationFunction `json:"function"`
	/*
	   Tags to group by for the aggregation.
	   If left empty, the tags to group by will be equivalent to those in the input series.
	   If specified, the result will be grouped ONLY by the specified tags.
	   The tags specified here MUST be a (non-strict) subset of the input series's group by tags.
	*/
	GroupByTags []StringConstant `conjure-docs:"Tags to group by for the aggregation.\nIf left empty, the tags to group by will be equivalent to those in the input series.\nIf specified, the result will be grouped ONLY by the specified tags.\nThe tags specified here MUST be a (non-strict) subset of the input series's group by tags." json:"groupByTags"`
}

func (o AggregateNumericSeries) MarshalJSON() ([]byte, error) {
	if o.GroupByTags == nil {
		o.GroupByTags = make([]StringConstant, 0)
	}
	type _tmpAggregateNumericSeries AggregateNumericSeries
	return safejson.Marshal(_tmpAggregateNumericSeries(o))
}

func (o *AggregateNumericSeries) UnmarshalJSON(data []byte) error {
	type _tmpAggregateNumericSeries AggregateNumericSeries
	var rawAggregateNumericSeries _tmpAggregateNumericSeries
	if err := safejson.Unmarshal(data, &rawAggregateNumericSeries); err != nil {
		return err
	}
	if rawAggregateNumericSeries.GroupByTags == nil {
		rawAggregateNumericSeries.GroupByTags = make([]StringConstant, 0)
	}
	*o = AggregateNumericSeries(rawAggregateNumericSeries)
	return nil
}

func (o AggregateNumericSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AggregateNumericSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AllowNegativeValues struct{}

func (o AllowNegativeValues) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AllowNegativeValues) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which the threshold condition is satisfied.
type ApproximateThresholdRanges struct {
	Input                          NumericSeries                   `json:"input"`
	Threshold                      DoubleConstant                  `json:"threshold"`
	Tolerance                      DoubleConstant                  `json:"tolerance"`
	Operator                       ApproximateThresholdOperator    `json:"operator"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration `json:"persistenceWindowConfiguration,omitempty"`
}

func (o ApproximateThresholdRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ApproximateThresholdRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArithmeticSeries struct {
	Inputs     map[LocalVariableName]NumericSeries `json:"inputs"`
	Expression string                              `json:"expression"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o ArithmeticSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make(map[LocalVariableName]NumericSeries, 0)
	}
	type _tmpArithmeticSeries ArithmeticSeries
	return safejson.Marshal(_tmpArithmeticSeries(o))
}

func (o *ArithmeticSeries) UnmarshalJSON(data []byte) error {
	type _tmpArithmeticSeries ArithmeticSeries
	var rawArithmeticSeries _tmpArithmeticSeries
	if err := safejson.Unmarshal(data, &rawArithmeticSeries); err != nil {
		return err
	}
	if rawArithmeticSeries.Inputs == nil {
		rawArithmeticSeries.Inputs = make(map[LocalVariableName]NumericSeries, 0)
	}
	*o = ArithmeticSeries(rawArithmeticSeries)
	return nil
}

func (o ArithmeticSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArithmeticSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArrowBucketedEnumPlot struct {
	// The raw binary containing Arrow IPC stream for BucketedEnumPlot
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for BucketedEnumPlot" json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
}

func (o ArrowBucketedEnumPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArrowBucketedEnumPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArrowBucketedNumericPlot struct {
	// The raw binary containing Arrow IPC stream for BucketedNumericPlot
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for BucketedNumericPlot" json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
}

func (o ArrowBucketedNumericPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArrowBucketedNumericPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArrowEnumPlot struct {
	// The raw binary containing Arrow IPC stream for EnumPlot
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for EnumPlot" json:"arrowBinary"`
}

func (o ArrowEnumPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArrowEnumPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArrowNumericPlot struct {
	// The raw binary containing Arrow IPC stream for NumericPlot
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for NumericPlot" json:"arrowBinary"`
}

func (o ArrowNumericPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArrowNumericPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AssetChannel struct {
	AssetRid StringConstant `json:"assetRid"`
	// Used to disambiguate when multiple data scopes within this asset contain channels with the same name.
	DataScopeName StringConstant `conjure-docs:"Used to disambiguate when multiple data scopes within this asset contain channels with the same name." json:"dataScopeName"`
	Channel       StringConstant `json:"channel"`
	// Deprecated: Use additionalTagFilters
	AdditionalTags map[string]StringConstant `json:"additionalTags"`
	/*
	   Tags to filter the channel by, in addition to tag filters defined for a given Asset data scope. Throws on
	   collisions with tag keys already defined for the given Asset data scope. Only returns points that match
	   both sets of tag filters. For log series, include arg filters here in addition to tag filters.
	*/
	AdditionalTagFilters *TagFilters `conjure-docs:"Tags to filter the channel by, in addition to tag filters defined for a given Asset data scope. Throws on \ncollisions with tag keys already defined for the given Asset data scope. Only returns points that match \nboth sets of tag filters. For log series, include arg filters here in addition to tag filters." json:"additionalTagFilters,omitempty"`
	// Deprecated: Use groupByTags instead. Throws if both tagsToGroupBy and groupByTags are specified.
	TagsToGroupBy []string `json:"tagsToGroupBy"`
	/*
	   Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned
	   with an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified.
	*/
	GroupByTags []StringConstant `conjure-docs:"Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned\nwith an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified." json:"groupByTags"`
}

func (o AssetChannel) MarshalJSON() ([]byte, error) {
	if o.AdditionalTags == nil {
		o.AdditionalTags = make(map[string]StringConstant, 0)
	}
	if o.TagsToGroupBy == nil {
		o.TagsToGroupBy = make([]string, 0)
	}
	if o.GroupByTags == nil {
		o.GroupByTags = make([]StringConstant, 0)
	}
	type _tmpAssetChannel AssetChannel
	return safejson.Marshal(_tmpAssetChannel(o))
}

func (o *AssetChannel) UnmarshalJSON(data []byte) error {
	type _tmpAssetChannel AssetChannel
	var rawAssetChannel _tmpAssetChannel
	if err := safejson.Unmarshal(data, &rawAssetChannel); err != nil {
		return err
	}
	if rawAssetChannel.AdditionalTags == nil {
		rawAssetChannel.AdditionalTags = make(map[string]StringConstant, 0)
	}
	if rawAssetChannel.TagsToGroupBy == nil {
		rawAssetChannel.TagsToGroupBy = make([]string, 0)
	}
	if rawAssetChannel.GroupByTags == nil {
		rawAssetChannel.GroupByTags = make([]StringConstant, 0)
	}
	*o = AssetChannel(rawAssetChannel)
	return nil
}

func (o AssetChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AssetChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A average that gives the same weight to each observation inside the time window
type Average struct{}

func (o Average) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Average) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BandPassConfiguration struct {
	LowPassbandFrequency  DoubleConstant `json:"lowPassbandFrequency"`
	HighPassbandFrequency DoubleConstant `json:"highPassbandFrequency"`
}

func (o BandPassConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BandPassConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BandStopConfiguration struct {
	LowStopbandFrequency  DoubleConstant `json:"lowStopbandFrequency"`
	HighStopbandFrequency DoubleConstant `json:"highStopbandFrequency"`
}

func (o BandStopConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BandStopConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchComputeUnitResult struct {
	Results []ComputeUnitResult `json:"results"`
}

func (o BatchComputeUnitResult) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ComputeUnitResult, 0)
	}
	type _tmpBatchComputeUnitResult BatchComputeUnitResult
	return safejson.Marshal(_tmpBatchComputeUnitResult(o))
}

func (o *BatchComputeUnitResult) UnmarshalJSON(data []byte) error {
	type _tmpBatchComputeUnitResult BatchComputeUnitResult
	var rawBatchComputeUnitResult _tmpBatchComputeUnitResult
	if err := safejson.Unmarshal(data, &rawBatchComputeUnitResult); err != nil {
		return err
	}
	if rawBatchComputeUnitResult.Results == nil {
		rawBatchComputeUnitResult.Results = make([]ComputeUnitResult, 0)
	}
	*o = BatchComputeUnitResult(rawBatchComputeUnitResult)
	return nil
}

func (o BatchComputeUnitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchComputeUnitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchComputeUnitsRequest struct {
	Requests []ComputeUnitsRequest `json:"requests"`
}

func (o BatchComputeUnitsRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]ComputeUnitsRequest, 0)
	}
	type _tmpBatchComputeUnitsRequest BatchComputeUnitsRequest
	return safejson.Marshal(_tmpBatchComputeUnitsRequest(o))
}

func (o *BatchComputeUnitsRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchComputeUnitsRequest BatchComputeUnitsRequest
	var rawBatchComputeUnitsRequest _tmpBatchComputeUnitsRequest
	if err := safejson.Unmarshal(data, &rawBatchComputeUnitsRequest); err != nil {
		return err
	}
	if rawBatchComputeUnitsRequest.Requests == nil {
		rawBatchComputeUnitsRequest.Requests = make([]ComputeUnitsRequest, 0)
	}
	*o = BatchComputeUnitsRequest(rawBatchComputeUnitsRequest)
	return nil
}

func (o BatchComputeUnitsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchComputeUnitsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchComputeWithUnitsRequest struct {
	Requests []ComputeNodeRequest `json:"requests"`
}

func (o BatchComputeWithUnitsRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]ComputeNodeRequest, 0)
	}
	type _tmpBatchComputeWithUnitsRequest BatchComputeWithUnitsRequest
	return safejson.Marshal(_tmpBatchComputeWithUnitsRequest(o))
}

func (o *BatchComputeWithUnitsRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchComputeWithUnitsRequest BatchComputeWithUnitsRequest
	var rawBatchComputeWithUnitsRequest _tmpBatchComputeWithUnitsRequest
	if err := safejson.Unmarshal(data, &rawBatchComputeWithUnitsRequest); err != nil {
		return err
	}
	if rawBatchComputeWithUnitsRequest.Requests == nil {
		rawBatchComputeWithUnitsRequest.Requests = make([]ComputeNodeRequest, 0)
	}
	*o = BatchComputeWithUnitsRequest(rawBatchComputeWithUnitsRequest)
	return nil
}

func (o BatchComputeWithUnitsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchComputeWithUnitsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchComputeWithUnitsResponse struct {
	Results []ComputeWithUnitsResult `json:"results"`
}

func (o BatchComputeWithUnitsResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ComputeWithUnitsResult, 0)
	}
	type _tmpBatchComputeWithUnitsResponse BatchComputeWithUnitsResponse
	return safejson.Marshal(_tmpBatchComputeWithUnitsResponse(o))
}

func (o *BatchComputeWithUnitsResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchComputeWithUnitsResponse BatchComputeWithUnitsResponse
	var rawBatchComputeWithUnitsResponse _tmpBatchComputeWithUnitsResponse
	if err := safejson.Unmarshal(data, &rawBatchComputeWithUnitsResponse); err != nil {
		return err
	}
	if rawBatchComputeWithUnitsResponse.Results == nil {
		rawBatchComputeWithUnitsResponse.Results = make([]ComputeWithUnitsResult, 0)
	}
	*o = BatchComputeWithUnitsResponse(rawBatchComputeWithUnitsResponse)
	return nil
}

func (o BatchComputeWithUnitsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchComputeWithUnitsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Applies a point-wise transformation to a pair of series.
type BinaryArithmeticSeries struct {
	Input1    NumericSeries             `json:"input1"`
	Input2    NumericSeries             `json:"input2"`
	Operation BinaryArithmeticOperation `json:"operation"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o BinaryArithmeticSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BinaryArithmeticSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BitAndFunction struct {
	Operand safelong.SafeLong `json:"operand"`
}

func (o BitAndFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitAndFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Casts input series values to long before applying the bitwise operation.
type BitOperationSeries struct {
	Input    NumericSeries        `json:"input"`
	Function BitOperationFunction `json:"function"`
}

func (o BitOperationSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitOperationSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BitOrFunction struct {
	Operand safelong.SafeLong `json:"operand"`
}

func (o BitOrFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitOrFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Shifts the bits in each value left according to the given operand.
type BitShiftLeftFunction struct {
	Operand int `json:"operand"`
}

func (o BitShiftLeftFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitShiftLeftFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Right shifts the bits in each value right according to the given operand.
type BitShiftRightFunction struct {
	Operand int `json:"operand"`
}

func (o BitShiftRightFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitShiftRightFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Returns the bit at the specified index, where the right-most bit has index 0.
type BitTestFunction struct {
	Index int `json:"index"`
}

func (o BitTestFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitTestFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BitXorFunction struct {
	Operand safelong.SafeLong `json:"operand"`
}

func (o BitXorFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitXorFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BucketedCartesian3dPlot struct {
	Buckets []Cartesian3dBucket `json:"buckets"`
}

func (o BucketedCartesian3dPlot) MarshalJSON() ([]byte, error) {
	if o.Buckets == nil {
		o.Buckets = make([]Cartesian3dBucket, 0)
	}
	type _tmpBucketedCartesian3dPlot BucketedCartesian3dPlot
	return safejson.Marshal(_tmpBucketedCartesian3dPlot(o))
}

func (o *BucketedCartesian3dPlot) UnmarshalJSON(data []byte) error {
	type _tmpBucketedCartesian3dPlot BucketedCartesian3dPlot
	var rawBucketedCartesian3dPlot _tmpBucketedCartesian3dPlot
	if err := safejson.Unmarshal(data, &rawBucketedCartesian3dPlot); err != nil {
		return err
	}
	if rawBucketedCartesian3dPlot.Buckets == nil {
		rawBucketedCartesian3dPlot.Buckets = make([]Cartesian3dBucket, 0)
	}
	*o = BucketedCartesian3dPlot(rawBucketedCartesian3dPlot)
	return nil
}

func (o BucketedCartesian3dPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedCartesian3dPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BucketedCartesianPlot struct {
	Buckets []CartesianBucket `json:"buckets"`
}

func (o BucketedCartesianPlot) MarshalJSON() ([]byte, error) {
	if o.Buckets == nil {
		o.Buckets = make([]CartesianBucket, 0)
	}
	type _tmpBucketedCartesianPlot BucketedCartesianPlot
	return safejson.Marshal(_tmpBucketedCartesianPlot(o))
}

func (o *BucketedCartesianPlot) UnmarshalJSON(data []byte) error {
	type _tmpBucketedCartesianPlot BucketedCartesianPlot
	var rawBucketedCartesianPlot _tmpBucketedCartesianPlot
	if err := safejson.Unmarshal(data, &rawBucketedCartesianPlot); err != nil {
		return err
	}
	if rawBucketedCartesianPlot.Buckets == nil {
		rawBucketedCartesianPlot.Buckets = make([]CartesianBucket, 0)
	}
	*o = BucketedCartesianPlot(rawBucketedCartesianPlot)
	return nil
}

func (o BucketedCartesianPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedCartesianPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The array is flattened out into a an arrow stream of bucketed primitive results, with an extra column to
indicate the index of the array that the bucket corresponds to.
*/
type BucketedEnumArrayPlot struct {
	// The raw binary containing Arrow IPC stream for a bucketed N-dimensional enum array plot.
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for a bucketed N-dimensional enum array plot." json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
}

func (o BucketedEnumArrayPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedEnumArrayPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BucketedEnumPlot struct {
	// The end of the bucket, exclusive.
	Timestamps []api.Timestamp `conjure-docs:"The end of the bucket, exclusive." json:"timestamps"`
	Buckets    []EnumBucket    `json:"buckets"`
	Categories []string        `json:"categories"`
}

func (o BucketedEnumPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.Buckets == nil {
		o.Buckets = make([]EnumBucket, 0)
	}
	if o.Categories == nil {
		o.Categories = make([]string, 0)
	}
	type _tmpBucketedEnumPlot BucketedEnumPlot
	return safejson.Marshal(_tmpBucketedEnumPlot(o))
}

func (o *BucketedEnumPlot) UnmarshalJSON(data []byte) error {
	type _tmpBucketedEnumPlot BucketedEnumPlot
	var rawBucketedEnumPlot _tmpBucketedEnumPlot
	if err := safejson.Unmarshal(data, &rawBucketedEnumPlot); err != nil {
		return err
	}
	if rawBucketedEnumPlot.Timestamps == nil {
		rawBucketedEnumPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawBucketedEnumPlot.Buckets == nil {
		rawBucketedEnumPlot.Buckets = make([]EnumBucket, 0)
	}
	if rawBucketedEnumPlot.Categories == nil {
		rawBucketedEnumPlot.Categories = make([]string, 0)
	}
	*o = BucketedEnumPlot(rawBucketedEnumPlot)
	return nil
}

func (o BucketedEnumPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedEnumPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The array is flattened out into a an arrow stream of bucketed primitive results, with an extra column to
indicate the index of the array that the bucket corresponds to.
*/
type BucketedNumericArrayPlot struct {
	// The raw binary containing Arrow IPC stream for a bucketed N-dimensional numeric array plot.
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for a bucketed N-dimensional numeric array plot." json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
}

func (o BucketedNumericArrayPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedNumericArrayPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BucketedNumericPlot struct {
	// The end of the bucket, exclusive.
	Timestamps []api.Timestamp `conjure-docs:"The end of the bucket, exclusive." json:"timestamps"`
	Buckets    []NumericBucket `json:"buckets"`
}

func (o BucketedNumericPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.Buckets == nil {
		o.Buckets = make([]NumericBucket, 0)
	}
	type _tmpBucketedNumericPlot BucketedNumericPlot
	return safejson.Marshal(_tmpBucketedNumericPlot(o))
}

func (o *BucketedNumericPlot) UnmarshalJSON(data []byte) error {
	type _tmpBucketedNumericPlot BucketedNumericPlot
	var rawBucketedNumericPlot _tmpBucketedNumericPlot
	if err := safejson.Unmarshal(data, &rawBucketedNumericPlot); err != nil {
		return err
	}
	if rawBucketedNumericPlot.Timestamps == nil {
		rawBucketedNumericPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawBucketedNumericPlot.Buckets == nil {
		rawBucketedNumericPlot.Buckets = make([]NumericBucket, 0)
	}
	*o = BucketedNumericPlot(rawBucketedNumericPlot)
	return nil
}

func (o BucketedNumericPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedNumericPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Min/max bounds of an XYZ Cartesian plot, inclusive.
type Cartesian3dBounds struct {
	MinX DoubleConstant `json:"minX"`
	MaxX DoubleConstant `json:"maxX"`
	MinY DoubleConstant `json:"minY"`
	MaxY DoubleConstant `json:"maxY"`
	MinZ DoubleConstant `json:"minZ"`
	MaxZ DoubleConstant `json:"maxZ"`
}

func (o Cartesian3dBounds) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Cartesian3dBounds) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Cartesian3dBucket struct {
	// Deprecated: Switching to point-based min/maxes
	MinX *float64 `json:"minX,omitempty"`
	// Deprecated: Switching to point-based min/maxes
	MaxX  *float64 `json:"maxX,omitempty"`
	MeanX float64  `json:"meanX"`
	// Deprecated: Switching to point-based min/maxes
	MinY *float64 `json:"minY,omitempty"`
	// Deprecated: Switching to point-based min/maxes
	MaxY  *float64 `json:"maxY,omitempty"`
	MeanY float64  `json:"meanY"`
	// Deprecated: Switching to point-based min/maxes
	MinZ *float64 `json:"minZ,omitempty"`
	// Deprecated: Switching to point-based min/maxes
	MaxZ         *float64          `json:"maxZ,omitempty"`
	MeanZ        float64           `json:"meanZ"`
	MinXPoint    Point3d           `json:"minXPoint"`
	MaxXPoint    Point3d           `json:"maxXPoint"`
	MinYPoint    Point3d           `json:"minYPoint"`
	MaxYPoint    Point3d           `json:"maxYPoint"`
	MinZPoint    Point3d           `json:"minZPoint"`
	MaxZPoint    Point3d           `json:"maxZPoint"`
	MinTimestamp api.Timestamp     `json:"minTimestamp"`
	MaxTimestamp api.Timestamp     `json:"maxTimestamp"`
	Count        safelong.SafeLong `json:"count"`
}

func (o Cartesian3dBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Cartesian3dBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Cartesian3dUnitResult struct {
	X UnitResult `json:"x"`
	Y UnitResult `json:"y"`
	Z UnitResult `json:"z"`
}

func (o Cartesian3dUnitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Cartesian3dUnitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Min/max bounds of an XY Cartesian plot, inclusive.
type CartesianBounds struct {
	MinX DoubleConstant `json:"minX"`
	MaxX DoubleConstant `json:"maxX"`
	MinY DoubleConstant `json:"minY"`
	MaxY DoubleConstant `json:"maxY"`
}

func (o CartesianBounds) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CartesianBounds) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CartesianBucket struct {
	MinX         float64           `json:"minX"`
	MaxX         float64           `json:"maxX"`
	MinY         float64           `json:"minY"`
	MaxY         float64           `json:"maxY"`
	MinTimestamp api.Timestamp     `json:"minTimestamp"`
	MaxTimestamp api.Timestamp     `json:"maxTimestamp"`
	Count        safelong.SafeLong `json:"count"`
}

func (o CartesianBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CartesianBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CartesianPlot struct {
	Timestamps []api.Timestamp `json:"timestamps"`
	XValues    []float64       `json:"xValues"`
	YValues    []float64       `json:"yValues"`
}

func (o CartesianPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.XValues == nil {
		o.XValues = make([]float64, 0)
	}
	if o.YValues == nil {
		o.YValues = make([]float64, 0)
	}
	type _tmpCartesianPlot CartesianPlot
	return safejson.Marshal(_tmpCartesianPlot(o))
}

func (o *CartesianPlot) UnmarshalJSON(data []byte) error {
	type _tmpCartesianPlot CartesianPlot
	var rawCartesianPlot _tmpCartesianPlot
	if err := safejson.Unmarshal(data, &rawCartesianPlot); err != nil {
		return err
	}
	if rawCartesianPlot.Timestamps == nil {
		rawCartesianPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawCartesianPlot.XValues == nil {
		rawCartesianPlot.XValues = make([]float64, 0)
	}
	if rawCartesianPlot.YValues == nil {
		rawCartesianPlot.YValues = make([]float64, 0)
	}
	*o = CartesianPlot(rawCartesianPlot)
	return nil
}

func (o CartesianPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CartesianPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CartesianUnitResult struct {
	X UnitResult `json:"x"`
	Y UnitResult `json:"y"`
}

func (o CartesianUnitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CartesianUnitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CompactEnumPoint struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Value     int           `json:"value"`
}

func (o CompactEnumPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CompactEnumPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeNodeFromReferenceRequest struct {
	Node        ComputableNode `json:"node"`
	ReferenceTs api.Timestamp  `json:"referenceTs"`
	PageSize    int            `json:"pageSize"`
	Context     Context        `json:"context"`
}

func (o ComputeNodeFromReferenceRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeNodeFromReferenceRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeNodeRequest struct {
	Node    ComputableNode `json:"node"`
	Start   api.Timestamp  `json:"start"`
	End     api.Timestamp  `json:"end"`
	Context Context        `json:"context"`
}

func (o ComputeNodeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeNodeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeNodeWithContext struct {
	SeriesNode ComputeNode `json:"seriesNode"`
	Context    Context     `json:"context"`
}

func (o ComputeNodeWithContext) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeNodeWithContext) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeUnitsRequest struct {
	Node    ComputableNode `json:"node"`
	Context Context        `json:"context"`
}

func (o ComputeUnitsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeUnitsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeWithUnitsResponse struct {
	ComputeResult ComputeNodeResponse `json:"computeResult"`
	ComputeUnit   ComputeUnitResult   `json:"computeUnit"`
}

func (o ComputeWithUnitsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeWithUnitsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeWithUnitsResult struct {
	ComputeResult ComputeNodeResult `json:"computeResult"`
	UnitResult    ComputeUnitResult `json:"unitResult"`
}

func (o ComputeWithUnitsResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeWithUnitsResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Context struct {
	Variables map[VariableName]VariableValue `json:"variables"`
	// Deprecated: This field is deprecated and will be removed in a future version.
	FunctionVariables *map[FunctionReference]FunctionVariables `json:"functionVariables,omitempty"`
}

func (o Context) MarshalJSON() ([]byte, error) {
	if o.Variables == nil {
		o.Variables = make(map[VariableName]VariableValue, 0)
	}
	type _tmpContext Context
	return safejson.Marshal(_tmpContext(o))
}

func (o *Context) UnmarshalJSON(data []byte) error {
	type _tmpContext Context
	var rawContext _tmpContext
	if err := safejson.Unmarshal(data, &rawContext); err != nil {
		return err
	}
	if rawContext.Variables == nil {
		rawContext.Variables = make(map[VariableName]VariableValue, 0)
	}
	*o = Context(rawContext)
	return nil
}

func (o Context) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Context) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The number of points inside the time window
type Count struct{}

func (o Count) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Count) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Calculates the running total of the series values.
type CumulativeSumSeries struct {
	Input          NumericSeries     `json:"input"`
	StartTimestamp TimestampConstant `json:"startTimestamp"`
}

func (o CumulativeSumSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CumulativeSumSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CurveFit struct {
	CurveFitPlotType CurveFitPlotType `json:"curveFitPlotType"`
	CurveFitDetails  CurveFitDetails  `json:"curveFitDetails"`
	CurveFitOptions  CurveFitOptions  `json:"curveFitOptions"`
}

func (o CurveFit) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CurveFit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CurveFitOptions struct {
	StartTime TimestampConstant `json:"startTime"`
	EndTime   TimestampConstant `json:"endTime"`
}

func (o CurveFitOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CurveFitOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CurveFitResult struct {
	/*
	   R^2 (coefficient of determination) for the fit curve, a normalized measure of how well the curve fits the data.
	   Usually ranges from 0 to 1, with higher indicating better fit (points closer to fit line).
	*/
	R2 float64 `conjure-docs:"R^2 (coefficient of determination) for the fit curve, a normalized measure of how well the curve fits the data.\nUsually ranges from 0 to 1, with higher indicating better fit (points closer to fit line)." json:"r2"`
	// Description of the fit curve.
	CurveResultDetails CurveResultDetails `conjure-docs:"Description of the fit curve." json:"curveResultDetails"`
}

func (o CurveFitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CurveFitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataSourceAndChannel struct {
	DataSourceRid rids.DataSourceRid `json:"dataSourceRid"`
	Channel       string             `json:"channel"`
}

func (o DataSourceAndChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataSourceAndChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataSourceChannel struct {
	DataSourceRid StringConstant `json:"dataSourceRid"`
	Channel       StringConstant `json:"channel"`
	// Deprecated: Use tagFilters
	Tags map[string]StringConstant `json:"tags"`
	/*
	   Tags to filter the channel by. Only returns points from the channel where tag values match the provided
	   expression. For log series, include arg filters here in addition to tag filters.
	*/
	TagFilters *TagFilters `conjure-docs:"Tags to filter the channel by. Only returns points from the channel where tag values match the provided\nexpression. For log series, include arg filters here in addition to tag filters." json:"tagFilters,omitempty"`
	// Deprecated: Use groupByTags instead. Throws if both tagsToGroupBy and groupByTags are specified.
	TagsToGroupBy []string `json:"tagsToGroupBy"`
	/*
	   Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned
	   with an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified.
	*/
	GroupByTags []StringConstant `conjure-docs:"Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned\nwith an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified." json:"groupByTags"`
}

func (o DataSourceChannel) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make(map[string]StringConstant, 0)
	}
	if o.TagsToGroupBy == nil {
		o.TagsToGroupBy = make([]string, 0)
	}
	if o.GroupByTags == nil {
		o.GroupByTags = make([]StringConstant, 0)
	}
	type _tmpDataSourceChannel DataSourceChannel
	return safejson.Marshal(_tmpDataSourceChannel(o))
}

func (o *DataSourceChannel) UnmarshalJSON(data []byte) error {
	type _tmpDataSourceChannel DataSourceChannel
	var rawDataSourceChannel _tmpDataSourceChannel
	if err := safejson.Unmarshal(data, &rawDataSourceChannel); err != nil {
		return err
	}
	if rawDataSourceChannel.Tags == nil {
		rawDataSourceChannel.Tags = make(map[string]StringConstant, 0)
	}
	if rawDataSourceChannel.TagsToGroupBy == nil {
		rawDataSourceChannel.TagsToGroupBy = make([]string, 0)
	}
	if rawDataSourceChannel.GroupByTags == nil {
		rawDataSourceChannel.GroupByTags = make([]StringConstant, 0)
	}
	*o = DataSourceChannel(rawDataSourceChannel)
	return nil
}

func (o DataSourceChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataSourceChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DecimateWithBuckets struct {
	// Number of points to generate in the output series.
	Buckets int `conjure-docs:"Number of points to generate in the output series." json:"buckets"`
}

func (o DecimateWithBuckets) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DecimateWithBuckets) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DecimateWithResolution struct {
	/*
	   Resolution of the output series specifying time interval between decimated points.
	   Picoseconds for picosecond-granularity dataset, nanoseconds otherwise.
	*/
	Resolution safelong.SafeLong `conjure-docs:"Resolution of the output series specifying time interval between decimated points.\nPicoseconds for picosecond-granularity dataset, nanoseconds otherwise." json:"resolution"`
}

func (o DecimateWithResolution) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DecimateWithResolution) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Calculates the rate of change between subsequent points.
type DerivativeSeries struct {
	Input NumericSeries `json:"input"`
	// Time unit used to calculate the derivative. Defaults to seconds if not specified.
	TimeUnit *api.TimeUnit `conjure-docs:"Time unit used to calculate the derivative. Defaults to seconds if not specified." json:"timeUnit,omitempty"`
	// Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified.
	NegativeValuesConfiguration *NegativeValueConfiguration `conjure-docs:"Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified." json:"negativeValuesConfiguration,omitempty"`
}

func (o DerivativeSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DerivativeSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Filters a list of ranges down to only those satisfying a threshold condition on the range's duration.
type DurationFilterRanges struct {
	Input             RangeSeries        `json:"input"`
	Threshold         DurationConstant   `json:"threshold"`
	Operator          ThresholdOperator  `json:"operator"`
	UnboundedBehavior *UnboundedBehavior `json:"unboundedBehavior,omitempty"`
}

func (o DurationFilterRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DurationFilterRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumBucket struct {
	// The map of values within the bucket to their frequency.
	Histogram  map[int]safelong.SafeLong `conjure-docs:"The map of values within the bucket to their frequency." json:"histogram"`
	FirstPoint CompactEnumPoint          `json:"firstPoint"`
	// Will be empty if the bucket only has a single point.
	LastPoint *CompactEnumPoint `conjure-docs:"Will be empty if the bucket only has a single point." json:"lastPoint,omitempty"`
}

func (o EnumBucket) MarshalJSON() ([]byte, error) {
	if o.Histogram == nil {
		o.Histogram = make(map[int]safelong.SafeLong, 0)
	}
	type _tmpEnumBucket EnumBucket
	return safejson.Marshal(_tmpEnumBucket(o))
}

func (o *EnumBucket) UnmarshalJSON(data []byte) error {
	type _tmpEnumBucket EnumBucket
	var rawEnumBucket _tmpEnumBucket
	if err := safejson.Unmarshal(data, &rawEnumBucket); err != nil {
		return err
	}
	if rawEnumBucket.Histogram == nil {
		rawEnumBucket.Histogram = make(map[int]safelong.SafeLong, 0)
	}
	*o = EnumBucket(rawEnumBucket)
	return nil
}

func (o EnumBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Counts the number of points along each timestamp in the input series.
type EnumCountDuplicateSeries struct {
	Inputs []EnumSeries `json:"inputs"`
}

func (o EnumCountDuplicateSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]EnumSeries, 0)
	}
	type _tmpEnumCountDuplicateSeries EnumCountDuplicateSeries
	return safejson.Marshal(_tmpEnumCountDuplicateSeries(o))
}

func (o *EnumCountDuplicateSeries) UnmarshalJSON(data []byte) error {
	type _tmpEnumCountDuplicateSeries EnumCountDuplicateSeries
	var rawEnumCountDuplicateSeries _tmpEnumCountDuplicateSeries
	if err := safejson.Unmarshal(data, &rawEnumCountDuplicateSeries); err != nil {
		return err
	}
	if rawEnumCountDuplicateSeries.Inputs == nil {
		rawEnumCountDuplicateSeries.Inputs = make([]EnumSeries, 0)
	}
	*o = EnumCountDuplicateSeries(rawEnumCountDuplicateSeries)
	return nil
}

func (o EnumCountDuplicateSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumCountDuplicateSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which the filter condition is satisfied.
type EnumFilterRanges struct {
	Input                          EnumSeries                      `json:"input"`
	Operator                       EnumFilterOperator              `json:"operator"`
	Values                         StringSetConstant               `json:"values"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration `json:"persistenceWindowConfiguration,omitempty"`
}

func (o EnumFilterRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumFilterRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs the values of the enum plot value within the ranges specified by a ranges node
type EnumFilterTransformationSeries struct {
	Input  EnumSeries  `json:"input"`
	Filter RangeSeries `json:"filter"`
}

func (o EnumFilterTransformationSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumFilterTransformationSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A bucket in an enum histogram representing all the counts
for a specific enumerated value, across all input series.
*/
type EnumHistogramBucket struct {
	// The value of the enum as a string
	Value           string                                 `conjure-docs:"The value of the enum as a string" json:"value"`
	CountsByChannel map[VariableName]HistogramChannelCount `json:"countsByChannel"`
}

func (o EnumHistogramBucket) MarshalJSON() ([]byte, error) {
	if o.CountsByChannel == nil {
		o.CountsByChannel = make(map[VariableName]HistogramChannelCount, 0)
	}
	type _tmpEnumHistogramBucket EnumHistogramBucket
	return safejson.Marshal(_tmpEnumHistogramBucket(o))
}

func (o *EnumHistogramBucket) UnmarshalJSON(data []byte) error {
	type _tmpEnumHistogramBucket EnumHistogramBucket
	var rawEnumHistogramBucket _tmpEnumHistogramBucket
	if err := safejson.Unmarshal(data, &rawEnumHistogramBucket); err != nil {
		return err
	}
	if rawEnumHistogramBucket.CountsByChannel == nil {
		rawEnumHistogramBucket.CountsByChannel = make(map[VariableName]HistogramChannelCount, 0)
	}
	*o = EnumHistogramBucket(rawEnumHistogramBucket)
	return nil
}

func (o EnumHistogramBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumHistogramBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumHistogramNode struct {
	Inputs map[VariableName]EnumSeries `json:"inputs"`
}

func (o EnumHistogramNode) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make(map[VariableName]EnumSeries, 0)
	}
	type _tmpEnumHistogramNode EnumHistogramNode
	return safejson.Marshal(_tmpEnumHistogramNode(o))
}

func (o *EnumHistogramNode) UnmarshalJSON(data []byte) error {
	type _tmpEnumHistogramNode EnumHistogramNode
	var rawEnumHistogramNode _tmpEnumHistogramNode
	if err := safejson.Unmarshal(data, &rawEnumHistogramNode); err != nil {
		return err
	}
	if rawEnumHistogramNode.Inputs == nil {
		rawEnumHistogramNode.Inputs = make(map[VariableName]EnumSeries, 0)
	}
	*o = EnumHistogramNode(rawEnumHistogramNode)
	return nil
}

func (o EnumHistogramNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumHistogramNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumHistogramPlot struct {
	Buckets []EnumHistogramBucket `json:"buckets"`
}

func (o EnumHistogramPlot) MarshalJSON() ([]byte, error) {
	if o.Buckets == nil {
		o.Buckets = make([]EnumHistogramBucket, 0)
	}
	type _tmpEnumHistogramPlot EnumHistogramPlot
	return safejson.Marshal(_tmpEnumHistogramPlot(o))
}

func (o *EnumHistogramPlot) UnmarshalJSON(data []byte) error {
	type _tmpEnumHistogramPlot EnumHistogramPlot
	var rawEnumHistogramPlot _tmpEnumHistogramPlot
	if err := safejson.Unmarshal(data, &rawEnumHistogramPlot); err != nil {
		return err
	}
	if rawEnumHistogramPlot.Buckets == nil {
		rawEnumHistogramPlot.Buckets = make([]EnumHistogramBucket, 0)
	}
	*o = EnumHistogramPlot(rawEnumHistogramPlot)
	return nil
}

func (o EnumHistogramPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumHistogramPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumPlot struct {
	Timestamps []api.Timestamp `json:"timestamps"`
	Values     []int           `json:"values"`
	Categories []string        `json:"categories"`
}

func (o EnumPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.Values == nil {
		o.Values = make([]int, 0)
	}
	if o.Categories == nil {
		o.Categories = make([]string, 0)
	}
	type _tmpEnumPlot EnumPlot
	return safejson.Marshal(_tmpEnumPlot(o))
}

func (o *EnumPlot) UnmarshalJSON(data []byte) error {
	type _tmpEnumPlot EnumPlot
	var rawEnumPlot _tmpEnumPlot
	if err := safejson.Unmarshal(data, &rawEnumPlot); err != nil {
		return err
	}
	if rawEnumPlot.Timestamps == nil {
		rawEnumPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawEnumPlot.Values == nil {
		rawEnumPlot.Values = make([]int, 0)
	}
	if rawEnumPlot.Categories == nil {
		rawEnumPlot.Categories = make([]string, 0)
	}
	*o = EnumPlot(rawEnumPlot)
	return nil
}

func (o EnumPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumPoint struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Value     string        `json:"value"`
}

func (o EnumPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Resamples the input series to a new resolution using interpolation.
Outputs data for timestamps corresponding to the defined frequency. Based on interpolation strategy,
determines range of timestamps to output data for and interpolates values where necessary.
*/
type EnumResampleSeries struct {
	Input EnumSeries `json:"input"`
	// The interval at which to resample the series and interpolation strategy
	ResampleConfiguration ResampleConfiguration `conjure-docs:"The interval at which to resample the series and interpolation strategy" json:"resampleConfiguration"`
}

func (o EnumResampleSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumResampleSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which provided enum series are all equal (or are not all equal).
type EnumSeriesEqualityRanges struct {
	Input                          []EnumSeries                    `json:"input"`
	EqualityOperator               EqualityOperator                `json:"equalityOperator"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration `json:"persistenceWindowConfiguration,omitempty"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o EnumSeriesEqualityRanges) MarshalJSON() ([]byte, error) {
	if o.Input == nil {
		o.Input = make([]EnumSeries, 0)
	}
	type _tmpEnumSeriesEqualityRanges EnumSeriesEqualityRanges
	return safejson.Marshal(_tmpEnumSeriesEqualityRanges(o))
}

func (o *EnumSeriesEqualityRanges) UnmarshalJSON(data []byte) error {
	type _tmpEnumSeriesEqualityRanges EnumSeriesEqualityRanges
	var rawEnumSeriesEqualityRanges _tmpEnumSeriesEqualityRanges
	if err := safejson.Unmarshal(data, &rawEnumSeriesEqualityRanges); err != nil {
		return err
	}
	if rawEnumSeriesEqualityRanges.Input == nil {
		rawEnumSeriesEqualityRanges.Input = make([]EnumSeries, 0)
	}
	*o = EnumSeriesEqualityRanges(rawEnumSeriesEqualityRanges)
	return nil
}

func (o EnumSeriesEqualityRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumSeriesEqualityRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Filters the series to points within the specified time range.
type EnumTimeRangeFilterSeries struct {
	Input EnumSeries `json:"input"`
	// Represents the start time (inclusive) of the time range.
	StartTime *TimestampConstant `conjure-docs:"Represents the start time (inclusive) of the time range." json:"startTime,omitempty"`
	// Represents the end time (inclusive) of the time range.
	EndTime *TimestampConstant `conjure-docs:"Represents the end time (inclusive) of the time range." json:"endTime,omitempty"`
}

func (o EnumTimeRangeFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumTimeRangeFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumTimeShiftSeries struct {
	Input    EnumSeries       `json:"input"`
	Duration DurationConstant `json:"duration"`
}

func (o EnumTimeShiftSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumTimeShiftSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Combines multiple enum series together and outputs a single series. The strategy to merge input values
with the same timestamp together is specified in the operation field.
*/
type EnumUnionSeries struct {
	Input []EnumSeries `json:"input"`
	// The strategy to merge points with duplicate timestamps.
	Operation EnumUnionOperation `conjure-docs:"The strategy to merge points with duplicate timestamps." json:"operation"`
}

func (o EnumUnionSeries) MarshalJSON() ([]byte, error) {
	if o.Input == nil {
		o.Input = make([]EnumSeries, 0)
	}
	type _tmpEnumUnionSeries EnumUnionSeries
	return safejson.Marshal(_tmpEnumUnionSeries(o))
}

func (o *EnumUnionSeries) UnmarshalJSON(data []byte) error {
	type _tmpEnumUnionSeries EnumUnionSeries
	var rawEnumUnionSeries _tmpEnumUnionSeries
	if err := safejson.Unmarshal(data, &rawEnumUnionSeries); err != nil {
		return err
	}
	if rawEnumUnionSeries.Input == nil {
		rawEnumUnionSeries.Input = make([]EnumSeries, 0)
	}
	*o = EnumUnionSeries(rawEnumUnionSeries)
	return nil
}

func (o EnumUnionSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumUnionSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ErrorResult struct {
	ErrorType ErrorType `json:"errorType"`
	Code      ErrorCode `json:"code"`
}

func (o ErrorResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ErrorResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EventTimeFilter struct {
	Timestamp          TimestampConstant        `json:"timestamp"`
	TimestampCondition EventTimeFilterCondition `json:"timestampCondition"`
}

func (o EventTimeFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EventTimeFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Produces a range series with a range for each event matching the query.
Throws if there are more than 1,000 results.
*/
type EventsSearchRanges struct {
	Query ComputeEventQuery `json:"query"`
}

func (o EventsSearchRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EventsSearchRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExcludeNegativeValues struct{}

func (o ExcludeNegativeValues) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExcludeNegativeValues) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExponentialCurve struct{}

func (o ExponentialCurve) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExponentialCurve) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// y = a * e^(b * x)
type ExponentialResultDetails struct {
	A float64 `json:"a"`
	B float64 `json:"b"`
}

func (o ExponentialResultDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExponentialResultDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Returns the single sided amplitude spectrum of the input series.
type Fft struct {
	Input NumericSeries `json:"input"`
}

func (o Fft) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Fft) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The first point in the output range will be the first point where the condition evaluates to true.
type FirstPointMatchingCondition struct{}

func (o FirstPointMatchingCondition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FirstPointMatchingCondition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ForwardFillInterpolation struct {
	InterpolationRadius DurationConstant `json:"interpolationRadius"`
}

func (o ForwardFillInterpolation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ForwardFillInterpolation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Forward fill interpolation for resampling. Rounds the earliest and latest timestamp up to the nearest interval
multiple and generates timestamps at the given interval between the new earliest and latest timestamps.
For every timestamp in the resampled timestamps, takes the last known value before the timestamp as the value.
*/
type ForwardFillResampleInterpolationConfiguration struct{}

func (o ForwardFillResampleInterpolationConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ForwardFillResampleInterpolationConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FrequencyDomainPlot struct {
	Frequencies []float64 `json:"frequencies"`
	Amplitudes  []float64 `json:"amplitudes"`
}

func (o FrequencyDomainPlot) MarshalJSON() ([]byte, error) {
	if o.Frequencies == nil {
		o.Frequencies = make([]float64, 0)
	}
	if o.Amplitudes == nil {
		o.Amplitudes = make([]float64, 0)
	}
	type _tmpFrequencyDomainPlot FrequencyDomainPlot
	return safejson.Marshal(_tmpFrequencyDomainPlot(o))
}

func (o *FrequencyDomainPlot) UnmarshalJSON(data []byte) error {
	type _tmpFrequencyDomainPlot FrequencyDomainPlot
	var rawFrequencyDomainPlot _tmpFrequencyDomainPlot
	if err := safejson.Unmarshal(data, &rawFrequencyDomainPlot); err != nil {
		return err
	}
	if rawFrequencyDomainPlot.Frequencies == nil {
		rawFrequencyDomainPlot.Frequencies = make([]float64, 0)
	}
	if rawFrequencyDomainPlot.Amplitudes == nil {
		rawFrequencyDomainPlot.Amplitudes = make([]float64, 0)
	}
	*o = FrequencyDomainPlot(rawFrequencyDomainPlot)
	return nil
}

func (o FrequencyDomainPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FrequencyDomainPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FunctionVariables struct {
	Variables            map[VariableName]VariableValue          `json:"variables"`
	SubFunctionVariables map[FunctionReference]FunctionVariables `json:"subFunctionVariables"`
}

func (o FunctionVariables) MarshalJSON() ([]byte, error) {
	if o.Variables == nil {
		o.Variables = make(map[VariableName]VariableValue, 0)
	}
	if o.SubFunctionVariables == nil {
		o.SubFunctionVariables = make(map[FunctionReference]FunctionVariables, 0)
	}
	type _tmpFunctionVariables FunctionVariables
	return safejson.Marshal(_tmpFunctionVariables(o))
}

func (o *FunctionVariables) UnmarshalJSON(data []byte) error {
	type _tmpFunctionVariables FunctionVariables
	var rawFunctionVariables _tmpFunctionVariables
	if err := safejson.Unmarshal(data, &rawFunctionVariables); err != nil {
		return err
	}
	if rawFunctionVariables.Variables == nil {
		rawFunctionVariables.Variables = make(map[VariableName]VariableValue, 0)
	}
	if rawFunctionVariables.SubFunctionVariables == nil {
		rawFunctionVariables.SubFunctionVariables = make(map[FunctionReference]FunctionVariables, 0)
	}
	*o = FunctionVariables(rawFunctionVariables)
	return nil
}

func (o FunctionVariables) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FunctionVariables) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GeoPointWithTimestamp struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Value     GeoPoint      `json:"value"`
}

func (o GeoPointWithTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeoPointWithTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GeoTemporalSummary struct {
	Resolution safelong.SafeLong `json:"resolution"`
}

func (o GeoTemporalSummary) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeoTemporalSummary) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Summary of a time-based bucket of geo points.
type GeoTimeBucket struct {
	// The mean value of the GeoPoints in the bucket.
	Mean GeoPoint `conjure-docs:"The mean value of the GeoPoints in the bucket." json:"mean"`
	// The number of GeoPoints in the bucket.
	Count safelong.SafeLong `conjure-docs:"The number of GeoPoints in the bucket." json:"count"`
	// The first GeoPoint in the bucket.
	FirstPoint GeoPointWithTimestamp `conjure-docs:"The first GeoPoint in the bucket." json:"firstPoint"`
	// The last GeoPoint in the bucket. Will be empty if the bucket only has a single point.
	LastPoint *GeoPointWithTimestamp `conjure-docs:"The last GeoPoint in the bucket. Will be empty if the bucket only has a single point." json:"lastPoint,omitempty"`
}

func (o GeoTimeBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeoTimeBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GroupedComputeNodeResponse struct {
	Grouping Grouping            `json:"grouping"`
	Response ComputeNodeResponse `json:"response"`
}

func (o GroupedComputeNodeResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GroupedComputeNodeResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Contains a `ComputeNodeResponse` for each applicable grouping along with metadata describing the grouping.
All the contained `ComputeNodeResponse`s are guaranteed to be of the same type.
*/
type GroupedComputeNodeResponses struct {
	Responses []GroupedComputeNodeResponse `json:"responses"`
}

func (o GroupedComputeNodeResponses) MarshalJSON() ([]byte, error) {
	if o.Responses == nil {
		o.Responses = make([]GroupedComputeNodeResponse, 0)
	}
	type _tmpGroupedComputeNodeResponses GroupedComputeNodeResponses
	return safejson.Marshal(_tmpGroupedComputeNodeResponses(o))
}

func (o *GroupedComputeNodeResponses) UnmarshalJSON(data []byte) error {
	type _tmpGroupedComputeNodeResponses GroupedComputeNodeResponses
	var rawGroupedComputeNodeResponses _tmpGroupedComputeNodeResponses
	if err := safejson.Unmarshal(data, &rawGroupedComputeNodeResponses); err != nil {
		return err
	}
	if rawGroupedComputeNodeResponses.Responses == nil {
		rawGroupedComputeNodeResponses.Responses = make([]GroupedComputeNodeResponse, 0)
	}
	*o = GroupedComputeNodeResponses(rawGroupedComputeNodeResponses)
	return nil
}

func (o GroupedComputeNodeResponses) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GroupedComputeNodeResponses) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HighPassConfiguration struct {
	CutoffFrequency DoubleConstant `json:"cutoffFrequency"`
}

func (o HighPassConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HighPassConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The count of the value in the bucket for the specific channel.
type HistogramChannelCount struct {
	Count safelong.SafeLong `json:"count"`
}

func (o HistogramChannelCount) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramChannelCount) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Attempted an incompatible operation of units.
type IncompatibleUnitOperation struct {
	Operation UnitOperation     `json:"operation"`
	Units     []api1.UnitSymbol `json:"units"`
}

func (o IncompatibleUnitOperation) MarshalJSON() ([]byte, error) {
	if o.Units == nil {
		o.Units = make([]api1.UnitSymbol, 0)
	}
	type _tmpIncompatibleUnitOperation IncompatibleUnitOperation
	return safejson.Marshal(_tmpIncompatibleUnitOperation(o))
}

func (o *IncompatibleUnitOperation) UnmarshalJSON(data []byte) error {
	type _tmpIncompatibleUnitOperation IncompatibleUnitOperation
	var rawIncompatibleUnitOperation _tmpIncompatibleUnitOperation
	if err := safejson.Unmarshal(data, &rawIncompatibleUnitOperation); err != nil {
		return err
	}
	if rawIncompatibleUnitOperation.Units == nil {
		rawIncompatibleUnitOperation.Units = make([]api1.UnitSymbol, 0)
	}
	*o = IncompatibleUnitOperation(rawIncompatibleUnitOperation)
	return nil
}

func (o IncompatibleUnitOperation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IncompatibleUnitOperation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Calculates the running sum of the area underneath a series using the trapezoidal rule.
type IntegralSeries struct {
	Input          NumericSeries     `json:"input"`
	StartTimestamp TimestampConstant `json:"startTimestamp"`
	// Time unit used to calculate the integral. Defaults to seconds if not specified.
	TimeUnit *api.TimeUnit `conjure-docs:"Time unit used to calculate the integral. Defaults to seconds if not specified." json:"timeUnit,omitempty"`
}

func (o IntegralSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IntegralSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The FE should try to pass in inputs in the order in which they should be
evaluated for optimization's sake. Alternatively, we can let the user select
preconditions which they know to be cheaper to compute, which we will evaluate
first.
*/
type IntersectRanges struct {
	Inputs []RangeSeries `json:"inputs"`
}

func (o IntersectRanges) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]RangeSeries, 0)
	}
	type _tmpIntersectRanges IntersectRanges
	return safejson.Marshal(_tmpIntersectRanges(o))
}

func (o *IntersectRanges) UnmarshalJSON(data []byte) error {
	type _tmpIntersectRanges IntersectRanges
	var rawIntersectRanges _tmpIntersectRanges
	if err := safejson.Unmarshal(data, &rawIntersectRanges); err != nil {
		return err
	}
	if rawIntersectRanges.Inputs == nil {
		rawIntersectRanges.Inputs = make([]RangeSeries, 0)
	}
	*o = IntersectRanges(rawIntersectRanges)
	return nil
}

func (o IntersectRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IntersectRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The bounds of a lat long geographic area. Represented by the southwest and northeast corners
of a rectangle, inclusive.
*/
type LatLongBounds struct {
	SouthWest LatLongPoint `json:"southWest"`
	NorthEast LatLongPoint `json:"northEast"`
}

func (o LatLongBounds) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LatLongBounds) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A geo node derived from a lat and long series.
type LatLongGeo struct {
	Latitude  NumericSeries  `json:"latitude"`
	Longitude NumericSeries  `json:"longitude"`
	Bounds    *LatLongBounds `json:"bounds,omitempty"`
}

func (o LatLongGeo) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LatLongGeo) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LatLongPoint struct {
	Latitude  float64 `json:"latitude"`
	Longitude float64 `json:"longitude"`
}

func (o LatLongPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LatLongPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A literal range of values.
type LiteralRange struct {
	StartTimestamp *TimestampConstant `json:"startTimestamp,omitempty"`
	EndTimestamp   *TimestampConstant `json:"endTimestamp,omitempty"`
}

func (o LiteralRange) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LiteralRange) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A list of literal ranges.
type LiteralRanges struct {
	LiteralRanges []LiteralRange `json:"literalRanges"`
}

func (o LiteralRanges) MarshalJSON() ([]byte, error) {
	if o.LiteralRanges == nil {
		o.LiteralRanges = make([]LiteralRange, 0)
	}
	type _tmpLiteralRanges LiteralRanges
	return safejson.Marshal(_tmpLiteralRanges(o))
}

func (o *LiteralRanges) UnmarshalJSON(data []byte) error {
	type _tmpLiteralRanges LiteralRanges
	var rawLiteralRanges _tmpLiteralRanges
	if err := safejson.Unmarshal(data, &rawLiteralRanges); err != nil {
		return err
	}
	if rawLiteralRanges.LiteralRanges == nil {
		rawLiteralRanges.LiteralRanges = make([]LiteralRange, 0)
	}
	*o = LiteralRanges(rawLiteralRanges)
	return nil
}

func (o LiteralRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LiteralRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Filters points such that the log message in each point contains an exact case-insensitive match of the
provided token.
*/
type LogExactMatchCaseInsensitiveFilter struct {
	Token string `json:"token"`
}

func (o LogExactMatchCaseInsensitiveFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogExactMatchCaseInsensitiveFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs only values of the log plot that satisfy the filter.
type LogFilterSeries struct {
	Input    LogSeries         `json:"input"`
	Operator LogFilterOperator `json:"operator"`
}

func (o LogFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogPoint struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Value     LogValue      `json:"value"`
}

func (o LogPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Filters points such that the log message in each point matches the given re2 regular expression.
Regular expression syntax: https://github.com/google/re2/wiki/Syntax.
*/
type LogRegexFilterOperator struct {
	Regex string `json:"regex"`
}

func (o LogRegexFilterOperator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogRegexFilterOperator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogTimeShiftSeries struct {
	Input    LogSeries        `json:"input"`
	Duration DurationConstant `json:"duration"`
}

func (o LogTimeShiftSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogTimeShiftSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Combines multiple log series together and outputs a single series. The strategy to merge input values with the
same timestamp together is specified in the operation field.
*/
type LogUnionSeries struct {
	Input []LogSeries `json:"input"`
	// The strategy to merge points with duplicate timestamps.
	Operation LogUnionOperation `conjure-docs:"The strategy to merge points with duplicate timestamps." json:"operation"`
}

func (o LogUnionSeries) MarshalJSON() ([]byte, error) {
	if o.Input == nil {
		o.Input = make([]LogSeries, 0)
	}
	type _tmpLogUnionSeries LogUnionSeries
	return safejson.Marshal(_tmpLogUnionSeries(o))
}

func (o *LogUnionSeries) UnmarshalJSON(data []byte) error {
	type _tmpLogUnionSeries LogUnionSeries
	var rawLogUnionSeries _tmpLogUnionSeries
	if err := safejson.Unmarshal(data, &rawLogUnionSeries); err != nil {
		return err
	}
	if rawLogUnionSeries.Input == nil {
		rawLogUnionSeries.Input = make([]LogSeries, 0)
	}
	*o = LogUnionSeries(rawLogUnionSeries)
	return nil
}

func (o LogUnionSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogUnionSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogValue struct {
	Message string            `json:"message"`
	Args    map[string]string `json:"args"`
	Id      uuid.UUID         `json:"id"`
}

func (o LogValue) MarshalJSON() ([]byte, error) {
	if o.Args == nil {
		o.Args = make(map[string]string, 0)
	}
	type _tmpLogValue LogValue
	return safejson.Marshal(_tmpLogValue(o))
}

func (o *LogValue) UnmarshalJSON(data []byte) error {
	type _tmpLogValue LogValue
	var rawLogValue _tmpLogValue
	if err := safejson.Unmarshal(data, &rawLogValue); err != nil {
		return err
	}
	if rawLogValue.Args == nil {
		rawLogValue.Args = make(map[string]string, 0)
	}
	*o = LogValue(rawLogValue)
	return nil
}

func (o LogValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogarithmicCurve struct{}

func (o LogarithmicCurve) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogarithmicCurve) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// y = a * ln(x) + b
type LogarithmicResultDetails struct {
	A float64 `json:"a"`
	B float64 `json:"b"`
}

func (o LogarithmicResultDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogarithmicResultDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LowPassConfiguration struct {
	CutoffFrequency DoubleConstant `json:"cutoffFrequency"`
}

func (o LowPassConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LowPassConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For every timestamp specified in the input series, outputs a value that is the maximum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
*/
type MaxSeries struct {
	Inputs []NumericSeries `json:"inputs"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o MaxSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]NumericSeries, 0)
	}
	type _tmpMaxSeries MaxSeries
	return safejson.Marshal(_tmpMaxSeries(o))
}

func (o *MaxSeries) UnmarshalJSON(data []byte) error {
	type _tmpMaxSeries MaxSeries
	var rawMaxSeries _tmpMaxSeries
	if err := safejson.Unmarshal(data, &rawMaxSeries); err != nil {
		return err
	}
	if rawMaxSeries.Inputs == nil {
		rawMaxSeries.Inputs = make([]NumericSeries, 0)
	}
	*o = MaxSeries(rawMaxSeries)
	return nil
}

func (o MaxSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MaxSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The maximum value of points inside the time window.
type Maximum struct{}

func (o Maximum) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Maximum) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For every timestamp specified in the input series, outputs a value that is the mean for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
*/
type MeanSeries struct {
	Inputs []NumericSeries `json:"inputs"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o MeanSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]NumericSeries, 0)
	}
	type _tmpMeanSeries MeanSeries
	return safejson.Marshal(_tmpMeanSeries(o))
}

func (o *MeanSeries) UnmarshalJSON(data []byte) error {
	type _tmpMeanSeries MeanSeries
	var rawMeanSeries _tmpMeanSeries
	if err := safejson.Unmarshal(data, &rawMeanSeries); err != nil {
		return err
	}
	if rawMeanSeries.Inputs == nil {
		rawMeanSeries.Inputs = make([]NumericSeries, 0)
	}
	*o = MeanSeries(rawMeanSeries)
	return nil
}

func (o MeanSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MeanSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which the threshold condition is satisfied.
type MinMaxThresholdRanges struct {
	Input                          NumericSeries                   `json:"input"`
	LowerBound                     DoubleConstant                  `json:"lowerBound"`
	UpperBound                     DoubleConstant                  `json:"upperBound"`
	Operator                       MinMaxThresholdOperator         `json:"operator"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration `json:"persistenceWindowConfiguration,omitempty"`
}

func (o MinMaxThresholdRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MinMaxThresholdRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For every timestamp specified in the input series, outputs a value that is the minimum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
*/
type MinSeries struct {
	Inputs []NumericSeries `json:"inputs"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o MinSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]NumericSeries, 0)
	}
	type _tmpMinSeries MinSeries
	return safejson.Marshal(_tmpMinSeries(o))
}

func (o *MinSeries) UnmarshalJSON(data []byte) error {
	type _tmpMinSeries MinSeries
	var rawMinSeries _tmpMinSeries
	if err := safejson.Unmarshal(data, &rawMinSeries); err != nil {
		return err
	}
	if rawMinSeries.Inputs == nil {
		rawMinSeries.Inputs = make([]NumericSeries, 0)
	}
	*o = MinSeries(rawMinSeries)
	return nil
}

func (o MinSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MinSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The minimum value of points inside the time window.
type Minimum struct{}

func (o Minimum) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Minimum) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A reference to a derived series resulting from applying a module to an asset.
The referenced module must be applied to the referenced asset.
*/
type ModuleApplicationDerivedSeries struct {
	// A reference to the module application that produced this derived series.
	ModuleApplicationRid StringConstant `conjure-docs:"A reference to the module application that produced this derived series." json:"moduleApplicationRid"`
	FunctionName         StringConstant `json:"functionName"`
	/*
	   Map of function input names to their values. The function inputs must match the function's parameter
	   names and types. Because all function parameters have default values when the module is applied to the asset, this can be empty.
	*/
	FunctionArgs map[VariableName]VariableValue `conjure-docs:"Map of function input names to their values. The function inputs must match the function's parameter\nnames and types. Because all function parameters have default values when the module is applied to the asset, this can be empty." json:"functionArgs"`
}

func (o ModuleApplicationDerivedSeries) MarshalJSON() ([]byte, error) {
	if o.FunctionArgs == nil {
		o.FunctionArgs = make(map[VariableName]VariableValue, 0)
	}
	type _tmpModuleApplicationDerivedSeries ModuleApplicationDerivedSeries
	return safejson.Marshal(_tmpModuleApplicationDerivedSeries(o))
}

func (o *ModuleApplicationDerivedSeries) UnmarshalJSON(data []byte) error {
	type _tmpModuleApplicationDerivedSeries ModuleApplicationDerivedSeries
	var rawModuleApplicationDerivedSeries _tmpModuleApplicationDerivedSeries
	if err := safejson.Unmarshal(data, &rawModuleApplicationDerivedSeries); err != nil {
		return err
	}
	if rawModuleApplicationDerivedSeries.FunctionArgs == nil {
		rawModuleApplicationDerivedSeries.FunctionArgs = make(map[VariableName]VariableValue, 0)
	}
	*o = ModuleApplicationDerivedSeries(rawModuleApplicationDerivedSeries)
	return nil
}

func (o ModuleApplicationDerivedSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ModuleApplicationDerivedSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The not ranges node will invert the ranges, filling the negative space in time.
type NotRanges struct {
	Input RangeSeries `json:"input"`
}

func (o NotRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NotRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs the values of the numeric plot value that are approximately equal to the threshold value.
type NumericApproximateFilterSeries struct {
	Input     NumericSeries                `json:"input"`
	Threshold DoubleConstant               `json:"threshold"`
	Tolerance DoubleConstant               `json:"tolerance"`
	Operator  ApproximateThresholdOperator `json:"operator"`
}

func (o NumericApproximateFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericApproximateFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericBucket struct {
	Min   float64           `json:"min"`
	Max   float64           `json:"max"`
	Mean  float64           `json:"mean"`
	Count safelong.SafeLong `json:"count"`
	// The population variance of the bucket. If the bucket has only one value, this will be 0.
	Variance   float64      `conjure-docs:"The population variance of the bucket. If the bucket has only one value, this will be 0." json:"variance"`
	FirstPoint NumericPoint `json:"firstPoint"`
	// Will be empty if the bucket only has a single point.
	LastPoint *NumericPoint `conjure-docs:"Will be empty if the bucket only has a single point." json:"lastPoint,omitempty"`
}

func (o NumericBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs the values of the numeric plot value within the ranges specified by a ranges node
type NumericFilterTransformationSeries struct {
	Input  NumericSeries `json:"input"`
	Filter RangeSeries   `json:"filter"`
}

func (o NumericFilterTransformationSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericFilterTransformationSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A bucket in a numeric histogram representing a range of values,
and the counts of values in that range across all input series.
*/
type NumericHistogramBucket struct {
	// The lower bound of the bucket, inclusive
	LowerBound float64 `conjure-docs:"The lower bound of the bucket, inclusive" json:"lowerBound"`
	// The upper bound of the bucket, exclusive
	UpperBound      float64                                `conjure-docs:"The upper bound of the bucket, exclusive" json:"upperBound"`
	CountsByChannel map[VariableName]HistogramChannelCount `json:"countsByChannel"`
	// Deprecated: Use countsByChannel instead
	Buckets map[VariableName]HistogramChannelCount `json:"buckets"`
}

func (o NumericHistogramBucket) MarshalJSON() ([]byte, error) {
	if o.CountsByChannel == nil {
		o.CountsByChannel = make(map[VariableName]HistogramChannelCount, 0)
	}
	if o.Buckets == nil {
		o.Buckets = make(map[VariableName]HistogramChannelCount, 0)
	}
	type _tmpNumericHistogramBucket NumericHistogramBucket
	return safejson.Marshal(_tmpNumericHistogramBucket(o))
}

func (o *NumericHistogramBucket) UnmarshalJSON(data []byte) error {
	type _tmpNumericHistogramBucket NumericHistogramBucket
	var rawNumericHistogramBucket _tmpNumericHistogramBucket
	if err := safejson.Unmarshal(data, &rawNumericHistogramBucket); err != nil {
		return err
	}
	if rawNumericHistogramBucket.CountsByChannel == nil {
		rawNumericHistogramBucket.CountsByChannel = make(map[VariableName]HistogramChannelCount, 0)
	}
	if rawNumericHistogramBucket.Buckets == nil {
		rawNumericHistogramBucket.Buckets = make(map[VariableName]HistogramChannelCount, 0)
	}
	*o = NumericHistogramBucket(rawNumericHistogramBucket)
	return nil
}

func (o NumericHistogramBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericHistogramBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericHistogramBucketWidthAndOffset struct {
	/*
	   The width of each bucket. If offset is not specified, the left and right bounds of each bucket
	   are multiples of the width. If offset is specified, the left and right bounds of each bucket are
	   shifted right by the offset value.
	*/
	Width DoubleConstant `conjure-docs:"The width of each bucket. If offset is not specified, the left and right bounds of each bucket\nare multiples of the width. If offset is specified, the left and right bounds of each bucket are\nshifted right by the offset value." json:"width"`
	/*
	   The rightward shift to apply to the left and right bounds of each bucket. If not specified,
	   the offset will be 0. The offset must be non-negative.
	*/
	Offset *DoubleConstant `conjure-docs:"The rightward shift to apply to the left and right bounds of each bucket. If not specified, \nthe offset will be 0. The offset must be non-negative." json:"offset,omitempty"`
}

func (o NumericHistogramBucketWidthAndOffset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericHistogramBucketWidthAndOffset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericHistogramNode struct {
	Inputs         map[VariableName]NumericSeries  `json:"inputs"`
	BucketStrategy *NumericHistogramBucketStrategy `json:"bucketStrategy,omitempty"`
}

func (o NumericHistogramNode) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make(map[VariableName]NumericSeries, 0)
	}
	type _tmpNumericHistogramNode NumericHistogramNode
	return safejson.Marshal(_tmpNumericHistogramNode(o))
}

func (o *NumericHistogramNode) UnmarshalJSON(data []byte) error {
	type _tmpNumericHistogramNode NumericHistogramNode
	var rawNumericHistogramNode _tmpNumericHistogramNode
	if err := safejson.Unmarshal(data, &rawNumericHistogramNode); err != nil {
		return err
	}
	if rawNumericHistogramNode.Inputs == nil {
		rawNumericHistogramNode.Inputs = make(map[VariableName]NumericSeries, 0)
	}
	*o = NumericHistogramNode(rawNumericHistogramNode)
	return nil
}

func (o NumericHistogramNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericHistogramNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericHistogramPlot struct {
	Buckets []NumericHistogramBucket `json:"buckets"`
}

func (o NumericHistogramPlot) MarshalJSON() ([]byte, error) {
	if o.Buckets == nil {
		o.Buckets = make([]NumericHistogramBucket, 0)
	}
	type _tmpNumericHistogramPlot NumericHistogramPlot
	return safejson.Marshal(_tmpNumericHistogramPlot(o))
}

func (o *NumericHistogramPlot) UnmarshalJSON(data []byte) error {
	type _tmpNumericHistogramPlot NumericHistogramPlot
	var rawNumericHistogramPlot _tmpNumericHistogramPlot
	if err := safejson.Unmarshal(data, &rawNumericHistogramPlot); err != nil {
		return err
	}
	if rawNumericHistogramPlot.Buckets == nil {
		rawNumericHistogramPlot.Buckets = make([]NumericHistogramBucket, 0)
	}
	*o = NumericHistogramPlot(rawNumericHistogramPlot)
	return nil
}

func (o NumericHistogramPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericHistogramPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericPlot struct {
	Timestamps []api.Timestamp `json:"timestamps"`
	Values     []float64       `json:"values"`
}

func (o NumericPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.Values == nil {
		o.Values = make([]float64, 0)
	}
	type _tmpNumericPlot NumericPlot
	return safejson.Marshal(_tmpNumericPlot(o))
}

func (o *NumericPlot) UnmarshalJSON(data []byte) error {
	type _tmpNumericPlot NumericPlot
	var rawNumericPlot _tmpNumericPlot
	if err := safejson.Unmarshal(data, &rawNumericPlot); err != nil {
		return err
	}
	if rawNumericPlot.Timestamps == nil {
		rawNumericPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawNumericPlot.Values == nil {
		rawNumericPlot.Values = make([]float64, 0)
	}
	*o = NumericPlot(rawNumericPlot)
	return nil
}

func (o NumericPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericPoint struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Value     float64       `json:"value"`
}

func (o NumericPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Resamples the input series to a new resolution using interpolation.
Outputs data for timestamps corresponding to the defined frequency. Based on interpolation strategy,
determines range of timestamps to output data for and interpolates values where necessary.
*/
type NumericResampleSeries struct {
	Input NumericSeries `json:"input"`
	// The interpolation strategy and interval at which to resample the series
	ResampleConfiguration ResampleConfiguration `conjure-docs:"The interpolation strategy and interval at which to resample the series" json:"resampleConfiguration"`
}

func (o NumericResampleSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericResampleSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs only the values of the numeric plot value that satisfy the threshold condition.
type NumericThresholdFilterSeries struct {
	Input     NumericSeries     `json:"input"`
	Threshold DoubleConstant    `json:"threshold"`
	Operator  ThresholdOperator `json:"operator"`
}

func (o NumericThresholdFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericThresholdFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Filters the series to points within the specified time range.
type NumericTimeRangeFilterSeries struct {
	Input NumericSeries `json:"input"`
	// Represents the start time (inclusive) of the time range.
	StartTime *TimestampConstant `conjure-docs:"Represents the start time (inclusive) of the time range." json:"startTime,omitempty"`
	// Represents the end time (inclusive) of the time range.
	EndTime *TimestampConstant `conjure-docs:"Represents the end time (inclusive) of the time range." json:"endTime,omitempty"`
}

func (o NumericTimeRangeFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericTimeRangeFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericTimeShiftSeries struct {
	Input    NumericSeries    `json:"input"`
	Duration DurationConstant `json:"duration"`
}

func (o NumericTimeShiftSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericTimeShiftSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Combines multiple numeric series together and outputs a single series. If the same timestamp is duplicated in
multiple input series, the output series will contain a single point with this timestamp. The strategy to
merge input values with the same timestamp together is specified in the operation field.
*/
type NumericUnionSeries struct {
	Input []NumericSeries `json:"input"`
	// The strategy to merge points with duplicate timestamps.
	Operation NumericUnionOperation `conjure-docs:"The strategy to merge points with duplicate timestamps." json:"operation"`
}

func (o NumericUnionSeries) MarshalJSON() ([]byte, error) {
	if o.Input == nil {
		o.Input = make([]NumericSeries, 0)
	}
	type _tmpNumericUnionSeries NumericUnionSeries
	return safejson.Marshal(_tmpNumericUnionSeries(o))
}

func (o *NumericUnionSeries) UnmarshalJSON(data []byte) error {
	type _tmpNumericUnionSeries NumericUnionSeries
	var rawNumericUnionSeries _tmpNumericUnionSeries
	if err := safejson.Unmarshal(data, &rawNumericUnionSeries); err != nil {
		return err
	}
	if rawNumericUnionSeries.Input == nil {
		rawNumericUnionSeries.Input = make([]NumericSeries, 0)
	}
	*o = NumericUnionSeries(rawNumericUnionSeries)
	return nil
}

func (o NumericUnionSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericUnionSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// For every timestamp specified in the input series, offset it by a constant factor.
type OffsetSeries struct {
	Input NumericSeries `json:"input"`
	// The constant to add to each point
	Scalar DoubleConstant `conjure-docs:"The constant to add to each point" json:"scalar"`
}

func (o OffsetSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *OffsetSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Produces a list of ranges for each point that has a different value to the previous point.
A range will have identical start and end times.
*/
type OnChangeRanges struct {
	Input Series `json:"input"`
}

func (o OnChangeRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *OnChangeRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Specification of a page for a series. Returns raw undecimated points beginning nearest to the given page
token, advancing pageSize points in the time direction specified by the sign of the page size.
*/
type PageInfo struct {
	PageToken *PageToken `json:"pageToken,omitempty"`
	PageSize  int        `json:"pageSize"`
}

func (o PageInfo) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PageInfo) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PagedEnumArrayPlot struct {
	// The raw binary containing Arrow IPC stream for a page of an N-dimensional enum array plot.
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for a page of an N-dimensional enum array plot." json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
	/*
	   The token to retrieve the next page of arrays in the direction originally requested (exclusive - not
	   included in these results). May be empty if there are no further values in the requested time range in the
	   direction originally requested.
	*/
	NextPageToken *PageToken `conjure-docs:"The token to retrieve the next page of arrays in the direction originally requested (exclusive - not\nincluded in these results). May be empty if there are no further values in the requested time range in the\ndirection originally requested." json:"nextPageToken,omitempty"`
}

func (o PagedEnumArrayPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PagedEnumArrayPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PagedLogPlot struct {
	Timestamps []api.Timestamp `json:"timestamps"`
	Values     []LogValue      `json:"values"`
	/*
	   The token to retrieve the next page of logs in the direction originally requested (exclusive - not
	   included in these results). May be empty if there are no further logs in the requested time range in the
	   direction originally requested.
	*/
	NextPageToken *PageToken `conjure-docs:"The token to retrieve the next page of logs in the direction originally requested (exclusive - not\nincluded in these results). May be empty if there are no further logs in the requested time range in the\ndirection originally requested." json:"nextPageToken,omitempty"`
}

func (o PagedLogPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.Values == nil {
		o.Values = make([]LogValue, 0)
	}
	type _tmpPagedLogPlot PagedLogPlot
	return safejson.Marshal(_tmpPagedLogPlot(o))
}

func (o *PagedLogPlot) UnmarshalJSON(data []byte) error {
	type _tmpPagedLogPlot PagedLogPlot
	var rawPagedLogPlot _tmpPagedLogPlot
	if err := safejson.Unmarshal(data, &rawPagedLogPlot); err != nil {
		return err
	}
	if rawPagedLogPlot.Timestamps == nil {
		rawPagedLogPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawPagedLogPlot.Values == nil {
		rawPagedLogPlot.Values = make([]LogValue, 0)
	}
	*o = PagedLogPlot(rawPagedLogPlot)
	return nil
}

func (o PagedLogPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PagedLogPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PagedNumericArrayPlot struct {
	// The raw binary containing Arrow IPC stream for a page of an N-dimensional numeric array plot.
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for a page of an N-dimensional numeric array plot." json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
	/*
	   The token to retrieve the next page of arrays in the direction originally requested (exclusive - not
	   included in these results). May be empty if there are no further values in the requested time range in the
	   direction originally requested.
	*/
	NextPageToken *PageToken `conjure-docs:"The token to retrieve the next page of arrays in the direction originally requested (exclusive - not\nincluded in these results). May be empty if there are no further values in the requested time range in the\ndirection originally requested." json:"nextPageToken,omitempty"`
}

func (o PagedNumericArrayPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PagedNumericArrayPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ParameterInput struct {
	Variables map[VariableName]VariableValue `json:"variables"`
	/*
	   Overrides the start and end time of the compute request. If either the start or end are not present, we
	   default back to the start/end specified in the request.
	*/
	TimeRange *Range `conjure-docs:"Overrides the start and end time of the compute request. If either the start or end are not present, we\ndefault back to the start/end specified in the request." json:"timeRange,omitempty"`
}

func (o ParameterInput) MarshalJSON() ([]byte, error) {
	if o.Variables == nil {
		o.Variables = make(map[VariableName]VariableValue, 0)
	}
	type _tmpParameterInput ParameterInput
	return safejson.Marshal(_tmpParameterInput(o))
}

func (o *ParameterInput) UnmarshalJSON(data []byte) error {
	type _tmpParameterInput ParameterInput
	var rawParameterInput _tmpParameterInput
	if err := safejson.Unmarshal(data, &rawParameterInput); err != nil {
		return err
	}
	if rawParameterInput.Variables == nil {
		rawParameterInput.Variables = make(map[VariableName]VariableValue, 0)
	}
	*o = ParameterInput(rawParameterInput)
	return nil
}

func (o ParameterInput) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ParameterInput) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ParameterizedComputeNodeRequest struct {
	Node    ComputableNode `json:"node"`
	Start   api.Timestamp  `json:"start"`
	End     api.Timestamp  `json:"end"`
	Context Context        `json:"context"`
	/*
	   Specifies how certain variables should be parameterized. If a variable name appears in both the context
	   and the parameterized context, it will be treated as parameterized.
	*/
	ParameterizedContext ParameterizedContext `conjure-docs:"Specifies how certain variables should be parameterized. If a variable name appears in both the context\nand the parameterized context, it will be treated as parameterized." json:"parameterizedContext"`
}

func (o ParameterizedComputeNodeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ParameterizedComputeNodeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ParameterizedComputeNodeResponse struct {
	Results []ComputeNodeResult `json:"results"`
}

func (o ParameterizedComputeNodeResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ComputeNodeResult, 0)
	}
	type _tmpParameterizedComputeNodeResponse ParameterizedComputeNodeResponse
	return safejson.Marshal(_tmpParameterizedComputeNodeResponse(o))
}

func (o *ParameterizedComputeNodeResponse) UnmarshalJSON(data []byte) error {
	type _tmpParameterizedComputeNodeResponse ParameterizedComputeNodeResponse
	var rawParameterizedComputeNodeResponse _tmpParameterizedComputeNodeResponse
	if err := safejson.Unmarshal(data, &rawParameterizedComputeNodeResponse); err != nil {
		return err
	}
	if rawParameterizedComputeNodeResponse.Results == nil {
		rawParameterizedComputeNodeResponse.Results = make([]ComputeNodeResult, 0)
	}
	*o = ParameterizedComputeNodeResponse(rawParameterizedComputeNodeResponse)
	return nil
}

func (o ParameterizedComputeNodeResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ParameterizedComputeNodeResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ParameterizedContext struct {
	// Each parameter input provides a satisfying set of values for the parameterized compute node.
	ParameterInputs []ParameterInput `conjure-docs:"Each parameter input provides a satisfying set of values for the parameterized compute node." json:"parameterInputs"`
}

func (o ParameterizedContext) MarshalJSON() ([]byte, error) {
	if o.ParameterInputs == nil {
		o.ParameterInputs = make([]ParameterInput, 0)
	}
	type _tmpParameterizedContext ParameterizedContext
	return safejson.Marshal(_tmpParameterizedContext(o))
}

func (o *ParameterizedContext) UnmarshalJSON(data []byte) error {
	type _tmpParameterizedContext ParameterizedContext
	var rawParameterizedContext _tmpParameterizedContext
	if err := safejson.Unmarshal(data, &rawParameterizedContext); err != nil {
		return err
	}
	if rawParameterizedContext.ParameterInputs == nil {
		rawParameterizedContext.ParameterInputs = make([]ParameterInput, 0)
	}
	*o = ParameterizedContext(rawParameterizedContext)
	return nil
}

func (o ParameterizedContext) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ParameterizedContext) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Produces a list of ranges for each point that is greater than its neighbors.
Peaks at edges are discarded, and continuous, multivalue, flat peaks will return all values.
*/
type PeakRanges struct {
	Input NumericSeries `json:"input"`
	/*
	   True if returning peaks, else troughs.

	   Deprecated: No longer used, use returnType instead
	*/
	ReturnsPeaks *bool `conjure-docs:"True if returning peaks, else troughs." json:"returnsPeaks,omitempty"`
	// Optional for backcompatibility.
	ReturnType *PeakType `conjure-docs:"Optional for backcompatibility." json:"returnType,omitempty"`
	/*
	   The minimum topographic prominence for an extrema to be returned.
	   Prominence is the minimum vertical distance needed to travel from an extrema to one of greater magnitude.
	*/
	MinimumProminence *DoubleConstant `conjure-docs:"The minimum topographic prominence for an extrema to be returned.\nProminence is the minimum vertical distance needed to travel from an extrema to one of greater magnitude." json:"minimumProminence,omitempty"`
}

func (o PeakRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PeakRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Threshold defined as the percentage of a given value.
type PercentageThreshold struct {
	Value DoubleConstant `json:"value"`
}

func (o PercentageThreshold) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PercentageThreshold) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Configures how long a condition has to be true for to output a time range, and what to use as the
start of the output range. For a point to be included in the output time range, both the minPoints and
minDuration conditions must be satisfied.
*/
type PersistenceWindowConfiguration struct {
	/*
	   The minimum number of points for which this condition be must satisfied to include the time range in the
	   output. Must be non-negative. If not present, will default to 1.
	*/
	MinPoints *IntegerConstant `conjure-docs:"The minimum number of points for which this condition be must satisfied to include the time range in the\noutput. Must be non-negative. If not present, will default to 1." json:"minPoints,omitempty"`
	/*
	   The minimum number of points for which this condition must be satisfied to include the time range in the
	   output. Must be non-negative. If not present, will default to 1 nanosecond.
	*/
	MinDuration *DurationConstant `conjure-docs:"The minimum number of points for which this condition must be satisfied to include the time range in the\noutput. Must be non-negative. If not present, will default to 1 nanosecond." json:"minDuration,omitempty"`
	// Which point to use as the start of the output range. Defaults to firstPointMatchingCondition if not specified.
	OutputRangeStart OutputRangeStart `conjure-docs:"Which point to use as the start of the output range. Defaults to firstPointMatchingCondition if not specified." json:"outputRangeStart"`
}

func (o PersistenceWindowConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PersistenceWindowConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Point3d struct {
	X         float64       `json:"x"`
	Y         float64       `json:"y"`
	Z         float64       `json:"z"`
	Timestamp api.Timestamp `json:"timestamp"`
}

func (o Point3d) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Point3d) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PolynomialCurve struct {
	// The highest allowable degree of the fit polynomial.
	Degree IntegerConstant `conjure-docs:"The highest allowable degree of the fit polynomial." json:"degree"`
	// The y-value at the point x (or t) = 0. If omitted, the y-intercept will also be fit to the data.
	Intercept *DoubleConstant `conjure-docs:"The y-value at the point x (or t) = 0. If omitted, the y-intercept will also be fit to the data." json:"intercept,omitempty"`
}

func (o PolynomialCurve) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PolynomialCurve) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// y = sum( a_i * x^i ) for i in 0...len(a)
type PolynomialResultDetails struct {
	A []float64 `json:"a"`
}

func (o PolynomialResultDetails) MarshalJSON() ([]byte, error) {
	if o.A == nil {
		o.A = make([]float64, 0)
	}
	type _tmpPolynomialResultDetails PolynomialResultDetails
	return safejson.Marshal(_tmpPolynomialResultDetails(o))
}

func (o *PolynomialResultDetails) UnmarshalJSON(data []byte) error {
	type _tmpPolynomialResultDetails PolynomialResultDetails
	var rawPolynomialResultDetails _tmpPolynomialResultDetails
	if err := safejson.Unmarshal(data, &rawPolynomialResultDetails); err != nil {
		return err
	}
	if rawPolynomialResultDetails.A == nil {
		rawPolynomialResultDetails.A = make([]float64, 0)
	}
	*o = PolynomialResultDetails(rawPolynomialResultDetails)
	return nil
}

func (o PolynomialResultDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PolynomialResultDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PowerCurve struct{}

func (o PowerCurve) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PowerCurve) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// y = a * x^b
type PowerResultDetails struct {
	A float64 `json:"a"`
	B float64 `json:"b"`
}

func (o PowerResultDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PowerResultDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For every timestamp specified in the input series, outputs a value that is the product for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
*/
type ProductSeries struct {
	Inputs []NumericSeries `json:"inputs"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o ProductSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]NumericSeries, 0)
	}
	type _tmpProductSeries ProductSeries
	return safejson.Marshal(_tmpProductSeries(o))
}

func (o *ProductSeries) UnmarshalJSON(data []byte) error {
	type _tmpProductSeries ProductSeries
	var rawProductSeries _tmpProductSeries
	if err := safejson.Unmarshal(data, &rawProductSeries); err != nil {
		return err
	}
	if rawProductSeries.Inputs == nil {
		rawProductSeries.Inputs = make([]NumericSeries, 0)
	}
	*o = ProductSeries(rawProductSeries)
	return nil
}

func (o ProductSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ProductSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Property struct {
	Name  StringConstant `json:"name"`
	Value StringConstant `json:"value"`
}

func (o Property) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Property) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The end represents the first timestamp that does not belong to the range. If absent, there is no known
end to the range.
*/
type Range struct {
	Start *api.Timestamp `json:"start,omitempty"`
	End   *api.Timestamp `json:"end,omitempty"`
	Value *RangeValue    `json:"value,omitempty"`
}

func (o Range) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Range) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RangeAggregation struct {
	Average           float64 `json:"average"`
	Min               float64 `json:"min"`
	Max               float64 `json:"max"`
	StandardDeviation float64 `json:"standardDeviation"`
	Count             float64 `json:"count"`
}

func (o RangeAggregation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangeAggregation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RangeMap struct {
	// Inclusive start value. If not specified, the start is the prior range's end value, or negative infinity.
	Start *DoubleConstant `conjure-docs:"Inclusive start value. If not specified, the start is the prior range's end value, or negative infinity." json:"start,omitempty"`
	// Exclusive end value. If not specified, the end value is the next range's start value, or positive infinity.
	End *DoubleConstant `conjure-docs:"Exclusive end value. If not specified, the end value is the next range's start value, or positive infinity." json:"end,omitempty"`
	// The value to map to if the input value is within the range.
	Output StringConstant `conjure-docs:"The value to map to if the input value is within the range." json:"output"`
}

func (o RangeMap) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangeMap) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Summary of a set of ranges
type RangeSummary struct {
	// The range representing the minimum start and maximum end times of the ranges.
	Range Range `conjure-docs:"The range representing the minimum start and maximum end times of the ranges." json:"range"`
	// The number of ranges found within this time range.
	SubRangeCount int `conjure-docs:"The number of ranges found within this time range." json:"subRangeCount"`
}

func (o RangeSummary) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangeSummary) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Aggregates the values of a numeric series at each range specified by the input ranges.
type RangesNumericAggregation struct {
	Ranges    RangeSeries               `json:"ranges"`
	Input     NumericSeries             `json:"input"`
	Operation RangeAggregationOperation `json:"operation"`
}

func (o RangesNumericAggregation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangesNumericAggregation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A summary of the ranges returned from a SummarizeRanges request. Returned when the number of ranges
found is above a threshold.
*/
type RangesSummary struct {
	RangesSummary []RangeSummary `json:"rangesSummary"`
}

func (o RangesSummary) MarshalJSON() ([]byte, error) {
	if o.RangesSummary == nil {
		o.RangesSummary = make([]RangeSummary, 0)
	}
	type _tmpRangesSummary RangesSummary
	return safejson.Marshal(_tmpRangesSummary(o))
}

func (o *RangesSummary) UnmarshalJSON(data []byte) error {
	type _tmpRangesSummary RangesSummary
	var rawRangesSummary _tmpRangesSummary
	if err := safejson.Unmarshal(data, &rawRangesSummary); err != nil {
		return err
	}
	if rawRangesSummary.RangesSummary == nil {
		rawRangesSummary.RangesSummary = make([]RangeSummary, 0)
	}
	*o = RangesSummary(rawRangesSummary)
	return nil
}

func (o RangesSummary) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangesSummary) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Reference struct {
	Name VariableName `json:"name"`
}

func (o Reference) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Reference) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ResampleConfiguration struct {
	// Interval between resampled points
	Interval DurationConstant `conjure-docs:"Interval between resampled points" json:"interval"`
	// Interpolation strategy to use (defaults to forward fill).
	Interpolation *ResampleInterpolationConfiguration `conjure-docs:"Interpolation strategy to use (defaults to forward fill)." json:"interpolation,omitempty"`
}

func (o ResampleConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ResampleConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RollingOperationSeries struct {
	Input    NumericSeries   `json:"input"`
	Window   Window          `json:"window"`
	Operator RollingOperator `json:"operator"`
}

func (o RollingOperationSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RollingOperationSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RunChannel struct {
	RunRid StringConstant `json:"runRid"`
	// Used to disambiguate when multiple data scopes within this run contain channels with the same name.
	DataScopeName StringConstant `conjure-docs:"Used to disambiguate when multiple data scopes within this run contain channels with the same name." json:"dataScopeName"`
	Channel       StringConstant `json:"channel"`
	// Deprecated: Use additionalTagFilters
	AdditionalTags map[string]StringConstant `json:"additionalTags"`
	/*
	   Tags to filter the channel by, in addition to tag filters defined for a given Run data scope. Throws on
	   collisions with tag keys already defined for the given Run data scope. Only returns points that match
	   both sets of tag filters. For log series, include arg filters here in addition to tag filters.
	*/
	AdditionalTagFilters *TagFilters `conjure-docs:"Tags to filter the channel by, in addition to tag filters defined for a given Run data scope. Throws on \ncollisions with tag keys already defined for the given Run data scope. Only returns points that match \nboth sets of tag filters. For log series, include arg filters here in addition to tag filters." json:"additionalTagFilters,omitempty"`
	// Deprecated: Use groupByTags instead. Throws if both tagsToGroupBy and groupByTags are specified.
	TagsToGroupBy []string `json:"tagsToGroupBy"`
	/*
	   Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned
	   with an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified.
	*/
	GroupByTags []StringConstant `conjure-docs:"Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned\nwith an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified." json:"groupByTags"`
}

func (o RunChannel) MarshalJSON() ([]byte, error) {
	if o.AdditionalTags == nil {
		o.AdditionalTags = make(map[string]StringConstant, 0)
	}
	if o.TagsToGroupBy == nil {
		o.TagsToGroupBy = make([]string, 0)
	}
	if o.GroupByTags == nil {
		o.GroupByTags = make([]StringConstant, 0)
	}
	type _tmpRunChannel RunChannel
	return safejson.Marshal(_tmpRunChannel(o))
}

func (o *RunChannel) UnmarshalJSON(data []byte) error {
	type _tmpRunChannel RunChannel
	var rawRunChannel _tmpRunChannel
	if err := safejson.Unmarshal(data, &rawRunChannel); err != nil {
		return err
	}
	if rawRunChannel.AdditionalTags == nil {
		rawRunChannel.AdditionalTags = make(map[string]StringConstant, 0)
	}
	if rawRunChannel.TagsToGroupBy == nil {
		rawRunChannel.TagsToGroupBy = make([]string, 0)
	}
	if rawRunChannel.GroupByTags == nil {
		rawRunChannel.GroupByTags = make([]StringConstant, 0)
	}
	*o = RunChannel(rawRunChannel)
	return nil
}

func (o RunChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RunChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// For every timestamp specified in the input series, multiply it by a constant factor.
type ScaleSeries struct {
	Input NumericSeries `json:"input"`
	// The constant to multiply each point by
	Scalar DoubleConstant `conjure-docs:"The constant to multiply each point by" json:"scalar"`
	// The units of the scalar to multiply by. If empty, the scalar is considered unit-less.
	ScalarUnit *api1.UnitSymbol `conjure-docs:"The units of the scalar to multiply by. If empty, the scalar is considered unit-less." json:"scalarUnit,omitempty"`
}

func (o ScaleSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ScaleSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A scatter plot comprised of the values from one input series on the x-axis
and values from another input series on the y-axis, for all points within a requested time range.
*/
type Scatter struct {
	X NumericSeries `json:"x"`
	Y NumericSeries `json:"y"`
}

func (o Scatter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Scatter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Scatter3d struct {
	X            NumericSeries   `json:"x"`
	Y            NumericSeries   `json:"y"`
	Z            NumericSeries   `json:"z"`
	DriverSeries *DriverSeries3d `json:"driverSeries,omitempty"`
}

func (o Scatter3d) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Scatter3d) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Fits a curve to the scatter between two series.
type ScatterCurveFit struct {
	// The x and y series to fit to.
	Scatter Scatter           `conjure-docs:"The x and y series to fit to." json:"scatter"`
	Options ScatterFitOptions `json:"options"`
}

func (o ScatterCurveFit) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ScatterCurveFit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ScatterFitOptions struct {
	/*
	   Inclusive lower bound on the x values to fit to. If omitted, does not set a bound
	   (equivalent to setting this to the minimum x value among all points in the time range).
	*/
	MinX *DoubleConstant `conjure-docs:"Inclusive lower bound on the x values to fit to. If omitted, does not set a bound\n(equivalent to setting this to the minimum x value among all points in the time range)." json:"minX,omitempty"`
	/*
	   Inclusive upper bound on the x values to fit to. If omitted, does not set a bound
	   (equivalent to setting this to the maximum x value among all points in the time range).
	*/
	MaxX *DoubleConstant `conjure-docs:"Inclusive upper bound on the x values to fit to. If omitted, does not set a bound\n(equivalent to setting this to the maximum x value among all points in the time range)." json:"maxX,omitempty"`
	/*
	   Inclusive lower bound on the y values to fit to. If omitted, does not set a bound
	   (equivalent to setting this to the minimum y value among all points in the time range).
	*/
	MinY *DoubleConstant `conjure-docs:"Inclusive lower bound on the y values to fit to. If omitted, does not set a bound\n(equivalent to setting this to the minimum y value among all points in the time range)." json:"minY,omitempty"`
	/*
	   Inclusive upper bound on the y values to fit to. If omitted, does not set a bound
	   (equivalent to setting this to the maximum y value among all points in the time range).
	*/
	MaxY *DoubleConstant `conjure-docs:"Inclusive upper bound on the y values to fit to. If omitted, does not set a bound\n(equivalent to setting this to the maximum y value among all points in the time range)." json:"maxY,omitempty"`
}

func (o ScatterFitOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ScatterFitOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For each timestamp, selects a single enum value from the 1D enum array at the specified index. If the index
is out of bounds for an array at a given timestamp, it is omitted.
*/
type SelectIndexFrom1dEnumArraySeries struct {
	Input Enum1dArraySeries `json:"input"`
	Index IntegerConstant   `json:"index"`
}

func (o SelectIndexFrom1dEnumArraySeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SelectIndexFrom1dEnumArraySeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For each timestamp, selects a single numeric value from the 1D numeric array at the specified index. If the
index is out of bounds for an array at a given timestamp, it is omitted.
*/
type SelectIndexFrom1dNumericArraySeries struct {
	Input Numeric1dArraySeries `json:"input"`
	Index IntegerConstant      `json:"index"`
}

func (o SelectIndexFrom1dNumericArraySeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SelectIndexFrom1dNumericArraySeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Select the most recent N points from the input series by timestamp.
type SelectNewestPointsSeries struct {
	Input     NumericSeries   `json:"input"`
	NumPoints IntegerConstant `json:"numPoints"`
}

func (o SelectNewestPointsSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SelectNewestPointsSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of zero-duration ranges at the first point where two series cross over one another
type SeriesCrossoverRanges struct {
	InputA NumericSeries `json:"inputA"`
	InputB NumericSeries `json:"inputB"`
}

func (o SeriesCrossoverRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SeriesCrossoverRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which provided series are all equal (or are not all equal).
type SeriesEqualityRanges struct {
	Input                          []NumericSeries                 `json:"input"`
	EqualityOperator               EqualityOperator                `json:"equalityOperator"`
	Tolerance                      *DoubleConstant                 `json:"tolerance,omitempty"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration `json:"persistenceWindowConfiguration,omitempty"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o SeriesEqualityRanges) MarshalJSON() ([]byte, error) {
	if o.Input == nil {
		o.Input = make([]NumericSeries, 0)
	}
	type _tmpSeriesEqualityRanges SeriesEqualityRanges
	return safejson.Marshal(_tmpSeriesEqualityRanges(o))
}

func (o *SeriesEqualityRanges) UnmarshalJSON(data []byte) error {
	type _tmpSeriesEqualityRanges SeriesEqualityRanges
	var rawSeriesEqualityRanges _tmpSeriesEqualityRanges
	if err := safejson.Unmarshal(data, &rawSeriesEqualityRanges); err != nil {
		return err
	}
	if rawSeriesEqualityRanges.Input == nil {
		rawSeriesEqualityRanges.Input = make([]NumericSeries, 0)
	}
	*o = SeriesEqualityRanges(rawSeriesEqualityRanges)
	return nil
}

func (o SeriesEqualityRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SeriesEqualityRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SeriesSpec struct {
	Rid api.LogicalSeriesRid `json:"rid"`
	// The offset of this series relative to the time scale in which the computation is performed.
	Offset        *api2.Duration `conjure-docs:"The offset of this series relative to the time scale in which the computation is performed." json:"offset,omitempty"`
	TagsToGroupBy []string       `json:"tagsToGroupBy"`
}

func (o SeriesSpec) MarshalJSON() ([]byte, error) {
	if o.TagsToGroupBy == nil {
		o.TagsToGroupBy = make([]string, 0)
	}
	type _tmpSeriesSpec SeriesSpec
	return safejson.Marshal(_tmpSeriesSpec(o))
}

func (o *SeriesSpec) UnmarshalJSON(data []byte) error {
	type _tmpSeriesSpec SeriesSpec
	var rawSeriesSpec _tmpSeriesSpec
	if err := safejson.Unmarshal(data, &rawSeriesSpec); err != nil {
		return err
	}
	if rawSeriesSpec.TagsToGroupBy == nil {
		rawSeriesSpec.TagsToGroupBy = make([]string, 0)
	}
	*o = SeriesSpec(rawSeriesSpec)
	return nil
}

func (o SeriesSpec) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SeriesSpec) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SetNegativeValuesToZero struct{}

func (o SetNegativeValuesToZero) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SetNegativeValuesToZero) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Applies IIR-based signal filtering to input series. Includes low-pass, high-pass, band-pass, and band-stop
filters. Currently supports variable-order bidirectional Butterworth filters, with fixed-size padding based
on SciPy output.
*/
type SignalFilterSeries struct {
	Input NumericSeries `json:"input"`
	// Filter type and cutoff frequencies.
	SignalFilterConfiguration SignalFilterConfiguration `conjure-docs:"Filter type and cutoff frequencies." json:"signalFilterConfiguration"`
	// Order of filter. Must be a positive integer, and is effectively doubled for bidirectional filters.
	Order IntegerConstant `conjure-docs:"Order of filter. Must be a positive integer, and is effectively doubled for bidirectional filters." json:"order"`
	// The sampling frequency of the input series. Used to calculate normalized frequency for cutoff frequencies.
	SamplingFrequency *DoubleConstant `conjure-docs:"The sampling frequency of the input series. Used to calculate normalized frequency for cutoff frequencies." json:"samplingFrequency,omitempty"`
}

func (o SignalFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SignalFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Decimate by spatial trees.
Creates buckets by bisecting on each dimension, creating quadrants for 2d scatter and octants for 3d scatter.
Continues subdividing by prioritizing larger undivided buckets until reaching the max amount of buckets.
*/
type SpatialDecimateStrategy struct{}

func (o SpatialDecimateStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SpatialDecimateStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Outputs a set of ranges where the input series is stable. For each point, the min and max are calculated over
the specified lookback window, including the current point. A point is considered stable if its value does
not deviate from the calculated min and the max by more than the threshold and the total number of points
within the window is at least the specified amount. The threshold can be either fixed values or percentages
of the value. The lookback window must be strictly positive. The minimum points threshold defaults to 2.
*/
type StabilityDetectionRanges struct {
	Input               NumericSeries                `json:"input"`
	WindowConfiguration StabilityWindowConfiguration `json:"windowConfiguration"`
	Threshold           Threshold                    `json:"threshold"`
}

func (o StabilityDetectionRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StabilityDetectionRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type StabilityWindowConfiguration struct {
	/*
	   The minimum number of points within the window to create a stable range. Must be non-negative. If not
	   present, will default to 2.
	*/
	MinPoints *IntegerConstant `conjure-docs:"The minimum number of points within the window to create a stable range. Must be non-negative. If not \npresent, will default to 2." json:"minPoints,omitempty"`
	Duration  DurationConstant `json:"duration"`
}

func (o StabilityWindowConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StabilityWindowConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Produces a list of ranges for which data does not exist for the specified duration or longer. Increases
window size by the specified staleness threshold on both ends to capture edge cases of data not currently
in view.
*/
type StaleRanges struct {
	Input     Series           `json:"input"`
	Threshold DurationConstant `json:"threshold"`
	// The start timestamp of the range. If not specified, staleness will automatically use view range start.
	StartTimestamp *TimestampConstant `conjure-docs:"The start timestamp of the range. If not specified, staleness will automatically use view range start." json:"startTimestamp,omitempty"`
	// Deprecated: No longer used and will be removed
	EndTimestamp *TimestampConstant `json:"endTimestamp,omitempty"`
}

func (o StaleRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StaleRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The standard deviation of points inside the time window.
type StandardDeviation struct{}

func (o StandardDeviation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StandardDeviation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The sum of point values inside the time window.
type Sum struct{}

func (o Sum) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Sum) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For every timestamp specified in the input series, outputs a value that is the sum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
*/
type SumSeries struct {
	Inputs []NumericSeries `json:"inputs"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o SumSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]NumericSeries, 0)
	}
	type _tmpSumSeries SumSeries
	return safejson.Marshal(_tmpSumSeries(o))
}

func (o *SumSeries) UnmarshalJSON(data []byte) error {
	type _tmpSumSeries SumSeries
	var rawSumSeries _tmpSumSeries
	if err := safejson.Unmarshal(data, &rawSumSeries); err != nil {
		return err
	}
	if rawSumSeries.Inputs == nil {
		rawSumSeries.Inputs = make([]NumericSeries, 0)
	}
	*o = SumSeries(rawSumSeries)
	return nil
}

func (o SumSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SumSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SummarizeCartesian struct {
	Input  Cartesian        `json:"input"`
	Bounds *CartesianBounds `json:"bounds,omitempty"`
	/*
	   The maximum number of points to return in the response. If more points are found, a BucketedCartesianPlot
	   will be returned. Maximum is 10,000. Defaults to 2,000 if not specified.
	*/
	MaxPoints *int `conjure-docs:"The maximum number of points to return in the response. If more points are found, a BucketedCartesianPlot\nwill be returned. Maximum is 10,000. Defaults to 2,000 if not specified." json:"maxPoints,omitempty"`
}

func (o SummarizeCartesian) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SummarizeCartesian) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SummarizeCartesian3d struct {
	Input  Cartesian3d        `json:"input"`
	Bounds *Cartesian3dBounds `json:"bounds,omitempty"`
	/*
	   The maximum number of points to return in the response.
	   If more points are found, a BucketedCartesian3dPlot will be returned.
	   Maximum is 10,000. Defaults to 2,000 if not specified.
	*/
	MaxPoints *int `conjure-docs:"The maximum number of points to return in the response.\nIf more points are found, a BucketedCartesian3dPlot will be returned.\nMaximum is 10,000. Defaults to 2,000 if not specified." json:"maxPoints,omitempty"`
	// The strategy to use when summarizing the series. Only spatial decimation is supported.
	SummarizationStrategy *ScatterSummarizationStrategy `conjure-docs:"The strategy to use when summarizing the series. Only spatial decimation is supported." json:"summarizationStrategy,omitempty"`
}

func (o SummarizeCartesian3d) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SummarizeCartesian3d) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SummarizeGeo struct {
	Input           GeoSeries          `json:"input"`
	SummaryStrategy GeoSummaryStrategy `json:"summaryStrategy"`
}

func (o SummarizeGeo) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SummarizeGeo) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SummarizeRanges struct {
	Input RangeSeries `json:"input"`
	/*
	   The maximum number of ranges to return in the response. If more ranges are found, a RangesSummary
	   will be returned. Defaults to 2000 if not specified.
	*/
	MaxRanges *int `conjure-docs:"The maximum number of ranges to return in the response. If more ranges are found, a RangesSummary\nwill be returned. Defaults to 2000 if not specified." json:"maxRanges,omitempty"`
}

func (o SummarizeRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SummarizeRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Summarizes the output of a series node. The output can be a numeric, enum, log, or cartesian series.
Summarization strategy should be specified.
*/
type SummarizeSeries struct {
	Input Series `json:"input"`
	// The output format of the response. Defaults to LEGACY.
	OutputFormat *OutputFormat `conjure-docs:"The output format of the response. Defaults to LEGACY." json:"outputFormat,omitempty"`
	// The fields to output from the summarization. Applies only to Arrow format numeric series.
	NumericOutputFields *[]NumericOutputField `conjure-docs:"The fields to output from the summarization. Applies only to Arrow format numeric series." json:"numericOutputFields,omitempty"`
	/*
	   Resolution of the output series specifying time interval between decimated points.
	   Picoseconds for picosecond-granularity dataset, nanoseconds otherwise.

	   Deprecated: Use summarizationStrategy instead.
	*/
	Resolution *safelong.SafeLong `conjure-docs:"Resolution of the output series specifying time interval between decimated points.\nPicoseconds for picosecond-granularity dataset, nanoseconds otherwise." json:"resolution,omitempty"`
	/*
	   Number of points to generate in the output series.

	   Deprecated: Use summarizationStrategy instead.
	*/
	Buckets *int `conjure-docs:"Number of points to generate in the output series." json:"buckets,omitempty"`
	// The strategy to use when summarizing the series.
	SummarizationStrategy *SummarizationStrategy `conjure-docs:"The strategy to use when summarizing the series." json:"summarizationStrategy,omitempty"`
}

func (o SummarizeSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SummarizeSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A filter on a single tag key and set of values. For an IN operator, the tag key must match at least one of the
values in the set. For a NOT_IN operator, it must not match any of the values in the set.
*/
type TagFilter struct {
	Key      StringConstant    `json:"key"`
	Values   []StringConstant  `json:"values"`
	Operator TagFilterOperator `json:"operator"`
}

func (o TagFilter) MarshalJSON() ([]byte, error) {
	if o.Values == nil {
		o.Values = make([]StringConstant, 0)
	}
	type _tmpTagFilter TagFilter
	return safejson.Marshal(_tmpTagFilter(o))
}

func (o *TagFilter) UnmarshalJSON(data []byte) error {
	type _tmpTagFilter TagFilter
	var rawTagFilter _tmpTagFilter
	if err := safejson.Unmarshal(data, &rawTagFilter); err != nil {
		return err
	}
	if rawTagFilter.Values == nil {
		rawTagFilter.Values = make([]StringConstant, 0)
	}
	*o = TagFilter(rawTagFilter)
	return nil
}

func (o TagFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TagFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which the threshold condition is satisfied.
type ThresholdingRanges struct {
	Input                          NumericSeries                   `json:"input"`
	Threshold                      DoubleConstant                  `json:"threshold"`
	Operator                       ThresholdOperator               `json:"operator"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration `json:"persistenceWindowConfiguration,omitempty"`
}

func (o ThresholdingRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ThresholdingRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimeBucketedGeoPlot struct {
	// The end of the bucket, exclusive.
	Timestamps []api.Timestamp `conjure-docs:"The end of the bucket, exclusive." json:"timestamps"`
	Buckets    []GeoTimeBucket `json:"buckets"`
}

func (o TimeBucketedGeoPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.Buckets == nil {
		o.Buckets = make([]GeoTimeBucket, 0)
	}
	type _tmpTimeBucketedGeoPlot TimeBucketedGeoPlot
	return safejson.Marshal(_tmpTimeBucketedGeoPlot(o))
}

func (o *TimeBucketedGeoPlot) UnmarshalJSON(data []byte) error {
	type _tmpTimeBucketedGeoPlot TimeBucketedGeoPlot
	var rawTimeBucketedGeoPlot _tmpTimeBucketedGeoPlot
	if err := safejson.Unmarshal(data, &rawTimeBucketedGeoPlot); err != nil {
		return err
	}
	if rawTimeBucketedGeoPlot.Timestamps == nil {
		rawTimeBucketedGeoPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawTimeBucketedGeoPlot.Buckets == nil {
		rawTimeBucketedGeoPlot.Buckets = make([]GeoTimeBucket, 0)
	}
	*o = TimeBucketedGeoPlot(rawTimeBucketedGeoPlot)
	return nil
}

func (o TimeBucketedGeoPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeBucketedGeoPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs a new series where each value is the difference between the time of the current and previous points.
type TimeDifferenceSeries struct {
	Input Series `json:"input"`
	// The time unit used to define the output values. Defaults to seconds if not specified.
	TimeUnit *api.TimeUnit `conjure-docs:"The time unit used to define the output values. Defaults to seconds if not specified." json:"timeUnit,omitempty"`
}

func (o TimeDifferenceSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeDifferenceSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Fits a curve to a series vs its timestamps.
type TimeSeriesCurveFit struct {
	/*
	   The series to fit. Timestamps will be used as x values and data as y values. The leftmost (earliest)
	   timestamp will be used as the value of 0, and all other timestamps will be relative to that.
	*/
	Series  NumericSeries        `conjure-docs:"The series to fit. Timestamps will be used as x values and data as y values. The leftmost (earliest)\ntimestamp will be used as the value of 0, and all other timestamps will be relative to that." json:"series"`
	Options TimeSeriesFitOptions `json:"options"`
}

func (o TimeSeriesCurveFit) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeSeriesCurveFit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimeSeriesFitOptions struct {
	// Time unit used for the timestamps to fit against. Defaults to seconds if not specified.
	TimeUnit *api.TimeUnit `conjure-docs:"Time unit used for the timestamps to fit against. Defaults to seconds if not specified." json:"timeUnit,omitempty"`
}

func (o TimeSeriesFitOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeSeriesFitOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimestampAndId struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Id        *uuid.UUID    `json:"id,omitempty"`
}

func (o TimestampAndId) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimestampAndId) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Applies a point-wise transformation to a series. The transformation function is applied to every
individual data point.
*/
type UnaryArithmeticSeries struct {
	Input     NumericSeries            `json:"input"`
	Operation UnaryArithmeticOperation `json:"operation"`
}

func (o UnaryArithmeticSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnaryArithmeticSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UnionRanges struct {
	Inputs []RangeSeries `json:"inputs"`
}

func (o UnionRanges) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]RangeSeries, 0)
	}
	type _tmpUnionRanges UnionRanges
	return safejson.Marshal(_tmpUnionRanges(o))
}

func (o *UnionRanges) UnmarshalJSON(data []byte) error {
	type _tmpUnionRanges UnionRanges
	var rawUnionRanges _tmpUnionRanges
	if err := safejson.Unmarshal(data, &rawUnionRanges); err != nil {
		return err
	}
	if rawUnionRanges.Inputs == nil {
		rawUnionRanges.Inputs = make([]RangeSeries, 0)
	}
	*o = UnionRanges(rawUnionRanges)
	return nil
}

func (o UnionRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnionRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Convert the given series to a different unit.
type UnitConversionSeries struct {
	Input      NumericSeries   `json:"input"`
	OutputUnit api1.UnitSymbol `json:"outputUnit"`
}

func (o UnitConversionSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnitConversionSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// At least one input is missing a unit.
type UnitsMissing struct {
	// Deprecated: Use channels instead.
	SeriesRids []api.LogicalSeriesRid `json:"seriesRids"`
	Channels   []DataSourceAndChannel `json:"channels"`
}

func (o UnitsMissing) MarshalJSON() ([]byte, error) {
	if o.SeriesRids == nil {
		o.SeriesRids = make([]api.LogicalSeriesRid, 0)
	}
	if o.Channels == nil {
		o.Channels = make([]DataSourceAndChannel, 0)
	}
	type _tmpUnitsMissing UnitsMissing
	return safejson.Marshal(_tmpUnitsMissing(o))
}

func (o *UnitsMissing) UnmarshalJSON(data []byte) error {
	type _tmpUnitsMissing UnitsMissing
	var rawUnitsMissing _tmpUnitsMissing
	if err := safejson.Unmarshal(data, &rawUnitsMissing); err != nil {
		return err
	}
	if rawUnitsMissing.SeriesRids == nil {
		rawUnitsMissing.SeriesRids = make([]api.LogicalSeriesRid, 0)
	}
	if rawUnitsMissing.Channels == nil {
		rawUnitsMissing.Channels = make([]DataSourceAndChannel, 0)
	}
	*o = UnitsMissing(rawUnitsMissing)
	return nil
}

func (o UnitsMissing) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnitsMissing) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs a new series where each value is the difference between the values of the current and previous point.
type ValueDifferenceSeries struct {
	Input NumericSeries `json:"input"`
	// Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified.
	NegativeValuesConfiguration *NegativeValueConfiguration `conjure-docs:"Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified." json:"negativeValuesConfiguration,omitempty"`
}

func (o ValueDifferenceSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueDifferenceSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Maps a continuous numeric series to a discrete enum series using the specified value ranges.
type ValueMapSeries struct {
	// The input series to map to an enumerated series
	Input NumericSeries `conjure-docs:"The input series to map to an enumerated series" json:"input"`
	/*
	   The output of the first capturing range will be used. Ranges are start inclusive, end exclusive, must not overlap,
	   and increasing from lowest to highest. Ranges can be open ended to the edge of the next or prior range.
	   The first range can be open ended to negative infinity, and the last range can be open ended to positive infinity.
	*/
	Mapping []RangeMap `conjure-docs:"The output of the first capturing range will be used. Ranges are start inclusive, end exclusive, must not overlap,\nand increasing from lowest to highest. Ranges can be open ended to the edge of the next or prior range.\nThe first range can be open ended to negative infinity, and the last range can be open ended to positive infinity." json:"mapping"`
	// The default value if not captured by any range. If not specified, points will be filtered.
	Default *StringConstant `conjure-docs:"The default value if not captured by any range. If not specified, points will be filtered." json:"default,omitempty"`
}

func (o ValueMapSeries) MarshalJSON() ([]byte, error) {
	if o.Mapping == nil {
		o.Mapping = make([]RangeMap, 0)
	}
	type _tmpValueMapSeries ValueMapSeries
	return safejson.Marshal(_tmpValueMapSeries(o))
}

func (o *ValueMapSeries) UnmarshalJSON(data []byte) error {
	type _tmpValueMapSeries ValueMapSeries
	var rawValueMapSeries _tmpValueMapSeries
	if err := safejson.Unmarshal(data, &rawValueMapSeries); err != nil {
		return err
	}
	if rawValueMapSeries.Mapping == nil {
		rawValueMapSeries.Mapping = make([]RangeMap, 0)
	}
	*o = ValueMapSeries(rawValueMapSeries)
	return nil
}

func (o ValueMapSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueMapSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
