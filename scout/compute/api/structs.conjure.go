// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/units/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
)

// Threshold defined as a real number corresponding the unit of a series.
type AbsoluteThreshold struct {
	Value DoubleConstant `json:"value"`
}

func (o AbsoluteThreshold) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AbsoluteThreshold) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The first point in the output range will be the first point after the condition has been true
for the min duration and min points.
*/
type AfterPersistenceWindow struct{}

func (o AfterPersistenceWindow) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AfterPersistenceWindow) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AllowNegativeValues struct{}

func (o AllowNegativeValues) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AllowNegativeValues) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArrowBucketedEnumPlot struct {
	// The raw binary containing Arrow IPC stream for BucketedEnumPlot
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for BucketedEnumPlot" json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
}

func (o ArrowBucketedEnumPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArrowBucketedEnumPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArrowBucketedNumericPlot struct {
	// The raw binary containing Arrow IPC stream for BucketedNumericPlot
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for BucketedNumericPlot" json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
}

func (o ArrowBucketedNumericPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArrowBucketedNumericPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArrowBucketedStructPlot struct {
	// The raw binary containing Arrow IPC stream for bucketed struct plot
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for bucketed struct plot" json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
}

func (o ArrowBucketedStructPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArrowBucketedStructPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArrowEnumPlot struct {
	// The raw binary containing Arrow IPC stream for EnumPlot
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for EnumPlot" json:"arrowBinary"`
}

func (o ArrowEnumPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArrowEnumPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArrowFullResolutionPlot struct {
	// The raw binary containing Arrow IPC stream for the first n rows of a full resolution plot sorted by timestamp.
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for the first n rows of a full resolution plot sorted by timestamp." json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
}

func (o ArrowFullResolutionPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArrowFullResolutionPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArrowNumericPlot struct {
	// The raw binary containing Arrow IPC stream for NumericPlot
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for NumericPlot" json:"arrowBinary"`
}

func (o ArrowNumericPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArrowNumericPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AssetChannel struct {
	AssetRid StringConstant `json:"assetRid"`
	// Used to disambiguate when multiple data scopes within this asset contain channels with the same name.
	DataScopeName StringConstant `conjure-docs:"Used to disambiguate when multiple data scopes within this asset contain channels with the same name." json:"dataScopeName"`
	Channel       StringConstant `json:"channel"`
	// Deprecated: Use additionalTagFilters
	AdditionalTags map[string]StringConstant `json:"additionalTags"`
	/*
	   Tags to filter the channel by, in addition to tag filters defined for a given Asset data scope. Throws on
	   collisions with tag keys already defined for the given Asset data scope. Only returns points that match
	   both sets of tag filters. For log series, include arg filters here in addition to tag filters.
	*/
	AdditionalTagFilters *TagFilters `conjure-docs:"Tags to filter the channel by, in addition to tag filters defined for a given Asset data scope. Throws on \ncollisions with tag keys already defined for the given Asset data scope. Only returns points that match \nboth sets of tag filters. For log series, include arg filters here in addition to tag filters." json:"additionalTagFilters,omitempty"`
	// Deprecated: Use groupByTags instead. Throws if both tagsToGroupBy and groupByTags are specified.
	TagsToGroupBy []string `json:"tagsToGroupBy"`
	/*
	   Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned
	   with an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified.
	*/
	GroupByTags []StringConstant `conjure-docs:"Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned\nwith an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified." json:"groupByTags"`
}

func (o AssetChannel) MarshalJSON() ([]byte, error) {
	if o.AdditionalTags == nil {
		o.AdditionalTags = make(map[string]StringConstant, 0)
	}
	if o.TagsToGroupBy == nil {
		o.TagsToGroupBy = make([]string, 0)
	}
	if o.GroupByTags == nil {
		o.GroupByTags = make([]StringConstant, 0)
	}
	type _tmpAssetChannel AssetChannel
	return safejson.Marshal(_tmpAssetChannel(o))
}

func (o *AssetChannel) UnmarshalJSON(data []byte) error {
	type _tmpAssetChannel AssetChannel
	var rawAssetChannel _tmpAssetChannel
	if err := safejson.Unmarshal(data, &rawAssetChannel); err != nil {
		return err
	}
	if rawAssetChannel.AdditionalTags == nil {
		rawAssetChannel.AdditionalTags = make(map[string]StringConstant, 0)
	}
	if rawAssetChannel.TagsToGroupBy == nil {
		rawAssetChannel.TagsToGroupBy = make([]string, 0)
	}
	if rawAssetChannel.GroupByTags == nil {
		rawAssetChannel.GroupByTags = make([]StringConstant, 0)
	}
	*o = AssetChannel(rawAssetChannel)
	return nil
}

func (o AssetChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AssetChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A average that gives the same weight to each observation inside the time window
type Average struct{}

func (o Average) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Average) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BandPassConfiguration struct {
	LowPassbandFrequency  DoubleConstant `json:"lowPassbandFrequency"`
	HighPassbandFrequency DoubleConstant `json:"highPassbandFrequency"`
}

func (o BandPassConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BandPassConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BandStopConfiguration struct {
	LowStopbandFrequency  DoubleConstant `json:"lowStopbandFrequency"`
	HighStopbandFrequency DoubleConstant `json:"highStopbandFrequency"`
}

func (o BandStopConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BandStopConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchComputeUnitResult struct {
	Results []ComputeUnitResult `json:"results"`
}

func (o BatchComputeUnitResult) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ComputeUnitResult, 0)
	}
	type _tmpBatchComputeUnitResult BatchComputeUnitResult
	return safejson.Marshal(_tmpBatchComputeUnitResult(o))
}

func (o *BatchComputeUnitResult) UnmarshalJSON(data []byte) error {
	type _tmpBatchComputeUnitResult BatchComputeUnitResult
	var rawBatchComputeUnitResult _tmpBatchComputeUnitResult
	if err := safejson.Unmarshal(data, &rawBatchComputeUnitResult); err != nil {
		return err
	}
	if rawBatchComputeUnitResult.Results == nil {
		rawBatchComputeUnitResult.Results = make([]ComputeUnitResult, 0)
	}
	*o = BatchComputeUnitResult(rawBatchComputeUnitResult)
	return nil
}

func (o BatchComputeUnitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchComputeUnitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchComputeWithUnitsResponse struct {
	Results []ComputeWithUnitsResult `json:"results"`
}

func (o BatchComputeWithUnitsResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ComputeWithUnitsResult, 0)
	}
	type _tmpBatchComputeWithUnitsResponse BatchComputeWithUnitsResponse
	return safejson.Marshal(_tmpBatchComputeWithUnitsResponse(o))
}

func (o *BatchComputeWithUnitsResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchComputeWithUnitsResponse BatchComputeWithUnitsResponse
	var rawBatchComputeWithUnitsResponse _tmpBatchComputeWithUnitsResponse
	if err := safejson.Unmarshal(data, &rawBatchComputeWithUnitsResponse); err != nil {
		return err
	}
	if rawBatchComputeWithUnitsResponse.Results == nil {
		rawBatchComputeWithUnitsResponse.Results = make([]ComputeWithUnitsResult, 0)
	}
	*o = BatchComputeWithUnitsResponse(rawBatchComputeWithUnitsResponse)
	return nil
}

func (o BatchComputeWithUnitsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchComputeWithUnitsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BitAndFunction struct {
	Operand safelong.SafeLong `json:"operand"`
}

func (o BitAndFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitAndFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BitOrFunction struct {
	Operand safelong.SafeLong `json:"operand"`
}

func (o BitOrFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitOrFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Shifts the bits in each value left according to the given operand.
type BitShiftLeftFunction struct {
	Operand int `json:"operand"`
}

func (o BitShiftLeftFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitShiftLeftFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Right shifts the bits in each value right according to the given operand.
type BitShiftRightFunction struct {
	Operand int `json:"operand"`
}

func (o BitShiftRightFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitShiftRightFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Returns the bit at the specified index, where the right-most bit has index 0.
type BitTestFunction struct {
	Index int `json:"index"`
}

func (o BitTestFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitTestFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BitXorFunction struct {
	Operand safelong.SafeLong `json:"operand"`
}

func (o BitXorFunction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitXorFunction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BucketedCartesian3dPlot struct {
	Buckets []Cartesian3dBucket `json:"buckets"`
}

func (o BucketedCartesian3dPlot) MarshalJSON() ([]byte, error) {
	if o.Buckets == nil {
		o.Buckets = make([]Cartesian3dBucket, 0)
	}
	type _tmpBucketedCartesian3dPlot BucketedCartesian3dPlot
	return safejson.Marshal(_tmpBucketedCartesian3dPlot(o))
}

func (o *BucketedCartesian3dPlot) UnmarshalJSON(data []byte) error {
	type _tmpBucketedCartesian3dPlot BucketedCartesian3dPlot
	var rawBucketedCartesian3dPlot _tmpBucketedCartesian3dPlot
	if err := safejson.Unmarshal(data, &rawBucketedCartesian3dPlot); err != nil {
		return err
	}
	if rawBucketedCartesian3dPlot.Buckets == nil {
		rawBucketedCartesian3dPlot.Buckets = make([]Cartesian3dBucket, 0)
	}
	*o = BucketedCartesian3dPlot(rawBucketedCartesian3dPlot)
	return nil
}

func (o BucketedCartesian3dPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedCartesian3dPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BucketedCartesianPlot struct {
	Buckets []CartesianBucket `json:"buckets"`
}

func (o BucketedCartesianPlot) MarshalJSON() ([]byte, error) {
	if o.Buckets == nil {
		o.Buckets = make([]CartesianBucket, 0)
	}
	type _tmpBucketedCartesianPlot BucketedCartesianPlot
	return safejson.Marshal(_tmpBucketedCartesianPlot(o))
}

func (o *BucketedCartesianPlot) UnmarshalJSON(data []byte) error {
	type _tmpBucketedCartesianPlot BucketedCartesianPlot
	var rawBucketedCartesianPlot _tmpBucketedCartesianPlot
	if err := safejson.Unmarshal(data, &rawBucketedCartesianPlot); err != nil {
		return err
	}
	if rawBucketedCartesianPlot.Buckets == nil {
		rawBucketedCartesianPlot.Buckets = make([]CartesianBucket, 0)
	}
	*o = BucketedCartesianPlot(rawBucketedCartesianPlot)
	return nil
}

func (o BucketedCartesianPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedCartesianPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The array is flattened out into a an arrow stream of bucketed primitive results, with an extra column to
indicate the index of the array that the bucket corresponds to.
*/
type BucketedEnumArrayPlot struct {
	// The raw binary containing Arrow IPC stream for a bucketed N-dimensional enum array plot.
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for a bucketed N-dimensional enum array plot." json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
}

func (o BucketedEnumArrayPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedEnumArrayPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BucketedEnumPlot struct {
	// The end of the bucket, exclusive.
	Timestamps []api.Timestamp `conjure-docs:"The end of the bucket, exclusive." json:"timestamps"`
	Buckets    []EnumBucket    `json:"buckets"`
	Categories []string        `json:"categories"`
}

func (o BucketedEnumPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.Buckets == nil {
		o.Buckets = make([]EnumBucket, 0)
	}
	if o.Categories == nil {
		o.Categories = make([]string, 0)
	}
	type _tmpBucketedEnumPlot BucketedEnumPlot
	return safejson.Marshal(_tmpBucketedEnumPlot(o))
}

func (o *BucketedEnumPlot) UnmarshalJSON(data []byte) error {
	type _tmpBucketedEnumPlot BucketedEnumPlot
	var rawBucketedEnumPlot _tmpBucketedEnumPlot
	if err := safejson.Unmarshal(data, &rawBucketedEnumPlot); err != nil {
		return err
	}
	if rawBucketedEnumPlot.Timestamps == nil {
		rawBucketedEnumPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawBucketedEnumPlot.Buckets == nil {
		rawBucketedEnumPlot.Buckets = make([]EnumBucket, 0)
	}
	if rawBucketedEnumPlot.Categories == nil {
		rawBucketedEnumPlot.Categories = make([]string, 0)
	}
	*o = BucketedEnumPlot(rawBucketedEnumPlot)
	return nil
}

func (o BucketedEnumPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedEnumPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The array is flattened out into a an arrow stream of bucketed primitive results, with an extra column to
indicate the index of the array that the bucket corresponds to.
*/
type BucketedNumericArrayPlot struct {
	// The raw binary containing Arrow IPC stream for a bucketed N-dimensional numeric array plot.
	ArrowBinary []byte `conjure-docs:"The raw binary containing Arrow IPC stream for a bucketed N-dimensional numeric array plot." json:"arrowBinary"`
	/*
	   This field specifies the tags that the final output is grouped by. When you combine multiple channels,
	   this list represents the superset of all group by keys used across every individual channel.
	*/
	GroupByKeys *[]string `conjure-docs:"This field specifies the tags that the final output is grouped by. When you combine multiple channels, \nthis list represents the superset of all group by keys used across every individual channel." json:"groupByKeys,omitempty"`
}

func (o BucketedNumericArrayPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedNumericArrayPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BucketedNumericPlot struct {
	// The end of the bucket, exclusive.
	Timestamps []api.Timestamp `conjure-docs:"The end of the bucket, exclusive." json:"timestamps"`
	Buckets    []NumericBucket `json:"buckets"`
}

func (o BucketedNumericPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.Buckets == nil {
		o.Buckets = make([]NumericBucket, 0)
	}
	type _tmpBucketedNumericPlot BucketedNumericPlot
	return safejson.Marshal(_tmpBucketedNumericPlot(o))
}

func (o *BucketedNumericPlot) UnmarshalJSON(data []byte) error {
	type _tmpBucketedNumericPlot BucketedNumericPlot
	var rawBucketedNumericPlot _tmpBucketedNumericPlot
	if err := safejson.Unmarshal(data, &rawBucketedNumericPlot); err != nil {
		return err
	}
	if rawBucketedNumericPlot.Timestamps == nil {
		rawBucketedNumericPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawBucketedNumericPlot.Buckets == nil {
		rawBucketedNumericPlot.Buckets = make([]NumericBucket, 0)
	}
	*o = BucketedNumericPlot(rawBucketedNumericPlot)
	return nil
}

func (o BucketedNumericPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BucketedNumericPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Min/max bounds of an XYZ Cartesian plot, inclusive.
type Cartesian3dBounds struct {
	MinX DoubleConstant `json:"minX"`
	MaxX DoubleConstant `json:"maxX"`
	MinY DoubleConstant `json:"minY"`
	MaxY DoubleConstant `json:"maxY"`
	MinZ DoubleConstant `json:"minZ"`
	MaxZ DoubleConstant `json:"maxZ"`
}

func (o Cartesian3dBounds) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Cartesian3dBounds) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Cartesian3dBucket struct {
	// Deprecated: Switching to point-based min/maxes
	MinX *float64 `json:"minX,omitempty"`
	// Deprecated: Switching to point-based min/maxes
	MaxX  *float64 `json:"maxX,omitempty"`
	MeanX float64  `json:"meanX"`
	// Deprecated: Switching to point-based min/maxes
	MinY *float64 `json:"minY,omitempty"`
	// Deprecated: Switching to point-based min/maxes
	MaxY  *float64 `json:"maxY,omitempty"`
	MeanY float64  `json:"meanY"`
	// Deprecated: Switching to point-based min/maxes
	MinZ *float64 `json:"minZ,omitempty"`
	// Deprecated: Switching to point-based min/maxes
	MaxZ         *float64          `json:"maxZ,omitempty"`
	MeanZ        float64           `json:"meanZ"`
	MinXPoint    Point3d           `json:"minXPoint"`
	MaxXPoint    Point3d           `json:"maxXPoint"`
	MinYPoint    Point3d           `json:"minYPoint"`
	MaxYPoint    Point3d           `json:"maxYPoint"`
	MinZPoint    Point3d           `json:"minZPoint"`
	MaxZPoint    Point3d           `json:"maxZPoint"`
	MinTimestamp api.Timestamp     `json:"minTimestamp"`
	MaxTimestamp api.Timestamp     `json:"maxTimestamp"`
	Count        safelong.SafeLong `json:"count"`
}

func (o Cartesian3dBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Cartesian3dBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Cartesian3dUnitResult struct {
	X UnitResult `json:"x"`
	Y UnitResult `json:"y"`
	Z UnitResult `json:"z"`
}

func (o Cartesian3dUnitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Cartesian3dUnitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Min/max bounds of an XY Cartesian plot, inclusive.
type CartesianBounds struct {
	MinX DoubleConstant `json:"minX"`
	MaxX DoubleConstant `json:"maxX"`
	MinY DoubleConstant `json:"minY"`
	MaxY DoubleConstant `json:"maxY"`
}

func (o CartesianBounds) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CartesianBounds) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CartesianBucket struct {
	MinX         float64           `json:"minX"`
	MaxX         float64           `json:"maxX"`
	MinY         float64           `json:"minY"`
	MaxY         float64           `json:"maxY"`
	MinTimestamp api.Timestamp     `json:"minTimestamp"`
	MaxTimestamp api.Timestamp     `json:"maxTimestamp"`
	Count        safelong.SafeLong `json:"count"`
}

func (o CartesianBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CartesianBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CartesianPlot struct {
	Timestamps []api.Timestamp `json:"timestamps"`
	XValues    []float64       `json:"xValues"`
	YValues    []float64       `json:"yValues"`
}

func (o CartesianPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.XValues == nil {
		o.XValues = make([]float64, 0)
	}
	if o.YValues == nil {
		o.YValues = make([]float64, 0)
	}
	type _tmpCartesianPlot CartesianPlot
	return safejson.Marshal(_tmpCartesianPlot(o))
}

func (o *CartesianPlot) UnmarshalJSON(data []byte) error {
	type _tmpCartesianPlot CartesianPlot
	var rawCartesianPlot _tmpCartesianPlot
	if err := safejson.Unmarshal(data, &rawCartesianPlot); err != nil {
		return err
	}
	if rawCartesianPlot.Timestamps == nil {
		rawCartesianPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawCartesianPlot.XValues == nil {
		rawCartesianPlot.XValues = make([]float64, 0)
	}
	if rawCartesianPlot.YValues == nil {
		rawCartesianPlot.YValues = make([]float64, 0)
	}
	*o = CartesianPlot(rawCartesianPlot)
	return nil
}

func (o CartesianPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CartesianPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CartesianUnitResult struct {
	X UnitResult `json:"x"`
	Y UnitResult `json:"y"`
}

func (o CartesianUnitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CartesianUnitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CompactEnumPoint struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Value     int           `json:"value"`
}

func (o CompactEnumPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CompactEnumPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeWithUnitsResponse struct {
	ComputeResult ComputeNodeResponse `json:"computeResult"`
	ComputeUnit   ComputeUnitResult   `json:"computeUnit"`
}

func (o ComputeWithUnitsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeWithUnitsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeWithUnitsResult struct {
	ComputeResult ComputeNodeResult `json:"computeResult"`
	UnitResult    ComputeUnitResult `json:"unitResult"`
}

func (o ComputeWithUnitsResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeWithUnitsResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The number of points inside the time window.
type Count struct{}

func (o Count) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Count) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CurveFitOptions struct {
	StartTime TimestampConstant `json:"startTime"`
	EndTime   TimestampConstant `json:"endTime"`
}

func (o CurveFitOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CurveFitOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CurveFitResult struct {
	/*
	   R^2 (coefficient of determination) for the fit curve, a normalized measure of how well the curve fits the data.
	   Usually ranges from 0 to 1, with higher indicating better fit (points closer to fit line).
	*/
	R2 float64 `conjure-docs:"R^2 (coefficient of determination) for the fit curve, a normalized measure of how well the curve fits the data.\nUsually ranges from 0 to 1, with higher indicating better fit (points closer to fit line)." json:"r2"`
	// Description of the fit curve.
	CurveResultDetails CurveResultDetails `conjure-docs:"Description of the fit curve." json:"curveResultDetails"`
}

func (o CurveFitResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CurveFitResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataSourceAndChannel struct {
	DataSourceRid rids.DataSourceRid `json:"dataSourceRid"`
	Channel       string             `json:"channel"`
}

func (o DataSourceAndChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataSourceAndChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataSourceChannel struct {
	DataSourceRid StringConstant `json:"dataSourceRid"`
	Channel       StringConstant `json:"channel"`
	// Deprecated: Use tagFilters
	Tags map[string]StringConstant `json:"tags"`
	/*
	   Tags to filter the channel by. Only returns points from the channel where tag values match the provided
	   expression. For log series, include arg filters here in addition to tag filters.
	*/
	TagFilters *TagFilters `conjure-docs:"Tags to filter the channel by. Only returns points from the channel where tag values match the provided\nexpression. For log series, include arg filters here in addition to tag filters." json:"tagFilters,omitempty"`
	// Deprecated: Use groupByTags instead. Throws if both tagsToGroupBy and groupByTags are specified.
	TagsToGroupBy []string `json:"tagsToGroupBy"`
	/*
	   Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned
	   with an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified.
	*/
	GroupByTags []StringConstant `conjure-docs:"Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned\nwith an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified." json:"groupByTags"`
}

func (o DataSourceChannel) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make(map[string]StringConstant, 0)
	}
	if o.TagsToGroupBy == nil {
		o.TagsToGroupBy = make([]string, 0)
	}
	if o.GroupByTags == nil {
		o.GroupByTags = make([]StringConstant, 0)
	}
	type _tmpDataSourceChannel DataSourceChannel
	return safejson.Marshal(_tmpDataSourceChannel(o))
}

func (o *DataSourceChannel) UnmarshalJSON(data []byte) error {
	type _tmpDataSourceChannel DataSourceChannel
	var rawDataSourceChannel _tmpDataSourceChannel
	if err := safejson.Unmarshal(data, &rawDataSourceChannel); err != nil {
		return err
	}
	if rawDataSourceChannel.Tags == nil {
		rawDataSourceChannel.Tags = make(map[string]StringConstant, 0)
	}
	if rawDataSourceChannel.TagsToGroupBy == nil {
		rawDataSourceChannel.TagsToGroupBy = make([]string, 0)
	}
	if rawDataSourceChannel.GroupByTags == nil {
		rawDataSourceChannel.GroupByTags = make([]StringConstant, 0)
	}
	*o = DataSourceChannel(rawDataSourceChannel)
	return nil
}

func (o DataSourceChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataSourceChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DecimateWithBuckets struct {
	// Number of points to generate in the output series.
	Buckets int `conjure-docs:"Number of points to generate in the output series." json:"buckets"`
}

func (o DecimateWithBuckets) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DecimateWithBuckets) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DecimateWithResolution struct {
	/*
	   Resolution of the output series specifying time interval between decimated points.
	   Picoseconds for picosecond-granularity dataset, nanoseconds otherwise.
	*/
	Resolution safelong.SafeLong `conjure-docs:"Resolution of the output series specifying time interval between decimated points.\nPicoseconds for picosecond-granularity dataset, nanoseconds otherwise." json:"resolution"`
}

func (o DecimateWithResolution) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DecimateWithResolution) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumBucket struct {
	// The map of values within the bucket to their frequency.
	Histogram  map[int]safelong.SafeLong `conjure-docs:"The map of values within the bucket to their frequency." json:"histogram"`
	FirstPoint CompactEnumPoint          `json:"firstPoint"`
	// Will be empty if the bucket only has a single point.
	LastPoint *CompactEnumPoint `conjure-docs:"Will be empty if the bucket only has a single point." json:"lastPoint,omitempty"`
}

func (o EnumBucket) MarshalJSON() ([]byte, error) {
	if o.Histogram == nil {
		o.Histogram = make(map[int]safelong.SafeLong, 0)
	}
	type _tmpEnumBucket EnumBucket
	return safejson.Marshal(_tmpEnumBucket(o))
}

func (o *EnumBucket) UnmarshalJSON(data []byte) error {
	type _tmpEnumBucket EnumBucket
	var rawEnumBucket _tmpEnumBucket
	if err := safejson.Unmarshal(data, &rawEnumBucket); err != nil {
		return err
	}
	if rawEnumBucket.Histogram == nil {
		rawEnumBucket.Histogram = make(map[int]safelong.SafeLong, 0)
	}
	*o = EnumBucket(rawEnumBucket)
	return nil
}

func (o EnumBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Fills all empty resample intervals with a single constant value.

If a resampled time interval (bucket) contains no data points from the input, it will
be assigned the specified 'constant' as a default value. This applies to gaps at the start of the
series, between data points, and at the end.
*/
type EnumConstantResampleInterpolationConfiguration struct {
	Constant StringConstant `json:"constant"`
}

func (o EnumConstantResampleInterpolationConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumConstantResampleInterpolationConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A bucket in an enum histogram representing all the counts
for a specific enumerated value, across all input series.
*/
type EnumHistogramBucket struct {
	// The value of the enum as a string
	Value           string                                 `conjure-docs:"The value of the enum as a string" json:"value"`
	CountsByChannel map[VariableName]HistogramChannelCount `json:"countsByChannel"`
}

func (o EnumHistogramBucket) MarshalJSON() ([]byte, error) {
	if o.CountsByChannel == nil {
		o.CountsByChannel = make(map[VariableName]HistogramChannelCount, 0)
	}
	type _tmpEnumHistogramBucket EnumHistogramBucket
	return safejson.Marshal(_tmpEnumHistogramBucket(o))
}

func (o *EnumHistogramBucket) UnmarshalJSON(data []byte) error {
	type _tmpEnumHistogramBucket EnumHistogramBucket
	var rawEnumHistogramBucket _tmpEnumHistogramBucket
	if err := safejson.Unmarshal(data, &rawEnumHistogramBucket); err != nil {
		return err
	}
	if rawEnumHistogramBucket.CountsByChannel == nil {
		rawEnumHistogramBucket.CountsByChannel = make(map[VariableName]HistogramChannelCount, 0)
	}
	*o = EnumHistogramBucket(rawEnumHistogramBucket)
	return nil
}

func (o EnumHistogramBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumHistogramBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumHistogramPlot struct {
	Buckets []EnumHistogramBucket `json:"buckets"`
}

func (o EnumHistogramPlot) MarshalJSON() ([]byte, error) {
	if o.Buckets == nil {
		o.Buckets = make([]EnumHistogramBucket, 0)
	}
	type _tmpEnumHistogramPlot EnumHistogramPlot
	return safejson.Marshal(_tmpEnumHistogramPlot(o))
}

func (o *EnumHistogramPlot) UnmarshalJSON(data []byte) error {
	type _tmpEnumHistogramPlot EnumHistogramPlot
	var rawEnumHistogramPlot _tmpEnumHistogramPlot
	if err := safejson.Unmarshal(data, &rawEnumHistogramPlot); err != nil {
		return err
	}
	if rawEnumHistogramPlot.Buckets == nil {
		rawEnumHistogramPlot.Buckets = make([]EnumHistogramBucket, 0)
	}
	*o = EnumHistogramPlot(rawEnumHistogramPlot)
	return nil
}

func (o EnumHistogramPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumHistogramPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumPlot struct {
	Timestamps []api.Timestamp `json:"timestamps"`
	Values     []int           `json:"values"`
	Categories []string        `json:"categories"`
}

func (o EnumPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.Values == nil {
		o.Values = make([]int, 0)
	}
	if o.Categories == nil {
		o.Categories = make([]string, 0)
	}
	type _tmpEnumPlot EnumPlot
	return safejson.Marshal(_tmpEnumPlot(o))
}

func (o *EnumPlot) UnmarshalJSON(data []byte) error {
	type _tmpEnumPlot EnumPlot
	var rawEnumPlot _tmpEnumPlot
	if err := safejson.Unmarshal(data, &rawEnumPlot); err != nil {
		return err
	}
	if rawEnumPlot.Timestamps == nil {
		rawEnumPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawEnumPlot.Values == nil {
		rawEnumPlot.Values = make([]int, 0)
	}
	if rawEnumPlot.Categories == nil {
		rawEnumPlot.Categories = make([]string, 0)
	}
	*o = EnumPlot(rawEnumPlot)
	return nil
}

func (o EnumPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumPoint struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Value     string        `json:"value"`
}

func (o EnumPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ErrorResult struct {
	ErrorType ErrorType `json:"errorType"`
	Code      ErrorCode `json:"code"`
}

func (o ErrorResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ErrorResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExcludeNegativeValues struct{}

func (o ExcludeNegativeValues) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExcludeNegativeValues) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExponentialCurve struct{}

func (o ExponentialCurve) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExponentialCurve) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// y = a * e^(b * x)
type ExponentialResultDetails struct {
	A float64 `json:"a"`
	B float64 `json:"b"`
}

func (o ExponentialResultDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExponentialResultDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The first point in the output range will be the first point where the condition evaluates to true.
type FirstPointMatchingCondition struct{}

func (o FirstPointMatchingCondition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FirstPointMatchingCondition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Forward fill interpolation for resampling. Rounds the earliest and latest timestamp up to the nearest interval
multiple and generates timestamps at the given interval between the new earliest and latest timestamps.
For every timestamp in the resampled timestamps, takes the last known value before the timestamp as the value.
*/
type ForwardFillResampleInterpolationConfiguration struct{}

func (o ForwardFillResampleInterpolationConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ForwardFillResampleInterpolationConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FrequencyDomainPlot struct {
	Frequencies []float64 `json:"frequencies"`
	Amplitudes  []float64 `json:"amplitudes"`
}

func (o FrequencyDomainPlot) MarshalJSON() ([]byte, error) {
	if o.Frequencies == nil {
		o.Frequencies = make([]float64, 0)
	}
	if o.Amplitudes == nil {
		o.Amplitudes = make([]float64, 0)
	}
	type _tmpFrequencyDomainPlot FrequencyDomainPlot
	return safejson.Marshal(_tmpFrequencyDomainPlot(o))
}

func (o *FrequencyDomainPlot) UnmarshalJSON(data []byte) error {
	type _tmpFrequencyDomainPlot FrequencyDomainPlot
	var rawFrequencyDomainPlot _tmpFrequencyDomainPlot
	if err := safejson.Unmarshal(data, &rawFrequencyDomainPlot); err != nil {
		return err
	}
	if rawFrequencyDomainPlot.Frequencies == nil {
		rawFrequencyDomainPlot.Frequencies = make([]float64, 0)
	}
	if rawFrequencyDomainPlot.Amplitudes == nil {
		rawFrequencyDomainPlot.Amplitudes = make([]float64, 0)
	}
	*o = FrequencyDomainPlot(rawFrequencyDomainPlot)
	return nil
}

func (o FrequencyDomainPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FrequencyDomainPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FrequencyDomainPlotComplex struct {
	Frequencies []float64 `json:"frequencies"`
	Real        []float64 `json:"real"`
	Imaginary   []float64 `json:"imaginary"`
}

func (o FrequencyDomainPlotComplex) MarshalJSON() ([]byte, error) {
	if o.Frequencies == nil {
		o.Frequencies = make([]float64, 0)
	}
	if o.Real == nil {
		o.Real = make([]float64, 0)
	}
	if o.Imaginary == nil {
		o.Imaginary = make([]float64, 0)
	}
	type _tmpFrequencyDomainPlotComplex FrequencyDomainPlotComplex
	return safejson.Marshal(_tmpFrequencyDomainPlotComplex(o))
}

func (o *FrequencyDomainPlotComplex) UnmarshalJSON(data []byte) error {
	type _tmpFrequencyDomainPlotComplex FrequencyDomainPlotComplex
	var rawFrequencyDomainPlotComplex _tmpFrequencyDomainPlotComplex
	if err := safejson.Unmarshal(data, &rawFrequencyDomainPlotComplex); err != nil {
		return err
	}
	if rawFrequencyDomainPlotComplex.Frequencies == nil {
		rawFrequencyDomainPlotComplex.Frequencies = make([]float64, 0)
	}
	if rawFrequencyDomainPlotComplex.Real == nil {
		rawFrequencyDomainPlotComplex.Real = make([]float64, 0)
	}
	if rawFrequencyDomainPlotComplex.Imaginary == nil {
		rawFrequencyDomainPlotComplex.Imaginary = make([]float64, 0)
	}
	*o = FrequencyDomainPlotComplex(rawFrequencyDomainPlotComplex)
	return nil
}

func (o FrequencyDomainPlotComplex) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FrequencyDomainPlotComplex) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FrequencyDomainPlotMagnitudeAndPhase struct {
	Frequencies []float64 `json:"frequencies"`
	Magnitudes  []float64 `json:"magnitudes"`
	Phases      []float64 `json:"phases"`
}

func (o FrequencyDomainPlotMagnitudeAndPhase) MarshalJSON() ([]byte, error) {
	if o.Frequencies == nil {
		o.Frequencies = make([]float64, 0)
	}
	if o.Magnitudes == nil {
		o.Magnitudes = make([]float64, 0)
	}
	if o.Phases == nil {
		o.Phases = make([]float64, 0)
	}
	type _tmpFrequencyDomainPlotMagnitudeAndPhase FrequencyDomainPlotMagnitudeAndPhase
	return safejson.Marshal(_tmpFrequencyDomainPlotMagnitudeAndPhase(o))
}

func (o *FrequencyDomainPlotMagnitudeAndPhase) UnmarshalJSON(data []byte) error {
	type _tmpFrequencyDomainPlotMagnitudeAndPhase FrequencyDomainPlotMagnitudeAndPhase
	var rawFrequencyDomainPlotMagnitudeAndPhase _tmpFrequencyDomainPlotMagnitudeAndPhase
	if err := safejson.Unmarshal(data, &rawFrequencyDomainPlotMagnitudeAndPhase); err != nil {
		return err
	}
	if rawFrequencyDomainPlotMagnitudeAndPhase.Frequencies == nil {
		rawFrequencyDomainPlotMagnitudeAndPhase.Frequencies = make([]float64, 0)
	}
	if rawFrequencyDomainPlotMagnitudeAndPhase.Magnitudes == nil {
		rawFrequencyDomainPlotMagnitudeAndPhase.Magnitudes = make([]float64, 0)
	}
	if rawFrequencyDomainPlotMagnitudeAndPhase.Phases == nil {
		rawFrequencyDomainPlotMagnitudeAndPhase.Phases = make([]float64, 0)
	}
	*o = FrequencyDomainPlotMagnitudeAndPhase(rawFrequencyDomainPlotMagnitudeAndPhase)
	return nil
}

func (o FrequencyDomainPlotMagnitudeAndPhase) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FrequencyDomainPlotMagnitudeAndPhase) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GroupedComputeNodeResponse struct {
	Grouping Grouping            `json:"grouping"`
	Response ComputeNodeResponse `json:"response"`
}

func (o GroupedComputeNodeResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GroupedComputeNodeResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Contains a `ComputeNodeResponse` for each applicable grouping along with metadata describing the grouping.
All the contained `ComputeNodeResponse`s are guaranteed to be of the same type.
*/
type GroupedComputeNodeResponses struct {
	Responses []GroupedComputeNodeResponse `json:"responses"`
}

func (o GroupedComputeNodeResponses) MarshalJSON() ([]byte, error) {
	if o.Responses == nil {
		o.Responses = make([]GroupedComputeNodeResponse, 0)
	}
	type _tmpGroupedComputeNodeResponses GroupedComputeNodeResponses
	return safejson.Marshal(_tmpGroupedComputeNodeResponses(o))
}

func (o *GroupedComputeNodeResponses) UnmarshalJSON(data []byte) error {
	type _tmpGroupedComputeNodeResponses GroupedComputeNodeResponses
	var rawGroupedComputeNodeResponses _tmpGroupedComputeNodeResponses
	if err := safejson.Unmarshal(data, &rawGroupedComputeNodeResponses); err != nil {
		return err
	}
	if rawGroupedComputeNodeResponses.Responses == nil {
		rawGroupedComputeNodeResponses.Responses = make([]GroupedComputeNodeResponse, 0)
	}
	*o = GroupedComputeNodeResponses(rawGroupedComputeNodeResponses)
	return nil
}

func (o GroupedComputeNodeResponses) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GroupedComputeNodeResponses) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HighPassConfiguration struct {
	CutoffFrequency DoubleConstant `json:"cutoffFrequency"`
}

func (o HighPassConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HighPassConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The count of the value in the bucket for the specific channel.
type HistogramChannelCount struct {
	Count safelong.SafeLong `json:"count"`
}

func (o HistogramChannelCount) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramChannelCount) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Attempted an incompatible operation of units.
type IncompatibleUnitOperation struct {
	Operation UnitOperation     `json:"operation"`
	Units     []api1.UnitSymbol `json:"units"`
}

func (o IncompatibleUnitOperation) MarshalJSON() ([]byte, error) {
	if o.Units == nil {
		o.Units = make([]api1.UnitSymbol, 0)
	}
	type _tmpIncompatibleUnitOperation IncompatibleUnitOperation
	return safejson.Marshal(_tmpIncompatibleUnitOperation(o))
}

func (o *IncompatibleUnitOperation) UnmarshalJSON(data []byte) error {
	type _tmpIncompatibleUnitOperation IncompatibleUnitOperation
	var rawIncompatibleUnitOperation _tmpIncompatibleUnitOperation
	if err := safejson.Unmarshal(data, &rawIncompatibleUnitOperation); err != nil {
		return err
	}
	if rawIncompatibleUnitOperation.Units == nil {
		rawIncompatibleUnitOperation.Units = make([]api1.UnitSymbol, 0)
	}
	*o = IncompatibleUnitOperation(rawIncompatibleUnitOperation)
	return nil
}

func (o IncompatibleUnitOperation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IncompatibleUnitOperation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LatLongPoint struct {
	Latitude  float64 `json:"latitude"`
	Longitude float64 `json:"longitude"`
}

func (o LatLongPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LatLongPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A literal range of values.
type LiteralRange struct {
	StartTimestamp *TimestampConstant `json:"startTimestamp,omitempty"`
	EndTimestamp   *TimestampConstant `json:"endTimestamp,omitempty"`
}

func (o LiteralRange) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LiteralRange) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A list of literal ranges.
type LiteralRanges struct {
	LiteralRanges []LiteralRange `json:"literalRanges"`
}

func (o LiteralRanges) MarshalJSON() ([]byte, error) {
	if o.LiteralRanges == nil {
		o.LiteralRanges = make([]LiteralRange, 0)
	}
	type _tmpLiteralRanges LiteralRanges
	return safejson.Marshal(_tmpLiteralRanges(o))
}

func (o *LiteralRanges) UnmarshalJSON(data []byte) error {
	type _tmpLiteralRanges LiteralRanges
	var rawLiteralRanges _tmpLiteralRanges
	if err := safejson.Unmarshal(data, &rawLiteralRanges); err != nil {
		return err
	}
	if rawLiteralRanges.LiteralRanges == nil {
		rawLiteralRanges.LiteralRanges = make([]LiteralRange, 0)
	}
	*o = LiteralRanges(rawLiteralRanges)
	return nil
}

func (o LiteralRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LiteralRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Filters points such that the log message in each point contains an exact case-insensitive match of the
provided token.
*/
type LogExactMatchCaseInsensitiveFilter struct {
	Token string `json:"token"`
}

func (o LogExactMatchCaseInsensitiveFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogExactMatchCaseInsensitiveFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogPoint struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Value     LogValue      `json:"value"`
}

func (o LogPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Filters points such that the log message in each point matches the given re2 regular expression.
Regular expression syntax: https://github.com/google/re2/wiki/Syntax.
*/
type LogRegexFilterOperator struct {
	Regex string `json:"regex"`
}

func (o LogRegexFilterOperator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogRegexFilterOperator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogValue struct {
	Message string            `json:"message"`
	Args    map[string]string `json:"args"`
	Id      uuid.UUID         `json:"id"`
}

func (o LogValue) MarshalJSON() ([]byte, error) {
	if o.Args == nil {
		o.Args = make(map[string]string, 0)
	}
	type _tmpLogValue LogValue
	return safejson.Marshal(_tmpLogValue(o))
}

func (o *LogValue) UnmarshalJSON(data []byte) error {
	type _tmpLogValue LogValue
	var rawLogValue _tmpLogValue
	if err := safejson.Unmarshal(data, &rawLogValue); err != nil {
		return err
	}
	if rawLogValue.Args == nil {
		rawLogValue.Args = make(map[string]string, 0)
	}
	*o = LogValue(rawLogValue)
	return nil
}

func (o LogValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogarithmicCurve struct{}

func (o LogarithmicCurve) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogarithmicCurve) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// y = a * ln(x) + b
type LogarithmicResultDetails struct {
	A float64 `json:"a"`
	B float64 `json:"b"`
}

func (o LogarithmicResultDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogarithmicResultDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LowPassConfiguration struct {
	CutoffFrequency DoubleConstant `json:"cutoffFrequency"`
}

func (o LowPassConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LowPassConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The maximum value of points inside the time window.
type Maximum struct{}

func (o Maximum) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Maximum) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The minimum value of points inside the time window.
type Minimum struct{}

func (o Minimum) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Minimum) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericBucket struct {
	Min   float64           `json:"min"`
	Max   float64           `json:"max"`
	Mean  float64           `json:"mean"`
	Count safelong.SafeLong `json:"count"`
	// The population variance of the bucket. If the bucket has only one value, this will be 0.
	Variance   float64      `conjure-docs:"The population variance of the bucket. If the bucket has only one value, this will be 0." json:"variance"`
	FirstPoint NumericPoint `json:"firstPoint"`
	// Will be empty if the bucket only has a single point.
	LastPoint *NumericPoint `conjure-docs:"Will be empty if the bucket only has a single point." json:"lastPoint,omitempty"`
}

func (o NumericBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Fills all empty resample intervals with a single constant value.

If a resampled time interval (bucket) contains no data points from the input, it will
be assigned the specified 'constant' as a default value. This applies to gaps at the start of the
series, between data points, and at the end.
*/
type NumericConstantResampleInterpolationConfiguration struct {
	Constant DoubleConstant `json:"constant"`
}

func (o NumericConstantResampleInterpolationConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericConstantResampleInterpolationConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A bucket in a numeric histogram representing a range of values,
and the counts of values in that range across all input series.
*/
type NumericHistogramBucket struct {
	// The lower bound of the bucket, inclusive
	LowerBound float64 `conjure-docs:"The lower bound of the bucket, inclusive" json:"lowerBound"`
	// The upper bound of the bucket, exclusive
	UpperBound      float64                                `conjure-docs:"The upper bound of the bucket, exclusive" json:"upperBound"`
	CountsByChannel map[VariableName]HistogramChannelCount `json:"countsByChannel"`
	// Deprecated: Use countsByChannel instead
	Buckets map[VariableName]HistogramChannelCount `json:"buckets"`
}

func (o NumericHistogramBucket) MarshalJSON() ([]byte, error) {
	if o.CountsByChannel == nil {
		o.CountsByChannel = make(map[VariableName]HistogramChannelCount, 0)
	}
	if o.Buckets == nil {
		o.Buckets = make(map[VariableName]HistogramChannelCount, 0)
	}
	type _tmpNumericHistogramBucket NumericHistogramBucket
	return safejson.Marshal(_tmpNumericHistogramBucket(o))
}

func (o *NumericHistogramBucket) UnmarshalJSON(data []byte) error {
	type _tmpNumericHistogramBucket NumericHistogramBucket
	var rawNumericHistogramBucket _tmpNumericHistogramBucket
	if err := safejson.Unmarshal(data, &rawNumericHistogramBucket); err != nil {
		return err
	}
	if rawNumericHistogramBucket.CountsByChannel == nil {
		rawNumericHistogramBucket.CountsByChannel = make(map[VariableName]HistogramChannelCount, 0)
	}
	if rawNumericHistogramBucket.Buckets == nil {
		rawNumericHistogramBucket.Buckets = make(map[VariableName]HistogramChannelCount, 0)
	}
	*o = NumericHistogramBucket(rawNumericHistogramBucket)
	return nil
}

func (o NumericHistogramBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericHistogramBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericHistogramBucketWidthAndOffset struct {
	/*
	   The width of each bucket. If offset is not specified, the left and right bounds of each bucket
	   are multiples of the width. If offset is specified, the left and right bounds of each bucket are
	   shifted right by the offset value.
	*/
	Width DoubleConstant `conjure-docs:"The width of each bucket. If offset is not specified, the left and right bounds of each bucket\nare multiples of the width. If offset is specified, the left and right bounds of each bucket are\nshifted right by the offset value." json:"width"`
	/*
	   The rightward shift to apply to the left and right bounds of each bucket. If not specified,
	   the offset will be 0. The offset must be non-negative.
	*/
	Offset *DoubleConstant `conjure-docs:"The rightward shift to apply to the left and right bounds of each bucket. If not specified, \nthe offset will be 0. The offset must be non-negative." json:"offset,omitempty"`
}

func (o NumericHistogramBucketWidthAndOffset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericHistogramBucketWidthAndOffset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericHistogramPlot struct {
	Buckets []NumericHistogramBucket `json:"buckets"`
}

func (o NumericHistogramPlot) MarshalJSON() ([]byte, error) {
	if o.Buckets == nil {
		o.Buckets = make([]NumericHistogramBucket, 0)
	}
	type _tmpNumericHistogramPlot NumericHistogramPlot
	return safejson.Marshal(_tmpNumericHistogramPlot(o))
}

func (o *NumericHistogramPlot) UnmarshalJSON(data []byte) error {
	type _tmpNumericHistogramPlot NumericHistogramPlot
	var rawNumericHistogramPlot _tmpNumericHistogramPlot
	if err := safejson.Unmarshal(data, &rawNumericHistogramPlot); err != nil {
		return err
	}
	if rawNumericHistogramPlot.Buckets == nil {
		rawNumericHistogramPlot.Buckets = make([]NumericHistogramBucket, 0)
	}
	*o = NumericHistogramPlot(rawNumericHistogramPlot)
	return nil
}

func (o NumericHistogramPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericHistogramPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericPlot struct {
	Timestamps []api.Timestamp `json:"timestamps"`
	Values     []float64       `json:"values"`
}

func (o NumericPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.Values == nil {
		o.Values = make([]float64, 0)
	}
	type _tmpNumericPlot NumericPlot
	return safejson.Marshal(_tmpNumericPlot(o))
}

func (o *NumericPlot) UnmarshalJSON(data []byte) error {
	type _tmpNumericPlot NumericPlot
	var rawNumericPlot _tmpNumericPlot
	if err := safejson.Unmarshal(data, &rawNumericPlot); err != nil {
		return err
	}
	if rawNumericPlot.Timestamps == nil {
		rawNumericPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawNumericPlot.Values == nil {
		rawNumericPlot.Values = make([]float64, 0)
	}
	*o = NumericPlot(rawNumericPlot)
	return nil
}

func (o NumericPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericPoint struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Value     float64       `json:"value"`
}

func (o NumericPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Specification of a page for a series. Returns raw undecimated points beginning nearest to the given page
token, advancing pageSize points in the time direction specified by the sign of the page size.
*/
type PageInfo struct {
	PageToken *PageToken `json:"pageToken,omitempty"`
	PageSize  int        `json:"pageSize"`
}

func (o PageInfo) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PageInfo) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PagedLogPlot struct {
	Timestamps []api.Timestamp `json:"timestamps"`
	Values     []LogValue      `json:"values"`
	/*
	   The token to retrieve the next page of logs in the direction originally requested (exclusive - not
	   included in these results). May be empty if there are no further logs in the requested time range in the
	   direction originally requested.
	*/
	NextPageToken *PageToken `conjure-docs:"The token to retrieve the next page of logs in the direction originally requested (exclusive - not\nincluded in these results). May be empty if there are no further logs in the requested time range in the\ndirection originally requested." json:"nextPageToken,omitempty"`
}

func (o PagedLogPlot) MarshalJSON() ([]byte, error) {
	if o.Timestamps == nil {
		o.Timestamps = make([]api.Timestamp, 0)
	}
	if o.Values == nil {
		o.Values = make([]LogValue, 0)
	}
	type _tmpPagedLogPlot PagedLogPlot
	return safejson.Marshal(_tmpPagedLogPlot(o))
}

func (o *PagedLogPlot) UnmarshalJSON(data []byte) error {
	type _tmpPagedLogPlot PagedLogPlot
	var rawPagedLogPlot _tmpPagedLogPlot
	if err := safejson.Unmarshal(data, &rawPagedLogPlot); err != nil {
		return err
	}
	if rawPagedLogPlot.Timestamps == nil {
		rawPagedLogPlot.Timestamps = make([]api.Timestamp, 0)
	}
	if rawPagedLogPlot.Values == nil {
		rawPagedLogPlot.Values = make([]LogValue, 0)
	}
	*o = PagedLogPlot(rawPagedLogPlot)
	return nil
}

func (o PagedLogPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PagedLogPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ParameterizedComputeNodeResponse struct {
	Results []ComputeNodeResult `json:"results"`
}

func (o ParameterizedComputeNodeResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ComputeNodeResult, 0)
	}
	type _tmpParameterizedComputeNodeResponse ParameterizedComputeNodeResponse
	return safejson.Marshal(_tmpParameterizedComputeNodeResponse(o))
}

func (o *ParameterizedComputeNodeResponse) UnmarshalJSON(data []byte) error {
	type _tmpParameterizedComputeNodeResponse ParameterizedComputeNodeResponse
	var rawParameterizedComputeNodeResponse _tmpParameterizedComputeNodeResponse
	if err := safejson.Unmarshal(data, &rawParameterizedComputeNodeResponse); err != nil {
		return err
	}
	if rawParameterizedComputeNodeResponse.Results == nil {
		rawParameterizedComputeNodeResponse.Results = make([]ComputeNodeResult, 0)
	}
	*o = ParameterizedComputeNodeResponse(rawParameterizedComputeNodeResponse)
	return nil
}

func (o ParameterizedComputeNodeResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ParameterizedComputeNodeResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Threshold defined as the percentage of a given value.
type PercentageThreshold struct {
	Value DoubleConstant `json:"value"`
}

func (o PercentageThreshold) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PercentageThreshold) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PinnedModuleVersionReference struct {
	Version StringConstant `json:"version"`
}

func (o PinnedModuleVersionReference) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PinnedModuleVersionReference) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Point3d struct {
	X         float64       `json:"x"`
	Y         float64       `json:"y"`
	Z         float64       `json:"z"`
	Timestamp api.Timestamp `json:"timestamp"`
}

func (o Point3d) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Point3d) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PolynomialCurve struct {
	// The highest allowable degree of the fit polynomial.
	Degree IntegerConstant `conjure-docs:"The highest allowable degree of the fit polynomial." json:"degree"`
	// The y-value at the point x (or t) = 0. If omitted, the y-intercept will also be fit to the data.
	Intercept *DoubleConstant `conjure-docs:"The y-value at the point x (or t) = 0. If omitted, the y-intercept will also be fit to the data." json:"intercept,omitempty"`
}

func (o PolynomialCurve) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PolynomialCurve) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// y = sum( a_i * x^i ) for i in 0...len(a)
type PolynomialResultDetails struct {
	A []float64 `json:"a"`
}

func (o PolynomialResultDetails) MarshalJSON() ([]byte, error) {
	if o.A == nil {
		o.A = make([]float64, 0)
	}
	type _tmpPolynomialResultDetails PolynomialResultDetails
	return safejson.Marshal(_tmpPolynomialResultDetails(o))
}

func (o *PolynomialResultDetails) UnmarshalJSON(data []byte) error {
	type _tmpPolynomialResultDetails PolynomialResultDetails
	var rawPolynomialResultDetails _tmpPolynomialResultDetails
	if err := safejson.Unmarshal(data, &rawPolynomialResultDetails); err != nil {
		return err
	}
	if rawPolynomialResultDetails.A == nil {
		rawPolynomialResultDetails.A = make([]float64, 0)
	}
	*o = PolynomialResultDetails(rawPolynomialResultDetails)
	return nil
}

func (o PolynomialResultDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PolynomialResultDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PowerCurve struct{}

func (o PowerCurve) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PowerCurve) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// y = a * x^b
type PowerResultDetails struct {
	A float64 `json:"a"`
	B float64 `json:"b"`
}

func (o PowerResultDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PowerResultDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The end represents the first timestamp that does not belong to the range. If absent, there is no known
end to the range.
*/
type Range struct {
	Start *api.Timestamp `json:"start,omitempty"`
	End   *api.Timestamp `json:"end,omitempty"`
	Value *RangeValue    `json:"value,omitempty"`
}

func (o Range) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Range) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// An aggregation value representing combined aggregation metrics for data over a range.
type RangeAggregation struct {
	Average           float64  `json:"average"`
	Min               float64  `json:"min"`
	Max               float64  `json:"max"`
	StandardDeviation float64  `json:"standardDeviation"`
	Count             float64  `json:"count"`
	Sum               float64  `json:"sum"`
	RootMeanSquare    *float64 `json:"rootMeanSquare,omitempty"`
}

func (o RangeAggregation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangeAggregation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RangeMap struct {
	// Inclusive start value. If not specified, the start is the prior range's end value, or negative infinity.
	Start *DoubleConstant `conjure-docs:"Inclusive start value. If not specified, the start is the prior range's end value, or negative infinity." json:"start,omitempty"`
	// Exclusive end value. If not specified, the end value is the next range's start value, or positive infinity.
	End *DoubleConstant `conjure-docs:"Exclusive end value. If not specified, the end value is the next range's start value, or positive infinity." json:"end,omitempty"`
	// The value to map to if the input value is within the range.
	Output StringConstant `conjure-docs:"The value to map to if the input value is within the range." json:"output"`
}

func (o RangeMap) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangeMap) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Summary of a set of ranges
type RangeSummary struct {
	// The range representing the minimum start and maximum end times of the ranges.
	Range Range `conjure-docs:"The range representing the minimum start and maximum end times of the ranges." json:"range"`
	// The number of ranges found within this time range.
	SubRangeCount int `conjure-docs:"The number of ranges found within this time range." json:"subRangeCount"`
}

func (o RangeSummary) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangeSummary) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A summary of the ranges returned from a SummarizeRanges request. Returned when the number of ranges
found is above a threshold.
*/
type RangesSummary struct {
	RangesSummary []RangeSummary `json:"rangesSummary"`
}

func (o RangesSummary) MarshalJSON() ([]byte, error) {
	if o.RangesSummary == nil {
		o.RangesSummary = make([]RangeSummary, 0)
	}
	type _tmpRangesSummary RangesSummary
	return safejson.Marshal(_tmpRangesSummary(o))
}

func (o *RangesSummary) UnmarshalJSON(data []byte) error {
	type _tmpRangesSummary RangesSummary
	var rawRangesSummary _tmpRangesSummary
	if err := safejson.Unmarshal(data, &rawRangesSummary); err != nil {
		return err
	}
	if rawRangesSummary.RangesSummary == nil {
		rawRangesSummary.RangesSummary = make([]RangeSummary, 0)
	}
	*o = RangesSummary(rawRangesSummary)
	return nil
}

func (o RangesSummary) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangesSummary) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Reference struct {
	Name VariableName `json:"name"`
}

func (o Reference) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Reference) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The root mean square of points inside the time window.
type RootMeanSquare struct{}

func (o RootMeanSquare) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RootMeanSquare) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RunChannel struct {
	RunRid StringConstant `json:"runRid"`
	/*
	   Used to disambiguate when multiple assets within this run contain data scopes with the same name.
	   If not specified for a run with multiple assets, an error will be thrown.
	*/
	AssetRid *StringConstant `conjure-docs:"Used to disambiguate when multiple assets within this run contain data scopes with the same name.\nIf not specified for a run with multiple assets, an error will be thrown." json:"assetRid,omitempty"`
	// Used to disambiguate when multiple data scopes within this run contain channels with the same name.
	DataScopeName StringConstant `conjure-docs:"Used to disambiguate when multiple data scopes within this run contain channels with the same name." json:"dataScopeName"`
	Channel       StringConstant `json:"channel"`
	// Deprecated: Use additionalTagFilters
	AdditionalTags map[string]StringConstant `json:"additionalTags"`
	/*
	   Tags to filter the channel by, in addition to tag filters defined for a given Run data scope. Throws on
	   collisions with tag keys already defined for the given Run data scope. Only returns points that match
	   both sets of tag filters. For log series, include arg filters here in addition to tag filters.
	*/
	AdditionalTagFilters *TagFilters `conjure-docs:"Tags to filter the channel by, in addition to tag filters defined for a given Run data scope. Throws on \ncollisions with tag keys already defined for the given Run data scope. Only returns points that match \nboth sets of tag filters. For log series, include arg filters here in addition to tag filters." json:"additionalTagFilters,omitempty"`
	// Deprecated: Use groupByTags instead. Throws if both tagsToGroupBy and groupByTags are specified.
	TagsToGroupBy []string `json:"tagsToGroupBy"`
	/*
	   Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned
	   with an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified.
	*/
	GroupByTags []StringConstant `conjure-docs:"Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned\nwith an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified." json:"groupByTags"`
}

func (o RunChannel) MarshalJSON() ([]byte, error) {
	if o.AdditionalTags == nil {
		o.AdditionalTags = make(map[string]StringConstant, 0)
	}
	if o.TagsToGroupBy == nil {
		o.TagsToGroupBy = make([]string, 0)
	}
	if o.GroupByTags == nil {
		o.GroupByTags = make([]StringConstant, 0)
	}
	type _tmpRunChannel RunChannel
	return safejson.Marshal(_tmpRunChannel(o))
}

func (o *RunChannel) UnmarshalJSON(data []byte) error {
	type _tmpRunChannel RunChannel
	var rawRunChannel _tmpRunChannel
	if err := safejson.Unmarshal(data, &rawRunChannel); err != nil {
		return err
	}
	if rawRunChannel.AdditionalTags == nil {
		rawRunChannel.AdditionalTags = make(map[string]StringConstant, 0)
	}
	if rawRunChannel.TagsToGroupBy == nil {
		rawRunChannel.TagsToGroupBy = make([]string, 0)
	}
	if rawRunChannel.GroupByTags == nil {
		rawRunChannel.GroupByTags = make([]StringConstant, 0)
	}
	*o = RunChannel(rawRunChannel)
	return nil
}

func (o RunChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RunChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ScatterFitOptions struct {
	/*
	   Inclusive lower bound on the x values to fit to. If omitted, does not set a bound
	   (equivalent to setting this to the minimum x value among all points in the time range).
	*/
	MinX *DoubleConstant `conjure-docs:"Inclusive lower bound on the x values to fit to. If omitted, does not set a bound\n(equivalent to setting this to the minimum x value among all points in the time range)." json:"minX,omitempty"`
	/*
	   Inclusive upper bound on the x values to fit to. If omitted, does not set a bound
	   (equivalent to setting this to the maximum x value among all points in the time range).
	*/
	MaxX *DoubleConstant `conjure-docs:"Inclusive upper bound on the x values to fit to. If omitted, does not set a bound\n(equivalent to setting this to the maximum x value among all points in the time range)." json:"maxX,omitempty"`
	/*
	   Inclusive lower bound on the y values to fit to. If omitted, does not set a bound
	   (equivalent to setting this to the minimum y value among all points in the time range).
	*/
	MinY *DoubleConstant `conjure-docs:"Inclusive lower bound on the y values to fit to. If omitted, does not set a bound\n(equivalent to setting this to the minimum y value among all points in the time range)." json:"minY,omitempty"`
	/*
	   Inclusive upper bound on the y values to fit to. If omitted, does not set a bound
	   (equivalent to setting this to the maximum y value among all points in the time range).
	*/
	MaxY *DoubleConstant `conjure-docs:"Inclusive upper bound on the y values to fit to. If omitted, does not set a bound\n(equivalent to setting this to the maximum y value among all points in the time range)." json:"maxY,omitempty"`
}

func (o ScatterFitOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ScatterFitOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SetNegativeValuesToZero struct{}

func (o SetNegativeValuesToZero) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SetNegativeValuesToZero) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Return type representing a single point value.
type SinglePoint struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Value     Value         `json:"value"`
	/*
	   Returns true if the result required downcasting to a type with less precision,
	   for example if the input series was Int64 and the result is a Float64.
	*/
	PrecisionLoss bool `conjure-docs:"Returns true if the result required downcasting to a type with less precision, \nfor example if the input series was Int64 and the result is a Float64." json:"precisionLoss"`
}

func (o SinglePoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SinglePoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Decimate by spatial trees.
Creates buckets by bisecting on each dimension, creating quadrants for 2d scatter and octants for 3d scatter.
Continues subdividing by prioritizing larger undivided buckets until reaching the max amount of buckets.
*/
type SpatialDecimateStrategy struct{}

func (o SpatialDecimateStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SpatialDecimateStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The standard deviation of points inside the time window.
type StandardDeviation struct{}

func (o StandardDeviation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StandardDeviation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Options for frequency analyses that are backed by short-time Fourier transforms.
type StftOptions struct {
	// Window function type to use
	Window *FftWindow `conjure-docs:"Window function type to use" json:"window,omitempty"`
	// Either DFT_EVEN or SYMMETRIC
	WindowSymmetry *WindowSymmetry `conjure-docs:"Either DFT_EVEN or SYMMETRIC" json:"windowSymmetry,omitempty"`
	// Sampling frequency of the series in Hz. If absent, will calculate using the input series.
	SamplingFrequency *float64 `conjure-docs:"Sampling frequency of the series in Hz. If absent, will calculate using the input series." json:"samplingFrequency,omitempty"`
	// Number of points per window segment.
	Nperseg *int `conjure-docs:"Number of points per window segment." json:"nperseg,omitempty"`
	// Number of points of overlap between windows. Must be less than nperseg.
	Noverlap *int `conjure-docs:"Number of points of overlap between windows. Must be less than nperseg." json:"noverlap,omitempty"`
	// Number of points to use in the FFT. Must be greater than or equal to nperseg.
	Nfft *int `conjure-docs:"Number of points to use in the FFT. Must be greater than or equal to nperseg." json:"nfft,omitempty"`
	// Detrend the points in each window segment. If absent, will use the default detrend for that function.
	Detrend *DetrendType `conjure-docs:"Detrend the points in each window segment. If absent, will use the default detrend for that function." json:"detrend,omitempty"`
}

func (o StftOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StftOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The sum of point values inside the time window.
type Sum struct{}

func (o Sum) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Sum) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The sum of points inside the time window.
type Summation struct{}

func (o Summation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Summation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A filter on a single tag key and set of values. For an IN operator, the tag key must match at least one of the
values in the set. For a NOT_IN operator, it must not match any of the values in the set.
*/
type TagFilter struct {
	Key      StringConstant    `json:"key"`
	Values   []StringConstant  `json:"values"`
	Operator TagFilterOperator `json:"operator"`
}

func (o TagFilter) MarshalJSON() ([]byte, error) {
	if o.Values == nil {
		o.Values = make([]StringConstant, 0)
	}
	type _tmpTagFilter TagFilter
	return safejson.Marshal(_tmpTagFilter(o))
}

func (o *TagFilter) UnmarshalJSON(data []byte) error {
	type _tmpTagFilter TagFilter
	var rawTagFilter _tmpTagFilter
	if err := safejson.Unmarshal(data, &rawTagFilter); err != nil {
		return err
	}
	if rawTagFilter.Values == nil {
		rawTagFilter.Values = make([]StringConstant, 0)
	}
	*o = TagFilter(rawTagFilter)
	return nil
}

func (o TagFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TagFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Buckets the input by time range into equally sized buckets.
The number of buckets is determined by the maxPoints parameter.
Returns a CartesianPlot.
*/
type TemporalDecimateStrategy struct {
	// The strategy to use for aggregating the x values in each bucket.
	XAggregation ScatterTemporalAggregation `conjure-docs:"The strategy to use for aggregating the x values in each bucket." json:"xAggregation"`
	// The strategy to use for aggregating the y values in each bucket.
	YAggregation ScatterTemporalAggregation `conjure-docs:"The strategy to use for aggregating the y values in each bucket." json:"yAggregation"`
}

func (o TemporalDecimateStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TemporalDecimateStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimeSeriesFitOptions struct {
	// Time unit used for the timestamps to fit against. Defaults to seconds if not specified.
	TimeUnit *api.TimeUnit `conjure-docs:"Time unit used for the timestamps to fit against. Defaults to seconds if not specified." json:"timeUnit,omitempty"`
}

func (o TimeSeriesFitOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeSeriesFitOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimestampAndId struct {
	Timestamp api.Timestamp `json:"timestamp"`
	Id        *uuid.UUID    `json:"id,omitempty"`
}

func (o TimestampAndId) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimestampAndId) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// At least one input is missing a unit.
type UnitsMissing struct {
	// Deprecated: Use channels instead.
	SeriesRids []api.LogicalSeriesRid `json:"seriesRids"`
	Channels   []DataSourceAndChannel `json:"channels"`
}

func (o UnitsMissing) MarshalJSON() ([]byte, error) {
	if o.SeriesRids == nil {
		o.SeriesRids = make([]api.LogicalSeriesRid, 0)
	}
	if o.Channels == nil {
		o.Channels = make([]DataSourceAndChannel, 0)
	}
	type _tmpUnitsMissing UnitsMissing
	return safejson.Marshal(_tmpUnitsMissing(o))
}

func (o *UnitsMissing) UnmarshalJSON(data []byte) error {
	type _tmpUnitsMissing UnitsMissing
	var rawUnitsMissing _tmpUnitsMissing
	if err := safejson.Unmarshal(data, &rawUnitsMissing); err != nil {
		return err
	}
	if rawUnitsMissing.SeriesRids == nil {
		rawUnitsMissing.SeriesRids = make([]api.LogicalSeriesRid, 0)
	}
	if rawUnitsMissing.Channels == nil {
		rawUnitsMissing.Channels = make([]DataSourceAndChannel, 0)
	}
	*o = UnitsMissing(rawUnitsMissing)
	return nil
}

func (o UnitsMissing) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnitsMissing) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
