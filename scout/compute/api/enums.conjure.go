// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"strings"
)

type ApproximateThresholdOperator struct {
	val ApproximateThresholdOperator_Value
}

type ApproximateThresholdOperator_Value string

const (
	ApproximateThresholdOperator_EQUAL_TO     ApproximateThresholdOperator_Value = "EQUAL_TO"
	ApproximateThresholdOperator_NOT_EQUAL_TO ApproximateThresholdOperator_Value = "NOT_EQUAL_TO"
	ApproximateThresholdOperator_UNKNOWN      ApproximateThresholdOperator_Value = "UNKNOWN"
)

// ApproximateThresholdOperator_Values returns all known variants of ApproximateThresholdOperator.
func ApproximateThresholdOperator_Values() []ApproximateThresholdOperator_Value {
	return []ApproximateThresholdOperator_Value{ApproximateThresholdOperator_EQUAL_TO, ApproximateThresholdOperator_NOT_EQUAL_TO}
}

func New_ApproximateThresholdOperator(value ApproximateThresholdOperator_Value) ApproximateThresholdOperator {
	return ApproximateThresholdOperator{val: value}
}

// IsUnknown returns false for all known variants of ApproximateThresholdOperator and true otherwise.
func (e ApproximateThresholdOperator) IsUnknown() bool {
	switch e.val {
	case ApproximateThresholdOperator_EQUAL_TO, ApproximateThresholdOperator_NOT_EQUAL_TO:
		return false
	}
	return true
}

func (e ApproximateThresholdOperator) Value() ApproximateThresholdOperator_Value {
	if e.IsUnknown() {
		return ApproximateThresholdOperator_UNKNOWN
	}
	return e.val
}

func (e ApproximateThresholdOperator) String() string {
	return string(e.val)
}

func (e ApproximateThresholdOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *ApproximateThresholdOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_ApproximateThresholdOperator(ApproximateThresholdOperator_Value(v))
	case "EQUAL_TO":
		*e = New_ApproximateThresholdOperator(ApproximateThresholdOperator_EQUAL_TO)
	case "NOT_EQUAL_TO":
		*e = New_ApproximateThresholdOperator(ApproximateThresholdOperator_NOT_EQUAL_TO)
	}
	return nil
}

type BinaryArithmeticOperation struct {
	val BinaryArithmeticOperation_Value
}

type BinaryArithmeticOperation_Value string

const (
	/*
	   Calculates the angle measure between the x-axis and a ray from the origin to a point (input2, input1)
	   in radians.
	   Note the order of arguments.
	*/
	BinaryArithmeticOperation_ATAN2   BinaryArithmeticOperation_Value = "ATAN2"
	BinaryArithmeticOperation_UNKNOWN BinaryArithmeticOperation_Value = "UNKNOWN"
)

// BinaryArithmeticOperation_Values returns all known variants of BinaryArithmeticOperation.
func BinaryArithmeticOperation_Values() []BinaryArithmeticOperation_Value {
	return []BinaryArithmeticOperation_Value{BinaryArithmeticOperation_ATAN2}
}

func New_BinaryArithmeticOperation(value BinaryArithmeticOperation_Value) BinaryArithmeticOperation {
	return BinaryArithmeticOperation{val: value}
}

// IsUnknown returns false for all known variants of BinaryArithmeticOperation and true otherwise.
func (e BinaryArithmeticOperation) IsUnknown() bool {
	switch e.val {
	case BinaryArithmeticOperation_ATAN2:
		return false
	}
	return true
}

func (e BinaryArithmeticOperation) Value() BinaryArithmeticOperation_Value {
	if e.IsUnknown() {
		return BinaryArithmeticOperation_UNKNOWN
	}
	return e.val
}

func (e BinaryArithmeticOperation) String() string {
	return string(e.val)
}

func (e BinaryArithmeticOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *BinaryArithmeticOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_BinaryArithmeticOperation(BinaryArithmeticOperation_Value(v))
	case "ATAN2":
		*e = New_BinaryArithmeticOperation(BinaryArithmeticOperation_ATAN2)
	}
	return nil
}

// The type of detrending to apply to the signal. When absent, will default to the detrend behavior for that function.
type DetrendType struct {
	val DetrendType_Value
}

type DetrendType_Value string

const (
	// Removes the mean value of the signal.
	DetrendType_CONSTANT DetrendType_Value = "CONSTANT"
	// Removes a best-fit linear trend from the signal.
	DetrendType_LINEAR DetrendType_Value = "LINEAR"
	// Does not perform any detrending.
	DetrendType_NO_OP   DetrendType_Value = "NO_OP"
	DetrendType_UNKNOWN DetrendType_Value = "UNKNOWN"
)

// DetrendType_Values returns all known variants of DetrendType.
func DetrendType_Values() []DetrendType_Value {
	return []DetrendType_Value{DetrendType_CONSTANT, DetrendType_LINEAR, DetrendType_NO_OP}
}

func New_DetrendType(value DetrendType_Value) DetrendType {
	return DetrendType{val: value}
}

// IsUnknown returns false for all known variants of DetrendType and true otherwise.
func (e DetrendType) IsUnknown() bool {
	switch e.val {
	case DetrendType_CONSTANT, DetrendType_LINEAR, DetrendType_NO_OP:
		return false
	}
	return true
}

func (e DetrendType) Value() DetrendType_Value {
	if e.IsUnknown() {
		return DetrendType_UNKNOWN
	}
	return e.val
}

func (e DetrendType) String() string {
	return string(e.val)
}

func (e DetrendType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *DetrendType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_DetrendType(DetrendType_Value(v))
	case "CONSTANT":
		*e = New_DetrendType(DetrendType_CONSTANT)
	case "LINEAR":
		*e = New_DetrendType(DetrendType_LINEAR)
	case "NO_OP":
		*e = New_DetrendType(DetrendType_NO_OP)
	}
	return nil
}

type DriverSeries3d struct {
	val DriverSeries3d_Value
}

type DriverSeries3d_Value string

const (
	DriverSeries3d_X       DriverSeries3d_Value = "X"
	DriverSeries3d_Y       DriverSeries3d_Value = "Y"
	DriverSeries3d_Z       DriverSeries3d_Value = "Z"
	DriverSeries3d_UNKNOWN DriverSeries3d_Value = "UNKNOWN"
)

// DriverSeries3d_Values returns all known variants of DriverSeries3d.
func DriverSeries3d_Values() []DriverSeries3d_Value {
	return []DriverSeries3d_Value{DriverSeries3d_X, DriverSeries3d_Y, DriverSeries3d_Z}
}

func New_DriverSeries3d(value DriverSeries3d_Value) DriverSeries3d {
	return DriverSeries3d{val: value}
}

// IsUnknown returns false for all known variants of DriverSeries3d and true otherwise.
func (e DriverSeries3d) IsUnknown() bool {
	switch e.val {
	case DriverSeries3d_X, DriverSeries3d_Y, DriverSeries3d_Z:
		return false
	}
	return true
}

func (e DriverSeries3d) Value() DriverSeries3d_Value {
	if e.IsUnknown() {
		return DriverSeries3d_UNKNOWN
	}
	return e.val
}

func (e DriverSeries3d) String() string {
	return string(e.val)
}

func (e DriverSeries3d) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *DriverSeries3d) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_DriverSeries3d(DriverSeries3d_Value(v))
	case "X":
		*e = New_DriverSeries3d(DriverSeries3d_X)
	case "Y":
		*e = New_DriverSeries3d(DriverSeries3d_Y)
	case "Z":
		*e = New_DriverSeries3d(DriverSeries3d_Z)
	}
	return nil
}

type EnumAggregationFunction struct {
	val EnumAggregationFunction_Value
}

type EnumAggregationFunction_Value string

const (
	EnumAggregationFunction_MIN     EnumAggregationFunction_Value = "MIN"
	EnumAggregationFunction_MAX     EnumAggregationFunction_Value = "MAX"
	EnumAggregationFunction_UNKNOWN EnumAggregationFunction_Value = "UNKNOWN"
)

// EnumAggregationFunction_Values returns all known variants of EnumAggregationFunction.
func EnumAggregationFunction_Values() []EnumAggregationFunction_Value {
	return []EnumAggregationFunction_Value{EnumAggregationFunction_MIN, EnumAggregationFunction_MAX}
}

func New_EnumAggregationFunction(value EnumAggregationFunction_Value) EnumAggregationFunction {
	return EnumAggregationFunction{val: value}
}

// IsUnknown returns false for all known variants of EnumAggregationFunction and true otherwise.
func (e EnumAggregationFunction) IsUnknown() bool {
	switch e.val {
	case EnumAggregationFunction_MIN, EnumAggregationFunction_MAX:
		return false
	}
	return true
}

func (e EnumAggregationFunction) Value() EnumAggregationFunction_Value {
	if e.IsUnknown() {
		return EnumAggregationFunction_UNKNOWN
	}
	return e.val
}

func (e EnumAggregationFunction) String() string {
	return string(e.val)
}

func (e EnumAggregationFunction) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EnumAggregationFunction) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EnumAggregationFunction(EnumAggregationFunction_Value(v))
	case "MIN":
		*e = New_EnumAggregationFunction(EnumAggregationFunction_MIN)
	case "MAX":
		*e = New_EnumAggregationFunction(EnumAggregationFunction_MAX)
	}
	return nil
}

type EnumFilterOperator struct {
	val EnumFilterOperator_Value
}

type EnumFilterOperator_Value string

const (
	EnumFilterOperator_IS_IN     EnumFilterOperator_Value = "IS_IN"
	EnumFilterOperator_IS_NOT_IN EnumFilterOperator_Value = "IS_NOT_IN"
	EnumFilterOperator_UNKNOWN   EnumFilterOperator_Value = "UNKNOWN"
)

// EnumFilterOperator_Values returns all known variants of EnumFilterOperator.
func EnumFilterOperator_Values() []EnumFilterOperator_Value {
	return []EnumFilterOperator_Value{EnumFilterOperator_IS_IN, EnumFilterOperator_IS_NOT_IN}
}

func New_EnumFilterOperator(value EnumFilterOperator_Value) EnumFilterOperator {
	return EnumFilterOperator{val: value}
}

// IsUnknown returns false for all known variants of EnumFilterOperator and true otherwise.
func (e EnumFilterOperator) IsUnknown() bool {
	switch e.val {
	case EnumFilterOperator_IS_IN, EnumFilterOperator_IS_NOT_IN:
		return false
	}
	return true
}

func (e EnumFilterOperator) Value() EnumFilterOperator_Value {
	if e.IsUnknown() {
		return EnumFilterOperator_UNKNOWN
	}
	return e.val
}

func (e EnumFilterOperator) String() string {
	return string(e.val)
}

func (e EnumFilterOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EnumFilterOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EnumFilterOperator(EnumFilterOperator_Value(v))
	case "IS_IN":
		*e = New_EnumFilterOperator(EnumFilterOperator_IS_IN)
	case "IS_NOT_IN":
		*e = New_EnumFilterOperator(EnumFilterOperator_IS_NOT_IN)
	}
	return nil
}

type EnumUnionOperation struct {
	val EnumUnionOperation_Value
}

type EnumUnionOperation_Value string

const (
	// Throws an exception if two series contain points with a duplicate timestamp.
	EnumUnionOperation_THROW EnumUnionOperation_Value = "THROW"
	// Aggregates duplicates by String MAX.
	EnumUnionOperation_MAX EnumUnionOperation_Value = "MAX"
	// Aggregates duplicates by String MIN.
	EnumUnionOperation_MIN     EnumUnionOperation_Value = "MIN"
	EnumUnionOperation_UNKNOWN EnumUnionOperation_Value = "UNKNOWN"
)

// EnumUnionOperation_Values returns all known variants of EnumUnionOperation.
func EnumUnionOperation_Values() []EnumUnionOperation_Value {
	return []EnumUnionOperation_Value{EnumUnionOperation_THROW, EnumUnionOperation_MAX, EnumUnionOperation_MIN}
}

func New_EnumUnionOperation(value EnumUnionOperation_Value) EnumUnionOperation {
	return EnumUnionOperation{val: value}
}

// IsUnknown returns false for all known variants of EnumUnionOperation and true otherwise.
func (e EnumUnionOperation) IsUnknown() bool {
	switch e.val {
	case EnumUnionOperation_THROW, EnumUnionOperation_MAX, EnumUnionOperation_MIN:
		return false
	}
	return true
}

func (e EnumUnionOperation) Value() EnumUnionOperation_Value {
	if e.IsUnknown() {
		return EnumUnionOperation_UNKNOWN
	}
	return e.val
}

func (e EnumUnionOperation) String() string {
	return string(e.val)
}

func (e EnumUnionOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EnumUnionOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EnumUnionOperation(EnumUnionOperation_Value(v))
	case "THROW":
		*e = New_EnumUnionOperation(EnumUnionOperation_THROW)
	case "MAX":
		*e = New_EnumUnionOperation(EnumUnionOperation_MAX)
	case "MIN":
		*e = New_EnumUnionOperation(EnumUnionOperation_MIN)
	}
	return nil
}

type EqualityOperator struct {
	val EqualityOperator_Value
}

type EqualityOperator_Value string

const (
	EqualityOperator_ALL_EQUAL     EqualityOperator_Value = "ALL_EQUAL"
	EqualityOperator_NOT_ALL_EQUAL EqualityOperator_Value = "NOT_ALL_EQUAL"
	EqualityOperator_UNKNOWN       EqualityOperator_Value = "UNKNOWN"
)

// EqualityOperator_Values returns all known variants of EqualityOperator.
func EqualityOperator_Values() []EqualityOperator_Value {
	return []EqualityOperator_Value{EqualityOperator_ALL_EQUAL, EqualityOperator_NOT_ALL_EQUAL}
}

func New_EqualityOperator(value EqualityOperator_Value) EqualityOperator {
	return EqualityOperator{val: value}
}

// IsUnknown returns false for all known variants of EqualityOperator and true otherwise.
func (e EqualityOperator) IsUnknown() bool {
	switch e.val {
	case EqualityOperator_ALL_EQUAL, EqualityOperator_NOT_ALL_EQUAL:
		return false
	}
	return true
}

func (e EqualityOperator) Value() EqualityOperator_Value {
	if e.IsUnknown() {
		return EqualityOperator_UNKNOWN
	}
	return e.val
}

func (e EqualityOperator) String() string {
	return string(e.val)
}

func (e EqualityOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EqualityOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EqualityOperator(EqualityOperator_Value(v))
	case "ALL_EQUAL":
		*e = New_EqualityOperator(EqualityOperator_ALL_EQUAL)
	case "NOT_ALL_EQUAL":
		*e = New_EqualityOperator(EqualityOperator_NOT_ALL_EQUAL)
	}
	return nil
}

type FftWindow struct {
	val FftWindow_Value
}

type FftWindow_Value string

const (
	FftWindow_BLACKMAN FftWindow_Value = "BLACKMAN"
	FftWindow_HANN     FftWindow_Value = "HANN"
	FftWindow_HAMMING  FftWindow_Value = "HAMMING"
	FftWindow_RECT     FftWindow_Value = "RECT"
	FftWindow_UNKNOWN  FftWindow_Value = "UNKNOWN"
)

// FftWindow_Values returns all known variants of FftWindow.
func FftWindow_Values() []FftWindow_Value {
	return []FftWindow_Value{FftWindow_BLACKMAN, FftWindow_HANN, FftWindow_HAMMING, FftWindow_RECT}
}

func New_FftWindow(value FftWindow_Value) FftWindow {
	return FftWindow{val: value}
}

// IsUnknown returns false for all known variants of FftWindow and true otherwise.
func (e FftWindow) IsUnknown() bool {
	switch e.val {
	case FftWindow_BLACKMAN, FftWindow_HANN, FftWindow_HAMMING, FftWindow_RECT:
		return false
	}
	return true
}

func (e FftWindow) Value() FftWindow_Value {
	if e.IsUnknown() {
		return FftWindow_UNKNOWN
	}
	return e.val
}

func (e FftWindow) String() string {
	return string(e.val)
}

func (e FftWindow) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *FftWindow) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_FftWindow(FftWindow_Value(v))
	case "BLACKMAN":
		*e = New_FftWindow(FftWindow_BLACKMAN)
	case "HANN":
		*e = New_FftWindow(FftWindow_HANN)
	case "HAMMING":
		*e = New_FftWindow(FftWindow_HAMMING)
	case "RECT":
		*e = New_FftWindow(FftWindow_RECT)
	}
	return nil
}

type LogUnionOperation struct {
	val LogUnionOperation_Value
}

type LogUnionOperation_Value string

const (
	// Keeps all points if multiple series contain points with a duplicate timestamp.
	LogUnionOperation_KEEP_ALL LogUnionOperation_Value = "KEEP_ALL"
	LogUnionOperation_UNKNOWN  LogUnionOperation_Value = "UNKNOWN"
)

// LogUnionOperation_Values returns all known variants of LogUnionOperation.
func LogUnionOperation_Values() []LogUnionOperation_Value {
	return []LogUnionOperation_Value{LogUnionOperation_KEEP_ALL}
}

func New_LogUnionOperation(value LogUnionOperation_Value) LogUnionOperation {
	return LogUnionOperation{val: value}
}

// IsUnknown returns false for all known variants of LogUnionOperation and true otherwise.
func (e LogUnionOperation) IsUnknown() bool {
	switch e.val {
	case LogUnionOperation_KEEP_ALL:
		return false
	}
	return true
}

func (e LogUnionOperation) Value() LogUnionOperation_Value {
	if e.IsUnknown() {
		return LogUnionOperation_UNKNOWN
	}
	return e.val
}

func (e LogUnionOperation) String() string {
	return string(e.val)
}

func (e LogUnionOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *LogUnionOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_LogUnionOperation(LogUnionOperation_Value(v))
	case "KEEP_ALL":
		*e = New_LogUnionOperation(LogUnionOperation_KEEP_ALL)
	}
	return nil
}

type MagnitudeScaling struct {
	val MagnitudeScaling_Value
}

type MagnitudeScaling_Value string

const (
	// Linear scaling of the magnitude.
	MagnitudeScaling_LINEAR MagnitudeScaling_Value = "LINEAR"
	// Scales the magnitude via 10 * log10(magnitude).
	MagnitudeScaling_MAGNITUDE_DB_10 MagnitudeScaling_Value = "MAGNITUDE_DB_10"
	// Scales the magnitude via 20 * log10(magnitude).
	MagnitudeScaling_MAGNITUDE_DB_20 MagnitudeScaling_Value = "MAGNITUDE_DB_20"
	MagnitudeScaling_UNKNOWN         MagnitudeScaling_Value = "UNKNOWN"
)

// MagnitudeScaling_Values returns all known variants of MagnitudeScaling.
func MagnitudeScaling_Values() []MagnitudeScaling_Value {
	return []MagnitudeScaling_Value{MagnitudeScaling_LINEAR, MagnitudeScaling_MAGNITUDE_DB_10, MagnitudeScaling_MAGNITUDE_DB_20}
}

func New_MagnitudeScaling(value MagnitudeScaling_Value) MagnitudeScaling {
	return MagnitudeScaling{val: value}
}

// IsUnknown returns false for all known variants of MagnitudeScaling and true otherwise.
func (e MagnitudeScaling) IsUnknown() bool {
	switch e.val {
	case MagnitudeScaling_LINEAR, MagnitudeScaling_MAGNITUDE_DB_10, MagnitudeScaling_MAGNITUDE_DB_20:
		return false
	}
	return true
}

func (e MagnitudeScaling) Value() MagnitudeScaling_Value {
	if e.IsUnknown() {
		return MagnitudeScaling_UNKNOWN
	}
	return e.val
}

func (e MagnitudeScaling) String() string {
	return string(e.val)
}

func (e MagnitudeScaling) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *MagnitudeScaling) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_MagnitudeScaling(MagnitudeScaling_Value(v))
	case "LINEAR":
		*e = New_MagnitudeScaling(MagnitudeScaling_LINEAR)
	case "MAGNITUDE_DB_10":
		*e = New_MagnitudeScaling(MagnitudeScaling_MAGNITUDE_DB_10)
	case "MAGNITUDE_DB_20":
		*e = New_MagnitudeScaling(MagnitudeScaling_MAGNITUDE_DB_20)
	}
	return nil
}

type MinMaxThresholdOperator struct {
	val MinMaxThresholdOperator_Value
}

type MinMaxThresholdOperator_Value string

const (
	MinMaxThresholdOperator_OUTSIDE_BOUNDS             MinMaxThresholdOperator_Value = "OUTSIDE_BOUNDS"
	MinMaxThresholdOperator_OUTSIDE_OR_EQUAL_TO_BOUNDS MinMaxThresholdOperator_Value = "OUTSIDE_OR_EQUAL_TO_BOUNDS"
	MinMaxThresholdOperator_INSIDE_BOUNDS              MinMaxThresholdOperator_Value = "INSIDE_BOUNDS"
	MinMaxThresholdOperator_INSIDE_OR_EQUAL_TO_BOUNDS  MinMaxThresholdOperator_Value = "INSIDE_OR_EQUAL_TO_BOUNDS"
	MinMaxThresholdOperator_UNKNOWN                    MinMaxThresholdOperator_Value = "UNKNOWN"
)

// MinMaxThresholdOperator_Values returns all known variants of MinMaxThresholdOperator.
func MinMaxThresholdOperator_Values() []MinMaxThresholdOperator_Value {
	return []MinMaxThresholdOperator_Value{MinMaxThresholdOperator_OUTSIDE_BOUNDS, MinMaxThresholdOperator_OUTSIDE_OR_EQUAL_TO_BOUNDS, MinMaxThresholdOperator_INSIDE_BOUNDS, MinMaxThresholdOperator_INSIDE_OR_EQUAL_TO_BOUNDS}
}

func New_MinMaxThresholdOperator(value MinMaxThresholdOperator_Value) MinMaxThresholdOperator {
	return MinMaxThresholdOperator{val: value}
}

// IsUnknown returns false for all known variants of MinMaxThresholdOperator and true otherwise.
func (e MinMaxThresholdOperator) IsUnknown() bool {
	switch e.val {
	case MinMaxThresholdOperator_OUTSIDE_BOUNDS, MinMaxThresholdOperator_OUTSIDE_OR_EQUAL_TO_BOUNDS, MinMaxThresholdOperator_INSIDE_BOUNDS, MinMaxThresholdOperator_INSIDE_OR_EQUAL_TO_BOUNDS:
		return false
	}
	return true
}

func (e MinMaxThresholdOperator) Value() MinMaxThresholdOperator_Value {
	if e.IsUnknown() {
		return MinMaxThresholdOperator_UNKNOWN
	}
	return e.val
}

func (e MinMaxThresholdOperator) String() string {
	return string(e.val)
}

func (e MinMaxThresholdOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *MinMaxThresholdOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_MinMaxThresholdOperator(MinMaxThresholdOperator_Value(v))
	case "OUTSIDE_BOUNDS":
		*e = New_MinMaxThresholdOperator(MinMaxThresholdOperator_OUTSIDE_BOUNDS)
	case "OUTSIDE_OR_EQUAL_TO_BOUNDS":
		*e = New_MinMaxThresholdOperator(MinMaxThresholdOperator_OUTSIDE_OR_EQUAL_TO_BOUNDS)
	case "INSIDE_BOUNDS":
		*e = New_MinMaxThresholdOperator(MinMaxThresholdOperator_INSIDE_BOUNDS)
	case "INSIDE_OR_EQUAL_TO_BOUNDS":
		*e = New_MinMaxThresholdOperator(MinMaxThresholdOperator_INSIDE_OR_EQUAL_TO_BOUNDS)
	}
	return nil
}

type NumericAggregationFunction struct {
	val NumericAggregationFunction_Value
}

type NumericAggregationFunction_Value string

const (
	NumericAggregationFunction_SUM                NumericAggregationFunction_Value = "SUM"
	NumericAggregationFunction_MEAN               NumericAggregationFunction_Value = "MEAN"
	NumericAggregationFunction_MIN                NumericAggregationFunction_Value = "MIN"
	NumericAggregationFunction_MAX                NumericAggregationFunction_Value = "MAX"
	NumericAggregationFunction_COUNT              NumericAggregationFunction_Value = "COUNT"
	NumericAggregationFunction_STANDARD_DEVIATION NumericAggregationFunction_Value = "STANDARD_DEVIATION"
	NumericAggregationFunction_ROOT_MEAN_SQUARE   NumericAggregationFunction_Value = "ROOT_MEAN_SQUARE"
	NumericAggregationFunction_UNKNOWN            NumericAggregationFunction_Value = "UNKNOWN"
)

// NumericAggregationFunction_Values returns all known variants of NumericAggregationFunction.
func NumericAggregationFunction_Values() []NumericAggregationFunction_Value {
	return []NumericAggregationFunction_Value{NumericAggregationFunction_SUM, NumericAggregationFunction_MEAN, NumericAggregationFunction_MIN, NumericAggregationFunction_MAX, NumericAggregationFunction_COUNT, NumericAggregationFunction_STANDARD_DEVIATION, NumericAggregationFunction_ROOT_MEAN_SQUARE}
}

func New_NumericAggregationFunction(value NumericAggregationFunction_Value) NumericAggregationFunction {
	return NumericAggregationFunction{val: value}
}

// IsUnknown returns false for all known variants of NumericAggregationFunction and true otherwise.
func (e NumericAggregationFunction) IsUnknown() bool {
	switch e.val {
	case NumericAggregationFunction_SUM, NumericAggregationFunction_MEAN, NumericAggregationFunction_MIN, NumericAggregationFunction_MAX, NumericAggregationFunction_COUNT, NumericAggregationFunction_STANDARD_DEVIATION, NumericAggregationFunction_ROOT_MEAN_SQUARE:
		return false
	}
	return true
}

func (e NumericAggregationFunction) Value() NumericAggregationFunction_Value {
	if e.IsUnknown() {
		return NumericAggregationFunction_UNKNOWN
	}
	return e.val
}

func (e NumericAggregationFunction) String() string {
	return string(e.val)
}

func (e NumericAggregationFunction) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *NumericAggregationFunction) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_NumericAggregationFunction(NumericAggregationFunction_Value(v))
	case "SUM":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_SUM)
	case "MEAN":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_MEAN)
	case "MIN":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_MIN)
	case "MAX":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_MAX)
	case "COUNT":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_COUNT)
	case "STANDARD_DEVIATION":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_STANDARD_DEVIATION)
	case "ROOT_MEAN_SQUARE":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_ROOT_MEAN_SQUARE)
	}
	return nil
}

// Supported numeric data types for value casting.
type NumericDataType struct {
	val NumericDataType_Value
}

type NumericDataType_Value string

const (
	NumericDataType_INT64   NumericDataType_Value = "INT64"
	NumericDataType_FLOAT64 NumericDataType_Value = "FLOAT64"
	NumericDataType_UINT64  NumericDataType_Value = "UINT64"
	NumericDataType_UNKNOWN NumericDataType_Value = "UNKNOWN"
)

// NumericDataType_Values returns all known variants of NumericDataType.
func NumericDataType_Values() []NumericDataType_Value {
	return []NumericDataType_Value{NumericDataType_INT64, NumericDataType_FLOAT64, NumericDataType_UINT64}
}

func New_NumericDataType(value NumericDataType_Value) NumericDataType {
	return NumericDataType{val: value}
}

// IsUnknown returns false for all known variants of NumericDataType and true otherwise.
func (e NumericDataType) IsUnknown() bool {
	switch e.val {
	case NumericDataType_INT64, NumericDataType_FLOAT64, NumericDataType_UINT64:
		return false
	}
	return true
}

func (e NumericDataType) Value() NumericDataType_Value {
	if e.IsUnknown() {
		return NumericDataType_UNKNOWN
	}
	return e.val
}

func (e NumericDataType) String() string {
	return string(e.val)
}

func (e NumericDataType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *NumericDataType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_NumericDataType(NumericDataType_Value(v))
	case "INT64":
		*e = New_NumericDataType(NumericDataType_INT64)
	case "FLOAT64":
		*e = New_NumericDataType(NumericDataType_FLOAT64)
	case "UINT64":
		*e = New_NumericDataType(NumericDataType_UINT64)
	}
	return nil
}

type NumericOutputField struct {
	val NumericOutputField_Value
}

type NumericOutputField_Value string

const (
	NumericOutputField_MIN         NumericOutputField_Value = "MIN"
	NumericOutputField_MAX         NumericOutputField_Value = "MAX"
	NumericOutputField_MEAN        NumericOutputField_Value = "MEAN"
	NumericOutputField_COUNT       NumericOutputField_Value = "COUNT"
	NumericOutputField_VARIANCE    NumericOutputField_Value = "VARIANCE"
	NumericOutputField_FIRST_POINT NumericOutputField_Value = "FIRST_POINT"
	NumericOutputField_LAST_POINT  NumericOutputField_Value = "LAST_POINT"
	NumericOutputField_UNKNOWN     NumericOutputField_Value = "UNKNOWN"
)

// NumericOutputField_Values returns all known variants of NumericOutputField.
func NumericOutputField_Values() []NumericOutputField_Value {
	return []NumericOutputField_Value{NumericOutputField_MIN, NumericOutputField_MAX, NumericOutputField_MEAN, NumericOutputField_COUNT, NumericOutputField_VARIANCE, NumericOutputField_FIRST_POINT, NumericOutputField_LAST_POINT}
}

func New_NumericOutputField(value NumericOutputField_Value) NumericOutputField {
	return NumericOutputField{val: value}
}

// IsUnknown returns false for all known variants of NumericOutputField and true otherwise.
func (e NumericOutputField) IsUnknown() bool {
	switch e.val {
	case NumericOutputField_MIN, NumericOutputField_MAX, NumericOutputField_MEAN, NumericOutputField_COUNT, NumericOutputField_VARIANCE, NumericOutputField_FIRST_POINT, NumericOutputField_LAST_POINT:
		return false
	}
	return true
}

func (e NumericOutputField) Value() NumericOutputField_Value {
	if e.IsUnknown() {
		return NumericOutputField_UNKNOWN
	}
	return e.val
}

func (e NumericOutputField) String() string {
	return string(e.val)
}

func (e NumericOutputField) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *NumericOutputField) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_NumericOutputField(NumericOutputField_Value(v))
	case "MIN":
		*e = New_NumericOutputField(NumericOutputField_MIN)
	case "MAX":
		*e = New_NumericOutputField(NumericOutputField_MAX)
	case "MEAN":
		*e = New_NumericOutputField(NumericOutputField_MEAN)
	case "COUNT":
		*e = New_NumericOutputField(NumericOutputField_COUNT)
	case "VARIANCE":
		*e = New_NumericOutputField(NumericOutputField_VARIANCE)
	case "FIRST_POINT":
		*e = New_NumericOutputField(NumericOutputField_FIRST_POINT)
	case "LAST_POINT":
		*e = New_NumericOutputField(NumericOutputField_LAST_POINT)
	}
	return nil
}

type NumericUnionOperation struct {
	val NumericUnionOperation_Value
}

type NumericUnionOperation_Value string

const (
	// Combines multiple points by taking the minimum value
	NumericUnionOperation_MIN NumericUnionOperation_Value = "MIN"
	// Combines multiple points by taking the maximum value
	NumericUnionOperation_MAX NumericUnionOperation_Value = "MAX"
	// Combines multiple points by taking the mean of the values
	NumericUnionOperation_MEAN NumericUnionOperation_Value = "MEAN"
	// Combines multiple points by taking the sum of the values
	NumericUnionOperation_SUM NumericUnionOperation_Value = "SUM"
	// Combines multiple points by taking the count of the values
	NumericUnionOperation_COUNT NumericUnionOperation_Value = "COUNT"
	// Combines multiple points by taking the standard deviation of the values
	NumericUnionOperation_STANDARD_DEVIATION NumericUnionOperation_Value = "STANDARD_DEVIATION"
	// Combines multiple points by taking the root mean square of the values
	NumericUnionOperation_ROOT_MEAN_SQUARE NumericUnionOperation_Value = "ROOT_MEAN_SQUARE"
	// Throws a DuplicateTimestamp error if two series contain points with a duplicate timestamp.
	NumericUnionOperation_THROW   NumericUnionOperation_Value = "THROW"
	NumericUnionOperation_UNKNOWN NumericUnionOperation_Value = "UNKNOWN"
)

// NumericUnionOperation_Values returns all known variants of NumericUnionOperation.
func NumericUnionOperation_Values() []NumericUnionOperation_Value {
	return []NumericUnionOperation_Value{NumericUnionOperation_MIN, NumericUnionOperation_MAX, NumericUnionOperation_MEAN, NumericUnionOperation_SUM, NumericUnionOperation_COUNT, NumericUnionOperation_STANDARD_DEVIATION, NumericUnionOperation_ROOT_MEAN_SQUARE, NumericUnionOperation_THROW}
}

func New_NumericUnionOperation(value NumericUnionOperation_Value) NumericUnionOperation {
	return NumericUnionOperation{val: value}
}

// IsUnknown returns false for all known variants of NumericUnionOperation and true otherwise.
func (e NumericUnionOperation) IsUnknown() bool {
	switch e.val {
	case NumericUnionOperation_MIN, NumericUnionOperation_MAX, NumericUnionOperation_MEAN, NumericUnionOperation_SUM, NumericUnionOperation_COUNT, NumericUnionOperation_STANDARD_DEVIATION, NumericUnionOperation_ROOT_MEAN_SQUARE, NumericUnionOperation_THROW:
		return false
	}
	return true
}

func (e NumericUnionOperation) Value() NumericUnionOperation_Value {
	if e.IsUnknown() {
		return NumericUnionOperation_UNKNOWN
	}
	return e.val
}

func (e NumericUnionOperation) String() string {
	return string(e.val)
}

func (e NumericUnionOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *NumericUnionOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_NumericUnionOperation(NumericUnionOperation_Value(v))
	case "MIN":
		*e = New_NumericUnionOperation(NumericUnionOperation_MIN)
	case "MAX":
		*e = New_NumericUnionOperation(NumericUnionOperation_MAX)
	case "MEAN":
		*e = New_NumericUnionOperation(NumericUnionOperation_MEAN)
	case "SUM":
		*e = New_NumericUnionOperation(NumericUnionOperation_SUM)
	case "COUNT":
		*e = New_NumericUnionOperation(NumericUnionOperation_COUNT)
	case "STANDARD_DEVIATION":
		*e = New_NumericUnionOperation(NumericUnionOperation_STANDARD_DEVIATION)
	case "ROOT_MEAN_SQUARE":
		*e = New_NumericUnionOperation(NumericUnionOperation_ROOT_MEAN_SQUARE)
	case "THROW":
		*e = New_NumericUnionOperation(NumericUnionOperation_THROW)
	}
	return nil
}

type OutputFormat struct {
	val OutputFormat_Value
}

type OutputFormat_Value string

const (
	OutputFormat_ARROW_V3 OutputFormat_Value = "ARROW_V3"
	OutputFormat_LEGACY   OutputFormat_Value = "LEGACY"
	OutputFormat_UNKNOWN  OutputFormat_Value = "UNKNOWN"
)

// OutputFormat_Values returns all known variants of OutputFormat.
func OutputFormat_Values() []OutputFormat_Value {
	return []OutputFormat_Value{OutputFormat_ARROW_V3, OutputFormat_LEGACY}
}

func New_OutputFormat(value OutputFormat_Value) OutputFormat {
	return OutputFormat{val: value}
}

// IsUnknown returns false for all known variants of OutputFormat and true otherwise.
func (e OutputFormat) IsUnknown() bool {
	switch e.val {
	case OutputFormat_ARROW_V3, OutputFormat_LEGACY:
		return false
	}
	return true
}

func (e OutputFormat) Value() OutputFormat_Value {
	if e.IsUnknown() {
		return OutputFormat_UNKNOWN
	}
	return e.val
}

func (e OutputFormat) String() string {
	return string(e.val)
}

func (e OutputFormat) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *OutputFormat) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_OutputFormat(OutputFormat_Value(v))
	case "ARROW_V3":
		*e = New_OutputFormat(OutputFormat_ARROW_V3)
	case "LEGACY":
		*e = New_OutputFormat(OutputFormat_LEGACY)
	}
	return nil
}

type OutputFrequencyType struct {
	val OutputFrequencyType_Value
}

type OutputFrequencyType_Value string

const (
	// Frequency in Hertz.
	OutputFrequencyType_LINEAR OutputFrequencyType_Value = "LINEAR"
	// Frequency in radians per second.
	OutputFrequencyType_ANGULAR OutputFrequencyType_Value = "ANGULAR"
	// Normalized frequency, in the range [0, 0.5] for real-valued signals.
	OutputFrequencyType_NORMALIZED_LINEAR OutputFrequencyType_Value = "NORMALIZED_LINEAR"
	// Normalized angular frequency, in the range [0, Ï€] for real-valued signals.
	OutputFrequencyType_NORMALIZED_ANGULAR OutputFrequencyType_Value = "NORMALIZED_ANGULAR"
	OutputFrequencyType_UNKNOWN            OutputFrequencyType_Value = "UNKNOWN"
)

// OutputFrequencyType_Values returns all known variants of OutputFrequencyType.
func OutputFrequencyType_Values() []OutputFrequencyType_Value {
	return []OutputFrequencyType_Value{OutputFrequencyType_LINEAR, OutputFrequencyType_ANGULAR, OutputFrequencyType_NORMALIZED_LINEAR, OutputFrequencyType_NORMALIZED_ANGULAR}
}

func New_OutputFrequencyType(value OutputFrequencyType_Value) OutputFrequencyType {
	return OutputFrequencyType{val: value}
}

// IsUnknown returns false for all known variants of OutputFrequencyType and true otherwise.
func (e OutputFrequencyType) IsUnknown() bool {
	switch e.val {
	case OutputFrequencyType_LINEAR, OutputFrequencyType_ANGULAR, OutputFrequencyType_NORMALIZED_LINEAR, OutputFrequencyType_NORMALIZED_ANGULAR:
		return false
	}
	return true
}

func (e OutputFrequencyType) Value() OutputFrequencyType_Value {
	if e.IsUnknown() {
		return OutputFrequencyType_UNKNOWN
	}
	return e.val
}

func (e OutputFrequencyType) String() string {
	return string(e.val)
}

func (e OutputFrequencyType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *OutputFrequencyType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_OutputFrequencyType(OutputFrequencyType_Value(v))
	case "LINEAR":
		*e = New_OutputFrequencyType(OutputFrequencyType_LINEAR)
	case "ANGULAR":
		*e = New_OutputFrequencyType(OutputFrequencyType_ANGULAR)
	case "NORMALIZED_LINEAR":
		*e = New_OutputFrequencyType(OutputFrequencyType_NORMALIZED_LINEAR)
	case "NORMALIZED_ANGULAR":
		*e = New_OutputFrequencyType(OutputFrequencyType_NORMALIZED_ANGULAR)
	}
	return nil
}

type OutputPhaseUnit struct {
	val OutputPhaseUnit_Value
}

type OutputPhaseUnit_Value string

const (
	OutputPhaseUnit_RADIANS OutputPhaseUnit_Value = "RADIANS"
	OutputPhaseUnit_DEGREES OutputPhaseUnit_Value = "DEGREES"
	OutputPhaseUnit_UNKNOWN OutputPhaseUnit_Value = "UNKNOWN"
)

// OutputPhaseUnit_Values returns all known variants of OutputPhaseUnit.
func OutputPhaseUnit_Values() []OutputPhaseUnit_Value {
	return []OutputPhaseUnit_Value{OutputPhaseUnit_RADIANS, OutputPhaseUnit_DEGREES}
}

func New_OutputPhaseUnit(value OutputPhaseUnit_Value) OutputPhaseUnit {
	return OutputPhaseUnit{val: value}
}

// IsUnknown returns false for all known variants of OutputPhaseUnit and true otherwise.
func (e OutputPhaseUnit) IsUnknown() bool {
	switch e.val {
	case OutputPhaseUnit_RADIANS, OutputPhaseUnit_DEGREES:
		return false
	}
	return true
}

func (e OutputPhaseUnit) Value() OutputPhaseUnit_Value {
	if e.IsUnknown() {
		return OutputPhaseUnit_UNKNOWN
	}
	return e.val
}

func (e OutputPhaseUnit) String() string {
	return string(e.val)
}

func (e OutputPhaseUnit) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *OutputPhaseUnit) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_OutputPhaseUnit(OutputPhaseUnit_Value(v))
	case "RADIANS":
		*e = New_OutputPhaseUnit(OutputPhaseUnit_RADIANS)
	case "DEGREES":
		*e = New_OutputPhaseUnit(OutputPhaseUnit_DEGREES)
	}
	return nil
}

type PeakType struct {
	val PeakType_Value
}

type PeakType_Value string

const (
	PeakType_PEAK    PeakType_Value = "PEAK"
	PeakType_TROUGH  PeakType_Value = "TROUGH"
	PeakType_BOTH    PeakType_Value = "BOTH"
	PeakType_UNKNOWN PeakType_Value = "UNKNOWN"
)

// PeakType_Values returns all known variants of PeakType.
func PeakType_Values() []PeakType_Value {
	return []PeakType_Value{PeakType_PEAK, PeakType_TROUGH, PeakType_BOTH}
}

func New_PeakType(value PeakType_Value) PeakType {
	return PeakType{val: value}
}

// IsUnknown returns false for all known variants of PeakType and true otherwise.
func (e PeakType) IsUnknown() bool {
	switch e.val {
	case PeakType_PEAK, PeakType_TROUGH, PeakType_BOTH:
		return false
	}
	return true
}

func (e PeakType) Value() PeakType_Value {
	if e.IsUnknown() {
		return PeakType_UNKNOWN
	}
	return e.val
}

func (e PeakType) String() string {
	return string(e.val)
}

func (e PeakType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *PeakType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_PeakType(PeakType_Value(v))
	case "PEAK":
		*e = New_PeakType(PeakType_PEAK)
	case "TROUGH":
		*e = New_PeakType(PeakType_TROUGH)
	case "BOTH":
		*e = New_PeakType(PeakType_BOTH)
	}
	return nil
}

type PeriodogramMethod struct {
	val PeriodogramMethod_Value
}

type PeriodogramMethod_Value string

const (
	PeriodogramMethod_WELCH_BLACKMAN PeriodogramMethod_Value = "WELCH_BLACKMAN"
	PeriodogramMethod_WELCH_HANN     PeriodogramMethod_Value = "WELCH_HANN"
	PeriodogramMethod_WELCH_HAMMING  PeriodogramMethod_Value = "WELCH_HAMMING"
	PeriodogramMethod_WELCH_RECT     PeriodogramMethod_Value = "WELCH_RECT"
	PeriodogramMethod_UNKNOWN        PeriodogramMethod_Value = "UNKNOWN"
)

// PeriodogramMethod_Values returns all known variants of PeriodogramMethod.
func PeriodogramMethod_Values() []PeriodogramMethod_Value {
	return []PeriodogramMethod_Value{PeriodogramMethod_WELCH_BLACKMAN, PeriodogramMethod_WELCH_HANN, PeriodogramMethod_WELCH_HAMMING, PeriodogramMethod_WELCH_RECT}
}

func New_PeriodogramMethod(value PeriodogramMethod_Value) PeriodogramMethod {
	return PeriodogramMethod{val: value}
}

// IsUnknown returns false for all known variants of PeriodogramMethod and true otherwise.
func (e PeriodogramMethod) IsUnknown() bool {
	switch e.val {
	case PeriodogramMethod_WELCH_BLACKMAN, PeriodogramMethod_WELCH_HANN, PeriodogramMethod_WELCH_HAMMING, PeriodogramMethod_WELCH_RECT:
		return false
	}
	return true
}

func (e PeriodogramMethod) Value() PeriodogramMethod_Value {
	if e.IsUnknown() {
		return PeriodogramMethod_UNKNOWN
	}
	return e.val
}

func (e PeriodogramMethod) String() string {
	return string(e.val)
}

func (e PeriodogramMethod) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *PeriodogramMethod) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_PeriodogramMethod(PeriodogramMethod_Value(v))
	case "WELCH_BLACKMAN":
		*e = New_PeriodogramMethod(PeriodogramMethod_WELCH_BLACKMAN)
	case "WELCH_HANN":
		*e = New_PeriodogramMethod(PeriodogramMethod_WELCH_HANN)
	case "WELCH_HAMMING":
		*e = New_PeriodogramMethod(PeriodogramMethod_WELCH_HAMMING)
	case "WELCH_RECT":
		*e = New_PeriodogramMethod(PeriodogramMethod_WELCH_RECT)
	}
	return nil
}

type RangePaddingConfiguration struct {
	val RangePaddingConfiguration_Value
}

type RangePaddingConfiguration_Value string

const (
	RangePaddingConfiguration_PAD_START         RangePaddingConfiguration_Value = "PAD_START"
	RangePaddingConfiguration_PAD_END           RangePaddingConfiguration_Value = "PAD_END"
	RangePaddingConfiguration_PAD_START_AND_END RangePaddingConfiguration_Value = "PAD_START_AND_END"
	RangePaddingConfiguration_UNKNOWN           RangePaddingConfiguration_Value = "UNKNOWN"
)

// RangePaddingConfiguration_Values returns all known variants of RangePaddingConfiguration.
func RangePaddingConfiguration_Values() []RangePaddingConfiguration_Value {
	return []RangePaddingConfiguration_Value{RangePaddingConfiguration_PAD_START, RangePaddingConfiguration_PAD_END, RangePaddingConfiguration_PAD_START_AND_END}
}

func New_RangePaddingConfiguration(value RangePaddingConfiguration_Value) RangePaddingConfiguration {
	return RangePaddingConfiguration{val: value}
}

// IsUnknown returns false for all known variants of RangePaddingConfiguration and true otherwise.
func (e RangePaddingConfiguration) IsUnknown() bool {
	switch e.val {
	case RangePaddingConfiguration_PAD_START, RangePaddingConfiguration_PAD_END, RangePaddingConfiguration_PAD_START_AND_END:
		return false
	}
	return true
}

func (e RangePaddingConfiguration) Value() RangePaddingConfiguration_Value {
	if e.IsUnknown() {
		return RangePaddingConfiguration_UNKNOWN
	}
	return e.val
}

func (e RangePaddingConfiguration) String() string {
	return string(e.val)
}

func (e RangePaddingConfiguration) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *RangePaddingConfiguration) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_RangePaddingConfiguration(RangePaddingConfiguration_Value(v))
	case "PAD_START":
		*e = New_RangePaddingConfiguration(RangePaddingConfiguration_PAD_START)
	case "PAD_END":
		*e = New_RangePaddingConfiguration(RangePaddingConfiguration_PAD_END)
	case "PAD_START_AND_END":
		*e = New_RangePaddingConfiguration(RangePaddingConfiguration_PAD_START_AND_END)
	}
	return nil
}

// Supported properties for REFPROP calculations
type RefpropProperty struct {
	val RefpropProperty_Value
}

type RefpropProperty_Value string

const (
	RefpropProperty_TEMPERATURE                   RefpropProperty_Value = "TEMPERATURE"
	RefpropProperty_PRESSURE                      RefpropProperty_Value = "PRESSURE"
	RefpropProperty_MASS_DENSITY                  RefpropProperty_Value = "MASS_DENSITY"
	RefpropProperty_MASS_SPECIFIC_ENTHALPY        RefpropProperty_Value = "MASS_SPECIFIC_ENTHALPY"
	RefpropProperty_MASS_SPECIFIC_INTERNAL_ENERGY RefpropProperty_Value = "MASS_SPECIFIC_INTERNAL_ENERGY"
	RefpropProperty_MASS_SPECIFIC_ENTROPY         RefpropProperty_Value = "MASS_SPECIFIC_ENTROPY"
	RefpropProperty_UNKNOWN                       RefpropProperty_Value = "UNKNOWN"
)

// RefpropProperty_Values returns all known variants of RefpropProperty.
func RefpropProperty_Values() []RefpropProperty_Value {
	return []RefpropProperty_Value{RefpropProperty_TEMPERATURE, RefpropProperty_PRESSURE, RefpropProperty_MASS_DENSITY, RefpropProperty_MASS_SPECIFIC_ENTHALPY, RefpropProperty_MASS_SPECIFIC_INTERNAL_ENERGY, RefpropProperty_MASS_SPECIFIC_ENTROPY}
}

func New_RefpropProperty(value RefpropProperty_Value) RefpropProperty {
	return RefpropProperty{val: value}
}

// IsUnknown returns false for all known variants of RefpropProperty and true otherwise.
func (e RefpropProperty) IsUnknown() bool {
	switch e.val {
	case RefpropProperty_TEMPERATURE, RefpropProperty_PRESSURE, RefpropProperty_MASS_DENSITY, RefpropProperty_MASS_SPECIFIC_ENTHALPY, RefpropProperty_MASS_SPECIFIC_INTERNAL_ENERGY, RefpropProperty_MASS_SPECIFIC_ENTROPY:
		return false
	}
	return true
}

func (e RefpropProperty) Value() RefpropProperty_Value {
	if e.IsUnknown() {
		return RefpropProperty_UNKNOWN
	}
	return e.val
}

func (e RefpropProperty) String() string {
	return string(e.val)
}

func (e RefpropProperty) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *RefpropProperty) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_RefpropProperty(RefpropProperty_Value(v))
	case "TEMPERATURE":
		*e = New_RefpropProperty(RefpropProperty_TEMPERATURE)
	case "PRESSURE":
		*e = New_RefpropProperty(RefpropProperty_PRESSURE)
	case "MASS_DENSITY":
		*e = New_RefpropProperty(RefpropProperty_MASS_DENSITY)
	case "MASS_SPECIFIC_ENTHALPY":
		*e = New_RefpropProperty(RefpropProperty_MASS_SPECIFIC_ENTHALPY)
	case "MASS_SPECIFIC_INTERNAL_ENERGY":
		*e = New_RefpropProperty(RefpropProperty_MASS_SPECIFIC_INTERNAL_ENERGY)
	case "MASS_SPECIFIC_ENTROPY":
		*e = New_RefpropProperty(RefpropProperty_MASS_SPECIFIC_ENTROPY)
	}
	return nil
}

// Supported substances for REFPROP calculations
type RefpropSubstance struct {
	val RefpropSubstance_Value
}

type RefpropSubstance_Value string

const (
	RefpropSubstance_NITROGEN RefpropSubstance_Value = "NITROGEN"
	RefpropSubstance_OXYGEN   RefpropSubstance_Value = "OXYGEN"
	RefpropSubstance_HELIUM   RefpropSubstance_Value = "HELIUM"
	RefpropSubstance_HYDROGEN RefpropSubstance_Value = "HYDROGEN"
	RefpropSubstance_METHANE  RefpropSubstance_Value = "METHANE"
	RefpropSubstance_PROPANE  RefpropSubstance_Value = "PROPANE"
	RefpropSubstance_BUTANE   RefpropSubstance_Value = "BUTANE"
	RefpropSubstance_WATER    RefpropSubstance_Value = "WATER"
	RefpropSubstance_XENON    RefpropSubstance_Value = "XENON"
	RefpropSubstance_AIR      RefpropSubstance_Value = "AIR"
	RefpropSubstance_UNKNOWN  RefpropSubstance_Value = "UNKNOWN"
)

// RefpropSubstance_Values returns all known variants of RefpropSubstance.
func RefpropSubstance_Values() []RefpropSubstance_Value {
	return []RefpropSubstance_Value{RefpropSubstance_NITROGEN, RefpropSubstance_OXYGEN, RefpropSubstance_HELIUM, RefpropSubstance_HYDROGEN, RefpropSubstance_METHANE, RefpropSubstance_PROPANE, RefpropSubstance_BUTANE, RefpropSubstance_WATER, RefpropSubstance_XENON, RefpropSubstance_AIR}
}

func New_RefpropSubstance(value RefpropSubstance_Value) RefpropSubstance {
	return RefpropSubstance{val: value}
}

// IsUnknown returns false for all known variants of RefpropSubstance and true otherwise.
func (e RefpropSubstance) IsUnknown() bool {
	switch e.val {
	case RefpropSubstance_NITROGEN, RefpropSubstance_OXYGEN, RefpropSubstance_HELIUM, RefpropSubstance_HYDROGEN, RefpropSubstance_METHANE, RefpropSubstance_PROPANE, RefpropSubstance_BUTANE, RefpropSubstance_WATER, RefpropSubstance_XENON, RefpropSubstance_AIR:
		return false
	}
	return true
}

func (e RefpropSubstance) Value() RefpropSubstance_Value {
	if e.IsUnknown() {
		return RefpropSubstance_UNKNOWN
	}
	return e.val
}

func (e RefpropSubstance) String() string {
	return string(e.val)
}

func (e RefpropSubstance) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *RefpropSubstance) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_RefpropSubstance(RefpropSubstance_Value(v))
	case "NITROGEN":
		*e = New_RefpropSubstance(RefpropSubstance_NITROGEN)
	case "OXYGEN":
		*e = New_RefpropSubstance(RefpropSubstance_OXYGEN)
	case "HELIUM":
		*e = New_RefpropSubstance(RefpropSubstance_HELIUM)
	case "HYDROGEN":
		*e = New_RefpropSubstance(RefpropSubstance_HYDROGEN)
	case "METHANE":
		*e = New_RefpropSubstance(RefpropSubstance_METHANE)
	case "PROPANE":
		*e = New_RefpropSubstance(RefpropSubstance_PROPANE)
	case "BUTANE":
		*e = New_RefpropSubstance(RefpropSubstance_BUTANE)
	case "WATER":
		*e = New_RefpropSubstance(RefpropSubstance_WATER)
	case "XENON":
		*e = New_RefpropSubstance(RefpropSubstance_XENON)
	case "AIR":
		*e = New_RefpropSubstance(RefpropSubstance_AIR)
	}
	return nil
}

type ScatterTemporalAggregation struct {
	val ScatterTemporalAggregation_Value
}

type ScatterTemporalAggregation_Value string

const (
	ScatterTemporalAggregation_MEAN    ScatterTemporalAggregation_Value = "MEAN"
	ScatterTemporalAggregation_MIN     ScatterTemporalAggregation_Value = "MIN"
	ScatterTemporalAggregation_MAX     ScatterTemporalAggregation_Value = "MAX"
	ScatterTemporalAggregation_FIRST   ScatterTemporalAggregation_Value = "FIRST"
	ScatterTemporalAggregation_LAST    ScatterTemporalAggregation_Value = "LAST"
	ScatterTemporalAggregation_UNKNOWN ScatterTemporalAggregation_Value = "UNKNOWN"
)

// ScatterTemporalAggregation_Values returns all known variants of ScatterTemporalAggregation.
func ScatterTemporalAggregation_Values() []ScatterTemporalAggregation_Value {
	return []ScatterTemporalAggregation_Value{ScatterTemporalAggregation_MEAN, ScatterTemporalAggregation_MIN, ScatterTemporalAggregation_MAX, ScatterTemporalAggregation_FIRST, ScatterTemporalAggregation_LAST}
}

func New_ScatterTemporalAggregation(value ScatterTemporalAggregation_Value) ScatterTemporalAggregation {
	return ScatterTemporalAggregation{val: value}
}

// IsUnknown returns false for all known variants of ScatterTemporalAggregation and true otherwise.
func (e ScatterTemporalAggregation) IsUnknown() bool {
	switch e.val {
	case ScatterTemporalAggregation_MEAN, ScatterTemporalAggregation_MIN, ScatterTemporalAggregation_MAX, ScatterTemporalAggregation_FIRST, ScatterTemporalAggregation_LAST:
		return false
	}
	return true
}

func (e ScatterTemporalAggregation) Value() ScatterTemporalAggregation_Value {
	if e.IsUnknown() {
		return ScatterTemporalAggregation_UNKNOWN
	}
	return e.val
}

func (e ScatterTemporalAggregation) String() string {
	return string(e.val)
}

func (e ScatterTemporalAggregation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *ScatterTemporalAggregation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_ScatterTemporalAggregation(ScatterTemporalAggregation_Value(v))
	case "MEAN":
		*e = New_ScatterTemporalAggregation(ScatterTemporalAggregation_MEAN)
	case "MIN":
		*e = New_ScatterTemporalAggregation(ScatterTemporalAggregation_MIN)
	case "MAX":
		*e = New_ScatterTemporalAggregation(ScatterTemporalAggregation_MAX)
	case "FIRST":
		*e = New_ScatterTemporalAggregation(ScatterTemporalAggregation_FIRST)
	case "LAST":
		*e = New_ScatterTemporalAggregation(ScatterTemporalAggregation_LAST)
	}
	return nil
}

type TagFilterOperator struct {
	val TagFilterOperator_Value
}

type TagFilterOperator_Value string

const (
	TagFilterOperator_IN      TagFilterOperator_Value = "IN"
	TagFilterOperator_NOT_IN  TagFilterOperator_Value = "NOT_IN"
	TagFilterOperator_UNKNOWN TagFilterOperator_Value = "UNKNOWN"
)

// TagFilterOperator_Values returns all known variants of TagFilterOperator.
func TagFilterOperator_Values() []TagFilterOperator_Value {
	return []TagFilterOperator_Value{TagFilterOperator_IN, TagFilterOperator_NOT_IN}
}

func New_TagFilterOperator(value TagFilterOperator_Value) TagFilterOperator {
	return TagFilterOperator{val: value}
}

// IsUnknown returns false for all known variants of TagFilterOperator and true otherwise.
func (e TagFilterOperator) IsUnknown() bool {
	switch e.val {
	case TagFilterOperator_IN, TagFilterOperator_NOT_IN:
		return false
	}
	return true
}

func (e TagFilterOperator) Value() TagFilterOperator_Value {
	if e.IsUnknown() {
		return TagFilterOperator_UNKNOWN
	}
	return e.val
}

func (e TagFilterOperator) String() string {
	return string(e.val)
}

func (e TagFilterOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *TagFilterOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_TagFilterOperator(TagFilterOperator_Value(v))
	case "IN":
		*e = New_TagFilterOperator(TagFilterOperator_IN)
	case "NOT_IN":
		*e = New_TagFilterOperator(TagFilterOperator_NOT_IN)
	}
	return nil
}

type TagFilterValidationErrorType struct {
	val TagFilterValidationErrorType_Value
}

type TagFilterValidationErrorType_Value string

const (
	TagFilterValidationErrorType_BOTH_TAGS_AND_TAG_FILTERS_PROVIDED TagFilterValidationErrorType_Value = "BOTH_TAGS_AND_TAG_FILTERS_PROVIDED"
	TagFilterValidationErrorType_EMPTY_FILTER_LIST                  TagFilterValidationErrorType_Value = "EMPTY_FILTER_LIST"
	TagFilterValidationErrorType_EMPTY_TAG_VALUE_SET                TagFilterValidationErrorType_Value = "EMPTY_TAG_VALUE_SET"
	TagFilterValidationErrorType_NESTED_AND_OPERATIONS              TagFilterValidationErrorType_Value = "NESTED_AND_OPERATIONS"
	TagFilterValidationErrorType_DUPLICATE_TAG_KEY                  TagFilterValidationErrorType_Value = "DUPLICATE_TAG_KEY"
	TagFilterValidationErrorType_UNKNOWN                            TagFilterValidationErrorType_Value = "UNKNOWN"
)

// TagFilterValidationErrorType_Values returns all known variants of TagFilterValidationErrorType.
func TagFilterValidationErrorType_Values() []TagFilterValidationErrorType_Value {
	return []TagFilterValidationErrorType_Value{TagFilterValidationErrorType_BOTH_TAGS_AND_TAG_FILTERS_PROVIDED, TagFilterValidationErrorType_EMPTY_FILTER_LIST, TagFilterValidationErrorType_EMPTY_TAG_VALUE_SET, TagFilterValidationErrorType_NESTED_AND_OPERATIONS, TagFilterValidationErrorType_DUPLICATE_TAG_KEY}
}

func New_TagFilterValidationErrorType(value TagFilterValidationErrorType_Value) TagFilterValidationErrorType {
	return TagFilterValidationErrorType{val: value}
}

// IsUnknown returns false for all known variants of TagFilterValidationErrorType and true otherwise.
func (e TagFilterValidationErrorType) IsUnknown() bool {
	switch e.val {
	case TagFilterValidationErrorType_BOTH_TAGS_AND_TAG_FILTERS_PROVIDED, TagFilterValidationErrorType_EMPTY_FILTER_LIST, TagFilterValidationErrorType_EMPTY_TAG_VALUE_SET, TagFilterValidationErrorType_NESTED_AND_OPERATIONS, TagFilterValidationErrorType_DUPLICATE_TAG_KEY:
		return false
	}
	return true
}

func (e TagFilterValidationErrorType) Value() TagFilterValidationErrorType_Value {
	if e.IsUnknown() {
		return TagFilterValidationErrorType_UNKNOWN
	}
	return e.val
}

func (e TagFilterValidationErrorType) String() string {
	return string(e.val)
}

func (e TagFilterValidationErrorType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *TagFilterValidationErrorType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_Value(v))
	case "BOTH_TAGS_AND_TAG_FILTERS_PROVIDED":
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_BOTH_TAGS_AND_TAG_FILTERS_PROVIDED)
	case "EMPTY_FILTER_LIST":
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_EMPTY_FILTER_LIST)
	case "EMPTY_TAG_VALUE_SET":
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_EMPTY_TAG_VALUE_SET)
	case "NESTED_AND_OPERATIONS":
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_NESTED_AND_OPERATIONS)
	case "DUPLICATE_TAG_KEY":
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_DUPLICATE_TAG_KEY)
	}
	return nil
}

type ThresholdOperator struct {
	val ThresholdOperator_Value
}

type ThresholdOperator_Value string

const (
	ThresholdOperator_GREATER_THAN             ThresholdOperator_Value = "GREATER_THAN"
	ThresholdOperator_GREATER_THAN_OR_EQUAL_TO ThresholdOperator_Value = "GREATER_THAN_OR_EQUAL_TO"
	ThresholdOperator_LESS_THAN                ThresholdOperator_Value = "LESS_THAN"
	ThresholdOperator_LESS_THAN_OR_EQUAL_TO    ThresholdOperator_Value = "LESS_THAN_OR_EQUAL_TO"
	ThresholdOperator_EQUAL_TO                 ThresholdOperator_Value = "EQUAL_TO"
	ThresholdOperator_NOT_EQUAL_TO             ThresholdOperator_Value = "NOT_EQUAL_TO"
	ThresholdOperator_UNKNOWN                  ThresholdOperator_Value = "UNKNOWN"
)

// ThresholdOperator_Values returns all known variants of ThresholdOperator.
func ThresholdOperator_Values() []ThresholdOperator_Value {
	return []ThresholdOperator_Value{ThresholdOperator_GREATER_THAN, ThresholdOperator_GREATER_THAN_OR_EQUAL_TO, ThresholdOperator_LESS_THAN, ThresholdOperator_LESS_THAN_OR_EQUAL_TO, ThresholdOperator_EQUAL_TO, ThresholdOperator_NOT_EQUAL_TO}
}

func New_ThresholdOperator(value ThresholdOperator_Value) ThresholdOperator {
	return ThresholdOperator{val: value}
}

// IsUnknown returns false for all known variants of ThresholdOperator and true otherwise.
func (e ThresholdOperator) IsUnknown() bool {
	switch e.val {
	case ThresholdOperator_GREATER_THAN, ThresholdOperator_GREATER_THAN_OR_EQUAL_TO, ThresholdOperator_LESS_THAN, ThresholdOperator_LESS_THAN_OR_EQUAL_TO, ThresholdOperator_EQUAL_TO, ThresholdOperator_NOT_EQUAL_TO:
		return false
	}
	return true
}

func (e ThresholdOperator) Value() ThresholdOperator_Value {
	if e.IsUnknown() {
		return ThresholdOperator_UNKNOWN
	}
	return e.val
}

func (e ThresholdOperator) String() string {
	return string(e.val)
}

func (e ThresholdOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *ThresholdOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_ThresholdOperator(ThresholdOperator_Value(v))
	case "GREATER_THAN":
		*e = New_ThresholdOperator(ThresholdOperator_GREATER_THAN)
	case "GREATER_THAN_OR_EQUAL_TO":
		*e = New_ThresholdOperator(ThresholdOperator_GREATER_THAN_OR_EQUAL_TO)
	case "LESS_THAN":
		*e = New_ThresholdOperator(ThresholdOperator_LESS_THAN)
	case "LESS_THAN_OR_EQUAL_TO":
		*e = New_ThresholdOperator(ThresholdOperator_LESS_THAN_OR_EQUAL_TO)
	case "EQUAL_TO":
		*e = New_ThresholdOperator(ThresholdOperator_EQUAL_TO)
	case "NOT_EQUAL_TO":
		*e = New_ThresholdOperator(ThresholdOperator_NOT_EQUAL_TO)
	}
	return nil
}

type UnaryArithmeticOperation struct {
	val UnaryArithmeticOperation_Value
}

type UnaryArithmeticOperation_Value string

const (
	// Calculates the trigonometric cosine
	UnaryArithmeticOperation_COS UnaryArithmeticOperation_Value = "COS"
	// Calculates the trigonometric sine
	UnaryArithmeticOperation_SIN UnaryArithmeticOperation_Value = "SIN"
	// Calculates the trigonometric tangent
	UnaryArithmeticOperation_TAN UnaryArithmeticOperation_Value = "TAN"
	// Calculates the absolute value
	UnaryArithmeticOperation_ABS UnaryArithmeticOperation_Value = "ABS"
	// Calculates the arcsin in radians
	UnaryArithmeticOperation_ASIN UnaryArithmeticOperation_Value = "ASIN"
	// Calculates the arccos in radians
	UnaryArithmeticOperation_ACOS UnaryArithmeticOperation_Value = "ACOS"
	// Calculates the base 10 logarithm
	UnaryArithmeticOperation_LOG UnaryArithmeticOperation_Value = "LOG"
	// Calculates the natural logarithm
	UnaryArithmeticOperation_LN UnaryArithmeticOperation_Value = "LN"
	// Calculates the square root
	UnaryArithmeticOperation_SQRT    UnaryArithmeticOperation_Value = "SQRT"
	UnaryArithmeticOperation_UNKNOWN UnaryArithmeticOperation_Value = "UNKNOWN"
)

// UnaryArithmeticOperation_Values returns all known variants of UnaryArithmeticOperation.
func UnaryArithmeticOperation_Values() []UnaryArithmeticOperation_Value {
	return []UnaryArithmeticOperation_Value{UnaryArithmeticOperation_COS, UnaryArithmeticOperation_SIN, UnaryArithmeticOperation_TAN, UnaryArithmeticOperation_ABS, UnaryArithmeticOperation_ASIN, UnaryArithmeticOperation_ACOS, UnaryArithmeticOperation_LOG, UnaryArithmeticOperation_LN, UnaryArithmeticOperation_SQRT}
}

func New_UnaryArithmeticOperation(value UnaryArithmeticOperation_Value) UnaryArithmeticOperation {
	return UnaryArithmeticOperation{val: value}
}

// IsUnknown returns false for all known variants of UnaryArithmeticOperation and true otherwise.
func (e UnaryArithmeticOperation) IsUnknown() bool {
	switch e.val {
	case UnaryArithmeticOperation_COS, UnaryArithmeticOperation_SIN, UnaryArithmeticOperation_TAN, UnaryArithmeticOperation_ABS, UnaryArithmeticOperation_ASIN, UnaryArithmeticOperation_ACOS, UnaryArithmeticOperation_LOG, UnaryArithmeticOperation_LN, UnaryArithmeticOperation_SQRT:
		return false
	}
	return true
}

func (e UnaryArithmeticOperation) Value() UnaryArithmeticOperation_Value {
	if e.IsUnknown() {
		return UnaryArithmeticOperation_UNKNOWN
	}
	return e.val
}

func (e UnaryArithmeticOperation) String() string {
	return string(e.val)
}

func (e UnaryArithmeticOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *UnaryArithmeticOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_Value(v))
	case "COS":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_COS)
	case "SIN":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_SIN)
	case "TAN":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_TAN)
	case "ABS":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_ABS)
	case "ASIN":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_ASIN)
	case "ACOS":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_ACOS)
	case "LOG":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_LOG)
	case "LN":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_LN)
	case "SQRT":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_SQRT)
	}
	return nil
}

// Dictates how empty range bounds should be handled by the compute node. Defaults to INFINITY.
type UnboundedBehavior struct {
	val UnboundedBehavior_Value
}

type UnboundedBehavior_Value string

const (
	UnboundedBehavior_INFINITY     UnboundedBehavior_Value = "INFINITY"
	UnboundedBehavior_WINDOW_BOUND UnboundedBehavior_Value = "WINDOW_BOUND"
	UnboundedBehavior_UNKNOWN      UnboundedBehavior_Value = "UNKNOWN"
)

// UnboundedBehavior_Values returns all known variants of UnboundedBehavior.
func UnboundedBehavior_Values() []UnboundedBehavior_Value {
	return []UnboundedBehavior_Value{UnboundedBehavior_INFINITY, UnboundedBehavior_WINDOW_BOUND}
}

func New_UnboundedBehavior(value UnboundedBehavior_Value) UnboundedBehavior {
	return UnboundedBehavior{val: value}
}

// IsUnknown returns false for all known variants of UnboundedBehavior and true otherwise.
func (e UnboundedBehavior) IsUnknown() bool {
	switch e.val {
	case UnboundedBehavior_INFINITY, UnboundedBehavior_WINDOW_BOUND:
		return false
	}
	return true
}

func (e UnboundedBehavior) Value() UnboundedBehavior_Value {
	if e.IsUnknown() {
		return UnboundedBehavior_UNKNOWN
	}
	return e.val
}

func (e UnboundedBehavior) String() string {
	return string(e.val)
}

func (e UnboundedBehavior) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *UnboundedBehavior) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_UnboundedBehavior(UnboundedBehavior_Value(v))
	case "INFINITY":
		*e = New_UnboundedBehavior(UnboundedBehavior_INFINITY)
	case "WINDOW_BOUND":
		*e = New_UnboundedBehavior(UnboundedBehavior_WINDOW_BOUND)
	}
	return nil
}

type UnitOperation struct {
	val UnitOperation_Value
}

type UnitOperation_Value string

const (
	UnitOperation_UNIT_AS_EXPONENT        UnitOperation_Value = "UNIT_AS_EXPONENT"
	UnitOperation_NON_INTEGER_AS_EXPONENT UnitOperation_Value = "NON_INTEGER_AS_EXPONENT"
	UnitOperation_FLOOR_DIVISION          UnitOperation_Value = "FLOOR_DIVISION"
	UnitOperation_MODULO                  UnitOperation_Value = "MODULO"
	UnitOperation_CROSSOVER_COMPARISON    UnitOperation_Value = "CROSSOVER_COMPARISON"
	UnitOperation_MAX                     UnitOperation_Value = "MAX"
	UnitOperation_MIN                     UnitOperation_Value = "MIN"
	UnitOperation_MEAN                    UnitOperation_Value = "MEAN"
	UnitOperation_UNION                   UnitOperation_Value = "UNION"
	UnitOperation_ADDITION                UnitOperation_Value = "ADDITION"
	UnitOperation_SUBTRACTION             UnitOperation_Value = "SUBTRACTION"
	UnitOperation_UNIT_CONVERSION         UnitOperation_Value = "UNIT_CONVERSION"
	UnitOperation_COMPARISON              UnitOperation_Value = "COMPARISON"
	UnitOperation_TERNARY_OPERATOR        UnitOperation_Value = "TERNARY_OPERATOR"
	UnitOperation_UNKNOWN                 UnitOperation_Value = "UNKNOWN"
)

// UnitOperation_Values returns all known variants of UnitOperation.
func UnitOperation_Values() []UnitOperation_Value {
	return []UnitOperation_Value{UnitOperation_UNIT_AS_EXPONENT, UnitOperation_NON_INTEGER_AS_EXPONENT, UnitOperation_FLOOR_DIVISION, UnitOperation_MODULO, UnitOperation_CROSSOVER_COMPARISON, UnitOperation_MAX, UnitOperation_MIN, UnitOperation_MEAN, UnitOperation_UNION, UnitOperation_ADDITION, UnitOperation_SUBTRACTION, UnitOperation_UNIT_CONVERSION, UnitOperation_COMPARISON, UnitOperation_TERNARY_OPERATOR}
}

func New_UnitOperation(value UnitOperation_Value) UnitOperation {
	return UnitOperation{val: value}
}

// IsUnknown returns false for all known variants of UnitOperation and true otherwise.
func (e UnitOperation) IsUnknown() bool {
	switch e.val {
	case UnitOperation_UNIT_AS_EXPONENT, UnitOperation_NON_INTEGER_AS_EXPONENT, UnitOperation_FLOOR_DIVISION, UnitOperation_MODULO, UnitOperation_CROSSOVER_COMPARISON, UnitOperation_MAX, UnitOperation_MIN, UnitOperation_MEAN, UnitOperation_UNION, UnitOperation_ADDITION, UnitOperation_SUBTRACTION, UnitOperation_UNIT_CONVERSION, UnitOperation_COMPARISON, UnitOperation_TERNARY_OPERATOR:
		return false
	}
	return true
}

func (e UnitOperation) Value() UnitOperation_Value {
	if e.IsUnknown() {
		return UnitOperation_UNKNOWN
	}
	return e.val
}

func (e UnitOperation) String() string {
	return string(e.val)
}

func (e UnitOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *UnitOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_UnitOperation(UnitOperation_Value(v))
	case "UNIT_AS_EXPONENT":
		*e = New_UnitOperation(UnitOperation_UNIT_AS_EXPONENT)
	case "NON_INTEGER_AS_EXPONENT":
		*e = New_UnitOperation(UnitOperation_NON_INTEGER_AS_EXPONENT)
	case "FLOOR_DIVISION":
		*e = New_UnitOperation(UnitOperation_FLOOR_DIVISION)
	case "MODULO":
		*e = New_UnitOperation(UnitOperation_MODULO)
	case "CROSSOVER_COMPARISON":
		*e = New_UnitOperation(UnitOperation_CROSSOVER_COMPARISON)
	case "MAX":
		*e = New_UnitOperation(UnitOperation_MAX)
	case "MIN":
		*e = New_UnitOperation(UnitOperation_MIN)
	case "MEAN":
		*e = New_UnitOperation(UnitOperation_MEAN)
	case "UNION":
		*e = New_UnitOperation(UnitOperation_UNION)
	case "ADDITION":
		*e = New_UnitOperation(UnitOperation_ADDITION)
	case "SUBTRACTION":
		*e = New_UnitOperation(UnitOperation_SUBTRACTION)
	case "UNIT_CONVERSION":
		*e = New_UnitOperation(UnitOperation_UNIT_CONVERSION)
	case "COMPARISON":
		*e = New_UnitOperation(UnitOperation_COMPARISON)
	case "TERNARY_OPERATOR":
		*e = New_UnitOperation(UnitOperation_TERNARY_OPERATOR)
	}
	return nil
}

type ValueStrategy struct {
	val ValueStrategy_Value
}

type ValueStrategy_Value string

const (
	ValueStrategy_FIRST   ValueStrategy_Value = "FIRST"
	ValueStrategy_LAST    ValueStrategy_Value = "LAST"
	ValueStrategy_UNKNOWN ValueStrategy_Value = "UNKNOWN"
)

// ValueStrategy_Values returns all known variants of ValueStrategy.
func ValueStrategy_Values() []ValueStrategy_Value {
	return []ValueStrategy_Value{ValueStrategy_FIRST, ValueStrategy_LAST}
}

func New_ValueStrategy(value ValueStrategy_Value) ValueStrategy {
	return ValueStrategy{val: value}
}

// IsUnknown returns false for all known variants of ValueStrategy and true otherwise.
func (e ValueStrategy) IsUnknown() bool {
	switch e.val {
	case ValueStrategy_FIRST, ValueStrategy_LAST:
		return false
	}
	return true
}

func (e ValueStrategy) Value() ValueStrategy_Value {
	if e.IsUnknown() {
		return ValueStrategy_UNKNOWN
	}
	return e.val
}

func (e ValueStrategy) String() string {
	return string(e.val)
}

func (e ValueStrategy) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *ValueStrategy) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_ValueStrategy(ValueStrategy_Value(v))
	case "FIRST":
		*e = New_ValueStrategy(ValueStrategy_FIRST)
	case "LAST":
		*e = New_ValueStrategy(ValueStrategy_LAST)
	}
	return nil
}

type WindowSymmetry struct {
	val WindowSymmetry_Value
}

type WindowSymmetry_Value string

const (
	// Generates dft-even/periodic window values.
	WindowSymmetry_DFT_EVEN WindowSymmetry_Value = "DFT_EVEN"
	// Generates symmetric window values.
	WindowSymmetry_SYMMETRIC WindowSymmetry_Value = "SYMMETRIC"
	WindowSymmetry_UNKNOWN   WindowSymmetry_Value = "UNKNOWN"
)

// WindowSymmetry_Values returns all known variants of WindowSymmetry.
func WindowSymmetry_Values() []WindowSymmetry_Value {
	return []WindowSymmetry_Value{WindowSymmetry_DFT_EVEN, WindowSymmetry_SYMMETRIC}
}

func New_WindowSymmetry(value WindowSymmetry_Value) WindowSymmetry {
	return WindowSymmetry{val: value}
}

// IsUnknown returns false for all known variants of WindowSymmetry and true otherwise.
func (e WindowSymmetry) IsUnknown() bool {
	switch e.val {
	case WindowSymmetry_DFT_EVEN, WindowSymmetry_SYMMETRIC:
		return false
	}
	return true
}

func (e WindowSymmetry) Value() WindowSymmetry_Value {
	if e.IsUnknown() {
		return WindowSymmetry_UNKNOWN
	}
	return e.val
}

func (e WindowSymmetry) String() string {
	return string(e.val)
}

func (e WindowSymmetry) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *WindowSymmetry) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_WindowSymmetry(WindowSymmetry_Value(v))
	case "DFT_EVEN":
		*e = New_WindowSymmetry(WindowSymmetry_DFT_EVEN)
	case "SYMMETRIC":
		*e = New_WindowSymmetry(WindowSymmetry_SYMMETRIC)
	}
	return nil
}
