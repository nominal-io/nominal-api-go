// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"strings"
)

type ApproximateThresholdOperator struct {
	val ApproximateThresholdOperator_Value
}

type ApproximateThresholdOperator_Value string

const (
	ApproximateThresholdOperator_EQUAL_TO     ApproximateThresholdOperator_Value = "EQUAL_TO"
	ApproximateThresholdOperator_NOT_EQUAL_TO ApproximateThresholdOperator_Value = "NOT_EQUAL_TO"
	ApproximateThresholdOperator_UNKNOWN      ApproximateThresholdOperator_Value = "UNKNOWN"
)

// ApproximateThresholdOperator_Values returns all known variants of ApproximateThresholdOperator.
func ApproximateThresholdOperator_Values() []ApproximateThresholdOperator_Value {
	return []ApproximateThresholdOperator_Value{ApproximateThresholdOperator_EQUAL_TO, ApproximateThresholdOperator_NOT_EQUAL_TO}
}

func New_ApproximateThresholdOperator(value ApproximateThresholdOperator_Value) ApproximateThresholdOperator {
	return ApproximateThresholdOperator{val: value}
}

// IsUnknown returns false for all known variants of ApproximateThresholdOperator and true otherwise.
func (e ApproximateThresholdOperator) IsUnknown() bool {
	switch e.val {
	case ApproximateThresholdOperator_EQUAL_TO, ApproximateThresholdOperator_NOT_EQUAL_TO:
		return false
	}
	return true
}

func (e ApproximateThresholdOperator) Value() ApproximateThresholdOperator_Value {
	if e.IsUnknown() {
		return ApproximateThresholdOperator_UNKNOWN
	}
	return e.val
}

func (e ApproximateThresholdOperator) String() string {
	return string(e.val)
}

func (e ApproximateThresholdOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *ApproximateThresholdOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_ApproximateThresholdOperator(ApproximateThresholdOperator_Value(v))
	case "EQUAL_TO":
		*e = New_ApproximateThresholdOperator(ApproximateThresholdOperator_EQUAL_TO)
	case "NOT_EQUAL_TO":
		*e = New_ApproximateThresholdOperator(ApproximateThresholdOperator_NOT_EQUAL_TO)
	}
	return nil
}

type BinaryArithmeticOperation struct {
	val BinaryArithmeticOperation_Value
}

type BinaryArithmeticOperation_Value string

const (
	/*
	   Calculates the angle measure between the x-axis and a ray from the origin to a point (input2, input1)
	   in radians.
	   Note the order of arguments.
	*/
	BinaryArithmeticOperation_ATAN2   BinaryArithmeticOperation_Value = "ATAN2"
	BinaryArithmeticOperation_UNKNOWN BinaryArithmeticOperation_Value = "UNKNOWN"
)

// BinaryArithmeticOperation_Values returns all known variants of BinaryArithmeticOperation.
func BinaryArithmeticOperation_Values() []BinaryArithmeticOperation_Value {
	return []BinaryArithmeticOperation_Value{BinaryArithmeticOperation_ATAN2}
}

func New_BinaryArithmeticOperation(value BinaryArithmeticOperation_Value) BinaryArithmeticOperation {
	return BinaryArithmeticOperation{val: value}
}

// IsUnknown returns false for all known variants of BinaryArithmeticOperation and true otherwise.
func (e BinaryArithmeticOperation) IsUnknown() bool {
	switch e.val {
	case BinaryArithmeticOperation_ATAN2:
		return false
	}
	return true
}

func (e BinaryArithmeticOperation) Value() BinaryArithmeticOperation_Value {
	if e.IsUnknown() {
		return BinaryArithmeticOperation_UNKNOWN
	}
	return e.val
}

func (e BinaryArithmeticOperation) String() string {
	return string(e.val)
}

func (e BinaryArithmeticOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *BinaryArithmeticOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_BinaryArithmeticOperation(BinaryArithmeticOperation_Value(v))
	case "ATAN2":
		*e = New_BinaryArithmeticOperation(BinaryArithmeticOperation_ATAN2)
	}
	return nil
}

type DriverSeries3d struct {
	val DriverSeries3d_Value
}

type DriverSeries3d_Value string

const (
	DriverSeries3d_X       DriverSeries3d_Value = "X"
	DriverSeries3d_Y       DriverSeries3d_Value = "Y"
	DriverSeries3d_Z       DriverSeries3d_Value = "Z"
	DriverSeries3d_UNKNOWN DriverSeries3d_Value = "UNKNOWN"
)

// DriverSeries3d_Values returns all known variants of DriverSeries3d.
func DriverSeries3d_Values() []DriverSeries3d_Value {
	return []DriverSeries3d_Value{DriverSeries3d_X, DriverSeries3d_Y, DriverSeries3d_Z}
}

func New_DriverSeries3d(value DriverSeries3d_Value) DriverSeries3d {
	return DriverSeries3d{val: value}
}

// IsUnknown returns false for all known variants of DriverSeries3d and true otherwise.
func (e DriverSeries3d) IsUnknown() bool {
	switch e.val {
	case DriverSeries3d_X, DriverSeries3d_Y, DriverSeries3d_Z:
		return false
	}
	return true
}

func (e DriverSeries3d) Value() DriverSeries3d_Value {
	if e.IsUnknown() {
		return DriverSeries3d_UNKNOWN
	}
	return e.val
}

func (e DriverSeries3d) String() string {
	return string(e.val)
}

func (e DriverSeries3d) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *DriverSeries3d) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_DriverSeries3d(DriverSeries3d_Value(v))
	case "X":
		*e = New_DriverSeries3d(DriverSeries3d_X)
	case "Y":
		*e = New_DriverSeries3d(DriverSeries3d_Y)
	case "Z":
		*e = New_DriverSeries3d(DriverSeries3d_Z)
	}
	return nil
}

type EnumAggregationFunction struct {
	val EnumAggregationFunction_Value
}

type EnumAggregationFunction_Value string

const (
	EnumAggregationFunction_MIN     EnumAggregationFunction_Value = "MIN"
	EnumAggregationFunction_MAX     EnumAggregationFunction_Value = "MAX"
	EnumAggregationFunction_UNKNOWN EnumAggregationFunction_Value = "UNKNOWN"
)

// EnumAggregationFunction_Values returns all known variants of EnumAggregationFunction.
func EnumAggregationFunction_Values() []EnumAggregationFunction_Value {
	return []EnumAggregationFunction_Value{EnumAggregationFunction_MIN, EnumAggregationFunction_MAX}
}

func New_EnumAggregationFunction(value EnumAggregationFunction_Value) EnumAggregationFunction {
	return EnumAggregationFunction{val: value}
}

// IsUnknown returns false for all known variants of EnumAggregationFunction and true otherwise.
func (e EnumAggregationFunction) IsUnknown() bool {
	switch e.val {
	case EnumAggregationFunction_MIN, EnumAggregationFunction_MAX:
		return false
	}
	return true
}

func (e EnumAggregationFunction) Value() EnumAggregationFunction_Value {
	if e.IsUnknown() {
		return EnumAggregationFunction_UNKNOWN
	}
	return e.val
}

func (e EnumAggregationFunction) String() string {
	return string(e.val)
}

func (e EnumAggregationFunction) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EnumAggregationFunction) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EnumAggregationFunction(EnumAggregationFunction_Value(v))
	case "MIN":
		*e = New_EnumAggregationFunction(EnumAggregationFunction_MIN)
	case "MAX":
		*e = New_EnumAggregationFunction(EnumAggregationFunction_MAX)
	}
	return nil
}

type EnumFilterOperator struct {
	val EnumFilterOperator_Value
}

type EnumFilterOperator_Value string

const (
	EnumFilterOperator_IS_IN     EnumFilterOperator_Value = "IS_IN"
	EnumFilterOperator_IS_NOT_IN EnumFilterOperator_Value = "IS_NOT_IN"
	EnumFilterOperator_UNKNOWN   EnumFilterOperator_Value = "UNKNOWN"
)

// EnumFilterOperator_Values returns all known variants of EnumFilterOperator.
func EnumFilterOperator_Values() []EnumFilterOperator_Value {
	return []EnumFilterOperator_Value{EnumFilterOperator_IS_IN, EnumFilterOperator_IS_NOT_IN}
}

func New_EnumFilterOperator(value EnumFilterOperator_Value) EnumFilterOperator {
	return EnumFilterOperator{val: value}
}

// IsUnknown returns false for all known variants of EnumFilterOperator and true otherwise.
func (e EnumFilterOperator) IsUnknown() bool {
	switch e.val {
	case EnumFilterOperator_IS_IN, EnumFilterOperator_IS_NOT_IN:
		return false
	}
	return true
}

func (e EnumFilterOperator) Value() EnumFilterOperator_Value {
	if e.IsUnknown() {
		return EnumFilterOperator_UNKNOWN
	}
	return e.val
}

func (e EnumFilterOperator) String() string {
	return string(e.val)
}

func (e EnumFilterOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EnumFilterOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EnumFilterOperator(EnumFilterOperator_Value(v))
	case "IS_IN":
		*e = New_EnumFilterOperator(EnumFilterOperator_IS_IN)
	case "IS_NOT_IN":
		*e = New_EnumFilterOperator(EnumFilterOperator_IS_NOT_IN)
	}
	return nil
}

type EnumUnionOperation struct {
	val EnumUnionOperation_Value
}

type EnumUnionOperation_Value string

const (
	// Throws an exception if two series contain points with a duplicate timestamp.
	EnumUnionOperation_THROW EnumUnionOperation_Value = "THROW"
	// Aggregates duplicates by String MAX.
	EnumUnionOperation_MAX EnumUnionOperation_Value = "MAX"
	// Aggregates duplicates by String MIN.
	EnumUnionOperation_MIN     EnumUnionOperation_Value = "MIN"
	EnumUnionOperation_UNKNOWN EnumUnionOperation_Value = "UNKNOWN"
)

// EnumUnionOperation_Values returns all known variants of EnumUnionOperation.
func EnumUnionOperation_Values() []EnumUnionOperation_Value {
	return []EnumUnionOperation_Value{EnumUnionOperation_THROW, EnumUnionOperation_MAX, EnumUnionOperation_MIN}
}

func New_EnumUnionOperation(value EnumUnionOperation_Value) EnumUnionOperation {
	return EnumUnionOperation{val: value}
}

// IsUnknown returns false for all known variants of EnumUnionOperation and true otherwise.
func (e EnumUnionOperation) IsUnknown() bool {
	switch e.val {
	case EnumUnionOperation_THROW, EnumUnionOperation_MAX, EnumUnionOperation_MIN:
		return false
	}
	return true
}

func (e EnumUnionOperation) Value() EnumUnionOperation_Value {
	if e.IsUnknown() {
		return EnumUnionOperation_UNKNOWN
	}
	return e.val
}

func (e EnumUnionOperation) String() string {
	return string(e.val)
}

func (e EnumUnionOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EnumUnionOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EnumUnionOperation(EnumUnionOperation_Value(v))
	case "THROW":
		*e = New_EnumUnionOperation(EnumUnionOperation_THROW)
	case "MAX":
		*e = New_EnumUnionOperation(EnumUnionOperation_MAX)
	case "MIN":
		*e = New_EnumUnionOperation(EnumUnionOperation_MIN)
	}
	return nil
}

type EqualityOperator struct {
	val EqualityOperator_Value
}

type EqualityOperator_Value string

const (
	EqualityOperator_ALL_EQUAL     EqualityOperator_Value = "ALL_EQUAL"
	EqualityOperator_NOT_ALL_EQUAL EqualityOperator_Value = "NOT_ALL_EQUAL"
	EqualityOperator_UNKNOWN       EqualityOperator_Value = "UNKNOWN"
)

// EqualityOperator_Values returns all known variants of EqualityOperator.
func EqualityOperator_Values() []EqualityOperator_Value {
	return []EqualityOperator_Value{EqualityOperator_ALL_EQUAL, EqualityOperator_NOT_ALL_EQUAL}
}

func New_EqualityOperator(value EqualityOperator_Value) EqualityOperator {
	return EqualityOperator{val: value}
}

// IsUnknown returns false for all known variants of EqualityOperator and true otherwise.
func (e EqualityOperator) IsUnknown() bool {
	switch e.val {
	case EqualityOperator_ALL_EQUAL, EqualityOperator_NOT_ALL_EQUAL:
		return false
	}
	return true
}

func (e EqualityOperator) Value() EqualityOperator_Value {
	if e.IsUnknown() {
		return EqualityOperator_UNKNOWN
	}
	return e.val
}

func (e EqualityOperator) String() string {
	return string(e.val)
}

func (e EqualityOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EqualityOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EqualityOperator(EqualityOperator_Value(v))
	case "ALL_EQUAL":
		*e = New_EqualityOperator(EqualityOperator_ALL_EQUAL)
	case "NOT_ALL_EQUAL":
		*e = New_EqualityOperator(EqualityOperator_NOT_ALL_EQUAL)
	}
	return nil
}

type EventDispositionStatus struct {
	val EventDispositionStatus_Value
}

type EventDispositionStatus_Value string

const (
	EventDispositionStatus_PENDING_REVIEW                 EventDispositionStatus_Value = "PENDING_REVIEW"
	EventDispositionStatus_CLOSED_IGNORED                 EventDispositionStatus_Value = "CLOSED_IGNORED"
	EventDispositionStatus_CLOSED_REQUIRES_FURTHER_ACTION EventDispositionStatus_Value = "CLOSED_REQUIRES_FURTHER_ACTION"
	EventDispositionStatus_NO_DISPOSITION                 EventDispositionStatus_Value = "NO_DISPOSITION"
	EventDispositionStatus_UNKNOWN                        EventDispositionStatus_Value = "UNKNOWN"
)

// EventDispositionStatus_Values returns all known variants of EventDispositionStatus.
func EventDispositionStatus_Values() []EventDispositionStatus_Value {
	return []EventDispositionStatus_Value{EventDispositionStatus_PENDING_REVIEW, EventDispositionStatus_CLOSED_IGNORED, EventDispositionStatus_CLOSED_REQUIRES_FURTHER_ACTION, EventDispositionStatus_NO_DISPOSITION}
}

func New_EventDispositionStatus(value EventDispositionStatus_Value) EventDispositionStatus {
	return EventDispositionStatus{val: value}
}

// IsUnknown returns false for all known variants of EventDispositionStatus and true otherwise.
func (e EventDispositionStatus) IsUnknown() bool {
	switch e.val {
	case EventDispositionStatus_PENDING_REVIEW, EventDispositionStatus_CLOSED_IGNORED, EventDispositionStatus_CLOSED_REQUIRES_FURTHER_ACTION, EventDispositionStatus_NO_DISPOSITION:
		return false
	}
	return true
}

func (e EventDispositionStatus) Value() EventDispositionStatus_Value {
	if e.IsUnknown() {
		return EventDispositionStatus_UNKNOWN
	}
	return e.val
}

func (e EventDispositionStatus) String() string {
	return string(e.val)
}

func (e EventDispositionStatus) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EventDispositionStatus) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EventDispositionStatus(EventDispositionStatus_Value(v))
	case "PENDING_REVIEW":
		*e = New_EventDispositionStatus(EventDispositionStatus_PENDING_REVIEW)
	case "CLOSED_IGNORED":
		*e = New_EventDispositionStatus(EventDispositionStatus_CLOSED_IGNORED)
	case "CLOSED_REQUIRES_FURTHER_ACTION":
		*e = New_EventDispositionStatus(EventDispositionStatus_CLOSED_REQUIRES_FURTHER_ACTION)
	case "NO_DISPOSITION":
		*e = New_EventDispositionStatus(EventDispositionStatus_NO_DISPOSITION)
	}
	return nil
}

type EventTimeFilterCondition struct {
	val EventTimeFilterCondition_Value
}

type EventTimeFilterCondition_Value string

const (
	EventTimeFilterCondition_START_TIME_BEFORE_INCLUSIVE EventTimeFilterCondition_Value = "START_TIME_BEFORE_INCLUSIVE"
	EventTimeFilterCondition_START_TIME_BEFORE_EXCLUSIVE EventTimeFilterCondition_Value = "START_TIME_BEFORE_EXCLUSIVE"
	EventTimeFilterCondition_START_TIME_AFTER_INCLUSIVE  EventTimeFilterCondition_Value = "START_TIME_AFTER_INCLUSIVE"
	EventTimeFilterCondition_START_TIME_AFTER_EXCLUSIVE  EventTimeFilterCondition_Value = "START_TIME_AFTER_EXCLUSIVE"
	EventTimeFilterCondition_END_TIME_BEFORE_INCLUSIVE   EventTimeFilterCondition_Value = "END_TIME_BEFORE_INCLUSIVE"
	EventTimeFilterCondition_END_TIME_BEFORE_EXCLUSIVE   EventTimeFilterCondition_Value = "END_TIME_BEFORE_EXCLUSIVE"
	EventTimeFilterCondition_END_TIME_AFTER_INCLUSIVE    EventTimeFilterCondition_Value = "END_TIME_AFTER_INCLUSIVE"
	EventTimeFilterCondition_END_TIME_AFTER_EXCLUSIVE    EventTimeFilterCondition_Value = "END_TIME_AFTER_EXCLUSIVE"
	EventTimeFilterCondition_UNKNOWN                     EventTimeFilterCondition_Value = "UNKNOWN"
)

// EventTimeFilterCondition_Values returns all known variants of EventTimeFilterCondition.
func EventTimeFilterCondition_Values() []EventTimeFilterCondition_Value {
	return []EventTimeFilterCondition_Value{EventTimeFilterCondition_START_TIME_BEFORE_INCLUSIVE, EventTimeFilterCondition_START_TIME_BEFORE_EXCLUSIVE, EventTimeFilterCondition_START_TIME_AFTER_INCLUSIVE, EventTimeFilterCondition_START_TIME_AFTER_EXCLUSIVE, EventTimeFilterCondition_END_TIME_BEFORE_INCLUSIVE, EventTimeFilterCondition_END_TIME_BEFORE_EXCLUSIVE, EventTimeFilterCondition_END_TIME_AFTER_INCLUSIVE, EventTimeFilterCondition_END_TIME_AFTER_EXCLUSIVE}
}

func New_EventTimeFilterCondition(value EventTimeFilterCondition_Value) EventTimeFilterCondition {
	return EventTimeFilterCondition{val: value}
}

// IsUnknown returns false for all known variants of EventTimeFilterCondition and true otherwise.
func (e EventTimeFilterCondition) IsUnknown() bool {
	switch e.val {
	case EventTimeFilterCondition_START_TIME_BEFORE_INCLUSIVE, EventTimeFilterCondition_START_TIME_BEFORE_EXCLUSIVE, EventTimeFilterCondition_START_TIME_AFTER_INCLUSIVE, EventTimeFilterCondition_START_TIME_AFTER_EXCLUSIVE, EventTimeFilterCondition_END_TIME_BEFORE_INCLUSIVE, EventTimeFilterCondition_END_TIME_BEFORE_EXCLUSIVE, EventTimeFilterCondition_END_TIME_AFTER_INCLUSIVE, EventTimeFilterCondition_END_TIME_AFTER_EXCLUSIVE:
		return false
	}
	return true
}

func (e EventTimeFilterCondition) Value() EventTimeFilterCondition_Value {
	if e.IsUnknown() {
		return EventTimeFilterCondition_UNKNOWN
	}
	return e.val
}

func (e EventTimeFilterCondition) String() string {
	return string(e.val)
}

func (e EventTimeFilterCondition) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EventTimeFilterCondition) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_Value(v))
	case "START_TIME_BEFORE_INCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_START_TIME_BEFORE_INCLUSIVE)
	case "START_TIME_BEFORE_EXCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_START_TIME_BEFORE_EXCLUSIVE)
	case "START_TIME_AFTER_INCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_START_TIME_AFTER_INCLUSIVE)
	case "START_TIME_AFTER_EXCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_START_TIME_AFTER_EXCLUSIVE)
	case "END_TIME_BEFORE_INCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_END_TIME_BEFORE_INCLUSIVE)
	case "END_TIME_BEFORE_EXCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_END_TIME_BEFORE_EXCLUSIVE)
	case "END_TIME_AFTER_INCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_END_TIME_AFTER_INCLUSIVE)
	case "END_TIME_AFTER_EXCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_END_TIME_AFTER_EXCLUSIVE)
	}
	return nil
}

type EventType struct {
	val EventType_Value
}

type EventType_Value string

const (
	EventType_INFO    EventType_Value = "INFO"
	EventType_FLAG    EventType_Value = "FLAG"
	EventType_ERROR   EventType_Value = "ERROR"
	EventType_SUCCESS EventType_Value = "SUCCESS"
	EventType_UNKNOWN EventType_Value = "UNKNOWN"
)

// EventType_Values returns all known variants of EventType.
func EventType_Values() []EventType_Value {
	return []EventType_Value{EventType_INFO, EventType_FLAG, EventType_ERROR, EventType_SUCCESS}
}

func New_EventType(value EventType_Value) EventType {
	return EventType{val: value}
}

// IsUnknown returns false for all known variants of EventType and true otherwise.
func (e EventType) IsUnknown() bool {
	switch e.val {
	case EventType_INFO, EventType_FLAG, EventType_ERROR, EventType_SUCCESS:
		return false
	}
	return true
}

func (e EventType) Value() EventType_Value {
	if e.IsUnknown() {
		return EventType_UNKNOWN
	}
	return e.val
}

func (e EventType) String() string {
	return string(e.val)
}

func (e EventType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EventType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EventType(EventType_Value(v))
	case "INFO":
		*e = New_EventType(EventType_INFO)
	case "FLAG":
		*e = New_EventType(EventType_FLAG)
	case "ERROR":
		*e = New_EventType(EventType_ERROR)
	case "SUCCESS":
		*e = New_EventType(EventType_SUCCESS)
	}
	return nil
}

type LogUnionOperation struct {
	val LogUnionOperation_Value
}

type LogUnionOperation_Value string

const (
	// Keeps all points if multiple series contain points with a duplicate timestamp.
	LogUnionOperation_KEEP_ALL LogUnionOperation_Value = "KEEP_ALL"
	LogUnionOperation_UNKNOWN  LogUnionOperation_Value = "UNKNOWN"
)

// LogUnionOperation_Values returns all known variants of LogUnionOperation.
func LogUnionOperation_Values() []LogUnionOperation_Value {
	return []LogUnionOperation_Value{LogUnionOperation_KEEP_ALL}
}

func New_LogUnionOperation(value LogUnionOperation_Value) LogUnionOperation {
	return LogUnionOperation{val: value}
}

// IsUnknown returns false for all known variants of LogUnionOperation and true otherwise.
func (e LogUnionOperation) IsUnknown() bool {
	switch e.val {
	case LogUnionOperation_KEEP_ALL:
		return false
	}
	return true
}

func (e LogUnionOperation) Value() LogUnionOperation_Value {
	if e.IsUnknown() {
		return LogUnionOperation_UNKNOWN
	}
	return e.val
}

func (e LogUnionOperation) String() string {
	return string(e.val)
}

func (e LogUnionOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *LogUnionOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_LogUnionOperation(LogUnionOperation_Value(v))
	case "KEEP_ALL":
		*e = New_LogUnionOperation(LogUnionOperation_KEEP_ALL)
	}
	return nil
}

type MinMaxThresholdOperator struct {
	val MinMaxThresholdOperator_Value
}

type MinMaxThresholdOperator_Value string

const (
	MinMaxThresholdOperator_OUTSIDE_BOUNDS             MinMaxThresholdOperator_Value = "OUTSIDE_BOUNDS"
	MinMaxThresholdOperator_OUTSIDE_OR_EQUAL_TO_BOUNDS MinMaxThresholdOperator_Value = "OUTSIDE_OR_EQUAL_TO_BOUNDS"
	MinMaxThresholdOperator_INSIDE_BOUNDS              MinMaxThresholdOperator_Value = "INSIDE_BOUNDS"
	MinMaxThresholdOperator_INSIDE_OR_EQUAL_TO_BOUNDS  MinMaxThresholdOperator_Value = "INSIDE_OR_EQUAL_TO_BOUNDS"
	MinMaxThresholdOperator_UNKNOWN                    MinMaxThresholdOperator_Value = "UNKNOWN"
)

// MinMaxThresholdOperator_Values returns all known variants of MinMaxThresholdOperator.
func MinMaxThresholdOperator_Values() []MinMaxThresholdOperator_Value {
	return []MinMaxThresholdOperator_Value{MinMaxThresholdOperator_OUTSIDE_BOUNDS, MinMaxThresholdOperator_OUTSIDE_OR_EQUAL_TO_BOUNDS, MinMaxThresholdOperator_INSIDE_BOUNDS, MinMaxThresholdOperator_INSIDE_OR_EQUAL_TO_BOUNDS}
}

func New_MinMaxThresholdOperator(value MinMaxThresholdOperator_Value) MinMaxThresholdOperator {
	return MinMaxThresholdOperator{val: value}
}

// IsUnknown returns false for all known variants of MinMaxThresholdOperator and true otherwise.
func (e MinMaxThresholdOperator) IsUnknown() bool {
	switch e.val {
	case MinMaxThresholdOperator_OUTSIDE_BOUNDS, MinMaxThresholdOperator_OUTSIDE_OR_EQUAL_TO_BOUNDS, MinMaxThresholdOperator_INSIDE_BOUNDS, MinMaxThresholdOperator_INSIDE_OR_EQUAL_TO_BOUNDS:
		return false
	}
	return true
}

func (e MinMaxThresholdOperator) Value() MinMaxThresholdOperator_Value {
	if e.IsUnknown() {
		return MinMaxThresholdOperator_UNKNOWN
	}
	return e.val
}

func (e MinMaxThresholdOperator) String() string {
	return string(e.val)
}

func (e MinMaxThresholdOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *MinMaxThresholdOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_MinMaxThresholdOperator(MinMaxThresholdOperator_Value(v))
	case "OUTSIDE_BOUNDS":
		*e = New_MinMaxThresholdOperator(MinMaxThresholdOperator_OUTSIDE_BOUNDS)
	case "OUTSIDE_OR_EQUAL_TO_BOUNDS":
		*e = New_MinMaxThresholdOperator(MinMaxThresholdOperator_OUTSIDE_OR_EQUAL_TO_BOUNDS)
	case "INSIDE_BOUNDS":
		*e = New_MinMaxThresholdOperator(MinMaxThresholdOperator_INSIDE_BOUNDS)
	case "INSIDE_OR_EQUAL_TO_BOUNDS":
		*e = New_MinMaxThresholdOperator(MinMaxThresholdOperator_INSIDE_OR_EQUAL_TO_BOUNDS)
	}
	return nil
}

type NumericAggregationFunction struct {
	val NumericAggregationFunction_Value
}

type NumericAggregationFunction_Value string

const (
	NumericAggregationFunction_SUM                NumericAggregationFunction_Value = "SUM"
	NumericAggregationFunction_MEAN               NumericAggregationFunction_Value = "MEAN"
	NumericAggregationFunction_MIN                NumericAggregationFunction_Value = "MIN"
	NumericAggregationFunction_MAX                NumericAggregationFunction_Value = "MAX"
	NumericAggregationFunction_COUNT              NumericAggregationFunction_Value = "COUNT"
	NumericAggregationFunction_STANDARD_DEVIATION NumericAggregationFunction_Value = "STANDARD_DEVIATION"
	NumericAggregationFunction_UNKNOWN            NumericAggregationFunction_Value = "UNKNOWN"
)

// NumericAggregationFunction_Values returns all known variants of NumericAggregationFunction.
func NumericAggregationFunction_Values() []NumericAggregationFunction_Value {
	return []NumericAggregationFunction_Value{NumericAggregationFunction_SUM, NumericAggregationFunction_MEAN, NumericAggregationFunction_MIN, NumericAggregationFunction_MAX, NumericAggregationFunction_COUNT, NumericAggregationFunction_STANDARD_DEVIATION}
}

func New_NumericAggregationFunction(value NumericAggregationFunction_Value) NumericAggregationFunction {
	return NumericAggregationFunction{val: value}
}

// IsUnknown returns false for all known variants of NumericAggregationFunction and true otherwise.
func (e NumericAggregationFunction) IsUnknown() bool {
	switch e.val {
	case NumericAggregationFunction_SUM, NumericAggregationFunction_MEAN, NumericAggregationFunction_MIN, NumericAggregationFunction_MAX, NumericAggregationFunction_COUNT, NumericAggregationFunction_STANDARD_DEVIATION:
		return false
	}
	return true
}

func (e NumericAggregationFunction) Value() NumericAggregationFunction_Value {
	if e.IsUnknown() {
		return NumericAggregationFunction_UNKNOWN
	}
	return e.val
}

func (e NumericAggregationFunction) String() string {
	return string(e.val)
}

func (e NumericAggregationFunction) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *NumericAggregationFunction) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_NumericAggregationFunction(NumericAggregationFunction_Value(v))
	case "SUM":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_SUM)
	case "MEAN":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_MEAN)
	case "MIN":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_MIN)
	case "MAX":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_MAX)
	case "COUNT":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_COUNT)
	case "STANDARD_DEVIATION":
		*e = New_NumericAggregationFunction(NumericAggregationFunction_STANDARD_DEVIATION)
	}
	return nil
}

type NumericOutputField struct {
	val NumericOutputField_Value
}

type NumericOutputField_Value string

const (
	NumericOutputField_MIN         NumericOutputField_Value = "MIN"
	NumericOutputField_MAX         NumericOutputField_Value = "MAX"
	NumericOutputField_MEAN        NumericOutputField_Value = "MEAN"
	NumericOutputField_COUNT       NumericOutputField_Value = "COUNT"
	NumericOutputField_VARIANCE    NumericOutputField_Value = "VARIANCE"
	NumericOutputField_FIRST_POINT NumericOutputField_Value = "FIRST_POINT"
	NumericOutputField_LAST_POINT  NumericOutputField_Value = "LAST_POINT"
	NumericOutputField_UNKNOWN     NumericOutputField_Value = "UNKNOWN"
)

// NumericOutputField_Values returns all known variants of NumericOutputField.
func NumericOutputField_Values() []NumericOutputField_Value {
	return []NumericOutputField_Value{NumericOutputField_MIN, NumericOutputField_MAX, NumericOutputField_MEAN, NumericOutputField_COUNT, NumericOutputField_VARIANCE, NumericOutputField_FIRST_POINT, NumericOutputField_LAST_POINT}
}

func New_NumericOutputField(value NumericOutputField_Value) NumericOutputField {
	return NumericOutputField{val: value}
}

// IsUnknown returns false for all known variants of NumericOutputField and true otherwise.
func (e NumericOutputField) IsUnknown() bool {
	switch e.val {
	case NumericOutputField_MIN, NumericOutputField_MAX, NumericOutputField_MEAN, NumericOutputField_COUNT, NumericOutputField_VARIANCE, NumericOutputField_FIRST_POINT, NumericOutputField_LAST_POINT:
		return false
	}
	return true
}

func (e NumericOutputField) Value() NumericOutputField_Value {
	if e.IsUnknown() {
		return NumericOutputField_UNKNOWN
	}
	return e.val
}

func (e NumericOutputField) String() string {
	return string(e.val)
}

func (e NumericOutputField) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *NumericOutputField) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_NumericOutputField(NumericOutputField_Value(v))
	case "MIN":
		*e = New_NumericOutputField(NumericOutputField_MIN)
	case "MAX":
		*e = New_NumericOutputField(NumericOutputField_MAX)
	case "MEAN":
		*e = New_NumericOutputField(NumericOutputField_MEAN)
	case "COUNT":
		*e = New_NumericOutputField(NumericOutputField_COUNT)
	case "VARIANCE":
		*e = New_NumericOutputField(NumericOutputField_VARIANCE)
	case "FIRST_POINT":
		*e = New_NumericOutputField(NumericOutputField_FIRST_POINT)
	case "LAST_POINT":
		*e = New_NumericOutputField(NumericOutputField_LAST_POINT)
	}
	return nil
}

type NumericUnionOperation struct {
	val NumericUnionOperation_Value
}

type NumericUnionOperation_Value string

const (
	// Combines multiple points by taking the minimum value
	NumericUnionOperation_MIN NumericUnionOperation_Value = "MIN"
	// Combines multiple points by taking the maximum value
	NumericUnionOperation_MAX NumericUnionOperation_Value = "MAX"
	// Combines multiple points by taking the mean of the values
	NumericUnionOperation_MEAN NumericUnionOperation_Value = "MEAN"
	// Combines multiple points by taking the sum of the values
	NumericUnionOperation_SUM NumericUnionOperation_Value = "SUM"
	// Combines multiple points by taking the count of the values
	NumericUnionOperation_COUNT NumericUnionOperation_Value = "COUNT"
	// Combines multiple points by taking the standard deviation of the values
	NumericUnionOperation_STANDARD_DEVIATION NumericUnionOperation_Value = "STANDARD_DEVIATION"
	// Throws a DuplicateTimestamp error if two series contain points with a duplicate timestamp.
	NumericUnionOperation_THROW   NumericUnionOperation_Value = "THROW"
	NumericUnionOperation_UNKNOWN NumericUnionOperation_Value = "UNKNOWN"
)

// NumericUnionOperation_Values returns all known variants of NumericUnionOperation.
func NumericUnionOperation_Values() []NumericUnionOperation_Value {
	return []NumericUnionOperation_Value{NumericUnionOperation_MIN, NumericUnionOperation_MAX, NumericUnionOperation_MEAN, NumericUnionOperation_SUM, NumericUnionOperation_COUNT, NumericUnionOperation_STANDARD_DEVIATION, NumericUnionOperation_THROW}
}

func New_NumericUnionOperation(value NumericUnionOperation_Value) NumericUnionOperation {
	return NumericUnionOperation{val: value}
}

// IsUnknown returns false for all known variants of NumericUnionOperation and true otherwise.
func (e NumericUnionOperation) IsUnknown() bool {
	switch e.val {
	case NumericUnionOperation_MIN, NumericUnionOperation_MAX, NumericUnionOperation_MEAN, NumericUnionOperation_SUM, NumericUnionOperation_COUNT, NumericUnionOperation_STANDARD_DEVIATION, NumericUnionOperation_THROW:
		return false
	}
	return true
}

func (e NumericUnionOperation) Value() NumericUnionOperation_Value {
	if e.IsUnknown() {
		return NumericUnionOperation_UNKNOWN
	}
	return e.val
}

func (e NumericUnionOperation) String() string {
	return string(e.val)
}

func (e NumericUnionOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *NumericUnionOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_NumericUnionOperation(NumericUnionOperation_Value(v))
	case "MIN":
		*e = New_NumericUnionOperation(NumericUnionOperation_MIN)
	case "MAX":
		*e = New_NumericUnionOperation(NumericUnionOperation_MAX)
	case "MEAN":
		*e = New_NumericUnionOperation(NumericUnionOperation_MEAN)
	case "SUM":
		*e = New_NumericUnionOperation(NumericUnionOperation_SUM)
	case "COUNT":
		*e = New_NumericUnionOperation(NumericUnionOperation_COUNT)
	case "STANDARD_DEVIATION":
		*e = New_NumericUnionOperation(NumericUnionOperation_STANDARD_DEVIATION)
	case "THROW":
		*e = New_NumericUnionOperation(NumericUnionOperation_THROW)
	}
	return nil
}

type OutputFormat struct {
	val OutputFormat_Value
}

type OutputFormat_Value string

const (
	OutputFormat_ARROW_V1   OutputFormat_Value = "ARROW_V1"
	OutputFormat_ARROW_V1_1 OutputFormat_Value = "ARROW_V1_1"
	OutputFormat_ARROW_V2   OutputFormat_Value = "ARROW_V2"
	OutputFormat_LEGACY     OutputFormat_Value = "LEGACY"
	OutputFormat_UNKNOWN    OutputFormat_Value = "UNKNOWN"
)

// OutputFormat_Values returns all known variants of OutputFormat.
func OutputFormat_Values() []OutputFormat_Value {
	return []OutputFormat_Value{OutputFormat_ARROW_V1, OutputFormat_ARROW_V1_1, OutputFormat_ARROW_V2, OutputFormat_LEGACY}
}

func New_OutputFormat(value OutputFormat_Value) OutputFormat {
	return OutputFormat{val: value}
}

// IsUnknown returns false for all known variants of OutputFormat and true otherwise.
func (e OutputFormat) IsUnknown() bool {
	switch e.val {
	case OutputFormat_ARROW_V1, OutputFormat_ARROW_V1_1, OutputFormat_ARROW_V2, OutputFormat_LEGACY:
		return false
	}
	return true
}

func (e OutputFormat) Value() OutputFormat_Value {
	if e.IsUnknown() {
		return OutputFormat_UNKNOWN
	}
	return e.val
}

func (e OutputFormat) String() string {
	return string(e.val)
}

func (e OutputFormat) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *OutputFormat) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_OutputFormat(OutputFormat_Value(v))
	case "ARROW_V1":
		*e = New_OutputFormat(OutputFormat_ARROW_V1)
	case "ARROW_V1_1":
		*e = New_OutputFormat(OutputFormat_ARROW_V1_1)
	case "ARROW_V2":
		*e = New_OutputFormat(OutputFormat_ARROW_V2)
	case "LEGACY":
		*e = New_OutputFormat(OutputFormat_LEGACY)
	}
	return nil
}

type PeakType struct {
	val PeakType_Value
}

type PeakType_Value string

const (
	PeakType_PEAK    PeakType_Value = "PEAK"
	PeakType_TROUGH  PeakType_Value = "TROUGH"
	PeakType_BOTH    PeakType_Value = "BOTH"
	PeakType_UNKNOWN PeakType_Value = "UNKNOWN"
)

// PeakType_Values returns all known variants of PeakType.
func PeakType_Values() []PeakType_Value {
	return []PeakType_Value{PeakType_PEAK, PeakType_TROUGH, PeakType_BOTH}
}

func New_PeakType(value PeakType_Value) PeakType {
	return PeakType{val: value}
}

// IsUnknown returns false for all known variants of PeakType and true otherwise.
func (e PeakType) IsUnknown() bool {
	switch e.val {
	case PeakType_PEAK, PeakType_TROUGH, PeakType_BOTH:
		return false
	}
	return true
}

func (e PeakType) Value() PeakType_Value {
	if e.IsUnknown() {
		return PeakType_UNKNOWN
	}
	return e.val
}

func (e PeakType) String() string {
	return string(e.val)
}

func (e PeakType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *PeakType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_PeakType(PeakType_Value(v))
	case "PEAK":
		*e = New_PeakType(PeakType_PEAK)
	case "TROUGH":
		*e = New_PeakType(PeakType_TROUGH)
	case "BOTH":
		*e = New_PeakType(PeakType_BOTH)
	}
	return nil
}

type SearchEventOriginType struct {
	val SearchEventOriginType_Value
}

type SearchEventOriginType_Value string

const (
	SearchEventOriginType_WORKBOOK    SearchEventOriginType_Value = "WORKBOOK"
	SearchEventOriginType_TEMPLATE    SearchEventOriginType_Value = "TEMPLATE"
	SearchEventOriginType_API         SearchEventOriginType_Value = "API"
	SearchEventOriginType_DATA_REVIEW SearchEventOriginType_Value = "DATA_REVIEW"
	SearchEventOriginType_PROCEDURE   SearchEventOriginType_Value = "PROCEDURE"
	SearchEventOriginType_UNKNOWN     SearchEventOriginType_Value = "UNKNOWN"
)

// SearchEventOriginType_Values returns all known variants of SearchEventOriginType.
func SearchEventOriginType_Values() []SearchEventOriginType_Value {
	return []SearchEventOriginType_Value{SearchEventOriginType_WORKBOOK, SearchEventOriginType_TEMPLATE, SearchEventOriginType_API, SearchEventOriginType_DATA_REVIEW, SearchEventOriginType_PROCEDURE}
}

func New_SearchEventOriginType(value SearchEventOriginType_Value) SearchEventOriginType {
	return SearchEventOriginType{val: value}
}

// IsUnknown returns false for all known variants of SearchEventOriginType and true otherwise.
func (e SearchEventOriginType) IsUnknown() bool {
	switch e.val {
	case SearchEventOriginType_WORKBOOK, SearchEventOriginType_TEMPLATE, SearchEventOriginType_API, SearchEventOriginType_DATA_REVIEW, SearchEventOriginType_PROCEDURE:
		return false
	}
	return true
}

func (e SearchEventOriginType) Value() SearchEventOriginType_Value {
	if e.IsUnknown() {
		return SearchEventOriginType_UNKNOWN
	}
	return e.val
}

func (e SearchEventOriginType) String() string {
	return string(e.val)
}

func (e SearchEventOriginType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *SearchEventOriginType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_SearchEventOriginType(SearchEventOriginType_Value(v))
	case "WORKBOOK":
		*e = New_SearchEventOriginType(SearchEventOriginType_WORKBOOK)
	case "TEMPLATE":
		*e = New_SearchEventOriginType(SearchEventOriginType_TEMPLATE)
	case "API":
		*e = New_SearchEventOriginType(SearchEventOriginType_API)
	case "DATA_REVIEW":
		*e = New_SearchEventOriginType(SearchEventOriginType_DATA_REVIEW)
	case "PROCEDURE":
		*e = New_SearchEventOriginType(SearchEventOriginType_PROCEDURE)
	}
	return nil
}

type TagFilterOperator struct {
	val TagFilterOperator_Value
}

type TagFilterOperator_Value string

const (
	TagFilterOperator_IN      TagFilterOperator_Value = "IN"
	TagFilterOperator_NOT_IN  TagFilterOperator_Value = "NOT_IN"
	TagFilterOperator_UNKNOWN TagFilterOperator_Value = "UNKNOWN"
)

// TagFilterOperator_Values returns all known variants of TagFilterOperator.
func TagFilterOperator_Values() []TagFilterOperator_Value {
	return []TagFilterOperator_Value{TagFilterOperator_IN, TagFilterOperator_NOT_IN}
}

func New_TagFilterOperator(value TagFilterOperator_Value) TagFilterOperator {
	return TagFilterOperator{val: value}
}

// IsUnknown returns false for all known variants of TagFilterOperator and true otherwise.
func (e TagFilterOperator) IsUnknown() bool {
	switch e.val {
	case TagFilterOperator_IN, TagFilterOperator_NOT_IN:
		return false
	}
	return true
}

func (e TagFilterOperator) Value() TagFilterOperator_Value {
	if e.IsUnknown() {
		return TagFilterOperator_UNKNOWN
	}
	return e.val
}

func (e TagFilterOperator) String() string {
	return string(e.val)
}

func (e TagFilterOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *TagFilterOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_TagFilterOperator(TagFilterOperator_Value(v))
	case "IN":
		*e = New_TagFilterOperator(TagFilterOperator_IN)
	case "NOT_IN":
		*e = New_TagFilterOperator(TagFilterOperator_NOT_IN)
	}
	return nil
}

type TagFilterValidationErrorType struct {
	val TagFilterValidationErrorType_Value
}

type TagFilterValidationErrorType_Value string

const (
	TagFilterValidationErrorType_BOTH_TAGS_AND_TAG_FILTERS_PROVIDED TagFilterValidationErrorType_Value = "BOTH_TAGS_AND_TAG_FILTERS_PROVIDED"
	TagFilterValidationErrorType_EMPTY_FILTER_LIST                  TagFilterValidationErrorType_Value = "EMPTY_FILTER_LIST"
	TagFilterValidationErrorType_EMPTY_TAG_VALUE_SET                TagFilterValidationErrorType_Value = "EMPTY_TAG_VALUE_SET"
	TagFilterValidationErrorType_NESTED_AND_OPERATIONS              TagFilterValidationErrorType_Value = "NESTED_AND_OPERATIONS"
	TagFilterValidationErrorType_DUPLICATE_TAG_KEY                  TagFilterValidationErrorType_Value = "DUPLICATE_TAG_KEY"
	TagFilterValidationErrorType_UNKNOWN                            TagFilterValidationErrorType_Value = "UNKNOWN"
)

// TagFilterValidationErrorType_Values returns all known variants of TagFilterValidationErrorType.
func TagFilterValidationErrorType_Values() []TagFilterValidationErrorType_Value {
	return []TagFilterValidationErrorType_Value{TagFilterValidationErrorType_BOTH_TAGS_AND_TAG_FILTERS_PROVIDED, TagFilterValidationErrorType_EMPTY_FILTER_LIST, TagFilterValidationErrorType_EMPTY_TAG_VALUE_SET, TagFilterValidationErrorType_NESTED_AND_OPERATIONS, TagFilterValidationErrorType_DUPLICATE_TAG_KEY}
}

func New_TagFilterValidationErrorType(value TagFilterValidationErrorType_Value) TagFilterValidationErrorType {
	return TagFilterValidationErrorType{val: value}
}

// IsUnknown returns false for all known variants of TagFilterValidationErrorType and true otherwise.
func (e TagFilterValidationErrorType) IsUnknown() bool {
	switch e.val {
	case TagFilterValidationErrorType_BOTH_TAGS_AND_TAG_FILTERS_PROVIDED, TagFilterValidationErrorType_EMPTY_FILTER_LIST, TagFilterValidationErrorType_EMPTY_TAG_VALUE_SET, TagFilterValidationErrorType_NESTED_AND_OPERATIONS, TagFilterValidationErrorType_DUPLICATE_TAG_KEY:
		return false
	}
	return true
}

func (e TagFilterValidationErrorType) Value() TagFilterValidationErrorType_Value {
	if e.IsUnknown() {
		return TagFilterValidationErrorType_UNKNOWN
	}
	return e.val
}

func (e TagFilterValidationErrorType) String() string {
	return string(e.val)
}

func (e TagFilterValidationErrorType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *TagFilterValidationErrorType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_Value(v))
	case "BOTH_TAGS_AND_TAG_FILTERS_PROVIDED":
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_BOTH_TAGS_AND_TAG_FILTERS_PROVIDED)
	case "EMPTY_FILTER_LIST":
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_EMPTY_FILTER_LIST)
	case "EMPTY_TAG_VALUE_SET":
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_EMPTY_TAG_VALUE_SET)
	case "NESTED_AND_OPERATIONS":
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_NESTED_AND_OPERATIONS)
	case "DUPLICATE_TAG_KEY":
		*e = New_TagFilterValidationErrorType(TagFilterValidationErrorType_DUPLICATE_TAG_KEY)
	}
	return nil
}

type ThresholdOperator struct {
	val ThresholdOperator_Value
}

type ThresholdOperator_Value string

const (
	ThresholdOperator_GREATER_THAN             ThresholdOperator_Value = "GREATER_THAN"
	ThresholdOperator_GREATER_THAN_OR_EQUAL_TO ThresholdOperator_Value = "GREATER_THAN_OR_EQUAL_TO"
	ThresholdOperator_LESS_THAN                ThresholdOperator_Value = "LESS_THAN"
	ThresholdOperator_LESS_THAN_OR_EQUAL_TO    ThresholdOperator_Value = "LESS_THAN_OR_EQUAL_TO"
	ThresholdOperator_EQUAL_TO                 ThresholdOperator_Value = "EQUAL_TO"
	ThresholdOperator_NOT_EQUAL_TO             ThresholdOperator_Value = "NOT_EQUAL_TO"
	ThresholdOperator_UNKNOWN                  ThresholdOperator_Value = "UNKNOWN"
)

// ThresholdOperator_Values returns all known variants of ThresholdOperator.
func ThresholdOperator_Values() []ThresholdOperator_Value {
	return []ThresholdOperator_Value{ThresholdOperator_GREATER_THAN, ThresholdOperator_GREATER_THAN_OR_EQUAL_TO, ThresholdOperator_LESS_THAN, ThresholdOperator_LESS_THAN_OR_EQUAL_TO, ThresholdOperator_EQUAL_TO, ThresholdOperator_NOT_EQUAL_TO}
}

func New_ThresholdOperator(value ThresholdOperator_Value) ThresholdOperator {
	return ThresholdOperator{val: value}
}

// IsUnknown returns false for all known variants of ThresholdOperator and true otherwise.
func (e ThresholdOperator) IsUnknown() bool {
	switch e.val {
	case ThresholdOperator_GREATER_THAN, ThresholdOperator_GREATER_THAN_OR_EQUAL_TO, ThresholdOperator_LESS_THAN, ThresholdOperator_LESS_THAN_OR_EQUAL_TO, ThresholdOperator_EQUAL_TO, ThresholdOperator_NOT_EQUAL_TO:
		return false
	}
	return true
}

func (e ThresholdOperator) Value() ThresholdOperator_Value {
	if e.IsUnknown() {
		return ThresholdOperator_UNKNOWN
	}
	return e.val
}

func (e ThresholdOperator) String() string {
	return string(e.val)
}

func (e ThresholdOperator) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *ThresholdOperator) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_ThresholdOperator(ThresholdOperator_Value(v))
	case "GREATER_THAN":
		*e = New_ThresholdOperator(ThresholdOperator_GREATER_THAN)
	case "GREATER_THAN_OR_EQUAL_TO":
		*e = New_ThresholdOperator(ThresholdOperator_GREATER_THAN_OR_EQUAL_TO)
	case "LESS_THAN":
		*e = New_ThresholdOperator(ThresholdOperator_LESS_THAN)
	case "LESS_THAN_OR_EQUAL_TO":
		*e = New_ThresholdOperator(ThresholdOperator_LESS_THAN_OR_EQUAL_TO)
	case "EQUAL_TO":
		*e = New_ThresholdOperator(ThresholdOperator_EQUAL_TO)
	case "NOT_EQUAL_TO":
		*e = New_ThresholdOperator(ThresholdOperator_NOT_EQUAL_TO)
	}
	return nil
}

type UnaryArithmeticOperation struct {
	val UnaryArithmeticOperation_Value
}

type UnaryArithmeticOperation_Value string

const (
	// Calculates the trigonometric cosine
	UnaryArithmeticOperation_COS UnaryArithmeticOperation_Value = "COS"
	// Calculates the trigonometric sine
	UnaryArithmeticOperation_SIN UnaryArithmeticOperation_Value = "SIN"
	// Calculates the trigonometric tangent
	UnaryArithmeticOperation_TAN UnaryArithmeticOperation_Value = "TAN"
	// Calculates the absolute value
	UnaryArithmeticOperation_ABS UnaryArithmeticOperation_Value = "ABS"
	// Calculates the arcsin in radians
	UnaryArithmeticOperation_ASIN UnaryArithmeticOperation_Value = "ASIN"
	// Calculates the arccos in radians
	UnaryArithmeticOperation_ACOS UnaryArithmeticOperation_Value = "ACOS"
	// Calculates the base 10 logarithm
	UnaryArithmeticOperation_LOG UnaryArithmeticOperation_Value = "LOG"
	// Calculates the natural logarithm
	UnaryArithmeticOperation_LN UnaryArithmeticOperation_Value = "LN"
	// Calculates the square root
	UnaryArithmeticOperation_SQRT    UnaryArithmeticOperation_Value = "SQRT"
	UnaryArithmeticOperation_UNKNOWN UnaryArithmeticOperation_Value = "UNKNOWN"
)

// UnaryArithmeticOperation_Values returns all known variants of UnaryArithmeticOperation.
func UnaryArithmeticOperation_Values() []UnaryArithmeticOperation_Value {
	return []UnaryArithmeticOperation_Value{UnaryArithmeticOperation_COS, UnaryArithmeticOperation_SIN, UnaryArithmeticOperation_TAN, UnaryArithmeticOperation_ABS, UnaryArithmeticOperation_ASIN, UnaryArithmeticOperation_ACOS, UnaryArithmeticOperation_LOG, UnaryArithmeticOperation_LN, UnaryArithmeticOperation_SQRT}
}

func New_UnaryArithmeticOperation(value UnaryArithmeticOperation_Value) UnaryArithmeticOperation {
	return UnaryArithmeticOperation{val: value}
}

// IsUnknown returns false for all known variants of UnaryArithmeticOperation and true otherwise.
func (e UnaryArithmeticOperation) IsUnknown() bool {
	switch e.val {
	case UnaryArithmeticOperation_COS, UnaryArithmeticOperation_SIN, UnaryArithmeticOperation_TAN, UnaryArithmeticOperation_ABS, UnaryArithmeticOperation_ASIN, UnaryArithmeticOperation_ACOS, UnaryArithmeticOperation_LOG, UnaryArithmeticOperation_LN, UnaryArithmeticOperation_SQRT:
		return false
	}
	return true
}

func (e UnaryArithmeticOperation) Value() UnaryArithmeticOperation_Value {
	if e.IsUnknown() {
		return UnaryArithmeticOperation_UNKNOWN
	}
	return e.val
}

func (e UnaryArithmeticOperation) String() string {
	return string(e.val)
}

func (e UnaryArithmeticOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *UnaryArithmeticOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_Value(v))
	case "COS":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_COS)
	case "SIN":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_SIN)
	case "TAN":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_TAN)
	case "ABS":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_ABS)
	case "ASIN":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_ASIN)
	case "ACOS":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_ACOS)
	case "LOG":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_LOG)
	case "LN":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_LN)
	case "SQRT":
		*e = New_UnaryArithmeticOperation(UnaryArithmeticOperation_SQRT)
	}
	return nil
}

// Dictates how empty range bounds should be handled by the compute node. Defaults to INFINITY.
type UnboundedBehavior struct {
	val UnboundedBehavior_Value
}

type UnboundedBehavior_Value string

const (
	UnboundedBehavior_INFINITY     UnboundedBehavior_Value = "INFINITY"
	UnboundedBehavior_WINDOW_BOUND UnboundedBehavior_Value = "WINDOW_BOUND"
	UnboundedBehavior_UNKNOWN      UnboundedBehavior_Value = "UNKNOWN"
)

// UnboundedBehavior_Values returns all known variants of UnboundedBehavior.
func UnboundedBehavior_Values() []UnboundedBehavior_Value {
	return []UnboundedBehavior_Value{UnboundedBehavior_INFINITY, UnboundedBehavior_WINDOW_BOUND}
}

func New_UnboundedBehavior(value UnboundedBehavior_Value) UnboundedBehavior {
	return UnboundedBehavior{val: value}
}

// IsUnknown returns false for all known variants of UnboundedBehavior and true otherwise.
func (e UnboundedBehavior) IsUnknown() bool {
	switch e.val {
	case UnboundedBehavior_INFINITY, UnboundedBehavior_WINDOW_BOUND:
		return false
	}
	return true
}

func (e UnboundedBehavior) Value() UnboundedBehavior_Value {
	if e.IsUnknown() {
		return UnboundedBehavior_UNKNOWN
	}
	return e.val
}

func (e UnboundedBehavior) String() string {
	return string(e.val)
}

func (e UnboundedBehavior) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *UnboundedBehavior) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_UnboundedBehavior(UnboundedBehavior_Value(v))
	case "INFINITY":
		*e = New_UnboundedBehavior(UnboundedBehavior_INFINITY)
	case "WINDOW_BOUND":
		*e = New_UnboundedBehavior(UnboundedBehavior_WINDOW_BOUND)
	}
	return nil
}

type UnitOperation struct {
	val UnitOperation_Value
}

type UnitOperation_Value string

const (
	UnitOperation_UNIT_AS_EXPONENT        UnitOperation_Value = "UNIT_AS_EXPONENT"
	UnitOperation_NON_INTEGER_AS_EXPONENT UnitOperation_Value = "NON_INTEGER_AS_EXPONENT"
	UnitOperation_FLOOR_DIVISION          UnitOperation_Value = "FLOOR_DIVISION"
	UnitOperation_MODULO                  UnitOperation_Value = "MODULO"
	UnitOperation_CROSSOVER_COMPARISON    UnitOperation_Value = "CROSSOVER_COMPARISON"
	UnitOperation_MAX                     UnitOperation_Value = "MAX"
	UnitOperation_MIN                     UnitOperation_Value = "MIN"
	UnitOperation_MEAN                    UnitOperation_Value = "MEAN"
	UnitOperation_UNION                   UnitOperation_Value = "UNION"
	UnitOperation_ADDITION                UnitOperation_Value = "ADDITION"
	UnitOperation_SUBTRACTION             UnitOperation_Value = "SUBTRACTION"
	UnitOperation_UNIT_CONVERSION         UnitOperation_Value = "UNIT_CONVERSION"
	UnitOperation_COMPARISON              UnitOperation_Value = "COMPARISON"
	UnitOperation_TERNARY_OPERATOR        UnitOperation_Value = "TERNARY_OPERATOR"
	UnitOperation_UNKNOWN                 UnitOperation_Value = "UNKNOWN"
)

// UnitOperation_Values returns all known variants of UnitOperation.
func UnitOperation_Values() []UnitOperation_Value {
	return []UnitOperation_Value{UnitOperation_UNIT_AS_EXPONENT, UnitOperation_NON_INTEGER_AS_EXPONENT, UnitOperation_FLOOR_DIVISION, UnitOperation_MODULO, UnitOperation_CROSSOVER_COMPARISON, UnitOperation_MAX, UnitOperation_MIN, UnitOperation_MEAN, UnitOperation_UNION, UnitOperation_ADDITION, UnitOperation_SUBTRACTION, UnitOperation_UNIT_CONVERSION, UnitOperation_COMPARISON, UnitOperation_TERNARY_OPERATOR}
}

func New_UnitOperation(value UnitOperation_Value) UnitOperation {
	return UnitOperation{val: value}
}

// IsUnknown returns false for all known variants of UnitOperation and true otherwise.
func (e UnitOperation) IsUnknown() bool {
	switch e.val {
	case UnitOperation_UNIT_AS_EXPONENT, UnitOperation_NON_INTEGER_AS_EXPONENT, UnitOperation_FLOOR_DIVISION, UnitOperation_MODULO, UnitOperation_CROSSOVER_COMPARISON, UnitOperation_MAX, UnitOperation_MIN, UnitOperation_MEAN, UnitOperation_UNION, UnitOperation_ADDITION, UnitOperation_SUBTRACTION, UnitOperation_UNIT_CONVERSION, UnitOperation_COMPARISON, UnitOperation_TERNARY_OPERATOR:
		return false
	}
	return true
}

func (e UnitOperation) Value() UnitOperation_Value {
	if e.IsUnknown() {
		return UnitOperation_UNKNOWN
	}
	return e.val
}

func (e UnitOperation) String() string {
	return string(e.val)
}

func (e UnitOperation) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *UnitOperation) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_UnitOperation(UnitOperation_Value(v))
	case "UNIT_AS_EXPONENT":
		*e = New_UnitOperation(UnitOperation_UNIT_AS_EXPONENT)
	case "NON_INTEGER_AS_EXPONENT":
		*e = New_UnitOperation(UnitOperation_NON_INTEGER_AS_EXPONENT)
	case "FLOOR_DIVISION":
		*e = New_UnitOperation(UnitOperation_FLOOR_DIVISION)
	case "MODULO":
		*e = New_UnitOperation(UnitOperation_MODULO)
	case "CROSSOVER_COMPARISON":
		*e = New_UnitOperation(UnitOperation_CROSSOVER_COMPARISON)
	case "MAX":
		*e = New_UnitOperation(UnitOperation_MAX)
	case "MIN":
		*e = New_UnitOperation(UnitOperation_MIN)
	case "MEAN":
		*e = New_UnitOperation(UnitOperation_MEAN)
	case "UNION":
		*e = New_UnitOperation(UnitOperation_UNION)
	case "ADDITION":
		*e = New_UnitOperation(UnitOperation_ADDITION)
	case "SUBTRACTION":
		*e = New_UnitOperation(UnitOperation_SUBTRACTION)
	case "UNIT_CONVERSION":
		*e = New_UnitOperation(UnitOperation_UNIT_CONVERSION)
	case "COMPARISON":
		*e = New_UnitOperation(UnitOperation_COMPARISON)
	case "TERNARY_OPERATOR":
		*e = New_UnitOperation(UnitOperation_TERNARY_OPERATOR)
	}
	return nil
}
