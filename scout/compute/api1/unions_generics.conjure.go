// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api1

import (
	"context"
	"fmt"

	api2 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/scout/compute/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/run/api"
)

type ArraySeriesWithT[T any] ArraySeries

func (u *ArraySeriesWithT[T]) Accept(ctx context.Context, v ArraySeriesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return result, fmt.Errorf("field \"numeric1d\" is required")
		}
		return v.VisitNumeric1d(ctx, *u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return result, fmt.Errorf("field \"enum1d\" is required")
		}
		return v.VisitEnum1d(ctx, *u.enum1d)
	}
}

func (u *ArraySeriesWithT[T]) AcceptFuncs(numeric1dFunc func(Numeric1dArraySeries) (T, error), enum1dFunc func(Enum1dArraySeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return result, fmt.Errorf("field \"numeric1d\" is required")
		}
		return numeric1dFunc(*u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return result, fmt.Errorf("field \"enum1d\" is required")
		}
		return enum1dFunc(*u.enum1d)
	}
}

func (u *ArraySeriesWithT[T]) Numeric1dNoopSuccess(Numeric1dArraySeries) (T, error) {
	var result T
	return result, nil
}

func (u *ArraySeriesWithT[T]) Enum1dNoopSuccess(Enum1dArraySeries) (T, error) {
	var result T
	return result, nil
}

func (u *ArraySeriesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ArraySeriesVisitorWithT[T any] interface {
	VisitNumeric1d(ctx context.Context, v Numeric1dArraySeries) (T, error)
	VisitEnum1d(ctx context.Context, v Enum1dArraySeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CartesianWithT[T any] Cartesian

func (u *CartesianWithT[T]) Accept(ctx context.Context, v CartesianVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(ctx, *u.scatter)
	}
}

func (u *CartesianWithT[T]) AcceptFuncs(scatterFunc func(Scatter) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *CartesianWithT[T]) ScatterNoopSuccess(Scatter) (T, error) {
	var result T
	return result, nil
}

func (u *CartesianWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CartesianVisitorWithT[T any] interface {
	VisitScatter(ctx context.Context, v Scatter) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Cartesian3dWithT[T any] Cartesian3d

func (u *Cartesian3dWithT[T]) Accept(ctx context.Context, v Cartesian3dVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return result, fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3d(ctx, *u.scatter3d)
	}
}

func (u *Cartesian3dWithT[T]) AcceptFuncs(scatter3dFunc func(Scatter3d) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return result, fmt.Errorf("field \"scatter3d\" is required")
		}
		return scatter3dFunc(*u.scatter3d)
	}
}

func (u *Cartesian3dWithT[T]) Scatter3dNoopSuccess(Scatter3d) (T, error) {
	var result T
	return result, nil
}

func (u *Cartesian3dWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Cartesian3dVisitorWithT[T any] interface {
	VisitScatter3d(ctx context.Context, v Scatter3d) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComputableNodeWithT[T any] ComputableNode

func (u *ComputableNodeWithT[T]) Accept(ctx context.Context, v ComputableNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(ctx, *u.ranges)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(ctx, *u.series)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(ctx, *u.value)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(ctx, *u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return result, fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3d(ctx, *u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return result, fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequency(ctx, *u.frequency)
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return result, fmt.Errorf("field \"frequencyV2\" is required")
		}
		return v.VisitFrequencyV2(ctx, *u.frequencyV2)
	case "histogram":
		if u.histogram == nil {
			return result, fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogram(ctx, *u.histogram)
	case "curve":
		if u.curve == nil {
			return result, fmt.Errorf("field \"curve\" is required")
		}
		return v.VisitCurve(ctx, *u.curve)
	}
}

func (u *ComputableNodeWithT[T]) AcceptFuncs(rangesFunc func(SummarizeRanges) (T, error), seriesFunc func(SummarizeSeries) (T, error), valueFunc func(SelectValue) (T, error), cartesianFunc func(SummarizeCartesian) (T, error), cartesian3dFunc func(SummarizeCartesian3d) (T, error), frequencyFunc func(FrequencyDomain) (T, error), frequencyV2Func func(FrequencyDomainV2) (T, error), histogramFunc func(Histogram) (T, error), curveFunc func(CurveFit) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return result, fmt.Errorf("field \"cartesian3d\" is required")
		}
		return cartesian3dFunc(*u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return result, fmt.Errorf("field \"frequency\" is required")
		}
		return frequencyFunc(*u.frequency)
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return result, fmt.Errorf("field \"frequencyV2\" is required")
		}
		return frequencyV2Func(*u.frequencyV2)
	case "histogram":
		if u.histogram == nil {
			return result, fmt.Errorf("field \"histogram\" is required")
		}
		return histogramFunc(*u.histogram)
	case "curve":
		if u.curve == nil {
			return result, fmt.Errorf("field \"curve\" is required")
		}
		return curveFunc(*u.curve)
	}
}

func (u *ComputableNodeWithT[T]) RangesNoopSuccess(SummarizeRanges) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) SeriesNoopSuccess(SummarizeSeries) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) ValueNoopSuccess(SelectValue) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) CartesianNoopSuccess(SummarizeCartesian) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) Cartesian3dNoopSuccess(SummarizeCartesian3d) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) FrequencyNoopSuccess(FrequencyDomain) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) FrequencyV2NoopSuccess(FrequencyDomainV2) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) HistogramNoopSuccess(Histogram) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) CurveNoopSuccess(CurveFit) (T, error) {
	var result T
	return result, nil
}

func (u *ComputableNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComputableNodeVisitorWithT[T any] interface {
	VisitRanges(ctx context.Context, v SummarizeRanges) (T, error)
	VisitSeries(ctx context.Context, v SummarizeSeries) (T, error)
	VisitValue(ctx context.Context, v SelectValue) (T, error)
	VisitCartesian(ctx context.Context, v SummarizeCartesian) (T, error)
	VisitCartesian3d(ctx context.Context, v SummarizeCartesian3d) (T, error)
	VisitFrequency(ctx context.Context, v FrequencyDomain) (T, error)
	VisitFrequencyV2(ctx context.Context, v FrequencyDomainV2) (T, error)
	VisitHistogram(ctx context.Context, v Histogram) (T, error)
	VisitCurve(ctx context.Context, v CurveFit) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComputeNodeWithT[T any] ComputeNode

func (u *ComputeNodeWithT[T]) Accept(ctx context.Context, v ComputeNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(ctx, *u.log)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(ctx, *u.ranges)
	case "array":
		if u.array == nil {
			return result, fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(ctx, *u.array)
	case "struct":
		if u.struct_ == nil {
			return result, fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStruct(ctx, *u.struct_)
	case "curveFit":
		if u.curveFit == nil {
			return result, fmt.Errorf("field \"curveFit\" is required")
		}
		return v.VisitCurveFit(ctx, *u.curveFit)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *ComputeNodeWithT[T]) AcceptFuncs(enumFunc func(EnumSeries) (T, error), numericFunc func(NumericSeries) (T, error), logFunc func(LogSeries) (T, error), rangesFunc func(RangeSeries) (T, error), arrayFunc func(ArraySeries) (T, error), struct_Func func(StructSeries) (T, error), curveFitFunc func(CurveFit) (T, error), rawFunc func(api.Reference) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	case "array":
		if u.array == nil {
			return result, fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	case "struct":
		if u.struct_ == nil {
			return result, fmt.Errorf("field \"struct\" is required")
		}
		return struct_Func(*u.struct_)
	case "curveFit":
		if u.curveFit == nil {
			return result, fmt.Errorf("field \"curveFit\" is required")
		}
		return curveFitFunc(*u.curveFit)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *ComputeNodeWithT[T]) EnumNoopSuccess(EnumSeries) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeWithT[T]) NumericNoopSuccess(NumericSeries) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeWithT[T]) LogNoopSuccess(LogSeries) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeWithT[T]) RangesNoopSuccess(RangeSeries) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeWithT[T]) ArrayNoopSuccess(ArraySeries) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeWithT[T]) StructNoopSuccess(StructSeries) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeWithT[T]) CurveFitNoopSuccess(CurveFit) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComputeNodeVisitorWithT[T any] interface {
	VisitEnum(ctx context.Context, v EnumSeries) (T, error)
	VisitNumeric(ctx context.Context, v NumericSeries) (T, error)
	VisitLog(ctx context.Context, v LogSeries) (T, error)
	VisitRanges(ctx context.Context, v RangeSeries) (T, error)
	VisitArray(ctx context.Context, v ArraySeries) (T, error)
	VisitStruct(ctx context.Context, v StructSeries) (T, error)
	VisitCurveFit(ctx context.Context, v CurveFit) (T, error)
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CurveFitPlotTypeWithT[T any] CurveFitPlotType

func (u *CurveFitPlotTypeWithT[T]) Accept(ctx context.Context, v CurveFitPlotTypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return result, fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeries(ctx, *u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(ctx, *u.scatter)
	}
}

func (u *CurveFitPlotTypeWithT[T]) AcceptFuncs(timeSeriesFunc func(TimeSeriesCurveFit) (T, error), scatterFunc func(ScatterCurveFit) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return result, fmt.Errorf("field \"timeSeries\" is required")
		}
		return timeSeriesFunc(*u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *CurveFitPlotTypeWithT[T]) TimeSeriesNoopSuccess(TimeSeriesCurveFit) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitPlotTypeWithT[T]) ScatterNoopSuccess(ScatterCurveFit) (T, error) {
	var result T
	return result, nil
}

func (u *CurveFitPlotTypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CurveFitPlotTypeVisitorWithT[T any] interface {
	VisitTimeSeries(ctx context.Context, v TimeSeriesCurveFit) (T, error)
	VisitScatter(ctx context.Context, v ScatterCurveFit) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type DerivedSeriesWithT[T any] DerivedSeries

func (u *DerivedSeriesWithT[T]) Accept(ctx context.Context, v DerivedSeriesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "function":
		if u.function == nil {
			return result, fmt.Errorf("field \"function\" is required")
		}
		return v.VisitFunction(ctx, *u.function)
	}
}

func (u *DerivedSeriesWithT[T]) AcceptFuncs(functionFunc func(FunctionDerivedSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "function":
		if u.function == nil {
			return result, fmt.Errorf("field \"function\" is required")
		}
		return functionFunc(*u.function)
	}
}

func (u *DerivedSeriesWithT[T]) FunctionNoopSuccess(FunctionDerivedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *DerivedSeriesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DerivedSeriesVisitorWithT[T any] interface {
	VisitFunction(ctx context.Context, v FunctionDerivedSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type DurationConstantWithT[T any] DurationConstant

func (u *DurationConstantWithT[T]) Accept(ctx context.Context, v DurationConstantVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(ctx, *u.variable)
	}
}

func (u *DurationConstantWithT[T]) AcceptFuncs(literalFunc func(api1.Duration) (T, error), variableFunc func(api.VariableName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *DurationConstantWithT[T]) LiteralNoopSuccess(api1.Duration) (T, error) {
	var result T
	return result, nil
}

func (u *DurationConstantWithT[T]) VariableNoopSuccess(api.VariableName) (T, error) {
	var result T
	return result, nil
}

func (u *DurationConstantWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DurationConstantVisitorWithT[T any] interface {
	VisitLiteral(ctx context.Context, v api1.Duration) (T, error)
	VisitVariable(ctx context.Context, v api.VariableName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Enum1dArraySeriesWithT[T any] Enum1dArraySeries

func (u *Enum1dArraySeriesWithT[T]) Accept(ctx context.Context, v Enum1dArraySeriesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(ctx, *u.channel)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(ctx, *u.derived)
	}
}

func (u *Enum1dArraySeriesWithT[T]) AcceptFuncs(channelFunc func(api.ChannelSeries) (T, error), rawFunc func(api.Reference) (T, error), derivedFunc func(DerivedSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	}
}

func (u *Enum1dArraySeriesWithT[T]) ChannelNoopSuccess(api.ChannelSeries) (T, error) {
	var result T
	return result, nil
}

func (u *Enum1dArraySeriesWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *Enum1dArraySeriesWithT[T]) DerivedNoopSuccess(DerivedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *Enum1dArraySeriesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Enum1dArraySeriesVisitorWithT[T any] interface {
	VisitChannel(ctx context.Context, v api.ChannelSeries) (T, error)
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitDerived(ctx context.Context, v DerivedSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EnumSeriesWithT[T any] EnumSeries

func (u *EnumSeriesWithT[T]) Accept(ctx context.Context, v EnumSeriesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return result, fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregate(ctx, *u.aggregate)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(ctx, *u.derived)
	case "resample":
		if u.resample == nil {
			return result, fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResample(ctx, *u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(ctx, *u.timeShift)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(ctx, *u.union)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return result, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformation(ctx, *u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return result, fmt.Errorf("field \"valueMap\" is required")
		}
		return v.VisitValueMap(ctx, *u.valueMap)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return result, fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return v.VisitSelect1dArrayIndex(ctx, *u.select1dArrayIndex)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(ctx, *u.extractFromStruct)
	case "eventAggregation":
		if u.eventAggregation == nil {
			return result, fmt.Errorf("field \"eventAggregation\" is required")
		}
		return v.VisitEventAggregation(ctx, *u.eventAggregation)
	}
}

func (u *EnumSeriesWithT[T]) AcceptFuncs(aggregateFunc func(AggregateEnumSeries) (T, error), rawFunc func(api.Reference) (T, error), channelFunc func(api.ChannelSeries) (T, error), derivedFunc func(DerivedSeries) (T, error), resampleFunc func(EnumResampleSeries) (T, error), timeRangeFilterFunc func(EnumTimeRangeFilterSeries) (T, error), timeShiftFunc func(EnumTimeShiftSeries) (T, error), unionFunc func(EnumUnionSeries) (T, error), filterTransformationFunc func(EnumFilterTransformationSeries) (T, error), valueMapFunc func(ValueMapSeries) (T, error), select1dArrayIndexFunc func(SelectIndexFrom1dEnumArraySeries) (T, error), extractFromStructFunc func(ExtractEnumFromStructSeries) (T, error), eventAggregationFunc func(EventsEnumSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return result, fmt.Errorf("field \"aggregate\" is required")
		}
		return aggregateFunc(*u.aggregate)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "resample":
		if u.resample == nil {
			return result, fmt.Errorf("field \"resample\" is required")
		}
		return resampleFunc(*u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return result, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return filterTransformationFunc(*u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return result, fmt.Errorf("field \"valueMap\" is required")
		}
		return valueMapFunc(*u.valueMap)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return result, fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return select1dArrayIndexFunc(*u.select1dArrayIndex)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	case "eventAggregation":
		if u.eventAggregation == nil {
			return result, fmt.Errorf("field \"eventAggregation\" is required")
		}
		return eventAggregationFunc(*u.eventAggregation)
	}
}

func (u *EnumSeriesWithT[T]) AggregateNoopSuccess(AggregateEnumSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) ChannelNoopSuccess(api.ChannelSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) DerivedNoopSuccess(DerivedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) ResampleNoopSuccess(EnumResampleSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) TimeRangeFilterNoopSuccess(EnumTimeRangeFilterSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) TimeShiftNoopSuccess(EnumTimeShiftSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) UnionNoopSuccess(EnumUnionSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) FilterTransformationNoopSuccess(EnumFilterTransformationSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) ValueMapNoopSuccess(ValueMapSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) Select1dArrayIndexNoopSuccess(SelectIndexFrom1dEnumArraySeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) ExtractFromStructNoopSuccess(ExtractEnumFromStructSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) EventAggregationNoopSuccess(EventsEnumSeries) (T, error) {
	var result T
	return result, nil
}

func (u *EnumSeriesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EnumSeriesVisitorWithT[T any] interface {
	VisitAggregate(ctx context.Context, v AggregateEnumSeries) (T, error)
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitChannel(ctx context.Context, v api.ChannelSeries) (T, error)
	VisitDerived(ctx context.Context, v DerivedSeries) (T, error)
	VisitResample(ctx context.Context, v EnumResampleSeries) (T, error)
	VisitTimeRangeFilter(ctx context.Context, v EnumTimeRangeFilterSeries) (T, error)
	VisitTimeShift(ctx context.Context, v EnumTimeShiftSeries) (T, error)
	VisitUnion(ctx context.Context, v EnumUnionSeries) (T, error)
	VisitFilterTransformation(ctx context.Context, v EnumFilterTransformationSeries) (T, error)
	VisitValueMap(ctx context.Context, v ValueMapSeries) (T, error)
	VisitSelect1dArrayIndex(ctx context.Context, v SelectIndexFrom1dEnumArraySeries) (T, error)
	VisitExtractFromStruct(ctx context.Context, v ExtractEnumFromStructSeries) (T, error)
	VisitEventAggregation(ctx context.Context, v EventsEnumSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FrequencyDomainWithT[T any] FrequencyDomain

func (u *FrequencyDomainWithT[T]) Accept(ctx context.Context, v FrequencyDomainVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(ctx, *u.fft)
	case "periodogram":
		if u.periodogram == nil {
			return result, fmt.Errorf("field \"periodogram\" is required")
		}
		return v.VisitPeriodogram(ctx, *u.periodogram)
	}
}

func (u *FrequencyDomainWithT[T]) AcceptFuncs(fftFunc func(Fft) (T, error), periodogramFunc func(Periodogram) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	case "periodogram":
		if u.periodogram == nil {
			return result, fmt.Errorf("field \"periodogram\" is required")
		}
		return periodogramFunc(*u.periodogram)
	}
}

func (u *FrequencyDomainWithT[T]) FftNoopSuccess(Fft) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainWithT[T]) PeriodogramNoopSuccess(Periodogram) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FrequencyDomainVisitorWithT[T any] interface {
	VisitFft(ctx context.Context, v Fft) (T, error)
	VisitPeriodogram(ctx context.Context, v Periodogram) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FrequencyDomainV2WithT[T any] FrequencyDomainV2

func (u *FrequencyDomainV2WithT[T]) Accept(ctx context.Context, v FrequencyDomainV2VisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(ctx, *u.fft)
	case "psd":
		if u.psd == nil {
			return result, fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsd(ctx, *u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return result, fmt.Errorf("field \"cpsd\" is required")
		}
		return v.VisitCpsd(ctx, *u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return result, fmt.Errorf("field \"nyquist\" is required")
		}
		return v.VisitNyquist(ctx, *u.nyquist)
	case "bode":
		if u.bode == nil {
			return result, fmt.Errorf("field \"bode\" is required")
		}
		return v.VisitBode(ctx, *u.bode)
	}
}

func (u *FrequencyDomainV2WithT[T]) AcceptFuncs(fftFunc func(Fft) (T, error), psdFunc func(Psd) (T, error), cpsdFunc func(Cpsd) (T, error), nyquistFunc func(Nyquist) (T, error), bodeFunc func(Bode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	case "psd":
		if u.psd == nil {
			return result, fmt.Errorf("field \"psd\" is required")
		}
		return psdFunc(*u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return result, fmt.Errorf("field \"cpsd\" is required")
		}
		return cpsdFunc(*u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return result, fmt.Errorf("field \"nyquist\" is required")
		}
		return nyquistFunc(*u.nyquist)
	case "bode":
		if u.bode == nil {
			return result, fmt.Errorf("field \"bode\" is required")
		}
		return bodeFunc(*u.bode)
	}
}

func (u *FrequencyDomainV2WithT[T]) FftNoopSuccess(Fft) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainV2WithT[T]) PsdNoopSuccess(Psd) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainV2WithT[T]) CpsdNoopSuccess(Cpsd) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainV2WithT[T]) NyquistNoopSuccess(Nyquist) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainV2WithT[T]) BodeNoopSuccess(Bode) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyDomainV2WithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FrequencyDomainV2VisitorWithT[T any] interface {
	VisitFft(ctx context.Context, v Fft) (T, error)
	VisitPsd(ctx context.Context, v Psd) (T, error)
	VisitCpsd(ctx context.Context, v Cpsd) (T, error)
	VisitNyquist(ctx context.Context, v Nyquist) (T, error)
	VisitBode(ctx context.Context, v Bode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FunctionParameterValueWithT[T any] FunctionParameterValue

func (u *FunctionParameterValueWithT[T]) Accept(ctx context.Context, v FunctionParameterValueVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(ctx, *u.variable)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(ctx, *u.value)
	}
}

func (u *FunctionParameterValueWithT[T]) AcceptFuncs(variableFunc func(api.VariableName) (T, error), valueFunc func(VariableValue) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *FunctionParameterValueWithT[T]) VariableNoopSuccess(api.VariableName) (T, error) {
	var result T
	return result, nil
}

func (u *FunctionParameterValueWithT[T]) ValueNoopSuccess(VariableValue) (T, error) {
	var result T
	return result, nil
}

func (u *FunctionParameterValueWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FunctionParameterValueVisitorWithT[T any] interface {
	VisitVariable(ctx context.Context, v api.VariableName) (T, error)
	VisitValue(ctx context.Context, v VariableValue) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type HistogramWithT[T any] Histogram

func (u *HistogramWithT[T]) Accept(ctx context.Context, v HistogramVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	}
}

func (u *HistogramWithT[T]) AcceptFuncs(numericFunc func(NumericHistogramNode) (T, error), enumFunc func(EnumHistogramNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	}
}

func (u *HistogramWithT[T]) NumericNoopSuccess(NumericHistogramNode) (T, error) {
	var result T
	return result, nil
}

func (u *HistogramWithT[T]) EnumNoopSuccess(EnumHistogramNode) (T, error) {
	var result T
	return result, nil
}

func (u *HistogramWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type HistogramVisitorWithT[T any] interface {
	VisitNumeric(ctx context.Context, v NumericHistogramNode) (T, error)
	VisitEnum(ctx context.Context, v EnumHistogramNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type InterpolationConfigurationWithT[T any] InterpolationConfiguration

func (u *InterpolationConfigurationWithT[T]) Accept(ctx context.Context, v InterpolationConfigurationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return result, fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return v.VisitForwardFillInterpolation(ctx, *u.forwardFillInterpolation)
	}
}

func (u *InterpolationConfigurationWithT[T]) AcceptFuncs(forwardFillInterpolationFunc func(ForwardFillInterpolation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return result, fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return forwardFillInterpolationFunc(*u.forwardFillInterpolation)
	}
}

func (u *InterpolationConfigurationWithT[T]) ForwardFillInterpolationNoopSuccess(ForwardFillInterpolation) (T, error) {
	var result T
	return result, nil
}

func (u *InterpolationConfigurationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type InterpolationConfigurationVisitorWithT[T any] interface {
	VisitForwardFillInterpolation(ctx context.Context, v ForwardFillInterpolation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type LogSeriesWithT[T any] LogSeries

func (u *LogSeriesWithT[T]) Accept(ctx context.Context, v LogSeriesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(ctx, *u.derived)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(ctx, *u.union)
	case "filter":
		if u.filter == nil {
			return result, fmt.Errorf("field \"filter\" is required")
		}
		return v.VisitFilter(ctx, *u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(ctx, *u.timeShift)
	}
}

func (u *LogSeriesWithT[T]) AcceptFuncs(rawFunc func(api.Reference) (T, error), channelFunc func(api.ChannelSeries) (T, error), derivedFunc func(DerivedSeries) (T, error), unionFunc func(LogUnionSeries) (T, error), filterFunc func(LogFilterSeries) (T, error), timeShiftFunc func(LogTimeShiftSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "filter":
		if u.filter == nil {
			return result, fmt.Errorf("field \"filter\" is required")
		}
		return filterFunc(*u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	}
}

func (u *LogSeriesWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *LogSeriesWithT[T]) ChannelNoopSuccess(api.ChannelSeries) (T, error) {
	var result T
	return result, nil
}

func (u *LogSeriesWithT[T]) DerivedNoopSuccess(DerivedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *LogSeriesWithT[T]) UnionNoopSuccess(LogUnionSeries) (T, error) {
	var result T
	return result, nil
}

func (u *LogSeriesWithT[T]) FilterNoopSuccess(LogFilterSeries) (T, error) {
	var result T
	return result, nil
}

func (u *LogSeriesWithT[T]) TimeShiftNoopSuccess(LogTimeShiftSeries) (T, error) {
	var result T
	return result, nil
}

func (u *LogSeriesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LogSeriesVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitChannel(ctx context.Context, v api.ChannelSeries) (T, error)
	VisitDerived(ctx context.Context, v DerivedSeries) (T, error)
	VisitUnion(ctx context.Context, v LogUnionSeries) (T, error)
	VisitFilter(ctx context.Context, v LogFilterSeries) (T, error)
	VisitTimeShift(ctx context.Context, v LogTimeShiftSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Numeric1dArraySeriesWithT[T any] Numeric1dArraySeries

func (u *Numeric1dArraySeriesWithT[T]) Accept(ctx context.Context, v Numeric1dArraySeriesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(ctx, *u.channel)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(ctx, *u.derived)
	}
}

func (u *Numeric1dArraySeriesWithT[T]) AcceptFuncs(channelFunc func(api.ChannelSeries) (T, error), rawFunc func(api.Reference) (T, error), derivedFunc func(DerivedSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	}
}

func (u *Numeric1dArraySeriesWithT[T]) ChannelNoopSuccess(api.ChannelSeries) (T, error) {
	var result T
	return result, nil
}

func (u *Numeric1dArraySeriesWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *Numeric1dArraySeriesWithT[T]) DerivedNoopSuccess(DerivedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *Numeric1dArraySeriesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Numeric1dArraySeriesVisitorWithT[T any] interface {
	VisitChannel(ctx context.Context, v api.ChannelSeries) (T, error)
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitDerived(ctx context.Context, v DerivedSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericSeriesWithT[T any] NumericSeries

func (u *NumericSeriesWithT[T]) Accept(ctx context.Context, v NumericSeriesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return result, fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregate(ctx, *u.aggregate)
	case "arithmetic":
		if u.arithmetic == nil {
			return result, fmt.Errorf("field \"arithmetic\" is required")
		}
		return v.VisitArithmetic(ctx, *u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return result, fmt.Errorf("field \"bitOperation\" is required")
		}
		return v.VisitBitOperation(ctx, *u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return result, fmt.Errorf("field \"countDuplicate\" is required")
		}
		return v.VisitCountDuplicate(ctx, *u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return result, fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return v.VisitCumulativeSum(ctx, *u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return result, fmt.Errorf("field \"derivative\" is required")
		}
		return v.VisitDerivative(ctx, *u.derivative)
	case "integral":
		if u.integral == nil {
			return result, fmt.Errorf("field \"integral\" is required")
		}
		return v.VisitIntegral(ctx, *u.integral)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(ctx, *u.max)
	case "mean":
		if u.mean == nil {
			return result, fmt.Errorf("field \"mean\" is required")
		}
		return v.VisitMean(ctx, *u.mean)
	case "min":
		if u.min == nil {
			return result, fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(ctx, *u.min)
	case "offset":
		if u.offset == nil {
			return result, fmt.Errorf("field \"offset\" is required")
		}
		return v.VisitOffset(ctx, *u.offset)
	case "product":
		if u.product == nil {
			return result, fmt.Errorf("field \"product\" is required")
		}
		return v.VisitProduct(ctx, *u.product)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(ctx, *u.derived)
	case "resample":
		if u.resample == nil {
			return result, fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResample(ctx, *u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return result, fmt.Errorf("field \"rollingOperation\" is required")
		}
		return v.VisitRollingOperation(ctx, *u.rollingOperation)
	case "signalFilter":
		if u.signalFilter == nil {
			return result, fmt.Errorf("field \"signalFilter\" is required")
		}
		return v.VisitSignalFilter(ctx, *u.signalFilter)
	case "sum":
		if u.sum == nil {
			return result, fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSum(ctx, *u.sum)
	case "scale":
		if u.scale == nil {
			return result, fmt.Errorf("field \"scale\" is required")
		}
		return v.VisitScale(ctx, *u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return result, fmt.Errorf("field \"timeDifference\" is required")
		}
		return v.VisitTimeDifference(ctx, *u.timeDifference)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return result, fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return v.VisitAbsoluteTimestamp(ctx, *u.absoluteTimestamp)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(ctx, *u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return result, fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return v.VisitUnaryArithmetic(ctx, *u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return result, fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return v.VisitBinaryArithmetic(ctx, *u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(ctx, *u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return result, fmt.Errorf("field \"unitConversion\" is required")
		}
		return v.VisitUnitConversion(ctx, *u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return result, fmt.Errorf("field \"valueDifference\" is required")
		}
		return v.VisitValueDifference(ctx, *u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return result, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformation(ctx, *u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return result, fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return v.VisitThresholdFilter(ctx, *u.thresholdFilter)
	case "approximateFilter":
		if u.approximateFilter == nil {
			return result, fmt.Errorf("field \"approximateFilter\" is required")
		}
		return v.VisitApproximateFilter(ctx, *u.approximateFilter)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return result, fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return v.VisitSelect1dArrayIndex(ctx, *u.select1dArrayIndex)
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return result, fmt.Errorf("field \"selectNewestPoints\" is required")
		}
		return v.VisitSelectNewestPoints(ctx, *u.selectNewestPoints)
	case "aggregateUnderRanges":
		if u.aggregateUnderRanges == nil {
			return result, fmt.Errorf("field \"aggregateUnderRanges\" is required")
		}
		return v.VisitAggregateUnderRanges(ctx, *u.aggregateUnderRanges)
	case "filterByExpression":
		if u.filterByExpression == nil {
			return result, fmt.Errorf("field \"filterByExpression\" is required")
		}
		return v.VisitFilterByExpression(ctx, *u.filterByExpression)
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return result, fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return v.VisitEnumToNumeric(ctx, *u.enumToNumeric)
	case "refprop":
		if u.refprop == nil {
			return result, fmt.Errorf("field \"refprop\" is required")
		}
		return v.VisitRefprop(ctx, *u.refprop)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(ctx, *u.extractFromStruct)
	}
}

func (u *NumericSeriesWithT[T]) AcceptFuncs(aggregateFunc func(AggregateNumericSeries) (T, error), arithmeticFunc func(ArithmeticSeries) (T, error), bitOperationFunc func(BitOperationSeries) (T, error), countDuplicateFunc func(EnumCountDuplicateSeries) (T, error), cumulativeSumFunc func(CumulativeSumSeries) (T, error), derivativeFunc func(DerivativeSeries) (T, error), integralFunc func(IntegralSeries) (T, error), maxFunc func(MaxSeries) (T, error), meanFunc func(MeanSeries) (T, error), minFunc func(MinSeries) (T, error), offsetFunc func(OffsetSeries) (T, error), productFunc func(ProductSeries) (T, error), rawFunc func(api.Reference) (T, error), channelFunc func(api.ChannelSeries) (T, error), derivedFunc func(DerivedSeries) (T, error), resampleFunc func(NumericResampleSeries) (T, error), rollingOperationFunc func(RollingOperationSeries) (T, error), signalFilterFunc func(SignalFilterSeries) (T, error), sumFunc func(SumSeries) (T, error), scaleFunc func(ScaleSeries) (T, error), timeDifferenceFunc func(TimeDifferenceSeries) (T, error), absoluteTimestampFunc func(AbsoluteTimestampSeries) (T, error), timeRangeFilterFunc func(NumericTimeRangeFilterSeries) (T, error), timeShiftFunc func(NumericTimeShiftSeries) (T, error), unaryArithmeticFunc func(UnaryArithmeticSeries) (T, error), binaryArithmeticFunc func(BinaryArithmeticSeries) (T, error), unionFunc func(NumericUnionSeries) (T, error), unitConversionFunc func(UnitConversionSeries) (T, error), valueDifferenceFunc func(ValueDifferenceSeries) (T, error), filterTransformationFunc func(NumericFilterTransformationSeries) (T, error), thresholdFilterFunc func(NumericThresholdFilterSeries) (T, error), approximateFilterFunc func(NumericApproximateFilterSeries) (T, error), select1dArrayIndexFunc func(SelectIndexFrom1dNumericArraySeries) (T, error), selectNewestPointsFunc func(SelectNewestPointsSeries) (T, error), aggregateUnderRangesFunc func(AggregateUnderRangesSeries) (T, error), filterByExpressionFunc func(FilterByExpressionSeries) (T, error), enumToNumericFunc func(EnumToNumericSeries) (T, error), refpropFunc func(RefpropSeries) (T, error), extractFromStructFunc func(ExtractNumericFromStructSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return result, fmt.Errorf("field \"aggregate\" is required")
		}
		return aggregateFunc(*u.aggregate)
	case "arithmetic":
		if u.arithmetic == nil {
			return result, fmt.Errorf("field \"arithmetic\" is required")
		}
		return arithmeticFunc(*u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return result, fmt.Errorf("field \"bitOperation\" is required")
		}
		return bitOperationFunc(*u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return result, fmt.Errorf("field \"countDuplicate\" is required")
		}
		return countDuplicateFunc(*u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return result, fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return cumulativeSumFunc(*u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return result, fmt.Errorf("field \"derivative\" is required")
		}
		return derivativeFunc(*u.derivative)
	case "integral":
		if u.integral == nil {
			return result, fmt.Errorf("field \"integral\" is required")
		}
		return integralFunc(*u.integral)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "mean":
		if u.mean == nil {
			return result, fmt.Errorf("field \"mean\" is required")
		}
		return meanFunc(*u.mean)
	case "min":
		if u.min == nil {
			return result, fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "offset":
		if u.offset == nil {
			return result, fmt.Errorf("field \"offset\" is required")
		}
		return offsetFunc(*u.offset)
	case "product":
		if u.product == nil {
			return result, fmt.Errorf("field \"product\" is required")
		}
		return productFunc(*u.product)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "resample":
		if u.resample == nil {
			return result, fmt.Errorf("field \"resample\" is required")
		}
		return resampleFunc(*u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return result, fmt.Errorf("field \"rollingOperation\" is required")
		}
		return rollingOperationFunc(*u.rollingOperation)
	case "signalFilter":
		if u.signalFilter == nil {
			return result, fmt.Errorf("field \"signalFilter\" is required")
		}
		return signalFilterFunc(*u.signalFilter)
	case "sum":
		if u.sum == nil {
			return result, fmt.Errorf("field \"sum\" is required")
		}
		return sumFunc(*u.sum)
	case "scale":
		if u.scale == nil {
			return result, fmt.Errorf("field \"scale\" is required")
		}
		return scaleFunc(*u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return result, fmt.Errorf("field \"timeDifference\" is required")
		}
		return timeDifferenceFunc(*u.timeDifference)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return result, fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return absoluteTimestampFunc(*u.absoluteTimestamp)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return result, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return result, fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return result, fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return unaryArithmeticFunc(*u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return result, fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return binaryArithmeticFunc(*u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return result, fmt.Errorf("field \"unitConversion\" is required")
		}
		return unitConversionFunc(*u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return result, fmt.Errorf("field \"valueDifference\" is required")
		}
		return valueDifferenceFunc(*u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return result, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return filterTransformationFunc(*u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return result, fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return thresholdFilterFunc(*u.thresholdFilter)
	case "approximateFilter":
		if u.approximateFilter == nil {
			return result, fmt.Errorf("field \"approximateFilter\" is required")
		}
		return approximateFilterFunc(*u.approximateFilter)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return result, fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return select1dArrayIndexFunc(*u.select1dArrayIndex)
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return result, fmt.Errorf("field \"selectNewestPoints\" is required")
		}
		return selectNewestPointsFunc(*u.selectNewestPoints)
	case "aggregateUnderRanges":
		if u.aggregateUnderRanges == nil {
			return result, fmt.Errorf("field \"aggregateUnderRanges\" is required")
		}
		return aggregateUnderRangesFunc(*u.aggregateUnderRanges)
	case "filterByExpression":
		if u.filterByExpression == nil {
			return result, fmt.Errorf("field \"filterByExpression\" is required")
		}
		return filterByExpressionFunc(*u.filterByExpression)
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return result, fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return enumToNumericFunc(*u.enumToNumeric)
	case "refprop":
		if u.refprop == nil {
			return result, fmt.Errorf("field \"refprop\" is required")
		}
		return refpropFunc(*u.refprop)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	}
}

func (u *NumericSeriesWithT[T]) AggregateNoopSuccess(AggregateNumericSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) ArithmeticNoopSuccess(ArithmeticSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) BitOperationNoopSuccess(BitOperationSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) CountDuplicateNoopSuccess(EnumCountDuplicateSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) CumulativeSumNoopSuccess(CumulativeSumSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) DerivativeNoopSuccess(DerivativeSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) IntegralNoopSuccess(IntegralSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) MaxNoopSuccess(MaxSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) MeanNoopSuccess(MeanSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) MinNoopSuccess(MinSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) OffsetNoopSuccess(OffsetSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) ProductNoopSuccess(ProductSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) ChannelNoopSuccess(api.ChannelSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) DerivedNoopSuccess(DerivedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) ResampleNoopSuccess(NumericResampleSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) RollingOperationNoopSuccess(RollingOperationSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) SignalFilterNoopSuccess(SignalFilterSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) SumNoopSuccess(SumSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) ScaleNoopSuccess(ScaleSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) TimeDifferenceNoopSuccess(TimeDifferenceSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) AbsoluteTimestampNoopSuccess(AbsoluteTimestampSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) TimeRangeFilterNoopSuccess(NumericTimeRangeFilterSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) TimeShiftNoopSuccess(NumericTimeShiftSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) UnaryArithmeticNoopSuccess(UnaryArithmeticSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) BinaryArithmeticNoopSuccess(BinaryArithmeticSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) UnionNoopSuccess(NumericUnionSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) UnitConversionNoopSuccess(UnitConversionSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) ValueDifferenceNoopSuccess(ValueDifferenceSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) FilterTransformationNoopSuccess(NumericFilterTransformationSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) ThresholdFilterNoopSuccess(NumericThresholdFilterSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) ApproximateFilterNoopSuccess(NumericApproximateFilterSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) Select1dArrayIndexNoopSuccess(SelectIndexFrom1dNumericArraySeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) SelectNewestPointsNoopSuccess(SelectNewestPointsSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) AggregateUnderRangesNoopSuccess(AggregateUnderRangesSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) FilterByExpressionNoopSuccess(FilterByExpressionSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) EnumToNumericNoopSuccess(EnumToNumericSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) RefpropNoopSuccess(RefpropSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) ExtractFromStructNoopSuccess(ExtractNumericFromStructSeries) (T, error) {
	var result T
	return result, nil
}

func (u *NumericSeriesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericSeriesVisitorWithT[T any] interface {
	VisitAggregate(ctx context.Context, v AggregateNumericSeries) (T, error)
	VisitArithmetic(ctx context.Context, v ArithmeticSeries) (T, error)
	VisitBitOperation(ctx context.Context, v BitOperationSeries) (T, error)
	VisitCountDuplicate(ctx context.Context, v EnumCountDuplicateSeries) (T, error)
	VisitCumulativeSum(ctx context.Context, v CumulativeSumSeries) (T, error)
	VisitDerivative(ctx context.Context, v DerivativeSeries) (T, error)
	VisitIntegral(ctx context.Context, v IntegralSeries) (T, error)
	VisitMax(ctx context.Context, v MaxSeries) (T, error)
	VisitMean(ctx context.Context, v MeanSeries) (T, error)
	VisitMin(ctx context.Context, v MinSeries) (T, error)
	VisitOffset(ctx context.Context, v OffsetSeries) (T, error)
	VisitProduct(ctx context.Context, v ProductSeries) (T, error)
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitChannel(ctx context.Context, v api.ChannelSeries) (T, error)
	VisitDerived(ctx context.Context, v DerivedSeries) (T, error)
	VisitResample(ctx context.Context, v NumericResampleSeries) (T, error)
	VisitRollingOperation(ctx context.Context, v RollingOperationSeries) (T, error)
	VisitSignalFilter(ctx context.Context, v SignalFilterSeries) (T, error)
	VisitSum(ctx context.Context, v SumSeries) (T, error)
	VisitScale(ctx context.Context, v ScaleSeries) (T, error)
	VisitTimeDifference(ctx context.Context, v TimeDifferenceSeries) (T, error)
	VisitAbsoluteTimestamp(ctx context.Context, v AbsoluteTimestampSeries) (T, error)
	VisitTimeRangeFilter(ctx context.Context, v NumericTimeRangeFilterSeries) (T, error)
	VisitTimeShift(ctx context.Context, v NumericTimeShiftSeries) (T, error)
	VisitUnaryArithmetic(ctx context.Context, v UnaryArithmeticSeries) (T, error)
	VisitBinaryArithmetic(ctx context.Context, v BinaryArithmeticSeries) (T, error)
	VisitUnion(ctx context.Context, v NumericUnionSeries) (T, error)
	VisitUnitConversion(ctx context.Context, v UnitConversionSeries) (T, error)
	VisitValueDifference(ctx context.Context, v ValueDifferenceSeries) (T, error)
	VisitFilterTransformation(ctx context.Context, v NumericFilterTransformationSeries) (T, error)
	VisitThresholdFilter(ctx context.Context, v NumericThresholdFilterSeries) (T, error)
	VisitApproximateFilter(ctx context.Context, v NumericApproximateFilterSeries) (T, error)
	VisitSelect1dArrayIndex(ctx context.Context, v SelectIndexFrom1dNumericArraySeries) (T, error)
	VisitSelectNewestPoints(ctx context.Context, v SelectNewestPointsSeries) (T, error)
	VisitAggregateUnderRanges(ctx context.Context, v AggregateUnderRangesSeries) (T, error)
	VisitFilterByExpression(ctx context.Context, v FilterByExpressionSeries) (T, error)
	VisitEnumToNumeric(ctx context.Context, v EnumToNumericSeries) (T, error)
	VisitRefprop(ctx context.Context, v RefpropSeries) (T, error)
	VisitExtractFromStruct(ctx context.Context, v ExtractNumericFromStructSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type RangeSeriesWithT[T any] RangeSeries

func (u *RangeSeriesWithT[T]) Accept(ctx context.Context, v RangeSeriesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return result, fmt.Errorf("field \"approximateThreshold\" is required")
		}
		return v.VisitApproximateThreshold(ctx, *u.approximateThreshold)
	case "durationFilter":
		if u.durationFilter == nil {
			return result, fmt.Errorf("field \"durationFilter\" is required")
		}
		return v.VisitDurationFilter(ctx, *u.durationFilter)
	case "enumFilter":
		if u.enumFilter == nil {
			return result, fmt.Errorf("field \"enumFilter\" is required")
		}
		return v.VisitEnumFilter(ctx, *u.enumFilter)
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return result, fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
		return v.VisitEnumSeriesEqualityRangesNode(ctx, *u.enumSeriesEqualityRangesNode)
	case "eventsSearch":
		if u.eventsSearch == nil {
			return result, fmt.Errorf("field \"eventsSearch\" is required")
		}
		return v.VisitEventsSearch(ctx, *u.eventsSearch)
	case "intersectRange":
		if u.intersectRange == nil {
			return result, fmt.Errorf("field \"intersectRange\" is required")
		}
		return v.VisitIntersectRange(ctx, *u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return result, fmt.Errorf("field \"literalRanges\" is required")
		}
		return v.VisitLiteralRanges(ctx, *u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return result, fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return v.VisitMinMaxThreshold(ctx, *u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(ctx, *u.not)
	case "onChange":
		if u.onChange == nil {
			return result, fmt.Errorf("field \"onChange\" is required")
		}
		return v.VisitOnChange(ctx, *u.onChange)
	case "peak":
		if u.peak == nil {
			return result, fmt.Errorf("field \"peak\" is required")
		}
		return v.VisitPeak(ctx, *u.peak)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return result, fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return v.VisitRangeNumericAggregation(ctx, *u.rangeNumericAggregation)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(ctx, *u.derived)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return result, fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return v.VisitSeriesCrossoverRangesNode(ctx, *u.seriesCrossoverRangesNode)
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return result, fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
		return v.VisitSeriesEqualityRangesNode(ctx, *u.seriesEqualityRangesNode)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return result, fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return v.VisitStabilityDetection(ctx, *u.stabilityDetection)
	case "staleRange":
		if u.staleRange == nil {
			return result, fmt.Errorf("field \"staleRange\" is required")
		}
		return v.VisitStaleRange(ctx, *u.staleRange)
	case "threshold":
		if u.threshold == nil {
			return result, fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThreshold(ctx, *u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return result, fmt.Errorf("field \"unionRange\" is required")
		}
		return v.VisitUnionRange(ctx, *u.unionRange)
	case "paddedRanges":
		if u.paddedRanges == nil {
			return result, fmt.Errorf("field \"paddedRanges\" is required")
		}
		return v.VisitPaddedRanges(ctx, *u.paddedRanges)
	}
}

func (u *RangeSeriesWithT[T]) AcceptFuncs(approximateThresholdFunc func(ApproximateThresholdRanges) (T, error), durationFilterFunc func(DurationFilterRanges) (T, error), enumFilterFunc func(EnumFilterRanges) (T, error), enumSeriesEqualityRangesNodeFunc func(EnumSeriesEqualityRanges) (T, error), eventsSearchFunc func(EventsSearchRanges) (T, error), intersectRangeFunc func(IntersectRanges) (T, error), literalRangesFunc func(api.LiteralRanges) (T, error), minMaxThresholdFunc func(MinMaxThresholdRanges) (T, error), notFunc func(NotRanges) (T, error), onChangeFunc func(OnChangeRanges) (T, error), peakFunc func(PeakRanges) (T, error), rangeNumericAggregationFunc func(RangesNumericAggregation) (T, error), rawFunc func(api.Reference) (T, error), derivedFunc func(DerivedSeries) (T, error), seriesCrossoverRangesNodeFunc func(SeriesCrossoverRanges) (T, error), seriesEqualityRangesNodeFunc func(SeriesEqualityRanges) (T, error), stabilityDetectionFunc func(StabilityDetectionRanges) (T, error), staleRangeFunc func(StaleRanges) (T, error), thresholdFunc func(ThresholdingRanges) (T, error), unionRangeFunc func(UnionRanges) (T, error), paddedRangesFunc func(PaddedRanges) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return result, fmt.Errorf("field \"approximateThreshold\" is required")
		}
		return approximateThresholdFunc(*u.approximateThreshold)
	case "durationFilter":
		if u.durationFilter == nil {
			return result, fmt.Errorf("field \"durationFilter\" is required")
		}
		return durationFilterFunc(*u.durationFilter)
	case "enumFilter":
		if u.enumFilter == nil {
			return result, fmt.Errorf("field \"enumFilter\" is required")
		}
		return enumFilterFunc(*u.enumFilter)
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return result, fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
		return enumSeriesEqualityRangesNodeFunc(*u.enumSeriesEqualityRangesNode)
	case "eventsSearch":
		if u.eventsSearch == nil {
			return result, fmt.Errorf("field \"eventsSearch\" is required")
		}
		return eventsSearchFunc(*u.eventsSearch)
	case "intersectRange":
		if u.intersectRange == nil {
			return result, fmt.Errorf("field \"intersectRange\" is required")
		}
		return intersectRangeFunc(*u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return result, fmt.Errorf("field \"literalRanges\" is required")
		}
		return literalRangesFunc(*u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return result, fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return minMaxThresholdFunc(*u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "onChange":
		if u.onChange == nil {
			return result, fmt.Errorf("field \"onChange\" is required")
		}
		return onChangeFunc(*u.onChange)
	case "peak":
		if u.peak == nil {
			return result, fmt.Errorf("field \"peak\" is required")
		}
		return peakFunc(*u.peak)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return result, fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return rangeNumericAggregationFunc(*u.rangeNumericAggregation)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return result, fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return seriesCrossoverRangesNodeFunc(*u.seriesCrossoverRangesNode)
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return result, fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
		return seriesEqualityRangesNodeFunc(*u.seriesEqualityRangesNode)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return result, fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return stabilityDetectionFunc(*u.stabilityDetection)
	case "staleRange":
		if u.staleRange == nil {
			return result, fmt.Errorf("field \"staleRange\" is required")
		}
		return staleRangeFunc(*u.staleRange)
	case "threshold":
		if u.threshold == nil {
			return result, fmt.Errorf("field \"threshold\" is required")
		}
		return thresholdFunc(*u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return result, fmt.Errorf("field \"unionRange\" is required")
		}
		return unionRangeFunc(*u.unionRange)
	case "paddedRanges":
		if u.paddedRanges == nil {
			return result, fmt.Errorf("field \"paddedRanges\" is required")
		}
		return paddedRangesFunc(*u.paddedRanges)
	}
}

func (u *RangeSeriesWithT[T]) ApproximateThresholdNoopSuccess(ApproximateThresholdRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) DurationFilterNoopSuccess(DurationFilterRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) EnumFilterNoopSuccess(EnumFilterRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) EnumSeriesEqualityRangesNodeNoopSuccess(EnumSeriesEqualityRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) EventsSearchNoopSuccess(EventsSearchRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) IntersectRangeNoopSuccess(IntersectRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) LiteralRangesNoopSuccess(api.LiteralRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) MinMaxThresholdNoopSuccess(MinMaxThresholdRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) NotNoopSuccess(NotRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) OnChangeNoopSuccess(OnChangeRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) PeakNoopSuccess(PeakRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) RangeNumericAggregationNoopSuccess(RangesNumericAggregation) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) DerivedNoopSuccess(DerivedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) SeriesCrossoverRangesNodeNoopSuccess(SeriesCrossoverRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) SeriesEqualityRangesNodeNoopSuccess(SeriesEqualityRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) StabilityDetectionNoopSuccess(StabilityDetectionRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) StaleRangeNoopSuccess(StaleRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) ThresholdNoopSuccess(ThresholdingRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) UnionRangeNoopSuccess(UnionRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) PaddedRangesNoopSuccess(PaddedRanges) (T, error) {
	var result T
	return result, nil
}

func (u *RangeSeriesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type RangeSeriesVisitorWithT[T any] interface {
	VisitApproximateThreshold(ctx context.Context, v ApproximateThresholdRanges) (T, error)
	VisitDurationFilter(ctx context.Context, v DurationFilterRanges) (T, error)
	VisitEnumFilter(ctx context.Context, v EnumFilterRanges) (T, error)
	VisitEnumSeriesEqualityRangesNode(ctx context.Context, v EnumSeriesEqualityRanges) (T, error)
	VisitEventsSearch(ctx context.Context, v EventsSearchRanges) (T, error)
	VisitIntersectRange(ctx context.Context, v IntersectRanges) (T, error)
	VisitLiteralRanges(ctx context.Context, v api.LiteralRanges) (T, error)
	VisitMinMaxThreshold(ctx context.Context, v MinMaxThresholdRanges) (T, error)
	VisitNot(ctx context.Context, v NotRanges) (T, error)
	VisitOnChange(ctx context.Context, v OnChangeRanges) (T, error)
	VisitPeak(ctx context.Context, v PeakRanges) (T, error)
	VisitRangeNumericAggregation(ctx context.Context, v RangesNumericAggregation) (T, error)
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitDerived(ctx context.Context, v DerivedSeries) (T, error)
	VisitSeriesCrossoverRangesNode(ctx context.Context, v SeriesCrossoverRanges) (T, error)
	VisitSeriesEqualityRangesNode(ctx context.Context, v SeriesEqualityRanges) (T, error)
	VisitStabilityDetection(ctx context.Context, v StabilityDetectionRanges) (T, error)
	VisitStaleRange(ctx context.Context, v StaleRanges) (T, error)
	VisitThreshold(ctx context.Context, v ThresholdingRanges) (T, error)
	VisitUnionRange(ctx context.Context, v UnionRanges) (T, error)
	VisitPaddedRanges(ctx context.Context, v PaddedRanges) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SelectValueWithT[T any] SelectValue

func (u *SelectValueWithT[T]) Accept(ctx context.Context, v SelectValueVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return result, fmt.Errorf("field \"firstPoint\" is required")
		}
		return v.VisitFirstPoint(ctx, *u.firstPoint)
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return result, fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return v.VisitFirstValuePoint(ctx, *u.firstValuePoint)
	case "firstRange":
		if u.firstRange == nil {
			return result, fmt.Errorf("field \"firstRange\" is required")
		}
		return v.VisitFirstRange(ctx, *u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return result, fmt.Errorf("field \"lastPoint\" is required")
		}
		return v.VisitLastPoint(ctx, *u.lastPoint)
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return result, fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return v.VisitLastValuePoint(ctx, *u.lastValuePoint)
	case "lastRange":
		if u.lastRange == nil {
			return result, fmt.Errorf("field \"lastRange\" is required")
		}
		return v.VisitLastRange(ctx, *u.lastRange)
	}
}

func (u *SelectValueWithT[T]) AcceptFuncs(firstPointFunc func(Series) (T, error), firstValuePointFunc func(Series) (T, error), firstRangeFunc func(RangeSeries) (T, error), lastPointFunc func(Series) (T, error), lastValuePointFunc func(Series) (T, error), lastRangeFunc func(RangeSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return result, fmt.Errorf("field \"firstPoint\" is required")
		}
		return firstPointFunc(*u.firstPoint)
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return result, fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return firstValuePointFunc(*u.firstValuePoint)
	case "firstRange":
		if u.firstRange == nil {
			return result, fmt.Errorf("field \"firstRange\" is required")
		}
		return firstRangeFunc(*u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return result, fmt.Errorf("field \"lastPoint\" is required")
		}
		return lastPointFunc(*u.lastPoint)
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return result, fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return lastValuePointFunc(*u.lastValuePoint)
	case "lastRange":
		if u.lastRange == nil {
			return result, fmt.Errorf("field \"lastRange\" is required")
		}
		return lastRangeFunc(*u.lastRange)
	}
}

func (u *SelectValueWithT[T]) FirstPointNoopSuccess(Series) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueWithT[T]) FirstValuePointNoopSuccess(Series) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueWithT[T]) FirstRangeNoopSuccess(RangeSeries) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueWithT[T]) LastPointNoopSuccess(Series) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueWithT[T]) LastValuePointNoopSuccess(Series) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueWithT[T]) LastRangeNoopSuccess(RangeSeries) (T, error) {
	var result T
	return result, nil
}

func (u *SelectValueWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SelectValueVisitorWithT[T any] interface {
	VisitFirstPoint(ctx context.Context, v Series) (T, error)
	VisitFirstValuePoint(ctx context.Context, v Series) (T, error)
	VisitFirstRange(ctx context.Context, v RangeSeries) (T, error)
	VisitLastPoint(ctx context.Context, v Series) (T, error)
	VisitLastValuePoint(ctx context.Context, v Series) (T, error)
	VisitLastRange(ctx context.Context, v RangeSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SeriesWithT[T any] Series

func (u *SeriesWithT[T]) Accept(ctx context.Context, v SeriesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(ctx, *u.log)
	case "array":
		if u.array == nil {
			return result, fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(ctx, *u.array)
	case "struct":
		if u.struct_ == nil {
			return result, fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStruct(ctx, *u.struct_)
	}
}

func (u *SeriesWithT[T]) AcceptFuncs(rawFunc func(api.Reference) (T, error), enumFunc func(EnumSeries) (T, error), numericFunc func(NumericSeries) (T, error), logFunc func(LogSeries) (T, error), arrayFunc func(ArraySeries) (T, error), struct_Func func(StructSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "array":
		if u.array == nil {
			return result, fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	case "struct":
		if u.struct_ == nil {
			return result, fmt.Errorf("field \"struct\" is required")
		}
		return struct_Func(*u.struct_)
	}
}

func (u *SeriesWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesWithT[T]) EnumNoopSuccess(EnumSeries) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesWithT[T]) NumericNoopSuccess(NumericSeries) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesWithT[T]) LogNoopSuccess(LogSeries) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesWithT[T]) ArrayNoopSuccess(ArraySeries) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesWithT[T]) StructNoopSuccess(StructSeries) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SeriesVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitEnum(ctx context.Context, v EnumSeries) (T, error)
	VisitNumeric(ctx context.Context, v NumericSeries) (T, error)
	VisitLog(ctx context.Context, v LogSeries) (T, error)
	VisitArray(ctx context.Context, v ArraySeries) (T, error)
	VisitStruct(ctx context.Context, v StructSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type StructSeriesWithT[T any] StructSeries

func (u *StructSeriesWithT[T]) Accept(ctx context.Context, v StructSeriesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(ctx, *u.channel)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(ctx, *u.derived)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(ctx, *u.extractFromStruct)
	}
}

func (u *StructSeriesWithT[T]) AcceptFuncs(channelFunc func(api.ChannelSeries) (T, error), rawFunc func(api.Reference) (T, error), derivedFunc func(DerivedSeries) (T, error), extractFromStructFunc func(ExtractStructFromStructSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return result, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	}
}

func (u *StructSeriesWithT[T]) ChannelNoopSuccess(api.ChannelSeries) (T, error) {
	var result T
	return result, nil
}

func (u *StructSeriesWithT[T]) RawNoopSuccess(api.Reference) (T, error) {
	var result T
	return result, nil
}

func (u *StructSeriesWithT[T]) DerivedNoopSuccess(DerivedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *StructSeriesWithT[T]) ExtractFromStructNoopSuccess(ExtractStructFromStructSeries) (T, error) {
	var result T
	return result, nil
}

func (u *StructSeriesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type StructSeriesVisitorWithT[T any] interface {
	VisitChannel(ctx context.Context, v api.ChannelSeries) (T, error)
	VisitRaw(ctx context.Context, v api.Reference) (T, error)
	VisitDerived(ctx context.Context, v DerivedSeries) (T, error)
	VisitExtractFromStruct(ctx context.Context, v ExtractStructFromStructSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VariableValueWithT[T any] VariableValue

func (u *VariableValueWithT[T]) Accept(ctx context.Context, v VariableValueVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "double":
		if u.double == nil {
			return result, fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(ctx, *u.double)
	case "computeNode":
		if u.computeNode == nil {
			return result, fmt.Errorf("field \"computeNode\" is required")
		}
		return v.VisitComputeNode(ctx, *u.computeNode)
	case "duration":
		if u.duration == nil {
			return result, fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDuration(ctx, *u.duration)
	case "integer":
		if u.integer == nil {
			return result, fmt.Errorf("field \"integer\" is required")
		}
		return v.VisitInteger(ctx, *u.integer)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(ctx, *u.derived)
	case "string":
		if u.string == nil {
			return result, fmt.Errorf("field \"string\" is required")
		}
		return v.VisitString(ctx, *u.string)
	case "stringSet":
		if u.stringSet == nil {
			return result, fmt.Errorf("field \"stringSet\" is required")
		}
		return v.VisitStringSet(ctx, *u.stringSet)
	case "timestamp":
		if u.timestamp == nil {
			return result, fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestamp(ctx, *u.timestamp)
	}
}

func (u *VariableValueWithT[T]) AcceptFuncs(doubleFunc func(float64) (T, error), computeNodeFunc func(ComputeNodeWithContext) (T, error), durationFunc func(api1.Duration) (T, error), integerFunc func(int) (T, error), channelFunc func(api.ChannelSeries) (T, error), derivedFunc func(DerivedSeries) (T, error), stringFunc func(string) (T, error), stringSetFunc func([]string) (T, error), timestampFunc func(api2.Timestamp) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "double":
		if u.double == nil {
			return result, fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "computeNode":
		if u.computeNode == nil {
			return result, fmt.Errorf("field \"computeNode\" is required")
		}
		return computeNodeFunc(*u.computeNode)
	case "duration":
		if u.duration == nil {
			return result, fmt.Errorf("field \"duration\" is required")
		}
		return durationFunc(*u.duration)
	case "integer":
		if u.integer == nil {
			return result, fmt.Errorf("field \"integer\" is required")
		}
		return integerFunc(*u.integer)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return result, fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "string":
		if u.string == nil {
			return result, fmt.Errorf("field \"string\" is required")
		}
		return stringFunc(*u.string)
	case "stringSet":
		if u.stringSet == nil {
			return result, fmt.Errorf("field \"stringSet\" is required")
		}
		return stringSetFunc(*u.stringSet)
	case "timestamp":
		if u.timestamp == nil {
			return result, fmt.Errorf("field \"timestamp\" is required")
		}
		return timestampFunc(*u.timestamp)
	}
}

func (u *VariableValueWithT[T]) DoubleNoopSuccess(float64) (T, error) {
	var result T
	return result, nil
}

func (u *VariableValueWithT[T]) ComputeNodeNoopSuccess(ComputeNodeWithContext) (T, error) {
	var result T
	return result, nil
}

func (u *VariableValueWithT[T]) DurationNoopSuccess(api1.Duration) (T, error) {
	var result T
	return result, nil
}

func (u *VariableValueWithT[T]) IntegerNoopSuccess(int) (T, error) {
	var result T
	return result, nil
}

func (u *VariableValueWithT[T]) ChannelNoopSuccess(api.ChannelSeries) (T, error) {
	var result T
	return result, nil
}

func (u *VariableValueWithT[T]) DerivedNoopSuccess(DerivedSeries) (T, error) {
	var result T
	return result, nil
}

func (u *VariableValueWithT[T]) StringNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *VariableValueWithT[T]) StringSetNoopSuccess([]string) (T, error) {
	var result T
	return result, nil
}

func (u *VariableValueWithT[T]) TimestampNoopSuccess(api2.Timestamp) (T, error) {
	var result T
	return result, nil
}

func (u *VariableValueWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VariableValueVisitorWithT[T any] interface {
	VisitDouble(ctx context.Context, v float64) (T, error)
	VisitComputeNode(ctx context.Context, v ComputeNodeWithContext) (T, error)
	VisitDuration(ctx context.Context, v api1.Duration) (T, error)
	VisitInteger(ctx context.Context, v int) (T, error)
	VisitChannel(ctx context.Context, v api.ChannelSeries) (T, error)
	VisitDerived(ctx context.Context, v DerivedSeries) (T, error)
	VisitString(ctx context.Context, v string) (T, error)
	VisitStringSet(ctx context.Context, v []string) (T, error)
	VisitTimestamp(ctx context.Context, v api2.Timestamp) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type WindowWithT[T any] Window

func (u *WindowWithT[T]) Accept(ctx context.Context, v WindowVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "duration":
		if u.duration == nil {
			return result, fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDuration(ctx, *u.duration)
	}
}

func (u *WindowWithT[T]) AcceptFuncs(durationFunc func(DurationConstant) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "duration":
		if u.duration == nil {
			return result, fmt.Errorf("field \"duration\" is required")
		}
		return durationFunc(*u.duration)
	}
}

func (u *WindowWithT[T]) DurationNoopSuccess(DurationConstant) (T, error) {
	var result T
	return result, nil
}

func (u *WindowWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type WindowVisitorWithT[T any] interface {
	VisitDuration(ctx context.Context, v DurationConstant) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
