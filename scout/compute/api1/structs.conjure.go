// Code generated by conjure-go. DO NOT EDIT.

package api1

import (
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/compute/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	api4 "github.com/nominal-io/nominal-api-go/scout/run/api"
	api3 "github.com/nominal-io/nominal-api-go/scout/units/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
)

// Replaces values in a series with the absolute timestamps.
type AbsoluteTimestampSeries struct {
	Input Series `json:"input"`
	// The time unit used to define the output values. Throws an error if nanosecond or finer.
	TimeUnit api.TimeUnit `conjure-docs:"The time unit used to define the output values. Throws an error if nanosecond or finer." json:"timeUnit"`
}

func (o AbsoluteTimestampSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AbsoluteTimestampSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Aggregates values with duplicate timestamps in the input series values into a single value using the specified aggregation function.
type AggregateEnumSeries struct {
	Input    EnumSeries                   `json:"input"`
	Function api1.EnumAggregationFunction `json:"function"`
}

func (o AggregateEnumSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AggregateEnumSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Aggregates values with duplicate timestamps in the input series values into a single value using the specified aggregation function.
type AggregateNumericSeries struct {
	Input    NumericSeries                   `json:"input"`
	Function api1.NumericAggregationFunction `json:"function"`
	/*
	   Tags to group by for the aggregation.
	   If left empty, the tags to group by will be equivalent to those in the input series.
	   If specified, the result will be grouped ONLY by the specified tags.
	   The tags specified here MUST be a (non-strict) subset of the input series's group by tags.
	*/
	GroupByTags []api1.StringConstant `conjure-docs:"Tags to group by for the aggregation.\nIf left empty, the tags to group by will be equivalent to those in the input series.\nIf specified, the result will be grouped ONLY by the specified tags.\nThe tags specified here MUST be a (non-strict) subset of the input series's group by tags." json:"groupByTags"`
	/*
	   This field's purpose is to distinguish between the two flavors of groupByTags being empty. It has no
	   effect when groupByTags is non-empty.
	   When true and groupByTags is empty, aggregate across all series in the input.
	   When false and groupByTags is empty, the result will be grouped by the same tags as the input series.
	*/
	AggregateByAllGroupings *bool `conjure-docs:"This field's purpose is to distinguish between the two flavors of groupByTags being empty. It has no\neffect when groupByTags is non-empty.\nWhen true and groupByTags is empty, aggregate across all series in the input.\nWhen false and groupByTags is empty, the result will be grouped by the same tags as the input series." json:"aggregateByAllGroupings,omitempty"`
}

func (o AggregateNumericSeries) MarshalJSON() ([]byte, error) {
	if o.GroupByTags == nil {
		o.GroupByTags = make([]api1.StringConstant, 0)
	}
	type _tmpAggregateNumericSeries AggregateNumericSeries
	return safejson.Marshal(_tmpAggregateNumericSeries(o))
}

func (o *AggregateNumericSeries) UnmarshalJSON(data []byte) error {
	type _tmpAggregateNumericSeries AggregateNumericSeries
	var rawAggregateNumericSeries _tmpAggregateNumericSeries
	if err := safejson.Unmarshal(data, &rawAggregateNumericSeries); err != nil {
		return err
	}
	if rawAggregateNumericSeries.GroupByTags == nil {
		rawAggregateNumericSeries.GroupByTags = make([]api1.StringConstant, 0)
	}
	*o = AggregateNumericSeries(rawAggregateNumericSeries)
	return nil
}

func (o AggregateNumericSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AggregateNumericSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Aggregates the input series under the ranges in the provided ranges series, and outputs a new series with one
point at the start of each range, where the value is the aggregation result. If a range has no points, no
point will be produced for it. If a range has no start, the point produced for it will be at the
start of the compute request range.
*/
type AggregateUnderRangesSeries struct {
	Input     NumericSeries                   `json:"input"`
	Ranges    RangeSeries                     `json:"ranges"`
	Operation api1.NumericAggregationFunction `json:"operation"`
}

func (o AggregateUnderRangesSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AggregateUnderRangesSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which the threshold condition is satisfied.
type ApproximateThresholdRanges struct {
	Input                          NumericSeries                     `json:"input"`
	Threshold                      api1.DoubleConstant               `json:"threshold"`
	Tolerance                      api1.DoubleConstant               `json:"tolerance"`
	Operator                       api1.ApproximateThresholdOperator `json:"operator"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration   `json:"persistenceWindowConfiguration,omitempty"`
}

func (o ApproximateThresholdRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ApproximateThresholdRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ArithmeticSeries struct {
	Inputs     map[api1.LocalVariableName]NumericSeries `json:"inputs"`
	Expression string                                   `json:"expression"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o ArithmeticSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make(map[api1.LocalVariableName]NumericSeries, 0)
	}
	type _tmpArithmeticSeries ArithmeticSeries
	return safejson.Marshal(_tmpArithmeticSeries(o))
}

func (o *ArithmeticSeries) UnmarshalJSON(data []byte) error {
	type _tmpArithmeticSeries ArithmeticSeries
	var rawArithmeticSeries _tmpArithmeticSeries
	if err := safejson.Unmarshal(data, &rawArithmeticSeries); err != nil {
		return err
	}
	if rawArithmeticSeries.Inputs == nil {
		rawArithmeticSeries.Inputs = make(map[api1.LocalVariableName]NumericSeries, 0)
	}
	*o = ArithmeticSeries(rawArithmeticSeries)
	return nil
}

func (o ArithmeticSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArithmeticSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchComputeUnitsRequest struct {
	Requests []ComputeUnitsRequest `json:"requests"`
}

func (o BatchComputeUnitsRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]ComputeUnitsRequest, 0)
	}
	type _tmpBatchComputeUnitsRequest BatchComputeUnitsRequest
	return safejson.Marshal(_tmpBatchComputeUnitsRequest(o))
}

func (o *BatchComputeUnitsRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchComputeUnitsRequest BatchComputeUnitsRequest
	var rawBatchComputeUnitsRequest _tmpBatchComputeUnitsRequest
	if err := safejson.Unmarshal(data, &rawBatchComputeUnitsRequest); err != nil {
		return err
	}
	if rawBatchComputeUnitsRequest.Requests == nil {
		rawBatchComputeUnitsRequest.Requests = make([]ComputeUnitsRequest, 0)
	}
	*o = BatchComputeUnitsRequest(rawBatchComputeUnitsRequest)
	return nil
}

func (o BatchComputeUnitsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchComputeUnitsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchComputeWithUnitsRequest struct {
	Requests []ComputeNodeRequest `json:"requests"`
}

func (o BatchComputeWithUnitsRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]ComputeNodeRequest, 0)
	}
	type _tmpBatchComputeWithUnitsRequest BatchComputeWithUnitsRequest
	return safejson.Marshal(_tmpBatchComputeWithUnitsRequest(o))
}

func (o *BatchComputeWithUnitsRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchComputeWithUnitsRequest BatchComputeWithUnitsRequest
	var rawBatchComputeWithUnitsRequest _tmpBatchComputeWithUnitsRequest
	if err := safejson.Unmarshal(data, &rawBatchComputeWithUnitsRequest); err != nil {
		return err
	}
	if rawBatchComputeWithUnitsRequest.Requests == nil {
		rawBatchComputeWithUnitsRequest.Requests = make([]ComputeNodeRequest, 0)
	}
	*o = BatchComputeWithUnitsRequest(rawBatchComputeWithUnitsRequest)
	return nil
}

func (o BatchComputeWithUnitsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchComputeWithUnitsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Applies a point-wise transformation to a pair of series.
type BinaryArithmeticSeries struct {
	Input1    NumericSeries                  `json:"input1"`
	Input2    NumericSeries                  `json:"input2"`
	Operation api1.BinaryArithmeticOperation `json:"operation"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o BinaryArithmeticSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BinaryArithmeticSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Casts input series values to long before applying the bitwise operation.
type BitOperationSeries struct {
	Input    NumericSeries             `json:"input"`
	Function api1.BitOperationFunction `json:"function"`
}

func (o BitOperationSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitOperationSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Returns the bode magnitude and phase of a system's frequency response.
type Bode struct {
	Input       NumericSeries     `json:"input"`
	Output      NumericSeries     `json:"output"`
	StftOptions *api1.StftOptions `json:"stftOptions,omitempty"`
	// The scaling to apply to the output magnitude. Defaults to MAGNITUDE_DB_20 if not specified.
	MagnitudeScaling *api1.MagnitudeScaling `conjure-docs:"The scaling to apply to the output magnitude. Defaults to MAGNITUDE_DB_20 if not specified." json:"magnitudeScaling,omitempty"`
	// The type of the output frequency. Defaults to LINEAR if not specified.
	OutputFrequencyType *api1.OutputFrequencyType `conjure-docs:"The type of the output frequency. Defaults to LINEAR if not specified." json:"outputFrequencyType,omitempty"`
	// Unwrap the phase of the output. Defaults to true if not specified.
	UnwrapPhase *bool `conjure-docs:"Unwrap the phase of the output. Defaults to true if not specified." json:"unwrapPhase,omitempty"`
}

func (o Bode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Bode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeNodeFromReferenceRequest struct {
	Node        ComputableNode `json:"node"`
	ReferenceTs api.Timestamp  `json:"referenceTs"`
	PageSize    int            `json:"pageSize"`
	Context     Context        `json:"context"`
}

func (o ComputeNodeFromReferenceRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeNodeFromReferenceRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeNodeRequest struct {
	Node    ComputableNode `json:"node"`
	Start   api.Timestamp  `json:"start"`
	End     api.Timestamp  `json:"end"`
	Context Context        `json:"context"`
}

func (o ComputeNodeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeNodeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeNodeWithContext struct {
	SeriesNode ComputeNode `json:"seriesNode"`
	Context    Context     `json:"context"`
}

func (o ComputeNodeWithContext) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeNodeWithContext) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ComputeUnitsRequest struct {
	Node    ComputableNode `json:"node"`
	Context Context        `json:"context"`
}

func (o ComputeUnitsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ComputeUnitsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Context struct {
	Variables map[api1.VariableName]VariableValue `json:"variables"`
	// Deprecated: This field is deprecated and will be removed in a future version.
	FunctionVariables *map[api1.FunctionReference]FunctionVariables `json:"functionVariables,omitempty"`
}

func (o Context) MarshalJSON() ([]byte, error) {
	if o.Variables == nil {
		o.Variables = make(map[api1.VariableName]VariableValue, 0)
	}
	type _tmpContext Context
	return safejson.Marshal(_tmpContext(o))
}

func (o *Context) UnmarshalJSON(data []byte) error {
	type _tmpContext Context
	var rawContext _tmpContext
	if err := safejson.Unmarshal(data, &rawContext); err != nil {
		return err
	}
	if rawContext.Variables == nil {
		rawContext.Variables = make(map[api1.VariableName]VariableValue, 0)
	}
	*o = Context(rawContext)
	return nil
}

func (o Context) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Context) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Returns the cross-spectral density magnitude and phase of the two input series.
type Cpsd struct {
	X           NumericSeries     `json:"x"`
	Y           NumericSeries     `json:"y"`
	StftOptions *api1.StftOptions `json:"stftOptions,omitempty"`
	// The scaling to apply to the output magnitude. Defaults to MAGNITUDE_DB_10 if not specified.
	MagnitudeScaling *api1.MagnitudeScaling `conjure-docs:"The scaling to apply to the output magnitude. Defaults to MAGNITUDE_DB_10 if not specified." json:"magnitudeScaling,omitempty"`
	/*
	   The type of the output frequency. Defaults to LINEAR if not specified. Changing the output frequency type
	   may also rescale the magnitude of the output in order to ensure the density of the output is consistent.
	*/
	OutputFrequencyType *api1.OutputFrequencyType `conjure-docs:"The type of the output frequency. Defaults to LINEAR if not specified. Changing the output frequency type\nmay also rescale the magnitude of the output in order to ensure the density of the output is consistent." json:"outputFrequencyType,omitempty"`
	// Unwrap the phase of the output. Defaults to true if not specified.
	UnwrapPhase *bool `conjure-docs:"Unwrap the phase of the output. Defaults to true if not specified." json:"unwrapPhase,omitempty"`
	// The unit of the output phase. Defaults to RADIANS if not specified.
	OutputPhaseUnit *api1.OutputPhaseUnit `conjure-docs:"The unit of the output phase. Defaults to RADIANS if not specified." json:"outputPhaseUnit,omitempty"`
}

func (o Cpsd) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Cpsd) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Calculates the running total of the series values.
type CumulativeSumSeries struct {
	Input          NumericSeries          `json:"input"`
	StartTimestamp api1.TimestampConstant `json:"startTimestamp"`
}

func (o CumulativeSumSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CumulativeSumSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CurveFit struct {
	CurveFitPlotType CurveFitPlotType     `json:"curveFitPlotType"`
	CurveFitDetails  api1.CurveFitDetails `json:"curveFitDetails"`
	CurveFitOptions  api1.CurveFitOptions `json:"curveFitOptions"`
}

func (o CurveFit) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CurveFit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Calculates the rate of change between subsequent points.
type DerivativeSeries struct {
	Input NumericSeries `json:"input"`
	// Time unit used to calculate the derivative. Defaults to seconds if not specified.
	TimeUnit *api.TimeUnit `conjure-docs:"Time unit used to calculate the derivative. Defaults to seconds if not specified." json:"timeUnit,omitempty"`
	// Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified.
	NegativeValuesConfiguration *api1.NegativeValueConfiguration `conjure-docs:"Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified." json:"negativeValuesConfiguration,omitempty"`
}

func (o DerivativeSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DerivativeSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Filters a list of ranges down to only those satisfying a threshold condition on the range's duration.
type DurationFilterRanges struct {
	Input             RangeSeries             `json:"input"`
	Threshold         DurationConstant        `json:"threshold"`
	Operator          api1.ThresholdOperator  `json:"operator"`
	UnboundedBehavior *api1.UnboundedBehavior `json:"unboundedBehavior,omitempty"`
}

func (o DurationFilterRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DurationFilterRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Counts the number of points along each timestamp in the input series.
type EnumCountDuplicateSeries struct {
	Inputs []EnumSeries `json:"inputs"`
}

func (o EnumCountDuplicateSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]EnumSeries, 0)
	}
	type _tmpEnumCountDuplicateSeries EnumCountDuplicateSeries
	return safejson.Marshal(_tmpEnumCountDuplicateSeries(o))
}

func (o *EnumCountDuplicateSeries) UnmarshalJSON(data []byte) error {
	type _tmpEnumCountDuplicateSeries EnumCountDuplicateSeries
	var rawEnumCountDuplicateSeries _tmpEnumCountDuplicateSeries
	if err := safejson.Unmarshal(data, &rawEnumCountDuplicateSeries); err != nil {
		return err
	}
	if rawEnumCountDuplicateSeries.Inputs == nil {
		rawEnumCountDuplicateSeries.Inputs = make([]EnumSeries, 0)
	}
	*o = EnumCountDuplicateSeries(rawEnumCountDuplicateSeries)
	return nil
}

func (o EnumCountDuplicateSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumCountDuplicateSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which the filter condition is satisfied.
type EnumFilterRanges struct {
	Input                          EnumSeries                      `json:"input"`
	Operator                       api1.EnumFilterOperator         `json:"operator"`
	Values                         api1.StringSetConstant          `json:"values"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration `json:"persistenceWindowConfiguration,omitempty"`
}

func (o EnumFilterRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumFilterRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs the values of the enum plot value within the ranges specified by a ranges node
type EnumFilterTransformationSeries struct {
	Input  EnumSeries  `json:"input"`
	Filter RangeSeries `json:"filter"`
}

func (o EnumFilterTransformationSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumFilterTransformationSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumHistogramNode struct {
	Inputs map[api1.VariableName]EnumSeries `json:"inputs"`
}

func (o EnumHistogramNode) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make(map[api1.VariableName]EnumSeries, 0)
	}
	type _tmpEnumHistogramNode EnumHistogramNode
	return safejson.Marshal(_tmpEnumHistogramNode(o))
}

func (o *EnumHistogramNode) UnmarshalJSON(data []byte) error {
	type _tmpEnumHistogramNode EnumHistogramNode
	var rawEnumHistogramNode _tmpEnumHistogramNode
	if err := safejson.Unmarshal(data, &rawEnumHistogramNode); err != nil {
		return err
	}
	if rawEnumHistogramNode.Inputs == nil {
		rawEnumHistogramNode.Inputs = make(map[api1.VariableName]EnumSeries, 0)
	}
	*o = EnumHistogramNode(rawEnumHistogramNode)
	return nil
}

func (o EnumHistogramNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumHistogramNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumResampleConfiguration struct {
	// Interval between resampled points
	Interval DurationConstant `conjure-docs:"Interval between resampled points" json:"interval"`
	// Interpolation strategy to use (defaults to forward fill).
	Interpolation *api1.EnumResampleInterpolationConfiguration `conjure-docs:"Interpolation strategy to use (defaults to forward fill)." json:"interpolation,omitempty"`
}

func (o EnumResampleConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumResampleConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Resamples the input series to a new resolution using interpolation.
Outputs data for timestamps corresponding to the defined frequency. Based on interpolation strategy,
determines range of timestamps to output data for and interpolates values where necessary.
*/
type EnumResampleSeries struct {
	Input EnumSeries `json:"input"`
	// The interval at which to resample the series and interpolation strategy
	ResampleConfiguration EnumResampleConfiguration `conjure-docs:"The interval at which to resample the series and interpolation strategy" json:"resampleConfiguration"`
}

func (o EnumResampleSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumResampleSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which provided enum series are all equal (or are not all equal).
type EnumSeriesEqualityRanges struct {
	Input                          []EnumSeries                    `json:"input"`
	EqualityOperator               api1.EqualityOperator           `json:"equalityOperator"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration `json:"persistenceWindowConfiguration,omitempty"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o EnumSeriesEqualityRanges) MarshalJSON() ([]byte, error) {
	if o.Input == nil {
		o.Input = make([]EnumSeries, 0)
	}
	type _tmpEnumSeriesEqualityRanges EnumSeriesEqualityRanges
	return safejson.Marshal(_tmpEnumSeriesEqualityRanges(o))
}

func (o *EnumSeriesEqualityRanges) UnmarshalJSON(data []byte) error {
	type _tmpEnumSeriesEqualityRanges EnumSeriesEqualityRanges
	var rawEnumSeriesEqualityRanges _tmpEnumSeriesEqualityRanges
	if err := safejson.Unmarshal(data, &rawEnumSeriesEqualityRanges); err != nil {
		return err
	}
	if rawEnumSeriesEqualityRanges.Input == nil {
		rawEnumSeriesEqualityRanges.Input = make([]EnumSeries, 0)
	}
	*o = EnumSeriesEqualityRanges(rawEnumSeriesEqualityRanges)
	return nil
}

func (o EnumSeriesEqualityRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumSeriesEqualityRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Filters the series to points within the specified time range.
type EnumTimeRangeFilterSeries struct {
	Input EnumSeries `json:"input"`
	// Represents the start time (inclusive) of the time range.
	StartTime *api1.TimestampConstant `conjure-docs:"Represents the start time (inclusive) of the time range." json:"startTime,omitempty"`
	// Represents the end time (inclusive) of the time range.
	EndTime *api1.TimestampConstant `conjure-docs:"Represents the end time (inclusive) of the time range." json:"endTime,omitempty"`
}

func (o EnumTimeRangeFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumTimeRangeFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumTimeShiftSeries struct {
	Input    EnumSeries       `json:"input"`
	Duration DurationConstant `json:"duration"`
}

func (o EnumTimeShiftSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumTimeShiftSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Maps an enumerated series to a numeric series by mapping each string value to a double.
type EnumToNumericSeries struct {
	Input EnumSeries `json:"input"`
	// The mapping from enum values to doubles.
	Mapping map[string]api1.DoubleConstant `conjure-docs:"The mapping from enum values to doubles." json:"mapping"`
	/*
	   The value to use for enum values not present in the mapping. If not specified, points with unmapped
	   enum values will be dropped.
	*/
	DefaultValue *api1.DoubleConstant `conjure-docs:"The value to use for enum values not present in the mapping. If not specified, points with unmapped\nenum values will be dropped." json:"defaultValue,omitempty"`
}

func (o EnumToNumericSeries) MarshalJSON() ([]byte, error) {
	if o.Mapping == nil {
		o.Mapping = make(map[string]api1.DoubleConstant, 0)
	}
	type _tmpEnumToNumericSeries EnumToNumericSeries
	return safejson.Marshal(_tmpEnumToNumericSeries(o))
}

func (o *EnumToNumericSeries) UnmarshalJSON(data []byte) error {
	type _tmpEnumToNumericSeries EnumToNumericSeries
	var rawEnumToNumericSeries _tmpEnumToNumericSeries
	if err := safejson.Unmarshal(data, &rawEnumToNumericSeries); err != nil {
		return err
	}
	if rawEnumToNumericSeries.Mapping == nil {
		rawEnumToNumericSeries.Mapping = make(map[string]api1.DoubleConstant, 0)
	}
	*o = EnumToNumericSeries(rawEnumToNumericSeries)
	return nil
}

func (o EnumToNumericSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumToNumericSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Combines multiple enum series together and outputs a single series. The strategy to merge input values
with the same timestamp together is specified in the operation field.
*/
type EnumUnionSeries struct {
	Input []EnumSeries `json:"input"`
	// The strategy to merge points with duplicate timestamps.
	Operation api1.EnumUnionOperation `conjure-docs:"The strategy to merge points with duplicate timestamps." json:"operation"`
}

func (o EnumUnionSeries) MarshalJSON() ([]byte, error) {
	if o.Input == nil {
		o.Input = make([]EnumSeries, 0)
	}
	type _tmpEnumUnionSeries EnumUnionSeries
	return safejson.Marshal(_tmpEnumUnionSeries(o))
}

func (o *EnumUnionSeries) UnmarshalJSON(data []byte) error {
	type _tmpEnumUnionSeries EnumUnionSeries
	var rawEnumUnionSeries _tmpEnumUnionSeries
	if err := safejson.Unmarshal(data, &rawEnumUnionSeries); err != nil {
		return err
	}
	if rawEnumUnionSeries.Input == nil {
		rawEnumUnionSeries.Input = make([]EnumSeries, 0)
	}
	*o = EnumUnionSeries(rawEnumUnionSeries)
	return nil
}

func (o EnumUnionSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumUnionSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Queries events and emits an enum series where each data point corresponds to an event and the enum value is
derived from a single event field (property, label, etc).
*/
type EventsEnumSeries struct {
	Query       api2.ComputeEventQuery     `json:"query"`
	ValueSource api1.EventsEnumValueSource `json:"valueSource"`
}

func (o EventsEnumSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EventsEnumSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Produces a range series with a range for each event matching the query.
Throws if there are more than 1,000 results.
*/
type EventsSearchRanges struct {
	Query api2.ComputeEventQuery `json:"query"`
}

func (o EventsSearchRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EventsSearchRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExtractEnumFromStructSeries struct {
	Input StructSeries `json:"input"`
	/*
	   Path to the field to extract as an enum series. Nested fields are separated by periods and field names cannot contain periods.
	   Will filter out invalid paths and paths to sub structures.
	*/
	FieldPath []api1.StringConstant `conjure-docs:"Path to the field to extract as an enum series. Nested fields are separated by periods and field names cannot contain periods.\nWill filter out invalid paths and paths to sub structures." json:"fieldPath"`
}

func (o ExtractEnumFromStructSeries) MarshalJSON() ([]byte, error) {
	if o.FieldPath == nil {
		o.FieldPath = make([]api1.StringConstant, 0)
	}
	type _tmpExtractEnumFromStructSeries ExtractEnumFromStructSeries
	return safejson.Marshal(_tmpExtractEnumFromStructSeries(o))
}

func (o *ExtractEnumFromStructSeries) UnmarshalJSON(data []byte) error {
	type _tmpExtractEnumFromStructSeries ExtractEnumFromStructSeries
	var rawExtractEnumFromStructSeries _tmpExtractEnumFromStructSeries
	if err := safejson.Unmarshal(data, &rawExtractEnumFromStructSeries); err != nil {
		return err
	}
	if rawExtractEnumFromStructSeries.FieldPath == nil {
		rawExtractEnumFromStructSeries.FieldPath = make([]api1.StringConstant, 0)
	}
	*o = ExtractEnumFromStructSeries(rawExtractEnumFromStructSeries)
	return nil
}

func (o ExtractEnumFromStructSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExtractEnumFromStructSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExtractNumericFromStructSeries struct {
	Input StructSeries `json:"input"`
	/*
	   Path to the field to extract as a numeric series. Nested fields are separated by periods and field names cannot contain periods.
	   Will filter out invalid paths and values that cannot be converted to the specified type.
	*/
	FieldPath []api1.StringConstant `conjure-docs:"Path to the field to extract as a numeric series. Nested fields are separated by periods and field names cannot contain periods.\nWill filter out invalid paths and values that cannot be converted to the specified type." json:"fieldPath"`
	// The type the numeric data will be cast to, defaults to FLOAT64
	DataType *api1.NumericDataType `conjure-docs:"The type the numeric data will be cast to, defaults to FLOAT64" json:"dataType,omitempty"`
}

func (o ExtractNumericFromStructSeries) MarshalJSON() ([]byte, error) {
	if o.FieldPath == nil {
		o.FieldPath = make([]api1.StringConstant, 0)
	}
	type _tmpExtractNumericFromStructSeries ExtractNumericFromStructSeries
	return safejson.Marshal(_tmpExtractNumericFromStructSeries(o))
}

func (o *ExtractNumericFromStructSeries) UnmarshalJSON(data []byte) error {
	type _tmpExtractNumericFromStructSeries ExtractNumericFromStructSeries
	var rawExtractNumericFromStructSeries _tmpExtractNumericFromStructSeries
	if err := safejson.Unmarshal(data, &rawExtractNumericFromStructSeries); err != nil {
		return err
	}
	if rawExtractNumericFromStructSeries.FieldPath == nil {
		rawExtractNumericFromStructSeries.FieldPath = make([]api1.StringConstant, 0)
	}
	*o = ExtractNumericFromStructSeries(rawExtractNumericFromStructSeries)
	return nil
}

func (o ExtractNumericFromStructSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExtractNumericFromStructSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExtractStructFromStructSeries struct {
	Input StructSeries `json:"input"`
	/*
	   Path to the field to extract as a struct. Nested fields are separated by periods and field names cannot contain periods.
	   Returns an empty struct if the path is invalid or does not resolve to a valid JSON struct.
	*/
	FieldPath []api1.StringConstant `conjure-docs:"Path to the field to extract as a struct. Nested fields are separated by periods and field names cannot contain periods.\nReturns an empty struct if the path is invalid or does not resolve to a valid JSON struct." json:"fieldPath"`
}

func (o ExtractStructFromStructSeries) MarshalJSON() ([]byte, error) {
	if o.FieldPath == nil {
		o.FieldPath = make([]api1.StringConstant, 0)
	}
	type _tmpExtractStructFromStructSeries ExtractStructFromStructSeries
	return safejson.Marshal(_tmpExtractStructFromStructSeries(o))
}

func (o *ExtractStructFromStructSeries) UnmarshalJSON(data []byte) error {
	type _tmpExtractStructFromStructSeries ExtractStructFromStructSeries
	var rawExtractStructFromStructSeries _tmpExtractStructFromStructSeries
	if err := safejson.Unmarshal(data, &rawExtractStructFromStructSeries); err != nil {
		return err
	}
	if rawExtractStructFromStructSeries.FieldPath == nil {
		rawExtractStructFromStructSeries.FieldPath = make([]api1.StringConstant, 0)
	}
	*o = ExtractStructFromStructSeries(rawExtractStructFromStructSeries)
	return nil
}

func (o ExtractStructFromStructSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExtractStructFromStructSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Returns the single sided amplitude spectrum of the input series.
type Fft struct {
	Input NumericSeries `json:"input"`
	// Window function applied to the input series. Defaults to RECT is not specified.
	Window *api1.FftWindow `conjure-docs:"Window function applied to the input series. Defaults to RECT is not specified." json:"window,omitempty"`
}

func (o Fft) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Fft) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Keeps points from the base series where the boolean expression evaluates to true. Only outputs timestamps
where all input series have an entry for that timestamp, or a value can be filled using the interpolation
configuration.
*/
type FilterByExpressionSeries struct {
	/*
	   The variable name for the series that will be returned by this filter. The expression can filter points
	   conditional on multiple series. The base defines which series' points will be returned after applying all the filters.
	*/
	Base api1.LocalVariableName `conjure-docs:"The variable name for the series that will be returned by this filter. The expression can filter points \nconditional on multiple series. The base defines which series' points will be returned after applying all the filters." json:"base"`
	// A map containing all the numeric series present in the expression.
	Inputs map[api1.LocalVariableName]NumericSeries `conjure-docs:"A map containing all the numeric series present in the expression." json:"inputs"`
	// An expression that evaluates to a boolean. For example - a > 5.
	Expression string `conjure-docs:"An expression that evaluates to a boolean. For example - a > 5." json:"expression"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o FilterByExpressionSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make(map[api1.LocalVariableName]NumericSeries, 0)
	}
	type _tmpFilterByExpressionSeries FilterByExpressionSeries
	return safejson.Marshal(_tmpFilterByExpressionSeries(o))
}

func (o *FilterByExpressionSeries) UnmarshalJSON(data []byte) error {
	type _tmpFilterByExpressionSeries FilterByExpressionSeries
	var rawFilterByExpressionSeries _tmpFilterByExpressionSeries
	if err := safejson.Unmarshal(data, &rawFilterByExpressionSeries); err != nil {
		return err
	}
	if rawFilterByExpressionSeries.Inputs == nil {
		rawFilterByExpressionSeries.Inputs = make(map[api1.LocalVariableName]NumericSeries, 0)
	}
	*o = FilterByExpressionSeries(rawFilterByExpressionSeries)
	return nil
}

func (o FilterByExpressionSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FilterByExpressionSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ForwardFillInterpolation struct {
	InterpolationRadius DurationConstant `json:"interpolationRadius"`
}

func (o ForwardFillInterpolation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ForwardFillInterpolation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A reference to a derived series resulting from applying a function to a set of arguments.
type FunctionDerivedSeries struct {
	ModuleName       api1.StringConstant         `json:"moduleName"`
	FunctionName     api1.StringConstant         `json:"functionName"`
	VersionReference api1.ModuleVersionReference `json:"versionReference"`
	/*
	   Map of function input names to their values. The function inputs must match the function's parameter
	   names and types. An input must be specified for each of the referenced function's parameters.
	*/
	FunctionArgs map[api1.FunctionParameterName]FunctionParameterValue `conjure-docs:"Map of function input names to their values. The function inputs must match the function's parameter\nnames and types. An input must be specified for each of the referenced function's parameters." json:"functionArgs"`
}

func (o FunctionDerivedSeries) MarshalJSON() ([]byte, error) {
	if o.FunctionArgs == nil {
		o.FunctionArgs = make(map[api1.FunctionParameterName]FunctionParameterValue, 0)
	}
	type _tmpFunctionDerivedSeries FunctionDerivedSeries
	return safejson.Marshal(_tmpFunctionDerivedSeries(o))
}

func (o *FunctionDerivedSeries) UnmarshalJSON(data []byte) error {
	type _tmpFunctionDerivedSeries FunctionDerivedSeries
	var rawFunctionDerivedSeries _tmpFunctionDerivedSeries
	if err := safejson.Unmarshal(data, &rawFunctionDerivedSeries); err != nil {
		return err
	}
	if rawFunctionDerivedSeries.FunctionArgs == nil {
		rawFunctionDerivedSeries.FunctionArgs = make(map[api1.FunctionParameterName]FunctionParameterValue, 0)
	}
	*o = FunctionDerivedSeries(rawFunctionDerivedSeries)
	return nil
}

func (o FunctionDerivedSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FunctionDerivedSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FunctionVariables struct {
	Variables            map[api1.VariableName]VariableValue          `json:"variables"`
	SubFunctionVariables map[api1.FunctionReference]FunctionVariables `json:"subFunctionVariables"`
}

func (o FunctionVariables) MarshalJSON() ([]byte, error) {
	if o.Variables == nil {
		o.Variables = make(map[api1.VariableName]VariableValue, 0)
	}
	if o.SubFunctionVariables == nil {
		o.SubFunctionVariables = make(map[api1.FunctionReference]FunctionVariables, 0)
	}
	type _tmpFunctionVariables FunctionVariables
	return safejson.Marshal(_tmpFunctionVariables(o))
}

func (o *FunctionVariables) UnmarshalJSON(data []byte) error {
	type _tmpFunctionVariables FunctionVariables
	var rawFunctionVariables _tmpFunctionVariables
	if err := safejson.Unmarshal(data, &rawFunctionVariables); err != nil {
		return err
	}
	if rawFunctionVariables.Variables == nil {
		rawFunctionVariables.Variables = make(map[api1.VariableName]VariableValue, 0)
	}
	if rawFunctionVariables.SubFunctionVariables == nil {
		rawFunctionVariables.SubFunctionVariables = make(map[api1.FunctionReference]FunctionVariables, 0)
	}
	*o = FunctionVariables(rawFunctionVariables)
	return nil
}

func (o FunctionVariables) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FunctionVariables) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Calculates the running sum of the area underneath a series using the trapezoidal rule.
type IntegralSeries struct {
	Input          NumericSeries          `json:"input"`
	StartTimestamp api1.TimestampConstant `json:"startTimestamp"`
	// Time unit used to calculate the integral. Defaults to seconds if not specified.
	TimeUnit *api.TimeUnit `conjure-docs:"Time unit used to calculate the integral. Defaults to seconds if not specified." json:"timeUnit,omitempty"`
}

func (o IntegralSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IntegralSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The FE should try to pass in inputs in the order in which they should be
evaluated for optimization's sake. Alternatively, we can let the user select
preconditions which they know to be cheaper to compute, which we will evaluate
first.
*/
type IntersectRanges struct {
	Inputs []RangeSeries `json:"inputs"`
}

func (o IntersectRanges) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]RangeSeries, 0)
	}
	type _tmpIntersectRanges IntersectRanges
	return safejson.Marshal(_tmpIntersectRanges(o))
}

func (o *IntersectRanges) UnmarshalJSON(data []byte) error {
	type _tmpIntersectRanges IntersectRanges
	var rawIntersectRanges _tmpIntersectRanges
	if err := safejson.Unmarshal(data, &rawIntersectRanges); err != nil {
		return err
	}
	if rawIntersectRanges.Inputs == nil {
		rawIntersectRanges.Inputs = make([]RangeSeries, 0)
	}
	*o = IntersectRanges(rawIntersectRanges)
	return nil
}

func (o IntersectRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IntersectRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs only values of the log plot that satisfy the filter.
type LogFilterSeries struct {
	Input    LogSeries              `json:"input"`
	Operator api1.LogFilterOperator `json:"operator"`
}

func (o LogFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogTimeShiftSeries struct {
	Input    LogSeries        `json:"input"`
	Duration DurationConstant `json:"duration"`
}

func (o LogTimeShiftSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogTimeShiftSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Combines multiple log series together and outputs a single series. The strategy to merge input values with the
same timestamp together is specified in the operation field.
*/
type LogUnionSeries struct {
	Input []LogSeries `json:"input"`
	// The strategy to merge points with duplicate timestamps.
	Operation api1.LogUnionOperation `conjure-docs:"The strategy to merge points with duplicate timestamps." json:"operation"`
}

func (o LogUnionSeries) MarshalJSON() ([]byte, error) {
	if o.Input == nil {
		o.Input = make([]LogSeries, 0)
	}
	type _tmpLogUnionSeries LogUnionSeries
	return safejson.Marshal(_tmpLogUnionSeries(o))
}

func (o *LogUnionSeries) UnmarshalJSON(data []byte) error {
	type _tmpLogUnionSeries LogUnionSeries
	var rawLogUnionSeries _tmpLogUnionSeries
	if err := safejson.Unmarshal(data, &rawLogUnionSeries); err != nil {
		return err
	}
	if rawLogUnionSeries.Input == nil {
		rawLogUnionSeries.Input = make([]LogSeries, 0)
	}
	*o = LogUnionSeries(rawLogUnionSeries)
	return nil
}

func (o LogUnionSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogUnionSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For every timestamp specified in the input series, outputs a value that is the maximum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
*/
type MaxSeries struct {
	Inputs []NumericSeries `json:"inputs"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o MaxSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]NumericSeries, 0)
	}
	type _tmpMaxSeries MaxSeries
	return safejson.Marshal(_tmpMaxSeries(o))
}

func (o *MaxSeries) UnmarshalJSON(data []byte) error {
	type _tmpMaxSeries MaxSeries
	var rawMaxSeries _tmpMaxSeries
	if err := safejson.Unmarshal(data, &rawMaxSeries); err != nil {
		return err
	}
	if rawMaxSeries.Inputs == nil {
		rawMaxSeries.Inputs = make([]NumericSeries, 0)
	}
	*o = MaxSeries(rawMaxSeries)
	return nil
}

func (o MaxSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MaxSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For every timestamp specified in the input series, outputs a value that is the mean for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
*/
type MeanSeries struct {
	Inputs []NumericSeries `json:"inputs"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o MeanSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]NumericSeries, 0)
	}
	type _tmpMeanSeries MeanSeries
	return safejson.Marshal(_tmpMeanSeries(o))
}

func (o *MeanSeries) UnmarshalJSON(data []byte) error {
	type _tmpMeanSeries MeanSeries
	var rawMeanSeries _tmpMeanSeries
	if err := safejson.Unmarshal(data, &rawMeanSeries); err != nil {
		return err
	}
	if rawMeanSeries.Inputs == nil {
		rawMeanSeries.Inputs = make([]NumericSeries, 0)
	}
	*o = MeanSeries(rawMeanSeries)
	return nil
}

func (o MeanSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MeanSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which the threshold condition is satisfied.
type MinMaxThresholdRanges struct {
	Input                          NumericSeries                   `json:"input"`
	LowerBound                     api1.DoubleConstant             `json:"lowerBound"`
	UpperBound                     api1.DoubleConstant             `json:"upperBound"`
	Operator                       api1.MinMaxThresholdOperator    `json:"operator"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration `json:"persistenceWindowConfiguration,omitempty"`
}

func (o MinMaxThresholdRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MinMaxThresholdRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For every timestamp specified in the input series, outputs a value that is the minimum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
*/
type MinSeries struct {
	Inputs []NumericSeries `json:"inputs"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o MinSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]NumericSeries, 0)
	}
	type _tmpMinSeries MinSeries
	return safejson.Marshal(_tmpMinSeries(o))
}

func (o *MinSeries) UnmarshalJSON(data []byte) error {
	type _tmpMinSeries MinSeries
	var rawMinSeries _tmpMinSeries
	if err := safejson.Unmarshal(data, &rawMinSeries); err != nil {
		return err
	}
	if rawMinSeries.Inputs == nil {
		rawMinSeries.Inputs = make([]NumericSeries, 0)
	}
	*o = MinSeries(rawMinSeries)
	return nil
}

func (o MinSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MinSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The not ranges node will invert the ranges, filling the negative space in time.
type NotRanges struct {
	Input RangeSeries `json:"input"`
}

func (o NotRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NotRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs the values of the numeric plot value that are approximately equal to the threshold value.
type NumericApproximateFilterSeries struct {
	Input     NumericSeries                     `json:"input"`
	Threshold api1.DoubleConstant               `json:"threshold"`
	Tolerance api1.DoubleConstant               `json:"tolerance"`
	Operator  api1.ApproximateThresholdOperator `json:"operator"`
}

func (o NumericApproximateFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericApproximateFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs the values of the numeric plot value within the ranges specified by a ranges node
type NumericFilterTransformationSeries struct {
	Input  NumericSeries `json:"input"`
	Filter RangeSeries   `json:"filter"`
}

func (o NumericFilterTransformationSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericFilterTransformationSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericHistogramNode struct {
	Inputs         map[api1.VariableName]NumericSeries  `json:"inputs"`
	BucketStrategy *api1.NumericHistogramBucketStrategy `json:"bucketStrategy,omitempty"`
}

func (o NumericHistogramNode) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make(map[api1.VariableName]NumericSeries, 0)
	}
	type _tmpNumericHistogramNode NumericHistogramNode
	return safejson.Marshal(_tmpNumericHistogramNode(o))
}

func (o *NumericHistogramNode) UnmarshalJSON(data []byte) error {
	type _tmpNumericHistogramNode NumericHistogramNode
	var rawNumericHistogramNode _tmpNumericHistogramNode
	if err := safejson.Unmarshal(data, &rawNumericHistogramNode); err != nil {
		return err
	}
	if rawNumericHistogramNode.Inputs == nil {
		rawNumericHistogramNode.Inputs = make(map[api1.VariableName]NumericSeries, 0)
	}
	*o = NumericHistogramNode(rawNumericHistogramNode)
	return nil
}

func (o NumericHistogramNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericHistogramNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericResampleConfiguration struct {
	// Interval between resampled points
	Interval DurationConstant `conjure-docs:"Interval between resampled points" json:"interval"`
	// Interpolation strategy to use (defaults to forward fill).
	Interpolation *api1.NumericResampleInterpolationConfiguration `conjure-docs:"Interpolation strategy to use (defaults to forward fill)." json:"interpolation,omitempty"`
}

func (o NumericResampleConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericResampleConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Resamples the input series to a new resolution using interpolation.
Outputs data for timestamps corresponding to the defined frequency. Based on interpolation strategy,
determines range of timestamps to output data for and interpolates values where necessary.
*/
type NumericResampleSeries struct {
	Input NumericSeries `json:"input"`
	// The interpolation strategy and interval at which to resample the series
	ResampleConfiguration NumericResampleConfiguration `conjure-docs:"The interpolation strategy and interval at which to resample the series" json:"resampleConfiguration"`
}

func (o NumericResampleSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericResampleSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs only the values of the numeric plot value that satisfy the threshold condition.
type NumericThresholdFilterSeries struct {
	Input     NumericSeries          `json:"input"`
	Threshold api1.DoubleConstant    `json:"threshold"`
	Operator  api1.ThresholdOperator `json:"operator"`
}

func (o NumericThresholdFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericThresholdFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Filters the series to points within the specified time range.
type NumericTimeRangeFilterSeries struct {
	Input NumericSeries `json:"input"`
	// Represents the start time (inclusive) of the time range.
	StartTime *api1.TimestampConstant `conjure-docs:"Represents the start time (inclusive) of the time range." json:"startTime,omitempty"`
	// Represents the end time (inclusive) of the time range.
	EndTime *api1.TimestampConstant `conjure-docs:"Represents the end time (inclusive) of the time range." json:"endTime,omitempty"`
}

func (o NumericTimeRangeFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericTimeRangeFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericTimeShiftSeries struct {
	Input    NumericSeries    `json:"input"`
	Duration DurationConstant `json:"duration"`
}

func (o NumericTimeShiftSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericTimeShiftSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Combines multiple numeric series together and outputs a single series. If the same timestamp is duplicated in
multiple input series, the output series will contain a single point with this timestamp. The strategy to
merge input values with the same timestamp together is specified in the operation field.
*/
type NumericUnionSeries struct {
	Input []NumericSeries `json:"input"`
	// The strategy to merge points with duplicate timestamps.
	Operation api1.NumericUnionOperation `conjure-docs:"The strategy to merge points with duplicate timestamps." json:"operation"`
}

func (o NumericUnionSeries) MarshalJSON() ([]byte, error) {
	if o.Input == nil {
		o.Input = make([]NumericSeries, 0)
	}
	type _tmpNumericUnionSeries NumericUnionSeries
	return safejson.Marshal(_tmpNumericUnionSeries(o))
}

func (o *NumericUnionSeries) UnmarshalJSON(data []byte) error {
	type _tmpNumericUnionSeries NumericUnionSeries
	var rawNumericUnionSeries _tmpNumericUnionSeries
	if err := safejson.Unmarshal(data, &rawNumericUnionSeries); err != nil {
		return err
	}
	if rawNumericUnionSeries.Input == nil {
		rawNumericUnionSeries.Input = make([]NumericSeries, 0)
	}
	*o = NumericUnionSeries(rawNumericUnionSeries)
	return nil
}

func (o NumericUnionSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericUnionSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Returns a complex-valued frequency response, H(f), of the input series to the output series.
type Nyquist struct {
	Input       NumericSeries     `json:"input"`
	Output      NumericSeries     `json:"output"`
	StftOptions *api1.StftOptions `json:"stftOptions,omitempty"`
}

func (o Nyquist) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Nyquist) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// For every timestamp specified in the input series, offset it by a constant factor.
type OffsetSeries struct {
	Input NumericSeries `json:"input"`
	// The constant to add to each point
	Scalar api1.DoubleConstant `conjure-docs:"The constant to add to each point" json:"scalar"`
}

func (o OffsetSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *OffsetSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Produces a list of ranges for each point that has a different value to the previous point.
A range will have identical start and end times.
*/
type OnChangeRanges struct {
	Input Series `json:"input"`
}

func (o OnChangeRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *OnChangeRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Expands ranges durations by adding temporal padding to the start, end, or both sides. Note that if the input
ranges contain a RangeValue, it will be dropped.
*/
type PaddedRanges struct {
	Input   RangeSeries      `json:"input"`
	Padding DurationConstant `json:"padding"`
	// Configuration for how to apply padding to the ranges. Defaults to PAD_START_AND_END if not specified.
	PaddingConfiguration *api1.RangePaddingConfiguration `conjure-docs:"Configuration for how to apply padding to the ranges. Defaults to PAD_START_AND_END if not specified." json:"paddingConfiguration,omitempty"`
}

func (o PaddedRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PaddedRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ParameterInput struct {
	Variables map[api1.VariableName]VariableValue `json:"variables"`
	/*
	   Overrides the start and end time of the compute request. If either the start or end are not present, we
	   default back to the start/end specified in the request.
	*/
	TimeRange *api1.Range `conjure-docs:"Overrides the start and end time of the compute request. If either the start or end are not present, we\ndefault back to the start/end specified in the request." json:"timeRange,omitempty"`
}

func (o ParameterInput) MarshalJSON() ([]byte, error) {
	if o.Variables == nil {
		o.Variables = make(map[api1.VariableName]VariableValue, 0)
	}
	type _tmpParameterInput ParameterInput
	return safejson.Marshal(_tmpParameterInput(o))
}

func (o *ParameterInput) UnmarshalJSON(data []byte) error {
	type _tmpParameterInput ParameterInput
	var rawParameterInput _tmpParameterInput
	if err := safejson.Unmarshal(data, &rawParameterInput); err != nil {
		return err
	}
	if rawParameterInput.Variables == nil {
		rawParameterInput.Variables = make(map[api1.VariableName]VariableValue, 0)
	}
	*o = ParameterInput(rawParameterInput)
	return nil
}

func (o ParameterInput) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ParameterInput) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ParameterizedComputeNodeRequest struct {
	Node    ComputableNode `json:"node"`
	Start   api.Timestamp  `json:"start"`
	End     api.Timestamp  `json:"end"`
	Context Context        `json:"context"`
	/*
	   Specifies how certain variables should be parameterized. If a variable name appears in both the context
	   and the parameterized context, it will be treated as parameterized.
	*/
	ParameterizedContext ParameterizedContext `conjure-docs:"Specifies how certain variables should be parameterized. If a variable name appears in both the context\nand the parameterized context, it will be treated as parameterized." json:"parameterizedContext"`
}

func (o ParameterizedComputeNodeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ParameterizedComputeNodeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ParameterizedContext struct {
	// Each parameter input provides a satisfying set of values for the parameterized compute node.
	ParameterInputs []ParameterInput `conjure-docs:"Each parameter input provides a satisfying set of values for the parameterized compute node." json:"parameterInputs"`
}

func (o ParameterizedContext) MarshalJSON() ([]byte, error) {
	if o.ParameterInputs == nil {
		o.ParameterInputs = make([]ParameterInput, 0)
	}
	type _tmpParameterizedContext ParameterizedContext
	return safejson.Marshal(_tmpParameterizedContext(o))
}

func (o *ParameterizedContext) UnmarshalJSON(data []byte) error {
	type _tmpParameterizedContext ParameterizedContext
	var rawParameterizedContext _tmpParameterizedContext
	if err := safejson.Unmarshal(data, &rawParameterizedContext); err != nil {
		return err
	}
	if rawParameterizedContext.ParameterInputs == nil {
		rawParameterizedContext.ParameterInputs = make([]ParameterInput, 0)
	}
	*o = ParameterizedContext(rawParameterizedContext)
	return nil
}

func (o ParameterizedContext) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ParameterizedContext) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Produces a list of ranges for each point that is greater than its neighbors.
Peaks at edges are discarded, and continuous, multivalue, flat peaks will return all values.
*/
type PeakRanges struct {
	Input NumericSeries `json:"input"`
	/*
	   True if returning peaks, else troughs.

	   Deprecated: No longer used, use returnType instead
	*/
	ReturnsPeaks *bool `conjure-docs:"True if returning peaks, else troughs." json:"returnsPeaks,omitempty"`
	// Optional for backcompatibility.
	ReturnType *api1.PeakType `conjure-docs:"Optional for backcompatibility." json:"returnType,omitempty"`
	/*
	   The minimum topographic prominence for an extrema to be returned.
	   Prominence is the minimum vertical distance needed to travel from an extrema to one of greater magnitude.
	*/
	MinimumProminence *api1.DoubleConstant `conjure-docs:"The minimum topographic prominence for an extrema to be returned.\nProminence is the minimum vertical distance needed to travel from an extrema to one of greater magnitude." json:"minimumProminence,omitempty"`
}

func (o PeakRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PeakRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Returns the spectral density estimate (i.e. PSD) of the input series.
type Periodogram struct {
	Input  NumericSeries          `json:"input"`
	Method api1.PeriodogramMethod `json:"method"`
}

func (o Periodogram) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Periodogram) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Configures how long a condition has to be true for to output a time range, and what to use as the
start of the output range. For a point to be included in the output time range, both the minPoints and
minDuration conditions must be satisfied.
*/
type PersistenceWindowConfiguration struct {
	/*
	   The minimum number of points for which this condition be must satisfied to include the time range in the
	   output. Must be non-negative. If not present, will default to 1.
	*/
	MinPoints *api1.IntegerConstant `conjure-docs:"The minimum number of points for which this condition be must satisfied to include the time range in the\noutput. Must be non-negative. If not present, will default to 1." json:"minPoints,omitempty"`
	/*
	   The minimum number of points for which this condition must be satisfied to include the time range in the
	   output. Must be non-negative. If not present, will default to 1 nanosecond.
	*/
	MinDuration *DurationConstant `conjure-docs:"The minimum number of points for which this condition must be satisfied to include the time range in the\noutput. Must be non-negative. If not present, will default to 1 nanosecond." json:"minDuration,omitempty"`
	// Which point to use as the start of the output range. Defaults to firstPointMatchingCondition if not specified.
	OutputRangeStart api1.OutputRangeStart `conjure-docs:"Which point to use as the start of the output range. Defaults to firstPointMatchingCondition if not specified." json:"outputRangeStart"`
}

func (o PersistenceWindowConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PersistenceWindowConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For every timestamp specified in the input series, outputs a value that is the product for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
*/
type ProductSeries struct {
	Inputs []NumericSeries `json:"inputs"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o ProductSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]NumericSeries, 0)
	}
	type _tmpProductSeries ProductSeries
	return safejson.Marshal(_tmpProductSeries(o))
}

func (o *ProductSeries) UnmarshalJSON(data []byte) error {
	type _tmpProductSeries ProductSeries
	var rawProductSeries _tmpProductSeries
	if err := safejson.Unmarshal(data, &rawProductSeries); err != nil {
		return err
	}
	if rawProductSeries.Inputs == nil {
		rawProductSeries.Inputs = make([]NumericSeries, 0)
	}
	*o = ProductSeries(rawProductSeries)
	return nil
}

func (o ProductSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ProductSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Psd struct {
	Input       NumericSeries     `json:"input"`
	StftOptions *api1.StftOptions `json:"stftOptions,omitempty"`
	// The scaling to apply to the output magnitude. Defaults to MAGNITUDE_DB_10 if not specified.
	MagnitudeScaling *api1.MagnitudeScaling `conjure-docs:"The scaling to apply to the output magnitude. Defaults to MAGNITUDE_DB_10 if not specified." json:"magnitudeScaling,omitempty"`
	/*
	   The type of the output frequency. Defaults to LINEAR if not specified. Changing the output frequency unit
	   may also rescale the magnitude of the output in order to ensure the density of the output is consistent.
	*/
	OutputFrequencyType *api1.OutputFrequencyType `conjure-docs:"The type of the output frequency. Defaults to LINEAR if not specified. Changing the output frequency unit\nmay also rescale the magnitude of the output in order to ensure the density of the output is consistent." json:"outputFrequencyType,omitempty"`
}

func (o Psd) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Psd) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Aggregates the values of a numeric series at each range specified by the input ranges.
type RangesNumericAggregation struct {
	Ranges    RangeSeries                    `json:"ranges"`
	Input     NumericSeries                  `json:"input"`
	Operation api1.RangeAggregationOperation `json:"operation"`
}

func (o RangesNumericAggregation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangesNumericAggregation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Computes the output property given input properties for the substance using REFPROP. Initial implementation
only expects two input properties.
*/
type RefpropSeries struct {
	// A map that maps a REFPROP property to its numeric series.
	Inputs map[api1.RefpropProperty]NumericSeries `conjure-docs:"A map that maps a REFPROP property to its numeric series." json:"inputs"`
	// The desired output property. This should not be one of the input properties.
	OutputProperty api1.RefpropProperty `conjure-docs:"The desired output property. This should not be one of the input properties." json:"outputProperty"`
	// The substance for REFPROP calculations.
	Substance                  api1.RefpropSubstance       `conjure-docs:"The substance for REFPROP calculations." json:"substance"`
	InterpolationConfiguration *InterpolationConfiguration `json:"interpolationConfiguration,omitempty"`
}

func (o RefpropSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make(map[api1.RefpropProperty]NumericSeries, 0)
	}
	type _tmpRefpropSeries RefpropSeries
	return safejson.Marshal(_tmpRefpropSeries(o))
}

func (o *RefpropSeries) UnmarshalJSON(data []byte) error {
	type _tmpRefpropSeries RefpropSeries
	var rawRefpropSeries _tmpRefpropSeries
	if err := safejson.Unmarshal(data, &rawRefpropSeries); err != nil {
		return err
	}
	if rawRefpropSeries.Inputs == nil {
		rawRefpropSeries.Inputs = make(map[api1.RefpropProperty]NumericSeries, 0)
	}
	*o = RefpropSeries(rawRefpropSeries)
	return nil
}

func (o RefpropSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RefpropSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RollingOperationSeries struct {
	Input    NumericSeries        `json:"input"`
	Window   Window               `json:"window"`
	Operator api1.RollingOperator `json:"operator"`
}

func (o RollingOperationSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RollingOperationSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// For every timestamp specified in the input series, multiply it by a constant factor.
type ScaleSeries struct {
	Input NumericSeries `json:"input"`
	// The constant to multiply each point by
	Scalar api1.DoubleConstant `conjure-docs:"The constant to multiply each point by" json:"scalar"`
	// The units of the scalar to multiply by. If empty, the scalar is considered unit-less.
	ScalarUnit *api3.UnitSymbol `conjure-docs:"The units of the scalar to multiply by. If empty, the scalar is considered unit-less." json:"scalarUnit,omitempty"`
}

func (o ScaleSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ScaleSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A scatter plot comprised of the values from one input series on the x-axis
and values from another input series on the y-axis, for all points within a requested time range.
*/
type Scatter struct {
	X NumericSeries `json:"x"`
	Y NumericSeries `json:"y"`
}

func (o Scatter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Scatter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Scatter3d struct {
	X            NumericSeries        `json:"x"`
	Y            NumericSeries        `json:"y"`
	Z            NumericSeries        `json:"z"`
	DriverSeries *api1.DriverSeries3d `json:"driverSeries,omitempty"`
}

func (o Scatter3d) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Scatter3d) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Fits a curve to the scatter between two series.
type ScatterCurveFit struct {
	// The x and y series to fit to.
	Scatter Scatter                `conjure-docs:"The x and y series to fit to." json:"scatter"`
	Options api1.ScatterFitOptions `json:"options"`
}

func (o ScatterCurveFit) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ScatterCurveFit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For each timestamp, selects a single enum value from the 1D enum array at the specified index. If the index
is out of bounds for an array at a given timestamp, it is omitted.
*/
type SelectIndexFrom1dEnumArraySeries struct {
	Input Enum1dArraySeries    `json:"input"`
	Index api1.IntegerConstant `json:"index"`
}

func (o SelectIndexFrom1dEnumArraySeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SelectIndexFrom1dEnumArraySeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For each timestamp, selects a single numeric value from the 1D numeric array at the specified index. If the
index is out of bounds for an array at a given timestamp, it is omitted.
*/
type SelectIndexFrom1dNumericArraySeries struct {
	Input Numeric1dArraySeries `json:"input"`
	Index api1.IntegerConstant `json:"index"`
}

func (o SelectIndexFrom1dNumericArraySeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SelectIndexFrom1dNumericArraySeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Select the most recent N points from the input series by timestamp.
type SelectNewestPointsSeries struct {
	Input     NumericSeries        `json:"input"`
	NumPoints api1.IntegerConstant `json:"numPoints"`
}

func (o SelectNewestPointsSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SelectNewestPointsSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of zero-duration ranges at the first point where two series cross over one another
type SeriesCrossoverRanges struct {
	InputA NumericSeries `json:"inputA"`
	InputB NumericSeries `json:"inputB"`
}

func (o SeriesCrossoverRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SeriesCrossoverRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which provided series are all equal (or are not all equal).
type SeriesEqualityRanges struct {
	Input                          []NumericSeries                 `json:"input"`
	EqualityOperator               api1.EqualityOperator           `json:"equalityOperator"`
	Tolerance                      *api1.DoubleConstant            `json:"tolerance,omitempty"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration `json:"persistenceWindowConfiguration,omitempty"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o SeriesEqualityRanges) MarshalJSON() ([]byte, error) {
	if o.Input == nil {
		o.Input = make([]NumericSeries, 0)
	}
	type _tmpSeriesEqualityRanges SeriesEqualityRanges
	return safejson.Marshal(_tmpSeriesEqualityRanges(o))
}

func (o *SeriesEqualityRanges) UnmarshalJSON(data []byte) error {
	type _tmpSeriesEqualityRanges SeriesEqualityRanges
	var rawSeriesEqualityRanges _tmpSeriesEqualityRanges
	if err := safejson.Unmarshal(data, &rawSeriesEqualityRanges); err != nil {
		return err
	}
	if rawSeriesEqualityRanges.Input == nil {
		rawSeriesEqualityRanges.Input = make([]NumericSeries, 0)
	}
	*o = SeriesEqualityRanges(rawSeriesEqualityRanges)
	return nil
}

func (o SeriesEqualityRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SeriesEqualityRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Deprecated and should not be created by clients. Use ChannelSeries instead.
type SeriesSpec struct {
	Rid api.LogicalSeriesRid `json:"rid"`
	// The offset of this series relative to the time scale in which the computation is performed.
	Offset        *api4.Duration `conjure-docs:"The offset of this series relative to the time scale in which the computation is performed." json:"offset,omitempty"`
	TagsToGroupBy []string       `json:"tagsToGroupBy"`
}

func (o SeriesSpec) MarshalJSON() ([]byte, error) {
	if o.TagsToGroupBy == nil {
		o.TagsToGroupBy = make([]string, 0)
	}
	type _tmpSeriesSpec SeriesSpec
	return safejson.Marshal(_tmpSeriesSpec(o))
}

func (o *SeriesSpec) UnmarshalJSON(data []byte) error {
	type _tmpSeriesSpec SeriesSpec
	var rawSeriesSpec _tmpSeriesSpec
	if err := safejson.Unmarshal(data, &rawSeriesSpec); err != nil {
		return err
	}
	if rawSeriesSpec.TagsToGroupBy == nil {
		rawSeriesSpec.TagsToGroupBy = make([]string, 0)
	}
	*o = SeriesSpec(rawSeriesSpec)
	return nil
}

func (o SeriesSpec) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SeriesSpec) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Applies IIR-based signal filtering to input series. Includes low-pass, high-pass, band-pass, and band-stop
filters. Currently supports variable-order bidirectional Butterworth filters, with fixed-size padding based
on SciPy output.
*/
type SignalFilterSeries struct {
	Input NumericSeries `json:"input"`
	// Filter type and cutoff frequencies.
	SignalFilterConfiguration api1.SignalFilterConfiguration `conjure-docs:"Filter type and cutoff frequencies." json:"signalFilterConfiguration"`
	// Order of filter. Must be a positive integer, and is effectively doubled for bidirectional filters.
	Order api1.IntegerConstant `conjure-docs:"Order of filter. Must be a positive integer, and is effectively doubled for bidirectional filters." json:"order"`
	// The sampling frequency of the input series. Used to calculate normalized frequency for cutoff frequencies.
	SamplingFrequency *api1.DoubleConstant `conjure-docs:"The sampling frequency of the input series. Used to calculate normalized frequency for cutoff frequencies." json:"samplingFrequency,omitempty"`
}

func (o SignalFilterSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SignalFilterSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Outputs a set of ranges where the input series is stable. For each point, the min and max are calculated over
the specified lookback window, including the current point. A point is considered stable if its value does
not deviate from the calculated min and the max by more than the threshold and the total number of points
within the window is at least the specified amount. The threshold can be either fixed values or percentages
of the value. The lookback window must be strictly positive. The minimum points threshold defaults to 2.
*/
type StabilityDetectionRanges struct {
	Input               NumericSeries                `json:"input"`
	WindowConfiguration StabilityWindowConfiguration `json:"windowConfiguration"`
	Threshold           api1.Threshold               `json:"threshold"`
}

func (o StabilityDetectionRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StabilityDetectionRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type StabilityWindowConfiguration struct {
	/*
	   The minimum number of points within the window to create a stable range. Must be non-negative. If not
	   present, will default to 2.
	*/
	MinPoints *api1.IntegerConstant `conjure-docs:"The minimum number of points within the window to create a stable range. Must be non-negative. If not \npresent, will default to 2." json:"minPoints,omitempty"`
	Duration  DurationConstant      `json:"duration"`
}

func (o StabilityWindowConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StabilityWindowConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Produces a list of ranges for which data does not exist for the specified duration or longer. Increases
window size by the specified staleness threshold on both ends to capture edge cases of data not currently
in view.
*/
type StaleRanges struct {
	Input     Series           `json:"input"`
	Threshold DurationConstant `json:"threshold"`
	// The start timestamp of the range. If not specified, staleness will automatically use view range start.
	StartTimestamp *api1.TimestampConstant `conjure-docs:"The start timestamp of the range. If not specified, staleness will automatically use view range start." json:"startTimestamp,omitempty"`
	// Deprecated: No longer used and will be removed
	EndTimestamp *api1.TimestampConstant `json:"endTimestamp,omitempty"`
}

func (o StaleRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StaleRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For every timestamp specified in the input series, outputs a value that is the sum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
*/
type SumSeries struct {
	Inputs []NumericSeries `json:"inputs"`
	// Defaults to forward fill interpolation with a 1s interpolation radius
	InterpolationConfiguration *InterpolationConfiguration `conjure-docs:"Defaults to forward fill interpolation with a 1s interpolation radius" json:"interpolationConfiguration,omitempty"`
}

func (o SumSeries) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]NumericSeries, 0)
	}
	type _tmpSumSeries SumSeries
	return safejson.Marshal(_tmpSumSeries(o))
}

func (o *SumSeries) UnmarshalJSON(data []byte) error {
	type _tmpSumSeries SumSeries
	var rawSumSeries _tmpSumSeries
	if err := safejson.Unmarshal(data, &rawSumSeries); err != nil {
		return err
	}
	if rawSumSeries.Inputs == nil {
		rawSumSeries.Inputs = make([]NumericSeries, 0)
	}
	*o = SumSeries(rawSumSeries)
	return nil
}

func (o SumSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SumSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SummarizeCartesian struct {
	Input  Cartesian             `json:"input"`
	Bounds *api1.CartesianBounds `json:"bounds,omitempty"`
	// The summarization strategy to use when there are more than `maxPoints`. Defaults to spatial.
	SummarizationStrategy *api1.ScatterSummarizationStrategy `conjure-docs:"The summarization strategy to use when there are more than \"maxPoints\". Defaults to spatial." json:"summarizationStrategy,omitempty"`
	/*
	   The maximum number of points to return in the response. If more points are found, a BucketedCartesianPlot
	   will be returned. Maximum is 10,000. Defaults to 2,000 if not specified.
	*/
	MaxPoints *int `conjure-docs:"The maximum number of points to return in the response. If more points are found, a BucketedCartesianPlot\nwill be returned. Maximum is 10,000. Defaults to 2,000 if not specified." json:"maxPoints,omitempty"`
}

func (o SummarizeCartesian) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SummarizeCartesian) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SummarizeCartesian3d struct {
	Input  Cartesian3d             `json:"input"`
	Bounds *api1.Cartesian3dBounds `json:"bounds,omitempty"`
	/*
	   The maximum number of points to return in the response.
	   If more points are found, a BucketedCartesian3dPlot will be returned.
	   Maximum is 10,000. Defaults to 2,000 if not specified.
	*/
	MaxPoints *int `conjure-docs:"The maximum number of points to return in the response.\nIf more points are found, a BucketedCartesian3dPlot will be returned.\nMaximum is 10,000. Defaults to 2,000 if not specified." json:"maxPoints,omitempty"`
	// The strategy to use when summarizing the series. Only spatial decimation is supported.
	SummarizationStrategy *api1.ScatterSummarizationStrategy `conjure-docs:"The strategy to use when summarizing the series. Only spatial decimation is supported." json:"summarizationStrategy,omitempty"`
}

func (o SummarizeCartesian3d) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SummarizeCartesian3d) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SummarizeRanges struct {
	Input RangeSeries `json:"input"`
	/*
	   The maximum number of ranges to return in the response. If more ranges are found, a RangesSummary
	   will be returned. Defaults to 2000 if not specified.
	*/
	MaxRanges *int `conjure-docs:"The maximum number of ranges to return in the response. If more ranges are found, a RangesSummary\nwill be returned. Defaults to 2000 if not specified." json:"maxRanges,omitempty"`
}

func (o SummarizeRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SummarizeRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Summarizes the output of a series node. The output can be a numeric, enum, log, or cartesian series.
Summarization strategy should be specified.
*/
type SummarizeSeries struct {
	Input Series `json:"input"`
	// The output format of the response. Defaults to LEGACY.
	OutputFormat *api1.OutputFormat `conjure-docs:"The output format of the response. Defaults to LEGACY." json:"outputFormat,omitempty"`
	// The fields to output from the summarization. Applies only to Arrow format numeric series.
	NumericOutputFields *[]api1.NumericOutputField `conjure-docs:"The fields to output from the summarization. Applies only to Arrow format numeric series." json:"numericOutputFields,omitempty"`
	/*
	   Resolution of the output series specifying time interval between decimated points.
	   Picoseconds for picosecond-granularity dataset, nanoseconds otherwise.

	   Deprecated: Use summarizationStrategy instead.
	*/
	Resolution *safelong.SafeLong `conjure-docs:"Resolution of the output series specifying time interval between decimated points.\nPicoseconds for picosecond-granularity dataset, nanoseconds otherwise." json:"resolution,omitempty"`
	/*
	   Number of points to generate in the output series.

	   Deprecated: Use summarizationStrategy instead.
	*/
	Buckets *int `conjure-docs:"Number of points to generate in the output series." json:"buckets,omitempty"`
	// The strategy to use when summarizing the series.
	SummarizationStrategy *api1.SummarizationStrategy `conjure-docs:"The strategy to use when summarizing the series." json:"summarizationStrategy,omitempty"`
}

func (o SummarizeSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SummarizeSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Produces a list of ranges for which the threshold condition is satisfied.
type ThresholdingRanges struct {
	Input                          NumericSeries                   `json:"input"`
	Threshold                      api1.DoubleConstant             `json:"threshold"`
	Operator                       api1.ThresholdOperator          `json:"operator"`
	PersistenceWindowConfiguration *PersistenceWindowConfiguration `json:"persistenceWindowConfiguration,omitempty"`
}

func (o ThresholdingRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ThresholdingRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs a new series where each value is the difference between the time of the current and previous points.
type TimeDifferenceSeries struct {
	Input Series `json:"input"`
	// The time unit used to define the output values. Defaults to seconds if not specified.
	TimeUnit *api.TimeUnit `conjure-docs:"The time unit used to define the output values. Defaults to seconds if not specified." json:"timeUnit,omitempty"`
}

func (o TimeDifferenceSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeDifferenceSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Fits a curve to a series vs its timestamps.
type TimeSeriesCurveFit struct {
	/*
	   The series to fit. Timestamps will be used as x values and data as y values. The leftmost (earliest)
	   timestamp will be used as the value of 0, and all other timestamps will be relative to that.
	*/
	Series  NumericSeries             `conjure-docs:"The series to fit. Timestamps will be used as x values and data as y values. The leftmost (earliest)\ntimestamp will be used as the value of 0, and all other timestamps will be relative to that." json:"series"`
	Options api1.TimeSeriesFitOptions `json:"options"`
}

func (o TimeSeriesCurveFit) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeSeriesCurveFit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Applies a point-wise transformation to a series. The transformation function is applied to every
individual data point.
*/
type UnaryArithmeticSeries struct {
	Input     NumericSeries                 `json:"input"`
	Operation api1.UnaryArithmeticOperation `json:"operation"`
}

func (o UnaryArithmeticSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnaryArithmeticSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UnionRanges struct {
	Inputs []RangeSeries `json:"inputs"`
}

func (o UnionRanges) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]RangeSeries, 0)
	}
	type _tmpUnionRanges UnionRanges
	return safejson.Marshal(_tmpUnionRanges(o))
}

func (o *UnionRanges) UnmarshalJSON(data []byte) error {
	type _tmpUnionRanges UnionRanges
	var rawUnionRanges _tmpUnionRanges
	if err := safejson.Unmarshal(data, &rawUnionRanges); err != nil {
		return err
	}
	if rawUnionRanges.Inputs == nil {
		rawUnionRanges.Inputs = make([]RangeSeries, 0)
	}
	*o = UnionRanges(rawUnionRanges)
	return nil
}

func (o UnionRanges) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnionRanges) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Convert the given series to a different unit.
type UnitConversionSeries struct {
	Input      NumericSeries   `json:"input"`
	OutputUnit api3.UnitSymbol `json:"outputUnit"`
}

func (o UnitConversionSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnitConversionSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Outputs a new series where each value is the difference between the values of the current and previous point.
type ValueDifferenceSeries struct {
	Input NumericSeries `json:"input"`
	// Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified.
	NegativeValuesConfiguration *api1.NegativeValueConfiguration `conjure-docs:"Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified." json:"negativeValuesConfiguration,omitempty"`
}

func (o ValueDifferenceSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueDifferenceSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Maps a continuous numeric series to a discrete enum series using the specified value ranges.
type ValueMapSeries struct {
	// The input series to map to an enumerated series
	Input NumericSeries `conjure-docs:"The input series to map to an enumerated series" json:"input"`
	/*
	   The output of the first capturing range will be used. Ranges are start inclusive, end exclusive, must not overlap,
	   and increasing from lowest to highest. Ranges can be open ended to the edge of the next or prior range.
	   The first range can be open ended to negative infinity, and the last range can be open ended to positive infinity.
	*/
	Mapping []api1.RangeMap `conjure-docs:"The output of the first capturing range will be used. Ranges are start inclusive, end exclusive, must not overlap,\nand increasing from lowest to highest. Ranges can be open ended to the edge of the next or prior range.\nThe first range can be open ended to negative infinity, and the last range can be open ended to positive infinity." json:"mapping"`
	// The default value if not captured by any range. If not specified, points will be filtered.
	Default *api1.StringConstant `conjure-docs:"The default value if not captured by any range. If not specified, points will be filtered." json:"default,omitempty"`
}

func (o ValueMapSeries) MarshalJSON() ([]byte, error) {
	if o.Mapping == nil {
		o.Mapping = make([]api1.RangeMap, 0)
	}
	type _tmpValueMapSeries ValueMapSeries
	return safejson.Marshal(_tmpValueMapSeries(o))
}

func (o *ValueMapSeries) UnmarshalJSON(data []byte) error {
	type _tmpValueMapSeries ValueMapSeries
	var rawValueMapSeries _tmpValueMapSeries
	if err := safejson.Unmarshal(data, &rawValueMapSeries); err != nil {
		return err
	}
	if rawValueMapSeries.Mapping == nil {
		rawValueMapSeries.Mapping = make([]api1.RangeMap, 0)
	}
	*o = ValueMapSeries(rawValueMapSeries)
	return nil
}

func (o ValueMapSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueMapSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
