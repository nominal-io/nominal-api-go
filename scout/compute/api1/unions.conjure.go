// Code generated by conjure-go. DO NOT EDIT.

package api1

import (
	"context"
	"fmt"

	api2 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/scout/compute/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/run/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type ArraySeries struct {
	typ       string
	numeric1d *Numeric1dArraySeries
	enum1d    *Enum1dArraySeries
}

type arraySeriesDeserializer struct {
	Type      string                `json:"type"`
	Numeric1d *Numeric1dArraySeries `json:"numeric1d"`
	Enum1d    *Enum1dArraySeries    `json:"enum1d"`
}

func (u *arraySeriesDeserializer) toStruct() ArraySeries {
	return ArraySeries{typ: u.Type, numeric1d: u.Numeric1d, enum1d: u.Enum1d}
}

func (u *ArraySeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return nil, fmt.Errorf("field \"numeric1d\" is required")
		}
		return struct {
			Type      string               `json:"type"`
			Numeric1d Numeric1dArraySeries `json:"numeric1d"`
		}{Type: "numeric1d", Numeric1d: *u.numeric1d}, nil
	case "enum1d":
		if u.enum1d == nil {
			return nil, fmt.Errorf("field \"enum1d\" is required")
		}
		return struct {
			Type   string            `json:"type"`
			Enum1d Enum1dArraySeries `json:"enum1d"`
		}{Type: "enum1d", Enum1d: *u.enum1d}, nil
	}
}

func (u ArraySeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ArraySeries) UnmarshalJSON(data []byte) error {
	var deser arraySeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
	}
	return nil
}

func (u ArraySeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ArraySeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ArraySeries) AcceptFuncs(numeric1dFunc func(Numeric1dArraySeries) error, enum1dFunc func(Enum1dArraySeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
		return numeric1dFunc(*u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
		return enum1dFunc(*u.enum1d)
	}
}

func (u *ArraySeries) Numeric1dNoopSuccess(Numeric1dArraySeries) error {
	return nil
}

func (u *ArraySeries) Enum1dNoopSuccess(Enum1dArraySeries) error {
	return nil
}

func (u *ArraySeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ArraySeries) Accept(v ArraySeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
		return v.VisitNumeric1d(*u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
		return v.VisitEnum1d(*u.enum1d)
	}
}

type ArraySeriesVisitor interface {
	VisitNumeric1d(v Numeric1dArraySeries) error
	VisitEnum1d(v Enum1dArraySeries) error
	VisitUnknown(typeName string) error
}

func (u *ArraySeries) AcceptWithContext(ctx context.Context, v ArraySeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric1d":
		if u.numeric1d == nil {
			return fmt.Errorf("field \"numeric1d\" is required")
		}
		return v.VisitNumeric1dWithContext(ctx, *u.numeric1d)
	case "enum1d":
		if u.enum1d == nil {
			return fmt.Errorf("field \"enum1d\" is required")
		}
		return v.VisitEnum1dWithContext(ctx, *u.enum1d)
	}
}

type ArraySeriesVisitorWithContext interface {
	VisitNumeric1dWithContext(ctx context.Context, v Numeric1dArraySeries) error
	VisitEnum1dWithContext(ctx context.Context, v Enum1dArraySeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewArraySeriesFromNumeric1d(v Numeric1dArraySeries) ArraySeries {
	return ArraySeries{typ: "numeric1d", numeric1d: &v}
}

func NewArraySeriesFromEnum1d(v Enum1dArraySeries) ArraySeries {
	return ArraySeries{typ: "enum1d", enum1d: &v}
}

type Cartesian struct {
	typ     string
	scatter *Scatter
}

type cartesianDeserializer struct {
	Type    string   `json:"type"`
	Scatter *Scatter `json:"scatter"`
}

func (u *cartesianDeserializer) toStruct() Cartesian {
	return Cartesian{typ: u.Type, scatter: u.Scatter}
}

func (u *Cartesian) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "scatter":
		if u.scatter == nil {
			return nil, fmt.Errorf("field \"scatter\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Scatter Scatter `json:"scatter"`
		}{Type: "scatter", Scatter: *u.scatter}, nil
	}
}

func (u Cartesian) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Cartesian) UnmarshalJSON(data []byte) error {
	var deser cartesianDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
	}
	return nil
}

func (u Cartesian) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Cartesian) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Cartesian) AcceptFuncs(scatterFunc func(Scatter) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *Cartesian) ScatterNoopSuccess(Scatter) error {
	return nil
}

func (u *Cartesian) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Cartesian) Accept(v CartesianVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(*u.scatter)
	}
}

type CartesianVisitor interface {
	VisitScatter(v Scatter) error
	VisitUnknown(typeName string) error
}

func (u *Cartesian) AcceptWithContext(ctx context.Context, v CartesianVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatterWithContext(ctx, *u.scatter)
	}
}

type CartesianVisitorWithContext interface {
	VisitScatterWithContext(ctx context.Context, v Scatter) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCartesianFromScatter(v Scatter) Cartesian {
	return Cartesian{typ: "scatter", scatter: &v}
}

type Cartesian3d struct {
	typ       string
	scatter3d *Scatter3d
}

type cartesian3dDeserializer struct {
	Type      string     `json:"type"`
	Scatter3d *Scatter3d `json:"scatter3d"`
}

func (u *cartesian3dDeserializer) toStruct() Cartesian3d {
	return Cartesian3d{typ: u.Type, scatter3d: u.Scatter3d}
}

func (u *Cartesian3d) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return nil, fmt.Errorf("field \"scatter3d\" is required")
		}
		return struct {
			Type      string    `json:"type"`
			Scatter3d Scatter3d `json:"scatter3d"`
		}{Type: "scatter3d", Scatter3d: *u.scatter3d}, nil
	}
}

func (u Cartesian3d) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Cartesian3d) UnmarshalJSON(data []byte) error {
	var deser cartesian3dDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
	}
	return nil
}

func (u Cartesian3d) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Cartesian3d) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Cartesian3d) AcceptFuncs(scatter3dFunc func(Scatter3d) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return scatter3dFunc(*u.scatter3d)
	}
}

func (u *Cartesian3d) Scatter3dNoopSuccess(Scatter3d) error {
	return nil
}

func (u *Cartesian3d) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Cartesian3d) Accept(v Cartesian3dVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3d(*u.scatter3d)
	}
}

type Cartesian3dVisitor interface {
	VisitScatter3d(v Scatter3d) error
	VisitUnknown(typeName string) error
}

func (u *Cartesian3d) AcceptWithContext(ctx context.Context, v Cartesian3dVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3dWithContext(ctx, *u.scatter3d)
	}
}

type Cartesian3dVisitorWithContext interface {
	VisitScatter3dWithContext(ctx context.Context, v Scatter3d) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCartesian3dFromScatter3d(v Scatter3d) Cartesian3d {
	return Cartesian3d{typ: "scatter3d", scatter3d: &v}
}

type ComputableNode struct {
	typ         string
	ranges      *SummarizeRanges
	series      *SummarizeSeries
	value       *SelectValue
	cartesian   *SummarizeCartesian
	cartesian3d *SummarizeCartesian3d
	frequency   *FrequencyDomain
	frequencyV2 *FrequencyDomainV2
	histogram   *Histogram
	curve       *CurveFit
}

type computableNodeDeserializer struct {
	Type        string                `json:"type"`
	Ranges      *SummarizeRanges      `json:"ranges"`
	Series      *SummarizeSeries      `json:"series"`
	Value       *SelectValue          `json:"value"`
	Cartesian   *SummarizeCartesian   `json:"cartesian"`
	Cartesian3d *SummarizeCartesian3d `json:"cartesian3d"`
	Frequency   *FrequencyDomain      `json:"frequency"`
	FrequencyV2 *FrequencyDomainV2    `json:"frequencyV2"`
	Histogram   *Histogram            `json:"histogram"`
	Curve       *CurveFit             `json:"curve"`
}

func (u *computableNodeDeserializer) toStruct() ComputableNode {
	return ComputableNode{typ: u.Type, ranges: u.Ranges, series: u.Series, value: u.Value, cartesian: u.Cartesian, cartesian3d: u.Cartesian3d, frequency: u.Frequency, frequencyV2: u.FrequencyV2, histogram: u.Histogram, curve: u.Curve}
}

func (u *ComputableNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "ranges":
		if u.ranges == nil {
			return nil, fmt.Errorf("field \"ranges\" is required")
		}
		return struct {
			Type   string          `json:"type"`
			Ranges SummarizeRanges `json:"ranges"`
		}{Type: "ranges", Ranges: *u.ranges}, nil
	case "series":
		if u.series == nil {
			return nil, fmt.Errorf("field \"series\" is required")
		}
		return struct {
			Type   string          `json:"type"`
			Series SummarizeSeries `json:"series"`
		}{Type: "series", Series: *u.series}, nil
	case "value":
		if u.value == nil {
			return nil, fmt.Errorf("field \"value\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Value SelectValue `json:"value"`
		}{Type: "value", Value: *u.value}, nil
	case "cartesian":
		if u.cartesian == nil {
			return nil, fmt.Errorf("field \"cartesian\" is required")
		}
		return struct {
			Type      string             `json:"type"`
			Cartesian SummarizeCartesian `json:"cartesian"`
		}{Type: "cartesian", Cartesian: *u.cartesian}, nil
	case "cartesian3d":
		if u.cartesian3d == nil {
			return nil, fmt.Errorf("field \"cartesian3d\" is required")
		}
		return struct {
			Type        string               `json:"type"`
			Cartesian3d SummarizeCartesian3d `json:"cartesian3d"`
		}{Type: "cartesian3d", Cartesian3d: *u.cartesian3d}, nil
	case "frequency":
		if u.frequency == nil {
			return nil, fmt.Errorf("field \"frequency\" is required")
		}
		return struct {
			Type      string          `json:"type"`
			Frequency FrequencyDomain `json:"frequency"`
		}{Type: "frequency", Frequency: *u.frequency}, nil
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return nil, fmt.Errorf("field \"frequencyV2\" is required")
		}
		return struct {
			Type        string            `json:"type"`
			FrequencyV2 FrequencyDomainV2 `json:"frequencyV2"`
		}{Type: "frequencyV2", FrequencyV2: *u.frequencyV2}, nil
	case "histogram":
		if u.histogram == nil {
			return nil, fmt.Errorf("field \"histogram\" is required")
		}
		return struct {
			Type      string    `json:"type"`
			Histogram Histogram `json:"histogram"`
		}{Type: "histogram", Histogram: *u.histogram}, nil
	case "curve":
		if u.curve == nil {
			return nil, fmt.Errorf("field \"curve\" is required")
		}
		return struct {
			Type  string   `json:"type"`
			Curve CurveFit `json:"curve"`
		}{Type: "curve", Curve: *u.curve}, nil
	}
}

func (u ComputableNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputableNode) UnmarshalJSON(data []byte) error {
	var deser computableNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return fmt.Errorf("field \"frequencyV2\" is required")
		}
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
	}
	return nil
}

func (u ComputableNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputableNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputableNode) AcceptFuncs(rangesFunc func(SummarizeRanges) error, seriesFunc func(SummarizeSeries) error, valueFunc func(SelectValue) error, cartesianFunc func(SummarizeCartesian) error, cartesian3dFunc func(SummarizeCartesian3d) error, frequencyFunc func(FrequencyDomain) error, frequencyV2Func func(FrequencyDomainV2) error, histogramFunc func(Histogram) error, curveFunc func(CurveFit) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return cartesian3dFunc(*u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return frequencyFunc(*u.frequency)
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return fmt.Errorf("field \"frequencyV2\" is required")
		}
		return frequencyV2Func(*u.frequencyV2)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return histogramFunc(*u.histogram)
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
		return curveFunc(*u.curve)
	}
}

func (u *ComputableNode) RangesNoopSuccess(SummarizeRanges) error {
	return nil
}

func (u *ComputableNode) SeriesNoopSuccess(SummarizeSeries) error {
	return nil
}

func (u *ComputableNode) ValueNoopSuccess(SelectValue) error {
	return nil
}

func (u *ComputableNode) CartesianNoopSuccess(SummarizeCartesian) error {
	return nil
}

func (u *ComputableNode) Cartesian3dNoopSuccess(SummarizeCartesian3d) error {
	return nil
}

func (u *ComputableNode) FrequencyNoopSuccess(FrequencyDomain) error {
	return nil
}

func (u *ComputableNode) FrequencyV2NoopSuccess(FrequencyDomainV2) error {
	return nil
}

func (u *ComputableNode) HistogramNoopSuccess(Histogram) error {
	return nil
}

func (u *ComputableNode) CurveNoopSuccess(CurveFit) error {
	return nil
}

func (u *ComputableNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputableNode) Accept(v ComputableNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(*u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(*u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(*u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(*u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3d(*u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequency(*u.frequency)
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return fmt.Errorf("field \"frequencyV2\" is required")
		}
		return v.VisitFrequencyV2(*u.frequencyV2)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogram(*u.histogram)
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
		return v.VisitCurve(*u.curve)
	}
}

type ComputableNodeVisitor interface {
	VisitRanges(v SummarizeRanges) error
	VisitSeries(v SummarizeSeries) error
	VisitValue(v SelectValue) error
	VisitCartesian(v SummarizeCartesian) error
	VisitCartesian3d(v SummarizeCartesian3d) error
	VisitFrequency(v FrequencyDomain) error
	VisitFrequencyV2(v FrequencyDomainV2) error
	VisitHistogram(v Histogram) error
	VisitCurve(v CurveFit) error
	VisitUnknown(typeName string) error
}

func (u *ComputableNode) AcceptWithContext(ctx context.Context, v ComputableNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRangesWithContext(ctx, *u.ranges)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeriesWithContext(ctx, *u.series)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValueWithContext(ctx, *u.value)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesianWithContext(ctx, *u.cartesian)
	case "cartesian3d":
		if u.cartesian3d == nil {
			return fmt.Errorf("field \"cartesian3d\" is required")
		}
		return v.VisitCartesian3dWithContext(ctx, *u.cartesian3d)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequencyWithContext(ctx, *u.frequency)
	case "frequencyV2":
		if u.frequencyV2 == nil {
			return fmt.Errorf("field \"frequencyV2\" is required")
		}
		return v.VisitFrequencyV2WithContext(ctx, *u.frequencyV2)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogramWithContext(ctx, *u.histogram)
	case "curve":
		if u.curve == nil {
			return fmt.Errorf("field \"curve\" is required")
		}
		return v.VisitCurveWithContext(ctx, *u.curve)
	}
}

type ComputableNodeVisitorWithContext interface {
	VisitRangesWithContext(ctx context.Context, v SummarizeRanges) error
	VisitSeriesWithContext(ctx context.Context, v SummarizeSeries) error
	VisitValueWithContext(ctx context.Context, v SelectValue) error
	VisitCartesianWithContext(ctx context.Context, v SummarizeCartesian) error
	VisitCartesian3dWithContext(ctx context.Context, v SummarizeCartesian3d) error
	VisitFrequencyWithContext(ctx context.Context, v FrequencyDomain) error
	VisitFrequencyV2WithContext(ctx context.Context, v FrequencyDomainV2) error
	VisitHistogramWithContext(ctx context.Context, v Histogram) error
	VisitCurveWithContext(ctx context.Context, v CurveFit) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputableNodeFromRanges(v SummarizeRanges) ComputableNode {
	return ComputableNode{typ: "ranges", ranges: &v}
}

func NewComputableNodeFromSeries(v SummarizeSeries) ComputableNode {
	return ComputableNode{typ: "series", series: &v}
}

func NewComputableNodeFromValue(v SelectValue) ComputableNode {
	return ComputableNode{typ: "value", value: &v}
}

func NewComputableNodeFromCartesian(v SummarizeCartesian) ComputableNode {
	return ComputableNode{typ: "cartesian", cartesian: &v}
}

func NewComputableNodeFromCartesian3d(v SummarizeCartesian3d) ComputableNode {
	return ComputableNode{typ: "cartesian3d", cartesian3d: &v}
}

func NewComputableNodeFromFrequency(v FrequencyDomain) ComputableNode {
	return ComputableNode{typ: "frequency", frequency: &v}
}

func NewComputableNodeFromFrequencyV2(v FrequencyDomainV2) ComputableNode {
	return ComputableNode{typ: "frequencyV2", frequencyV2: &v}
}

func NewComputableNodeFromHistogram(v Histogram) ComputableNode {
	return ComputableNode{typ: "histogram", histogram: &v}
}

func NewComputableNodeFromCurve(v CurveFit) ComputableNode {
	return ComputableNode{typ: "curve", curve: &v}
}

type ComputeNode struct {
	typ      string
	enum     *EnumSeries
	numeric  *NumericSeries
	log      *LogSeries
	ranges   *RangeSeries
	array    *ArraySeries
	struct_  *StructSeries
	curveFit *CurveFit
	raw      *api.Reference
}

type computeNodeDeserializer struct {
	Type     string         `json:"type"`
	Enum     *EnumSeries    `json:"enum"`
	Numeric  *NumericSeries `json:"numeric"`
	Log      *LogSeries     `json:"log"`
	Ranges   *RangeSeries   `json:"ranges"`
	Array    *ArraySeries   `json:"array"`
	Struct   *StructSeries  `json:"struct"`
	CurveFit *CurveFit      `json:"curveFit"`
	Raw      *api.Reference `json:"raw"`
}

func (u *computeNodeDeserializer) toStruct() ComputeNode {
	return ComputeNode{typ: u.Type, enum: u.Enum, numeric: u.Numeric, log: u.Log, ranges: u.Ranges, array: u.Array, struct_: u.Struct, curveFit: u.CurveFit, raw: u.Raw}
}

func (u *ComputeNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Enum EnumSeries `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Numeric NumericSeries `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "log":
		if u.log == nil {
			return nil, fmt.Errorf("field \"log\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Log  LogSeries `json:"log"`
		}{Type: "log", Log: *u.log}, nil
	case "ranges":
		if u.ranges == nil {
			return nil, fmt.Errorf("field \"ranges\" is required")
		}
		return struct {
			Type   string      `json:"type"`
			Ranges RangeSeries `json:"ranges"`
		}{Type: "ranges", Ranges: *u.ranges}, nil
	case "array":
		if u.array == nil {
			return nil, fmt.Errorf("field \"array\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Array ArraySeries `json:"array"`
		}{Type: "array", Array: *u.array}, nil
	case "struct":
		if u.struct_ == nil {
			return nil, fmt.Errorf("field \"struct\" is required")
		}
		return struct {
			Type   string       `json:"type"`
			Struct StructSeries `json:"struct"`
		}{Type: "struct", Struct: *u.struct_}, nil
	case "curveFit":
		if u.curveFit == nil {
			return nil, fmt.Errorf("field \"curveFit\" is required")
		}
		return struct {
			Type     string   `json:"type"`
			CurveFit CurveFit `json:"curveFit"`
		}{Type: "curveFit", CurveFit: *u.curveFit}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u ComputeNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputeNode) UnmarshalJSON(data []byte) error {
	var deser computeNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u ComputeNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputeNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputeNode) AcceptFuncs(enumFunc func(EnumSeries) error, numericFunc func(NumericSeries) error, logFunc func(LogSeries) error, rangesFunc func(RangeSeries) error, arrayFunc func(ArraySeries) error, struct_Func func(StructSeries) error, curveFitFunc func(CurveFit) error, rawFunc func(api.Reference) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return struct_Func(*u.struct_)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return curveFitFunc(*u.curveFit)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *ComputeNode) EnumNoopSuccess(EnumSeries) error {
	return nil
}

func (u *ComputeNode) NumericNoopSuccess(NumericSeries) error {
	return nil
}

func (u *ComputeNode) LogNoopSuccess(LogSeries) error {
	return nil
}

func (u *ComputeNode) RangesNoopSuccess(RangeSeries) error {
	return nil
}

func (u *ComputeNode) ArrayNoopSuccess(ArraySeries) error {
	return nil
}

func (u *ComputeNode) StructNoopSuccess(StructSeries) error {
	return nil
}

func (u *ComputeNode) CurveFitNoopSuccess(CurveFit) error {
	return nil
}

func (u *ComputeNode) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *ComputeNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputeNode) Accept(v ComputeNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(*u.log)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(*u.ranges)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(*u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStruct(*u.struct_)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return v.VisitCurveFit(*u.curveFit)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type ComputeNodeVisitor interface {
	VisitEnum(v EnumSeries) error
	VisitNumeric(v NumericSeries) error
	VisitLog(v LogSeries) error
	VisitRanges(v RangeSeries) error
	VisitArray(v ArraySeries) error
	VisitStruct(v StructSeries) error
	VisitCurveFit(v CurveFit) error
	VisitRaw(v api.Reference) error
	VisitUnknown(typeName string) error
}

func (u *ComputeNode) AcceptWithContext(ctx context.Context, v ComputeNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLogWithContext(ctx, *u.log)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRangesWithContext(ctx, *u.ranges)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArrayWithContext(ctx, *u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStructWithContext(ctx, *u.struct_)
	case "curveFit":
		if u.curveFit == nil {
			return fmt.Errorf("field \"curveFit\" is required")
		}
		return v.VisitCurveFitWithContext(ctx, *u.curveFit)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type ComputeNodeVisitorWithContext interface {
	VisitEnumWithContext(ctx context.Context, v EnumSeries) error
	VisitNumericWithContext(ctx context.Context, v NumericSeries) error
	VisitLogWithContext(ctx context.Context, v LogSeries) error
	VisitRangesWithContext(ctx context.Context, v RangeSeries) error
	VisitArrayWithContext(ctx context.Context, v ArraySeries) error
	VisitStructWithContext(ctx context.Context, v StructSeries) error
	VisitCurveFitWithContext(ctx context.Context, v CurveFit) error
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputeNodeFromEnum(v EnumSeries) ComputeNode {
	return ComputeNode{typ: "enum", enum: &v}
}

func NewComputeNodeFromNumeric(v NumericSeries) ComputeNode {
	return ComputeNode{typ: "numeric", numeric: &v}
}

func NewComputeNodeFromLog(v LogSeries) ComputeNode {
	return ComputeNode{typ: "log", log: &v}
}

func NewComputeNodeFromRanges(v RangeSeries) ComputeNode {
	return ComputeNode{typ: "ranges", ranges: &v}
}

func NewComputeNodeFromArray(v ArraySeries) ComputeNode {
	return ComputeNode{typ: "array", array: &v}
}

func NewComputeNodeFromStruct(v StructSeries) ComputeNode {
	return ComputeNode{typ: "struct", struct_: &v}
}

func NewComputeNodeFromCurveFit(v CurveFit) ComputeNode {
	return ComputeNode{typ: "curveFit", curveFit: &v}
}

func NewComputeNodeFromRaw(v api.Reference) ComputeNode {
	return ComputeNode{typ: "raw", raw: &v}
}

type CurveFitPlotType struct {
	typ        string
	timeSeries *TimeSeriesCurveFit
	scatter    *ScatterCurveFit
}

type curveFitPlotTypeDeserializer struct {
	Type       string              `json:"type"`
	TimeSeries *TimeSeriesCurveFit `json:"timeSeries"`
	Scatter    *ScatterCurveFit    `json:"scatter"`
}

func (u *curveFitPlotTypeDeserializer) toStruct() CurveFitPlotType {
	return CurveFitPlotType{typ: u.Type, timeSeries: u.TimeSeries, scatter: u.Scatter}
}

func (u *CurveFitPlotType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return nil, fmt.Errorf("field \"timeSeries\" is required")
		}
		return struct {
			Type       string             `json:"type"`
			TimeSeries TimeSeriesCurveFit `json:"timeSeries"`
		}{Type: "timeSeries", TimeSeries: *u.timeSeries}, nil
	case "scatter":
		if u.scatter == nil {
			return nil, fmt.Errorf("field \"scatter\" is required")
		}
		return struct {
			Type    string          `json:"type"`
			Scatter ScatterCurveFit `json:"scatter"`
		}{Type: "scatter", Scatter: *u.scatter}, nil
	}
}

func (u CurveFitPlotType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CurveFitPlotType) UnmarshalJSON(data []byte) error {
	var deser curveFitPlotTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
	}
	return nil
}

func (u CurveFitPlotType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CurveFitPlotType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CurveFitPlotType) AcceptFuncs(timeSeriesFunc func(TimeSeriesCurveFit) error, scatterFunc func(ScatterCurveFit) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return timeSeriesFunc(*u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	}
}

func (u *CurveFitPlotType) TimeSeriesNoopSuccess(TimeSeriesCurveFit) error {
	return nil
}

func (u *CurveFitPlotType) ScatterNoopSuccess(ScatterCurveFit) error {
	return nil
}

func (u *CurveFitPlotType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CurveFitPlotType) Accept(v CurveFitPlotTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeries(*u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(*u.scatter)
	}
}

type CurveFitPlotTypeVisitor interface {
	VisitTimeSeries(v TimeSeriesCurveFit) error
	VisitScatter(v ScatterCurveFit) error
	VisitUnknown(typeName string) error
}

func (u *CurveFitPlotType) AcceptWithContext(ctx context.Context, v CurveFitPlotTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeriesWithContext(ctx, *u.timeSeries)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatterWithContext(ctx, *u.scatter)
	}
}

type CurveFitPlotTypeVisitorWithContext interface {
	VisitTimeSeriesWithContext(ctx context.Context, v TimeSeriesCurveFit) error
	VisitScatterWithContext(ctx context.Context, v ScatterCurveFit) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCurveFitPlotTypeFromTimeSeries(v TimeSeriesCurveFit) CurveFitPlotType {
	return CurveFitPlotType{typ: "timeSeries", timeSeries: &v}
}

func NewCurveFitPlotTypeFromScatter(v ScatterCurveFit) CurveFitPlotType {
	return CurveFitPlotType{typ: "scatter", scatter: &v}
}

/*
Represents a derived series within a compute graph.
This is a series that is derived from a function within a module.
*/
type DerivedSeries struct {
	typ      string
	function *FunctionDerivedSeries
}

type derivedSeriesDeserializer struct {
	Type     string                 `json:"type"`
	Function *FunctionDerivedSeries `json:"function"`
}

func (u *derivedSeriesDeserializer) toStruct() DerivedSeries {
	return DerivedSeries{typ: u.Type, function: u.Function}
}

func (u *DerivedSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "function":
		if u.function == nil {
			return nil, fmt.Errorf("field \"function\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			Function FunctionDerivedSeries `json:"function"`
		}{Type: "function", Function: *u.function}, nil
	}
}

func (u DerivedSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DerivedSeries) UnmarshalJSON(data []byte) error {
	var deser derivedSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "function":
		if u.function == nil {
			return fmt.Errorf("field \"function\" is required")
		}
	}
	return nil
}

func (u DerivedSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DerivedSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DerivedSeries) AcceptFuncs(functionFunc func(FunctionDerivedSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "function":
		if u.function == nil {
			return fmt.Errorf("field \"function\" is required")
		}
		return functionFunc(*u.function)
	}
}

func (u *DerivedSeries) FunctionNoopSuccess(FunctionDerivedSeries) error {
	return nil
}

func (u *DerivedSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DerivedSeries) Accept(v DerivedSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "function":
		if u.function == nil {
			return fmt.Errorf("field \"function\" is required")
		}
		return v.VisitFunction(*u.function)
	}
}

type DerivedSeriesVisitor interface {
	VisitFunction(v FunctionDerivedSeries) error
	VisitUnknown(typeName string) error
}

func (u *DerivedSeries) AcceptWithContext(ctx context.Context, v DerivedSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "function":
		if u.function == nil {
			return fmt.Errorf("field \"function\" is required")
		}
		return v.VisitFunctionWithContext(ctx, *u.function)
	}
}

type DerivedSeriesVisitorWithContext interface {
	VisitFunctionWithContext(ctx context.Context, v FunctionDerivedSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDerivedSeriesFromFunction(v FunctionDerivedSeries) DerivedSeries {
	return DerivedSeries{typ: "function", function: &v}
}

type DurationConstant struct {
	typ      string
	literal  *api1.Duration
	variable *api.VariableName
}

type durationConstantDeserializer struct {
	Type     string            `json:"type"`
	Literal  *api1.Duration    `json:"literal"`
	Variable *api.VariableName `json:"variable"`
}

func (u *durationConstantDeserializer) toStruct() DurationConstant {
	return DurationConstant{typ: u.Type, literal: u.Literal, variable: u.Variable}
}

func (u *DurationConstant) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Literal api1.Duration `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string           `json:"type"`
			Variable api.VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	}
}

func (u DurationConstant) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DurationConstant) UnmarshalJSON(data []byte) error {
	var deser durationConstantDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	}
	return nil
}

func (u DurationConstant) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DurationConstant) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DurationConstant) AcceptFuncs(literalFunc func(api1.Duration) error, variableFunc func(api.VariableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	}
}

func (u *DurationConstant) LiteralNoopSuccess(api1.Duration) error {
	return nil
}

func (u *DurationConstant) VariableNoopSuccess(api.VariableName) error {
	return nil
}

func (u *DurationConstant) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DurationConstant) Accept(v DurationConstantVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	}
}

type DurationConstantVisitor interface {
	VisitLiteral(v api1.Duration) error
	VisitVariable(v api.VariableName) error
	VisitUnknown(typeName string) error
}

func (u *DurationConstant) AcceptWithContext(ctx context.Context, v DurationConstantVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	}
}

type DurationConstantVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v api1.Duration) error
	VisitVariableWithContext(ctx context.Context, v api.VariableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDurationConstantFromLiteral(v api1.Duration) DurationConstant {
	return DurationConstant{typ: "literal", literal: &v}
}

func NewDurationConstantFromVariable(v api.VariableName) DurationConstant {
	return DurationConstant{typ: "variable", variable: &v}
}

type Enum1dArraySeries struct {
	typ     string
	channel *api.ChannelSeries
	raw     *api.Reference
	derived *DerivedSeries
}

type enum1dArraySeriesDeserializer struct {
	Type    string             `json:"type"`
	Channel *api.ChannelSeries `json:"channel"`
	Raw     *api.Reference     `json:"raw"`
	Derived *DerivedSeries     `json:"derived"`
}

func (u *enum1dArraySeriesDeserializer) toStruct() Enum1dArraySeries {
	return Enum1dArraySeries{typ: u.Type, channel: u.Channel, raw: u.Raw, derived: u.Derived}
}

func (u *Enum1dArraySeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Channel api.ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	}
}

func (u Enum1dArraySeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Enum1dArraySeries) UnmarshalJSON(data []byte) error {
	var deser enum1dArraySeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	}
	return nil
}

func (u Enum1dArraySeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Enum1dArraySeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Enum1dArraySeries) AcceptFuncs(channelFunc func(api.ChannelSeries) error, rawFunc func(api.Reference) error, derivedFunc func(DerivedSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	}
}

func (u *Enum1dArraySeries) ChannelNoopSuccess(api.ChannelSeries) error {
	return nil
}

func (u *Enum1dArraySeries) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *Enum1dArraySeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *Enum1dArraySeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Enum1dArraySeries) Accept(v Enum1dArraySeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	}
}

type Enum1dArraySeriesVisitor interface {
	VisitChannel(v api.ChannelSeries) error
	VisitRaw(v api.Reference) error
	VisitDerived(v DerivedSeries) error
	VisitUnknown(typeName string) error
}

func (u *Enum1dArraySeries) AcceptWithContext(ctx context.Context, v Enum1dArraySeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	}
}

type Enum1dArraySeriesVisitorWithContext interface {
	VisitChannelWithContext(ctx context.Context, v api.ChannelSeries) error
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnum1dArraySeriesFromChannel(v api.ChannelSeries) Enum1dArraySeries {
	return Enum1dArraySeries{typ: "channel", channel: &v}
}

func NewEnum1dArraySeriesFromRaw(v api.Reference) Enum1dArraySeries {
	return Enum1dArraySeries{typ: "raw", raw: &v}
}

func NewEnum1dArraySeriesFromDerived(v DerivedSeries) Enum1dArraySeries {
	return Enum1dArraySeries{typ: "derived", derived: &v}
}

type EnumSeries struct {
	typ                  string
	aggregate            *AggregateEnumSeries
	raw                  *api.Reference
	channel              *api.ChannelSeries
	derived              *DerivedSeries
	resample             *EnumResampleSeries
	timeRangeFilter      *EnumTimeRangeFilterSeries
	timeShift            *EnumTimeShiftSeries
	union                *EnumUnionSeries
	filterTransformation *EnumFilterTransformationSeries
	valueMap             *ValueMapSeries
	select1dArrayIndex   *SelectIndexFrom1dEnumArraySeries
	extractFromStruct    *ExtractEnumFromStructSeries
	eventAggregation     *EventsEnumSeries
}

type enumSeriesDeserializer struct {
	Type                 string                            `json:"type"`
	Aggregate            *AggregateEnumSeries              `json:"aggregate"`
	Raw                  *api.Reference                    `json:"raw"`
	Channel              *api.ChannelSeries                `json:"channel"`
	Derived              *DerivedSeries                    `json:"derived"`
	Resample             *EnumResampleSeries               `json:"resample"`
	TimeRangeFilter      *EnumTimeRangeFilterSeries        `json:"timeRangeFilter"`
	TimeShift            *EnumTimeShiftSeries              `json:"timeShift"`
	Union                *EnumUnionSeries                  `json:"union"`
	FilterTransformation *EnumFilterTransformationSeries   `json:"filterTransformation"`
	ValueMap             *ValueMapSeries                   `json:"valueMap"`
	Select1dArrayIndex   *SelectIndexFrom1dEnumArraySeries `json:"select1dArrayIndex"`
	ExtractFromStruct    *ExtractEnumFromStructSeries      `json:"extractFromStruct"`
	EventAggregation     *EventsEnumSeries                 `json:"eventAggregation"`
}

func (u *enumSeriesDeserializer) toStruct() EnumSeries {
	return EnumSeries{typ: u.Type, aggregate: u.Aggregate, raw: u.Raw, channel: u.Channel, derived: u.Derived, resample: u.Resample, timeRangeFilter: u.TimeRangeFilter, timeShift: u.TimeShift, union: u.Union, filterTransformation: u.FilterTransformation, valueMap: u.ValueMap, select1dArrayIndex: u.Select1dArrayIndex, extractFromStruct: u.ExtractFromStruct, eventAggregation: u.EventAggregation}
}

func (u *EnumSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return nil, fmt.Errorf("field \"aggregate\" is required")
		}
		return struct {
			Type      string              `json:"type"`
			Aggregate AggregateEnumSeries `json:"aggregate"`
		}{Type: "aggregate", Aggregate: *u.aggregate}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Channel api.ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	case "resample":
		if u.resample == nil {
			return nil, fmt.Errorf("field \"resample\" is required")
		}
		return struct {
			Type     string             `json:"type"`
			Resample EnumResampleSeries `json:"resample"`
		}{Type: "resample", Resample: *u.resample}, nil
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return nil, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return struct {
			Type            string                    `json:"type"`
			TimeRangeFilter EnumTimeRangeFilterSeries `json:"timeRangeFilter"`
		}{Type: "timeRangeFilter", TimeRangeFilter: *u.timeRangeFilter}, nil
	case "timeShift":
		if u.timeShift == nil {
			return nil, fmt.Errorf("field \"timeShift\" is required")
		}
		return struct {
			Type      string              `json:"type"`
			TimeShift EnumTimeShiftSeries `json:"timeShift"`
		}{Type: "timeShift", TimeShift: *u.timeShift}, nil
	case "union":
		if u.union == nil {
			return nil, fmt.Errorf("field \"union\" is required")
		}
		return struct {
			Type  string          `json:"type"`
			Union EnumUnionSeries `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	case "filterTransformation":
		if u.filterTransformation == nil {
			return nil, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return struct {
			Type                 string                         `json:"type"`
			FilterTransformation EnumFilterTransformationSeries `json:"filterTransformation"`
		}{Type: "filterTransformation", FilterTransformation: *u.filterTransformation}, nil
	case "valueMap":
		if u.valueMap == nil {
			return nil, fmt.Errorf("field \"valueMap\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			ValueMap ValueMapSeries `json:"valueMap"`
		}{Type: "valueMap", ValueMap: *u.valueMap}, nil
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return nil, fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return struct {
			Type               string                           `json:"type"`
			Select1dArrayIndex SelectIndexFrom1dEnumArraySeries `json:"select1dArrayIndex"`
		}{Type: "select1dArrayIndex", Select1dArrayIndex: *u.select1dArrayIndex}, nil
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return nil, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return struct {
			Type              string                      `json:"type"`
			ExtractFromStruct ExtractEnumFromStructSeries `json:"extractFromStruct"`
		}{Type: "extractFromStruct", ExtractFromStruct: *u.extractFromStruct}, nil
	case "eventAggregation":
		if u.eventAggregation == nil {
			return nil, fmt.Errorf("field \"eventAggregation\" is required")
		}
		return struct {
			Type             string           `json:"type"`
			EventAggregation EventsEnumSeries `json:"eventAggregation"`
		}{Type: "eventAggregation", EventAggregation: *u.eventAggregation}, nil
	}
}

func (u EnumSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumSeries) UnmarshalJSON(data []byte) error {
	var deser enumSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
	case "eventAggregation":
		if u.eventAggregation == nil {
			return fmt.Errorf("field \"eventAggregation\" is required")
		}
	}
	return nil
}

func (u EnumSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumSeries) AcceptFuncs(aggregateFunc func(AggregateEnumSeries) error, rawFunc func(api.Reference) error, channelFunc func(api.ChannelSeries) error, derivedFunc func(DerivedSeries) error, resampleFunc func(EnumResampleSeries) error, timeRangeFilterFunc func(EnumTimeRangeFilterSeries) error, timeShiftFunc func(EnumTimeShiftSeries) error, unionFunc func(EnumUnionSeries) error, filterTransformationFunc func(EnumFilterTransformationSeries) error, valueMapFunc func(ValueMapSeries) error, select1dArrayIndexFunc func(SelectIndexFrom1dEnumArraySeries) error, extractFromStructFunc func(ExtractEnumFromStructSeries) error, eventAggregationFunc func(EventsEnumSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return aggregateFunc(*u.aggregate)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return resampleFunc(*u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return filterTransformationFunc(*u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
		return valueMapFunc(*u.valueMap)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return select1dArrayIndexFunc(*u.select1dArrayIndex)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	case "eventAggregation":
		if u.eventAggregation == nil {
			return fmt.Errorf("field \"eventAggregation\" is required")
		}
		return eventAggregationFunc(*u.eventAggregation)
	}
}

func (u *EnumSeries) AggregateNoopSuccess(AggregateEnumSeries) error {
	return nil
}

func (u *EnumSeries) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *EnumSeries) ChannelNoopSuccess(api.ChannelSeries) error {
	return nil
}

func (u *EnumSeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *EnumSeries) ResampleNoopSuccess(EnumResampleSeries) error {
	return nil
}

func (u *EnumSeries) TimeRangeFilterNoopSuccess(EnumTimeRangeFilterSeries) error {
	return nil
}

func (u *EnumSeries) TimeShiftNoopSuccess(EnumTimeShiftSeries) error {
	return nil
}

func (u *EnumSeries) UnionNoopSuccess(EnumUnionSeries) error {
	return nil
}

func (u *EnumSeries) FilterTransformationNoopSuccess(EnumFilterTransformationSeries) error {
	return nil
}

func (u *EnumSeries) ValueMapNoopSuccess(ValueMapSeries) error {
	return nil
}

func (u *EnumSeries) Select1dArrayIndexNoopSuccess(SelectIndexFrom1dEnumArraySeries) error {
	return nil
}

func (u *EnumSeries) ExtractFromStructNoopSuccess(ExtractEnumFromStructSeries) error {
	return nil
}

func (u *EnumSeries) EventAggregationNoopSuccess(EventsEnumSeries) error {
	return nil
}

func (u *EnumSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumSeries) Accept(v EnumSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregate(*u.aggregate)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResample(*u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(*u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformation(*u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
		return v.VisitValueMap(*u.valueMap)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return v.VisitSelect1dArrayIndex(*u.select1dArrayIndex)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(*u.extractFromStruct)
	case "eventAggregation":
		if u.eventAggregation == nil {
			return fmt.Errorf("field \"eventAggregation\" is required")
		}
		return v.VisitEventAggregation(*u.eventAggregation)
	}
}

type EnumSeriesVisitor interface {
	VisitAggregate(v AggregateEnumSeries) error
	VisitRaw(v api.Reference) error
	VisitChannel(v api.ChannelSeries) error
	VisitDerived(v DerivedSeries) error
	VisitResample(v EnumResampleSeries) error
	VisitTimeRangeFilter(v EnumTimeRangeFilterSeries) error
	VisitTimeShift(v EnumTimeShiftSeries) error
	VisitUnion(v EnumUnionSeries) error
	VisitFilterTransformation(v EnumFilterTransformationSeries) error
	VisitValueMap(v ValueMapSeries) error
	VisitSelect1dArrayIndex(v SelectIndexFrom1dEnumArraySeries) error
	VisitExtractFromStruct(v ExtractEnumFromStructSeries) error
	VisitEventAggregation(v EventsEnumSeries) error
	VisitUnknown(typeName string) error
}

func (u *EnumSeries) AcceptWithContext(ctx context.Context, v EnumSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregateWithContext(ctx, *u.aggregate)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResampleWithContext(ctx, *u.resample)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilterWithContext(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShiftWithContext(ctx, *u.timeShift)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformationWithContext(ctx, *u.filterTransformation)
	case "valueMap":
		if u.valueMap == nil {
			return fmt.Errorf("field \"valueMap\" is required")
		}
		return v.VisitValueMapWithContext(ctx, *u.valueMap)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return v.VisitSelect1dArrayIndexWithContext(ctx, *u.select1dArrayIndex)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStructWithContext(ctx, *u.extractFromStruct)
	case "eventAggregation":
		if u.eventAggregation == nil {
			return fmt.Errorf("field \"eventAggregation\" is required")
		}
		return v.VisitEventAggregationWithContext(ctx, *u.eventAggregation)
	}
}

type EnumSeriesVisitorWithContext interface {
	VisitAggregateWithContext(ctx context.Context, v AggregateEnumSeries) error
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitChannelWithContext(ctx context.Context, v api.ChannelSeries) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitResampleWithContext(ctx context.Context, v EnumResampleSeries) error
	VisitTimeRangeFilterWithContext(ctx context.Context, v EnumTimeRangeFilterSeries) error
	VisitTimeShiftWithContext(ctx context.Context, v EnumTimeShiftSeries) error
	VisitUnionWithContext(ctx context.Context, v EnumUnionSeries) error
	VisitFilterTransformationWithContext(ctx context.Context, v EnumFilterTransformationSeries) error
	VisitValueMapWithContext(ctx context.Context, v ValueMapSeries) error
	VisitSelect1dArrayIndexWithContext(ctx context.Context, v SelectIndexFrom1dEnumArraySeries) error
	VisitExtractFromStructWithContext(ctx context.Context, v ExtractEnumFromStructSeries) error
	VisitEventAggregationWithContext(ctx context.Context, v EventsEnumSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumSeriesFromAggregate(v AggregateEnumSeries) EnumSeries {
	return EnumSeries{typ: "aggregate", aggregate: &v}
}

func NewEnumSeriesFromRaw(v api.Reference) EnumSeries {
	return EnumSeries{typ: "raw", raw: &v}
}

func NewEnumSeriesFromChannel(v api.ChannelSeries) EnumSeries {
	return EnumSeries{typ: "channel", channel: &v}
}

func NewEnumSeriesFromDerived(v DerivedSeries) EnumSeries {
	return EnumSeries{typ: "derived", derived: &v}
}

func NewEnumSeriesFromResample(v EnumResampleSeries) EnumSeries {
	return EnumSeries{typ: "resample", resample: &v}
}

func NewEnumSeriesFromTimeRangeFilter(v EnumTimeRangeFilterSeries) EnumSeries {
	return EnumSeries{typ: "timeRangeFilter", timeRangeFilter: &v}
}

func NewEnumSeriesFromTimeShift(v EnumTimeShiftSeries) EnumSeries {
	return EnumSeries{typ: "timeShift", timeShift: &v}
}

func NewEnumSeriesFromUnion(v EnumUnionSeries) EnumSeries {
	return EnumSeries{typ: "union", union: &v}
}

func NewEnumSeriesFromFilterTransformation(v EnumFilterTransformationSeries) EnumSeries {
	return EnumSeries{typ: "filterTransformation", filterTransformation: &v}
}

func NewEnumSeriesFromValueMap(v ValueMapSeries) EnumSeries {
	return EnumSeries{typ: "valueMap", valueMap: &v}
}

func NewEnumSeriesFromSelect1dArrayIndex(v SelectIndexFrom1dEnumArraySeries) EnumSeries {
	return EnumSeries{typ: "select1dArrayIndex", select1dArrayIndex: &v}
}

func NewEnumSeriesFromExtractFromStruct(v ExtractEnumFromStructSeries) EnumSeries {
	return EnumSeries{typ: "extractFromStruct", extractFromStruct: &v}
}

func NewEnumSeriesFromEventAggregation(v EventsEnumSeries) EnumSeries {
	return EnumSeries{typ: "eventAggregation", eventAggregation: &v}
}

type FrequencyDomain struct {
	typ         string
	fft         *Fft
	periodogram *Periodogram
}

type frequencyDomainDeserializer struct {
	Type        string       `json:"type"`
	Fft         *Fft         `json:"fft"`
	Periodogram *Periodogram `json:"periodogram"`
}

func (u *frequencyDomainDeserializer) toStruct() FrequencyDomain {
	return FrequencyDomain{typ: u.Type, fft: u.Fft, periodogram: u.Periodogram}
}

func (u *FrequencyDomain) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "fft":
		if u.fft == nil {
			return nil, fmt.Errorf("field \"fft\" is required")
		}
		return struct {
			Type string `json:"type"`
			Fft  Fft    `json:"fft"`
		}{Type: "fft", Fft: *u.fft}, nil
	case "periodogram":
		if u.periodogram == nil {
			return nil, fmt.Errorf("field \"periodogram\" is required")
		}
		return struct {
			Type        string      `json:"type"`
			Periodogram Periodogram `json:"periodogram"`
		}{Type: "periodogram", Periodogram: *u.periodogram}, nil
	}
}

func (u FrequencyDomain) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FrequencyDomain) UnmarshalJSON(data []byte) error {
	var deser frequencyDomainDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
	case "periodogram":
		if u.periodogram == nil {
			return fmt.Errorf("field \"periodogram\" is required")
		}
	}
	return nil
}

func (u FrequencyDomain) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FrequencyDomain) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FrequencyDomain) AcceptFuncs(fftFunc func(Fft) error, periodogramFunc func(Periodogram) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	case "periodogram":
		if u.periodogram == nil {
			return fmt.Errorf("field \"periodogram\" is required")
		}
		return periodogramFunc(*u.periodogram)
	}
}

func (u *FrequencyDomain) FftNoopSuccess(Fft) error {
	return nil
}

func (u *FrequencyDomain) PeriodogramNoopSuccess(Periodogram) error {
	return nil
}

func (u *FrequencyDomain) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FrequencyDomain) Accept(v FrequencyDomainVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(*u.fft)
	case "periodogram":
		if u.periodogram == nil {
			return fmt.Errorf("field \"periodogram\" is required")
		}
		return v.VisitPeriodogram(*u.periodogram)
	}
}

type FrequencyDomainVisitor interface {
	VisitFft(v Fft) error
	VisitPeriodogram(v Periodogram) error
	VisitUnknown(typeName string) error
}

func (u *FrequencyDomain) AcceptWithContext(ctx context.Context, v FrequencyDomainVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFftWithContext(ctx, *u.fft)
	case "periodogram":
		if u.periodogram == nil {
			return fmt.Errorf("field \"periodogram\" is required")
		}
		return v.VisitPeriodogramWithContext(ctx, *u.periodogram)
	}
}

type FrequencyDomainVisitorWithContext interface {
	VisitFftWithContext(ctx context.Context, v Fft) error
	VisitPeriodogramWithContext(ctx context.Context, v Periodogram) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFrequencyDomainFromFft(v Fft) FrequencyDomain {
	return FrequencyDomain{typ: "fft", fft: &v}
}

func NewFrequencyDomainFromPeriodogram(v Periodogram) FrequencyDomain {
	return FrequencyDomain{typ: "periodogram", periodogram: &v}
}

type FrequencyDomainV2 struct {
	typ     string
	fft     *Fft
	psd     *Psd
	cpsd    *Cpsd
	nyquist *Nyquist
	bode    *Bode
}

type frequencyDomainV2Deserializer struct {
	Type    string   `json:"type"`
	Fft     *Fft     `json:"fft"`
	Psd     *Psd     `json:"psd"`
	Cpsd    *Cpsd    `json:"cpsd"`
	Nyquist *Nyquist `json:"nyquist"`
	Bode    *Bode    `json:"bode"`
}

func (u *frequencyDomainV2Deserializer) toStruct() FrequencyDomainV2 {
	return FrequencyDomainV2{typ: u.Type, fft: u.Fft, psd: u.Psd, cpsd: u.Cpsd, nyquist: u.Nyquist, bode: u.Bode}
}

func (u *FrequencyDomainV2) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "fft":
		if u.fft == nil {
			return nil, fmt.Errorf("field \"fft\" is required")
		}
		return struct {
			Type string `json:"type"`
			Fft  Fft    `json:"fft"`
		}{Type: "fft", Fft: *u.fft}, nil
	case "psd":
		if u.psd == nil {
			return nil, fmt.Errorf("field \"psd\" is required")
		}
		return struct {
			Type string `json:"type"`
			Psd  Psd    `json:"psd"`
		}{Type: "psd", Psd: *u.psd}, nil
	case "cpsd":
		if u.cpsd == nil {
			return nil, fmt.Errorf("field \"cpsd\" is required")
		}
		return struct {
			Type string `json:"type"`
			Cpsd Cpsd   `json:"cpsd"`
		}{Type: "cpsd", Cpsd: *u.cpsd}, nil
	case "nyquist":
		if u.nyquist == nil {
			return nil, fmt.Errorf("field \"nyquist\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Nyquist Nyquist `json:"nyquist"`
		}{Type: "nyquist", Nyquist: *u.nyquist}, nil
	case "bode":
		if u.bode == nil {
			return nil, fmt.Errorf("field \"bode\" is required")
		}
		return struct {
			Type string `json:"type"`
			Bode Bode   `json:"bode"`
		}{Type: "bode", Bode: *u.bode}, nil
	}
}

func (u FrequencyDomainV2) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FrequencyDomainV2) UnmarshalJSON(data []byte) error {
	var deser frequencyDomainV2Deserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
	}
	return nil
}

func (u FrequencyDomainV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FrequencyDomainV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FrequencyDomainV2) AcceptFuncs(fftFunc func(Fft) error, psdFunc func(Psd) error, cpsdFunc func(Cpsd) error, nyquistFunc func(Nyquist) error, bodeFunc func(Bode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return psdFunc(*u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
		return cpsdFunc(*u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
		return nyquistFunc(*u.nyquist)
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
		return bodeFunc(*u.bode)
	}
}

func (u *FrequencyDomainV2) FftNoopSuccess(Fft) error {
	return nil
}

func (u *FrequencyDomainV2) PsdNoopSuccess(Psd) error {
	return nil
}

func (u *FrequencyDomainV2) CpsdNoopSuccess(Cpsd) error {
	return nil
}

func (u *FrequencyDomainV2) NyquistNoopSuccess(Nyquist) error {
	return nil
}

func (u *FrequencyDomainV2) BodeNoopSuccess(Bode) error {
	return nil
}

func (u *FrequencyDomainV2) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FrequencyDomainV2) Accept(v FrequencyDomainV2Visitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(*u.fft)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsd(*u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
		return v.VisitCpsd(*u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
		return v.VisitNyquist(*u.nyquist)
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
		return v.VisitBode(*u.bode)
	}
}

type FrequencyDomainV2Visitor interface {
	VisitFft(v Fft) error
	VisitPsd(v Psd) error
	VisitCpsd(v Cpsd) error
	VisitNyquist(v Nyquist) error
	VisitBode(v Bode) error
	VisitUnknown(typeName string) error
}

func (u *FrequencyDomainV2) AcceptWithContext(ctx context.Context, v FrequencyDomainV2VisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFftWithContext(ctx, *u.fft)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsdWithContext(ctx, *u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
		return v.VisitCpsdWithContext(ctx, *u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
		return v.VisitNyquistWithContext(ctx, *u.nyquist)
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
		return v.VisitBodeWithContext(ctx, *u.bode)
	}
}

type FrequencyDomainV2VisitorWithContext interface {
	VisitFftWithContext(ctx context.Context, v Fft) error
	VisitPsdWithContext(ctx context.Context, v Psd) error
	VisitCpsdWithContext(ctx context.Context, v Cpsd) error
	VisitNyquistWithContext(ctx context.Context, v Nyquist) error
	VisitBodeWithContext(ctx context.Context, v Bode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFrequencyDomainV2FromFft(v Fft) FrequencyDomainV2 {
	return FrequencyDomainV2{typ: "fft", fft: &v}
}

func NewFrequencyDomainV2FromPsd(v Psd) FrequencyDomainV2 {
	return FrequencyDomainV2{typ: "psd", psd: &v}
}

func NewFrequencyDomainV2FromCpsd(v Cpsd) FrequencyDomainV2 {
	return FrequencyDomainV2{typ: "cpsd", cpsd: &v}
}

func NewFrequencyDomainV2FromNyquist(v Nyquist) FrequencyDomainV2 {
	return FrequencyDomainV2{typ: "nyquist", nyquist: &v}
}

func NewFrequencyDomainV2FromBode(v Bode) FrequencyDomainV2 {
	return FrequencyDomainV2{typ: "bode", bode: &v}
}

type FunctionParameterValue struct {
	typ      string
	variable *api.VariableName
	value    *VariableValue
}

type functionParameterValueDeserializer struct {
	Type     string            `json:"type"`
	Variable *api.VariableName `json:"variable"`
	Value    *VariableValue    `json:"value"`
}

func (u *functionParameterValueDeserializer) toStruct() FunctionParameterValue {
	return FunctionParameterValue{typ: u.Type, variable: u.Variable, value: u.Value}
}

func (u *FunctionParameterValue) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string           `json:"type"`
			Variable api.VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	case "value":
		if u.value == nil {
			return nil, fmt.Errorf("field \"value\" is required")
		}
		return struct {
			Type  string        `json:"type"`
			Value VariableValue `json:"value"`
		}{Type: "value", Value: *u.value}, nil
	}
}

func (u FunctionParameterValue) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FunctionParameterValue) UnmarshalJSON(data []byte) error {
	var deser functionParameterValueDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
	}
	return nil
}

func (u FunctionParameterValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FunctionParameterValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FunctionParameterValue) AcceptFuncs(variableFunc func(api.VariableName) error, valueFunc func(VariableValue) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *FunctionParameterValue) VariableNoopSuccess(api.VariableName) error {
	return nil
}

func (u *FunctionParameterValue) ValueNoopSuccess(VariableValue) error {
	return nil
}

func (u *FunctionParameterValue) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FunctionParameterValue) Accept(v FunctionParameterValueVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(*u.value)
	}
}

type FunctionParameterValueVisitor interface {
	VisitVariable(v api.VariableName) error
	VisitValue(v VariableValue) error
	VisitUnknown(typeName string) error
}

func (u *FunctionParameterValue) AcceptWithContext(ctx context.Context, v FunctionParameterValueVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValueWithContext(ctx, *u.value)
	}
}

type FunctionParameterValueVisitorWithContext interface {
	VisitVariableWithContext(ctx context.Context, v api.VariableName) error
	VisitValueWithContext(ctx context.Context, v VariableValue) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFunctionParameterValueFromVariable(v api.VariableName) FunctionParameterValue {
	return FunctionParameterValue{typ: "variable", variable: &v}
}

func NewFunctionParameterValueFromValue(v VariableValue) FunctionParameterValue {
	return FunctionParameterValue{typ: "value", value: &v}
}

type Histogram struct {
	typ     string
	numeric *NumericHistogramNode
	enum    *EnumHistogramNode
}

type histogramDeserializer struct {
	Type    string                `json:"type"`
	Numeric *NumericHistogramNode `json:"numeric"`
	Enum    *EnumHistogramNode    `json:"enum"`
}

func (u *histogramDeserializer) toStruct() Histogram {
	return Histogram{typ: u.Type, numeric: u.Numeric, enum: u.Enum}
}

func (u *Histogram) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string               `json:"type"`
			Numeric NumericHistogramNode `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string            `json:"type"`
			Enum EnumHistogramNode `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	}
}

func (u Histogram) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Histogram) UnmarshalJSON(data []byte) error {
	var deser histogramDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	}
	return nil
}

func (u Histogram) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Histogram) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Histogram) AcceptFuncs(numericFunc func(NumericHistogramNode) error, enumFunc func(EnumHistogramNode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	}
}

func (u *Histogram) NumericNoopSuccess(NumericHistogramNode) error {
	return nil
}

func (u *Histogram) EnumNoopSuccess(EnumHistogramNode) error {
	return nil
}

func (u *Histogram) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Histogram) Accept(v HistogramVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	}
}

type HistogramVisitor interface {
	VisitNumeric(v NumericHistogramNode) error
	VisitEnum(v EnumHistogramNode) error
	VisitUnknown(typeName string) error
}

func (u *Histogram) AcceptWithContext(ctx context.Context, v HistogramVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	}
}

type HistogramVisitorWithContext interface {
	VisitNumericWithContext(ctx context.Context, v NumericHistogramNode) error
	VisitEnumWithContext(ctx context.Context, v EnumHistogramNode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewHistogramFromNumeric(v NumericHistogramNode) Histogram {
	return Histogram{typ: "numeric", numeric: &v}
}

func NewHistogramFromEnum(v EnumHistogramNode) Histogram {
	return Histogram{typ: "enum", enum: &v}
}

type InterpolationConfiguration struct {
	typ                      string
	forwardFillInterpolation *ForwardFillInterpolation
}

type interpolationConfigurationDeserializer struct {
	Type                     string                    `json:"type"`
	ForwardFillInterpolation *ForwardFillInterpolation `json:"forwardFillInterpolation"`
}

func (u *interpolationConfigurationDeserializer) toStruct() InterpolationConfiguration {
	return InterpolationConfiguration{typ: u.Type, forwardFillInterpolation: u.ForwardFillInterpolation}
}

func (u *InterpolationConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return nil, fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return struct {
			Type                     string                   `json:"type"`
			ForwardFillInterpolation ForwardFillInterpolation `json:"forwardFillInterpolation"`
		}{Type: "forwardFillInterpolation", ForwardFillInterpolation: *u.forwardFillInterpolation}, nil
	}
}

func (u InterpolationConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *InterpolationConfiguration) UnmarshalJSON(data []byte) error {
	var deser interpolationConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
	}
	return nil
}

func (u InterpolationConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *InterpolationConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *InterpolationConfiguration) AcceptFuncs(forwardFillInterpolationFunc func(ForwardFillInterpolation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return forwardFillInterpolationFunc(*u.forwardFillInterpolation)
	}
}

func (u *InterpolationConfiguration) ForwardFillInterpolationNoopSuccess(ForwardFillInterpolation) error {
	return nil
}

func (u *InterpolationConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *InterpolationConfiguration) Accept(v InterpolationConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return v.VisitForwardFillInterpolation(*u.forwardFillInterpolation)
	}
}

type InterpolationConfigurationVisitor interface {
	VisitForwardFillInterpolation(v ForwardFillInterpolation) error
	VisitUnknown(typeName string) error
}

func (u *InterpolationConfiguration) AcceptWithContext(ctx context.Context, v InterpolationConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "forwardFillInterpolation":
		if u.forwardFillInterpolation == nil {
			return fmt.Errorf("field \"forwardFillInterpolation\" is required")
		}
		return v.VisitForwardFillInterpolationWithContext(ctx, *u.forwardFillInterpolation)
	}
}

type InterpolationConfigurationVisitorWithContext interface {
	VisitForwardFillInterpolationWithContext(ctx context.Context, v ForwardFillInterpolation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewInterpolationConfigurationFromForwardFillInterpolation(v ForwardFillInterpolation) InterpolationConfiguration {
	return InterpolationConfiguration{typ: "forwardFillInterpolation", forwardFillInterpolation: &v}
}

type LogSeries struct {
	typ       string
	raw       *api.Reference
	channel   *api.ChannelSeries
	derived   *DerivedSeries
	union     *LogUnionSeries
	filter    *LogFilterSeries
	timeShift *LogTimeShiftSeries
}

type logSeriesDeserializer struct {
	Type      string              `json:"type"`
	Raw       *api.Reference      `json:"raw"`
	Channel   *api.ChannelSeries  `json:"channel"`
	Derived   *DerivedSeries      `json:"derived"`
	Union     *LogUnionSeries     `json:"union"`
	Filter    *LogFilterSeries    `json:"filter"`
	TimeShift *LogTimeShiftSeries `json:"timeShift"`
}

func (u *logSeriesDeserializer) toStruct() LogSeries {
	return LogSeries{typ: u.Type, raw: u.Raw, channel: u.Channel, derived: u.Derived, union: u.Union, filter: u.Filter, timeShift: u.TimeShift}
}

func (u *LogSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Channel api.ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	case "union":
		if u.union == nil {
			return nil, fmt.Errorf("field \"union\" is required")
		}
		return struct {
			Type  string         `json:"type"`
			Union LogUnionSeries `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	case "filter":
		if u.filter == nil {
			return nil, fmt.Errorf("field \"filter\" is required")
		}
		return struct {
			Type   string          `json:"type"`
			Filter LogFilterSeries `json:"filter"`
		}{Type: "filter", Filter: *u.filter}, nil
	case "timeShift":
		if u.timeShift == nil {
			return nil, fmt.Errorf("field \"timeShift\" is required")
		}
		return struct {
			Type      string             `json:"type"`
			TimeShift LogTimeShiftSeries `json:"timeShift"`
		}{Type: "timeShift", TimeShift: *u.timeShift}, nil
	}
}

func (u LogSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LogSeries) UnmarshalJSON(data []byte) error {
	var deser logSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
	}
	return nil
}

func (u LogSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LogSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LogSeries) AcceptFuncs(rawFunc func(api.Reference) error, channelFunc func(api.ChannelSeries) error, derivedFunc func(DerivedSeries) error, unionFunc func(LogUnionSeries) error, filterFunc func(LogFilterSeries) error, timeShiftFunc func(LogTimeShiftSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
		return filterFunc(*u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	}
}

func (u *LogSeries) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *LogSeries) ChannelNoopSuccess(api.ChannelSeries) error {
	return nil
}

func (u *LogSeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *LogSeries) UnionNoopSuccess(LogUnionSeries) error {
	return nil
}

func (u *LogSeries) FilterNoopSuccess(LogFilterSeries) error {
	return nil
}

func (u *LogSeries) TimeShiftNoopSuccess(LogTimeShiftSeries) error {
	return nil
}

func (u *LogSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LogSeries) Accept(v LogSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
		return v.VisitFilter(*u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(*u.timeShift)
	}
}

type LogSeriesVisitor interface {
	VisitRaw(v api.Reference) error
	VisitChannel(v api.ChannelSeries) error
	VisitDerived(v DerivedSeries) error
	VisitUnion(v LogUnionSeries) error
	VisitFilter(v LogFilterSeries) error
	VisitTimeShift(v LogTimeShiftSeries) error
	VisitUnknown(typeName string) error
}

func (u *LogSeries) AcceptWithContext(ctx context.Context, v LogSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	case "filter":
		if u.filter == nil {
			return fmt.Errorf("field \"filter\" is required")
		}
		return v.VisitFilterWithContext(ctx, *u.filter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShiftWithContext(ctx, *u.timeShift)
	}
}

type LogSeriesVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitChannelWithContext(ctx context.Context, v api.ChannelSeries) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitUnionWithContext(ctx context.Context, v LogUnionSeries) error
	VisitFilterWithContext(ctx context.Context, v LogFilterSeries) error
	VisitTimeShiftWithContext(ctx context.Context, v LogTimeShiftSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLogSeriesFromRaw(v api.Reference) LogSeries {
	return LogSeries{typ: "raw", raw: &v}
}

func NewLogSeriesFromChannel(v api.ChannelSeries) LogSeries {
	return LogSeries{typ: "channel", channel: &v}
}

func NewLogSeriesFromDerived(v DerivedSeries) LogSeries {
	return LogSeries{typ: "derived", derived: &v}
}

func NewLogSeriesFromUnion(v LogUnionSeries) LogSeries {
	return LogSeries{typ: "union", union: &v}
}

func NewLogSeriesFromFilter(v LogFilterSeries) LogSeries {
	return LogSeries{typ: "filter", filter: &v}
}

func NewLogSeriesFromTimeShift(v LogTimeShiftSeries) LogSeries {
	return LogSeries{typ: "timeShift", timeShift: &v}
}

type Numeric1dArraySeries struct {
	typ     string
	channel *api.ChannelSeries
	raw     *api.Reference
	derived *DerivedSeries
}

type numeric1dArraySeriesDeserializer struct {
	Type    string             `json:"type"`
	Channel *api.ChannelSeries `json:"channel"`
	Raw     *api.Reference     `json:"raw"`
	Derived *DerivedSeries     `json:"derived"`
}

func (u *numeric1dArraySeriesDeserializer) toStruct() Numeric1dArraySeries {
	return Numeric1dArraySeries{typ: u.Type, channel: u.Channel, raw: u.Raw, derived: u.Derived}
}

func (u *Numeric1dArraySeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Channel api.ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	}
}

func (u Numeric1dArraySeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Numeric1dArraySeries) UnmarshalJSON(data []byte) error {
	var deser numeric1dArraySeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	}
	return nil
}

func (u Numeric1dArraySeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Numeric1dArraySeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Numeric1dArraySeries) AcceptFuncs(channelFunc func(api.ChannelSeries) error, rawFunc func(api.Reference) error, derivedFunc func(DerivedSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	}
}

func (u *Numeric1dArraySeries) ChannelNoopSuccess(api.ChannelSeries) error {
	return nil
}

func (u *Numeric1dArraySeries) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *Numeric1dArraySeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *Numeric1dArraySeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Numeric1dArraySeries) Accept(v Numeric1dArraySeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	}
}

type Numeric1dArraySeriesVisitor interface {
	VisitChannel(v api.ChannelSeries) error
	VisitRaw(v api.Reference) error
	VisitDerived(v DerivedSeries) error
	VisitUnknown(typeName string) error
}

func (u *Numeric1dArraySeries) AcceptWithContext(ctx context.Context, v Numeric1dArraySeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	}
}

type Numeric1dArraySeriesVisitorWithContext interface {
	VisitChannelWithContext(ctx context.Context, v api.ChannelSeries) error
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumeric1dArraySeriesFromChannel(v api.ChannelSeries) Numeric1dArraySeries {
	return Numeric1dArraySeries{typ: "channel", channel: &v}
}

func NewNumeric1dArraySeriesFromRaw(v api.Reference) Numeric1dArraySeries {
	return Numeric1dArraySeries{typ: "raw", raw: &v}
}

func NewNumeric1dArraySeriesFromDerived(v DerivedSeries) Numeric1dArraySeries {
	return Numeric1dArraySeries{typ: "derived", derived: &v}
}

type NumericSeries struct {
	typ                  string
	aggregate            *AggregateNumericSeries
	arithmetic           *ArithmeticSeries
	bitOperation         *BitOperationSeries
	countDuplicate       *EnumCountDuplicateSeries
	cumulativeSum        *CumulativeSumSeries
	derivative           *DerivativeSeries
	integral             *IntegralSeries
	max                  *MaxSeries
	mean                 *MeanSeries
	min                  *MinSeries
	offset               *OffsetSeries
	product              *ProductSeries
	raw                  *api.Reference
	channel              *api.ChannelSeries
	derived              *DerivedSeries
	resample             *NumericResampleSeries
	rollingOperation     *RollingOperationSeries
	signalFilter         *SignalFilterSeries
	sum                  *SumSeries
	scale                *ScaleSeries
	timeDifference       *TimeDifferenceSeries
	absoluteTimestamp    *AbsoluteTimestampSeries
	timeRangeFilter      *NumericTimeRangeFilterSeries
	timeShift            *NumericTimeShiftSeries
	unaryArithmetic      *UnaryArithmeticSeries
	binaryArithmetic     *BinaryArithmeticSeries
	union                *NumericUnionSeries
	unitConversion       *UnitConversionSeries
	valueDifference      *ValueDifferenceSeries
	filterTransformation *NumericFilterTransformationSeries
	thresholdFilter      *NumericThresholdFilterSeries
	approximateFilter    *NumericApproximateFilterSeries
	select1dArrayIndex   *SelectIndexFrom1dNumericArraySeries
	selectNewestPoints   *SelectNewestPointsSeries
	aggregateUnderRanges *AggregateUnderRangesSeries
	filterByExpression   *FilterByExpressionSeries
	enumToNumeric        *EnumToNumericSeries
	refprop              *RefpropSeries
	extractFromStruct    *ExtractNumericFromStructSeries
}

type numericSeriesDeserializer struct {
	Type                 string                               `json:"type"`
	Aggregate            *AggregateNumericSeries              `json:"aggregate"`
	Arithmetic           *ArithmeticSeries                    `json:"arithmetic"`
	BitOperation         *BitOperationSeries                  `json:"bitOperation"`
	CountDuplicate       *EnumCountDuplicateSeries            `json:"countDuplicate"`
	CumulativeSum        *CumulativeSumSeries                 `json:"cumulativeSum"`
	Derivative           *DerivativeSeries                    `json:"derivative"`
	Integral             *IntegralSeries                      `json:"integral"`
	Max                  *MaxSeries                           `json:"max"`
	Mean                 *MeanSeries                          `json:"mean"`
	Min                  *MinSeries                           `json:"min"`
	Offset               *OffsetSeries                        `json:"offset"`
	Product              *ProductSeries                       `json:"product"`
	Raw                  *api.Reference                       `json:"raw"`
	Channel              *api.ChannelSeries                   `json:"channel"`
	Derived              *DerivedSeries                       `json:"derived"`
	Resample             *NumericResampleSeries               `json:"resample"`
	RollingOperation     *RollingOperationSeries              `json:"rollingOperation"`
	SignalFilter         *SignalFilterSeries                  `json:"signalFilter"`
	Sum                  *SumSeries                           `json:"sum"`
	Scale                *ScaleSeries                         `json:"scale"`
	TimeDifference       *TimeDifferenceSeries                `json:"timeDifference"`
	AbsoluteTimestamp    *AbsoluteTimestampSeries             `json:"absoluteTimestamp"`
	TimeRangeFilter      *NumericTimeRangeFilterSeries        `json:"timeRangeFilter"`
	TimeShift            *NumericTimeShiftSeries              `json:"timeShift"`
	UnaryArithmetic      *UnaryArithmeticSeries               `json:"unaryArithmetic"`
	BinaryArithmetic     *BinaryArithmeticSeries              `json:"binaryArithmetic"`
	Union                *NumericUnionSeries                  `json:"union"`
	UnitConversion       *UnitConversionSeries                `json:"unitConversion"`
	ValueDifference      *ValueDifferenceSeries               `json:"valueDifference"`
	FilterTransformation *NumericFilterTransformationSeries   `json:"filterTransformation"`
	ThresholdFilter      *NumericThresholdFilterSeries        `json:"thresholdFilter"`
	ApproximateFilter    *NumericApproximateFilterSeries      `json:"approximateFilter"`
	Select1dArrayIndex   *SelectIndexFrom1dNumericArraySeries `json:"select1dArrayIndex"`
	SelectNewestPoints   *SelectNewestPointsSeries            `json:"selectNewestPoints"`
	AggregateUnderRanges *AggregateUnderRangesSeries          `json:"aggregateUnderRanges"`
	FilterByExpression   *FilterByExpressionSeries            `json:"filterByExpression"`
	EnumToNumeric        *EnumToNumericSeries                 `json:"enumToNumeric"`
	Refprop              *RefpropSeries                       `json:"refprop"`
	ExtractFromStruct    *ExtractNumericFromStructSeries      `json:"extractFromStruct"`
}

func (u *numericSeriesDeserializer) toStruct() NumericSeries {
	return NumericSeries{typ: u.Type, aggregate: u.Aggregate, arithmetic: u.Arithmetic, bitOperation: u.BitOperation, countDuplicate: u.CountDuplicate, cumulativeSum: u.CumulativeSum, derivative: u.Derivative, integral: u.Integral, max: u.Max, mean: u.Mean, min: u.Min, offset: u.Offset, product: u.Product, raw: u.Raw, channel: u.Channel, derived: u.Derived, resample: u.Resample, rollingOperation: u.RollingOperation, signalFilter: u.SignalFilter, sum: u.Sum, scale: u.Scale, timeDifference: u.TimeDifference, absoluteTimestamp: u.AbsoluteTimestamp, timeRangeFilter: u.TimeRangeFilter, timeShift: u.TimeShift, unaryArithmetic: u.UnaryArithmetic, binaryArithmetic: u.BinaryArithmetic, union: u.Union, unitConversion: u.UnitConversion, valueDifference: u.ValueDifference, filterTransformation: u.FilterTransformation, thresholdFilter: u.ThresholdFilter, approximateFilter: u.ApproximateFilter, select1dArrayIndex: u.Select1dArrayIndex, selectNewestPoints: u.SelectNewestPoints, aggregateUnderRanges: u.AggregateUnderRanges, filterByExpression: u.FilterByExpression, enumToNumeric: u.EnumToNumeric, refprop: u.Refprop, extractFromStruct: u.ExtractFromStruct}
}

func (u *NumericSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return nil, fmt.Errorf("field \"aggregate\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			Aggregate AggregateNumericSeries `json:"aggregate"`
		}{Type: "aggregate", Aggregate: *u.aggregate}, nil
	case "arithmetic":
		if u.arithmetic == nil {
			return nil, fmt.Errorf("field \"arithmetic\" is required")
		}
		return struct {
			Type       string           `json:"type"`
			Arithmetic ArithmeticSeries `json:"arithmetic"`
		}{Type: "arithmetic", Arithmetic: *u.arithmetic}, nil
	case "bitOperation":
		if u.bitOperation == nil {
			return nil, fmt.Errorf("field \"bitOperation\" is required")
		}
		return struct {
			Type         string             `json:"type"`
			BitOperation BitOperationSeries `json:"bitOperation"`
		}{Type: "bitOperation", BitOperation: *u.bitOperation}, nil
	case "countDuplicate":
		if u.countDuplicate == nil {
			return nil, fmt.Errorf("field \"countDuplicate\" is required")
		}
		return struct {
			Type           string                   `json:"type"`
			CountDuplicate EnumCountDuplicateSeries `json:"countDuplicate"`
		}{Type: "countDuplicate", CountDuplicate: *u.countDuplicate}, nil
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return nil, fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return struct {
			Type          string              `json:"type"`
			CumulativeSum CumulativeSumSeries `json:"cumulativeSum"`
		}{Type: "cumulativeSum", CumulativeSum: *u.cumulativeSum}, nil
	case "derivative":
		if u.derivative == nil {
			return nil, fmt.Errorf("field \"derivative\" is required")
		}
		return struct {
			Type       string           `json:"type"`
			Derivative DerivativeSeries `json:"derivative"`
		}{Type: "derivative", Derivative: *u.derivative}, nil
	case "integral":
		if u.integral == nil {
			return nil, fmt.Errorf("field \"integral\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			Integral IntegralSeries `json:"integral"`
		}{Type: "integral", Integral: *u.integral}, nil
	case "max":
		if u.max == nil {
			return nil, fmt.Errorf("field \"max\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Max  MaxSeries `json:"max"`
		}{Type: "max", Max: *u.max}, nil
	case "mean":
		if u.mean == nil {
			return nil, fmt.Errorf("field \"mean\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Mean MeanSeries `json:"mean"`
		}{Type: "mean", Mean: *u.mean}, nil
	case "min":
		if u.min == nil {
			return nil, fmt.Errorf("field \"min\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Min  MinSeries `json:"min"`
		}{Type: "min", Min: *u.min}, nil
	case "offset":
		if u.offset == nil {
			return nil, fmt.Errorf("field \"offset\" is required")
		}
		return struct {
			Type   string       `json:"type"`
			Offset OffsetSeries `json:"offset"`
		}{Type: "offset", Offset: *u.offset}, nil
	case "product":
		if u.product == nil {
			return nil, fmt.Errorf("field \"product\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Product ProductSeries `json:"product"`
		}{Type: "product", Product: *u.product}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Channel api.ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	case "resample":
		if u.resample == nil {
			return nil, fmt.Errorf("field \"resample\" is required")
		}
		return struct {
			Type     string                `json:"type"`
			Resample NumericResampleSeries `json:"resample"`
		}{Type: "resample", Resample: *u.resample}, nil
	case "rollingOperation":
		if u.rollingOperation == nil {
			return nil, fmt.Errorf("field \"rollingOperation\" is required")
		}
		return struct {
			Type             string                 `json:"type"`
			RollingOperation RollingOperationSeries `json:"rollingOperation"`
		}{Type: "rollingOperation", RollingOperation: *u.rollingOperation}, nil
	case "signalFilter":
		if u.signalFilter == nil {
			return nil, fmt.Errorf("field \"signalFilter\" is required")
		}
		return struct {
			Type         string             `json:"type"`
			SignalFilter SignalFilterSeries `json:"signalFilter"`
		}{Type: "signalFilter", SignalFilter: *u.signalFilter}, nil
	case "sum":
		if u.sum == nil {
			return nil, fmt.Errorf("field \"sum\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Sum  SumSeries `json:"sum"`
		}{Type: "sum", Sum: *u.sum}, nil
	case "scale":
		if u.scale == nil {
			return nil, fmt.Errorf("field \"scale\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Scale ScaleSeries `json:"scale"`
		}{Type: "scale", Scale: *u.scale}, nil
	case "timeDifference":
		if u.timeDifference == nil {
			return nil, fmt.Errorf("field \"timeDifference\" is required")
		}
		return struct {
			Type           string               `json:"type"`
			TimeDifference TimeDifferenceSeries `json:"timeDifference"`
		}{Type: "timeDifference", TimeDifference: *u.timeDifference}, nil
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return nil, fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return struct {
			Type              string                  `json:"type"`
			AbsoluteTimestamp AbsoluteTimestampSeries `json:"absoluteTimestamp"`
		}{Type: "absoluteTimestamp", AbsoluteTimestamp: *u.absoluteTimestamp}, nil
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return nil, fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return struct {
			Type            string                       `json:"type"`
			TimeRangeFilter NumericTimeRangeFilterSeries `json:"timeRangeFilter"`
		}{Type: "timeRangeFilter", TimeRangeFilter: *u.timeRangeFilter}, nil
	case "timeShift":
		if u.timeShift == nil {
			return nil, fmt.Errorf("field \"timeShift\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			TimeShift NumericTimeShiftSeries `json:"timeShift"`
		}{Type: "timeShift", TimeShift: *u.timeShift}, nil
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return nil, fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return struct {
			Type            string                `json:"type"`
			UnaryArithmetic UnaryArithmeticSeries `json:"unaryArithmetic"`
		}{Type: "unaryArithmetic", UnaryArithmetic: *u.unaryArithmetic}, nil
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return nil, fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return struct {
			Type             string                 `json:"type"`
			BinaryArithmetic BinaryArithmeticSeries `json:"binaryArithmetic"`
		}{Type: "binaryArithmetic", BinaryArithmetic: *u.binaryArithmetic}, nil
	case "union":
		if u.union == nil {
			return nil, fmt.Errorf("field \"union\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Union NumericUnionSeries `json:"union"`
		}{Type: "union", Union: *u.union}, nil
	case "unitConversion":
		if u.unitConversion == nil {
			return nil, fmt.Errorf("field \"unitConversion\" is required")
		}
		return struct {
			Type           string               `json:"type"`
			UnitConversion UnitConversionSeries `json:"unitConversion"`
		}{Type: "unitConversion", UnitConversion: *u.unitConversion}, nil
	case "valueDifference":
		if u.valueDifference == nil {
			return nil, fmt.Errorf("field \"valueDifference\" is required")
		}
		return struct {
			Type            string                `json:"type"`
			ValueDifference ValueDifferenceSeries `json:"valueDifference"`
		}{Type: "valueDifference", ValueDifference: *u.valueDifference}, nil
	case "filterTransformation":
		if u.filterTransformation == nil {
			return nil, fmt.Errorf("field \"filterTransformation\" is required")
		}
		return struct {
			Type                 string                            `json:"type"`
			FilterTransformation NumericFilterTransformationSeries `json:"filterTransformation"`
		}{Type: "filterTransformation", FilterTransformation: *u.filterTransformation}, nil
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return nil, fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return struct {
			Type            string                       `json:"type"`
			ThresholdFilter NumericThresholdFilterSeries `json:"thresholdFilter"`
		}{Type: "thresholdFilter", ThresholdFilter: *u.thresholdFilter}, nil
	case "approximateFilter":
		if u.approximateFilter == nil {
			return nil, fmt.Errorf("field \"approximateFilter\" is required")
		}
		return struct {
			Type              string                         `json:"type"`
			ApproximateFilter NumericApproximateFilterSeries `json:"approximateFilter"`
		}{Type: "approximateFilter", ApproximateFilter: *u.approximateFilter}, nil
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return nil, fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return struct {
			Type               string                              `json:"type"`
			Select1dArrayIndex SelectIndexFrom1dNumericArraySeries `json:"select1dArrayIndex"`
		}{Type: "select1dArrayIndex", Select1dArrayIndex: *u.select1dArrayIndex}, nil
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return nil, fmt.Errorf("field \"selectNewestPoints\" is required")
		}
		return struct {
			Type               string                   `json:"type"`
			SelectNewestPoints SelectNewestPointsSeries `json:"selectNewestPoints"`
		}{Type: "selectNewestPoints", SelectNewestPoints: *u.selectNewestPoints}, nil
	case "aggregateUnderRanges":
		if u.aggregateUnderRanges == nil {
			return nil, fmt.Errorf("field \"aggregateUnderRanges\" is required")
		}
		return struct {
			Type                 string                     `json:"type"`
			AggregateUnderRanges AggregateUnderRangesSeries `json:"aggregateUnderRanges"`
		}{Type: "aggregateUnderRanges", AggregateUnderRanges: *u.aggregateUnderRanges}, nil
	case "filterByExpression":
		if u.filterByExpression == nil {
			return nil, fmt.Errorf("field \"filterByExpression\" is required")
		}
		return struct {
			Type               string                   `json:"type"`
			FilterByExpression FilterByExpressionSeries `json:"filterByExpression"`
		}{Type: "filterByExpression", FilterByExpression: *u.filterByExpression}, nil
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return nil, fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return struct {
			Type          string              `json:"type"`
			EnumToNumeric EnumToNumericSeries `json:"enumToNumeric"`
		}{Type: "enumToNumeric", EnumToNumeric: *u.enumToNumeric}, nil
	case "refprop":
		if u.refprop == nil {
			return nil, fmt.Errorf("field \"refprop\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Refprop RefpropSeries `json:"refprop"`
		}{Type: "refprop", Refprop: *u.refprop}, nil
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return nil, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return struct {
			Type              string                         `json:"type"`
			ExtractFromStruct ExtractNumericFromStructSeries `json:"extractFromStruct"`
		}{Type: "extractFromStruct", ExtractFromStruct: *u.extractFromStruct}, nil
	}
}

func (u NumericSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericSeries) UnmarshalJSON(data []byte) error {
	var deser numericSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
	case "approximateFilter":
		if u.approximateFilter == nil {
			return fmt.Errorf("field \"approximateFilter\" is required")
		}
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return fmt.Errorf("field \"selectNewestPoints\" is required")
		}
	case "aggregateUnderRanges":
		if u.aggregateUnderRanges == nil {
			return fmt.Errorf("field \"aggregateUnderRanges\" is required")
		}
	case "filterByExpression":
		if u.filterByExpression == nil {
			return fmt.Errorf("field \"filterByExpression\" is required")
		}
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return fmt.Errorf("field \"enumToNumeric\" is required")
		}
	case "refprop":
		if u.refprop == nil {
			return fmt.Errorf("field \"refprop\" is required")
		}
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
	}
	return nil
}

func (u NumericSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericSeries) AcceptFuncs(aggregateFunc func(AggregateNumericSeries) error, arithmeticFunc func(ArithmeticSeries) error, bitOperationFunc func(BitOperationSeries) error, countDuplicateFunc func(EnumCountDuplicateSeries) error, cumulativeSumFunc func(CumulativeSumSeries) error, derivativeFunc func(DerivativeSeries) error, integralFunc func(IntegralSeries) error, maxFunc func(MaxSeries) error, meanFunc func(MeanSeries) error, minFunc func(MinSeries) error, offsetFunc func(OffsetSeries) error, productFunc func(ProductSeries) error, rawFunc func(api.Reference) error, channelFunc func(api.ChannelSeries) error, derivedFunc func(DerivedSeries) error, resampleFunc func(NumericResampleSeries) error, rollingOperationFunc func(RollingOperationSeries) error, signalFilterFunc func(SignalFilterSeries) error, sumFunc func(SumSeries) error, scaleFunc func(ScaleSeries) error, timeDifferenceFunc func(TimeDifferenceSeries) error, absoluteTimestampFunc func(AbsoluteTimestampSeries) error, timeRangeFilterFunc func(NumericTimeRangeFilterSeries) error, timeShiftFunc func(NumericTimeShiftSeries) error, unaryArithmeticFunc func(UnaryArithmeticSeries) error, binaryArithmeticFunc func(BinaryArithmeticSeries) error, unionFunc func(NumericUnionSeries) error, unitConversionFunc func(UnitConversionSeries) error, valueDifferenceFunc func(ValueDifferenceSeries) error, filterTransformationFunc func(NumericFilterTransformationSeries) error, thresholdFilterFunc func(NumericThresholdFilterSeries) error, approximateFilterFunc func(NumericApproximateFilterSeries) error, select1dArrayIndexFunc func(SelectIndexFrom1dNumericArraySeries) error, selectNewestPointsFunc func(SelectNewestPointsSeries) error, aggregateUnderRangesFunc func(AggregateUnderRangesSeries) error, filterByExpressionFunc func(FilterByExpressionSeries) error, enumToNumericFunc func(EnumToNumericSeries) error, refpropFunc func(RefpropSeries) error, extractFromStructFunc func(ExtractNumericFromStructSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return aggregateFunc(*u.aggregate)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return arithmeticFunc(*u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return bitOperationFunc(*u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
		return countDuplicateFunc(*u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return cumulativeSumFunc(*u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return derivativeFunc(*u.derivative)
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
		return integralFunc(*u.integral)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return meanFunc(*u.mean)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
		return offsetFunc(*u.offset)
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
		return productFunc(*u.product)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return resampleFunc(*u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return rollingOperationFunc(*u.rollingOperation)
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
		return signalFilterFunc(*u.signalFilter)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return sumFunc(*u.sum)
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
		return scaleFunc(*u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return timeDifferenceFunc(*u.timeDifference)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return absoluteTimestampFunc(*u.absoluteTimestamp)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return timeRangeFilterFunc(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return timeShiftFunc(*u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return unaryArithmeticFunc(*u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return binaryArithmeticFunc(*u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
		return unitConversionFunc(*u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return valueDifferenceFunc(*u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return filterTransformationFunc(*u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return thresholdFilterFunc(*u.thresholdFilter)
	case "approximateFilter":
		if u.approximateFilter == nil {
			return fmt.Errorf("field \"approximateFilter\" is required")
		}
		return approximateFilterFunc(*u.approximateFilter)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return select1dArrayIndexFunc(*u.select1dArrayIndex)
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return fmt.Errorf("field \"selectNewestPoints\" is required")
		}
		return selectNewestPointsFunc(*u.selectNewestPoints)
	case "aggregateUnderRanges":
		if u.aggregateUnderRanges == nil {
			return fmt.Errorf("field \"aggregateUnderRanges\" is required")
		}
		return aggregateUnderRangesFunc(*u.aggregateUnderRanges)
	case "filterByExpression":
		if u.filterByExpression == nil {
			return fmt.Errorf("field \"filterByExpression\" is required")
		}
		return filterByExpressionFunc(*u.filterByExpression)
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return enumToNumericFunc(*u.enumToNumeric)
	case "refprop":
		if u.refprop == nil {
			return fmt.Errorf("field \"refprop\" is required")
		}
		return refpropFunc(*u.refprop)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	}
}

func (u *NumericSeries) AggregateNoopSuccess(AggregateNumericSeries) error {
	return nil
}

func (u *NumericSeries) ArithmeticNoopSuccess(ArithmeticSeries) error {
	return nil
}

func (u *NumericSeries) BitOperationNoopSuccess(BitOperationSeries) error {
	return nil
}

func (u *NumericSeries) CountDuplicateNoopSuccess(EnumCountDuplicateSeries) error {
	return nil
}

func (u *NumericSeries) CumulativeSumNoopSuccess(CumulativeSumSeries) error {
	return nil
}

func (u *NumericSeries) DerivativeNoopSuccess(DerivativeSeries) error {
	return nil
}

func (u *NumericSeries) IntegralNoopSuccess(IntegralSeries) error {
	return nil
}

func (u *NumericSeries) MaxNoopSuccess(MaxSeries) error {
	return nil
}

func (u *NumericSeries) MeanNoopSuccess(MeanSeries) error {
	return nil
}

func (u *NumericSeries) MinNoopSuccess(MinSeries) error {
	return nil
}

func (u *NumericSeries) OffsetNoopSuccess(OffsetSeries) error {
	return nil
}

func (u *NumericSeries) ProductNoopSuccess(ProductSeries) error {
	return nil
}

func (u *NumericSeries) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *NumericSeries) ChannelNoopSuccess(api.ChannelSeries) error {
	return nil
}

func (u *NumericSeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *NumericSeries) ResampleNoopSuccess(NumericResampleSeries) error {
	return nil
}

func (u *NumericSeries) RollingOperationNoopSuccess(RollingOperationSeries) error {
	return nil
}

func (u *NumericSeries) SignalFilterNoopSuccess(SignalFilterSeries) error {
	return nil
}

func (u *NumericSeries) SumNoopSuccess(SumSeries) error {
	return nil
}

func (u *NumericSeries) ScaleNoopSuccess(ScaleSeries) error {
	return nil
}

func (u *NumericSeries) TimeDifferenceNoopSuccess(TimeDifferenceSeries) error {
	return nil
}

func (u *NumericSeries) AbsoluteTimestampNoopSuccess(AbsoluteTimestampSeries) error {
	return nil
}

func (u *NumericSeries) TimeRangeFilterNoopSuccess(NumericTimeRangeFilterSeries) error {
	return nil
}

func (u *NumericSeries) TimeShiftNoopSuccess(NumericTimeShiftSeries) error {
	return nil
}

func (u *NumericSeries) UnaryArithmeticNoopSuccess(UnaryArithmeticSeries) error {
	return nil
}

func (u *NumericSeries) BinaryArithmeticNoopSuccess(BinaryArithmeticSeries) error {
	return nil
}

func (u *NumericSeries) UnionNoopSuccess(NumericUnionSeries) error {
	return nil
}

func (u *NumericSeries) UnitConversionNoopSuccess(UnitConversionSeries) error {
	return nil
}

func (u *NumericSeries) ValueDifferenceNoopSuccess(ValueDifferenceSeries) error {
	return nil
}

func (u *NumericSeries) FilterTransformationNoopSuccess(NumericFilterTransformationSeries) error {
	return nil
}

func (u *NumericSeries) ThresholdFilterNoopSuccess(NumericThresholdFilterSeries) error {
	return nil
}

func (u *NumericSeries) ApproximateFilterNoopSuccess(NumericApproximateFilterSeries) error {
	return nil
}

func (u *NumericSeries) Select1dArrayIndexNoopSuccess(SelectIndexFrom1dNumericArraySeries) error {
	return nil
}

func (u *NumericSeries) SelectNewestPointsNoopSuccess(SelectNewestPointsSeries) error {
	return nil
}

func (u *NumericSeries) AggregateUnderRangesNoopSuccess(AggregateUnderRangesSeries) error {
	return nil
}

func (u *NumericSeries) FilterByExpressionNoopSuccess(FilterByExpressionSeries) error {
	return nil
}

func (u *NumericSeries) EnumToNumericNoopSuccess(EnumToNumericSeries) error {
	return nil
}

func (u *NumericSeries) RefpropNoopSuccess(RefpropSeries) error {
	return nil
}

func (u *NumericSeries) ExtractFromStructNoopSuccess(ExtractNumericFromStructSeries) error {
	return nil
}

func (u *NumericSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericSeries) Accept(v NumericSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregate(*u.aggregate)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return v.VisitArithmetic(*u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return v.VisitBitOperation(*u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
		return v.VisitCountDuplicate(*u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return v.VisitCumulativeSum(*u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return v.VisitDerivative(*u.derivative)
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
		return v.VisitIntegral(*u.integral)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(*u.max)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return v.VisitMean(*u.mean)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(*u.min)
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
		return v.VisitOffset(*u.offset)
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
		return v.VisitProduct(*u.product)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResample(*u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return v.VisitRollingOperation(*u.rollingOperation)
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
		return v.VisitSignalFilter(*u.signalFilter)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSum(*u.sum)
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
		return v.VisitScale(*u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return v.VisitTimeDifference(*u.timeDifference)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return v.VisitAbsoluteTimestamp(*u.absoluteTimestamp)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilter(*u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShift(*u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return v.VisitUnaryArithmetic(*u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return v.VisitBinaryArithmetic(*u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(*u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
		return v.VisitUnitConversion(*u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return v.VisitValueDifference(*u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformation(*u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return v.VisitThresholdFilter(*u.thresholdFilter)
	case "approximateFilter":
		if u.approximateFilter == nil {
			return fmt.Errorf("field \"approximateFilter\" is required")
		}
		return v.VisitApproximateFilter(*u.approximateFilter)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return v.VisitSelect1dArrayIndex(*u.select1dArrayIndex)
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return fmt.Errorf("field \"selectNewestPoints\" is required")
		}
		return v.VisitSelectNewestPoints(*u.selectNewestPoints)
	case "aggregateUnderRanges":
		if u.aggregateUnderRanges == nil {
			return fmt.Errorf("field \"aggregateUnderRanges\" is required")
		}
		return v.VisitAggregateUnderRanges(*u.aggregateUnderRanges)
	case "filterByExpression":
		if u.filterByExpression == nil {
			return fmt.Errorf("field \"filterByExpression\" is required")
		}
		return v.VisitFilterByExpression(*u.filterByExpression)
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return v.VisitEnumToNumeric(*u.enumToNumeric)
	case "refprop":
		if u.refprop == nil {
			return fmt.Errorf("field \"refprop\" is required")
		}
		return v.VisitRefprop(*u.refprop)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(*u.extractFromStruct)
	}
}

type NumericSeriesVisitor interface {
	VisitAggregate(v AggregateNumericSeries) error
	VisitArithmetic(v ArithmeticSeries) error
	VisitBitOperation(v BitOperationSeries) error
	VisitCountDuplicate(v EnumCountDuplicateSeries) error
	VisitCumulativeSum(v CumulativeSumSeries) error
	VisitDerivative(v DerivativeSeries) error
	VisitIntegral(v IntegralSeries) error
	VisitMax(v MaxSeries) error
	VisitMean(v MeanSeries) error
	VisitMin(v MinSeries) error
	VisitOffset(v OffsetSeries) error
	VisitProduct(v ProductSeries) error
	VisitRaw(v api.Reference) error
	VisitChannel(v api.ChannelSeries) error
	VisitDerived(v DerivedSeries) error
	VisitResample(v NumericResampleSeries) error
	VisitRollingOperation(v RollingOperationSeries) error
	VisitSignalFilter(v SignalFilterSeries) error
	VisitSum(v SumSeries) error
	VisitScale(v ScaleSeries) error
	VisitTimeDifference(v TimeDifferenceSeries) error
	VisitAbsoluteTimestamp(v AbsoluteTimestampSeries) error
	VisitTimeRangeFilter(v NumericTimeRangeFilterSeries) error
	VisitTimeShift(v NumericTimeShiftSeries) error
	VisitUnaryArithmetic(v UnaryArithmeticSeries) error
	VisitBinaryArithmetic(v BinaryArithmeticSeries) error
	VisitUnion(v NumericUnionSeries) error
	VisitUnitConversion(v UnitConversionSeries) error
	VisitValueDifference(v ValueDifferenceSeries) error
	VisitFilterTransformation(v NumericFilterTransformationSeries) error
	VisitThresholdFilter(v NumericThresholdFilterSeries) error
	VisitApproximateFilter(v NumericApproximateFilterSeries) error
	VisitSelect1dArrayIndex(v SelectIndexFrom1dNumericArraySeries) error
	VisitSelectNewestPoints(v SelectNewestPointsSeries) error
	VisitAggregateUnderRanges(v AggregateUnderRangesSeries) error
	VisitFilterByExpression(v FilterByExpressionSeries) error
	VisitEnumToNumeric(v EnumToNumericSeries) error
	VisitRefprop(v RefpropSeries) error
	VisitExtractFromStruct(v ExtractNumericFromStructSeries) error
	VisitUnknown(typeName string) error
}

func (u *NumericSeries) AcceptWithContext(ctx context.Context, v NumericSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "aggregate":
		if u.aggregate == nil {
			return fmt.Errorf("field \"aggregate\" is required")
		}
		return v.VisitAggregateWithContext(ctx, *u.aggregate)
	case "arithmetic":
		if u.arithmetic == nil {
			return fmt.Errorf("field \"arithmetic\" is required")
		}
		return v.VisitArithmeticWithContext(ctx, *u.arithmetic)
	case "bitOperation":
		if u.bitOperation == nil {
			return fmt.Errorf("field \"bitOperation\" is required")
		}
		return v.VisitBitOperationWithContext(ctx, *u.bitOperation)
	case "countDuplicate":
		if u.countDuplicate == nil {
			return fmt.Errorf("field \"countDuplicate\" is required")
		}
		return v.VisitCountDuplicateWithContext(ctx, *u.countDuplicate)
	case "cumulativeSum":
		if u.cumulativeSum == nil {
			return fmt.Errorf("field \"cumulativeSum\" is required")
		}
		return v.VisitCumulativeSumWithContext(ctx, *u.cumulativeSum)
	case "derivative":
		if u.derivative == nil {
			return fmt.Errorf("field \"derivative\" is required")
		}
		return v.VisitDerivativeWithContext(ctx, *u.derivative)
	case "integral":
		if u.integral == nil {
			return fmt.Errorf("field \"integral\" is required")
		}
		return v.VisitIntegralWithContext(ctx, *u.integral)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMaxWithContext(ctx, *u.max)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return v.VisitMeanWithContext(ctx, *u.mean)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMinWithContext(ctx, *u.min)
	case "offset":
		if u.offset == nil {
			return fmt.Errorf("field \"offset\" is required")
		}
		return v.VisitOffsetWithContext(ctx, *u.offset)
	case "product":
		if u.product == nil {
			return fmt.Errorf("field \"product\" is required")
		}
		return v.VisitProductWithContext(ctx, *u.product)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	case "resample":
		if u.resample == nil {
			return fmt.Errorf("field \"resample\" is required")
		}
		return v.VisitResampleWithContext(ctx, *u.resample)
	case "rollingOperation":
		if u.rollingOperation == nil {
			return fmt.Errorf("field \"rollingOperation\" is required")
		}
		return v.VisitRollingOperationWithContext(ctx, *u.rollingOperation)
	case "signalFilter":
		if u.signalFilter == nil {
			return fmt.Errorf("field \"signalFilter\" is required")
		}
		return v.VisitSignalFilterWithContext(ctx, *u.signalFilter)
	case "sum":
		if u.sum == nil {
			return fmt.Errorf("field \"sum\" is required")
		}
		return v.VisitSumWithContext(ctx, *u.sum)
	case "scale":
		if u.scale == nil {
			return fmt.Errorf("field \"scale\" is required")
		}
		return v.VisitScaleWithContext(ctx, *u.scale)
	case "timeDifference":
		if u.timeDifference == nil {
			return fmt.Errorf("field \"timeDifference\" is required")
		}
		return v.VisitTimeDifferenceWithContext(ctx, *u.timeDifference)
	case "absoluteTimestamp":
		if u.absoluteTimestamp == nil {
			return fmt.Errorf("field \"absoluteTimestamp\" is required")
		}
		return v.VisitAbsoluteTimestampWithContext(ctx, *u.absoluteTimestamp)
	case "timeRangeFilter":
		if u.timeRangeFilter == nil {
			return fmt.Errorf("field \"timeRangeFilter\" is required")
		}
		return v.VisitTimeRangeFilterWithContext(ctx, *u.timeRangeFilter)
	case "timeShift":
		if u.timeShift == nil {
			return fmt.Errorf("field \"timeShift\" is required")
		}
		return v.VisitTimeShiftWithContext(ctx, *u.timeShift)
	case "unaryArithmetic":
		if u.unaryArithmetic == nil {
			return fmt.Errorf("field \"unaryArithmetic\" is required")
		}
		return v.VisitUnaryArithmeticWithContext(ctx, *u.unaryArithmetic)
	case "binaryArithmetic":
		if u.binaryArithmetic == nil {
			return fmt.Errorf("field \"binaryArithmetic\" is required")
		}
		return v.VisitBinaryArithmeticWithContext(ctx, *u.binaryArithmetic)
	case "union":
		if u.union == nil {
			return fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnionWithContext(ctx, *u.union)
	case "unitConversion":
		if u.unitConversion == nil {
			return fmt.Errorf("field \"unitConversion\" is required")
		}
		return v.VisitUnitConversionWithContext(ctx, *u.unitConversion)
	case "valueDifference":
		if u.valueDifference == nil {
			return fmt.Errorf("field \"valueDifference\" is required")
		}
		return v.VisitValueDifferenceWithContext(ctx, *u.valueDifference)
	case "filterTransformation":
		if u.filterTransformation == nil {
			return fmt.Errorf("field \"filterTransformation\" is required")
		}
		return v.VisitFilterTransformationWithContext(ctx, *u.filterTransformation)
	case "thresholdFilter":
		if u.thresholdFilter == nil {
			return fmt.Errorf("field \"thresholdFilter\" is required")
		}
		return v.VisitThresholdFilterWithContext(ctx, *u.thresholdFilter)
	case "approximateFilter":
		if u.approximateFilter == nil {
			return fmt.Errorf("field \"approximateFilter\" is required")
		}
		return v.VisitApproximateFilterWithContext(ctx, *u.approximateFilter)
	case "select1dArrayIndex":
		if u.select1dArrayIndex == nil {
			return fmt.Errorf("field \"select1dArrayIndex\" is required")
		}
		return v.VisitSelect1dArrayIndexWithContext(ctx, *u.select1dArrayIndex)
	case "selectNewestPoints":
		if u.selectNewestPoints == nil {
			return fmt.Errorf("field \"selectNewestPoints\" is required")
		}
		return v.VisitSelectNewestPointsWithContext(ctx, *u.selectNewestPoints)
	case "aggregateUnderRanges":
		if u.aggregateUnderRanges == nil {
			return fmt.Errorf("field \"aggregateUnderRanges\" is required")
		}
		return v.VisitAggregateUnderRangesWithContext(ctx, *u.aggregateUnderRanges)
	case "filterByExpression":
		if u.filterByExpression == nil {
			return fmt.Errorf("field \"filterByExpression\" is required")
		}
		return v.VisitFilterByExpressionWithContext(ctx, *u.filterByExpression)
	case "enumToNumeric":
		if u.enumToNumeric == nil {
			return fmt.Errorf("field \"enumToNumeric\" is required")
		}
		return v.VisitEnumToNumericWithContext(ctx, *u.enumToNumeric)
	case "refprop":
		if u.refprop == nil {
			return fmt.Errorf("field \"refprop\" is required")
		}
		return v.VisitRefpropWithContext(ctx, *u.refprop)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStructWithContext(ctx, *u.extractFromStruct)
	}
}

type NumericSeriesVisitorWithContext interface {
	VisitAggregateWithContext(ctx context.Context, v AggregateNumericSeries) error
	VisitArithmeticWithContext(ctx context.Context, v ArithmeticSeries) error
	VisitBitOperationWithContext(ctx context.Context, v BitOperationSeries) error
	VisitCountDuplicateWithContext(ctx context.Context, v EnumCountDuplicateSeries) error
	VisitCumulativeSumWithContext(ctx context.Context, v CumulativeSumSeries) error
	VisitDerivativeWithContext(ctx context.Context, v DerivativeSeries) error
	VisitIntegralWithContext(ctx context.Context, v IntegralSeries) error
	VisitMaxWithContext(ctx context.Context, v MaxSeries) error
	VisitMeanWithContext(ctx context.Context, v MeanSeries) error
	VisitMinWithContext(ctx context.Context, v MinSeries) error
	VisitOffsetWithContext(ctx context.Context, v OffsetSeries) error
	VisitProductWithContext(ctx context.Context, v ProductSeries) error
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitChannelWithContext(ctx context.Context, v api.ChannelSeries) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitResampleWithContext(ctx context.Context, v NumericResampleSeries) error
	VisitRollingOperationWithContext(ctx context.Context, v RollingOperationSeries) error
	VisitSignalFilterWithContext(ctx context.Context, v SignalFilterSeries) error
	VisitSumWithContext(ctx context.Context, v SumSeries) error
	VisitScaleWithContext(ctx context.Context, v ScaleSeries) error
	VisitTimeDifferenceWithContext(ctx context.Context, v TimeDifferenceSeries) error
	VisitAbsoluteTimestampWithContext(ctx context.Context, v AbsoluteTimestampSeries) error
	VisitTimeRangeFilterWithContext(ctx context.Context, v NumericTimeRangeFilterSeries) error
	VisitTimeShiftWithContext(ctx context.Context, v NumericTimeShiftSeries) error
	VisitUnaryArithmeticWithContext(ctx context.Context, v UnaryArithmeticSeries) error
	VisitBinaryArithmeticWithContext(ctx context.Context, v BinaryArithmeticSeries) error
	VisitUnionWithContext(ctx context.Context, v NumericUnionSeries) error
	VisitUnitConversionWithContext(ctx context.Context, v UnitConversionSeries) error
	VisitValueDifferenceWithContext(ctx context.Context, v ValueDifferenceSeries) error
	VisitFilterTransformationWithContext(ctx context.Context, v NumericFilterTransformationSeries) error
	VisitThresholdFilterWithContext(ctx context.Context, v NumericThresholdFilterSeries) error
	VisitApproximateFilterWithContext(ctx context.Context, v NumericApproximateFilterSeries) error
	VisitSelect1dArrayIndexWithContext(ctx context.Context, v SelectIndexFrom1dNumericArraySeries) error
	VisitSelectNewestPointsWithContext(ctx context.Context, v SelectNewestPointsSeries) error
	VisitAggregateUnderRangesWithContext(ctx context.Context, v AggregateUnderRangesSeries) error
	VisitFilterByExpressionWithContext(ctx context.Context, v FilterByExpressionSeries) error
	VisitEnumToNumericWithContext(ctx context.Context, v EnumToNumericSeries) error
	VisitRefpropWithContext(ctx context.Context, v RefpropSeries) error
	VisitExtractFromStructWithContext(ctx context.Context, v ExtractNumericFromStructSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericSeriesFromAggregate(v AggregateNumericSeries) NumericSeries {
	return NumericSeries{typ: "aggregate", aggregate: &v}
}

func NewNumericSeriesFromArithmetic(v ArithmeticSeries) NumericSeries {
	return NumericSeries{typ: "arithmetic", arithmetic: &v}
}

func NewNumericSeriesFromBitOperation(v BitOperationSeries) NumericSeries {
	return NumericSeries{typ: "bitOperation", bitOperation: &v}
}

func NewNumericSeriesFromCountDuplicate(v EnumCountDuplicateSeries) NumericSeries {
	return NumericSeries{typ: "countDuplicate", countDuplicate: &v}
}

func NewNumericSeriesFromCumulativeSum(v CumulativeSumSeries) NumericSeries {
	return NumericSeries{typ: "cumulativeSum", cumulativeSum: &v}
}

func NewNumericSeriesFromDerivative(v DerivativeSeries) NumericSeries {
	return NumericSeries{typ: "derivative", derivative: &v}
}

func NewNumericSeriesFromIntegral(v IntegralSeries) NumericSeries {
	return NumericSeries{typ: "integral", integral: &v}
}

func NewNumericSeriesFromMax(v MaxSeries) NumericSeries {
	return NumericSeries{typ: "max", max: &v}
}

func NewNumericSeriesFromMean(v MeanSeries) NumericSeries {
	return NumericSeries{typ: "mean", mean: &v}
}

func NewNumericSeriesFromMin(v MinSeries) NumericSeries {
	return NumericSeries{typ: "min", min: &v}
}

func NewNumericSeriesFromOffset(v OffsetSeries) NumericSeries {
	return NumericSeries{typ: "offset", offset: &v}
}

func NewNumericSeriesFromProduct(v ProductSeries) NumericSeries {
	return NumericSeries{typ: "product", product: &v}
}

func NewNumericSeriesFromRaw(v api.Reference) NumericSeries {
	return NumericSeries{typ: "raw", raw: &v}
}

func NewNumericSeriesFromChannel(v api.ChannelSeries) NumericSeries {
	return NumericSeries{typ: "channel", channel: &v}
}

func NewNumericSeriesFromDerived(v DerivedSeries) NumericSeries {
	return NumericSeries{typ: "derived", derived: &v}
}

func NewNumericSeriesFromResample(v NumericResampleSeries) NumericSeries {
	return NumericSeries{typ: "resample", resample: &v}
}

func NewNumericSeriesFromRollingOperation(v RollingOperationSeries) NumericSeries {
	return NumericSeries{typ: "rollingOperation", rollingOperation: &v}
}

func NewNumericSeriesFromSignalFilter(v SignalFilterSeries) NumericSeries {
	return NumericSeries{typ: "signalFilter", signalFilter: &v}
}

func NewNumericSeriesFromSum(v SumSeries) NumericSeries {
	return NumericSeries{typ: "sum", sum: &v}
}

func NewNumericSeriesFromScale(v ScaleSeries) NumericSeries {
	return NumericSeries{typ: "scale", scale: &v}
}

func NewNumericSeriesFromTimeDifference(v TimeDifferenceSeries) NumericSeries {
	return NumericSeries{typ: "timeDifference", timeDifference: &v}
}

func NewNumericSeriesFromAbsoluteTimestamp(v AbsoluteTimestampSeries) NumericSeries {
	return NumericSeries{typ: "absoluteTimestamp", absoluteTimestamp: &v}
}

func NewNumericSeriesFromTimeRangeFilter(v NumericTimeRangeFilterSeries) NumericSeries {
	return NumericSeries{typ: "timeRangeFilter", timeRangeFilter: &v}
}

func NewNumericSeriesFromTimeShift(v NumericTimeShiftSeries) NumericSeries {
	return NumericSeries{typ: "timeShift", timeShift: &v}
}

func NewNumericSeriesFromUnaryArithmetic(v UnaryArithmeticSeries) NumericSeries {
	return NumericSeries{typ: "unaryArithmetic", unaryArithmetic: &v}
}

func NewNumericSeriesFromBinaryArithmetic(v BinaryArithmeticSeries) NumericSeries {
	return NumericSeries{typ: "binaryArithmetic", binaryArithmetic: &v}
}

func NewNumericSeriesFromUnion(v NumericUnionSeries) NumericSeries {
	return NumericSeries{typ: "union", union: &v}
}

func NewNumericSeriesFromUnitConversion(v UnitConversionSeries) NumericSeries {
	return NumericSeries{typ: "unitConversion", unitConversion: &v}
}

func NewNumericSeriesFromValueDifference(v ValueDifferenceSeries) NumericSeries {
	return NumericSeries{typ: "valueDifference", valueDifference: &v}
}

func NewNumericSeriesFromFilterTransformation(v NumericFilterTransformationSeries) NumericSeries {
	return NumericSeries{typ: "filterTransformation", filterTransformation: &v}
}

func NewNumericSeriesFromThresholdFilter(v NumericThresholdFilterSeries) NumericSeries {
	return NumericSeries{typ: "thresholdFilter", thresholdFilter: &v}
}

func NewNumericSeriesFromApproximateFilter(v NumericApproximateFilterSeries) NumericSeries {
	return NumericSeries{typ: "approximateFilter", approximateFilter: &v}
}

func NewNumericSeriesFromSelect1dArrayIndex(v SelectIndexFrom1dNumericArraySeries) NumericSeries {
	return NumericSeries{typ: "select1dArrayIndex", select1dArrayIndex: &v}
}

func NewNumericSeriesFromSelectNewestPoints(v SelectNewestPointsSeries) NumericSeries {
	return NumericSeries{typ: "selectNewestPoints", selectNewestPoints: &v}
}

func NewNumericSeriesFromAggregateUnderRanges(v AggregateUnderRangesSeries) NumericSeries {
	return NumericSeries{typ: "aggregateUnderRanges", aggregateUnderRanges: &v}
}

func NewNumericSeriesFromFilterByExpression(v FilterByExpressionSeries) NumericSeries {
	return NumericSeries{typ: "filterByExpression", filterByExpression: &v}
}

func NewNumericSeriesFromEnumToNumeric(v EnumToNumericSeries) NumericSeries {
	return NumericSeries{typ: "enumToNumeric", enumToNumeric: &v}
}

func NewNumericSeriesFromRefprop(v RefpropSeries) NumericSeries {
	return NumericSeries{typ: "refprop", refprop: &v}
}

func NewNumericSeriesFromExtractFromStruct(v ExtractNumericFromStructSeries) NumericSeries {
	return NumericSeries{typ: "extractFromStruct", extractFromStruct: &v}
}

type RangeSeries struct {
	typ                          string
	approximateThreshold         *ApproximateThresholdRanges
	durationFilter               *DurationFilterRanges
	enumFilter                   *EnumFilterRanges
	enumSeriesEqualityRangesNode *EnumSeriesEqualityRanges
	eventsSearch                 *EventsSearchRanges
	intersectRange               *IntersectRanges
	literalRanges                *api.LiteralRanges
	minMaxThreshold              *MinMaxThresholdRanges
	not                          *NotRanges
	onChange                     *OnChangeRanges
	peak                         *PeakRanges
	rangeNumericAggregation      *RangesNumericAggregation
	raw                          *api.Reference
	derived                      *DerivedSeries
	seriesCrossoverRangesNode    *SeriesCrossoverRanges
	seriesEqualityRangesNode     *SeriesEqualityRanges
	stabilityDetection           *StabilityDetectionRanges
	staleRange                   *StaleRanges
	threshold                    *ThresholdingRanges
	unionRange                   *UnionRanges
	paddedRanges                 *PaddedRanges
}

type rangeSeriesDeserializer struct {
	Type                         string                      `json:"type"`
	ApproximateThreshold         *ApproximateThresholdRanges `json:"approximateThreshold"`
	DurationFilter               *DurationFilterRanges       `json:"durationFilter"`
	EnumFilter                   *EnumFilterRanges           `json:"enumFilter"`
	EnumSeriesEqualityRangesNode *EnumSeriesEqualityRanges   `json:"enumSeriesEqualityRangesNode"`
	EventsSearch                 *EventsSearchRanges         `json:"eventsSearch"`
	IntersectRange               *IntersectRanges            `json:"intersectRange"`
	LiteralRanges                *api.LiteralRanges          `json:"literalRanges"`
	MinMaxThreshold              *MinMaxThresholdRanges      `json:"minMaxThreshold"`
	Not                          *NotRanges                  `json:"not"`
	OnChange                     *OnChangeRanges             `json:"onChange"`
	Peak                         *PeakRanges                 `json:"peak"`
	RangeNumericAggregation      *RangesNumericAggregation   `json:"rangeNumericAggregation"`
	Raw                          *api.Reference              `json:"raw"`
	Derived                      *DerivedSeries              `json:"derived"`
	SeriesCrossoverRangesNode    *SeriesCrossoverRanges      `json:"seriesCrossoverRangesNode"`
	SeriesEqualityRangesNode     *SeriesEqualityRanges       `json:"seriesEqualityRangesNode"`
	StabilityDetection           *StabilityDetectionRanges   `json:"stabilityDetection"`
	StaleRange                   *StaleRanges                `json:"staleRange"`
	Threshold                    *ThresholdingRanges         `json:"threshold"`
	UnionRange                   *UnionRanges                `json:"unionRange"`
	PaddedRanges                 *PaddedRanges               `json:"paddedRanges"`
}

func (u *rangeSeriesDeserializer) toStruct() RangeSeries {
	return RangeSeries{typ: u.Type, approximateThreshold: u.ApproximateThreshold, durationFilter: u.DurationFilter, enumFilter: u.EnumFilter, enumSeriesEqualityRangesNode: u.EnumSeriesEqualityRangesNode, eventsSearch: u.EventsSearch, intersectRange: u.IntersectRange, literalRanges: u.LiteralRanges, minMaxThreshold: u.MinMaxThreshold, not: u.Not, onChange: u.OnChange, peak: u.Peak, rangeNumericAggregation: u.RangeNumericAggregation, raw: u.Raw, derived: u.Derived, seriesCrossoverRangesNode: u.SeriesCrossoverRangesNode, seriesEqualityRangesNode: u.SeriesEqualityRangesNode, stabilityDetection: u.StabilityDetection, staleRange: u.StaleRange, threshold: u.Threshold, unionRange: u.UnionRange, paddedRanges: u.PaddedRanges}
}

func (u *RangeSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return nil, fmt.Errorf("field \"approximateThreshold\" is required")
		}
		return struct {
			Type                 string                     `json:"type"`
			ApproximateThreshold ApproximateThresholdRanges `json:"approximateThreshold"`
		}{Type: "approximateThreshold", ApproximateThreshold: *u.approximateThreshold}, nil
	case "durationFilter":
		if u.durationFilter == nil {
			return nil, fmt.Errorf("field \"durationFilter\" is required")
		}
		return struct {
			Type           string               `json:"type"`
			DurationFilter DurationFilterRanges `json:"durationFilter"`
		}{Type: "durationFilter", DurationFilter: *u.durationFilter}, nil
	case "enumFilter":
		if u.enumFilter == nil {
			return nil, fmt.Errorf("field \"enumFilter\" is required")
		}
		return struct {
			Type       string           `json:"type"`
			EnumFilter EnumFilterRanges `json:"enumFilter"`
		}{Type: "enumFilter", EnumFilter: *u.enumFilter}, nil
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return nil, fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
		return struct {
			Type                         string                   `json:"type"`
			EnumSeriesEqualityRangesNode EnumSeriesEqualityRanges `json:"enumSeriesEqualityRangesNode"`
		}{Type: "enumSeriesEqualityRangesNode", EnumSeriesEqualityRangesNode: *u.enumSeriesEqualityRangesNode}, nil
	case "eventsSearch":
		if u.eventsSearch == nil {
			return nil, fmt.Errorf("field \"eventsSearch\" is required")
		}
		return struct {
			Type         string             `json:"type"`
			EventsSearch EventsSearchRanges `json:"eventsSearch"`
		}{Type: "eventsSearch", EventsSearch: *u.eventsSearch}, nil
	case "intersectRange":
		if u.intersectRange == nil {
			return nil, fmt.Errorf("field \"intersectRange\" is required")
		}
		return struct {
			Type           string          `json:"type"`
			IntersectRange IntersectRanges `json:"intersectRange"`
		}{Type: "intersectRange", IntersectRange: *u.intersectRange}, nil
	case "literalRanges":
		if u.literalRanges == nil {
			return nil, fmt.Errorf("field \"literalRanges\" is required")
		}
		return struct {
			Type          string            `json:"type"`
			LiteralRanges api.LiteralRanges `json:"literalRanges"`
		}{Type: "literalRanges", LiteralRanges: *u.literalRanges}, nil
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return nil, fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return struct {
			Type            string                `json:"type"`
			MinMaxThreshold MinMaxThresholdRanges `json:"minMaxThreshold"`
		}{Type: "minMaxThreshold", MinMaxThreshold: *u.minMaxThreshold}, nil
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Not  NotRanges `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	case "onChange":
		if u.onChange == nil {
			return nil, fmt.Errorf("field \"onChange\" is required")
		}
		return struct {
			Type     string         `json:"type"`
			OnChange OnChangeRanges `json:"onChange"`
		}{Type: "onChange", OnChange: *u.onChange}, nil
	case "peak":
		if u.peak == nil {
			return nil, fmt.Errorf("field \"peak\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Peak PeakRanges `json:"peak"`
		}{Type: "peak", Peak: *u.peak}, nil
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return nil, fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return struct {
			Type                    string                   `json:"type"`
			RangeNumericAggregation RangesNumericAggregation `json:"rangeNumericAggregation"`
		}{Type: "rangeNumericAggregation", RangeNumericAggregation: *u.rangeNumericAggregation}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return nil, fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return struct {
			Type                      string                `json:"type"`
			SeriesCrossoverRangesNode SeriesCrossoverRanges `json:"seriesCrossoverRangesNode"`
		}{Type: "seriesCrossoverRangesNode", SeriesCrossoverRangesNode: *u.seriesCrossoverRangesNode}, nil
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return nil, fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
		return struct {
			Type                     string               `json:"type"`
			SeriesEqualityRangesNode SeriesEqualityRanges `json:"seriesEqualityRangesNode"`
		}{Type: "seriesEqualityRangesNode", SeriesEqualityRangesNode: *u.seriesEqualityRangesNode}, nil
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return nil, fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return struct {
			Type               string                   `json:"type"`
			StabilityDetection StabilityDetectionRanges `json:"stabilityDetection"`
		}{Type: "stabilityDetection", StabilityDetection: *u.stabilityDetection}, nil
	case "staleRange":
		if u.staleRange == nil {
			return nil, fmt.Errorf("field \"staleRange\" is required")
		}
		return struct {
			Type       string      `json:"type"`
			StaleRange StaleRanges `json:"staleRange"`
		}{Type: "staleRange", StaleRange: *u.staleRange}, nil
	case "threshold":
		if u.threshold == nil {
			return nil, fmt.Errorf("field \"threshold\" is required")
		}
		return struct {
			Type      string             `json:"type"`
			Threshold ThresholdingRanges `json:"threshold"`
		}{Type: "threshold", Threshold: *u.threshold}, nil
	case "unionRange":
		if u.unionRange == nil {
			return nil, fmt.Errorf("field \"unionRange\" is required")
		}
		return struct {
			Type       string      `json:"type"`
			UnionRange UnionRanges `json:"unionRange"`
		}{Type: "unionRange", UnionRange: *u.unionRange}, nil
	case "paddedRanges":
		if u.paddedRanges == nil {
			return nil, fmt.Errorf("field \"paddedRanges\" is required")
		}
		return struct {
			Type         string       `json:"type"`
			PaddedRanges PaddedRanges `json:"paddedRanges"`
		}{Type: "paddedRanges", PaddedRanges: *u.paddedRanges}, nil
	}
}

func (u RangeSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangeSeries) UnmarshalJSON(data []byte) error {
	var deser rangeSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return fmt.Errorf("field \"approximateThreshold\" is required")
		}
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
	case "eventsSearch":
		if u.eventsSearch == nil {
			return fmt.Errorf("field \"eventsSearch\" is required")
		}
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
	case "peak":
		if u.peak == nil {
			return fmt.Errorf("field \"peak\" is required")
		}
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
	case "paddedRanges":
		if u.paddedRanges == nil {
			return fmt.Errorf("field \"paddedRanges\" is required")
		}
	}
	return nil
}

func (u RangeSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangeSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangeSeries) AcceptFuncs(approximateThresholdFunc func(ApproximateThresholdRanges) error, durationFilterFunc func(DurationFilterRanges) error, enumFilterFunc func(EnumFilterRanges) error, enumSeriesEqualityRangesNodeFunc func(EnumSeriesEqualityRanges) error, eventsSearchFunc func(EventsSearchRanges) error, intersectRangeFunc func(IntersectRanges) error, literalRangesFunc func(api.LiteralRanges) error, minMaxThresholdFunc func(MinMaxThresholdRanges) error, notFunc func(NotRanges) error, onChangeFunc func(OnChangeRanges) error, peakFunc func(PeakRanges) error, rangeNumericAggregationFunc func(RangesNumericAggregation) error, rawFunc func(api.Reference) error, derivedFunc func(DerivedSeries) error, seriesCrossoverRangesNodeFunc func(SeriesCrossoverRanges) error, seriesEqualityRangesNodeFunc func(SeriesEqualityRanges) error, stabilityDetectionFunc func(StabilityDetectionRanges) error, staleRangeFunc func(StaleRanges) error, thresholdFunc func(ThresholdingRanges) error, unionRangeFunc func(UnionRanges) error, paddedRangesFunc func(PaddedRanges) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return fmt.Errorf("field \"approximateThreshold\" is required")
		}
		return approximateThresholdFunc(*u.approximateThreshold)
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
		return durationFilterFunc(*u.durationFilter)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return enumFilterFunc(*u.enumFilter)
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
		return enumSeriesEqualityRangesNodeFunc(*u.enumSeriesEqualityRangesNode)
	case "eventsSearch":
		if u.eventsSearch == nil {
			return fmt.Errorf("field \"eventsSearch\" is required")
		}
		return eventsSearchFunc(*u.eventsSearch)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return intersectRangeFunc(*u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
		return literalRangesFunc(*u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return minMaxThresholdFunc(*u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return onChangeFunc(*u.onChange)
	case "peak":
		if u.peak == nil {
			return fmt.Errorf("field \"peak\" is required")
		}
		return peakFunc(*u.peak)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return rangeNumericAggregationFunc(*u.rangeNumericAggregation)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return seriesCrossoverRangesNodeFunc(*u.seriesCrossoverRangesNode)
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
		return seriesEqualityRangesNodeFunc(*u.seriesEqualityRangesNode)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return stabilityDetectionFunc(*u.stabilityDetection)
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
		return staleRangeFunc(*u.staleRange)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return thresholdFunc(*u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return unionRangeFunc(*u.unionRange)
	case "paddedRanges":
		if u.paddedRanges == nil {
			return fmt.Errorf("field \"paddedRanges\" is required")
		}
		return paddedRangesFunc(*u.paddedRanges)
	}
}

func (u *RangeSeries) ApproximateThresholdNoopSuccess(ApproximateThresholdRanges) error {
	return nil
}

func (u *RangeSeries) DurationFilterNoopSuccess(DurationFilterRanges) error {
	return nil
}

func (u *RangeSeries) EnumFilterNoopSuccess(EnumFilterRanges) error {
	return nil
}

func (u *RangeSeries) EnumSeriesEqualityRangesNodeNoopSuccess(EnumSeriesEqualityRanges) error {
	return nil
}

func (u *RangeSeries) EventsSearchNoopSuccess(EventsSearchRanges) error {
	return nil
}

func (u *RangeSeries) IntersectRangeNoopSuccess(IntersectRanges) error {
	return nil
}

func (u *RangeSeries) LiteralRangesNoopSuccess(api.LiteralRanges) error {
	return nil
}

func (u *RangeSeries) MinMaxThresholdNoopSuccess(MinMaxThresholdRanges) error {
	return nil
}

func (u *RangeSeries) NotNoopSuccess(NotRanges) error {
	return nil
}

func (u *RangeSeries) OnChangeNoopSuccess(OnChangeRanges) error {
	return nil
}

func (u *RangeSeries) PeakNoopSuccess(PeakRanges) error {
	return nil
}

func (u *RangeSeries) RangeNumericAggregationNoopSuccess(RangesNumericAggregation) error {
	return nil
}

func (u *RangeSeries) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *RangeSeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *RangeSeries) SeriesCrossoverRangesNodeNoopSuccess(SeriesCrossoverRanges) error {
	return nil
}

func (u *RangeSeries) SeriesEqualityRangesNodeNoopSuccess(SeriesEqualityRanges) error {
	return nil
}

func (u *RangeSeries) StabilityDetectionNoopSuccess(StabilityDetectionRanges) error {
	return nil
}

func (u *RangeSeries) StaleRangeNoopSuccess(StaleRanges) error {
	return nil
}

func (u *RangeSeries) ThresholdNoopSuccess(ThresholdingRanges) error {
	return nil
}

func (u *RangeSeries) UnionRangeNoopSuccess(UnionRanges) error {
	return nil
}

func (u *RangeSeries) PaddedRangesNoopSuccess(PaddedRanges) error {
	return nil
}

func (u *RangeSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangeSeries) Accept(v RangeSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return fmt.Errorf("field \"approximateThreshold\" is required")
		}
		return v.VisitApproximateThreshold(*u.approximateThreshold)
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
		return v.VisitDurationFilter(*u.durationFilter)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return v.VisitEnumFilter(*u.enumFilter)
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
		return v.VisitEnumSeriesEqualityRangesNode(*u.enumSeriesEqualityRangesNode)
	case "eventsSearch":
		if u.eventsSearch == nil {
			return fmt.Errorf("field \"eventsSearch\" is required")
		}
		return v.VisitEventsSearch(*u.eventsSearch)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return v.VisitIntersectRange(*u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
		return v.VisitLiteralRanges(*u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return v.VisitMinMaxThreshold(*u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return v.VisitOnChange(*u.onChange)
	case "peak":
		if u.peak == nil {
			return fmt.Errorf("field \"peak\" is required")
		}
		return v.VisitPeak(*u.peak)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return v.VisitRangeNumericAggregation(*u.rangeNumericAggregation)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return v.VisitSeriesCrossoverRangesNode(*u.seriesCrossoverRangesNode)
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
		return v.VisitSeriesEqualityRangesNode(*u.seriesEqualityRangesNode)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return v.VisitStabilityDetection(*u.stabilityDetection)
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
		return v.VisitStaleRange(*u.staleRange)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThreshold(*u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return v.VisitUnionRange(*u.unionRange)
	case "paddedRanges":
		if u.paddedRanges == nil {
			return fmt.Errorf("field \"paddedRanges\" is required")
		}
		return v.VisitPaddedRanges(*u.paddedRanges)
	}
}

type RangeSeriesVisitor interface {
	VisitApproximateThreshold(v ApproximateThresholdRanges) error
	VisitDurationFilter(v DurationFilterRanges) error
	VisitEnumFilter(v EnumFilterRanges) error
	VisitEnumSeriesEqualityRangesNode(v EnumSeriesEqualityRanges) error
	VisitEventsSearch(v EventsSearchRanges) error
	VisitIntersectRange(v IntersectRanges) error
	VisitLiteralRanges(v api.LiteralRanges) error
	VisitMinMaxThreshold(v MinMaxThresholdRanges) error
	VisitNot(v NotRanges) error
	VisitOnChange(v OnChangeRanges) error
	VisitPeak(v PeakRanges) error
	VisitRangeNumericAggregation(v RangesNumericAggregation) error
	VisitRaw(v api.Reference) error
	VisitDerived(v DerivedSeries) error
	VisitSeriesCrossoverRangesNode(v SeriesCrossoverRanges) error
	VisitSeriesEqualityRangesNode(v SeriesEqualityRanges) error
	VisitStabilityDetection(v StabilityDetectionRanges) error
	VisitStaleRange(v StaleRanges) error
	VisitThreshold(v ThresholdingRanges) error
	VisitUnionRange(v UnionRanges) error
	VisitPaddedRanges(v PaddedRanges) error
	VisitUnknown(typeName string) error
}

func (u *RangeSeries) AcceptWithContext(ctx context.Context, v RangeSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "approximateThreshold":
		if u.approximateThreshold == nil {
			return fmt.Errorf("field \"approximateThreshold\" is required")
		}
		return v.VisitApproximateThresholdWithContext(ctx, *u.approximateThreshold)
	case "durationFilter":
		if u.durationFilter == nil {
			return fmt.Errorf("field \"durationFilter\" is required")
		}
		return v.VisitDurationFilterWithContext(ctx, *u.durationFilter)
	case "enumFilter":
		if u.enumFilter == nil {
			return fmt.Errorf("field \"enumFilter\" is required")
		}
		return v.VisitEnumFilterWithContext(ctx, *u.enumFilter)
	case "enumSeriesEqualityRangesNode":
		if u.enumSeriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"enumSeriesEqualityRangesNode\" is required")
		}
		return v.VisitEnumSeriesEqualityRangesNodeWithContext(ctx, *u.enumSeriesEqualityRangesNode)
	case "eventsSearch":
		if u.eventsSearch == nil {
			return fmt.Errorf("field \"eventsSearch\" is required")
		}
		return v.VisitEventsSearchWithContext(ctx, *u.eventsSearch)
	case "intersectRange":
		if u.intersectRange == nil {
			return fmt.Errorf("field \"intersectRange\" is required")
		}
		return v.VisitIntersectRangeWithContext(ctx, *u.intersectRange)
	case "literalRanges":
		if u.literalRanges == nil {
			return fmt.Errorf("field \"literalRanges\" is required")
		}
		return v.VisitLiteralRangesWithContext(ctx, *u.literalRanges)
	case "minMaxThreshold":
		if u.minMaxThreshold == nil {
			return fmt.Errorf("field \"minMaxThreshold\" is required")
		}
		return v.VisitMinMaxThresholdWithContext(ctx, *u.minMaxThreshold)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	case "onChange":
		if u.onChange == nil {
			return fmt.Errorf("field \"onChange\" is required")
		}
		return v.VisitOnChangeWithContext(ctx, *u.onChange)
	case "peak":
		if u.peak == nil {
			return fmt.Errorf("field \"peak\" is required")
		}
		return v.VisitPeakWithContext(ctx, *u.peak)
	case "rangeNumericAggregation":
		if u.rangeNumericAggregation == nil {
			return fmt.Errorf("field \"rangeNumericAggregation\" is required")
		}
		return v.VisitRangeNumericAggregationWithContext(ctx, *u.rangeNumericAggregation)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	case "seriesCrossoverRangesNode":
		if u.seriesCrossoverRangesNode == nil {
			return fmt.Errorf("field \"seriesCrossoverRangesNode\" is required")
		}
		return v.VisitSeriesCrossoverRangesNodeWithContext(ctx, *u.seriesCrossoverRangesNode)
	case "seriesEqualityRangesNode":
		if u.seriesEqualityRangesNode == nil {
			return fmt.Errorf("field \"seriesEqualityRangesNode\" is required")
		}
		return v.VisitSeriesEqualityRangesNodeWithContext(ctx, *u.seriesEqualityRangesNode)
	case "stabilityDetection":
		if u.stabilityDetection == nil {
			return fmt.Errorf("field \"stabilityDetection\" is required")
		}
		return v.VisitStabilityDetectionWithContext(ctx, *u.stabilityDetection)
	case "staleRange":
		if u.staleRange == nil {
			return fmt.Errorf("field \"staleRange\" is required")
		}
		return v.VisitStaleRangeWithContext(ctx, *u.staleRange)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThresholdWithContext(ctx, *u.threshold)
	case "unionRange":
		if u.unionRange == nil {
			return fmt.Errorf("field \"unionRange\" is required")
		}
		return v.VisitUnionRangeWithContext(ctx, *u.unionRange)
	case "paddedRanges":
		if u.paddedRanges == nil {
			return fmt.Errorf("field \"paddedRanges\" is required")
		}
		return v.VisitPaddedRangesWithContext(ctx, *u.paddedRanges)
	}
}

type RangeSeriesVisitorWithContext interface {
	VisitApproximateThresholdWithContext(ctx context.Context, v ApproximateThresholdRanges) error
	VisitDurationFilterWithContext(ctx context.Context, v DurationFilterRanges) error
	VisitEnumFilterWithContext(ctx context.Context, v EnumFilterRanges) error
	VisitEnumSeriesEqualityRangesNodeWithContext(ctx context.Context, v EnumSeriesEqualityRanges) error
	VisitEventsSearchWithContext(ctx context.Context, v EventsSearchRanges) error
	VisitIntersectRangeWithContext(ctx context.Context, v IntersectRanges) error
	VisitLiteralRangesWithContext(ctx context.Context, v api.LiteralRanges) error
	VisitMinMaxThresholdWithContext(ctx context.Context, v MinMaxThresholdRanges) error
	VisitNotWithContext(ctx context.Context, v NotRanges) error
	VisitOnChangeWithContext(ctx context.Context, v OnChangeRanges) error
	VisitPeakWithContext(ctx context.Context, v PeakRanges) error
	VisitRangeNumericAggregationWithContext(ctx context.Context, v RangesNumericAggregation) error
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitSeriesCrossoverRangesNodeWithContext(ctx context.Context, v SeriesCrossoverRanges) error
	VisitSeriesEqualityRangesNodeWithContext(ctx context.Context, v SeriesEqualityRanges) error
	VisitStabilityDetectionWithContext(ctx context.Context, v StabilityDetectionRanges) error
	VisitStaleRangeWithContext(ctx context.Context, v StaleRanges) error
	VisitThresholdWithContext(ctx context.Context, v ThresholdingRanges) error
	VisitUnionRangeWithContext(ctx context.Context, v UnionRanges) error
	VisitPaddedRangesWithContext(ctx context.Context, v PaddedRanges) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangeSeriesFromApproximateThreshold(v ApproximateThresholdRanges) RangeSeries {
	return RangeSeries{typ: "approximateThreshold", approximateThreshold: &v}
}

func NewRangeSeriesFromDurationFilter(v DurationFilterRanges) RangeSeries {
	return RangeSeries{typ: "durationFilter", durationFilter: &v}
}

func NewRangeSeriesFromEnumFilter(v EnumFilterRanges) RangeSeries {
	return RangeSeries{typ: "enumFilter", enumFilter: &v}
}

func NewRangeSeriesFromEnumSeriesEqualityRangesNode(v EnumSeriesEqualityRanges) RangeSeries {
	return RangeSeries{typ: "enumSeriesEqualityRangesNode", enumSeriesEqualityRangesNode: &v}
}

func NewRangeSeriesFromEventsSearch(v EventsSearchRanges) RangeSeries {
	return RangeSeries{typ: "eventsSearch", eventsSearch: &v}
}

func NewRangeSeriesFromIntersectRange(v IntersectRanges) RangeSeries {
	return RangeSeries{typ: "intersectRange", intersectRange: &v}
}

func NewRangeSeriesFromLiteralRanges(v api.LiteralRanges) RangeSeries {
	return RangeSeries{typ: "literalRanges", literalRanges: &v}
}

func NewRangeSeriesFromMinMaxThreshold(v MinMaxThresholdRanges) RangeSeries {
	return RangeSeries{typ: "minMaxThreshold", minMaxThreshold: &v}
}

func NewRangeSeriesFromNot(v NotRanges) RangeSeries {
	return RangeSeries{typ: "not", not: &v}
}

func NewRangeSeriesFromOnChange(v OnChangeRanges) RangeSeries {
	return RangeSeries{typ: "onChange", onChange: &v}
}

func NewRangeSeriesFromPeak(v PeakRanges) RangeSeries {
	return RangeSeries{typ: "peak", peak: &v}
}

func NewRangeSeriesFromRangeNumericAggregation(v RangesNumericAggregation) RangeSeries {
	return RangeSeries{typ: "rangeNumericAggregation", rangeNumericAggregation: &v}
}

func NewRangeSeriesFromRaw(v api.Reference) RangeSeries {
	return RangeSeries{typ: "raw", raw: &v}
}

func NewRangeSeriesFromDerived(v DerivedSeries) RangeSeries {
	return RangeSeries{typ: "derived", derived: &v}
}

func NewRangeSeriesFromSeriesCrossoverRangesNode(v SeriesCrossoverRanges) RangeSeries {
	return RangeSeries{typ: "seriesCrossoverRangesNode", seriesCrossoverRangesNode: &v}
}

func NewRangeSeriesFromSeriesEqualityRangesNode(v SeriesEqualityRanges) RangeSeries {
	return RangeSeries{typ: "seriesEqualityRangesNode", seriesEqualityRangesNode: &v}
}

func NewRangeSeriesFromStabilityDetection(v StabilityDetectionRanges) RangeSeries {
	return RangeSeries{typ: "stabilityDetection", stabilityDetection: &v}
}

func NewRangeSeriesFromStaleRange(v StaleRanges) RangeSeries {
	return RangeSeries{typ: "staleRange", staleRange: &v}
}

func NewRangeSeriesFromThreshold(v ThresholdingRanges) RangeSeries {
	return RangeSeries{typ: "threshold", threshold: &v}
}

func NewRangeSeriesFromUnionRange(v UnionRanges) RangeSeries {
	return RangeSeries{typ: "unionRange", unionRange: &v}
}

func NewRangeSeriesFromPaddedRanges(v PaddedRanges) RangeSeries {
	return RangeSeries{typ: "paddedRanges", paddedRanges: &v}
}

type SelectValue struct {
	typ             string
	firstPoint      *Series
	firstValuePoint *Series
	firstRange      *RangeSeries
	lastPoint       *Series
	lastValuePoint  *Series
	lastRange       *RangeSeries
}

type selectValueDeserializer struct {
	Type            string       `json:"type"`
	FirstPoint      *Series      `json:"firstPoint"`
	FirstValuePoint *Series      `json:"firstValuePoint"`
	FirstRange      *RangeSeries `json:"firstRange"`
	LastPoint       *Series      `json:"lastPoint"`
	LastValuePoint  *Series      `json:"lastValuePoint"`
	LastRange       *RangeSeries `json:"lastRange"`
}

func (u *selectValueDeserializer) toStruct() SelectValue {
	return SelectValue{typ: u.Type, firstPoint: u.FirstPoint, firstValuePoint: u.FirstValuePoint, firstRange: u.FirstRange, lastPoint: u.LastPoint, lastValuePoint: u.LastValuePoint, lastRange: u.LastRange}
}

func (u *SelectValue) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return nil, fmt.Errorf("field \"firstPoint\" is required")
		}
		return struct {
			Type       string `json:"type"`
			FirstPoint Series `json:"firstPoint"`
		}{Type: "firstPoint", FirstPoint: *u.firstPoint}, nil
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return nil, fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return struct {
			Type            string `json:"type"`
			FirstValuePoint Series `json:"firstValuePoint"`
		}{Type: "firstValuePoint", FirstValuePoint: *u.firstValuePoint}, nil
	case "firstRange":
		if u.firstRange == nil {
			return nil, fmt.Errorf("field \"firstRange\" is required")
		}
		return struct {
			Type       string      `json:"type"`
			FirstRange RangeSeries `json:"firstRange"`
		}{Type: "firstRange", FirstRange: *u.firstRange}, nil
	case "lastPoint":
		if u.lastPoint == nil {
			return nil, fmt.Errorf("field \"lastPoint\" is required")
		}
		return struct {
			Type      string `json:"type"`
			LastPoint Series `json:"lastPoint"`
		}{Type: "lastPoint", LastPoint: *u.lastPoint}, nil
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return nil, fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return struct {
			Type           string `json:"type"`
			LastValuePoint Series `json:"lastValuePoint"`
		}{Type: "lastValuePoint", LastValuePoint: *u.lastValuePoint}, nil
	case "lastRange":
		if u.lastRange == nil {
			return nil, fmt.Errorf("field \"lastRange\" is required")
		}
		return struct {
			Type      string      `json:"type"`
			LastRange RangeSeries `json:"lastRange"`
		}{Type: "lastRange", LastRange: *u.lastRange}, nil
	}
}

func (u SelectValue) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SelectValue) UnmarshalJSON(data []byte) error {
	var deser selectValueDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return fmt.Errorf("field \"firstValuePoint\" is required")
		}
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return fmt.Errorf("field \"lastValuePoint\" is required")
		}
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
	}
	return nil
}

func (u SelectValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SelectValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SelectValue) AcceptFuncs(firstPointFunc func(Series) error, firstValuePointFunc func(Series) error, firstRangeFunc func(RangeSeries) error, lastPointFunc func(Series) error, lastValuePointFunc func(Series) error, lastRangeFunc func(RangeSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return firstPointFunc(*u.firstPoint)
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return firstValuePointFunc(*u.firstValuePoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return firstRangeFunc(*u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
		return lastPointFunc(*u.lastPoint)
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return lastValuePointFunc(*u.lastValuePoint)
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
		return lastRangeFunc(*u.lastRange)
	}
}

func (u *SelectValue) FirstPointNoopSuccess(Series) error {
	return nil
}

func (u *SelectValue) FirstValuePointNoopSuccess(Series) error {
	return nil
}

func (u *SelectValue) FirstRangeNoopSuccess(RangeSeries) error {
	return nil
}

func (u *SelectValue) LastPointNoopSuccess(Series) error {
	return nil
}

func (u *SelectValue) LastValuePointNoopSuccess(Series) error {
	return nil
}

func (u *SelectValue) LastRangeNoopSuccess(RangeSeries) error {
	return nil
}

func (u *SelectValue) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SelectValue) Accept(v SelectValueVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return v.VisitFirstPoint(*u.firstPoint)
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return v.VisitFirstValuePoint(*u.firstValuePoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return v.VisitFirstRange(*u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
		return v.VisitLastPoint(*u.lastPoint)
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return v.VisitLastValuePoint(*u.lastValuePoint)
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
		return v.VisitLastRange(*u.lastRange)
	}
}

type SelectValueVisitor interface {
	VisitFirstPoint(v Series) error
	VisitFirstValuePoint(v Series) error
	VisitFirstRange(v RangeSeries) error
	VisitLastPoint(v Series) error
	VisitLastValuePoint(v Series) error
	VisitLastRange(v RangeSeries) error
	VisitUnknown(typeName string) error
}

func (u *SelectValue) AcceptWithContext(ctx context.Context, v SelectValueVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "firstPoint":
		if u.firstPoint == nil {
			return fmt.Errorf("field \"firstPoint\" is required")
		}
		return v.VisitFirstPointWithContext(ctx, *u.firstPoint)
	case "firstValuePoint":
		if u.firstValuePoint == nil {
			return fmt.Errorf("field \"firstValuePoint\" is required")
		}
		return v.VisitFirstValuePointWithContext(ctx, *u.firstValuePoint)
	case "firstRange":
		if u.firstRange == nil {
			return fmt.Errorf("field \"firstRange\" is required")
		}
		return v.VisitFirstRangeWithContext(ctx, *u.firstRange)
	case "lastPoint":
		if u.lastPoint == nil {
			return fmt.Errorf("field \"lastPoint\" is required")
		}
		return v.VisitLastPointWithContext(ctx, *u.lastPoint)
	case "lastValuePoint":
		if u.lastValuePoint == nil {
			return fmt.Errorf("field \"lastValuePoint\" is required")
		}
		return v.VisitLastValuePointWithContext(ctx, *u.lastValuePoint)
	case "lastRange":
		if u.lastRange == nil {
			return fmt.Errorf("field \"lastRange\" is required")
		}
		return v.VisitLastRangeWithContext(ctx, *u.lastRange)
	}
}

type SelectValueVisitorWithContext interface {
	VisitFirstPointWithContext(ctx context.Context, v Series) error
	VisitFirstValuePointWithContext(ctx context.Context, v Series) error
	VisitFirstRangeWithContext(ctx context.Context, v RangeSeries) error
	VisitLastPointWithContext(ctx context.Context, v Series) error
	VisitLastValuePointWithContext(ctx context.Context, v Series) error
	VisitLastRangeWithContext(ctx context.Context, v RangeSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSelectValueFromFirstPoint(v Series) SelectValue {
	return SelectValue{typ: "firstPoint", firstPoint: &v}
}

func NewSelectValueFromFirstValuePoint(v Series) SelectValue {
	return SelectValue{typ: "firstValuePoint", firstValuePoint: &v}
}

func NewSelectValueFromFirstRange(v RangeSeries) SelectValue {
	return SelectValue{typ: "firstRange", firstRange: &v}
}

func NewSelectValueFromLastPoint(v Series) SelectValue {
	return SelectValue{typ: "lastPoint", lastPoint: &v}
}

func NewSelectValueFromLastValuePoint(v Series) SelectValue {
	return SelectValue{typ: "lastValuePoint", lastValuePoint: &v}
}

func NewSelectValueFromLastRange(v RangeSeries) SelectValue {
	return SelectValue{typ: "lastRange", lastRange: &v}
}

type Series struct {
	typ     string
	raw     *api.Reference
	enum    *EnumSeries
	numeric *NumericSeries
	log     *LogSeries
	array   *ArraySeries
	struct_ *StructSeries
}

type seriesDeserializer struct {
	Type    string         `json:"type"`
	Raw     *api.Reference `json:"raw"`
	Enum    *EnumSeries    `json:"enum"`
	Numeric *NumericSeries `json:"numeric"`
	Log     *LogSeries     `json:"log"`
	Array   *ArraySeries   `json:"array"`
	Struct  *StructSeries  `json:"struct"`
}

func (u *seriesDeserializer) toStruct() Series {
	return Series{typ: u.Type, raw: u.Raw, enum: u.Enum, numeric: u.Numeric, log: u.Log, array: u.Array, struct_: u.Struct}
}

func (u *Series) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Enum EnumSeries `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Numeric NumericSeries `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "log":
		if u.log == nil {
			return nil, fmt.Errorf("field \"log\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Log  LogSeries `json:"log"`
		}{Type: "log", Log: *u.log}, nil
	case "array":
		if u.array == nil {
			return nil, fmt.Errorf("field \"array\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Array ArraySeries `json:"array"`
		}{Type: "array", Array: *u.array}, nil
	case "struct":
		if u.struct_ == nil {
			return nil, fmt.Errorf("field \"struct\" is required")
		}
		return struct {
			Type   string       `json:"type"`
			Struct StructSeries `json:"struct"`
		}{Type: "struct", Struct: *u.struct_}, nil
	}
}

func (u Series) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Series) UnmarshalJSON(data []byte) error {
	var deser seriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
	}
	return nil
}

func (u Series) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Series) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Series) AcceptFuncs(rawFunc func(api.Reference) error, enumFunc func(EnumSeries) error, numericFunc func(NumericSeries) error, logFunc func(LogSeries) error, arrayFunc func(ArraySeries) error, struct_Func func(StructSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return struct_Func(*u.struct_)
	}
}

func (u *Series) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *Series) EnumNoopSuccess(EnumSeries) error {
	return nil
}

func (u *Series) NumericNoopSuccess(NumericSeries) error {
	return nil
}

func (u *Series) LogNoopSuccess(LogSeries) error {
	return nil
}

func (u *Series) ArrayNoopSuccess(ArraySeries) error {
	return nil
}

func (u *Series) StructNoopSuccess(StructSeries) error {
	return nil
}

func (u *Series) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Series) Accept(v SeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(*u.log)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(*u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStruct(*u.struct_)
	}
}

type SeriesVisitor interface {
	VisitRaw(v api.Reference) error
	VisitEnum(v EnumSeries) error
	VisitNumeric(v NumericSeries) error
	VisitLog(v LogSeries) error
	VisitArray(v ArraySeries) error
	VisitStruct(v StructSeries) error
	VisitUnknown(typeName string) error
}

func (u *Series) AcceptWithContext(ctx context.Context, v SeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLogWithContext(ctx, *u.log)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArrayWithContext(ctx, *u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStructWithContext(ctx, *u.struct_)
	}
}

type SeriesVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitEnumWithContext(ctx context.Context, v EnumSeries) error
	VisitNumericWithContext(ctx context.Context, v NumericSeries) error
	VisitLogWithContext(ctx context.Context, v LogSeries) error
	VisitArrayWithContext(ctx context.Context, v ArraySeries) error
	VisitStructWithContext(ctx context.Context, v StructSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSeriesFromRaw(v api.Reference) Series {
	return Series{typ: "raw", raw: &v}
}

func NewSeriesFromEnum(v EnumSeries) Series {
	return Series{typ: "enum", enum: &v}
}

func NewSeriesFromNumeric(v NumericSeries) Series {
	return Series{typ: "numeric", numeric: &v}
}

func NewSeriesFromLog(v LogSeries) Series {
	return Series{typ: "log", log: &v}
}

func NewSeriesFromArray(v ArraySeries) Series {
	return Series{typ: "array", array: &v}
}

func NewSeriesFromStruct(v StructSeries) Series {
	return Series{typ: "struct", struct_: &v}
}

type StructSeries struct {
	typ               string
	channel           *api.ChannelSeries
	raw               *api.Reference
	derived           *DerivedSeries
	extractFromStruct *ExtractStructFromStructSeries
}

type structSeriesDeserializer struct {
	Type              string                         `json:"type"`
	Channel           *api.ChannelSeries             `json:"channel"`
	Raw               *api.Reference                 `json:"raw"`
	Derived           *DerivedSeries                 `json:"derived"`
	ExtractFromStruct *ExtractStructFromStructSeries `json:"extractFromStruct"`
}

func (u *structSeriesDeserializer) toStruct() StructSeries {
	return StructSeries{typ: u.Type, channel: u.Channel, raw: u.Raw, derived: u.Derived, extractFromStruct: u.ExtractFromStruct}
}

func (u *StructSeries) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Channel api.ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Raw  api.Reference `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return nil, fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return struct {
			Type              string                        `json:"type"`
			ExtractFromStruct ExtractStructFromStructSeries `json:"extractFromStruct"`
		}{Type: "extractFromStruct", ExtractFromStruct: *u.extractFromStruct}, nil
	}
}

func (u StructSeries) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *StructSeries) UnmarshalJSON(data []byte) error {
	var deser structSeriesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
	}
	return nil
}

func (u StructSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *StructSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *StructSeries) AcceptFuncs(channelFunc func(api.ChannelSeries) error, rawFunc func(api.Reference) error, derivedFunc func(DerivedSeries) error, extractFromStructFunc func(ExtractStructFromStructSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return extractFromStructFunc(*u.extractFromStruct)
	}
}

func (u *StructSeries) ChannelNoopSuccess(api.ChannelSeries) error {
	return nil
}

func (u *StructSeries) RawNoopSuccess(api.Reference) error {
	return nil
}

func (u *StructSeries) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *StructSeries) ExtractFromStructNoopSuccess(ExtractStructFromStructSeries) error {
	return nil
}

func (u *StructSeries) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *StructSeries) Accept(v StructSeriesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStruct(*u.extractFromStruct)
	}
}

type StructSeriesVisitor interface {
	VisitChannel(v api.ChannelSeries) error
	VisitRaw(v api.Reference) error
	VisitDerived(v DerivedSeries) error
	VisitExtractFromStruct(v ExtractStructFromStructSeries) error
	VisitUnknown(typeName string) error
}

func (u *StructSeries) AcceptWithContext(ctx context.Context, v StructSeriesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	case "extractFromStruct":
		if u.extractFromStruct == nil {
			return fmt.Errorf("field \"extractFromStruct\" is required")
		}
		return v.VisitExtractFromStructWithContext(ctx, *u.extractFromStruct)
	}
}

type StructSeriesVisitorWithContext interface {
	VisitChannelWithContext(ctx context.Context, v api.ChannelSeries) error
	VisitRawWithContext(ctx context.Context, v api.Reference) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitExtractFromStructWithContext(ctx context.Context, v ExtractStructFromStructSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewStructSeriesFromChannel(v api.ChannelSeries) StructSeries {
	return StructSeries{typ: "channel", channel: &v}
}

func NewStructSeriesFromRaw(v api.Reference) StructSeries {
	return StructSeries{typ: "raw", raw: &v}
}

func NewStructSeriesFromDerived(v DerivedSeries) StructSeries {
	return StructSeries{typ: "derived", derived: &v}
}

func NewStructSeriesFromExtractFromStruct(v ExtractStructFromStructSeries) StructSeries {
	return StructSeries{typ: "extractFromStruct", extractFromStruct: &v}
}

type VariableValue struct {
	typ         string
	double      *float64
	computeNode *ComputeNodeWithContext
	duration    *api1.Duration
	integer     *int
	channel     *api.ChannelSeries
	derived     *DerivedSeries
	string      *string
	stringSet   *[]string
	timestamp   *api2.Timestamp
}

type variableValueDeserializer struct {
	Type        string                  `json:"type"`
	Double      *float64                `json:"double"`
	ComputeNode *ComputeNodeWithContext `json:"computeNode"`
	Duration    *api1.Duration          `json:"duration"`
	Integer     *int                    `json:"integer"`
	Channel     *api.ChannelSeries      `json:"channel"`
	Derived     *DerivedSeries          `json:"derived"`
	String      *string                 `json:"string"`
	StringSet   *[]string               `json:"stringSet"`
	Timestamp   *api2.Timestamp         `json:"timestamp"`
}

func (u *variableValueDeserializer) toStruct() VariableValue {
	return VariableValue{typ: u.Type, double: u.Double, computeNode: u.ComputeNode, duration: u.Duration, integer: u.Integer, channel: u.Channel, derived: u.Derived, string: u.String, stringSet: u.StringSet, timestamp: u.Timestamp}
}

func (u *VariableValue) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "double":
		if u.double == nil {
			return nil, fmt.Errorf("field \"double\" is required")
		}
		return struct {
			Type   string  `json:"type"`
			Double float64 `json:"double"`
		}{Type: "double", Double: *u.double}, nil
	case "computeNode":
		if u.computeNode == nil {
			return nil, fmt.Errorf("field \"computeNode\" is required")
		}
		return struct {
			Type        string                 `json:"type"`
			ComputeNode ComputeNodeWithContext `json:"computeNode"`
		}{Type: "computeNode", ComputeNode: *u.computeNode}, nil
	case "duration":
		if u.duration == nil {
			return nil, fmt.Errorf("field \"duration\" is required")
		}
		return struct {
			Type     string        `json:"type"`
			Duration api1.Duration `json:"duration"`
		}{Type: "duration", Duration: *u.duration}, nil
	case "integer":
		if u.integer == nil {
			return nil, fmt.Errorf("field \"integer\" is required")
		}
		return struct {
			Type    string `json:"type"`
			Integer int    `json:"integer"`
		}{Type: "integer", Integer: *u.integer}, nil
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Channel api.ChannelSeries `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "derived":
		if u.derived == nil {
			return nil, fmt.Errorf("field \"derived\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Derived DerivedSeries `json:"derived"`
		}{Type: "derived", Derived: *u.derived}, nil
	case "string":
		if u.string == nil {
			return nil, fmt.Errorf("field \"string\" is required")
		}
		return struct {
			Type   string `json:"type"`
			String string `json:"string"`
		}{Type: "string", String: *u.string}, nil
	case "stringSet":
		if u.stringSet == nil {
			return nil, fmt.Errorf("field \"stringSet\" is required")
		}
		return struct {
			Type      string   `json:"type"`
			StringSet []string `json:"stringSet"`
		}{Type: "stringSet", StringSet: *u.stringSet}, nil
	case "timestamp":
		if u.timestamp == nil {
			return nil, fmt.Errorf("field \"timestamp\" is required")
		}
		return struct {
			Type      string         `json:"type"`
			Timestamp api2.Timestamp `json:"timestamp"`
		}{Type: "timestamp", Timestamp: *u.timestamp}, nil
	}
}

func (u VariableValue) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VariableValue) UnmarshalJSON(data []byte) error {
	var deser variableValueDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
	case "integer":
		if u.integer == nil {
			return fmt.Errorf("field \"integer\" is required")
		}
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
	case "stringSet":
		if u.stringSet == nil {
			return fmt.Errorf("field \"stringSet\" is required")
		}
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
	}
	return nil
}

func (u VariableValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VariableValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VariableValue) AcceptFuncs(doubleFunc func(float64) error, computeNodeFunc func(ComputeNodeWithContext) error, durationFunc func(api1.Duration) error, integerFunc func(int) error, channelFunc func(api.ChannelSeries) error, derivedFunc func(DerivedSeries) error, stringFunc func(string) error, stringSetFunc func([]string) error, timestampFunc func(api2.Timestamp) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return computeNodeFunc(*u.computeNode)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return durationFunc(*u.duration)
	case "integer":
		if u.integer == nil {
			return fmt.Errorf("field \"integer\" is required")
		}
		return integerFunc(*u.integer)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return derivedFunc(*u.derived)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return stringFunc(*u.string)
	case "stringSet":
		if u.stringSet == nil {
			return fmt.Errorf("field \"stringSet\" is required")
		}
		return stringSetFunc(*u.stringSet)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return timestampFunc(*u.timestamp)
	}
}

func (u *VariableValue) DoubleNoopSuccess(float64) error {
	return nil
}

func (u *VariableValue) ComputeNodeNoopSuccess(ComputeNodeWithContext) error {
	return nil
}

func (u *VariableValue) DurationNoopSuccess(api1.Duration) error {
	return nil
}

func (u *VariableValue) IntegerNoopSuccess(int) error {
	return nil
}

func (u *VariableValue) ChannelNoopSuccess(api.ChannelSeries) error {
	return nil
}

func (u *VariableValue) DerivedNoopSuccess(DerivedSeries) error {
	return nil
}

func (u *VariableValue) StringNoopSuccess(string) error {
	return nil
}

func (u *VariableValue) StringSetNoopSuccess([]string) error {
	return nil
}

func (u *VariableValue) TimestampNoopSuccess(api2.Timestamp) error {
	return nil
}

func (u *VariableValue) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VariableValue) Accept(v VariableValueVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(*u.double)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return v.VisitComputeNode(*u.computeNode)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDuration(*u.duration)
	case "integer":
		if u.integer == nil {
			return fmt.Errorf("field \"integer\" is required")
		}
		return v.VisitInteger(*u.integer)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerived(*u.derived)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitString(*u.string)
	case "stringSet":
		if u.stringSet == nil {
			return fmt.Errorf("field \"stringSet\" is required")
		}
		return v.VisitStringSet(*u.stringSet)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestamp(*u.timestamp)
	}
}

type VariableValueVisitor interface {
	VisitDouble(v float64) error
	VisitComputeNode(v ComputeNodeWithContext) error
	VisitDuration(v api1.Duration) error
	VisitInteger(v int) error
	VisitChannel(v api.ChannelSeries) error
	VisitDerived(v DerivedSeries) error
	VisitString(v string) error
	VisitStringSet(v []string) error
	VisitTimestamp(v api2.Timestamp) error
	VisitUnknown(typeName string) error
}

func (u *VariableValue) AcceptWithContext(ctx context.Context, v VariableValueVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDoubleWithContext(ctx, *u.double)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return v.VisitComputeNodeWithContext(ctx, *u.computeNode)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDurationWithContext(ctx, *u.duration)
	case "integer":
		if u.integer == nil {
			return fmt.Errorf("field \"integer\" is required")
		}
		return v.VisitIntegerWithContext(ctx, *u.integer)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "derived":
		if u.derived == nil {
			return fmt.Errorf("field \"derived\" is required")
		}
		return v.VisitDerivedWithContext(ctx, *u.derived)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitStringWithContext(ctx, *u.string)
	case "stringSet":
		if u.stringSet == nil {
			return fmt.Errorf("field \"stringSet\" is required")
		}
		return v.VisitStringSetWithContext(ctx, *u.stringSet)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestampWithContext(ctx, *u.timestamp)
	}
}

type VariableValueVisitorWithContext interface {
	VisitDoubleWithContext(ctx context.Context, v float64) error
	VisitComputeNodeWithContext(ctx context.Context, v ComputeNodeWithContext) error
	VisitDurationWithContext(ctx context.Context, v api1.Duration) error
	VisitIntegerWithContext(ctx context.Context, v int) error
	VisitChannelWithContext(ctx context.Context, v api.ChannelSeries) error
	VisitDerivedWithContext(ctx context.Context, v DerivedSeries) error
	VisitStringWithContext(ctx context.Context, v string) error
	VisitStringSetWithContext(ctx context.Context, v []string) error
	VisitTimestampWithContext(ctx context.Context, v api2.Timestamp) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVariableValueFromDouble(v float64) VariableValue {
	return VariableValue{typ: "double", double: &v}
}

func NewVariableValueFromComputeNode(v ComputeNodeWithContext) VariableValue {
	return VariableValue{typ: "computeNode", computeNode: &v}
}

func NewVariableValueFromDuration(v api1.Duration) VariableValue {
	return VariableValue{typ: "duration", duration: &v}
}

func NewVariableValueFromInteger(v int) VariableValue {
	return VariableValue{typ: "integer", integer: &v}
}

func NewVariableValueFromChannel(v api.ChannelSeries) VariableValue {
	return VariableValue{typ: "channel", channel: &v}
}

func NewVariableValueFromDerived(v DerivedSeries) VariableValue {
	return VariableValue{typ: "derived", derived: &v}
}

func NewVariableValueFromString(v string) VariableValue {
	return VariableValue{typ: "string", string: &v}
}

func NewVariableValueFromStringSet(v []string) VariableValue {
	return VariableValue{typ: "stringSet", stringSet: &v}
}

func NewVariableValueFromTimestamp(v api2.Timestamp) VariableValue {
	return VariableValue{typ: "timestamp", timestamp: &v}
}

type Window struct {
	typ      string
	duration *DurationConstant
}

type windowDeserializer struct {
	Type     string            `json:"type"`
	Duration *DurationConstant `json:"duration"`
}

func (u *windowDeserializer) toStruct() Window {
	return Window{typ: u.Type, duration: u.Duration}
}

func (u *Window) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "duration":
		if u.duration == nil {
			return nil, fmt.Errorf("field \"duration\" is required")
		}
		return struct {
			Type     string           `json:"type"`
			Duration DurationConstant `json:"duration"`
		}{Type: "duration", Duration: *u.duration}, nil
	}
}

func (u Window) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Window) UnmarshalJSON(data []byte) error {
	var deser windowDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
	}
	return nil
}

func (u Window) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Window) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Window) AcceptFuncs(durationFunc func(DurationConstant) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return durationFunc(*u.duration)
	}
}

func (u *Window) DurationNoopSuccess(DurationConstant) error {
	return nil
}

func (u *Window) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Window) Accept(v WindowVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDuration(*u.duration)
	}
}

type WindowVisitor interface {
	VisitDuration(v DurationConstant) error
	VisitUnknown(typeName string) error
}

func (u *Window) AcceptWithContext(ctx context.Context, v WindowVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDurationWithContext(ctx, *u.duration)
	}
}

type WindowVisitorWithContext interface {
	VisitDurationWithContext(ctx context.Context, v DurationConstant) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewWindowFromDuration(v DurationConstant) Window {
	return Window{typ: "duration", duration: &v}
}
