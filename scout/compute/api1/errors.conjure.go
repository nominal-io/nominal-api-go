// Code generated by conjure-go. DO NOT EDIT.

package api1

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	api2 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/scout/compute/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/run/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type derivedSeriesHasWrongType struct {
	ExpectedType  string        `json:"expectedType"`
	DerivedSeries DerivedSeries `json:"derivedSeries"`
}

func (o derivedSeriesHasWrongType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *derivedSeriesHasWrongType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDerivedSeriesHasWrongType returns new instance of DerivedSeriesHasWrongType error.
func NewDerivedSeriesHasWrongType(expectedTypeArg string, derivedSeriesArg DerivedSeries) *DerivedSeriesHasWrongType {
	return &DerivedSeriesHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), derivedSeriesHasWrongType: derivedSeriesHasWrongType{ExpectedType: expectedTypeArg, DerivedSeries: derivedSeriesArg}}
}

// WrapWithDerivedSeriesHasWrongType returns new instance of DerivedSeriesHasWrongType error wrapping an existing error.
func WrapWithDerivedSeriesHasWrongType(err error, expectedTypeArg string, derivedSeriesArg DerivedSeries) *DerivedSeriesHasWrongType {
	return &DerivedSeriesHasWrongType{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, derivedSeriesHasWrongType: derivedSeriesHasWrongType{ExpectedType: expectedTypeArg, DerivedSeries: derivedSeriesArg}}
}

// DerivedSeriesHasWrongType is an error type.
type DerivedSeriesHasWrongType struct {
	errorInstanceID uuid.UUID
	derivedSeriesHasWrongType
	cause error
	stack werror.StackTrace
}

// IsDerivedSeriesHasWrongType returns true if err is an instance of DerivedSeriesHasWrongType.
func IsDerivedSeriesHasWrongType(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DerivedSeriesHasWrongType)
	return ok
}

func (e *DerivedSeriesHasWrongType) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:DerivedSeriesHasWrongType (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DerivedSeriesHasWrongType) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DerivedSeriesHasWrongType) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DerivedSeriesHasWrongType) Message() string {
	return "INVALID_ARGUMENT Compute:DerivedSeriesHasWrongType"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DerivedSeriesHasWrongType) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DerivedSeriesHasWrongType) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *DerivedSeriesHasWrongType) Name() string {
	return "Compute:DerivedSeriesHasWrongType"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DerivedSeriesHasWrongType) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DerivedSeriesHasWrongType) Parameters() map[string]interface{} {
	return map[string]interface{}{"expectedType": e.ExpectedType, "derivedSeries": e.DerivedSeries}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DerivedSeriesHasWrongType) safeParams() map[string]interface{} {
	return map[string]interface{}{"expectedType": e.ExpectedType, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DerivedSeriesHasWrongType) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DerivedSeriesHasWrongType) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"derivedSeries": e.DerivedSeries}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DerivedSeriesHasWrongType) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DerivedSeriesHasWrongType) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.derivedSeriesHasWrongType)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:DerivedSeriesHasWrongType", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DerivedSeriesHasWrongType) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters derivedSeriesHasWrongType
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.derivedSeriesHasWrongType = parameters
	return nil
}

type missingModuleVariable struct {
	VariableName api.VariableName `json:"variableName"`
	Context      *Context         `json:"context,omitempty"`
}

func (o missingModuleVariable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *missingModuleVariable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMissingModuleVariable returns new instance of MissingModuleVariable error.
func NewMissingModuleVariable(variableNameArg api.VariableName, contextArg *Context) *MissingModuleVariable {
	return &MissingModuleVariable{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), missingModuleVariable: missingModuleVariable{VariableName: variableNameArg, Context: contextArg}}
}

// WrapWithMissingModuleVariable returns new instance of MissingModuleVariable error wrapping an existing error.
func WrapWithMissingModuleVariable(err error, variableNameArg api.VariableName, contextArg *Context) *MissingModuleVariable {
	return &MissingModuleVariable{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, missingModuleVariable: missingModuleVariable{VariableName: variableNameArg, Context: contextArg}}
}

// MissingModuleVariable is an error type.
type MissingModuleVariable struct {
	errorInstanceID uuid.UUID
	missingModuleVariable
	cause error
	stack werror.StackTrace
}

// IsMissingModuleVariable returns true if err is an instance of MissingModuleVariable.
func IsMissingModuleVariable(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MissingModuleVariable)
	return ok
}

func (e *MissingModuleVariable) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MissingModuleVariable (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MissingModuleVariable) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MissingModuleVariable) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MissingModuleVariable) Message() string {
	return "INVALID_ARGUMENT Compute:MissingModuleVariable"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MissingModuleVariable) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MissingModuleVariable) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MissingModuleVariable) Name() string {
	return "Compute:MissingModuleVariable"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MissingModuleVariable) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MissingModuleVariable) Parameters() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "context": e.Context}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MissingModuleVariable) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingModuleVariable) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MissingModuleVariable) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "context": e.Context}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingModuleVariable) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MissingModuleVariable) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.missingModuleVariable)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MissingModuleVariable", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MissingModuleVariable) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters missingModuleVariable
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.missingModuleVariable = parameters
	return nil
}

type missingVariable struct {
	VariableName api.VariableName `json:"variableName"`
	Context      *Context         `json:"context,omitempty"`
}

func (o missingVariable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *missingVariable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMissingVariable returns new instance of MissingVariable error.
func NewMissingVariable(variableNameArg api.VariableName, contextArg *Context) *MissingVariable {
	return &MissingVariable{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), missingVariable: missingVariable{VariableName: variableNameArg, Context: contextArg}}
}

// WrapWithMissingVariable returns new instance of MissingVariable error wrapping an existing error.
func WrapWithMissingVariable(err error, variableNameArg api.VariableName, contextArg *Context) *MissingVariable {
	return &MissingVariable{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, missingVariable: missingVariable{VariableName: variableNameArg, Context: contextArg}}
}

// MissingVariable is an error type.
type MissingVariable struct {
	errorInstanceID uuid.UUID
	missingVariable
	cause error
	stack werror.StackTrace
}

// IsMissingVariable returns true if err is an instance of MissingVariable.
func IsMissingVariable(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MissingVariable)
	return ok
}

func (e *MissingVariable) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:MissingVariable (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MissingVariable) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MissingVariable) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MissingVariable) Message() string {
	return "INVALID_ARGUMENT Compute:MissingVariable"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MissingVariable) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MissingVariable) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MissingVariable) Name() string {
	return "Compute:MissingVariable"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MissingVariable) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MissingVariable) Parameters() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "context": e.Context}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MissingVariable) safeParams() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingVariable) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MissingVariable) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"context": e.Context}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingVariable) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MissingVariable) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.missingVariable)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:MissingVariable", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MissingVariable) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters missingVariable
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.missingVariable = parameters
	return nil
}

type nonPositiveDuration struct {
	Duration api1.Duration `json:"duration"`
}

func (o nonPositiveDuration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *nonPositiveDuration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNonPositiveDuration returns new instance of NonPositiveDuration error.
func NewNonPositiveDuration(durationArg api1.Duration) *NonPositiveDuration {
	return &NonPositiveDuration{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), nonPositiveDuration: nonPositiveDuration{Duration: durationArg}}
}

// WrapWithNonPositiveDuration returns new instance of NonPositiveDuration error wrapping an existing error.
func WrapWithNonPositiveDuration(err error, durationArg api1.Duration) *NonPositiveDuration {
	return &NonPositiveDuration{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, nonPositiveDuration: nonPositiveDuration{Duration: durationArg}}
}

// NonPositiveDuration is an error type.
// Duration must be strictly positive.
type NonPositiveDuration struct {
	errorInstanceID uuid.UUID
	nonPositiveDuration
	cause error
	stack werror.StackTrace
}

// IsNonPositiveDuration returns true if err is an instance of NonPositiveDuration.
func IsNonPositiveDuration(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NonPositiveDuration)
	return ok
}

func (e *NonPositiveDuration) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:NonPositiveDuration (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NonPositiveDuration) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NonPositiveDuration) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NonPositiveDuration) Message() string {
	return "INVALID_ARGUMENT Compute:NonPositiveDuration"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NonPositiveDuration) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NonPositiveDuration) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *NonPositiveDuration) Name() string {
	return "Compute:NonPositiveDuration"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NonPositiveDuration) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NonPositiveDuration) Parameters() map[string]interface{} {
	return map[string]interface{}{"duration": e.Duration}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NonPositiveDuration) safeParams() map[string]interface{} {
	return map[string]interface{}{"duration": e.Duration, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NonPositiveDuration) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NonPositiveDuration) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NonPositiveDuration) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NonPositiveDuration) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.nonPositiveDuration)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:NonPositiveDuration", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NonPositiveDuration) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters nonPositiveDuration
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.nonPositiveDuration = parameters
	return nil
}

type nonPositiveResampleInterval struct {
	ResampleInterval api1.Duration `json:"resampleInterval"`
}

func (o nonPositiveResampleInterval) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *nonPositiveResampleInterval) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNonPositiveResampleInterval returns new instance of NonPositiveResampleInterval error.
func NewNonPositiveResampleInterval(resampleIntervalArg api1.Duration) *NonPositiveResampleInterval {
	return &NonPositiveResampleInterval{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), nonPositiveResampleInterval: nonPositiveResampleInterval{ResampleInterval: resampleIntervalArg}}
}

// WrapWithNonPositiveResampleInterval returns new instance of NonPositiveResampleInterval error wrapping an existing error.
func WrapWithNonPositiveResampleInterval(err error, resampleIntervalArg api1.Duration) *NonPositiveResampleInterval {
	return &NonPositiveResampleInterval{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, nonPositiveResampleInterval: nonPositiveResampleInterval{ResampleInterval: resampleIntervalArg}}
}

// NonPositiveResampleInterval is an error type.
// The resample interval must be strictly positive.
type NonPositiveResampleInterval struct {
	errorInstanceID uuid.UUID
	nonPositiveResampleInterval
	cause error
	stack werror.StackTrace
}

// IsNonPositiveResampleInterval returns true if err is an instance of NonPositiveResampleInterval.
func IsNonPositiveResampleInterval(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NonPositiveResampleInterval)
	return ok
}

func (e *NonPositiveResampleInterval) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:NonPositiveResampleInterval (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NonPositiveResampleInterval) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NonPositiveResampleInterval) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NonPositiveResampleInterval) Message() string {
	return "INVALID_ARGUMENT Compute:NonPositiveResampleInterval"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NonPositiveResampleInterval) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NonPositiveResampleInterval) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *NonPositiveResampleInterval) Name() string {
	return "Compute:NonPositiveResampleInterval"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NonPositiveResampleInterval) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NonPositiveResampleInterval) Parameters() map[string]interface{} {
	return map[string]interface{}{"resampleInterval": e.ResampleInterval}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NonPositiveResampleInterval) safeParams() map[string]interface{} {
	return map[string]interface{}{"resampleInterval": e.ResampleInterval, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NonPositiveResampleInterval) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NonPositiveResampleInterval) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NonPositiveResampleInterval) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NonPositiveResampleInterval) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.nonPositiveResampleInterval)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:NonPositiveResampleInterval", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NonPositiveResampleInterval) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters nonPositiveResampleInterval
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.nonPositiveResampleInterval = parameters
	return nil
}

type resolutionIntervalTooSmallForRange struct {
	RequestedResolution api1.Duration  `json:"requestedResolution"`
	Start               api2.Timestamp `json:"start"`
	End                 api2.Timestamp `json:"end"`
}

func (o resolutionIntervalTooSmallForRange) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *resolutionIntervalTooSmallForRange) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewResolutionIntervalTooSmallForRange returns new instance of ResolutionIntervalTooSmallForRange error.
func NewResolutionIntervalTooSmallForRange(requestedResolutionArg api1.Duration, startArg api2.Timestamp, endArg api2.Timestamp) *ResolutionIntervalTooSmallForRange {
	return &ResolutionIntervalTooSmallForRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), resolutionIntervalTooSmallForRange: resolutionIntervalTooSmallForRange{RequestedResolution: requestedResolutionArg, Start: startArg, End: endArg}}
}

// WrapWithResolutionIntervalTooSmallForRange returns new instance of ResolutionIntervalTooSmallForRange error wrapping an existing error.
func WrapWithResolutionIntervalTooSmallForRange(err error, requestedResolutionArg api1.Duration, startArg api2.Timestamp, endArg api2.Timestamp) *ResolutionIntervalTooSmallForRange {
	return &ResolutionIntervalTooSmallForRange{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, resolutionIntervalTooSmallForRange: resolutionIntervalTooSmallForRange{RequestedResolution: requestedResolutionArg, Start: startArg, End: endArg}}
}

// ResolutionIntervalTooSmallForRange is an error type.
type ResolutionIntervalTooSmallForRange struct {
	errorInstanceID uuid.UUID
	resolutionIntervalTooSmallForRange
	cause error
	stack werror.StackTrace
}

// IsResolutionIntervalTooSmallForRange returns true if err is an instance of ResolutionIntervalTooSmallForRange.
func IsResolutionIntervalTooSmallForRange(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ResolutionIntervalTooSmallForRange)
	return ok
}

func (e *ResolutionIntervalTooSmallForRange) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Compute:ResolutionIntervalTooSmallForRange (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ResolutionIntervalTooSmallForRange) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ResolutionIntervalTooSmallForRange) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ResolutionIntervalTooSmallForRange) Message() string {
	return "INVALID_ARGUMENT Compute:ResolutionIntervalTooSmallForRange"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ResolutionIntervalTooSmallForRange) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ResolutionIntervalTooSmallForRange) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ResolutionIntervalTooSmallForRange) Name() string {
	return "Compute:ResolutionIntervalTooSmallForRange"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ResolutionIntervalTooSmallForRange) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ResolutionIntervalTooSmallForRange) Parameters() map[string]interface{} {
	return map[string]interface{}{"requestedResolution": e.RequestedResolution, "start": e.Start, "end": e.End}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ResolutionIntervalTooSmallForRange) safeParams() map[string]interface{} {
	return map[string]interface{}{"requestedResolution": e.RequestedResolution, "start": e.Start, "end": e.End, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ResolutionIntervalTooSmallForRange) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ResolutionIntervalTooSmallForRange) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ResolutionIntervalTooSmallForRange) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ResolutionIntervalTooSmallForRange) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.resolutionIntervalTooSmallForRange)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Compute:ResolutionIntervalTooSmallForRange", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ResolutionIntervalTooSmallForRange) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters resolutionIntervalTooSmallForRange
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.resolutionIntervalTooSmallForRange = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Compute:DerivedSeriesHasWrongType", reflect.TypeOf(DerivedSeriesHasWrongType{}))
	conjureerrors.RegisterErrorType("Compute:MissingModuleVariable", reflect.TypeOf(MissingModuleVariable{}))
	conjureerrors.RegisterErrorType("Compute:MissingVariable", reflect.TypeOf(MissingVariable{}))
	conjureerrors.RegisterErrorType("Compute:NonPositiveDuration", reflect.TypeOf(NonPositiveDuration{}))
	conjureerrors.RegisterErrorType("Compute:NonPositiveResampleInterval", reflect.TypeOf(NonPositiveResampleInterval{}))
	conjureerrors.RegisterErrorType("Compute:ResolutionIntervalTooSmallForRange", reflect.TypeOf(ResolutionIntervalTooSmallForRange{}))
}
