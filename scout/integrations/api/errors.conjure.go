// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type integrationNotFound struct {
	IntegrationRid IntegrationRid `json:"integrationRid"`
}

func (o integrationNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *integrationNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewIntegrationNotFound returns new instance of IntegrationNotFound error.
func NewIntegrationNotFound(integrationRidArg IntegrationRid) *IntegrationNotFound {
	return &IntegrationNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), integrationNotFound: integrationNotFound{IntegrationRid: integrationRidArg}}
}

// WrapWithIntegrationNotFound returns new instance of IntegrationNotFound error wrapping an existing error.
func WrapWithIntegrationNotFound(err error, integrationRidArg IntegrationRid) *IntegrationNotFound {
	return &IntegrationNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, integrationNotFound: integrationNotFound{IntegrationRid: integrationRidArg}}
}

// IntegrationNotFound is an error type.
type IntegrationNotFound struct {
	errorInstanceID uuid.UUID
	integrationNotFound
	cause error
	stack werror.StackTrace
}

// IsIntegrationNotFound returns true if err is an instance of IntegrationNotFound.
func IsIntegrationNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*IntegrationNotFound)
	return ok
}

func (e *IntegrationNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Scout:IntegrationNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *IntegrationNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *IntegrationNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *IntegrationNotFound) Message() string {
	return "NOT_FOUND Scout:IntegrationNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *IntegrationNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *IntegrationNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *IntegrationNotFound) Name() string {
	return "Scout:IntegrationNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *IntegrationNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *IntegrationNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"integrationRid": e.IntegrationRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *IntegrationNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"integrationRid": e.IntegrationRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *IntegrationNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *IntegrationNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *IntegrationNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e IntegrationNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.integrationNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Scout:IntegrationNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *IntegrationNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters integrationNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.integrationNotFound = parameters
	return nil
}

type integrationTokenNotFound struct {
	Token string `json:"token"`
}

func (o integrationTokenNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *integrationTokenNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewIntegrationTokenNotFound returns new instance of IntegrationTokenNotFound error.
func NewIntegrationTokenNotFound(tokenArg string) *IntegrationTokenNotFound {
	return &IntegrationTokenNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), integrationTokenNotFound: integrationTokenNotFound{Token: tokenArg}}
}

// WrapWithIntegrationTokenNotFound returns new instance of IntegrationTokenNotFound error wrapping an existing error.
func WrapWithIntegrationTokenNotFound(err error, tokenArg string) *IntegrationTokenNotFound {
	return &IntegrationTokenNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, integrationTokenNotFound: integrationTokenNotFound{Token: tokenArg}}
}

// IntegrationTokenNotFound is an error type.
type IntegrationTokenNotFound struct {
	errorInstanceID uuid.UUID
	integrationTokenNotFound
	cause error
	stack werror.StackTrace
}

// IsIntegrationTokenNotFound returns true if err is an instance of IntegrationTokenNotFound.
func IsIntegrationTokenNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*IntegrationTokenNotFound)
	return ok
}

func (e *IntegrationTokenNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Scout:IntegrationTokenNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *IntegrationTokenNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *IntegrationTokenNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *IntegrationTokenNotFound) Message() string {
	return "NOT_FOUND Scout:IntegrationTokenNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *IntegrationTokenNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *IntegrationTokenNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *IntegrationTokenNotFound) Name() string {
	return "Scout:IntegrationTokenNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *IntegrationTokenNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *IntegrationTokenNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"token": e.Token}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *IntegrationTokenNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"token": e.Token, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *IntegrationTokenNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *IntegrationTokenNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *IntegrationTokenNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e IntegrationTokenNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.integrationTokenNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Scout:IntegrationTokenNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *IntegrationTokenNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters integrationTokenNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.integrationTokenNotFound = parameters
	return nil
}

type integrationsNotFound struct {
	IntegrationRids []IntegrationRid `json:"integrationRids"`
}

func (o integrationsNotFound) MarshalJSON() ([]byte, error) {
	if o.IntegrationRids == nil {
		o.IntegrationRids = make([]IntegrationRid, 0)
	}
	type _tmpintegrationsNotFound integrationsNotFound
	return safejson.Marshal(_tmpintegrationsNotFound(o))
}

func (o *integrationsNotFound) UnmarshalJSON(data []byte) error {
	type _tmpintegrationsNotFound integrationsNotFound
	var rawintegrationsNotFound _tmpintegrationsNotFound
	if err := safejson.Unmarshal(data, &rawintegrationsNotFound); err != nil {
		return err
	}
	if rawintegrationsNotFound.IntegrationRids == nil {
		rawintegrationsNotFound.IntegrationRids = make([]IntegrationRid, 0)
	}
	*o = integrationsNotFound(rawintegrationsNotFound)
	return nil
}

func (o integrationsNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *integrationsNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewIntegrationsNotFound returns new instance of IntegrationsNotFound error.
func NewIntegrationsNotFound(integrationRidsArg []IntegrationRid) *IntegrationsNotFound {
	return &IntegrationsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), integrationsNotFound: integrationsNotFound{IntegrationRids: integrationRidsArg}}
}

// WrapWithIntegrationsNotFound returns new instance of IntegrationsNotFound error wrapping an existing error.
func WrapWithIntegrationsNotFound(err error, integrationRidsArg []IntegrationRid) *IntegrationsNotFound {
	return &IntegrationsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, integrationsNotFound: integrationsNotFound{IntegrationRids: integrationRidsArg}}
}

// IntegrationsNotFound is an error type.
type IntegrationsNotFound struct {
	errorInstanceID uuid.UUID
	integrationsNotFound
	cause error
	stack werror.StackTrace
}

// IsIntegrationsNotFound returns true if err is an instance of IntegrationsNotFound.
func IsIntegrationsNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*IntegrationsNotFound)
	return ok
}

func (e *IntegrationsNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Scout:IntegrationsNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *IntegrationsNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *IntegrationsNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *IntegrationsNotFound) Message() string {
	return "NOT_FOUND Scout:IntegrationsNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *IntegrationsNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *IntegrationsNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *IntegrationsNotFound) Name() string {
	return "Scout:IntegrationsNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *IntegrationsNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *IntegrationsNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"integrationRids": e.IntegrationRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *IntegrationsNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"integrationRids": e.IntegrationRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *IntegrationsNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *IntegrationsNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *IntegrationsNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e IntegrationsNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.integrationsNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Scout:IntegrationsNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *IntegrationsNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters integrationsNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.integrationsNotFound = parameters
	return nil
}

type slackIntegrationNotAvailable struct{}

func (o slackIntegrationNotAvailable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *slackIntegrationNotAvailable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSlackIntegrationNotAvailable returns new instance of SlackIntegrationNotAvailable error.
func NewSlackIntegrationNotAvailable() *SlackIntegrationNotAvailable {
	return &SlackIntegrationNotAvailable{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), slackIntegrationNotAvailable: slackIntegrationNotAvailable{}}
}

// WrapWithSlackIntegrationNotAvailable returns new instance of SlackIntegrationNotAvailable error wrapping an existing error.
func WrapWithSlackIntegrationNotAvailable(err error) *SlackIntegrationNotAvailable {
	return &SlackIntegrationNotAvailable{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, slackIntegrationNotAvailable: slackIntegrationNotAvailable{}}
}

// SlackIntegrationNotAvailable is an error type.
type SlackIntegrationNotAvailable struct {
	errorInstanceID uuid.UUID
	slackIntegrationNotAvailable
	cause error
	stack werror.StackTrace
}

// IsSlackIntegrationNotAvailable returns true if err is an instance of SlackIntegrationNotAvailable.
func IsSlackIntegrationNotAvailable(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SlackIntegrationNotAvailable)
	return ok
}

func (e *SlackIntegrationNotAvailable) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Scout:SlackIntegrationNotAvailable (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SlackIntegrationNotAvailable) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SlackIntegrationNotAvailable) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SlackIntegrationNotAvailable) Message() string {
	return "INVALID_ARGUMENT Scout:SlackIntegrationNotAvailable"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SlackIntegrationNotAvailable) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SlackIntegrationNotAvailable) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SlackIntegrationNotAvailable) Name() string {
	return "Scout:SlackIntegrationNotAvailable"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SlackIntegrationNotAvailable) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SlackIntegrationNotAvailable) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SlackIntegrationNotAvailable) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SlackIntegrationNotAvailable) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SlackIntegrationNotAvailable) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SlackIntegrationNotAvailable) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SlackIntegrationNotAvailable) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.slackIntegrationNotAvailable)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Scout:SlackIntegrationNotAvailable", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SlackIntegrationNotAvailable) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters slackIntegrationNotAvailable
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.slackIntegrationNotAvailable = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Scout:IntegrationNotFound", reflect.TypeOf(IntegrationNotFound{}))
	conjureerrors.RegisterErrorType("Scout:IntegrationTokenNotFound", reflect.TypeOf(IntegrationTokenNotFound{}))
	conjureerrors.RegisterErrorType("Scout:IntegrationsNotFound", reflect.TypeOf(IntegrationsNotFound{}))
	conjureerrors.RegisterErrorType("Scout:SlackIntegrationNotAvailable", reflect.TypeOf(SlackIntegrationNotAvailable{}))
}
