// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"
	"net/url"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	werror "github.com/palantir/witchcraft-go-error"
)

// Service for managing integrations with external services.
type IntegrationsServiceClient interface {
	// Generates link to request permissions for Slack bot to join workspaces and use a webhook.
	GenerateSlackWebhookLink(ctx context.Context, authHeader bearertoken.Token, workspaceArg *rids.WorkspaceRid, isGovSlackArg *bool) (GenerateSlackWebhookResponse, error)
	// Creates a new Slack integration. Called internally after Slack authorization.
	CreateSlackWebhook(ctx context.Context, authHeader bearertoken.Token, codeArg string, stateArg string) error
	// Creates a new integration.
	CreateIntegration(ctx context.Context, authHeader bearertoken.Token, createIntegrationRequestArg CreateIntegrationRequest) (Integration, error)
	// Deletes an integration by archiving.
	DeleteIntegration(ctx context.Context, authHeader bearertoken.Token, integrationRidArg IntegrationRid) error
	// Updates the metadata of an integration.
	UpdateIntegrationMetadata(ctx context.Context, authHeader bearertoken.Token, integrationRidArg IntegrationRid, requestArg UpdateIntegrationRequest) (Integration, error)
	// Retrieves an integration with the specified integration RID.
	GetIntegration(ctx context.Context, authHeader bearertoken.Token, integrationRidArg IntegrationRid) (Integration, error)
	// Lists all integrations. Archived integrations are not included.
	ListIntegrations(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) ([]Integration, error)
	// Sends a string message to the specified integration from a checklist execution.
	SendMessage(ctx context.Context, authHeader bearertoken.Token, requestArg SendMessageRequest) error
}

type integrationsServiceClient struct {
	client httpclient.Client
}

func NewIntegrationsServiceClient(client httpclient.Client) IntegrationsServiceClient {
	return &integrationsServiceClient{client: client}
}

func (c *integrationsServiceClient) GenerateSlackWebhookLink(ctx context.Context, authHeader bearertoken.Token, workspaceArg *rids.WorkspaceRid, isGovSlackArg *bool) (GenerateSlackWebhookResponse, error) {
	var defaultReturnVal GenerateSlackWebhookResponse
	var returnVal *GenerateSlackWebhookResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GenerateSlackWebhookLink"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/integrations/slack-oauth/init-webhook"))
	queryParams := make(url.Values)
	if workspaceArg != nil {
		queryParams.Set("workspace", fmt.Sprint(*workspaceArg))
	}
	if isGovSlackArg != nil {
		queryParams.Set("isGovSlack", fmt.Sprint(*isGovSlackArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "generateSlackWebhookLink failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "generateSlackWebhookLink response cannot be nil")
	}
	return *returnVal, nil
}

func (c *integrationsServiceClient) CreateSlackWebhook(ctx context.Context, authHeader bearertoken.Token, codeArg string, stateArg string) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateSlackWebhook"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/integrations/slack-oauth/redirect"))
	queryParams := make(url.Values)
	queryParams.Set("code", fmt.Sprint(codeArg))
	queryParams.Set("state", fmt.Sprint(stateArg))
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "createSlackWebhook failed")
	}
	return nil
}

func (c *integrationsServiceClient) CreateIntegration(ctx context.Context, authHeader bearertoken.Token, createIntegrationRequestArg CreateIntegrationRequest) (Integration, error) {
	var defaultReturnVal Integration
	var returnVal *Integration
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateIntegration"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/integrations"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(createIntegrationRequestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createIntegration failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createIntegration response cannot be nil")
	}
	return *returnVal, nil
}

func (c *integrationsServiceClient) DeleteIntegration(ctx context.Context, authHeader bearertoken.Token, integrationRidArg IntegrationRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("DeleteIntegration"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("DELETE"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/integrations/%s", url.PathEscape(fmt.Sprint(integrationRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "deleteIntegration failed")
	}
	return nil
}

func (c *integrationsServiceClient) UpdateIntegrationMetadata(ctx context.Context, authHeader bearertoken.Token, integrationRidArg IntegrationRid, requestArg UpdateIntegrationRequest) (Integration, error) {
	var defaultReturnVal Integration
	var returnVal *Integration
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateIntegrationMetadata"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/integrations/%s", url.PathEscape(fmt.Sprint(integrationRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateIntegrationMetadata failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateIntegrationMetadata response cannot be nil")
	}
	return *returnVal, nil
}

func (c *integrationsServiceClient) GetIntegration(ctx context.Context, authHeader bearertoken.Token, integrationRidArg IntegrationRid) (Integration, error) {
	var defaultReturnVal Integration
	var returnVal *Integration
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetIntegration"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/integrations/%s", url.PathEscape(fmt.Sprint(integrationRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getIntegration failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getIntegration response cannot be nil")
	}
	return *returnVal, nil
}

func (c *integrationsServiceClient) ListIntegrations(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) ([]Integration, error) {
	var returnVal []Integration
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ListIntegrations"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/integrations/list"))
	queryParams := make(url.Values)
	for _, v := range workspacesArg {
		queryParams.Add("workspaces", fmt.Sprint(v))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "listIntegrations failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "listIntegrations response cannot be nil")
	}
	return returnVal, nil
}

func (c *integrationsServiceClient) SendMessage(ctx context.Context, authHeader bearertoken.Token, requestArg SendMessageRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SendMessage"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/integrations/send-message"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "sendMessage failed")
	}
	return nil
}

// Service for managing integrations with external services.
type IntegrationsServiceClientWithAuth interface {
	// Generates link to request permissions for Slack bot to join workspaces and use a webhook.
	GenerateSlackWebhookLink(ctx context.Context, workspaceArg *rids.WorkspaceRid, isGovSlackArg *bool) (GenerateSlackWebhookResponse, error)
	// Creates a new Slack integration. Called internally after Slack authorization.
	CreateSlackWebhook(ctx context.Context, codeArg string, stateArg string) error
	// Creates a new integration.
	CreateIntegration(ctx context.Context, createIntegrationRequestArg CreateIntegrationRequest) (Integration, error)
	// Deletes an integration by archiving.
	DeleteIntegration(ctx context.Context, integrationRidArg IntegrationRid) error
	// Updates the metadata of an integration.
	UpdateIntegrationMetadata(ctx context.Context, integrationRidArg IntegrationRid, requestArg UpdateIntegrationRequest) (Integration, error)
	// Retrieves an integration with the specified integration RID.
	GetIntegration(ctx context.Context, integrationRidArg IntegrationRid) (Integration, error)
	// Lists all integrations. Archived integrations are not included.
	ListIntegrations(ctx context.Context, workspacesArg []rids.WorkspaceRid) ([]Integration, error)
	// Sends a string message to the specified integration from a checklist execution.
	SendMessage(ctx context.Context, requestArg SendMessageRequest) error
}

func NewIntegrationsServiceClientWithAuth(client IntegrationsServiceClient, authHeader bearertoken.Token) IntegrationsServiceClientWithAuth {
	return &integrationsServiceClientWithAuth{client: client, authHeader: authHeader}
}

type integrationsServiceClientWithAuth struct {
	client     IntegrationsServiceClient
	authHeader bearertoken.Token
}

func (c *integrationsServiceClientWithAuth) GenerateSlackWebhookLink(ctx context.Context, workspaceArg *rids.WorkspaceRid, isGovSlackArg *bool) (GenerateSlackWebhookResponse, error) {
	return c.client.GenerateSlackWebhookLink(ctx, c.authHeader, workspaceArg, isGovSlackArg)
}

func (c *integrationsServiceClientWithAuth) CreateSlackWebhook(ctx context.Context, codeArg string, stateArg string) error {
	return c.client.CreateSlackWebhook(ctx, c.authHeader, codeArg, stateArg)
}

func (c *integrationsServiceClientWithAuth) CreateIntegration(ctx context.Context, createIntegrationRequestArg CreateIntegrationRequest) (Integration, error) {
	return c.client.CreateIntegration(ctx, c.authHeader, createIntegrationRequestArg)
}

func (c *integrationsServiceClientWithAuth) DeleteIntegration(ctx context.Context, integrationRidArg IntegrationRid) error {
	return c.client.DeleteIntegration(ctx, c.authHeader, integrationRidArg)
}

func (c *integrationsServiceClientWithAuth) UpdateIntegrationMetadata(ctx context.Context, integrationRidArg IntegrationRid, requestArg UpdateIntegrationRequest) (Integration, error) {
	return c.client.UpdateIntegrationMetadata(ctx, c.authHeader, integrationRidArg, requestArg)
}

func (c *integrationsServiceClientWithAuth) GetIntegration(ctx context.Context, integrationRidArg IntegrationRid) (Integration, error) {
	return c.client.GetIntegration(ctx, c.authHeader, integrationRidArg)
}

func (c *integrationsServiceClientWithAuth) ListIntegrations(ctx context.Context, workspacesArg []rids.WorkspaceRid) ([]Integration, error) {
	return c.client.ListIntegrations(ctx, c.authHeader, workspacesArg)
}

func (c *integrationsServiceClientWithAuth) SendMessage(ctx context.Context, requestArg SendMessageRequest) error {
	return c.client.SendMessage(ctx, c.authHeader, requestArg)
}

func NewIntegrationsServiceClientWithTokenProvider(client IntegrationsServiceClient, tokenProvider httpclient.TokenProvider) IntegrationsServiceClientWithAuth {
	return &integrationsServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type integrationsServiceClientWithTokenProvider struct {
	client        IntegrationsServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *integrationsServiceClientWithTokenProvider) GenerateSlackWebhookLink(ctx context.Context, workspaceArg *rids.WorkspaceRid, isGovSlackArg *bool) (GenerateSlackWebhookResponse, error) {
	var defaultReturnVal GenerateSlackWebhookResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GenerateSlackWebhookLink(ctx, bearertoken.Token(token), workspaceArg, isGovSlackArg)
}

func (c *integrationsServiceClientWithTokenProvider) CreateSlackWebhook(ctx context.Context, codeArg string, stateArg string) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.CreateSlackWebhook(ctx, bearertoken.Token(token), codeArg, stateArg)
}

func (c *integrationsServiceClientWithTokenProvider) CreateIntegration(ctx context.Context, createIntegrationRequestArg CreateIntegrationRequest) (Integration, error) {
	var defaultReturnVal Integration
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateIntegration(ctx, bearertoken.Token(token), createIntegrationRequestArg)
}

func (c *integrationsServiceClientWithTokenProvider) DeleteIntegration(ctx context.Context, integrationRidArg IntegrationRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.DeleteIntegration(ctx, bearertoken.Token(token), integrationRidArg)
}

func (c *integrationsServiceClientWithTokenProvider) UpdateIntegrationMetadata(ctx context.Context, integrationRidArg IntegrationRid, requestArg UpdateIntegrationRequest) (Integration, error) {
	var defaultReturnVal Integration
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateIntegrationMetadata(ctx, bearertoken.Token(token), integrationRidArg, requestArg)
}

func (c *integrationsServiceClientWithTokenProvider) GetIntegration(ctx context.Context, integrationRidArg IntegrationRid) (Integration, error) {
	var defaultReturnVal Integration
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetIntegration(ctx, bearertoken.Token(token), integrationRidArg)
}

func (c *integrationsServiceClientWithTokenProvider) ListIntegrations(ctx context.Context, workspacesArg []rids.WorkspaceRid) ([]Integration, error) {
	var defaultReturnVal []Integration
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ListIntegrations(ctx, bearertoken.Token(token), workspacesArg)
}

func (c *integrationsServiceClientWithTokenProvider) SendMessage(ctx context.Context, requestArg SendMessageRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.SendMessage(ctx, bearertoken.Token(token), requestArg)
}
