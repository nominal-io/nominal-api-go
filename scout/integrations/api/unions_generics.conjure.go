// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"
)

type CreateIntegrationDetailsWithT[T any] CreateIntegrationDetails

func (u *CreateIntegrationDetailsWithT[T]) Accept(ctx context.Context, v CreateIntegrationDetailsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "createSimpleWebhookDetails":
		if u.createSimpleWebhookDetails == nil {
			return result, fmt.Errorf("field \"createSimpleWebhookDetails\" is required")
		}
		return v.VisitCreateSimpleWebhookDetails(ctx, *u.createSimpleWebhookDetails)
	case "createOpsgenieIntegrationDetails":
		if u.createOpsgenieIntegrationDetails == nil {
			return result, fmt.Errorf("field \"createOpsgenieIntegrationDetails\" is required")
		}
		return v.VisitCreateOpsgenieIntegrationDetails(ctx, *u.createOpsgenieIntegrationDetails)
	}
}

func (u *CreateIntegrationDetailsWithT[T]) AcceptFuncs(createSimpleWebhookDetailsFunc func(CreateSimpleWebhookDetails) (T, error), createOpsgenieIntegrationDetailsFunc func(CreateOpsgenieIntegrationDetails) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "createSimpleWebhookDetails":
		if u.createSimpleWebhookDetails == nil {
			return result, fmt.Errorf("field \"createSimpleWebhookDetails\" is required")
		}
		return createSimpleWebhookDetailsFunc(*u.createSimpleWebhookDetails)
	case "createOpsgenieIntegrationDetails":
		if u.createOpsgenieIntegrationDetails == nil {
			return result, fmt.Errorf("field \"createOpsgenieIntegrationDetails\" is required")
		}
		return createOpsgenieIntegrationDetailsFunc(*u.createOpsgenieIntegrationDetails)
	}
}

func (u *CreateIntegrationDetailsWithT[T]) CreateSimpleWebhookDetailsNoopSuccess(CreateSimpleWebhookDetails) (T, error) {
	var result T
	return result, nil
}

func (u *CreateIntegrationDetailsWithT[T]) CreateOpsgenieIntegrationDetailsNoopSuccess(CreateOpsgenieIntegrationDetails) (T, error) {
	var result T
	return result, nil
}

func (u *CreateIntegrationDetailsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CreateIntegrationDetailsVisitorWithT[T any] interface {
	VisitCreateSimpleWebhookDetails(ctx context.Context, v CreateSimpleWebhookDetails) (T, error)
	VisitCreateOpsgenieIntegrationDetails(ctx context.Context, v CreateOpsgenieIntegrationDetails) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type IntegrationDetailsWithT[T any] IntegrationDetails

func (u *IntegrationDetailsWithT[T]) Accept(ctx context.Context, v IntegrationDetailsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "slackWebhookIntegration":
		if u.slackWebhookIntegration == nil {
			return result, fmt.Errorf("field \"slackWebhookIntegration\" is required")
		}
		return v.VisitSlackWebhookIntegration(ctx, *u.slackWebhookIntegration)
	case "opsgenieIntegration":
		if u.opsgenieIntegration == nil {
			return result, fmt.Errorf("field \"opsgenieIntegration\" is required")
		}
		return v.VisitOpsgenieIntegration(ctx, *u.opsgenieIntegration)
	case "simpleWebhookIntegration":
		if u.simpleWebhookIntegration == nil {
			return result, fmt.Errorf("field \"simpleWebhookIntegration\" is required")
		}
		return v.VisitSimpleWebhookIntegration(ctx, *u.simpleWebhookIntegration)
	}
}

func (u *IntegrationDetailsWithT[T]) AcceptFuncs(slackWebhookIntegrationFunc func(SlackWebhookIntegration) (T, error), opsgenieIntegrationFunc func(OpsgenieIntegration) (T, error), simpleWebhookIntegrationFunc func(SimpleWebhookIntegration) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "slackWebhookIntegration":
		if u.slackWebhookIntegration == nil {
			return result, fmt.Errorf("field \"slackWebhookIntegration\" is required")
		}
		return slackWebhookIntegrationFunc(*u.slackWebhookIntegration)
	case "opsgenieIntegration":
		if u.opsgenieIntegration == nil {
			return result, fmt.Errorf("field \"opsgenieIntegration\" is required")
		}
		return opsgenieIntegrationFunc(*u.opsgenieIntegration)
	case "simpleWebhookIntegration":
		if u.simpleWebhookIntegration == nil {
			return result, fmt.Errorf("field \"simpleWebhookIntegration\" is required")
		}
		return simpleWebhookIntegrationFunc(*u.simpleWebhookIntegration)
	}
}

func (u *IntegrationDetailsWithT[T]) SlackWebhookIntegrationNoopSuccess(SlackWebhookIntegration) (T, error) {
	var result T
	return result, nil
}

func (u *IntegrationDetailsWithT[T]) OpsgenieIntegrationNoopSuccess(OpsgenieIntegration) (T, error) {
	var result T
	return result, nil
}

func (u *IntegrationDetailsWithT[T]) SimpleWebhookIntegrationNoopSuccess(SimpleWebhookIntegration) (T, error) {
	var result T
	return result, nil
}

func (u *IntegrationDetailsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type IntegrationDetailsVisitorWithT[T any] interface {
	VisitSlackWebhookIntegration(ctx context.Context, v SlackWebhookIntegration) (T, error)
	VisitOpsgenieIntegration(ctx context.Context, v OpsgenieIntegration) (T, error)
	VisitSimpleWebhookIntegration(ctx context.Context, v SimpleWebhookIntegration) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
