// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/rids/api"
)

type SearchTemplatesQueryWithT[T any] SearchTemplatesQuery

func (u *SearchTemplatesQueryWithT[T]) Accept(ctx context.Context, v SearchTemplatesQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "exactMatch":
		if u.exactMatch == nil {
			return result, fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatch(ctx, *u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(ctx, *u.searchText)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(ctx, *u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	case "createdBy":
		if u.createdBy == nil {
			return result, fmt.Errorf("field \"createdBy\" is required")
		}
		return v.VisitCreatedBy(ctx, *u.createdBy)
	case "isArchived":
		if u.isArchived == nil {
			return result, fmt.Errorf("field \"isArchived\" is required")
		}
		return v.VisitIsArchived(ctx, *u.isArchived)
	case "isPublished":
		if u.isPublished == nil {
			return result, fmt.Errorf("field \"isPublished\" is required")
		}
		return v.VisitIsPublished(ctx, *u.isPublished)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	}
}

func (u *SearchTemplatesQueryWithT[T]) AcceptFuncs(andFunc func([]SearchTemplatesQuery) (T, error), orFunc func([]SearchTemplatesQuery) (T, error), exactMatchFunc func(string) (T, error), searchTextFunc func(string) (T, error), labelFunc func(api.Label) (T, error), propertyFunc func(api.Property) (T, error), createdByFunc func(api1.UserRid) (T, error), isArchivedFunc func(bool) (T, error), isPublishedFunc func(bool) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "exactMatch":
		if u.exactMatch == nil {
			return result, fmt.Errorf("field \"exactMatch\" is required")
		}
		return exactMatchFunc(*u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "createdBy":
		if u.createdBy == nil {
			return result, fmt.Errorf("field \"createdBy\" is required")
		}
		return createdByFunc(*u.createdBy)
	case "isArchived":
		if u.isArchived == nil {
			return result, fmt.Errorf("field \"isArchived\" is required")
		}
		return isArchivedFunc(*u.isArchived)
	case "isPublished":
		if u.isPublished == nil {
			return result, fmt.Errorf("field \"isPublished\" is required")
		}
		return isPublishedFunc(*u.isPublished)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchTemplatesQueryWithT[T]) AndNoopSuccess([]SearchTemplatesQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTemplatesQueryWithT[T]) OrNoopSuccess([]SearchTemplatesQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTemplatesQueryWithT[T]) ExactMatchNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTemplatesQueryWithT[T]) SearchTextNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTemplatesQueryWithT[T]) LabelNoopSuccess(api.Label) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTemplatesQueryWithT[T]) PropertyNoopSuccess(api.Property) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTemplatesQueryWithT[T]) CreatedByNoopSuccess(api1.UserRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTemplatesQueryWithT[T]) IsArchivedNoopSuccess(bool) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTemplatesQueryWithT[T]) IsPublishedNoopSuccess(bool) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTemplatesQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTemplatesQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchTemplatesQueryVisitorWithT[T any] interface {
	VisitAnd(ctx context.Context, v []SearchTemplatesQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchTemplatesQuery) (T, error)
	VisitExactMatch(ctx context.Context, v string) (T, error)
	VisitSearchText(ctx context.Context, v string) (T, error)
	VisitLabel(ctx context.Context, v api.Label) (T, error)
	VisitProperty(ctx context.Context, v api.Property) (T, error)
	VisitCreatedBy(ctx context.Context, v api1.UserRid) (T, error)
	VisitIsArchived(ctx context.Context, v bool) (T, error)
	VisitIsPublished(ctx context.Context, v bool) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
