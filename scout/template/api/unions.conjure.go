// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api/scout/rids/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type SearchTemplatesQuery struct {
	typ         string
	and         *[]SearchTemplatesQuery
	or          *[]SearchTemplatesQuery
	exactMatch  *string
	searchText  *string
	label       *api.Label
	property    *api.Property
	createdBy   *api1.UserRid
	isArchived  *bool
	isPublished *bool
	workspace   *rids.WorkspaceRid
}

type searchTemplatesQueryDeserializer struct {
	Type        string                  `json:"type"`
	And         *[]SearchTemplatesQuery `json:"and"`
	Or          *[]SearchTemplatesQuery `json:"or"`
	ExactMatch  *string                 `json:"exactMatch"`
	SearchText  *string                 `json:"searchText"`
	Label       *api.Label              `json:"label"`
	Property    *api.Property           `json:"property"`
	CreatedBy   *api1.UserRid           `json:"createdBy"`
	IsArchived  *bool                   `json:"isArchived"`
	IsPublished *bool                   `json:"isPublished"`
	Workspace   *rids.WorkspaceRid      `json:"workspace"`
}

func (u *searchTemplatesQueryDeserializer) toStruct() SearchTemplatesQuery {
	return SearchTemplatesQuery{typ: u.Type, and: u.And, or: u.Or, exactMatch: u.ExactMatch, searchText: u.SearchText, label: u.Label, property: u.Property, createdBy: u.CreatedBy, isArchived: u.IsArchived, isPublished: u.IsPublished, workspace: u.Workspace}
}

func (u *SearchTemplatesQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string                 `json:"type"`
			And  []SearchTemplatesQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string                 `json:"type"`
			Or   []SearchTemplatesQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "exactMatch":
		if u.exactMatch == nil {
			return nil, fmt.Errorf("field \"exactMatch\" is required")
		}
		return struct {
			Type       string `json:"type"`
			ExactMatch string `json:"exactMatch"`
		}{Type: "exactMatch", ExactMatch: *u.exactMatch}, nil
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "label":
		if u.label == nil {
			return nil, fmt.Errorf("field \"label\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Label api.Label `json:"label"`
		}{Type: "label", Label: *u.label}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Property api.Property `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "createdBy":
		if u.createdBy == nil {
			return nil, fmt.Errorf("field \"createdBy\" is required")
		}
		return struct {
			Type      string       `json:"type"`
			CreatedBy api1.UserRid `json:"createdBy"`
		}{Type: "createdBy", CreatedBy: *u.createdBy}, nil
	case "isArchived":
		if u.isArchived == nil {
			return nil, fmt.Errorf("field \"isArchived\" is required")
		}
		return struct {
			Type       string `json:"type"`
			IsArchived bool   `json:"isArchived"`
		}{Type: "isArchived", IsArchived: *u.isArchived}, nil
	case "isPublished":
		if u.isPublished == nil {
			return nil, fmt.Errorf("field \"isPublished\" is required")
		}
		return struct {
			Type        string `json:"type"`
			IsPublished bool   `json:"isPublished"`
		}{Type: "isPublished", IsPublished: *u.isPublished}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	}
}

func (u SearchTemplatesQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchTemplatesQuery) UnmarshalJSON(data []byte) error {
	var deser searchTemplatesQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
	case "isArchived":
		if u.isArchived == nil {
			return fmt.Errorf("field \"isArchived\" is required")
		}
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	}
	return nil
}

func (u SearchTemplatesQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchTemplatesQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchTemplatesQuery) AcceptFuncs(andFunc func([]SearchTemplatesQuery) error, orFunc func([]SearchTemplatesQuery) error, exactMatchFunc func(string) error, searchTextFunc func(string) error, labelFunc func(api.Label) error, propertyFunc func(api.Property) error, createdByFunc func(api1.UserRid) error, isArchivedFunc func(bool) error, isPublishedFunc func(bool) error, workspaceFunc func(rids.WorkspaceRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return exactMatchFunc(*u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
		return createdByFunc(*u.createdBy)
	case "isArchived":
		if u.isArchived == nil {
			return fmt.Errorf("field \"isArchived\" is required")
		}
		return isArchivedFunc(*u.isArchived)
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
		return isPublishedFunc(*u.isPublished)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchTemplatesQuery) AndNoopSuccess([]SearchTemplatesQuery) error {
	return nil
}

func (u *SearchTemplatesQuery) OrNoopSuccess([]SearchTemplatesQuery) error {
	return nil
}

func (u *SearchTemplatesQuery) ExactMatchNoopSuccess(string) error {
	return nil
}

func (u *SearchTemplatesQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *SearchTemplatesQuery) LabelNoopSuccess(api.Label) error {
	return nil
}

func (u *SearchTemplatesQuery) PropertyNoopSuccess(api.Property) error {
	return nil
}

func (u *SearchTemplatesQuery) CreatedByNoopSuccess(api1.UserRid) error {
	return nil
}

func (u *SearchTemplatesQuery) IsArchivedNoopSuccess(bool) error {
	return nil
}

func (u *SearchTemplatesQuery) IsPublishedNoopSuccess(bool) error {
	return nil
}

func (u *SearchTemplatesQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *SearchTemplatesQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchTemplatesQuery) Accept(v SearchTemplatesQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatch(*u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
		return v.VisitCreatedBy(*u.createdBy)
	case "isArchived":
		if u.isArchived == nil {
			return fmt.Errorf("field \"isArchived\" is required")
		}
		return v.VisitIsArchived(*u.isArchived)
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
		return v.VisitIsPublished(*u.isPublished)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	}
}

type SearchTemplatesQueryVisitor interface {
	VisitAnd(v []SearchTemplatesQuery) error
	VisitOr(v []SearchTemplatesQuery) error
	VisitExactMatch(v string) error
	VisitSearchText(v string) error
	VisitLabel(v api.Label) error
	VisitProperty(v api.Property) error
	VisitCreatedBy(v api1.UserRid) error
	VisitIsArchived(v bool) error
	VisitIsPublished(v bool) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitUnknown(typeName string) error
}

func (u *SearchTemplatesQuery) AcceptWithContext(ctx context.Context, v SearchTemplatesQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatchWithContext(ctx, *u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabelWithContext(ctx, *u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
		return v.VisitCreatedByWithContext(ctx, *u.createdBy)
	case "isArchived":
		if u.isArchived == nil {
			return fmt.Errorf("field \"isArchived\" is required")
		}
		return v.VisitIsArchivedWithContext(ctx, *u.isArchived)
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
		return v.VisitIsPublishedWithContext(ctx, *u.isPublished)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	}
}

type SearchTemplatesQueryVisitorWithContext interface {
	VisitAndWithContext(ctx context.Context, v []SearchTemplatesQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchTemplatesQuery) error
	VisitExactMatchWithContext(ctx context.Context, v string) error
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitLabelWithContext(ctx context.Context, v api.Label) error
	VisitPropertyWithContext(ctx context.Context, v api.Property) error
	VisitCreatedByWithContext(ctx context.Context, v api1.UserRid) error
	VisitIsArchivedWithContext(ctx context.Context, v bool) error
	VisitIsPublishedWithContext(ctx context.Context, v bool) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchTemplatesQueryFromAnd(v []SearchTemplatesQuery) SearchTemplatesQuery {
	return SearchTemplatesQuery{typ: "and", and: &v}
}

func NewSearchTemplatesQueryFromOr(v []SearchTemplatesQuery) SearchTemplatesQuery {
	return SearchTemplatesQuery{typ: "or", or: &v}
}

func NewSearchTemplatesQueryFromExactMatch(v string) SearchTemplatesQuery {
	return SearchTemplatesQuery{typ: "exactMatch", exactMatch: &v}
}

func NewSearchTemplatesQueryFromSearchText(v string) SearchTemplatesQuery {
	return SearchTemplatesQuery{typ: "searchText", searchText: &v}
}

func NewSearchTemplatesQueryFromLabel(v api.Label) SearchTemplatesQuery {
	return SearchTemplatesQuery{typ: "label", label: &v}
}

func NewSearchTemplatesQueryFromProperty(v api.Property) SearchTemplatesQuery {
	return SearchTemplatesQuery{typ: "property", property: &v}
}

func NewSearchTemplatesQueryFromCreatedBy(v api1.UserRid) SearchTemplatesQuery {
	return SearchTemplatesQuery{typ: "createdBy", createdBy: &v}
}

func NewSearchTemplatesQueryFromIsArchived(v bool) SearchTemplatesQuery {
	return SearchTemplatesQuery{typ: "isArchived", isArchived: &v}
}

func NewSearchTemplatesQueryFromIsPublished(v bool) SearchTemplatesQuery {
	return SearchTemplatesQuery{typ: "isPublished", isPublished: &v}
}

func NewSearchTemplatesQueryFromWorkspace(v rids.WorkspaceRid) SearchTemplatesQuery {
	return SearchTemplatesQuery{typ: "workspace", workspace: &v}
}
