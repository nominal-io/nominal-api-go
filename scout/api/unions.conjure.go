// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type Color struct {
	typ     string
	hexCode *string
}

type colorDeserializer struct {
	Type    string  `json:"type"`
	HexCode *string `json:"hexCode"`
}

func (u *colorDeserializer) toStruct() Color {
	return Color{typ: u.Type, hexCode: u.HexCode}
}

func (u *Color) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "hexCode":
		if u.hexCode == nil {
			return nil, fmt.Errorf("field \"hexCode\" is required")
		}
		return struct {
			Type    string `json:"type"`
			HexCode string `json:"hexCode"`
		}{Type: "hexCode", HexCode: *u.hexCode}, nil
	}
}

func (u Color) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Color) UnmarshalJSON(data []byte) error {
	var deser colorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "hexCode":
		if u.hexCode == nil {
			return fmt.Errorf("field \"hexCode\" is required")
		}
	}
	return nil
}

func (u Color) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Color) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Color) AcceptFuncs(hexCodeFunc func(string) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "hexCode":
		if u.hexCode == nil {
			return fmt.Errorf("field \"hexCode\" is required")
		}
		return hexCodeFunc(*u.hexCode)
	}
}

func (u *Color) HexCodeNoopSuccess(string) error {
	return nil
}

func (u *Color) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Color) Accept(v ColorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "hexCode":
		if u.hexCode == nil {
			return fmt.Errorf("field \"hexCode\" is required")
		}
		return v.VisitHexCode(*u.hexCode)
	}
}

type ColorVisitor interface {
	VisitHexCode(v string) error
	VisitUnknown(typeName string) error
}

func (u *Color) AcceptWithContext(ctx context.Context, v ColorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "hexCode":
		if u.hexCode == nil {
			return fmt.Errorf("field \"hexCode\" is required")
		}
		return v.VisitHexCodeWithContext(ctx, *u.hexCode)
	}
}

type ColorVisitorWithContext interface {
	VisitHexCodeWithContext(ctx context.Context, v string) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewColorFromHexCode(v string) Color {
	return Color{typ: "hexCode", hexCode: &v}
}

type DispositionState struct {
	typ                     string
	pendingReview           *PendingReviewDispositionState
	closedWithFurtherAction *ClosedWithFurtherActionDispositionState
	closedWithIgnore        *ClosedWithIgnoreDispositionState
}

type dispositionStateDeserializer struct {
	Type                    string                                   `json:"type"`
	PendingReview           *PendingReviewDispositionState           `json:"pendingReview"`
	ClosedWithFurtherAction *ClosedWithFurtherActionDispositionState `json:"closedWithFurtherAction"`
	ClosedWithIgnore        *ClosedWithIgnoreDispositionState        `json:"closedWithIgnore"`
}

func (u *dispositionStateDeserializer) toStruct() DispositionState {
	return DispositionState{typ: u.Type, pendingReview: u.PendingReview, closedWithFurtherAction: u.ClosedWithFurtherAction, closedWithIgnore: u.ClosedWithIgnore}
}

func (u *DispositionState) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return nil, fmt.Errorf("field \"pendingReview\" is required")
		}
		return struct {
			Type          string                        `json:"type"`
			PendingReview PendingReviewDispositionState `json:"pendingReview"`
		}{Type: "pendingReview", PendingReview: *u.pendingReview}, nil
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return nil, fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return struct {
			Type                    string                                  `json:"type"`
			ClosedWithFurtherAction ClosedWithFurtherActionDispositionState `json:"closedWithFurtherAction"`
		}{Type: "closedWithFurtherAction", ClosedWithFurtherAction: *u.closedWithFurtherAction}, nil
	case "closedWithIgnore":
		if u.closedWithIgnore == nil {
			return nil, fmt.Errorf("field \"closedWithIgnore\" is required")
		}
		return struct {
			Type             string                           `json:"type"`
			ClosedWithIgnore ClosedWithIgnoreDispositionState `json:"closedWithIgnore"`
		}{Type: "closedWithIgnore", ClosedWithIgnore: *u.closedWithIgnore}, nil
	}
}

func (u DispositionState) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DispositionState) UnmarshalJSON(data []byte) error {
	var deser dispositionStateDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "pendingReview":
		if u.pendingReview == nil {
			return fmt.Errorf("field \"pendingReview\" is required")
		}
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
	case "closedWithIgnore":
		if u.closedWithIgnore == nil {
			return fmt.Errorf("field \"closedWithIgnore\" is required")
		}
	}
	return nil
}

func (u DispositionState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DispositionState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DispositionState) AcceptFuncs(pendingReviewFunc func(PendingReviewDispositionState) error, closedWithFurtherActionFunc func(ClosedWithFurtherActionDispositionState) error, closedWithIgnoreFunc func(ClosedWithIgnoreDispositionState) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return fmt.Errorf("field \"pendingReview\" is required")
		}
		return pendingReviewFunc(*u.pendingReview)
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return closedWithFurtherActionFunc(*u.closedWithFurtherAction)
	case "closedWithIgnore":
		if u.closedWithIgnore == nil {
			return fmt.Errorf("field \"closedWithIgnore\" is required")
		}
		return closedWithIgnoreFunc(*u.closedWithIgnore)
	}
}

func (u *DispositionState) PendingReviewNoopSuccess(PendingReviewDispositionState) error {
	return nil
}

func (u *DispositionState) ClosedWithFurtherActionNoopSuccess(ClosedWithFurtherActionDispositionState) error {
	return nil
}

func (u *DispositionState) ClosedWithIgnoreNoopSuccess(ClosedWithIgnoreDispositionState) error {
	return nil
}

func (u *DispositionState) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DispositionState) Accept(v DispositionStateVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return fmt.Errorf("field \"pendingReview\" is required")
		}
		return v.VisitPendingReview(*u.pendingReview)
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return v.VisitClosedWithFurtherAction(*u.closedWithFurtherAction)
	case "closedWithIgnore":
		if u.closedWithIgnore == nil {
			return fmt.Errorf("field \"closedWithIgnore\" is required")
		}
		return v.VisitClosedWithIgnore(*u.closedWithIgnore)
	}
}

type DispositionStateVisitor interface {
	VisitPendingReview(v PendingReviewDispositionState) error
	VisitClosedWithFurtherAction(v ClosedWithFurtherActionDispositionState) error
	VisitClosedWithIgnore(v ClosedWithIgnoreDispositionState) error
	VisitUnknown(typeName string) error
}

func (u *DispositionState) AcceptWithContext(ctx context.Context, v DispositionStateVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return fmt.Errorf("field \"pendingReview\" is required")
		}
		return v.VisitPendingReviewWithContext(ctx, *u.pendingReview)
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return v.VisitClosedWithFurtherActionWithContext(ctx, *u.closedWithFurtherAction)
	case "closedWithIgnore":
		if u.closedWithIgnore == nil {
			return fmt.Errorf("field \"closedWithIgnore\" is required")
		}
		return v.VisitClosedWithIgnoreWithContext(ctx, *u.closedWithIgnore)
	}
}

type DispositionStateVisitorWithContext interface {
	VisitPendingReviewWithContext(ctx context.Context, v PendingReviewDispositionState) error
	VisitClosedWithFurtherActionWithContext(ctx context.Context, v ClosedWithFurtherActionDispositionState) error
	VisitClosedWithIgnoreWithContext(ctx context.Context, v ClosedWithIgnoreDispositionState) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDispositionStateFromPendingReview(v PendingReviewDispositionState) DispositionState {
	return DispositionState{typ: "pendingReview", pendingReview: &v}
}

func NewDispositionStateFromClosedWithFurtherAction(v ClosedWithFurtherActionDispositionState) DispositionState {
	return DispositionState{typ: "closedWithFurtherAction", closedWithFurtherAction: &v}
}

func NewDispositionStateFromClosedWithIgnore(v ClosedWithIgnoreDispositionState) DispositionState {
	return DispositionState{typ: "closedWithIgnore", closedWithIgnore: &v}
}

type Symbol struct {
	typ   string
	icon  *string
	emoji *string
	image *string
}

type symbolDeserializer struct {
	Type  string  `json:"type"`
	Icon  *string `json:"icon"`
	Emoji *string `json:"emoji"`
	Image *string `json:"image"`
}

func (u *symbolDeserializer) toStruct() Symbol {
	return Symbol{typ: u.Type, icon: u.Icon, emoji: u.Emoji, image: u.Image}
}

func (u *Symbol) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "icon":
		if u.icon == nil {
			return nil, fmt.Errorf("field \"icon\" is required")
		}
		return struct {
			Type string `json:"type"`
			Icon string `json:"icon"`
		}{Type: "icon", Icon: *u.icon}, nil
	case "emoji":
		if u.emoji == nil {
			return nil, fmt.Errorf("field \"emoji\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Emoji string `json:"emoji"`
		}{Type: "emoji", Emoji: *u.emoji}, nil
	case "image":
		if u.image == nil {
			return nil, fmt.Errorf("field \"image\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Image string `json:"image"`
		}{Type: "image", Image: *u.image}, nil
	}
}

func (u Symbol) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Symbol) UnmarshalJSON(data []byte) error {
	var deser symbolDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "icon":
		if u.icon == nil {
			return fmt.Errorf("field \"icon\" is required")
		}
	case "emoji":
		if u.emoji == nil {
			return fmt.Errorf("field \"emoji\" is required")
		}
	case "image":
		if u.image == nil {
			return fmt.Errorf("field \"image\" is required")
		}
	}
	return nil
}

func (u Symbol) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Symbol) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Symbol) AcceptFuncs(iconFunc func(string) error, emojiFunc func(string) error, imageFunc func(string) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "icon":
		if u.icon == nil {
			return fmt.Errorf("field \"icon\" is required")
		}
		return iconFunc(*u.icon)
	case "emoji":
		if u.emoji == nil {
			return fmt.Errorf("field \"emoji\" is required")
		}
		return emojiFunc(*u.emoji)
	case "image":
		if u.image == nil {
			return fmt.Errorf("field \"image\" is required")
		}
		return imageFunc(*u.image)
	}
}

func (u *Symbol) IconNoopSuccess(string) error {
	return nil
}

func (u *Symbol) EmojiNoopSuccess(string) error {
	return nil
}

func (u *Symbol) ImageNoopSuccess(string) error {
	return nil
}

func (u *Symbol) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Symbol) Accept(v SymbolVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "icon":
		if u.icon == nil {
			return fmt.Errorf("field \"icon\" is required")
		}
		return v.VisitIcon(*u.icon)
	case "emoji":
		if u.emoji == nil {
			return fmt.Errorf("field \"emoji\" is required")
		}
		return v.VisitEmoji(*u.emoji)
	case "image":
		if u.image == nil {
			return fmt.Errorf("field \"image\" is required")
		}
		return v.VisitImage(*u.image)
	}
}

type SymbolVisitor interface {
	VisitIcon(v string) error
	VisitEmoji(v string) error
	VisitImage(v string) error
	VisitUnknown(typeName string) error
}

func (u *Symbol) AcceptWithContext(ctx context.Context, v SymbolVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "icon":
		if u.icon == nil {
			return fmt.Errorf("field \"icon\" is required")
		}
		return v.VisitIconWithContext(ctx, *u.icon)
	case "emoji":
		if u.emoji == nil {
			return fmt.Errorf("field \"emoji\" is required")
		}
		return v.VisitEmojiWithContext(ctx, *u.emoji)
	case "image":
		if u.image == nil {
			return fmt.Errorf("field \"image\" is required")
		}
		return v.VisitImageWithContext(ctx, *u.image)
	}
}

type SymbolVisitorWithContext interface {
	VisitIconWithContext(ctx context.Context, v string) error
	VisitEmojiWithContext(ctx context.Context, v string) error
	VisitImageWithContext(ctx context.Context, v string) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSymbolFromIcon(v string) Symbol {
	return Symbol{typ: "icon", icon: &v}
}

func NewSymbolFromEmoji(v string) Symbol {
	return Symbol{typ: "emoji", emoji: &v}
}

func NewSymbolFromImage(v string) Symbol {
	return Symbol{typ: "image", image: &v}
}
