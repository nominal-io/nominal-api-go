// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"
)

type ColorWithT[T any] Color

func (u *ColorWithT[T]) Accept(ctx context.Context, v ColorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "hexCode":
		if u.hexCode == nil {
			return result, fmt.Errorf("field \"hexCode\" is required")
		}
		return v.VisitHexCode(ctx, *u.hexCode)
	}
}

func (u *ColorWithT[T]) AcceptFuncs(hexCodeFunc func(string) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "hexCode":
		if u.hexCode == nil {
			return result, fmt.Errorf("field \"hexCode\" is required")
		}
		return hexCodeFunc(*u.hexCode)
	}
}

func (u *ColorWithT[T]) HexCodeNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *ColorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ColorVisitorWithT[T any] interface {
	VisitHexCode(ctx context.Context, v string) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type DispositionStateWithT[T any] DispositionState

func (u *DispositionStateWithT[T]) Accept(ctx context.Context, v DispositionStateVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return result, fmt.Errorf("field \"pendingReview\" is required")
		}
		return v.VisitPendingReview(ctx, *u.pendingReview)
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return v.VisitClosedWithFurtherAction(ctx, *u.closedWithFurtherAction)
	case "closedWithIgnore":
		if u.closedWithIgnore == nil {
			return result, fmt.Errorf("field \"closedWithIgnore\" is required")
		}
		return v.VisitClosedWithIgnore(ctx, *u.closedWithIgnore)
	}
}

func (u *DispositionStateWithT[T]) AcceptFuncs(pendingReviewFunc func(PendingReviewDispositionState) (T, error), closedWithFurtherActionFunc func(ClosedWithFurtherActionDispositionState) (T, error), closedWithIgnoreFunc func(ClosedWithIgnoreDispositionState) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return result, fmt.Errorf("field \"pendingReview\" is required")
		}
		return pendingReviewFunc(*u.pendingReview)
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return closedWithFurtherActionFunc(*u.closedWithFurtherAction)
	case "closedWithIgnore":
		if u.closedWithIgnore == nil {
			return result, fmt.Errorf("field \"closedWithIgnore\" is required")
		}
		return closedWithIgnoreFunc(*u.closedWithIgnore)
	}
}

func (u *DispositionStateWithT[T]) PendingReviewNoopSuccess(PendingReviewDispositionState) (T, error) {
	var result T
	return result, nil
}

func (u *DispositionStateWithT[T]) ClosedWithFurtherActionNoopSuccess(ClosedWithFurtherActionDispositionState) (T, error) {
	var result T
	return result, nil
}

func (u *DispositionStateWithT[T]) ClosedWithIgnoreNoopSuccess(ClosedWithIgnoreDispositionState) (T, error) {
	var result T
	return result, nil
}

func (u *DispositionStateWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DispositionStateVisitorWithT[T any] interface {
	VisitPendingReview(ctx context.Context, v PendingReviewDispositionState) (T, error)
	VisitClosedWithFurtherAction(ctx context.Context, v ClosedWithFurtherActionDispositionState) (T, error)
	VisitClosedWithIgnore(ctx context.Context, v ClosedWithIgnoreDispositionState) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SymbolWithT[T any] Symbol

func (u *SymbolWithT[T]) Accept(ctx context.Context, v SymbolVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "icon":
		if u.icon == nil {
			return result, fmt.Errorf("field \"icon\" is required")
		}
		return v.VisitIcon(ctx, *u.icon)
	case "emoji":
		if u.emoji == nil {
			return result, fmt.Errorf("field \"emoji\" is required")
		}
		return v.VisitEmoji(ctx, *u.emoji)
	case "image":
		if u.image == nil {
			return result, fmt.Errorf("field \"image\" is required")
		}
		return v.VisitImage(ctx, *u.image)
	}
}

func (u *SymbolWithT[T]) AcceptFuncs(iconFunc func(string) (T, error), emojiFunc func(string) (T, error), imageFunc func(string) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "icon":
		if u.icon == nil {
			return result, fmt.Errorf("field \"icon\" is required")
		}
		return iconFunc(*u.icon)
	case "emoji":
		if u.emoji == nil {
			return result, fmt.Errorf("field \"emoji\" is required")
		}
		return emojiFunc(*u.emoji)
	case "image":
		if u.image == nil {
			return result, fmt.Errorf("field \"image\" is required")
		}
		return imageFunc(*u.image)
	}
}

func (u *SymbolWithT[T]) IconNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SymbolWithT[T]) EmojiNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SymbolWithT[T]) ImageNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SymbolWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SymbolVisitorWithT[T any] interface {
	VisitIcon(ctx context.Context, v string) (T, error)
	VisitEmoji(ctx context.Context, v string) (T, error)
	VisitImage(ctx context.Context, v string) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
