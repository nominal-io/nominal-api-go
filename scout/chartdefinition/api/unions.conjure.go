// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/scout/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type AxisThresholdGroup struct {
	typ            string
	lineThresholds *LineThresholdGroup
}

type axisThresholdGroupDeserializer struct {
	Type           string              `json:"type"`
	LineThresholds *LineThresholdGroup `json:"lineThresholds"`
}

func (u *axisThresholdGroupDeserializer) toStruct() AxisThresholdGroup {
	return AxisThresholdGroup{typ: u.Type, lineThresholds: u.LineThresholds}
}

func (u *AxisThresholdGroup) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return nil, fmt.Errorf("field \"lineThresholds\" is required")
		}
		return struct {
			Type           string             `json:"type"`
			LineThresholds LineThresholdGroup `json:"lineThresholds"`
		}{Type: "lineThresholds", LineThresholds: *u.lineThresholds}, nil
	}
}

func (u AxisThresholdGroup) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *AxisThresholdGroup) UnmarshalJSON(data []byte) error {
	var deser axisThresholdGroupDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "lineThresholds":
		if u.lineThresholds == nil {
			return fmt.Errorf("field \"lineThresholds\" is required")
		}
	}
	return nil
}

func (u AxisThresholdGroup) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *AxisThresholdGroup) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *AxisThresholdGroup) AcceptFuncs(lineThresholdsFunc func(LineThresholdGroup) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return fmt.Errorf("field \"lineThresholds\" is required")
		}
		return lineThresholdsFunc(*u.lineThresholds)
	}
}

func (u *AxisThresholdGroup) LineThresholdsNoopSuccess(LineThresholdGroup) error {
	return nil
}

func (u *AxisThresholdGroup) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *AxisThresholdGroup) Accept(v AxisThresholdGroupVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return fmt.Errorf("field \"lineThresholds\" is required")
		}
		return v.VisitLineThresholds(*u.lineThresholds)
	}
}

type AxisThresholdGroupVisitor interface {
	VisitLineThresholds(v LineThresholdGroup) error
	VisitUnknown(typeName string) error
}

func (u *AxisThresholdGroup) AcceptWithContext(ctx context.Context, v AxisThresholdGroupVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return fmt.Errorf("field \"lineThresholds\" is required")
		}
		return v.VisitLineThresholdsWithContext(ctx, *u.lineThresholds)
	}
}

type AxisThresholdGroupVisitorWithContext interface {
	VisitLineThresholdsWithContext(ctx context.Context, v LineThresholdGroup) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAxisThresholdGroupFromLineThresholds(v LineThresholdGroup) AxisThresholdGroup {
	return AxisThresholdGroup{typ: "lineThresholds", lineThresholds: &v}
}

type BitFlagMapVisualisation struct {
	typ string
	raw *BitFlagMapRawVisualisation
}

type bitFlagMapVisualisationDeserializer struct {
	Type string                      `json:"type"`
	Raw  *BitFlagMapRawVisualisation `json:"raw"`
}

func (u *bitFlagMapVisualisationDeserializer) toStruct() BitFlagMapVisualisation {
	return BitFlagMapVisualisation{typ: u.Type, raw: u.Raw}
}

func (u *BitFlagMapVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                     `json:"type"`
			Raw  BitFlagMapRawVisualisation `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u BitFlagMapVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *BitFlagMapVisualisation) UnmarshalJSON(data []byte) error {
	var deser bitFlagMapVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u BitFlagMapVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *BitFlagMapVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *BitFlagMapVisualisation) AcceptFuncs(rawFunc func(BitFlagMapRawVisualisation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *BitFlagMapVisualisation) RawNoopSuccess(BitFlagMapRawVisualisation) error {
	return nil
}

func (u *BitFlagMapVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *BitFlagMapVisualisation) Accept(v BitFlagMapVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type BitFlagMapVisualisationVisitor interface {
	VisitRaw(v BitFlagMapRawVisualisation) error
	VisitUnknown(typeName string) error
}

func (u *BitFlagMapVisualisation) AcceptWithContext(ctx context.Context, v BitFlagMapVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type BitFlagMapVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v BitFlagMapRawVisualisation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewBitFlagMapVisualisationFromRaw(v BitFlagMapRawVisualisation) BitFlagMapVisualisation {
	return BitFlagMapVisualisation{typ: "raw", raw: &v}
}

type CartesianChartDefinition struct {
	typ string
	v1  *CartesianChartDefinitionV1
}

type cartesianChartDefinitionDeserializer struct {
	Type string                      `json:"type"`
	V1   *CartesianChartDefinitionV1 `json:"v1"`
}

func (u *cartesianChartDefinitionDeserializer) toStruct() CartesianChartDefinition {
	return CartesianChartDefinition{typ: u.Type, v1: u.V1}
}

func (u *CartesianChartDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                     `json:"type"`
			V1   CartesianChartDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u CartesianChartDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CartesianChartDefinition) UnmarshalJSON(data []byte) error {
	var deser cartesianChartDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u CartesianChartDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CartesianChartDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CartesianChartDefinition) AcceptFuncs(v1Func func(CartesianChartDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *CartesianChartDefinition) V1NoopSuccess(CartesianChartDefinitionV1) error {
	return nil
}

func (u *CartesianChartDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CartesianChartDefinition) Accept(v CartesianChartDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type CartesianChartDefinitionVisitor interface {
	VisitV1(v CartesianChartDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *CartesianChartDefinition) AcceptWithContext(ctx context.Context, v CartesianChartDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type CartesianChartDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v CartesianChartDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCartesianChartDefinitionFromV1(v CartesianChartDefinitionV1) CartesianChartDefinition {
	return CartesianChartDefinition{typ: "v1", v1: &v}
}

type ChecklistChartDefinition struct {
	typ string
	v1  *ChecklistChartDefinitionV1
}

type checklistChartDefinitionDeserializer struct {
	Type string                      `json:"type"`
	V1   *ChecklistChartDefinitionV1 `json:"v1"`
}

func (u *checklistChartDefinitionDeserializer) toStruct() ChecklistChartDefinition {
	return ChecklistChartDefinition{typ: u.Type, v1: u.V1}
}

func (u *ChecklistChartDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                     `json:"type"`
			V1   ChecklistChartDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u ChecklistChartDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ChecklistChartDefinition) UnmarshalJSON(data []byte) error {
	var deser checklistChartDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u ChecklistChartDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ChecklistChartDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ChecklistChartDefinition) AcceptFuncs(v1Func func(ChecklistChartDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ChecklistChartDefinition) V1NoopSuccess(ChecklistChartDefinitionV1) error {
	return nil
}

func (u *ChecklistChartDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ChecklistChartDefinition) Accept(v ChecklistChartDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type ChecklistChartDefinitionVisitor interface {
	VisitV1(v ChecklistChartDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *ChecklistChartDefinition) AcceptWithContext(ctx context.Context, v ChecklistChartDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type ChecklistChartDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v ChecklistChartDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewChecklistChartDefinitionFromV1(v ChecklistChartDefinitionV1) ChecklistChartDefinition {
	return ChecklistChartDefinition{typ: "v1", v1: &v}
}

type ColorStyle struct {
	typ    string
	mapped *map[string]api.HexColor
	single *api.HexColor
}

type colorStyleDeserializer struct {
	Type   string                   `json:"type"`
	Mapped *map[string]api.HexColor `json:"mapped"`
	Single *api.HexColor            `json:"single"`
}

func (u *colorStyleDeserializer) toStruct() ColorStyle {
	return ColorStyle{typ: u.Type, mapped: u.Mapped, single: u.Single}
}

func (u *ColorStyle) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "mapped":
		if u.mapped == nil {
			return nil, fmt.Errorf("field \"mapped\" is required")
		}
		return struct {
			Type   string                  `json:"type"`
			Mapped map[string]api.HexColor `json:"mapped"`
		}{Type: "mapped", Mapped: *u.mapped}, nil
	case "single":
		if u.single == nil {
			return nil, fmt.Errorf("field \"single\" is required")
		}
		return struct {
			Type   string       `json:"type"`
			Single api.HexColor `json:"single"`
		}{Type: "single", Single: *u.single}, nil
	}
}

func (u ColorStyle) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ColorStyle) UnmarshalJSON(data []byte) error {
	var deser colorStyleDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "mapped":
		if u.mapped == nil {
			return fmt.Errorf("field \"mapped\" is required")
		}
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
	}
	return nil
}

func (u ColorStyle) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ColorStyle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ColorStyle) AcceptFuncs(mappedFunc func(map[string]api.HexColor) error, singleFunc func(api.HexColor) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "mapped":
		if u.mapped == nil {
			return fmt.Errorf("field \"mapped\" is required")
		}
		return mappedFunc(*u.mapped)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	}
}

func (u *ColorStyle) MappedNoopSuccess(map[string]api.HexColor) error {
	return nil
}

func (u *ColorStyle) SingleNoopSuccess(api.HexColor) error {
	return nil
}

func (u *ColorStyle) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ColorStyle) Accept(v ColorStyleVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "mapped":
		if u.mapped == nil {
			return fmt.Errorf("field \"mapped\" is required")
		}
		return v.VisitMapped(*u.mapped)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(*u.single)
	}
}

type ColorStyleVisitor interface {
	VisitMapped(v map[string]api.HexColor) error
	VisitSingle(v api.HexColor) error
	VisitUnknown(typeName string) error
}

func (u *ColorStyle) AcceptWithContext(ctx context.Context, v ColorStyleVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "mapped":
		if u.mapped == nil {
			return fmt.Errorf("field \"mapped\" is required")
		}
		return v.VisitMappedWithContext(ctx, *u.mapped)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingleWithContext(ctx, *u.single)
	}
}

type ColorStyleVisitorWithContext interface {
	VisitMappedWithContext(ctx context.Context, v map[string]api.HexColor) error
	VisitSingleWithContext(ctx context.Context, v api.HexColor) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewColorStyleFromMapped(v map[string]api.HexColor) ColorStyle {
	return ColorStyle{typ: "mapped", mapped: &v}
}

func NewColorStyleFromSingle(v api.HexColor) ColorStyle {
	return ColorStyle{typ: "single", single: &v}
}

type DecimalPlaces struct {
	typ   string
	fixed *FixedDecimalPlaces
	max   *MaxDecimalPlaces
}

type decimalPlacesDeserializer struct {
	Type  string              `json:"type"`
	Fixed *FixedDecimalPlaces `json:"fixed"`
	Max   *MaxDecimalPlaces   `json:"max"`
}

func (u *decimalPlacesDeserializer) toStruct() DecimalPlaces {
	return DecimalPlaces{typ: u.Type, fixed: u.Fixed, max: u.Max}
}

func (u *DecimalPlaces) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "fixed":
		if u.fixed == nil {
			return nil, fmt.Errorf("field \"fixed\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Fixed FixedDecimalPlaces `json:"fixed"`
		}{Type: "fixed", Fixed: *u.fixed}, nil
	case "max":
		if u.max == nil {
			return nil, fmt.Errorf("field \"max\" is required")
		}
		return struct {
			Type string           `json:"type"`
			Max  MaxDecimalPlaces `json:"max"`
		}{Type: "max", Max: *u.max}, nil
	}
}

func (u DecimalPlaces) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DecimalPlaces) UnmarshalJSON(data []byte) error {
	var deser decimalPlacesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
	}
	return nil
}

func (u DecimalPlaces) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DecimalPlaces) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DecimalPlaces) AcceptFuncs(fixedFunc func(FixedDecimalPlaces) error, maxFunc func(MaxDecimalPlaces) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
		return fixedFunc(*u.fixed)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	}
}

func (u *DecimalPlaces) FixedNoopSuccess(FixedDecimalPlaces) error {
	return nil
}

func (u *DecimalPlaces) MaxNoopSuccess(MaxDecimalPlaces) error {
	return nil
}

func (u *DecimalPlaces) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DecimalPlaces) Accept(v DecimalPlacesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
		return v.VisitFixed(*u.fixed)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(*u.max)
	}
}

type DecimalPlacesVisitor interface {
	VisitFixed(v FixedDecimalPlaces) error
	VisitMax(v MaxDecimalPlaces) error
	VisitUnknown(typeName string) error
}

func (u *DecimalPlaces) AcceptWithContext(ctx context.Context, v DecimalPlacesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
		return v.VisitFixedWithContext(ctx, *u.fixed)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMaxWithContext(ctx, *u.max)
	}
}

type DecimalPlacesVisitorWithContext interface {
	VisitFixedWithContext(ctx context.Context, v FixedDecimalPlaces) error
	VisitMaxWithContext(ctx context.Context, v MaxDecimalPlaces) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDecimalPlacesFromFixed(v FixedDecimalPlaces) DecimalPlaces {
	return DecimalPlaces{typ: "fixed", fixed: &v}
}

func NewDecimalPlacesFromMax(v MaxDecimalPlaces) DecimalPlaces {
	return DecimalPlaces{typ: "max", max: &v}
}

type DisconnectedValueVisualization struct {
	typ           string
	alwaysConnect *AlwaysConnectDisconnectedValues
	never         *NeverConnectDisconnectedValues
	threshold     *ThresholdDisconnectedValues
}

type disconnectedValueVisualizationDeserializer struct {
	Type          string                           `json:"type"`
	AlwaysConnect *AlwaysConnectDisconnectedValues `json:"alwaysConnect"`
	Never         *NeverConnectDisconnectedValues  `json:"never"`
	Threshold     *ThresholdDisconnectedValues     `json:"threshold"`
}

func (u *disconnectedValueVisualizationDeserializer) toStruct() DisconnectedValueVisualization {
	return DisconnectedValueVisualization{typ: u.Type, alwaysConnect: u.AlwaysConnect, never: u.Never, threshold: u.Threshold}
}

func (u *DisconnectedValueVisualization) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return nil, fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return struct {
			Type          string                          `json:"type"`
			AlwaysConnect AlwaysConnectDisconnectedValues `json:"alwaysConnect"`
		}{Type: "alwaysConnect", AlwaysConnect: *u.alwaysConnect}, nil
	case "never":
		if u.never == nil {
			return nil, fmt.Errorf("field \"never\" is required")
		}
		return struct {
			Type  string                         `json:"type"`
			Never NeverConnectDisconnectedValues `json:"never"`
		}{Type: "never", Never: *u.never}, nil
	case "threshold":
		if u.threshold == nil {
			return nil, fmt.Errorf("field \"threshold\" is required")
		}
		return struct {
			Type      string                      `json:"type"`
			Threshold ThresholdDisconnectedValues `json:"threshold"`
		}{Type: "threshold", Threshold: *u.threshold}, nil
	}
}

func (u DisconnectedValueVisualization) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DisconnectedValueVisualization) UnmarshalJSON(data []byte) error {
	var deser disconnectedValueVisualizationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return fmt.Errorf("field \"alwaysConnect\" is required")
		}
	case "never":
		if u.never == nil {
			return fmt.Errorf("field \"never\" is required")
		}
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
	}
	return nil
}

func (u DisconnectedValueVisualization) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DisconnectedValueVisualization) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DisconnectedValueVisualization) AcceptFuncs(alwaysConnectFunc func(AlwaysConnectDisconnectedValues) error, neverFunc func(NeverConnectDisconnectedValues) error, thresholdFunc func(ThresholdDisconnectedValues) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return alwaysConnectFunc(*u.alwaysConnect)
	case "never":
		if u.never == nil {
			return fmt.Errorf("field \"never\" is required")
		}
		return neverFunc(*u.never)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return thresholdFunc(*u.threshold)
	}
}

func (u *DisconnectedValueVisualization) AlwaysConnectNoopSuccess(AlwaysConnectDisconnectedValues) error {
	return nil
}

func (u *DisconnectedValueVisualization) NeverNoopSuccess(NeverConnectDisconnectedValues) error {
	return nil
}

func (u *DisconnectedValueVisualization) ThresholdNoopSuccess(ThresholdDisconnectedValues) error {
	return nil
}

func (u *DisconnectedValueVisualization) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DisconnectedValueVisualization) Accept(v DisconnectedValueVisualizationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return v.VisitAlwaysConnect(*u.alwaysConnect)
	case "never":
		if u.never == nil {
			return fmt.Errorf("field \"never\" is required")
		}
		return v.VisitNever(*u.never)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThreshold(*u.threshold)
	}
}

type DisconnectedValueVisualizationVisitor interface {
	VisitAlwaysConnect(v AlwaysConnectDisconnectedValues) error
	VisitNever(v NeverConnectDisconnectedValues) error
	VisitThreshold(v ThresholdDisconnectedValues) error
	VisitUnknown(typeName string) error
}

func (u *DisconnectedValueVisualization) AcceptWithContext(ctx context.Context, v DisconnectedValueVisualizationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return v.VisitAlwaysConnectWithContext(ctx, *u.alwaysConnect)
	case "never":
		if u.never == nil {
			return fmt.Errorf("field \"never\" is required")
		}
		return v.VisitNeverWithContext(ctx, *u.never)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThresholdWithContext(ctx, *u.threshold)
	}
}

type DisconnectedValueVisualizationVisitorWithContext interface {
	VisitAlwaysConnectWithContext(ctx context.Context, v AlwaysConnectDisconnectedValues) error
	VisitNeverWithContext(ctx context.Context, v NeverConnectDisconnectedValues) error
	VisitThresholdWithContext(ctx context.Context, v ThresholdDisconnectedValues) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDisconnectedValueVisualizationFromAlwaysConnect(v AlwaysConnectDisconnectedValues) DisconnectedValueVisualization {
	return DisconnectedValueVisualization{typ: "alwaysConnect", alwaysConnect: &v}
}

func NewDisconnectedValueVisualizationFromNever(v NeverConnectDisconnectedValues) DisconnectedValueVisualization {
	return DisconnectedValueVisualization{typ: "never", never: &v}
}

func NewDisconnectedValueVisualizationFromThreshold(v ThresholdDisconnectedValues) DisconnectedValueVisualization {
	return DisconnectedValueVisualization{typ: "threshold", threshold: &v}
}

type EnumArrayVisualisation struct {
	typ string
	raw *EnumArrayRawVisualisation
}

type enumArrayVisualisationDeserializer struct {
	Type string                     `json:"type"`
	Raw  *EnumArrayRawVisualisation `json:"raw"`
}

func (u *enumArrayVisualisationDeserializer) toStruct() EnumArrayVisualisation {
	return EnumArrayVisualisation{typ: u.Type, raw: u.Raw}
}

func (u *EnumArrayVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			Raw  EnumArrayRawVisualisation `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u EnumArrayVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumArrayVisualisation) UnmarshalJSON(data []byte) error {
	var deser enumArrayVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u EnumArrayVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumArrayVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumArrayVisualisation) AcceptFuncs(rawFunc func(EnumArrayRawVisualisation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *EnumArrayVisualisation) RawNoopSuccess(EnumArrayRawVisualisation) error {
	return nil
}

func (u *EnumArrayVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumArrayVisualisation) Accept(v EnumArrayVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type EnumArrayVisualisationVisitor interface {
	VisitRaw(v EnumArrayRawVisualisation) error
	VisitUnknown(typeName string) error
}

func (u *EnumArrayVisualisation) AcceptWithContext(ctx context.Context, v EnumArrayVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type EnumArrayVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v EnumArrayRawVisualisation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumArrayVisualisationFromRaw(v EnumArrayRawVisualisation) EnumArrayVisualisation {
	return EnumArrayVisualisation{typ: "raw", raw: &v}
}

type EnumDisplayStyle struct {
	typ     string
	stacked *EnumDisplayStyleStacked
	inline  *EnumDisplayStyleInline
	bar     *EnumDisplayStyleBar
	line    *EnumDisplayStyleLine
}

type enumDisplayStyleDeserializer struct {
	Type    string                   `json:"type"`
	Stacked *EnumDisplayStyleStacked `json:"stacked"`
	Inline  *EnumDisplayStyleInline  `json:"inline"`
	Bar     *EnumDisplayStyleBar     `json:"bar"`
	Line    *EnumDisplayStyleLine    `json:"line"`
}

func (u *enumDisplayStyleDeserializer) toStruct() EnumDisplayStyle {
	return EnumDisplayStyle{typ: u.Type, stacked: u.Stacked, inline: u.Inline, bar: u.Bar, line: u.Line}
}

func (u *EnumDisplayStyle) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "stacked":
		if u.stacked == nil {
			return nil, fmt.Errorf("field \"stacked\" is required")
		}
		return struct {
			Type    string                  `json:"type"`
			Stacked EnumDisplayStyleStacked `json:"stacked"`
		}{Type: "stacked", Stacked: *u.stacked}, nil
	case "inline":
		if u.inline == nil {
			return nil, fmt.Errorf("field \"inline\" is required")
		}
		return struct {
			Type   string                 `json:"type"`
			Inline EnumDisplayStyleInline `json:"inline"`
		}{Type: "inline", Inline: *u.inline}, nil
	case "bar":
		if u.bar == nil {
			return nil, fmt.Errorf("field \"bar\" is required")
		}
		return struct {
			Type string              `json:"type"`
			Bar  EnumDisplayStyleBar `json:"bar"`
		}{Type: "bar", Bar: *u.bar}, nil
	case "line":
		if u.line == nil {
			return nil, fmt.Errorf("field \"line\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Line EnumDisplayStyleLine `json:"line"`
		}{Type: "line", Line: *u.line}, nil
	}
}

func (u EnumDisplayStyle) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumDisplayStyle) UnmarshalJSON(data []byte) error {
	var deser enumDisplayStyleDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "stacked":
		if u.stacked == nil {
			return fmt.Errorf("field \"stacked\" is required")
		}
	case "inline":
		if u.inline == nil {
			return fmt.Errorf("field \"inline\" is required")
		}
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
	case "line":
		if u.line == nil {
			return fmt.Errorf("field \"line\" is required")
		}
	}
	return nil
}

func (u EnumDisplayStyle) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumDisplayStyle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumDisplayStyle) AcceptFuncs(stackedFunc func(EnumDisplayStyleStacked) error, inlineFunc func(EnumDisplayStyleInline) error, barFunc func(EnumDisplayStyleBar) error, lineFunc func(EnumDisplayStyleLine) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "stacked":
		if u.stacked == nil {
			return fmt.Errorf("field \"stacked\" is required")
		}
		return stackedFunc(*u.stacked)
	case "inline":
		if u.inline == nil {
			return fmt.Errorf("field \"inline\" is required")
		}
		return inlineFunc(*u.inline)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return barFunc(*u.bar)
	case "line":
		if u.line == nil {
			return fmt.Errorf("field \"line\" is required")
		}
		return lineFunc(*u.line)
	}
}

func (u *EnumDisplayStyle) StackedNoopSuccess(EnumDisplayStyleStacked) error {
	return nil
}

func (u *EnumDisplayStyle) InlineNoopSuccess(EnumDisplayStyleInline) error {
	return nil
}

func (u *EnumDisplayStyle) BarNoopSuccess(EnumDisplayStyleBar) error {
	return nil
}

func (u *EnumDisplayStyle) LineNoopSuccess(EnumDisplayStyleLine) error {
	return nil
}

func (u *EnumDisplayStyle) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumDisplayStyle) Accept(v EnumDisplayStyleVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "stacked":
		if u.stacked == nil {
			return fmt.Errorf("field \"stacked\" is required")
		}
		return v.VisitStacked(*u.stacked)
	case "inline":
		if u.inline == nil {
			return fmt.Errorf("field \"inline\" is required")
		}
		return v.VisitInline(*u.inline)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBar(*u.bar)
	case "line":
		if u.line == nil {
			return fmt.Errorf("field \"line\" is required")
		}
		return v.VisitLine(*u.line)
	}
}

type EnumDisplayStyleVisitor interface {
	VisitStacked(v EnumDisplayStyleStacked) error
	VisitInline(v EnumDisplayStyleInline) error
	VisitBar(v EnumDisplayStyleBar) error
	VisitLine(v EnumDisplayStyleLine) error
	VisitUnknown(typeName string) error
}

func (u *EnumDisplayStyle) AcceptWithContext(ctx context.Context, v EnumDisplayStyleVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "stacked":
		if u.stacked == nil {
			return fmt.Errorf("field \"stacked\" is required")
		}
		return v.VisitStackedWithContext(ctx, *u.stacked)
	case "inline":
		if u.inline == nil {
			return fmt.Errorf("field \"inline\" is required")
		}
		return v.VisitInlineWithContext(ctx, *u.inline)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBarWithContext(ctx, *u.bar)
	case "line":
		if u.line == nil {
			return fmt.Errorf("field \"line\" is required")
		}
		return v.VisitLineWithContext(ctx, *u.line)
	}
}

type EnumDisplayStyleVisitorWithContext interface {
	VisitStackedWithContext(ctx context.Context, v EnumDisplayStyleStacked) error
	VisitInlineWithContext(ctx context.Context, v EnumDisplayStyleInline) error
	VisitBarWithContext(ctx context.Context, v EnumDisplayStyleBar) error
	VisitLineWithContext(ctx context.Context, v EnumDisplayStyleLine) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumDisplayStyleFromStacked(v EnumDisplayStyleStacked) EnumDisplayStyle {
	return EnumDisplayStyle{typ: "stacked", stacked: &v}
}

func NewEnumDisplayStyleFromInline(v EnumDisplayStyleInline) EnumDisplayStyle {
	return EnumDisplayStyle{typ: "inline", inline: &v}
}

func NewEnumDisplayStyleFromBar(v EnumDisplayStyleBar) EnumDisplayStyle {
	return EnumDisplayStyle{typ: "bar", bar: &v}
}

func NewEnumDisplayStyleFromLine(v EnumDisplayStyleLine) EnumDisplayStyle {
	return EnumDisplayStyle{typ: "line", line: &v}
}

type EnumGroupBySort struct {
	typ          string
	custom       *EnumGroupBySortCustom
	alphabetical *ValueSort
}

type enumGroupBySortDeserializer struct {
	Type         string                 `json:"type"`
	Custom       *EnumGroupBySortCustom `json:"custom"`
	Alphabetical *ValueSort             `json:"alphabetical"`
}

func (u *enumGroupBySortDeserializer) toStruct() EnumGroupBySort {
	return EnumGroupBySort{typ: u.Type, custom: u.Custom, alphabetical: u.Alphabetical}
}

func (u *EnumGroupBySort) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "custom":
		if u.custom == nil {
			return nil, fmt.Errorf("field \"custom\" is required")
		}
		return struct {
			Type   string                `json:"type"`
			Custom EnumGroupBySortCustom `json:"custom"`
		}{Type: "custom", Custom: *u.custom}, nil
	case "alphabetical":
		if u.alphabetical == nil {
			return nil, fmt.Errorf("field \"alphabetical\" is required")
		}
		return struct {
			Type         string    `json:"type"`
			Alphabetical ValueSort `json:"alphabetical"`
		}{Type: "alphabetical", Alphabetical: *u.alphabetical}, nil
	}
}

func (u EnumGroupBySort) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumGroupBySort) UnmarshalJSON(data []byte) error {
	var deser enumGroupBySortDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
	case "alphabetical":
		if u.alphabetical == nil {
			return fmt.Errorf("field \"alphabetical\" is required")
		}
	}
	return nil
}

func (u EnumGroupBySort) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumGroupBySort) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumGroupBySort) AcceptFuncs(customFunc func(EnumGroupBySortCustom) error, alphabeticalFunc func(ValueSort) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	case "alphabetical":
		if u.alphabetical == nil {
			return fmt.Errorf("field \"alphabetical\" is required")
		}
		return alphabeticalFunc(*u.alphabetical)
	}
}

func (u *EnumGroupBySort) CustomNoopSuccess(EnumGroupBySortCustom) error {
	return nil
}

func (u *EnumGroupBySort) AlphabeticalNoopSuccess(ValueSort) error {
	return nil
}

func (u *EnumGroupBySort) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumGroupBySort) Accept(v EnumGroupBySortVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(*u.custom)
	case "alphabetical":
		if u.alphabetical == nil {
			return fmt.Errorf("field \"alphabetical\" is required")
		}
		return v.VisitAlphabetical(*u.alphabetical)
	}
}

type EnumGroupBySortVisitor interface {
	VisitCustom(v EnumGroupBySortCustom) error
	VisitAlphabetical(v ValueSort) error
	VisitUnknown(typeName string) error
}

func (u *EnumGroupBySort) AcceptWithContext(ctx context.Context, v EnumGroupBySortVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustomWithContext(ctx, *u.custom)
	case "alphabetical":
		if u.alphabetical == nil {
			return fmt.Errorf("field \"alphabetical\" is required")
		}
		return v.VisitAlphabeticalWithContext(ctx, *u.alphabetical)
	}
}

type EnumGroupBySortVisitorWithContext interface {
	VisitCustomWithContext(ctx context.Context, v EnumGroupBySortCustom) error
	VisitAlphabeticalWithContext(ctx context.Context, v ValueSort) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumGroupBySortFromCustom(v EnumGroupBySortCustom) EnumGroupBySort {
	return EnumGroupBySort{typ: "custom", custom: &v}
}

func NewEnumGroupBySortFromAlphabetical(v ValueSort) EnumGroupBySort {
	return EnumGroupBySort{typ: "alphabetical", alphabetical: &v}
}

type EnumValueVisualisation struct {
	typ string
	raw *EnumRawVisualisation
}

type enumValueVisualisationDeserializer struct {
	Type string                `json:"type"`
	Raw  *EnumRawVisualisation `json:"raw"`
}

func (u *enumValueVisualisationDeserializer) toStruct() EnumValueVisualisation {
	return EnumValueVisualisation{typ: u.Type, raw: u.Raw}
}

func (u *EnumValueVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Raw  EnumRawVisualisation `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u EnumValueVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumValueVisualisation) UnmarshalJSON(data []byte) error {
	var deser enumValueVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u EnumValueVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumValueVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumValueVisualisation) AcceptFuncs(rawFunc func(EnumRawVisualisation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *EnumValueVisualisation) RawNoopSuccess(EnumRawVisualisation) error {
	return nil
}

func (u *EnumValueVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumValueVisualisation) Accept(v EnumValueVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type EnumValueVisualisationVisitor interface {
	VisitRaw(v EnumRawVisualisation) error
	VisitUnknown(typeName string) error
}

func (u *EnumValueVisualisation) AcceptWithContext(ctx context.Context, v EnumValueVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type EnumValueVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v EnumRawVisualisation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumValueVisualisationFromRaw(v EnumRawVisualisation) EnumValueVisualisation {
	return EnumValueVisualisation{typ: "raw", raw: &v}
}

type FloatingLegend struct {
	typ    string
	perRow *PerRowFloatingLegends
}

type floatingLegendDeserializer struct {
	Type   string                 `json:"type"`
	PerRow *PerRowFloatingLegends `json:"perRow"`
}

func (u *floatingLegendDeserializer) toStruct() FloatingLegend {
	return FloatingLegend{typ: u.Type, perRow: u.PerRow}
}

func (u *FloatingLegend) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "perRow":
		if u.perRow == nil {
			return nil, fmt.Errorf("field \"perRow\" is required")
		}
		return struct {
			Type   string                `json:"type"`
			PerRow PerRowFloatingLegends `json:"perRow"`
		}{Type: "perRow", PerRow: *u.perRow}, nil
	}
}

func (u FloatingLegend) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FloatingLegend) UnmarshalJSON(data []byte) error {
	var deser floatingLegendDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "perRow":
		if u.perRow == nil {
			return fmt.Errorf("field \"perRow\" is required")
		}
	}
	return nil
}

func (u FloatingLegend) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FloatingLegend) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FloatingLegend) AcceptFuncs(perRowFunc func(PerRowFloatingLegends) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "perRow":
		if u.perRow == nil {
			return fmt.Errorf("field \"perRow\" is required")
		}
		return perRowFunc(*u.perRow)
	}
}

func (u *FloatingLegend) PerRowNoopSuccess(PerRowFloatingLegends) error {
	return nil
}

func (u *FloatingLegend) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FloatingLegend) Accept(v FloatingLegendVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "perRow":
		if u.perRow == nil {
			return fmt.Errorf("field \"perRow\" is required")
		}
		return v.VisitPerRow(*u.perRow)
	}
}

type FloatingLegendVisitor interface {
	VisitPerRow(v PerRowFloatingLegends) error
	VisitUnknown(typeName string) error
}

func (u *FloatingLegend) AcceptWithContext(ctx context.Context, v FloatingLegendVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "perRow":
		if u.perRow == nil {
			return fmt.Errorf("field \"perRow\" is required")
		}
		return v.VisitPerRowWithContext(ctx, *u.perRow)
	}
}

type FloatingLegendVisitorWithContext interface {
	VisitPerRowWithContext(ctx context.Context, v PerRowFloatingLegends) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFloatingLegendFromPerRow(v PerRowFloatingLegends) FloatingLegend {
	return FloatingLegend{typ: "perRow", perRow: &v}
}

type FrequencyChartDefinition struct {
	typ string
	v1  *FrequencyChartDefinitionV1
	v2  *FrequencyChartDefinitionV2
}

type frequencyChartDefinitionDeserializer struct {
	Type string                      `json:"type"`
	V1   *FrequencyChartDefinitionV1 `json:"v1"`
	V2   *FrequencyChartDefinitionV2 `json:"v2"`
}

func (u *frequencyChartDefinitionDeserializer) toStruct() FrequencyChartDefinition {
	return FrequencyChartDefinition{typ: u.Type, v1: u.V1, v2: u.V2}
}

func (u *FrequencyChartDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                     `json:"type"`
			V1   FrequencyChartDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	case "v2":
		if u.v2 == nil {
			return nil, fmt.Errorf("field \"v2\" is required")
		}
		return struct {
			Type string                     `json:"type"`
			V2   FrequencyChartDefinitionV2 `json:"v2"`
		}{Type: "v2", V2: *u.v2}, nil
	}
}

func (u FrequencyChartDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FrequencyChartDefinition) UnmarshalJSON(data []byte) error {
	var deser frequencyChartDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
	}
	return nil
}

func (u FrequencyChartDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FrequencyChartDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FrequencyChartDefinition) AcceptFuncs(v1Func func(FrequencyChartDefinitionV1) error, v2Func func(FrequencyChartDefinitionV2) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *FrequencyChartDefinition) V1NoopSuccess(FrequencyChartDefinitionV1) error {
	return nil
}

func (u *FrequencyChartDefinition) V2NoopSuccess(FrequencyChartDefinitionV2) error {
	return nil
}

func (u *FrequencyChartDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FrequencyChartDefinition) Accept(v FrequencyChartDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(*u.v2)
	}
}

type FrequencyChartDefinitionVisitor interface {
	VisitV1(v FrequencyChartDefinitionV1) error
	VisitV2(v FrequencyChartDefinitionV2) error
	VisitUnknown(typeName string) error
}

func (u *FrequencyChartDefinition) AcceptWithContext(ctx context.Context, v FrequencyChartDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2WithContext(ctx, *u.v2)
	}
}

type FrequencyChartDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v FrequencyChartDefinitionV1) error
	VisitV2WithContext(ctx context.Context, v FrequencyChartDefinitionV2) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFrequencyChartDefinitionFromV1(v FrequencyChartDefinitionV1) FrequencyChartDefinition {
	return FrequencyChartDefinition{typ: "v1", v1: &v}
}

func NewFrequencyChartDefinitionFromV2(v FrequencyChartDefinitionV2) FrequencyChartDefinition {
	return FrequencyChartDefinition{typ: "v2", v2: &v}
}

type FrequencyPlotType struct {
	typ         string
	fft         *FrequencyPlotTypeFft
	periodogram *FrequencyPlotTypePeriodogram
	psd         *FrequencyPlotTypePsd
	cpsd        *FrequencyPlotTypeCpsd
	nyquist     *FrequencyPlotTypeNyquist
	bode        *FrequencyPlotTypeBode
}

type frequencyPlotTypeDeserializer struct {
	Type        string                        `json:"type"`
	Fft         *FrequencyPlotTypeFft         `json:"fft"`
	Periodogram *FrequencyPlotTypePeriodogram `json:"periodogram"`
	Psd         *FrequencyPlotTypePsd         `json:"psd"`
	Cpsd        *FrequencyPlotTypeCpsd        `json:"cpsd"`
	Nyquist     *FrequencyPlotTypeNyquist     `json:"nyquist"`
	Bode        *FrequencyPlotTypeBode        `json:"bode"`
}

func (u *frequencyPlotTypeDeserializer) toStruct() FrequencyPlotType {
	return FrequencyPlotType{typ: u.Type, fft: u.Fft, periodogram: u.Periodogram, psd: u.Psd, cpsd: u.Cpsd, nyquist: u.Nyquist, bode: u.Bode}
}

func (u *FrequencyPlotType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "fft":
		if u.fft == nil {
			return nil, fmt.Errorf("field \"fft\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Fft  FrequencyPlotTypeFft `json:"fft"`
		}{Type: "fft", Fft: *u.fft}, nil
	case "periodogram":
		if u.periodogram == nil {
			return nil, fmt.Errorf("field \"periodogram\" is required")
		}
		return struct {
			Type        string                       `json:"type"`
			Periodogram FrequencyPlotTypePeriodogram `json:"periodogram"`
		}{Type: "periodogram", Periodogram: *u.periodogram}, nil
	case "psd":
		if u.psd == nil {
			return nil, fmt.Errorf("field \"psd\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Psd  FrequencyPlotTypePsd `json:"psd"`
		}{Type: "psd", Psd: *u.psd}, nil
	case "cpsd":
		if u.cpsd == nil {
			return nil, fmt.Errorf("field \"cpsd\" is required")
		}
		return struct {
			Type string                `json:"type"`
			Cpsd FrequencyPlotTypeCpsd `json:"cpsd"`
		}{Type: "cpsd", Cpsd: *u.cpsd}, nil
	case "nyquist":
		if u.nyquist == nil {
			return nil, fmt.Errorf("field \"nyquist\" is required")
		}
		return struct {
			Type    string                   `json:"type"`
			Nyquist FrequencyPlotTypeNyquist `json:"nyquist"`
		}{Type: "nyquist", Nyquist: *u.nyquist}, nil
	case "bode":
		if u.bode == nil {
			return nil, fmt.Errorf("field \"bode\" is required")
		}
		return struct {
			Type string                `json:"type"`
			Bode FrequencyPlotTypeBode `json:"bode"`
		}{Type: "bode", Bode: *u.bode}, nil
	}
}

func (u FrequencyPlotType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FrequencyPlotType) UnmarshalJSON(data []byte) error {
	var deser frequencyPlotTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
	case "periodogram":
		if u.periodogram == nil {
			return fmt.Errorf("field \"periodogram\" is required")
		}
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
	}
	return nil
}

func (u FrequencyPlotType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FrequencyPlotType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FrequencyPlotType) AcceptFuncs(fftFunc func(FrequencyPlotTypeFft) error, periodogramFunc func(FrequencyPlotTypePeriodogram) error, psdFunc func(FrequencyPlotTypePsd) error, cpsdFunc func(FrequencyPlotTypeCpsd) error, nyquistFunc func(FrequencyPlotTypeNyquist) error, bodeFunc func(FrequencyPlotTypeBode) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	case "periodogram":
		if u.periodogram == nil {
			return fmt.Errorf("field \"periodogram\" is required")
		}
		return periodogramFunc(*u.periodogram)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return psdFunc(*u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
		return cpsdFunc(*u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
		return nyquistFunc(*u.nyquist)
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
		return bodeFunc(*u.bode)
	}
}

func (u *FrequencyPlotType) FftNoopSuccess(FrequencyPlotTypeFft) error {
	return nil
}

func (u *FrequencyPlotType) PeriodogramNoopSuccess(FrequencyPlotTypePeriodogram) error {
	return nil
}

func (u *FrequencyPlotType) PsdNoopSuccess(FrequencyPlotTypePsd) error {
	return nil
}

func (u *FrequencyPlotType) CpsdNoopSuccess(FrequencyPlotTypeCpsd) error {
	return nil
}

func (u *FrequencyPlotType) NyquistNoopSuccess(FrequencyPlotTypeNyquist) error {
	return nil
}

func (u *FrequencyPlotType) BodeNoopSuccess(FrequencyPlotTypeBode) error {
	return nil
}

func (u *FrequencyPlotType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FrequencyPlotType) Accept(v FrequencyPlotTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(*u.fft)
	case "periodogram":
		if u.periodogram == nil {
			return fmt.Errorf("field \"periodogram\" is required")
		}
		return v.VisitPeriodogram(*u.periodogram)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsd(*u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
		return v.VisitCpsd(*u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
		return v.VisitNyquist(*u.nyquist)
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
		return v.VisitBode(*u.bode)
	}
}

type FrequencyPlotTypeVisitor interface {
	VisitFft(v FrequencyPlotTypeFft) error
	VisitPeriodogram(v FrequencyPlotTypePeriodogram) error
	VisitPsd(v FrequencyPlotTypePsd) error
	VisitCpsd(v FrequencyPlotTypeCpsd) error
	VisitNyquist(v FrequencyPlotTypeNyquist) error
	VisitBode(v FrequencyPlotTypeBode) error
	VisitUnknown(typeName string) error
}

func (u *FrequencyPlotType) AcceptWithContext(ctx context.Context, v FrequencyPlotTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFftWithContext(ctx, *u.fft)
	case "periodogram":
		if u.periodogram == nil {
			return fmt.Errorf("field \"periodogram\" is required")
		}
		return v.VisitPeriodogramWithContext(ctx, *u.periodogram)
	case "psd":
		if u.psd == nil {
			return fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsdWithContext(ctx, *u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return fmt.Errorf("field \"cpsd\" is required")
		}
		return v.VisitCpsdWithContext(ctx, *u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return fmt.Errorf("field \"nyquist\" is required")
		}
		return v.VisitNyquistWithContext(ctx, *u.nyquist)
	case "bode":
		if u.bode == nil {
			return fmt.Errorf("field \"bode\" is required")
		}
		return v.VisitBodeWithContext(ctx, *u.bode)
	}
}

type FrequencyPlotTypeVisitorWithContext interface {
	VisitFftWithContext(ctx context.Context, v FrequencyPlotTypeFft) error
	VisitPeriodogramWithContext(ctx context.Context, v FrequencyPlotTypePeriodogram) error
	VisitPsdWithContext(ctx context.Context, v FrequencyPlotTypePsd) error
	VisitCpsdWithContext(ctx context.Context, v FrequencyPlotTypeCpsd) error
	VisitNyquistWithContext(ctx context.Context, v FrequencyPlotTypeNyquist) error
	VisitBodeWithContext(ctx context.Context, v FrequencyPlotTypeBode) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFrequencyPlotTypeFromFft(v FrequencyPlotTypeFft) FrequencyPlotType {
	return FrequencyPlotType{typ: "fft", fft: &v}
}

func NewFrequencyPlotTypeFromPeriodogram(v FrequencyPlotTypePeriodogram) FrequencyPlotType {
	return FrequencyPlotType{typ: "periodogram", periodogram: &v}
}

func NewFrequencyPlotTypeFromPsd(v FrequencyPlotTypePsd) FrequencyPlotType {
	return FrequencyPlotType{typ: "psd", psd: &v}
}

func NewFrequencyPlotTypeFromCpsd(v FrequencyPlotTypeCpsd) FrequencyPlotType {
	return FrequencyPlotType{typ: "cpsd", cpsd: &v}
}

func NewFrequencyPlotTypeFromNyquist(v FrequencyPlotTypeNyquist) FrequencyPlotType {
	return FrequencyPlotType{typ: "nyquist", nyquist: &v}
}

func NewFrequencyPlotTypeFromBode(v FrequencyPlotTypeBode) FrequencyPlotType {
	return FrequencyPlotType{typ: "bode", bode: &v}
}

type FrequencyPlotV2 struct {
	typ          string
	single       *FrequencyPlot
	multivariate *FrequencyPlotMultivariate
}

type frequencyPlotV2Deserializer struct {
	Type         string                     `json:"type"`
	Single       *FrequencyPlot             `json:"single"`
	Multivariate *FrequencyPlotMultivariate `json:"multivariate"`
}

func (u *frequencyPlotV2Deserializer) toStruct() FrequencyPlotV2 {
	return FrequencyPlotV2{typ: u.Type, single: u.Single, multivariate: u.Multivariate}
}

func (u *FrequencyPlotV2) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "single":
		if u.single == nil {
			return nil, fmt.Errorf("field \"single\" is required")
		}
		return struct {
			Type   string        `json:"type"`
			Single FrequencyPlot `json:"single"`
		}{Type: "single", Single: *u.single}, nil
	case "multivariate":
		if u.multivariate == nil {
			return nil, fmt.Errorf("field \"multivariate\" is required")
		}
		return struct {
			Type         string                    `json:"type"`
			Multivariate FrequencyPlotMultivariate `json:"multivariate"`
		}{Type: "multivariate", Multivariate: *u.multivariate}, nil
	}
}

func (u FrequencyPlotV2) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FrequencyPlotV2) UnmarshalJSON(data []byte) error {
	var deser frequencyPlotV2Deserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
	case "multivariate":
		if u.multivariate == nil {
			return fmt.Errorf("field \"multivariate\" is required")
		}
	}
	return nil
}

func (u FrequencyPlotV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FrequencyPlotV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FrequencyPlotV2) AcceptFuncs(singleFunc func(FrequencyPlot) error, multivariateFunc func(FrequencyPlotMultivariate) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	case "multivariate":
		if u.multivariate == nil {
			return fmt.Errorf("field \"multivariate\" is required")
		}
		return multivariateFunc(*u.multivariate)
	}
}

func (u *FrequencyPlotV2) SingleNoopSuccess(FrequencyPlot) error {
	return nil
}

func (u *FrequencyPlotV2) MultivariateNoopSuccess(FrequencyPlotMultivariate) error {
	return nil
}

func (u *FrequencyPlotV2) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FrequencyPlotV2) Accept(v FrequencyPlotV2Visitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(*u.single)
	case "multivariate":
		if u.multivariate == nil {
			return fmt.Errorf("field \"multivariate\" is required")
		}
		return v.VisitMultivariate(*u.multivariate)
	}
}

type FrequencyPlotV2Visitor interface {
	VisitSingle(v FrequencyPlot) error
	VisitMultivariate(v FrequencyPlotMultivariate) error
	VisitUnknown(typeName string) error
}

func (u *FrequencyPlotV2) AcceptWithContext(ctx context.Context, v FrequencyPlotV2VisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingleWithContext(ctx, *u.single)
	case "multivariate":
		if u.multivariate == nil {
			return fmt.Errorf("field \"multivariate\" is required")
		}
		return v.VisitMultivariateWithContext(ctx, *u.multivariate)
	}
}

type FrequencyPlotV2VisitorWithContext interface {
	VisitSingleWithContext(ctx context.Context, v FrequencyPlot) error
	VisitMultivariateWithContext(ctx context.Context, v FrequencyPlotMultivariate) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFrequencyPlotV2FromSingle(v FrequencyPlot) FrequencyPlotV2 {
	return FrequencyPlotV2{typ: "single", single: &v}
}

func NewFrequencyPlotV2FromMultivariate(v FrequencyPlotMultivariate) FrequencyPlotV2 {
	return FrequencyPlotV2{typ: "multivariate", multivariate: &v}
}

type Geo3dDefinition struct {
	typ string
	v1  *Geo3dDefinitionV1
}

type geo3dDefinitionDeserializer struct {
	Type string             `json:"type"`
	V1   *Geo3dDefinitionV1 `json:"v1"`
}

func (u *geo3dDefinitionDeserializer) toStruct() Geo3dDefinition {
	return Geo3dDefinition{typ: u.Type, v1: u.V1}
}

func (u *Geo3dDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string            `json:"type"`
			V1   Geo3dDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u Geo3dDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dDefinition) UnmarshalJSON(data []byte) error {
	var deser geo3dDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u Geo3dDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dDefinition) AcceptFuncs(v1Func func(Geo3dDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *Geo3dDefinition) V1NoopSuccess(Geo3dDefinitionV1) error {
	return nil
}

func (u *Geo3dDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dDefinition) Accept(v Geo3dDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type Geo3dDefinitionVisitor interface {
	VisitV1(v Geo3dDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dDefinition) AcceptWithContext(ctx context.Context, v Geo3dDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type Geo3dDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v Geo3dDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dDefinitionFromV1(v Geo3dDefinitionV1) Geo3dDefinition {
	return Geo3dDefinition{typ: "v1", v1: &v}
}

type Geo3dModel struct {
	typ      string
	default_ *Geo3dDefaultModel
	custom   *Geo3dCustomModel
}

type geo3dModelDeserializer struct {
	Type    string             `json:"type"`
	Default *Geo3dDefaultModel `json:"default"`
	Custom  *Geo3dCustomModel  `json:"custom"`
}

func (u *geo3dModelDeserializer) toStruct() Geo3dModel {
	return Geo3dModel{typ: u.Type, default_: u.Default, custom: u.Custom}
}

func (u *Geo3dModel) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "default":
		if u.default_ == nil {
			return nil, fmt.Errorf("field \"default\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Default Geo3dDefaultModel `json:"default"`
		}{Type: "default", Default: *u.default_}, nil
	case "custom":
		if u.custom == nil {
			return nil, fmt.Errorf("field \"custom\" is required")
		}
		return struct {
			Type   string           `json:"type"`
			Custom Geo3dCustomModel `json:"custom"`
		}{Type: "custom", Custom: *u.custom}, nil
	}
}

func (u Geo3dModel) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dModel) UnmarshalJSON(data []byte) error {
	var deser geo3dModelDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "default":
		if u.default_ == nil {
			return fmt.Errorf("field \"default\" is required")
		}
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
	}
	return nil
}

func (u Geo3dModel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dModel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dModel) AcceptFuncs(default_Func func(Geo3dDefaultModel) error, customFunc func(Geo3dCustomModel) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "default":
		if u.default_ == nil {
			return fmt.Errorf("field \"default\" is required")
		}
		return default_Func(*u.default_)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	}
}

func (u *Geo3dModel) DefaultNoopSuccess(Geo3dDefaultModel) error {
	return nil
}

func (u *Geo3dModel) CustomNoopSuccess(Geo3dCustomModel) error {
	return nil
}

func (u *Geo3dModel) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dModel) Accept(v Geo3dModelVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "default":
		if u.default_ == nil {
			return fmt.Errorf("field \"default\" is required")
		}
		return v.VisitDefault(*u.default_)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(*u.custom)
	}
}

type Geo3dModelVisitor interface {
	VisitDefault(v Geo3dDefaultModel) error
	VisitCustom(v Geo3dCustomModel) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dModel) AcceptWithContext(ctx context.Context, v Geo3dModelVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "default":
		if u.default_ == nil {
			return fmt.Errorf("field \"default\" is required")
		}
		return v.VisitDefaultWithContext(ctx, *u.default_)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustomWithContext(ctx, *u.custom)
	}
}

type Geo3dModelVisitorWithContext interface {
	VisitDefaultWithContext(ctx context.Context, v Geo3dDefaultModel) error
	VisitCustomWithContext(ctx context.Context, v Geo3dCustomModel) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dModelFromDefault(v Geo3dDefaultModel) Geo3dModel {
	return Geo3dModel{typ: "default", default_: &v}
}

func NewGeo3dModelFromCustom(v Geo3dCustomModel) Geo3dModel {
	return Geo3dModel{typ: "custom", custom: &v}
}

type Geo3dOrientation struct {
	typ           string
	principalAxes *Geo3dOrientationPrincipalAxes
}

type geo3dOrientationDeserializer struct {
	Type          string                         `json:"type"`
	PrincipalAxes *Geo3dOrientationPrincipalAxes `json:"principalAxes"`
}

func (u *geo3dOrientationDeserializer) toStruct() Geo3dOrientation {
	return Geo3dOrientation{typ: u.Type, principalAxes: u.PrincipalAxes}
}

func (u *Geo3dOrientation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return nil, fmt.Errorf("field \"principalAxes\" is required")
		}
		return struct {
			Type          string                        `json:"type"`
			PrincipalAxes Geo3dOrientationPrincipalAxes `json:"principalAxes"`
		}{Type: "principalAxes", PrincipalAxes: *u.principalAxes}, nil
	}
}

func (u Geo3dOrientation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dOrientation) UnmarshalJSON(data []byte) error {
	var deser geo3dOrientationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
	}
	return nil
}

func (u Geo3dOrientation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dOrientation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dOrientation) AcceptFuncs(principalAxesFunc func(Geo3dOrientationPrincipalAxes) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
		return principalAxesFunc(*u.principalAxes)
	}
}

func (u *Geo3dOrientation) PrincipalAxesNoopSuccess(Geo3dOrientationPrincipalAxes) error {
	return nil
}

func (u *Geo3dOrientation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dOrientation) Accept(v Geo3dOrientationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
		return v.VisitPrincipalAxes(*u.principalAxes)
	}
}

type Geo3dOrientationVisitor interface {
	VisitPrincipalAxes(v Geo3dOrientationPrincipalAxes) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dOrientation) AcceptWithContext(ctx context.Context, v Geo3dOrientationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
		return v.VisitPrincipalAxesWithContext(ctx, *u.principalAxes)
	}
}

type Geo3dOrientationVisitorWithContext interface {
	VisitPrincipalAxesWithContext(ctx context.Context, v Geo3dOrientationPrincipalAxes) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dOrientationFromPrincipalAxes(v Geo3dOrientationPrincipalAxes) Geo3dOrientation {
	return Geo3dOrientation{typ: "principalAxes", principalAxes: &v}
}

type Geo3dOrientationStatic struct {
	typ           string
	principalAxes *Geo3dOrientationStaticPrincipalAxes
}

type geo3dOrientationStaticDeserializer struct {
	Type          string                               `json:"type"`
	PrincipalAxes *Geo3dOrientationStaticPrincipalAxes `json:"principalAxes"`
}

func (u *geo3dOrientationStaticDeserializer) toStruct() Geo3dOrientationStatic {
	return Geo3dOrientationStatic{typ: u.Type, principalAxes: u.PrincipalAxes}
}

func (u *Geo3dOrientationStatic) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return nil, fmt.Errorf("field \"principalAxes\" is required")
		}
		return struct {
			Type          string                              `json:"type"`
			PrincipalAxes Geo3dOrientationStaticPrincipalAxes `json:"principalAxes"`
		}{Type: "principalAxes", PrincipalAxes: *u.principalAxes}, nil
	}
}

func (u Geo3dOrientationStatic) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dOrientationStatic) UnmarshalJSON(data []byte) error {
	var deser geo3dOrientationStaticDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
	}
	return nil
}

func (u Geo3dOrientationStatic) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dOrientationStatic) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dOrientationStatic) AcceptFuncs(principalAxesFunc func(Geo3dOrientationStaticPrincipalAxes) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
		return principalAxesFunc(*u.principalAxes)
	}
}

func (u *Geo3dOrientationStatic) PrincipalAxesNoopSuccess(Geo3dOrientationStaticPrincipalAxes) error {
	return nil
}

func (u *Geo3dOrientationStatic) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dOrientationStatic) Accept(v Geo3dOrientationStaticVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
		return v.VisitPrincipalAxes(*u.principalAxes)
	}
}

type Geo3dOrientationStaticVisitor interface {
	VisitPrincipalAxes(v Geo3dOrientationStaticPrincipalAxes) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dOrientationStatic) AcceptWithContext(ctx context.Context, v Geo3dOrientationStaticVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
		return v.VisitPrincipalAxesWithContext(ctx, *u.principalAxes)
	}
}

type Geo3dOrientationStaticVisitorWithContext interface {
	VisitPrincipalAxesWithContext(ctx context.Context, v Geo3dOrientationStaticPrincipalAxes) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dOrientationStaticFromPrincipalAxes(v Geo3dOrientationStaticPrincipalAxes) Geo3dOrientationStatic {
	return Geo3dOrientationStatic{typ: "principalAxes", principalAxes: &v}
}

type Geo3dPosition struct {
	typ   string
	wgs84 *Geo3dPositionWgs84
	ecef  *Geo3dPositionEcef
}

type geo3dPositionDeserializer struct {
	Type  string              `json:"type"`
	Wgs84 *Geo3dPositionWgs84 `json:"wgs84"`
	Ecef  *Geo3dPositionEcef  `json:"ecef"`
}

func (u *geo3dPositionDeserializer) toStruct() Geo3dPosition {
	return Geo3dPosition{typ: u.Type, wgs84: u.Wgs84, ecef: u.Ecef}
}

func (u *Geo3dPosition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return nil, fmt.Errorf("field \"wgs84\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Wgs84 Geo3dPositionWgs84 `json:"wgs84"`
		}{Type: "wgs84", Wgs84: *u.wgs84}, nil
	case "ecef":
		if u.ecef == nil {
			return nil, fmt.Errorf("field \"ecef\" is required")
		}
		return struct {
			Type string            `json:"type"`
			Ecef Geo3dPositionEcef `json:"ecef"`
		}{Type: "ecef", Ecef: *u.ecef}, nil
	}
}

func (u Geo3dPosition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dPosition) UnmarshalJSON(data []byte) error {
	var deser geo3dPositionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
	case "ecef":
		if u.ecef == nil {
			return fmt.Errorf("field \"ecef\" is required")
		}
	}
	return nil
}

func (u Geo3dPosition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dPosition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dPosition) AcceptFuncs(wgs84Func func(Geo3dPositionWgs84) error, ecefFunc func(Geo3dPositionEcef) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
		return wgs84Func(*u.wgs84)
	case "ecef":
		if u.ecef == nil {
			return fmt.Errorf("field \"ecef\" is required")
		}
		return ecefFunc(*u.ecef)
	}
}

func (u *Geo3dPosition) Wgs84NoopSuccess(Geo3dPositionWgs84) error {
	return nil
}

func (u *Geo3dPosition) EcefNoopSuccess(Geo3dPositionEcef) error {
	return nil
}

func (u *Geo3dPosition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dPosition) Accept(v Geo3dPositionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
		return v.VisitWgs84(*u.wgs84)
	case "ecef":
		if u.ecef == nil {
			return fmt.Errorf("field \"ecef\" is required")
		}
		return v.VisitEcef(*u.ecef)
	}
}

type Geo3dPositionVisitor interface {
	VisitWgs84(v Geo3dPositionWgs84) error
	VisitEcef(v Geo3dPositionEcef) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dPosition) AcceptWithContext(ctx context.Context, v Geo3dPositionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
		return v.VisitWgs84WithContext(ctx, *u.wgs84)
	case "ecef":
		if u.ecef == nil {
			return fmt.Errorf("field \"ecef\" is required")
		}
		return v.VisitEcefWithContext(ctx, *u.ecef)
	}
}

type Geo3dPositionVisitorWithContext interface {
	VisitWgs84WithContext(ctx context.Context, v Geo3dPositionWgs84) error
	VisitEcefWithContext(ctx context.Context, v Geo3dPositionEcef) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dPositionFromWgs84(v Geo3dPositionWgs84) Geo3dPosition {
	return Geo3dPosition{typ: "wgs84", wgs84: &v}
}

func NewGeo3dPositionFromEcef(v Geo3dPositionEcef) Geo3dPosition {
	return Geo3dPosition{typ: "ecef", ecef: &v}
}

type Geo3dPositionStatic struct {
	typ   string
	wgs84 *Geo3dPositionStaticWgs84
	ecef  *Geo3dPositionStaticEcef
}

type geo3dPositionStaticDeserializer struct {
	Type  string                    `json:"type"`
	Wgs84 *Geo3dPositionStaticWgs84 `json:"wgs84"`
	Ecef  *Geo3dPositionStaticEcef  `json:"ecef"`
}

func (u *geo3dPositionStaticDeserializer) toStruct() Geo3dPositionStatic {
	return Geo3dPositionStatic{typ: u.Type, wgs84: u.Wgs84, ecef: u.Ecef}
}

func (u *Geo3dPositionStatic) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return nil, fmt.Errorf("field \"wgs84\" is required")
		}
		return struct {
			Type  string                   `json:"type"`
			Wgs84 Geo3dPositionStaticWgs84 `json:"wgs84"`
		}{Type: "wgs84", Wgs84: *u.wgs84}, nil
	case "ecef":
		if u.ecef == nil {
			return nil, fmt.Errorf("field \"ecef\" is required")
		}
		return struct {
			Type string                  `json:"type"`
			Ecef Geo3dPositionStaticEcef `json:"ecef"`
		}{Type: "ecef", Ecef: *u.ecef}, nil
	}
}

func (u Geo3dPositionStatic) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dPositionStatic) UnmarshalJSON(data []byte) error {
	var deser geo3dPositionStaticDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
	case "ecef":
		if u.ecef == nil {
			return fmt.Errorf("field \"ecef\" is required")
		}
	}
	return nil
}

func (u Geo3dPositionStatic) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dPositionStatic) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dPositionStatic) AcceptFuncs(wgs84Func func(Geo3dPositionStaticWgs84) error, ecefFunc func(Geo3dPositionStaticEcef) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
		return wgs84Func(*u.wgs84)
	case "ecef":
		if u.ecef == nil {
			return fmt.Errorf("field \"ecef\" is required")
		}
		return ecefFunc(*u.ecef)
	}
}

func (u *Geo3dPositionStatic) Wgs84NoopSuccess(Geo3dPositionStaticWgs84) error {
	return nil
}

func (u *Geo3dPositionStatic) EcefNoopSuccess(Geo3dPositionStaticEcef) error {
	return nil
}

func (u *Geo3dPositionStatic) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dPositionStatic) Accept(v Geo3dPositionStaticVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
		return v.VisitWgs84(*u.wgs84)
	case "ecef":
		if u.ecef == nil {
			return fmt.Errorf("field \"ecef\" is required")
		}
		return v.VisitEcef(*u.ecef)
	}
}

type Geo3dPositionStaticVisitor interface {
	VisitWgs84(v Geo3dPositionStaticWgs84) error
	VisitEcef(v Geo3dPositionStaticEcef) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dPositionStatic) AcceptWithContext(ctx context.Context, v Geo3dPositionStaticVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
		return v.VisitWgs84WithContext(ctx, *u.wgs84)
	case "ecef":
		if u.ecef == nil {
			return fmt.Errorf("field \"ecef\" is required")
		}
		return v.VisitEcefWithContext(ctx, *u.ecef)
	}
}

type Geo3dPositionStaticVisitorWithContext interface {
	VisitWgs84WithContext(ctx context.Context, v Geo3dPositionStaticWgs84) error
	VisitEcefWithContext(ctx context.Context, v Geo3dPositionStaticEcef) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dPositionStaticFromWgs84(v Geo3dPositionStaticWgs84) Geo3dPositionStatic {
	return Geo3dPositionStatic{typ: "wgs84", wgs84: &v}
}

func NewGeo3dPositionStaticFromEcef(v Geo3dPositionStaticEcef) Geo3dPositionStatic {
	return Geo3dPositionStatic{typ: "ecef", ecef: &v}
}

// Orientation configuration for a sensor.
type Geo3dSensorOrientationConfig struct {
	typ     string
	static  *Geo3dOrientationStatic
	channel *Geo3dOrientation
	nadir   *Geo3dSensorOrientationNadir
	zenith  *Geo3dSensorOrientationZenith
}

type geo3dSensorOrientationConfigDeserializer struct {
	Type    string                        `json:"type"`
	Static  *Geo3dOrientationStatic       `json:"static"`
	Channel *Geo3dOrientation             `json:"channel"`
	Nadir   *Geo3dSensorOrientationNadir  `json:"nadir"`
	Zenith  *Geo3dSensorOrientationZenith `json:"zenith"`
}

func (u *geo3dSensorOrientationConfigDeserializer) toStruct() Geo3dSensorOrientationConfig {
	return Geo3dSensorOrientationConfig{typ: u.Type, static: u.Static, channel: u.Channel, nadir: u.Nadir, zenith: u.Zenith}
}

func (u *Geo3dSensorOrientationConfig) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "static":
		if u.static == nil {
			return nil, fmt.Errorf("field \"static\" is required")
		}
		return struct {
			Type   string                 `json:"type"`
			Static Geo3dOrientationStatic `json:"static"`
		}{Type: "static", Static: *u.static}, nil
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string           `json:"type"`
			Channel Geo3dOrientation `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "nadir":
		if u.nadir == nil {
			return nil, fmt.Errorf("field \"nadir\" is required")
		}
		return struct {
			Type  string                      `json:"type"`
			Nadir Geo3dSensorOrientationNadir `json:"nadir"`
		}{Type: "nadir", Nadir: *u.nadir}, nil
	case "zenith":
		if u.zenith == nil {
			return nil, fmt.Errorf("field \"zenith\" is required")
		}
		return struct {
			Type   string                       `json:"type"`
			Zenith Geo3dSensorOrientationZenith `json:"zenith"`
		}{Type: "zenith", Zenith: *u.zenith}, nil
	}
}

func (u Geo3dSensorOrientationConfig) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dSensorOrientationConfig) UnmarshalJSON(data []byte) error {
	var deser geo3dSensorOrientationConfigDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "static":
		if u.static == nil {
			return fmt.Errorf("field \"static\" is required")
		}
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "nadir":
		if u.nadir == nil {
			return fmt.Errorf("field \"nadir\" is required")
		}
	case "zenith":
		if u.zenith == nil {
			return fmt.Errorf("field \"zenith\" is required")
		}
	}
	return nil
}

func (u Geo3dSensorOrientationConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dSensorOrientationConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dSensorOrientationConfig) AcceptFuncs(staticFunc func(Geo3dOrientationStatic) error, channelFunc func(Geo3dOrientation) error, nadirFunc func(Geo3dSensorOrientationNadir) error, zenithFunc func(Geo3dSensorOrientationZenith) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "static":
		if u.static == nil {
			return fmt.Errorf("field \"static\" is required")
		}
		return staticFunc(*u.static)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "nadir":
		if u.nadir == nil {
			return fmt.Errorf("field \"nadir\" is required")
		}
		return nadirFunc(*u.nadir)
	case "zenith":
		if u.zenith == nil {
			return fmt.Errorf("field \"zenith\" is required")
		}
		return zenithFunc(*u.zenith)
	}
}

func (u *Geo3dSensorOrientationConfig) StaticNoopSuccess(Geo3dOrientationStatic) error {
	return nil
}

func (u *Geo3dSensorOrientationConfig) ChannelNoopSuccess(Geo3dOrientation) error {
	return nil
}

func (u *Geo3dSensorOrientationConfig) NadirNoopSuccess(Geo3dSensorOrientationNadir) error {
	return nil
}

func (u *Geo3dSensorOrientationConfig) ZenithNoopSuccess(Geo3dSensorOrientationZenith) error {
	return nil
}

func (u *Geo3dSensorOrientationConfig) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dSensorOrientationConfig) Accept(v Geo3dSensorOrientationConfigVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "static":
		if u.static == nil {
			return fmt.Errorf("field \"static\" is required")
		}
		return v.VisitStatic(*u.static)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "nadir":
		if u.nadir == nil {
			return fmt.Errorf("field \"nadir\" is required")
		}
		return v.VisitNadir(*u.nadir)
	case "zenith":
		if u.zenith == nil {
			return fmt.Errorf("field \"zenith\" is required")
		}
		return v.VisitZenith(*u.zenith)
	}
}

type Geo3dSensorOrientationConfigVisitor interface {
	VisitStatic(v Geo3dOrientationStatic) error
	VisitChannel(v Geo3dOrientation) error
	VisitNadir(v Geo3dSensorOrientationNadir) error
	VisitZenith(v Geo3dSensorOrientationZenith) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dSensorOrientationConfig) AcceptWithContext(ctx context.Context, v Geo3dSensorOrientationConfigVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "static":
		if u.static == nil {
			return fmt.Errorf("field \"static\" is required")
		}
		return v.VisitStaticWithContext(ctx, *u.static)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "nadir":
		if u.nadir == nil {
			return fmt.Errorf("field \"nadir\" is required")
		}
		return v.VisitNadirWithContext(ctx, *u.nadir)
	case "zenith":
		if u.zenith == nil {
			return fmt.Errorf("field \"zenith\" is required")
		}
		return v.VisitZenithWithContext(ctx, *u.zenith)
	}
}

type Geo3dSensorOrientationConfigVisitorWithContext interface {
	VisitStaticWithContext(ctx context.Context, v Geo3dOrientationStatic) error
	VisitChannelWithContext(ctx context.Context, v Geo3dOrientation) error
	VisitNadirWithContext(ctx context.Context, v Geo3dSensorOrientationNadir) error
	VisitZenithWithContext(ctx context.Context, v Geo3dSensorOrientationZenith) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dSensorOrientationConfigFromStatic(v Geo3dOrientationStatic) Geo3dSensorOrientationConfig {
	return Geo3dSensorOrientationConfig{typ: "static", static: &v}
}

func NewGeo3dSensorOrientationConfigFromChannel(v Geo3dOrientation) Geo3dSensorOrientationConfig {
	return Geo3dSensorOrientationConfig{typ: "channel", channel: &v}
}

func NewGeo3dSensorOrientationConfigFromNadir(v Geo3dSensorOrientationNadir) Geo3dSensorOrientationConfig {
	return Geo3dSensorOrientationConfig{typ: "nadir", nadir: &v}
}

func NewGeo3dSensorOrientationConfigFromZenith(v Geo3dSensorOrientationZenith) Geo3dSensorOrientationConfig {
	return Geo3dSensorOrientationConfig{typ: "zenith", zenith: &v}
}

// Determines how a sensor's position is specified.
type Geo3dSensorPositionConfig struct {
	typ      string
	static   *Geo3dPositionStatic
	channel  *Geo3dPosition
	model    *string
	waypoint *string
}

type geo3dSensorPositionConfigDeserializer struct {
	Type     string               `json:"type"`
	Static   *Geo3dPositionStatic `json:"static"`
	Channel  *Geo3dPosition       `json:"channel"`
	Model    *string              `json:"model"`
	Waypoint *string              `json:"waypoint"`
}

func (u *geo3dSensorPositionConfigDeserializer) toStruct() Geo3dSensorPositionConfig {
	return Geo3dSensorPositionConfig{typ: u.Type, static: u.Static, channel: u.Channel, model: u.Model, waypoint: u.Waypoint}
}

func (u *Geo3dSensorPositionConfig) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "static":
		if u.static == nil {
			return nil, fmt.Errorf("field \"static\" is required")
		}
		return struct {
			Type   string              `json:"type"`
			Static Geo3dPositionStatic `json:"static"`
		}{Type: "static", Static: *u.static}, nil
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Channel Geo3dPosition `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "model":
		if u.model == nil {
			return nil, fmt.Errorf("field \"model\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Model string `json:"model"`
		}{Type: "model", Model: *u.model}, nil
	case "waypoint":
		if u.waypoint == nil {
			return nil, fmt.Errorf("field \"waypoint\" is required")
		}
		return struct {
			Type     string `json:"type"`
			Waypoint string `json:"waypoint"`
		}{Type: "waypoint", Waypoint: *u.waypoint}, nil
	}
}

func (u Geo3dSensorPositionConfig) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dSensorPositionConfig) UnmarshalJSON(data []byte) error {
	var deser geo3dSensorPositionConfigDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "static":
		if u.static == nil {
			return fmt.Errorf("field \"static\" is required")
		}
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "model":
		if u.model == nil {
			return fmt.Errorf("field \"model\" is required")
		}
	case "waypoint":
		if u.waypoint == nil {
			return fmt.Errorf("field \"waypoint\" is required")
		}
	}
	return nil
}

func (u Geo3dSensorPositionConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dSensorPositionConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dSensorPositionConfig) AcceptFuncs(staticFunc func(Geo3dPositionStatic) error, channelFunc func(Geo3dPosition) error, modelFunc func(string) error, waypointFunc func(string) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "static":
		if u.static == nil {
			return fmt.Errorf("field \"static\" is required")
		}
		return staticFunc(*u.static)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "model":
		if u.model == nil {
			return fmt.Errorf("field \"model\" is required")
		}
		return modelFunc(*u.model)
	case "waypoint":
		if u.waypoint == nil {
			return fmt.Errorf("field \"waypoint\" is required")
		}
		return waypointFunc(*u.waypoint)
	}
}

func (u *Geo3dSensorPositionConfig) StaticNoopSuccess(Geo3dPositionStatic) error {
	return nil
}

func (u *Geo3dSensorPositionConfig) ChannelNoopSuccess(Geo3dPosition) error {
	return nil
}

func (u *Geo3dSensorPositionConfig) ModelNoopSuccess(string) error {
	return nil
}

func (u *Geo3dSensorPositionConfig) WaypointNoopSuccess(string) error {
	return nil
}

func (u *Geo3dSensorPositionConfig) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dSensorPositionConfig) Accept(v Geo3dSensorPositionConfigVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "static":
		if u.static == nil {
			return fmt.Errorf("field \"static\" is required")
		}
		return v.VisitStatic(*u.static)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "model":
		if u.model == nil {
			return fmt.Errorf("field \"model\" is required")
		}
		return v.VisitModel(*u.model)
	case "waypoint":
		if u.waypoint == nil {
			return fmt.Errorf("field \"waypoint\" is required")
		}
		return v.VisitWaypoint(*u.waypoint)
	}
}

type Geo3dSensorPositionConfigVisitor interface {
	VisitStatic(v Geo3dPositionStatic) error
	VisitChannel(v Geo3dPosition) error
	VisitModel(v string) error
	VisitWaypoint(v string) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dSensorPositionConfig) AcceptWithContext(ctx context.Context, v Geo3dSensorPositionConfigVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "static":
		if u.static == nil {
			return fmt.Errorf("field \"static\" is required")
		}
		return v.VisitStaticWithContext(ctx, *u.static)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "model":
		if u.model == nil {
			return fmt.Errorf("field \"model\" is required")
		}
		return v.VisitModelWithContext(ctx, *u.model)
	case "waypoint":
		if u.waypoint == nil {
			return fmt.Errorf("field \"waypoint\" is required")
		}
		return v.VisitWaypointWithContext(ctx, *u.waypoint)
	}
}

type Geo3dSensorPositionConfigVisitorWithContext interface {
	VisitStaticWithContext(ctx context.Context, v Geo3dPositionStatic) error
	VisitChannelWithContext(ctx context.Context, v Geo3dPosition) error
	VisitModelWithContext(ctx context.Context, v string) error
	VisitWaypointWithContext(ctx context.Context, v string) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dSensorPositionConfigFromStatic(v Geo3dPositionStatic) Geo3dSensorPositionConfig {
	return Geo3dSensorPositionConfig{typ: "static", static: &v}
}

func NewGeo3dSensorPositionConfigFromChannel(v Geo3dPosition) Geo3dSensorPositionConfig {
	return Geo3dSensorPositionConfig{typ: "channel", channel: &v}
}

func NewGeo3dSensorPositionConfigFromModel(v string) Geo3dSensorPositionConfig {
	return Geo3dSensorPositionConfig{typ: "model", model: &v}
}

func NewGeo3dSensorPositionConfigFromWaypoint(v string) Geo3dSensorPositionConfig {
	return Geo3dSensorPositionConfig{typ: "waypoint", waypoint: &v}
}

// Additional static objects on the map, such as a point representing a tower
type GeoCustomFeature struct {
	typ   string
	point *GeoPoint
}

type geoCustomFeatureDeserializer struct {
	Type  string    `json:"type"`
	Point *GeoPoint `json:"point"`
}

func (u *geoCustomFeatureDeserializer) toStruct() GeoCustomFeature {
	return GeoCustomFeature{typ: u.Type, point: u.Point}
}

func (u *GeoCustomFeature) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "point":
		if u.point == nil {
			return nil, fmt.Errorf("field \"point\" is required")
		}
		return struct {
			Type  string   `json:"type"`
			Point GeoPoint `json:"point"`
		}{Type: "point", Point: *u.point}, nil
	}
}

func (u GeoCustomFeature) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *GeoCustomFeature) UnmarshalJSON(data []byte) error {
	var deser geoCustomFeatureDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "point":
		if u.point == nil {
			return fmt.Errorf("field \"point\" is required")
		}
	}
	return nil
}

func (u GeoCustomFeature) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *GeoCustomFeature) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *GeoCustomFeature) AcceptFuncs(pointFunc func(GeoPoint) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "point":
		if u.point == nil {
			return fmt.Errorf("field \"point\" is required")
		}
		return pointFunc(*u.point)
	}
}

func (u *GeoCustomFeature) PointNoopSuccess(GeoPoint) error {
	return nil
}

func (u *GeoCustomFeature) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *GeoCustomFeature) Accept(v GeoCustomFeatureVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "point":
		if u.point == nil {
			return fmt.Errorf("field \"point\" is required")
		}
		return v.VisitPoint(*u.point)
	}
}

type GeoCustomFeatureVisitor interface {
	VisitPoint(v GeoPoint) error
	VisitUnknown(typeName string) error
}

func (u *GeoCustomFeature) AcceptWithContext(ctx context.Context, v GeoCustomFeatureVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "point":
		if u.point == nil {
			return fmt.Errorf("field \"point\" is required")
		}
		return v.VisitPointWithContext(ctx, *u.point)
	}
}

type GeoCustomFeatureVisitorWithContext interface {
	VisitPointWithContext(ctx context.Context, v GeoPoint) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeoCustomFeatureFromPoint(v GeoPoint) GeoCustomFeature {
	return GeoCustomFeature{typ: "point", point: &v}
}

// Specifies how values of a secondary channel should be visualized.
type GeoSecondaryPlotVisualizationOption struct {
	typ      string
	asColors *ValueToColorMap
}

type geoSecondaryPlotVisualizationOptionDeserializer struct {
	Type     string           `json:"type"`
	AsColors *ValueToColorMap `json:"asColors"`
}

func (u *geoSecondaryPlotVisualizationOptionDeserializer) toStruct() GeoSecondaryPlotVisualizationOption {
	return GeoSecondaryPlotVisualizationOption{typ: u.Type, asColors: u.AsColors}
}

func (u *GeoSecondaryPlotVisualizationOption) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "asColors":
		if u.asColors == nil {
			return nil, fmt.Errorf("field \"asColors\" is required")
		}
		return struct {
			Type     string          `json:"type"`
			AsColors ValueToColorMap `json:"asColors"`
		}{Type: "asColors", AsColors: *u.asColors}, nil
	}
}

func (u GeoSecondaryPlotVisualizationOption) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *GeoSecondaryPlotVisualizationOption) UnmarshalJSON(data []byte) error {
	var deser geoSecondaryPlotVisualizationOptionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "asColors":
		if u.asColors == nil {
			return fmt.Errorf("field \"asColors\" is required")
		}
	}
	return nil
}

func (u GeoSecondaryPlotVisualizationOption) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *GeoSecondaryPlotVisualizationOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *GeoSecondaryPlotVisualizationOption) AcceptFuncs(asColorsFunc func(ValueToColorMap) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "asColors":
		if u.asColors == nil {
			return fmt.Errorf("field \"asColors\" is required")
		}
		return asColorsFunc(*u.asColors)
	}
}

func (u *GeoSecondaryPlotVisualizationOption) AsColorsNoopSuccess(ValueToColorMap) error {
	return nil
}

func (u *GeoSecondaryPlotVisualizationOption) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *GeoSecondaryPlotVisualizationOption) Accept(v GeoSecondaryPlotVisualizationOptionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "asColors":
		if u.asColors == nil {
			return fmt.Errorf("field \"asColors\" is required")
		}
		return v.VisitAsColors(*u.asColors)
	}
}

type GeoSecondaryPlotVisualizationOptionVisitor interface {
	VisitAsColors(v ValueToColorMap) error
	VisitUnknown(typeName string) error
}

func (u *GeoSecondaryPlotVisualizationOption) AcceptWithContext(ctx context.Context, v GeoSecondaryPlotVisualizationOptionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "asColors":
		if u.asColors == nil {
			return fmt.Errorf("field \"asColors\" is required")
		}
		return v.VisitAsColorsWithContext(ctx, *u.asColors)
	}
}

type GeoSecondaryPlotVisualizationOptionVisitorWithContext interface {
	VisitAsColorsWithContext(ctx context.Context, v ValueToColorMap) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeoSecondaryPlotVisualizationOptionFromAsColors(v ValueToColorMap) GeoSecondaryPlotVisualizationOption {
	return GeoSecondaryPlotVisualizationOption{typ: "asColors", asColors: &v}
}

type GeoVizDefinition struct {
	typ string
	v1  *GeoVizDefinitionV1
}

type geoVizDefinitionDeserializer struct {
	Type string              `json:"type"`
	V1   *GeoVizDefinitionV1 `json:"v1"`
}

func (u *geoVizDefinitionDeserializer) toStruct() GeoVizDefinition {
	return GeoVizDefinition{typ: u.Type, v1: u.V1}
}

func (u *GeoVizDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string             `json:"type"`
			V1   GeoVizDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u GeoVizDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *GeoVizDefinition) UnmarshalJSON(data []byte) error {
	var deser geoVizDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u GeoVizDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *GeoVizDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *GeoVizDefinition) AcceptFuncs(v1Func func(GeoVizDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *GeoVizDefinition) V1NoopSuccess(GeoVizDefinitionV1) error {
	return nil
}

func (u *GeoVizDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *GeoVizDefinition) Accept(v GeoVizDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type GeoVizDefinitionVisitor interface {
	VisitV1(v GeoVizDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *GeoVizDefinition) AcceptWithContext(ctx context.Context, v GeoVizDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type GeoVizDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v GeoVizDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeoVizDefinitionFromV1(v GeoVizDefinitionV1) GeoVizDefinition {
	return GeoVizDefinition{typ: "v1", v1: &v}
}

type HistogramChartDefinition struct {
	typ string
	v1  *HistogramChartDefinitionV1
}

type histogramChartDefinitionDeserializer struct {
	Type string                      `json:"type"`
	V1   *HistogramChartDefinitionV1 `json:"v1"`
}

func (u *histogramChartDefinitionDeserializer) toStruct() HistogramChartDefinition {
	return HistogramChartDefinition{typ: u.Type, v1: u.V1}
}

func (u *HistogramChartDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                     `json:"type"`
			V1   HistogramChartDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u HistogramChartDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *HistogramChartDefinition) UnmarshalJSON(data []byte) error {
	var deser histogramChartDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u HistogramChartDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *HistogramChartDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *HistogramChartDefinition) AcceptFuncs(v1Func func(HistogramChartDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *HistogramChartDefinition) V1NoopSuccess(HistogramChartDefinitionV1) error {
	return nil
}

func (u *HistogramChartDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *HistogramChartDefinition) Accept(v HistogramChartDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type HistogramChartDefinitionVisitor interface {
	VisitV1(v HistogramChartDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *HistogramChartDefinition) AcceptWithContext(ctx context.Context, v HistogramChartDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type HistogramChartDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v HistogramChartDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewHistogramChartDefinitionFromV1(v HistogramChartDefinitionV1) HistogramChartDefinition {
	return HistogramChartDefinition{typ: "v1", v1: &v}
}

type LineStyle struct {
	typ string
	v1  *LineStyleV1
}

type lineStyleDeserializer struct {
	Type string       `json:"type"`
	V1   *LineStyleV1 `json:"v1"`
}

func (u *lineStyleDeserializer) toStruct() LineStyle {
	return LineStyle{typ: u.Type, v1: u.V1}
}

func (u *LineStyle) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string      `json:"type"`
			V1   LineStyleV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u LineStyle) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LineStyle) UnmarshalJSON(data []byte) error {
	var deser lineStyleDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u LineStyle) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LineStyle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LineStyle) AcceptFuncs(v1Func func(LineStyleV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *LineStyle) V1NoopSuccess(LineStyleV1) error {
	return nil
}

func (u *LineStyle) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LineStyle) Accept(v LineStyleVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type LineStyleVisitor interface {
	VisitV1(v LineStyleV1) error
	VisitUnknown(typeName string) error
}

func (u *LineStyle) AcceptWithContext(ctx context.Context, v LineStyleVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type LineStyleVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v LineStyleV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLineStyleFromV1(v LineStyleV1) LineStyle {
	return LineStyle{typ: "v1", v1: &v}
}

type LogPanelDefinition struct {
	typ string
	v1  *LogPanelDefinitionV1
}

type logPanelDefinitionDeserializer struct {
	Type string                `json:"type"`
	V1   *LogPanelDefinitionV1 `json:"v1"`
}

func (u *logPanelDefinitionDeserializer) toStruct() LogPanelDefinition {
	return LogPanelDefinition{typ: u.Type, v1: u.V1}
}

func (u *LogPanelDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string               `json:"type"`
			V1   LogPanelDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u LogPanelDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LogPanelDefinition) UnmarshalJSON(data []byte) error {
	var deser logPanelDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u LogPanelDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LogPanelDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LogPanelDefinition) AcceptFuncs(v1Func func(LogPanelDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *LogPanelDefinition) V1NoopSuccess(LogPanelDefinitionV1) error {
	return nil
}

func (u *LogPanelDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LogPanelDefinition) Accept(v LogPanelDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type LogPanelDefinitionVisitor interface {
	VisitV1(v LogPanelDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *LogPanelDefinition) AcceptWithContext(ctx context.Context, v LogPanelDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type LogPanelDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v LogPanelDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLogPanelDefinitionFromV1(v LogPanelDefinitionV1) LogPanelDefinition {
	return LogPanelDefinition{typ: "v1", v1: &v}
}

type NumericArrayVisualisation struct {
	typ string
	raw *NumericArrayRawVisualisation
}

type numericArrayVisualisationDeserializer struct {
	Type string                        `json:"type"`
	Raw  *NumericArrayRawVisualisation `json:"raw"`
}

func (u *numericArrayVisualisationDeserializer) toStruct() NumericArrayVisualisation {
	return NumericArrayVisualisation{typ: u.Type, raw: u.Raw}
}

func (u *NumericArrayVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                       `json:"type"`
			Raw  NumericArrayRawVisualisation `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u NumericArrayVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericArrayVisualisation) UnmarshalJSON(data []byte) error {
	var deser numericArrayVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u NumericArrayVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericArrayVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericArrayVisualisation) AcceptFuncs(rawFunc func(NumericArrayRawVisualisation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *NumericArrayVisualisation) RawNoopSuccess(NumericArrayRawVisualisation) error {
	return nil
}

func (u *NumericArrayVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericArrayVisualisation) Accept(v NumericArrayVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type NumericArrayVisualisationVisitor interface {
	VisitRaw(v NumericArrayRawVisualisation) error
	VisitUnknown(typeName string) error
}

func (u *NumericArrayVisualisation) AcceptWithContext(ctx context.Context, v NumericArrayVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type NumericArrayVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v NumericArrayRawVisualisation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericArrayVisualisationFromRaw(v NumericArrayRawVisualisation) NumericArrayVisualisation {
	return NumericArrayVisualisation{typ: "raw", raw: &v}
}

type NumericGroupBySort struct {
	typ   string
	value *ValueSort
}

type numericGroupBySortDeserializer struct {
	Type  string     `json:"type"`
	Value *ValueSort `json:"value"`
}

func (u *numericGroupBySortDeserializer) toStruct() NumericGroupBySort {
	return NumericGroupBySort{typ: u.Type, value: u.Value}
}

func (u *NumericGroupBySort) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "value":
		if u.value == nil {
			return nil, fmt.Errorf("field \"value\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Value ValueSort `json:"value"`
		}{Type: "value", Value: *u.value}, nil
	}
}

func (u NumericGroupBySort) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericGroupBySort) UnmarshalJSON(data []byte) error {
	var deser numericGroupBySortDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
	}
	return nil
}

func (u NumericGroupBySort) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericGroupBySort) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericGroupBySort) AcceptFuncs(valueFunc func(ValueSort) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *NumericGroupBySort) ValueNoopSuccess(ValueSort) error {
	return nil
}

func (u *NumericGroupBySort) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericGroupBySort) Accept(v NumericGroupBySortVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(*u.value)
	}
}

type NumericGroupBySortVisitor interface {
	VisitValue(v ValueSort) error
	VisitUnknown(typeName string) error
}

func (u *NumericGroupBySort) AcceptWithContext(ctx context.Context, v NumericGroupBySortVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValueWithContext(ctx, *u.value)
	}
}

type NumericGroupBySortVisitorWithContext interface {
	VisitValueWithContext(ctx context.Context, v ValueSort) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericGroupBySortFromValue(v ValueSort) NumericGroupBySort {
	return NumericGroupBySort{typ: "value", value: &v}
}

type NumericValueVisualisation struct {
	typ      string
	raw      *NumericRawVisualisation
	barGauge *NumericBarGaugeVisualisation
}

type numericValueVisualisationDeserializer struct {
	Type     string                        `json:"type"`
	Raw      *NumericRawVisualisation      `json:"raw"`
	BarGauge *NumericBarGaugeVisualisation `json:"barGauge"`
}

func (u *numericValueVisualisationDeserializer) toStruct() NumericValueVisualisation {
	return NumericValueVisualisation{typ: u.Type, raw: u.Raw, barGauge: u.BarGauge}
}

func (u *NumericValueVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                  `json:"type"`
			Raw  NumericRawVisualisation `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "barGauge":
		if u.barGauge == nil {
			return nil, fmt.Errorf("field \"barGauge\" is required")
		}
		return struct {
			Type     string                       `json:"type"`
			BarGauge NumericBarGaugeVisualisation `json:"barGauge"`
		}{Type: "barGauge", BarGauge: *u.barGauge}, nil
	}
}

func (u NumericValueVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericValueVisualisation) UnmarshalJSON(data []byte) error {
	var deser numericValueVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "barGauge":
		if u.barGauge == nil {
			return fmt.Errorf("field \"barGauge\" is required")
		}
	}
	return nil
}

func (u NumericValueVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericValueVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericValueVisualisation) AcceptFuncs(rawFunc func(NumericRawVisualisation) error, barGaugeFunc func(NumericBarGaugeVisualisation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "barGauge":
		if u.barGauge == nil {
			return fmt.Errorf("field \"barGauge\" is required")
		}
		return barGaugeFunc(*u.barGauge)
	}
}

func (u *NumericValueVisualisation) RawNoopSuccess(NumericRawVisualisation) error {
	return nil
}

func (u *NumericValueVisualisation) BarGaugeNoopSuccess(NumericBarGaugeVisualisation) error {
	return nil
}

func (u *NumericValueVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericValueVisualisation) Accept(v NumericValueVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "barGauge":
		if u.barGauge == nil {
			return fmt.Errorf("field \"barGauge\" is required")
		}
		return v.VisitBarGauge(*u.barGauge)
	}
}

type NumericValueVisualisationVisitor interface {
	VisitRaw(v NumericRawVisualisation) error
	VisitBarGauge(v NumericBarGaugeVisualisation) error
	VisitUnknown(typeName string) error
}

func (u *NumericValueVisualisation) AcceptWithContext(ctx context.Context, v NumericValueVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "barGauge":
		if u.barGauge == nil {
			return fmt.Errorf("field \"barGauge\" is required")
		}
		return v.VisitBarGaugeWithContext(ctx, *u.barGauge)
	}
}

type NumericValueVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v NumericRawVisualisation) error
	VisitBarGaugeWithContext(ctx context.Context, v NumericBarGaugeVisualisation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericValueVisualisationFromRaw(v NumericRawVisualisation) NumericValueVisualisation {
	return NumericValueVisualisation{typ: "raw", raw: &v}
}

func NewNumericValueVisualisationFromBarGauge(v NumericBarGaugeVisualisation) NumericValueVisualisation {
	return NumericValueVisualisation{typ: "barGauge", barGauge: &v}
}

type NumericValueVisualisationV2 struct {
	typ string
	raw *NumericRawVisualisationV2
	bar *NumericBarVisualisationV2
}

type numericValueVisualisationV2Deserializer struct {
	Type string                     `json:"type"`
	Raw  *NumericRawVisualisationV2 `json:"raw"`
	Bar  *NumericBarVisualisationV2 `json:"bar"`
}

func (u *numericValueVisualisationV2Deserializer) toStruct() NumericValueVisualisationV2 {
	return NumericValueVisualisationV2{typ: u.Type, raw: u.Raw, bar: u.Bar}
}

func (u *NumericValueVisualisationV2) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			Raw  NumericRawVisualisationV2 `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "bar":
		if u.bar == nil {
			return nil, fmt.Errorf("field \"bar\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			Bar  NumericBarVisualisationV2 `json:"bar"`
		}{Type: "bar", Bar: *u.bar}, nil
	}
}

func (u NumericValueVisualisationV2) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericValueVisualisationV2) UnmarshalJSON(data []byte) error {
	var deser numericValueVisualisationV2Deserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
	}
	return nil
}

func (u NumericValueVisualisationV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericValueVisualisationV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericValueVisualisationV2) AcceptFuncs(rawFunc func(NumericRawVisualisationV2) error, barFunc func(NumericBarVisualisationV2) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return barFunc(*u.bar)
	}
}

func (u *NumericValueVisualisationV2) RawNoopSuccess(NumericRawVisualisationV2) error {
	return nil
}

func (u *NumericValueVisualisationV2) BarNoopSuccess(NumericBarVisualisationV2) error {
	return nil
}

func (u *NumericValueVisualisationV2) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericValueVisualisationV2) Accept(v NumericValueVisualisationV2Visitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBar(*u.bar)
	}
}

type NumericValueVisualisationV2Visitor interface {
	VisitRaw(v NumericRawVisualisationV2) error
	VisitBar(v NumericBarVisualisationV2) error
	VisitUnknown(typeName string) error
}

func (u *NumericValueVisualisationV2) AcceptWithContext(ctx context.Context, v NumericValueVisualisationV2VisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBarWithContext(ctx, *u.bar)
	}
}

type NumericValueVisualisationV2VisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v NumericRawVisualisationV2) error
	VisitBarWithContext(ctx context.Context, v NumericBarVisualisationV2) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericValueVisualisationV2FromRaw(v NumericRawVisualisationV2) NumericValueVisualisationV2 {
	return NumericValueVisualisationV2{typ: "raw", raw: &v}
}

func NewNumericValueVisualisationV2FromBar(v NumericBarVisualisationV2) NumericValueVisualisationV2 {
	return NumericValueVisualisationV2{typ: "bar", bar: &v}
}

type PanelBucketStrategy struct {
	typ      string
	auto     *PanelBucketStrategyAuto
	fixed    *PanelBucketStrategyFixed
	duration *PanelBucketStrategyDuration
}

type panelBucketStrategyDeserializer struct {
	Type     string                       `json:"type"`
	Auto     *PanelBucketStrategyAuto     `json:"auto"`
	Fixed    *PanelBucketStrategyFixed    `json:"fixed"`
	Duration *PanelBucketStrategyDuration `json:"duration"`
}

func (u *panelBucketStrategyDeserializer) toStruct() PanelBucketStrategy {
	return PanelBucketStrategy{typ: u.Type, auto: u.Auto, fixed: u.Fixed, duration: u.Duration}
}

func (u *PanelBucketStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "auto":
		if u.auto == nil {
			return nil, fmt.Errorf("field \"auto\" is required")
		}
		return struct {
			Type string                  `json:"type"`
			Auto PanelBucketStrategyAuto `json:"auto"`
		}{Type: "auto", Auto: *u.auto}, nil
	case "fixed":
		if u.fixed == nil {
			return nil, fmt.Errorf("field \"fixed\" is required")
		}
		return struct {
			Type  string                   `json:"type"`
			Fixed PanelBucketStrategyFixed `json:"fixed"`
		}{Type: "fixed", Fixed: *u.fixed}, nil
	case "duration":
		if u.duration == nil {
			return nil, fmt.Errorf("field \"duration\" is required")
		}
		return struct {
			Type     string                      `json:"type"`
			Duration PanelBucketStrategyDuration `json:"duration"`
		}{Type: "duration", Duration: *u.duration}, nil
	}
}

func (u PanelBucketStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PanelBucketStrategy) UnmarshalJSON(data []byte) error {
	var deser panelBucketStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "auto":
		if u.auto == nil {
			return fmt.Errorf("field \"auto\" is required")
		}
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
	}
	return nil
}

func (u PanelBucketStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PanelBucketStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PanelBucketStrategy) AcceptFuncs(autoFunc func(PanelBucketStrategyAuto) error, fixedFunc func(PanelBucketStrategyFixed) error, durationFunc func(PanelBucketStrategyDuration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "auto":
		if u.auto == nil {
			return fmt.Errorf("field \"auto\" is required")
		}
		return autoFunc(*u.auto)
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
		return fixedFunc(*u.fixed)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return durationFunc(*u.duration)
	}
}

func (u *PanelBucketStrategy) AutoNoopSuccess(PanelBucketStrategyAuto) error {
	return nil
}

func (u *PanelBucketStrategy) FixedNoopSuccess(PanelBucketStrategyFixed) error {
	return nil
}

func (u *PanelBucketStrategy) DurationNoopSuccess(PanelBucketStrategyDuration) error {
	return nil
}

func (u *PanelBucketStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PanelBucketStrategy) Accept(v PanelBucketStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "auto":
		if u.auto == nil {
			return fmt.Errorf("field \"auto\" is required")
		}
		return v.VisitAuto(*u.auto)
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
		return v.VisitFixed(*u.fixed)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDuration(*u.duration)
	}
}

type PanelBucketStrategyVisitor interface {
	VisitAuto(v PanelBucketStrategyAuto) error
	VisitFixed(v PanelBucketStrategyFixed) error
	VisitDuration(v PanelBucketStrategyDuration) error
	VisitUnknown(typeName string) error
}

func (u *PanelBucketStrategy) AcceptWithContext(ctx context.Context, v PanelBucketStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "auto":
		if u.auto == nil {
			return fmt.Errorf("field \"auto\" is required")
		}
		return v.VisitAutoWithContext(ctx, *u.auto)
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
		return v.VisitFixedWithContext(ctx, *u.fixed)
	case "duration":
		if u.duration == nil {
			return fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDurationWithContext(ctx, *u.duration)
	}
}

type PanelBucketStrategyVisitorWithContext interface {
	VisitAutoWithContext(ctx context.Context, v PanelBucketStrategyAuto) error
	VisitFixedWithContext(ctx context.Context, v PanelBucketStrategyFixed) error
	VisitDurationWithContext(ctx context.Context, v PanelBucketStrategyDuration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPanelBucketStrategyFromAuto(v PanelBucketStrategyAuto) PanelBucketStrategy {
	return PanelBucketStrategy{typ: "auto", auto: &v}
}

func NewPanelBucketStrategyFromFixed(v PanelBucketStrategyFixed) PanelBucketStrategy {
	return PanelBucketStrategy{typ: "fixed", fixed: &v}
}

func NewPanelBucketStrategyFromDuration(v PanelBucketStrategyDuration) PanelBucketStrategy {
	return PanelBucketStrategy{typ: "duration", duration: &v}
}

type PersistValueOverlay struct {
	typ     string
	byValue *PersistByValue
	all     *PersistAll
}

type persistValueOverlayDeserializer struct {
	Type    string          `json:"type"`
	ByValue *PersistByValue `json:"byValue"`
	All     *PersistAll     `json:"all"`
}

func (u *persistValueOverlayDeserializer) toStruct() PersistValueOverlay {
	return PersistValueOverlay{typ: u.Type, byValue: u.ByValue, all: u.All}
}

func (u *PersistValueOverlay) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "byValue":
		if u.byValue == nil {
			return nil, fmt.Errorf("field \"byValue\" is required")
		}
		return struct {
			Type    string         `json:"type"`
			ByValue PersistByValue `json:"byValue"`
		}{Type: "byValue", ByValue: *u.byValue}, nil
	case "all":
		if u.all == nil {
			return nil, fmt.Errorf("field \"all\" is required")
		}
		return struct {
			Type string     `json:"type"`
			All  PersistAll `json:"all"`
		}{Type: "all", All: *u.all}, nil
	}
}

func (u PersistValueOverlay) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PersistValueOverlay) UnmarshalJSON(data []byte) error {
	var deser persistValueOverlayDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "byValue":
		if u.byValue == nil {
			return fmt.Errorf("field \"byValue\" is required")
		}
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
	}
	return nil
}

func (u PersistValueOverlay) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PersistValueOverlay) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PersistValueOverlay) AcceptFuncs(byValueFunc func(PersistByValue) error, allFunc func(PersistAll) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "byValue":
		if u.byValue == nil {
			return fmt.Errorf("field \"byValue\" is required")
		}
		return byValueFunc(*u.byValue)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return allFunc(*u.all)
	}
}

func (u *PersistValueOverlay) ByValueNoopSuccess(PersistByValue) error {
	return nil
}

func (u *PersistValueOverlay) AllNoopSuccess(PersistAll) error {
	return nil
}

func (u *PersistValueOverlay) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PersistValueOverlay) Accept(v PersistValueOverlayVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "byValue":
		if u.byValue == nil {
			return fmt.Errorf("field \"byValue\" is required")
		}
		return v.VisitByValue(*u.byValue)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAll(*u.all)
	}
}

type PersistValueOverlayVisitor interface {
	VisitByValue(v PersistByValue) error
	VisitAll(v PersistAll) error
	VisitUnknown(typeName string) error
}

func (u *PersistValueOverlay) AcceptWithContext(ctx context.Context, v PersistValueOverlayVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "byValue":
		if u.byValue == nil {
			return fmt.Errorf("field \"byValue\" is required")
		}
		return v.VisitByValueWithContext(ctx, *u.byValue)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAllWithContext(ctx, *u.all)
	}
}

type PersistValueOverlayVisitorWithContext interface {
	VisitByValueWithContext(ctx context.Context, v PersistByValue) error
	VisitAllWithContext(ctx context.Context, v PersistAll) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPersistValueOverlayFromByValue(v PersistByValue) PersistValueOverlay {
	return PersistValueOverlay{typ: "byValue", byValue: &v}
}

func NewPersistValueOverlayFromAll(v PersistAll) PersistValueOverlay {
	return PersistValueOverlay{typ: "all", all: &v}
}

type PlotColoringConfiguration struct {
	typ            string
	rowIndependent *RowIndependentPlotColoringConfiguration
	rowShared      *RowSharedPlotColoringConfiguration
}

type plotColoringConfigurationDeserializer struct {
	Type           string                                   `json:"type"`
	RowIndependent *RowIndependentPlotColoringConfiguration `json:"rowIndependent"`
	RowShared      *RowSharedPlotColoringConfiguration      `json:"rowShared"`
}

func (u *plotColoringConfigurationDeserializer) toStruct() PlotColoringConfiguration {
	return PlotColoringConfiguration{typ: u.Type, rowIndependent: u.RowIndependent, rowShared: u.RowShared}
}

func (u *PlotColoringConfiguration) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "rowIndependent":
		if u.rowIndependent == nil {
			return nil, fmt.Errorf("field \"rowIndependent\" is required")
		}
		return struct {
			Type           string                                  `json:"type"`
			RowIndependent RowIndependentPlotColoringConfiguration `json:"rowIndependent"`
		}{Type: "rowIndependent", RowIndependent: *u.rowIndependent}, nil
	case "rowShared":
		if u.rowShared == nil {
			return nil, fmt.Errorf("field \"rowShared\" is required")
		}
		return struct {
			Type      string                             `json:"type"`
			RowShared RowSharedPlotColoringConfiguration `json:"rowShared"`
		}{Type: "rowShared", RowShared: *u.rowShared}, nil
	}
}

func (u PlotColoringConfiguration) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PlotColoringConfiguration) UnmarshalJSON(data []byte) error {
	var deser plotColoringConfigurationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "rowIndependent":
		if u.rowIndependent == nil {
			return fmt.Errorf("field \"rowIndependent\" is required")
		}
	case "rowShared":
		if u.rowShared == nil {
			return fmt.Errorf("field \"rowShared\" is required")
		}
	}
	return nil
}

func (u PlotColoringConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PlotColoringConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PlotColoringConfiguration) AcceptFuncs(rowIndependentFunc func(RowIndependentPlotColoringConfiguration) error, rowSharedFunc func(RowSharedPlotColoringConfiguration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "rowIndependent":
		if u.rowIndependent == nil {
			return fmt.Errorf("field \"rowIndependent\" is required")
		}
		return rowIndependentFunc(*u.rowIndependent)
	case "rowShared":
		if u.rowShared == nil {
			return fmt.Errorf("field \"rowShared\" is required")
		}
		return rowSharedFunc(*u.rowShared)
	}
}

func (u *PlotColoringConfiguration) RowIndependentNoopSuccess(RowIndependentPlotColoringConfiguration) error {
	return nil
}

func (u *PlotColoringConfiguration) RowSharedNoopSuccess(RowSharedPlotColoringConfiguration) error {
	return nil
}

func (u *PlotColoringConfiguration) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PlotColoringConfiguration) Accept(v PlotColoringConfigurationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "rowIndependent":
		if u.rowIndependent == nil {
			return fmt.Errorf("field \"rowIndependent\" is required")
		}
		return v.VisitRowIndependent(*u.rowIndependent)
	case "rowShared":
		if u.rowShared == nil {
			return fmt.Errorf("field \"rowShared\" is required")
		}
		return v.VisitRowShared(*u.rowShared)
	}
}

type PlotColoringConfigurationVisitor interface {
	VisitRowIndependent(v RowIndependentPlotColoringConfiguration) error
	VisitRowShared(v RowSharedPlotColoringConfiguration) error
	VisitUnknown(typeName string) error
}

func (u *PlotColoringConfiguration) AcceptWithContext(ctx context.Context, v PlotColoringConfigurationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "rowIndependent":
		if u.rowIndependent == nil {
			return fmt.Errorf("field \"rowIndependent\" is required")
		}
		return v.VisitRowIndependentWithContext(ctx, *u.rowIndependent)
	case "rowShared":
		if u.rowShared == nil {
			return fmt.Errorf("field \"rowShared\" is required")
		}
		return v.VisitRowSharedWithContext(ctx, *u.rowShared)
	}
}

type PlotColoringConfigurationVisitorWithContext interface {
	VisitRowIndependentWithContext(ctx context.Context, v RowIndependentPlotColoringConfiguration) error
	VisitRowSharedWithContext(ctx context.Context, v RowSharedPlotColoringConfiguration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPlotColoringConfigurationFromRowIndependent(v RowIndependentPlotColoringConfiguration) PlotColoringConfiguration {
	return PlotColoringConfiguration{typ: "rowIndependent", rowIndependent: &v}
}

func NewPlotColoringConfigurationFromRowShared(v RowSharedPlotColoringConfiguration) PlotColoringConfiguration {
	return PlotColoringConfiguration{typ: "rowShared", rowShared: &v}
}

type PlotlyPanelDefinition struct {
	typ string
	v1  *PlotlyPanelDefinitionV1
}

type plotlyPanelDefinitionDeserializer struct {
	Type string                   `json:"type"`
	V1   *PlotlyPanelDefinitionV1 `json:"v1"`
}

func (u *plotlyPanelDefinitionDeserializer) toStruct() PlotlyPanelDefinition {
	return PlotlyPanelDefinition{typ: u.Type, v1: u.V1}
}

func (u *PlotlyPanelDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                  `json:"type"`
			V1   PlotlyPanelDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u PlotlyPanelDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PlotlyPanelDefinition) UnmarshalJSON(data []byte) error {
	var deser plotlyPanelDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u PlotlyPanelDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PlotlyPanelDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PlotlyPanelDefinition) AcceptFuncs(v1Func func(PlotlyPanelDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *PlotlyPanelDefinition) V1NoopSuccess(PlotlyPanelDefinitionV1) error {
	return nil
}

func (u *PlotlyPanelDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PlotlyPanelDefinition) Accept(v PlotlyPanelDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type PlotlyPanelDefinitionVisitor interface {
	VisitV1(v PlotlyPanelDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *PlotlyPanelDefinition) AcceptWithContext(ctx context.Context, v PlotlyPanelDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type PlotlyPanelDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v PlotlyPanelDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPlotlyPanelDefinitionFromV1(v PlotlyPanelDefinitionV1) PlotlyPanelDefinition {
	return PlotlyPanelDefinition{typ: "v1", v1: &v}
}

type ProcedureVizDefinition struct {
	typ string
	v1  *ProcedureVizDefinitionV1
	v2  *ProcedureVizDefinitionV2
}

type procedureVizDefinitionDeserializer struct {
	Type string                    `json:"type"`
	V1   *ProcedureVizDefinitionV1 `json:"v1"`
	V2   *ProcedureVizDefinitionV2 `json:"v2"`
}

func (u *procedureVizDefinitionDeserializer) toStruct() ProcedureVizDefinition {
	return ProcedureVizDefinition{typ: u.Type, v1: u.V1, v2: u.V2}
}

func (u *ProcedureVizDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                   `json:"type"`
			V1   ProcedureVizDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	case "v2":
		if u.v2 == nil {
			return nil, fmt.Errorf("field \"v2\" is required")
		}
		return struct {
			Type string                   `json:"type"`
			V2   ProcedureVizDefinitionV2 `json:"v2"`
		}{Type: "v2", V2: *u.v2}, nil
	}
}

func (u ProcedureVizDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ProcedureVizDefinition) UnmarshalJSON(data []byte) error {
	var deser procedureVizDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
	}
	return nil
}

func (u ProcedureVizDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ProcedureVizDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ProcedureVizDefinition) AcceptFuncs(v1Func func(ProcedureVizDefinitionV1) error, v2Func func(ProcedureVizDefinitionV2) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *ProcedureVizDefinition) V1NoopSuccess(ProcedureVizDefinitionV1) error {
	return nil
}

func (u *ProcedureVizDefinition) V2NoopSuccess(ProcedureVizDefinitionV2) error {
	return nil
}

func (u *ProcedureVizDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ProcedureVizDefinition) Accept(v ProcedureVizDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(*u.v2)
	}
}

type ProcedureVizDefinitionVisitor interface {
	VisitV1(v ProcedureVizDefinitionV1) error
	VisitV2(v ProcedureVizDefinitionV2) error
	VisitUnknown(typeName string) error
}

func (u *ProcedureVizDefinition) AcceptWithContext(ctx context.Context, v ProcedureVizDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2WithContext(ctx, *u.v2)
	}
}

type ProcedureVizDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v ProcedureVizDefinitionV1) error
	VisitV2WithContext(ctx context.Context, v ProcedureVizDefinitionV2) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewProcedureVizDefinitionFromV1(v ProcedureVizDefinitionV1) ProcedureVizDefinition {
	return ProcedureVizDefinition{typ: "v1", v1: &v}
}

func NewProcedureVizDefinitionFromV2(v ProcedureVizDefinitionV2) ProcedureVizDefinition {
	return ProcedureVizDefinition{typ: "v2", v2: &v}
}

type ProcedureVizId struct {
	typ          string
	executionRid *rids.ProcedureExecutionRid
	templateRid  *rids.ProcedureRid
}

type procedureVizIdDeserializer struct {
	Type         string                      `json:"type"`
	ExecutionRid *rids.ProcedureExecutionRid `json:"executionRid"`
	TemplateRid  *rids.ProcedureRid          `json:"templateRid"`
}

func (u *procedureVizIdDeserializer) toStruct() ProcedureVizId {
	return ProcedureVizId{typ: u.Type, executionRid: u.ExecutionRid, templateRid: u.TemplateRid}
}

func (u *ProcedureVizId) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "executionRid":
		if u.executionRid == nil {
			return nil, fmt.Errorf("field \"executionRid\" is required")
		}
		return struct {
			Type         string                     `json:"type"`
			ExecutionRid rids.ProcedureExecutionRid `json:"executionRid"`
		}{Type: "executionRid", ExecutionRid: *u.executionRid}, nil
	case "templateRid":
		if u.templateRid == nil {
			return nil, fmt.Errorf("field \"templateRid\" is required")
		}
		return struct {
			Type        string            `json:"type"`
			TemplateRid rids.ProcedureRid `json:"templateRid"`
		}{Type: "templateRid", TemplateRid: *u.templateRid}, nil
	}
}

func (u ProcedureVizId) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ProcedureVizId) UnmarshalJSON(data []byte) error {
	var deser procedureVizIdDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "executionRid":
		if u.executionRid == nil {
			return fmt.Errorf("field \"executionRid\" is required")
		}
	case "templateRid":
		if u.templateRid == nil {
			return fmt.Errorf("field \"templateRid\" is required")
		}
	}
	return nil
}

func (u ProcedureVizId) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ProcedureVizId) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ProcedureVizId) AcceptFuncs(executionRidFunc func(rids.ProcedureExecutionRid) error, templateRidFunc func(rids.ProcedureRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "executionRid":
		if u.executionRid == nil {
			return fmt.Errorf("field \"executionRid\" is required")
		}
		return executionRidFunc(*u.executionRid)
	case "templateRid":
		if u.templateRid == nil {
			return fmt.Errorf("field \"templateRid\" is required")
		}
		return templateRidFunc(*u.templateRid)
	}
}

func (u *ProcedureVizId) ExecutionRidNoopSuccess(rids.ProcedureExecutionRid) error {
	return nil
}

func (u *ProcedureVizId) TemplateRidNoopSuccess(rids.ProcedureRid) error {
	return nil
}

func (u *ProcedureVizId) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ProcedureVizId) Accept(v ProcedureVizIdVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "executionRid":
		if u.executionRid == nil {
			return fmt.Errorf("field \"executionRid\" is required")
		}
		return v.VisitExecutionRid(*u.executionRid)
	case "templateRid":
		if u.templateRid == nil {
			return fmt.Errorf("field \"templateRid\" is required")
		}
		return v.VisitTemplateRid(*u.templateRid)
	}
}

type ProcedureVizIdVisitor interface {
	VisitExecutionRid(v rids.ProcedureExecutionRid) error
	VisitTemplateRid(v rids.ProcedureRid) error
	VisitUnknown(typeName string) error
}

func (u *ProcedureVizId) AcceptWithContext(ctx context.Context, v ProcedureVizIdVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "executionRid":
		if u.executionRid == nil {
			return fmt.Errorf("field \"executionRid\" is required")
		}
		return v.VisitExecutionRidWithContext(ctx, *u.executionRid)
	case "templateRid":
		if u.templateRid == nil {
			return fmt.Errorf("field \"templateRid\" is required")
		}
		return v.VisitTemplateRidWithContext(ctx, *u.templateRid)
	}
}

type ProcedureVizIdVisitorWithContext interface {
	VisitExecutionRidWithContext(ctx context.Context, v rids.ProcedureExecutionRid) error
	VisitTemplateRidWithContext(ctx context.Context, v rids.ProcedureRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewProcedureVizIdFromExecutionRid(v rids.ProcedureExecutionRid) ProcedureVizId {
	return ProcedureVizId{typ: "executionRid", executionRid: &v}
}

func NewProcedureVizIdFromTemplateRid(v rids.ProcedureRid) ProcedureVizId {
	return ProcedureVizId{typ: "templateRid", templateRid: &v}
}

type RangeGroupBySort struct {
	typ   string
	value *ValueSort
}

type rangeGroupBySortDeserializer struct {
	Type  string     `json:"type"`
	Value *ValueSort `json:"value"`
}

func (u *rangeGroupBySortDeserializer) toStruct() RangeGroupBySort {
	return RangeGroupBySort{typ: u.Type, value: u.Value}
}

func (u *RangeGroupBySort) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "value":
		if u.value == nil {
			return nil, fmt.Errorf("field \"value\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Value ValueSort `json:"value"`
		}{Type: "value", Value: *u.value}, nil
	}
}

func (u RangeGroupBySort) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangeGroupBySort) UnmarshalJSON(data []byte) error {
	var deser rangeGroupBySortDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
	}
	return nil
}

func (u RangeGroupBySort) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangeGroupBySort) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangeGroupBySort) AcceptFuncs(valueFunc func(ValueSort) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *RangeGroupBySort) ValueNoopSuccess(ValueSort) error {
	return nil
}

func (u *RangeGroupBySort) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangeGroupBySort) Accept(v RangeGroupBySortVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(*u.value)
	}
}

type RangeGroupBySortVisitor interface {
	VisitValue(v ValueSort) error
	VisitUnknown(typeName string) error
}

func (u *RangeGroupBySort) AcceptWithContext(ctx context.Context, v RangeGroupBySortVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValueWithContext(ctx, *u.value)
	}
}

type RangeGroupBySortVisitorWithContext interface {
	VisitValueWithContext(ctx context.Context, v ValueSort) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangeGroupBySortFromValue(v ValueSort) RangeGroupBySort {
	return RangeGroupBySort{typ: "value", value: &v}
}

type RangeValueVisualisation struct {
	typ string
	raw *RangeRawVisualisation
}

type rangeValueVisualisationDeserializer struct {
	Type string                 `json:"type"`
	Raw  *RangeRawVisualisation `json:"raw"`
}

func (u *rangeValueVisualisationDeserializer) toStruct() RangeValueVisualisation {
	return RangeValueVisualisation{typ: u.Type, raw: u.Raw}
}

func (u *RangeValueVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                `json:"type"`
			Raw  RangeRawVisualisation `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u RangeValueVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangeValueVisualisation) UnmarshalJSON(data []byte) error {
	var deser rangeValueVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u RangeValueVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangeValueVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangeValueVisualisation) AcceptFuncs(rawFunc func(RangeRawVisualisation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *RangeValueVisualisation) RawNoopSuccess(RangeRawVisualisation) error {
	return nil
}

func (u *RangeValueVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangeValueVisualisation) Accept(v RangeValueVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type RangeValueVisualisationVisitor interface {
	VisitRaw(v RangeRawVisualisation) error
	VisitUnknown(typeName string) error
}

func (u *RangeValueVisualisation) AcceptWithContext(ctx context.Context, v RangeValueVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type RangeValueVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v RangeRawVisualisation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangeValueVisualisationFromRaw(v RangeRawVisualisation) RangeValueVisualisation {
	return RangeValueVisualisation{typ: "raw", raw: &v}
}

type StalenessVisualisation struct {
	typ string
	raw *NumericRawVisualisationV2
	bar *NumericBarVisualisationV2
}

type stalenessVisualisationDeserializer struct {
	Type string                     `json:"type"`
	Raw  *NumericRawVisualisationV2 `json:"raw"`
	Bar  *NumericBarVisualisationV2 `json:"bar"`
}

func (u *stalenessVisualisationDeserializer) toStruct() StalenessVisualisation {
	return StalenessVisualisation{typ: u.Type, raw: u.Raw, bar: u.Bar}
}

func (u *StalenessVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			Raw  NumericRawVisualisationV2 `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "bar":
		if u.bar == nil {
			return nil, fmt.Errorf("field \"bar\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			Bar  NumericBarVisualisationV2 `json:"bar"`
		}{Type: "bar", Bar: *u.bar}, nil
	}
}

func (u StalenessVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *StalenessVisualisation) UnmarshalJSON(data []byte) error {
	var deser stalenessVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
	}
	return nil
}

func (u StalenessVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *StalenessVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *StalenessVisualisation) AcceptFuncs(rawFunc func(NumericRawVisualisationV2) error, barFunc func(NumericBarVisualisationV2) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return barFunc(*u.bar)
	}
}

func (u *StalenessVisualisation) RawNoopSuccess(NumericRawVisualisationV2) error {
	return nil
}

func (u *StalenessVisualisation) BarNoopSuccess(NumericBarVisualisationV2) error {
	return nil
}

func (u *StalenessVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *StalenessVisualisation) Accept(v StalenessVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBar(*u.bar)
	}
}

type StalenessVisualisationVisitor interface {
	VisitRaw(v NumericRawVisualisationV2) error
	VisitBar(v NumericBarVisualisationV2) error
	VisitUnknown(typeName string) error
}

func (u *StalenessVisualisation) AcceptWithContext(ctx context.Context, v StalenessVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBarWithContext(ctx, *u.bar)
	}
}

type StalenessVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v NumericRawVisualisationV2) error
	VisitBarWithContext(ctx context.Context, v NumericBarVisualisationV2) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewStalenessVisualisationFromRaw(v NumericRawVisualisationV2) StalenessVisualisation {
	return StalenessVisualisation{typ: "raw", raw: &v}
}

func NewStalenessVisualisationFromBar(v NumericBarVisualisationV2) StalenessVisualisation {
	return StalenessVisualisation{typ: "bar", bar: &v}
}

type StructVisualisation struct {
	typ string
	raw *StructRawVisualisation
}

type structVisualisationDeserializer struct {
	Type string                  `json:"type"`
	Raw  *StructRawVisualisation `json:"raw"`
}

func (u *structVisualisationDeserializer) toStruct() StructVisualisation {
	return StructVisualisation{typ: u.Type, raw: u.Raw}
}

func (u *StructVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                 `json:"type"`
			Raw  StructRawVisualisation `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u StructVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *StructVisualisation) UnmarshalJSON(data []byte) error {
	var deser structVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u StructVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *StructVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *StructVisualisation) AcceptFuncs(rawFunc func(StructRawVisualisation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *StructVisualisation) RawNoopSuccess(StructRawVisualisation) error {
	return nil
}

func (u *StructVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *StructVisualisation) Accept(v StructVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type StructVisualisationVisitor interface {
	VisitRaw(v StructRawVisualisation) error
	VisitUnknown(typeName string) error
}

func (u *StructVisualisation) AcceptWithContext(ctx context.Context, v StructVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type StructVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v StructRawVisualisation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewStructVisualisationFromRaw(v StructRawVisualisation) StructVisualisation {
	return StructVisualisation{typ: "raw", raw: &v}
}

type TimeSeriesChartDefinition struct {
	typ string
	v1  *TimeSeriesChartDefinitionV1
}

type timeSeriesChartDefinitionDeserializer struct {
	Type string                       `json:"type"`
	V1   *TimeSeriesChartDefinitionV1 `json:"v1"`
}

func (u *timeSeriesChartDefinitionDeserializer) toStruct() TimeSeriesChartDefinition {
	return TimeSeriesChartDefinition{typ: u.Type, v1: u.V1}
}

func (u *TimeSeriesChartDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                      `json:"type"`
			V1   TimeSeriesChartDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u TimeSeriesChartDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimeSeriesChartDefinition) UnmarshalJSON(data []byte) error {
	var deser timeSeriesChartDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u TimeSeriesChartDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimeSeriesChartDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimeSeriesChartDefinition) AcceptFuncs(v1Func func(TimeSeriesChartDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *TimeSeriesChartDefinition) V1NoopSuccess(TimeSeriesChartDefinitionV1) error {
	return nil
}

func (u *TimeSeriesChartDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimeSeriesChartDefinition) Accept(v TimeSeriesChartDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type TimeSeriesChartDefinitionVisitor interface {
	VisitV1(v TimeSeriesChartDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *TimeSeriesChartDefinition) AcceptWithContext(ctx context.Context, v TimeSeriesChartDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type TimeSeriesChartDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v TimeSeriesChartDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimeSeriesChartDefinitionFromV1(v TimeSeriesChartDefinitionV1) TimeSeriesChartDefinition {
	return TimeSeriesChartDefinition{typ: "v1", v1: &v}
}

type TimeSeriesPlotConfig struct {
	typ     string
	numeric *TimeSeriesNumericPlot
	range_  *TimeSeriesRangePlot
	enum    *TimeSeriesEnumPlot
}

type timeSeriesPlotConfigDeserializer struct {
	Type    string                 `json:"type"`
	Numeric *TimeSeriesNumericPlot `json:"numeric"`
	Range   *TimeSeriesRangePlot   `json:"range"`
	Enum    *TimeSeriesEnumPlot    `json:"enum"`
}

func (u *timeSeriesPlotConfigDeserializer) toStruct() TimeSeriesPlotConfig {
	return TimeSeriesPlotConfig{typ: u.Type, numeric: u.Numeric, range_: u.Range, enum: u.Enum}
}

func (u *TimeSeriesPlotConfig) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string                `json:"type"`
			Numeric TimeSeriesNumericPlot `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "range":
		if u.range_ == nil {
			return nil, fmt.Errorf("field \"range\" is required")
		}
		return struct {
			Type  string              `json:"type"`
			Range TimeSeriesRangePlot `json:"range"`
		}{Type: "range", Range: *u.range_}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string             `json:"type"`
			Enum TimeSeriesEnumPlot `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	}
}

func (u TimeSeriesPlotConfig) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimeSeriesPlotConfig) UnmarshalJSON(data []byte) error {
	var deser timeSeriesPlotConfigDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	}
	return nil
}

func (u TimeSeriesPlotConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimeSeriesPlotConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimeSeriesPlotConfig) AcceptFuncs(numericFunc func(TimeSeriesNumericPlot) error, range_Func func(TimeSeriesRangePlot) error, enumFunc func(TimeSeriesEnumPlot) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	}
}

func (u *TimeSeriesPlotConfig) NumericNoopSuccess(TimeSeriesNumericPlot) error {
	return nil
}

func (u *TimeSeriesPlotConfig) RangeNoopSuccess(TimeSeriesRangePlot) error {
	return nil
}

func (u *TimeSeriesPlotConfig) EnumNoopSuccess(TimeSeriesEnumPlot) error {
	return nil
}

func (u *TimeSeriesPlotConfig) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimeSeriesPlotConfig) Accept(v TimeSeriesPlotConfigVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(*u.range_)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	}
}

type TimeSeriesPlotConfigVisitor interface {
	VisitNumeric(v TimeSeriesNumericPlot) error
	VisitRange(v TimeSeriesRangePlot) error
	VisitEnum(v TimeSeriesEnumPlot) error
	VisitUnknown(typeName string) error
}

func (u *TimeSeriesPlotConfig) AcceptWithContext(ctx context.Context, v TimeSeriesPlotConfigVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRangeWithContext(ctx, *u.range_)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	}
}

type TimeSeriesPlotConfigVisitorWithContext interface {
	VisitNumericWithContext(ctx context.Context, v TimeSeriesNumericPlot) error
	VisitRangeWithContext(ctx context.Context, v TimeSeriesRangePlot) error
	VisitEnumWithContext(ctx context.Context, v TimeSeriesEnumPlot) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimeSeriesPlotConfigFromNumeric(v TimeSeriesNumericPlot) TimeSeriesPlotConfig {
	return TimeSeriesPlotConfig{typ: "numeric", numeric: &v}
}

func NewTimeSeriesPlotConfigFromRange(v TimeSeriesRangePlot) TimeSeriesPlotConfig {
	return TimeSeriesPlotConfig{typ: "range", range_: &v}
}

func NewTimeSeriesPlotConfigFromEnum(v TimeSeriesEnumPlot) TimeSeriesPlotConfig {
	return TimeSeriesPlotConfig{typ: "enum", enum: &v}
}

type TraceComputeConfig struct {
	typ       string
	scatter3d *Scatter3dTraceComputeConfig
}

type traceComputeConfigDeserializer struct {
	Type      string                       `json:"type"`
	Scatter3d *Scatter3dTraceComputeConfig `json:"scatter3d"`
}

func (u *traceComputeConfigDeserializer) toStruct() TraceComputeConfig {
	return TraceComputeConfig{typ: u.Type, scatter3d: u.Scatter3d}
}

func (u *TraceComputeConfig) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return nil, fmt.Errorf("field \"scatter3d\" is required")
		}
		return struct {
			Type      string                      `json:"type"`
			Scatter3d Scatter3dTraceComputeConfig `json:"scatter3d"`
		}{Type: "scatter3d", Scatter3d: *u.scatter3d}, nil
	}
}

func (u TraceComputeConfig) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TraceComputeConfig) UnmarshalJSON(data []byte) error {
	var deser traceComputeConfigDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
	}
	return nil
}

func (u TraceComputeConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TraceComputeConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TraceComputeConfig) AcceptFuncs(scatter3dFunc func(Scatter3dTraceComputeConfig) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return scatter3dFunc(*u.scatter3d)
	}
}

func (u *TraceComputeConfig) Scatter3dNoopSuccess(Scatter3dTraceComputeConfig) error {
	return nil
}

func (u *TraceComputeConfig) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TraceComputeConfig) Accept(v TraceComputeConfigVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3d(*u.scatter3d)
	}
}

type TraceComputeConfigVisitor interface {
	VisitScatter3d(v Scatter3dTraceComputeConfig) error
	VisitUnknown(typeName string) error
}

func (u *TraceComputeConfig) AcceptWithContext(ctx context.Context, v TraceComputeConfigVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3dWithContext(ctx, *u.scatter3d)
	}
}

type TraceComputeConfigVisitorWithContext interface {
	VisitScatter3dWithContext(ctx context.Context, v Scatter3dTraceComputeConfig) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTraceComputeConfigFromScatter3d(v Scatter3dTraceComputeConfig) TraceComputeConfig {
	return TraceComputeConfig{typ: "scatter3d", scatter3d: &v}
}

type ValueTableCellConfig struct {
	typ          string
	numeric      *NumericCellConfig
	enum         *EnumCellConfig
	range_       *RangeCellConfig
	bitFlagMap   *BitFlagMapCellConfig
	staleness    *StalenessCellConfig
	numericArray *NumericArrayCellConfig
	enumArray    *EnumArrayCellConfig
	struct_      *StructCellConfig
}

type valueTableCellConfigDeserializer struct {
	Type         string                  `json:"type"`
	Numeric      *NumericCellConfig      `json:"numeric"`
	Enum         *EnumCellConfig         `json:"enum"`
	Range        *RangeCellConfig        `json:"range"`
	BitFlagMap   *BitFlagMapCellConfig   `json:"bitFlagMap"`
	Staleness    *StalenessCellConfig    `json:"staleness"`
	NumericArray *NumericArrayCellConfig `json:"numericArray"`
	EnumArray    *EnumArrayCellConfig    `json:"enumArray"`
	Struct       *StructCellConfig       `json:"struct"`
}

func (u *valueTableCellConfigDeserializer) toStruct() ValueTableCellConfig {
	return ValueTableCellConfig{typ: u.Type, numeric: u.Numeric, enum: u.Enum, range_: u.Range, bitFlagMap: u.BitFlagMap, staleness: u.Staleness, numericArray: u.NumericArray, enumArray: u.EnumArray, struct_: u.Struct}
}

func (u *ValueTableCellConfig) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Numeric NumericCellConfig `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string         `json:"type"`
			Enum EnumCellConfig `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "range":
		if u.range_ == nil {
			return nil, fmt.Errorf("field \"range\" is required")
		}
		return struct {
			Type  string          `json:"type"`
			Range RangeCellConfig `json:"range"`
		}{Type: "range", Range: *u.range_}, nil
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return nil, fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return struct {
			Type       string               `json:"type"`
			BitFlagMap BitFlagMapCellConfig `json:"bitFlagMap"`
		}{Type: "bitFlagMap", BitFlagMap: *u.bitFlagMap}, nil
	case "staleness":
		if u.staleness == nil {
			return nil, fmt.Errorf("field \"staleness\" is required")
		}
		return struct {
			Type      string              `json:"type"`
			Staleness StalenessCellConfig `json:"staleness"`
		}{Type: "staleness", Staleness: *u.staleness}, nil
	case "numericArray":
		if u.numericArray == nil {
			return nil, fmt.Errorf("field \"numericArray\" is required")
		}
		return struct {
			Type         string                 `json:"type"`
			NumericArray NumericArrayCellConfig `json:"numericArray"`
		}{Type: "numericArray", NumericArray: *u.numericArray}, nil
	case "enumArray":
		if u.enumArray == nil {
			return nil, fmt.Errorf("field \"enumArray\" is required")
		}
		return struct {
			Type      string              `json:"type"`
			EnumArray EnumArrayCellConfig `json:"enumArray"`
		}{Type: "enumArray", EnumArray: *u.enumArray}, nil
	case "struct":
		if u.struct_ == nil {
			return nil, fmt.Errorf("field \"struct\" is required")
		}
		return struct {
			Type   string           `json:"type"`
			Struct StructCellConfig `json:"struct"`
		}{Type: "struct", Struct: *u.struct_}, nil
	}
}

func (u ValueTableCellConfig) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ValueTableCellConfig) UnmarshalJSON(data []byte) error {
	var deser valueTableCellConfigDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return fmt.Errorf("field \"bitFlagMap\" is required")
		}
	case "staleness":
		if u.staleness == nil {
			return fmt.Errorf("field \"staleness\" is required")
		}
	case "numericArray":
		if u.numericArray == nil {
			return fmt.Errorf("field \"numericArray\" is required")
		}
	case "enumArray":
		if u.enumArray == nil {
			return fmt.Errorf("field \"enumArray\" is required")
		}
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
	}
	return nil
}

func (u ValueTableCellConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ValueTableCellConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ValueTableCellConfig) AcceptFuncs(numericFunc func(NumericCellConfig) error, enumFunc func(EnumCellConfig) error, range_Func func(RangeCellConfig) error, bitFlagMapFunc func(BitFlagMapCellConfig) error, stalenessFunc func(StalenessCellConfig) error, numericArrayFunc func(NumericArrayCellConfig) error, enumArrayFunc func(EnumArrayCellConfig) error, struct_Func func(StructCellConfig) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return bitFlagMapFunc(*u.bitFlagMap)
	case "staleness":
		if u.staleness == nil {
			return fmt.Errorf("field \"staleness\" is required")
		}
		return stalenessFunc(*u.staleness)
	case "numericArray":
		if u.numericArray == nil {
			return fmt.Errorf("field \"numericArray\" is required")
		}
		return numericArrayFunc(*u.numericArray)
	case "enumArray":
		if u.enumArray == nil {
			return fmt.Errorf("field \"enumArray\" is required")
		}
		return enumArrayFunc(*u.enumArray)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return struct_Func(*u.struct_)
	}
}

func (u *ValueTableCellConfig) NumericNoopSuccess(NumericCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) EnumNoopSuccess(EnumCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) RangeNoopSuccess(RangeCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) BitFlagMapNoopSuccess(BitFlagMapCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) StalenessNoopSuccess(StalenessCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) NumericArrayNoopSuccess(NumericArrayCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) EnumArrayNoopSuccess(EnumArrayCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) StructNoopSuccess(StructCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ValueTableCellConfig) Accept(v ValueTableCellConfigVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(*u.range_)
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return v.VisitBitFlagMap(*u.bitFlagMap)
	case "staleness":
		if u.staleness == nil {
			return fmt.Errorf("field \"staleness\" is required")
		}
		return v.VisitStaleness(*u.staleness)
	case "numericArray":
		if u.numericArray == nil {
			return fmt.Errorf("field \"numericArray\" is required")
		}
		return v.VisitNumericArray(*u.numericArray)
	case "enumArray":
		if u.enumArray == nil {
			return fmt.Errorf("field \"enumArray\" is required")
		}
		return v.VisitEnumArray(*u.enumArray)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStruct(*u.struct_)
	}
}

type ValueTableCellConfigVisitor interface {
	VisitNumeric(v NumericCellConfig) error
	VisitEnum(v EnumCellConfig) error
	VisitRange(v RangeCellConfig) error
	VisitBitFlagMap(v BitFlagMapCellConfig) error
	VisitStaleness(v StalenessCellConfig) error
	VisitNumericArray(v NumericArrayCellConfig) error
	VisitEnumArray(v EnumArrayCellConfig) error
	VisitStruct(v StructCellConfig) error
	VisitUnknown(typeName string) error
}

func (u *ValueTableCellConfig) AcceptWithContext(ctx context.Context, v ValueTableCellConfigVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRangeWithContext(ctx, *u.range_)
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return v.VisitBitFlagMapWithContext(ctx, *u.bitFlagMap)
	case "staleness":
		if u.staleness == nil {
			return fmt.Errorf("field \"staleness\" is required")
		}
		return v.VisitStalenessWithContext(ctx, *u.staleness)
	case "numericArray":
		if u.numericArray == nil {
			return fmt.Errorf("field \"numericArray\" is required")
		}
		return v.VisitNumericArrayWithContext(ctx, *u.numericArray)
	case "enumArray":
		if u.enumArray == nil {
			return fmt.Errorf("field \"enumArray\" is required")
		}
		return v.VisitEnumArrayWithContext(ctx, *u.enumArray)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStructWithContext(ctx, *u.struct_)
	}
}

type ValueTableCellConfigVisitorWithContext interface {
	VisitNumericWithContext(ctx context.Context, v NumericCellConfig) error
	VisitEnumWithContext(ctx context.Context, v EnumCellConfig) error
	VisitRangeWithContext(ctx context.Context, v RangeCellConfig) error
	VisitBitFlagMapWithContext(ctx context.Context, v BitFlagMapCellConfig) error
	VisitStalenessWithContext(ctx context.Context, v StalenessCellConfig) error
	VisitNumericArrayWithContext(ctx context.Context, v NumericArrayCellConfig) error
	VisitEnumArrayWithContext(ctx context.Context, v EnumArrayCellConfig) error
	VisitStructWithContext(ctx context.Context, v StructCellConfig) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewValueTableCellConfigFromNumeric(v NumericCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "numeric", numeric: &v}
}

func NewValueTableCellConfigFromEnum(v EnumCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "enum", enum: &v}
}

func NewValueTableCellConfigFromRange(v RangeCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "range", range_: &v}
}

func NewValueTableCellConfigFromBitFlagMap(v BitFlagMapCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "bitFlagMap", bitFlagMap: &v}
}

func NewValueTableCellConfigFromStaleness(v StalenessCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "staleness", staleness: &v}
}

func NewValueTableCellConfigFromNumericArray(v NumericArrayCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "numericArray", numericArray: &v}
}

func NewValueTableCellConfigFromEnumArray(v EnumArrayCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "enumArray", enumArray: &v}
}

func NewValueTableCellConfigFromStruct(v StructCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "struct", struct_: &v}
}

type ValueTableChannel struct {
	typ     string
	numeric *NumericValueChannel
	enum    *EnumValueChannel
	range_  *RangeValueChannel
}

type valueTableChannelDeserializer struct {
	Type    string               `json:"type"`
	Numeric *NumericValueChannel `json:"numeric"`
	Enum    *EnumValueChannel    `json:"enum"`
	Range   *RangeValueChannel   `json:"range"`
}

func (u *valueTableChannelDeserializer) toStruct() ValueTableChannel {
	return ValueTableChannel{typ: u.Type, numeric: u.Numeric, enum: u.Enum, range_: u.Range}
}

func (u *ValueTableChannel) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string              `json:"type"`
			Numeric NumericValueChannel `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string           `json:"type"`
			Enum EnumValueChannel `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "range":
		if u.range_ == nil {
			return nil, fmt.Errorf("field \"range\" is required")
		}
		return struct {
			Type  string            `json:"type"`
			Range RangeValueChannel `json:"range"`
		}{Type: "range", Range: *u.range_}, nil
	}
}

func (u ValueTableChannel) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ValueTableChannel) UnmarshalJSON(data []byte) error {
	var deser valueTableChannelDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
	}
	return nil
}

func (u ValueTableChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ValueTableChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ValueTableChannel) AcceptFuncs(numericFunc func(NumericValueChannel) error, enumFunc func(EnumValueChannel) error, range_Func func(RangeValueChannel) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	}
}

func (u *ValueTableChannel) NumericNoopSuccess(NumericValueChannel) error {
	return nil
}

func (u *ValueTableChannel) EnumNoopSuccess(EnumValueChannel) error {
	return nil
}

func (u *ValueTableChannel) RangeNoopSuccess(RangeValueChannel) error {
	return nil
}

func (u *ValueTableChannel) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ValueTableChannel) Accept(v ValueTableChannelVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(*u.range_)
	}
}

type ValueTableChannelVisitor interface {
	VisitNumeric(v NumericValueChannel) error
	VisitEnum(v EnumValueChannel) error
	VisitRange(v RangeValueChannel) error
	VisitUnknown(typeName string) error
}

func (u *ValueTableChannel) AcceptWithContext(ctx context.Context, v ValueTableChannelVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRangeWithContext(ctx, *u.range_)
	}
}

type ValueTableChannelVisitorWithContext interface {
	VisitNumericWithContext(ctx context.Context, v NumericValueChannel) error
	VisitEnumWithContext(ctx context.Context, v EnumValueChannel) error
	VisitRangeWithContext(ctx context.Context, v RangeValueChannel) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewValueTableChannelFromNumeric(v NumericValueChannel) ValueTableChannel {
	return ValueTableChannel{typ: "numeric", numeric: &v}
}

func NewValueTableChannelFromEnum(v EnumValueChannel) ValueTableChannel {
	return ValueTableChannel{typ: "enum", enum: &v}
}

func NewValueTableChannelFromRange(v RangeValueChannel) ValueTableChannel {
	return ValueTableChannel{typ: "range", range_: &v}
}

type ValueTableDefinition struct {
	typ string
	v1  *ValueTableDefinitionV1
	v2  *ValueTableDefinitionV2
}

type valueTableDefinitionDeserializer struct {
	Type string                  `json:"type"`
	V1   *ValueTableDefinitionV1 `json:"v1"`
	V2   *ValueTableDefinitionV2 `json:"v2"`
}

func (u *valueTableDefinitionDeserializer) toStruct() ValueTableDefinition {
	return ValueTableDefinition{typ: u.Type, v1: u.V1, v2: u.V2}
}

func (u *ValueTableDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                 `json:"type"`
			V1   ValueTableDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	case "v2":
		if u.v2 == nil {
			return nil, fmt.Errorf("field \"v2\" is required")
		}
		return struct {
			Type string                 `json:"type"`
			V2   ValueTableDefinitionV2 `json:"v2"`
		}{Type: "v2", V2: *u.v2}, nil
	}
}

func (u ValueTableDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ValueTableDefinition) UnmarshalJSON(data []byte) error {
	var deser valueTableDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
	}
	return nil
}

func (u ValueTableDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ValueTableDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ValueTableDefinition) AcceptFuncs(v1Func func(ValueTableDefinitionV1) error, v2Func func(ValueTableDefinitionV2) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *ValueTableDefinition) V1NoopSuccess(ValueTableDefinitionV1) error {
	return nil
}

func (u *ValueTableDefinition) V2NoopSuccess(ValueTableDefinitionV2) error {
	return nil
}

func (u *ValueTableDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ValueTableDefinition) Accept(v ValueTableDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(*u.v2)
	}
}

type ValueTableDefinitionVisitor interface {
	VisitV1(v ValueTableDefinitionV1) error
	VisitV2(v ValueTableDefinitionV2) error
	VisitUnknown(typeName string) error
}

func (u *ValueTableDefinition) AcceptWithContext(ctx context.Context, v ValueTableDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2WithContext(ctx, *u.v2)
	}
}

type ValueTableDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v ValueTableDefinitionV1) error
	VisitV2WithContext(ctx context.Context, v ValueTableDefinitionV2) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewValueTableDefinitionFromV1(v ValueTableDefinitionV1) ValueTableDefinition {
	return ValueTableDefinition{typ: "v1", v1: &v}
}

func NewValueTableDefinitionFromV2(v ValueTableDefinitionV2) ValueTableDefinition {
	return ValueTableDefinition{typ: "v2", v2: &v}
}

type ValueTableLayout struct {
	typ  string
	grid *ValueTableLayoutGrid
}

type valueTableLayoutDeserializer struct {
	Type string                `json:"type"`
	Grid *ValueTableLayoutGrid `json:"grid"`
}

func (u *valueTableLayoutDeserializer) toStruct() ValueTableLayout {
	return ValueTableLayout{typ: u.Type, grid: u.Grid}
}

func (u *ValueTableLayout) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "grid":
		if u.grid == nil {
			return nil, fmt.Errorf("field \"grid\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Grid ValueTableLayoutGrid `json:"grid"`
		}{Type: "grid", Grid: *u.grid}, nil
	}
}

func (u ValueTableLayout) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ValueTableLayout) UnmarshalJSON(data []byte) error {
	var deser valueTableLayoutDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "grid":
		if u.grid == nil {
			return fmt.Errorf("field \"grid\" is required")
		}
	}
	return nil
}

func (u ValueTableLayout) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ValueTableLayout) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ValueTableLayout) AcceptFuncs(gridFunc func(ValueTableLayoutGrid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "grid":
		if u.grid == nil {
			return fmt.Errorf("field \"grid\" is required")
		}
		return gridFunc(*u.grid)
	}
}

func (u *ValueTableLayout) GridNoopSuccess(ValueTableLayoutGrid) error {
	return nil
}

func (u *ValueTableLayout) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ValueTableLayout) Accept(v ValueTableLayoutVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "grid":
		if u.grid == nil {
			return fmt.Errorf("field \"grid\" is required")
		}
		return v.VisitGrid(*u.grid)
	}
}

type ValueTableLayoutVisitor interface {
	VisitGrid(v ValueTableLayoutGrid) error
	VisitUnknown(typeName string) error
}

func (u *ValueTableLayout) AcceptWithContext(ctx context.Context, v ValueTableLayoutVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "grid":
		if u.grid == nil {
			return fmt.Errorf("field \"grid\" is required")
		}
		return v.VisitGridWithContext(ctx, *u.grid)
	}
}

type ValueTableLayoutVisitorWithContext interface {
	VisitGridWithContext(ctx context.Context, v ValueTableLayoutGrid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewValueTableLayoutFromGrid(v ValueTableLayoutGrid) ValueTableLayout {
	return ValueTableLayout{typ: "grid", grid: &v}
}

// Specifies an assignment of colors across several values.
type ValueToColorMap struct {
	typ     string
	numeric *map[api.HexColor]float64
}

type valueToColorMapDeserializer struct {
	Type    string                    `json:"type"`
	Numeric *map[api.HexColor]float64 `json:"numeric"`
}

func (u *valueToColorMapDeserializer) toStruct() ValueToColorMap {
	return ValueToColorMap{typ: u.Type, numeric: u.Numeric}
}

func (u *ValueToColorMap) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string                   `json:"type"`
			Numeric map[api.HexColor]float64 `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	}
}

func (u ValueToColorMap) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ValueToColorMap) UnmarshalJSON(data []byte) error {
	var deser valueToColorMapDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	}
	return nil
}

func (u ValueToColorMap) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ValueToColorMap) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ValueToColorMap) AcceptFuncs(numericFunc func(map[api.HexColor]float64) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	}
}

func (u *ValueToColorMap) NumericNoopSuccess(map[api.HexColor]float64) error {
	return nil
}

func (u *ValueToColorMap) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ValueToColorMap) Accept(v ValueToColorMapVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	}
}

type ValueToColorMapVisitor interface {
	VisitNumeric(v map[api.HexColor]float64) error
	VisitUnknown(typeName string) error
}

func (u *ValueToColorMap) AcceptWithContext(ctx context.Context, v ValueToColorMapVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	}
}

type ValueToColorMapVisitorWithContext interface {
	VisitNumericWithContext(ctx context.Context, v map[api.HexColor]float64) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewValueToColorMapFromNumeric(v map[api.HexColor]float64) ValueToColorMap {
	return ValueToColorMap{typ: "numeric", numeric: &v}
}

type VideoVizDefinition struct {
	typ string
	v1  *VideoVizDefinitionV1
	v2  *VideoVizDefinitionV2
}

type videoVizDefinitionDeserializer struct {
	Type string                `json:"type"`
	V1   *VideoVizDefinitionV1 `json:"v1"`
	V2   *VideoVizDefinitionV2 `json:"v2"`
}

func (u *videoVizDefinitionDeserializer) toStruct() VideoVizDefinition {
	return VideoVizDefinition{typ: u.Type, v1: u.V1, v2: u.V2}
}

func (u *VideoVizDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string               `json:"type"`
			V1   VideoVizDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	case "v2":
		if u.v2 == nil {
			return nil, fmt.Errorf("field \"v2\" is required")
		}
		return struct {
			Type string               `json:"type"`
			V2   VideoVizDefinitionV2 `json:"v2"`
		}{Type: "v2", V2: *u.v2}, nil
	}
}

func (u VideoVizDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VideoVizDefinition) UnmarshalJSON(data []byte) error {
	var deser videoVizDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
	}
	return nil
}

func (u VideoVizDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VideoVizDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VideoVizDefinition) AcceptFuncs(v1Func func(VideoVizDefinitionV1) error, v2Func func(VideoVizDefinitionV2) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *VideoVizDefinition) V1NoopSuccess(VideoVizDefinitionV1) error {
	return nil
}

func (u *VideoVizDefinition) V2NoopSuccess(VideoVizDefinitionV2) error {
	return nil
}

func (u *VideoVizDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VideoVizDefinition) Accept(v VideoVizDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(*u.v2)
	}
}

type VideoVizDefinitionVisitor interface {
	VisitV1(v VideoVizDefinitionV1) error
	VisitV2(v VideoVizDefinitionV2) error
	VisitUnknown(typeName string) error
}

func (u *VideoVizDefinition) AcceptWithContext(ctx context.Context, v VideoVizDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2WithContext(ctx, *u.v2)
	}
}

type VideoVizDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v VideoVizDefinitionV1) error
	VisitV2WithContext(ctx context.Context, v VideoVizDefinitionV2) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVideoVizDefinitionFromV1(v VideoVizDefinitionV1) VideoVizDefinition {
	return VideoVizDefinition{typ: "v1", v1: &v}
}

func NewVideoVizDefinitionFromV2(v VideoVizDefinitionV2) VideoVizDefinition {
	return VideoVizDefinition{typ: "v2", v2: &v}
}

type VizDefinition struct {
	typ        string
	cartesian  *CartesianChartDefinition
	checklist  *ChecklistChartDefinition
	frequency  *FrequencyChartDefinition
	geo        *GeoVizDefinition
	geo3d      *Geo3dDefinition
	histogram  *HistogramChartDefinition
	log        *LogPanelDefinition
	plotly     *PlotlyPanelDefinition
	timeSeries *TimeSeriesChartDefinition
	valueTable *ValueTableDefinition
	video      *VideoVizDefinition
	procedure  *ProcedureVizDefinition
}

type vizDefinitionDeserializer struct {
	Type       string                     `json:"type"`
	Cartesian  *CartesianChartDefinition  `json:"cartesian"`
	Checklist  *ChecklistChartDefinition  `json:"checklist"`
	Frequency  *FrequencyChartDefinition  `json:"frequency"`
	Geo        *GeoVizDefinition          `json:"geo"`
	Geo3d      *Geo3dDefinition           `json:"geo3d"`
	Histogram  *HistogramChartDefinition  `json:"histogram"`
	Log        *LogPanelDefinition        `json:"log"`
	Plotly     *PlotlyPanelDefinition     `json:"plotly"`
	TimeSeries *TimeSeriesChartDefinition `json:"timeSeries"`
	ValueTable *ValueTableDefinition      `json:"valueTable"`
	Video      *VideoVizDefinition        `json:"video"`
	Procedure  *ProcedureVizDefinition    `json:"procedure"`
}

func (u *vizDefinitionDeserializer) toStruct() VizDefinition {
	return VizDefinition{typ: u.Type, cartesian: u.Cartesian, checklist: u.Checklist, frequency: u.Frequency, geo: u.Geo, geo3d: u.Geo3d, histogram: u.Histogram, log: u.Log, plotly: u.Plotly, timeSeries: u.TimeSeries, valueTable: u.ValueTable, video: u.Video, procedure: u.Procedure}
}

func (u *VizDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return nil, fmt.Errorf("field \"cartesian\" is required")
		}
		return struct {
			Type      string                   `json:"type"`
			Cartesian CartesianChartDefinition `json:"cartesian"`
		}{Type: "cartesian", Cartesian: *u.cartesian}, nil
	case "checklist":
		if u.checklist == nil {
			return nil, fmt.Errorf("field \"checklist\" is required")
		}
		return struct {
			Type      string                   `json:"type"`
			Checklist ChecklistChartDefinition `json:"checklist"`
		}{Type: "checklist", Checklist: *u.checklist}, nil
	case "frequency":
		if u.frequency == nil {
			return nil, fmt.Errorf("field \"frequency\" is required")
		}
		return struct {
			Type      string                   `json:"type"`
			Frequency FrequencyChartDefinition `json:"frequency"`
		}{Type: "frequency", Frequency: *u.frequency}, nil
	case "geo":
		if u.geo == nil {
			return nil, fmt.Errorf("field \"geo\" is required")
		}
		return struct {
			Type string           `json:"type"`
			Geo  GeoVizDefinition `json:"geo"`
		}{Type: "geo", Geo: *u.geo}, nil
	case "geo3d":
		if u.geo3d == nil {
			return nil, fmt.Errorf("field \"geo3d\" is required")
		}
		return struct {
			Type  string          `json:"type"`
			Geo3d Geo3dDefinition `json:"geo3d"`
		}{Type: "geo3d", Geo3d: *u.geo3d}, nil
	case "histogram":
		if u.histogram == nil {
			return nil, fmt.Errorf("field \"histogram\" is required")
		}
		return struct {
			Type      string                   `json:"type"`
			Histogram HistogramChartDefinition `json:"histogram"`
		}{Type: "histogram", Histogram: *u.histogram}, nil
	case "log":
		if u.log == nil {
			return nil, fmt.Errorf("field \"log\" is required")
		}
		return struct {
			Type string             `json:"type"`
			Log  LogPanelDefinition `json:"log"`
		}{Type: "log", Log: *u.log}, nil
	case "plotly":
		if u.plotly == nil {
			return nil, fmt.Errorf("field \"plotly\" is required")
		}
		return struct {
			Type   string                `json:"type"`
			Plotly PlotlyPanelDefinition `json:"plotly"`
		}{Type: "plotly", Plotly: *u.plotly}, nil
	case "timeSeries":
		if u.timeSeries == nil {
			return nil, fmt.Errorf("field \"timeSeries\" is required")
		}
		return struct {
			Type       string                    `json:"type"`
			TimeSeries TimeSeriesChartDefinition `json:"timeSeries"`
		}{Type: "timeSeries", TimeSeries: *u.timeSeries}, nil
	case "valueTable":
		if u.valueTable == nil {
			return nil, fmt.Errorf("field \"valueTable\" is required")
		}
		return struct {
			Type       string               `json:"type"`
			ValueTable ValueTableDefinition `json:"valueTable"`
		}{Type: "valueTable", ValueTable: *u.valueTable}, nil
	case "video":
		if u.video == nil {
			return nil, fmt.Errorf("field \"video\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Video VideoVizDefinition `json:"video"`
		}{Type: "video", Video: *u.video}, nil
	case "procedure":
		if u.procedure == nil {
			return nil, fmt.Errorf("field \"procedure\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			Procedure ProcedureVizDefinition `json:"procedure"`
		}{Type: "procedure", Procedure: *u.procedure}, nil
	}
}

func (u VizDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VizDefinition) UnmarshalJSON(data []byte) error {
	var deser vizDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
	case "geo3d":
		if u.geo3d == nil {
			return fmt.Errorf("field \"geo3d\" is required")
		}
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
	case "plotly":
		if u.plotly == nil {
			return fmt.Errorf("field \"plotly\" is required")
		}
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
	case "valueTable":
		if u.valueTable == nil {
			return fmt.Errorf("field \"valueTable\" is required")
		}
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
	}
	return nil
}

func (u VizDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VizDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VizDefinition) AcceptFuncs(cartesianFunc func(CartesianChartDefinition) error, checklistFunc func(ChecklistChartDefinition) error, frequencyFunc func(FrequencyChartDefinition) error, geoFunc func(GeoVizDefinition) error, geo3dFunc func(Geo3dDefinition) error, histogramFunc func(HistogramChartDefinition) error, logFunc func(LogPanelDefinition) error, plotlyFunc func(PlotlyPanelDefinition) error, timeSeriesFunc func(TimeSeriesChartDefinition) error, valueTableFunc func(ValueTableDefinition) error, videoFunc func(VideoVizDefinition) error, procedureFunc func(ProcedureVizDefinition) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
		return checklistFunc(*u.checklist)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return frequencyFunc(*u.frequency)
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
		return geoFunc(*u.geo)
	case "geo3d":
		if u.geo3d == nil {
			return fmt.Errorf("field \"geo3d\" is required")
		}
		return geo3dFunc(*u.geo3d)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return histogramFunc(*u.histogram)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "plotly":
		if u.plotly == nil {
			return fmt.Errorf("field \"plotly\" is required")
		}
		return plotlyFunc(*u.plotly)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return timeSeriesFunc(*u.timeSeries)
	case "valueTable":
		if u.valueTable == nil {
			return fmt.Errorf("field \"valueTable\" is required")
		}
		return valueTableFunc(*u.valueTable)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
		return procedureFunc(*u.procedure)
	}
}

func (u *VizDefinition) CartesianNoopSuccess(CartesianChartDefinition) error {
	return nil
}

func (u *VizDefinition) ChecklistNoopSuccess(ChecklistChartDefinition) error {
	return nil
}

func (u *VizDefinition) FrequencyNoopSuccess(FrequencyChartDefinition) error {
	return nil
}

func (u *VizDefinition) GeoNoopSuccess(GeoVizDefinition) error {
	return nil
}

func (u *VizDefinition) Geo3dNoopSuccess(Geo3dDefinition) error {
	return nil
}

func (u *VizDefinition) HistogramNoopSuccess(HistogramChartDefinition) error {
	return nil
}

func (u *VizDefinition) LogNoopSuccess(LogPanelDefinition) error {
	return nil
}

func (u *VizDefinition) PlotlyNoopSuccess(PlotlyPanelDefinition) error {
	return nil
}

func (u *VizDefinition) TimeSeriesNoopSuccess(TimeSeriesChartDefinition) error {
	return nil
}

func (u *VizDefinition) ValueTableNoopSuccess(ValueTableDefinition) error {
	return nil
}

func (u *VizDefinition) VideoNoopSuccess(VideoVizDefinition) error {
	return nil
}

func (u *VizDefinition) ProcedureNoopSuccess(ProcedureVizDefinition) error {
	return nil
}

func (u *VizDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VizDefinition) Accept(v VizDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(*u.cartesian)
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
		return v.VisitChecklist(*u.checklist)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequency(*u.frequency)
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
		return v.VisitGeo(*u.geo)
	case "geo3d":
		if u.geo3d == nil {
			return fmt.Errorf("field \"geo3d\" is required")
		}
		return v.VisitGeo3d(*u.geo3d)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogram(*u.histogram)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(*u.log)
	case "plotly":
		if u.plotly == nil {
			return fmt.Errorf("field \"plotly\" is required")
		}
		return v.VisitPlotly(*u.plotly)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeries(*u.timeSeries)
	case "valueTable":
		if u.valueTable == nil {
			return fmt.Errorf("field \"valueTable\" is required")
		}
		return v.VisitValueTable(*u.valueTable)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(*u.video)
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
		return v.VisitProcedure(*u.procedure)
	}
}

type VizDefinitionVisitor interface {
	VisitCartesian(v CartesianChartDefinition) error
	VisitChecklist(v ChecklistChartDefinition) error
	VisitFrequency(v FrequencyChartDefinition) error
	VisitGeo(v GeoVizDefinition) error
	VisitGeo3d(v Geo3dDefinition) error
	VisitHistogram(v HistogramChartDefinition) error
	VisitLog(v LogPanelDefinition) error
	VisitPlotly(v PlotlyPanelDefinition) error
	VisitTimeSeries(v TimeSeriesChartDefinition) error
	VisitValueTable(v ValueTableDefinition) error
	VisitVideo(v VideoVizDefinition) error
	VisitProcedure(v ProcedureVizDefinition) error
	VisitUnknown(typeName string) error
}

func (u *VizDefinition) AcceptWithContext(ctx context.Context, v VizDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesianWithContext(ctx, *u.cartesian)
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
		return v.VisitChecklistWithContext(ctx, *u.checklist)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequencyWithContext(ctx, *u.frequency)
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
		return v.VisitGeoWithContext(ctx, *u.geo)
	case "geo3d":
		if u.geo3d == nil {
			return fmt.Errorf("field \"geo3d\" is required")
		}
		return v.VisitGeo3dWithContext(ctx, *u.geo3d)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogramWithContext(ctx, *u.histogram)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLogWithContext(ctx, *u.log)
	case "plotly":
		if u.plotly == nil {
			return fmt.Errorf("field \"plotly\" is required")
		}
		return v.VisitPlotlyWithContext(ctx, *u.plotly)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeriesWithContext(ctx, *u.timeSeries)
	case "valueTable":
		if u.valueTable == nil {
			return fmt.Errorf("field \"valueTable\" is required")
		}
		return v.VisitValueTableWithContext(ctx, *u.valueTable)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideoWithContext(ctx, *u.video)
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
		return v.VisitProcedureWithContext(ctx, *u.procedure)
	}
}

type VizDefinitionVisitorWithContext interface {
	VisitCartesianWithContext(ctx context.Context, v CartesianChartDefinition) error
	VisitChecklistWithContext(ctx context.Context, v ChecklistChartDefinition) error
	VisitFrequencyWithContext(ctx context.Context, v FrequencyChartDefinition) error
	VisitGeoWithContext(ctx context.Context, v GeoVizDefinition) error
	VisitGeo3dWithContext(ctx context.Context, v Geo3dDefinition) error
	VisitHistogramWithContext(ctx context.Context, v HistogramChartDefinition) error
	VisitLogWithContext(ctx context.Context, v LogPanelDefinition) error
	VisitPlotlyWithContext(ctx context.Context, v PlotlyPanelDefinition) error
	VisitTimeSeriesWithContext(ctx context.Context, v TimeSeriesChartDefinition) error
	VisitValueTableWithContext(ctx context.Context, v ValueTableDefinition) error
	VisitVideoWithContext(ctx context.Context, v VideoVizDefinition) error
	VisitProcedureWithContext(ctx context.Context, v ProcedureVizDefinition) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVizDefinitionFromCartesian(v CartesianChartDefinition) VizDefinition {
	return VizDefinition{typ: "cartesian", cartesian: &v}
}

func NewVizDefinitionFromChecklist(v ChecklistChartDefinition) VizDefinition {
	return VizDefinition{typ: "checklist", checklist: &v}
}

func NewVizDefinitionFromFrequency(v FrequencyChartDefinition) VizDefinition {
	return VizDefinition{typ: "frequency", frequency: &v}
}

func NewVizDefinitionFromGeo(v GeoVizDefinition) VizDefinition {
	return VizDefinition{typ: "geo", geo: &v}
}

func NewVizDefinitionFromGeo3d(v Geo3dDefinition) VizDefinition {
	return VizDefinition{typ: "geo3d", geo3d: &v}
}

func NewVizDefinitionFromHistogram(v HistogramChartDefinition) VizDefinition {
	return VizDefinition{typ: "histogram", histogram: &v}
}

func NewVizDefinitionFromLog(v LogPanelDefinition) VizDefinition {
	return VizDefinition{typ: "log", log: &v}
}

func NewVizDefinitionFromPlotly(v PlotlyPanelDefinition) VizDefinition {
	return VizDefinition{typ: "plotly", plotly: &v}
}

func NewVizDefinitionFromTimeSeries(v TimeSeriesChartDefinition) VizDefinition {
	return VizDefinition{typ: "timeSeries", timeSeries: &v}
}

func NewVizDefinitionFromValueTable(v ValueTableDefinition) VizDefinition {
	return VizDefinition{typ: "valueTable", valueTable: &v}
}

func NewVizDefinitionFromVideo(v VideoVizDefinition) VizDefinition {
	return VizDefinition{typ: "video", video: &v}
}

func NewVizDefinitionFromProcedure(v ProcedureVizDefinition) VizDefinition {
	return VizDefinition{typ: "procedure", procedure: &v}
}
