// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/scout/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type AxisThresholdGroup struct {
	typ            string
	lineThresholds *LineThresholdGroup
}

type axisThresholdGroupDeserializer struct {
	Type           string              `json:"type"`
	LineThresholds *LineThresholdGroup `json:"lineThresholds"`
}

func (u *axisThresholdGroupDeserializer) toStruct() AxisThresholdGroup {
	return AxisThresholdGroup{typ: u.Type, lineThresholds: u.LineThresholds}
}

func (u *AxisThresholdGroup) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return nil, fmt.Errorf("field \"lineThresholds\" is required")
		}
		return struct {
			Type           string             `json:"type"`
			LineThresholds LineThresholdGroup `json:"lineThresholds"`
		}{Type: "lineThresholds", LineThresholds: *u.lineThresholds}, nil
	}
}

func (u AxisThresholdGroup) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *AxisThresholdGroup) UnmarshalJSON(data []byte) error {
	var deser axisThresholdGroupDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "lineThresholds":
		if u.lineThresholds == nil {
			return fmt.Errorf("field \"lineThresholds\" is required")
		}
	}
	return nil
}

func (u AxisThresholdGroup) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *AxisThresholdGroup) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *AxisThresholdGroup) AcceptFuncs(lineThresholdsFunc func(LineThresholdGroup) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return fmt.Errorf("field \"lineThresholds\" is required")
		}
		return lineThresholdsFunc(*u.lineThresholds)
	}
}

func (u *AxisThresholdGroup) LineThresholdsNoopSuccess(LineThresholdGroup) error {
	return nil
}

func (u *AxisThresholdGroup) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *AxisThresholdGroup) Accept(v AxisThresholdGroupVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return fmt.Errorf("field \"lineThresholds\" is required")
		}
		return v.VisitLineThresholds(*u.lineThresholds)
	}
}

type AxisThresholdGroupVisitor interface {
	VisitLineThresholds(v LineThresholdGroup) error
	VisitUnknown(typeName string) error
}

func (u *AxisThresholdGroup) AcceptWithContext(ctx context.Context, v AxisThresholdGroupVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return fmt.Errorf("field \"lineThresholds\" is required")
		}
		return v.VisitLineThresholdsWithContext(ctx, *u.lineThresholds)
	}
}

type AxisThresholdGroupVisitorWithContext interface {
	VisitLineThresholdsWithContext(ctx context.Context, v LineThresholdGroup) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAxisThresholdGroupFromLineThresholds(v LineThresholdGroup) AxisThresholdGroup {
	return AxisThresholdGroup{typ: "lineThresholds", lineThresholds: &v}
}

type BitFlagMapVisualisation struct {
	typ string
	raw *BitFlagMapRawVisualisation
}

type bitFlagMapVisualisationDeserializer struct {
	Type string                      `json:"type"`
	Raw  *BitFlagMapRawVisualisation `json:"raw"`
}

func (u *bitFlagMapVisualisationDeserializer) toStruct() BitFlagMapVisualisation {
	return BitFlagMapVisualisation{typ: u.Type, raw: u.Raw}
}

func (u *BitFlagMapVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                     `json:"type"`
			Raw  BitFlagMapRawVisualisation `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u BitFlagMapVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *BitFlagMapVisualisation) UnmarshalJSON(data []byte) error {
	var deser bitFlagMapVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u BitFlagMapVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *BitFlagMapVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *BitFlagMapVisualisation) AcceptFuncs(rawFunc func(BitFlagMapRawVisualisation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *BitFlagMapVisualisation) RawNoopSuccess(BitFlagMapRawVisualisation) error {
	return nil
}

func (u *BitFlagMapVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *BitFlagMapVisualisation) Accept(v BitFlagMapVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type BitFlagMapVisualisationVisitor interface {
	VisitRaw(v BitFlagMapRawVisualisation) error
	VisitUnknown(typeName string) error
}

func (u *BitFlagMapVisualisation) AcceptWithContext(ctx context.Context, v BitFlagMapVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type BitFlagMapVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v BitFlagMapRawVisualisation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewBitFlagMapVisualisationFromRaw(v BitFlagMapRawVisualisation) BitFlagMapVisualisation {
	return BitFlagMapVisualisation{typ: "raw", raw: &v}
}

type CartesianChartDefinition struct {
	typ string
	v1  *CartesianChartDefinitionV1
}

type cartesianChartDefinitionDeserializer struct {
	Type string                      `json:"type"`
	V1   *CartesianChartDefinitionV1 `json:"v1"`
}

func (u *cartesianChartDefinitionDeserializer) toStruct() CartesianChartDefinition {
	return CartesianChartDefinition{typ: u.Type, v1: u.V1}
}

func (u *CartesianChartDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                     `json:"type"`
			V1   CartesianChartDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u CartesianChartDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CartesianChartDefinition) UnmarshalJSON(data []byte) error {
	var deser cartesianChartDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u CartesianChartDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CartesianChartDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CartesianChartDefinition) AcceptFuncs(v1Func func(CartesianChartDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *CartesianChartDefinition) V1NoopSuccess(CartesianChartDefinitionV1) error {
	return nil
}

func (u *CartesianChartDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CartesianChartDefinition) Accept(v CartesianChartDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type CartesianChartDefinitionVisitor interface {
	VisitV1(v CartesianChartDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *CartesianChartDefinition) AcceptWithContext(ctx context.Context, v CartesianChartDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type CartesianChartDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v CartesianChartDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCartesianChartDefinitionFromV1(v CartesianChartDefinitionV1) CartesianChartDefinition {
	return CartesianChartDefinition{typ: "v1", v1: &v}
}

type ChecklistChartDefinition struct {
	typ string
	v1  *ChecklistChartDefinitionV1
}

type checklistChartDefinitionDeserializer struct {
	Type string                      `json:"type"`
	V1   *ChecklistChartDefinitionV1 `json:"v1"`
}

func (u *checklistChartDefinitionDeserializer) toStruct() ChecklistChartDefinition {
	return ChecklistChartDefinition{typ: u.Type, v1: u.V1}
}

func (u *ChecklistChartDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                     `json:"type"`
			V1   ChecklistChartDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u ChecklistChartDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ChecklistChartDefinition) UnmarshalJSON(data []byte) error {
	var deser checklistChartDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u ChecklistChartDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ChecklistChartDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ChecklistChartDefinition) AcceptFuncs(v1Func func(ChecklistChartDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ChecklistChartDefinition) V1NoopSuccess(ChecklistChartDefinitionV1) error {
	return nil
}

func (u *ChecklistChartDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ChecklistChartDefinition) Accept(v ChecklistChartDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type ChecklistChartDefinitionVisitor interface {
	VisitV1(v ChecklistChartDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *ChecklistChartDefinition) AcceptWithContext(ctx context.Context, v ChecklistChartDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type ChecklistChartDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v ChecklistChartDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewChecklistChartDefinitionFromV1(v ChecklistChartDefinitionV1) ChecklistChartDefinition {
	return ChecklistChartDefinition{typ: "v1", v1: &v}
}

type ColorStyle struct {
	typ    string
	mapped *map[string]api.HexColor
	single *api.HexColor
}

type colorStyleDeserializer struct {
	Type   string                   `json:"type"`
	Mapped *map[string]api.HexColor `json:"mapped"`
	Single *api.HexColor            `json:"single"`
}

func (u *colorStyleDeserializer) toStruct() ColorStyle {
	return ColorStyle{typ: u.Type, mapped: u.Mapped, single: u.Single}
}

func (u *ColorStyle) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "mapped":
		if u.mapped == nil {
			return nil, fmt.Errorf("field \"mapped\" is required")
		}
		return struct {
			Type   string                  `json:"type"`
			Mapped map[string]api.HexColor `json:"mapped"`
		}{Type: "mapped", Mapped: *u.mapped}, nil
	case "single":
		if u.single == nil {
			return nil, fmt.Errorf("field \"single\" is required")
		}
		return struct {
			Type   string       `json:"type"`
			Single api.HexColor `json:"single"`
		}{Type: "single", Single: *u.single}, nil
	}
}

func (u ColorStyle) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ColorStyle) UnmarshalJSON(data []byte) error {
	var deser colorStyleDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "mapped":
		if u.mapped == nil {
			return fmt.Errorf("field \"mapped\" is required")
		}
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
	}
	return nil
}

func (u ColorStyle) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ColorStyle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ColorStyle) AcceptFuncs(mappedFunc func(map[string]api.HexColor) error, singleFunc func(api.HexColor) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "mapped":
		if u.mapped == nil {
			return fmt.Errorf("field \"mapped\" is required")
		}
		return mappedFunc(*u.mapped)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	}
}

func (u *ColorStyle) MappedNoopSuccess(map[string]api.HexColor) error {
	return nil
}

func (u *ColorStyle) SingleNoopSuccess(api.HexColor) error {
	return nil
}

func (u *ColorStyle) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ColorStyle) Accept(v ColorStyleVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "mapped":
		if u.mapped == nil {
			return fmt.Errorf("field \"mapped\" is required")
		}
		return v.VisitMapped(*u.mapped)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(*u.single)
	}
}

type ColorStyleVisitor interface {
	VisitMapped(v map[string]api.HexColor) error
	VisitSingle(v api.HexColor) error
	VisitUnknown(typeName string) error
}

func (u *ColorStyle) AcceptWithContext(ctx context.Context, v ColorStyleVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "mapped":
		if u.mapped == nil {
			return fmt.Errorf("field \"mapped\" is required")
		}
		return v.VisitMappedWithContext(ctx, *u.mapped)
	case "single":
		if u.single == nil {
			return fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingleWithContext(ctx, *u.single)
	}
}

type ColorStyleVisitorWithContext interface {
	VisitMappedWithContext(ctx context.Context, v map[string]api.HexColor) error
	VisitSingleWithContext(ctx context.Context, v api.HexColor) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewColorStyleFromMapped(v map[string]api.HexColor) ColorStyle {
	return ColorStyle{typ: "mapped", mapped: &v}
}

func NewColorStyleFromSingle(v api.HexColor) ColorStyle {
	return ColorStyle{typ: "single", single: &v}
}

type DisconnectedValueVisualization struct {
	typ           string
	alwaysConnect *AlwaysConnectDisconnectedValues
	never         *NeverConnectDisconnectedValues
	threshold     *ThresholdDisconnectedValues
}

type disconnectedValueVisualizationDeserializer struct {
	Type          string                           `json:"type"`
	AlwaysConnect *AlwaysConnectDisconnectedValues `json:"alwaysConnect"`
	Never         *NeverConnectDisconnectedValues  `json:"never"`
	Threshold     *ThresholdDisconnectedValues     `json:"threshold"`
}

func (u *disconnectedValueVisualizationDeserializer) toStruct() DisconnectedValueVisualization {
	return DisconnectedValueVisualization{typ: u.Type, alwaysConnect: u.AlwaysConnect, never: u.Never, threshold: u.Threshold}
}

func (u *DisconnectedValueVisualization) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return nil, fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return struct {
			Type          string                          `json:"type"`
			AlwaysConnect AlwaysConnectDisconnectedValues `json:"alwaysConnect"`
		}{Type: "alwaysConnect", AlwaysConnect: *u.alwaysConnect}, nil
	case "never":
		if u.never == nil {
			return nil, fmt.Errorf("field \"never\" is required")
		}
		return struct {
			Type  string                         `json:"type"`
			Never NeverConnectDisconnectedValues `json:"never"`
		}{Type: "never", Never: *u.never}, nil
	case "threshold":
		if u.threshold == nil {
			return nil, fmt.Errorf("field \"threshold\" is required")
		}
		return struct {
			Type      string                      `json:"type"`
			Threshold ThresholdDisconnectedValues `json:"threshold"`
		}{Type: "threshold", Threshold: *u.threshold}, nil
	}
}

func (u DisconnectedValueVisualization) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DisconnectedValueVisualization) UnmarshalJSON(data []byte) error {
	var deser disconnectedValueVisualizationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return fmt.Errorf("field \"alwaysConnect\" is required")
		}
	case "never":
		if u.never == nil {
			return fmt.Errorf("field \"never\" is required")
		}
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
	}
	return nil
}

func (u DisconnectedValueVisualization) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DisconnectedValueVisualization) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DisconnectedValueVisualization) AcceptFuncs(alwaysConnectFunc func(AlwaysConnectDisconnectedValues) error, neverFunc func(NeverConnectDisconnectedValues) error, thresholdFunc func(ThresholdDisconnectedValues) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return alwaysConnectFunc(*u.alwaysConnect)
	case "never":
		if u.never == nil {
			return fmt.Errorf("field \"never\" is required")
		}
		return neverFunc(*u.never)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return thresholdFunc(*u.threshold)
	}
}

func (u *DisconnectedValueVisualization) AlwaysConnectNoopSuccess(AlwaysConnectDisconnectedValues) error {
	return nil
}

func (u *DisconnectedValueVisualization) NeverNoopSuccess(NeverConnectDisconnectedValues) error {
	return nil
}

func (u *DisconnectedValueVisualization) ThresholdNoopSuccess(ThresholdDisconnectedValues) error {
	return nil
}

func (u *DisconnectedValueVisualization) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DisconnectedValueVisualization) Accept(v DisconnectedValueVisualizationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return v.VisitAlwaysConnect(*u.alwaysConnect)
	case "never":
		if u.never == nil {
			return fmt.Errorf("field \"never\" is required")
		}
		return v.VisitNever(*u.never)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThreshold(*u.threshold)
	}
}

type DisconnectedValueVisualizationVisitor interface {
	VisitAlwaysConnect(v AlwaysConnectDisconnectedValues) error
	VisitNever(v NeverConnectDisconnectedValues) error
	VisitThreshold(v ThresholdDisconnectedValues) error
	VisitUnknown(typeName string) error
}

func (u *DisconnectedValueVisualization) AcceptWithContext(ctx context.Context, v DisconnectedValueVisualizationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return v.VisitAlwaysConnectWithContext(ctx, *u.alwaysConnect)
	case "never":
		if u.never == nil {
			return fmt.Errorf("field \"never\" is required")
		}
		return v.VisitNeverWithContext(ctx, *u.never)
	case "threshold":
		if u.threshold == nil {
			return fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThresholdWithContext(ctx, *u.threshold)
	}
}

type DisconnectedValueVisualizationVisitorWithContext interface {
	VisitAlwaysConnectWithContext(ctx context.Context, v AlwaysConnectDisconnectedValues) error
	VisitNeverWithContext(ctx context.Context, v NeverConnectDisconnectedValues) error
	VisitThresholdWithContext(ctx context.Context, v ThresholdDisconnectedValues) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDisconnectedValueVisualizationFromAlwaysConnect(v AlwaysConnectDisconnectedValues) DisconnectedValueVisualization {
	return DisconnectedValueVisualization{typ: "alwaysConnect", alwaysConnect: &v}
}

func NewDisconnectedValueVisualizationFromNever(v NeverConnectDisconnectedValues) DisconnectedValueVisualization {
	return DisconnectedValueVisualization{typ: "never", never: &v}
}

func NewDisconnectedValueVisualizationFromThreshold(v ThresholdDisconnectedValues) DisconnectedValueVisualization {
	return DisconnectedValueVisualization{typ: "threshold", threshold: &v}
}

type EnumGroupBySort struct {
	typ          string
	custom       *EnumGroupBySortCustom
	alphabetical *ValueSort
}

type enumGroupBySortDeserializer struct {
	Type         string                 `json:"type"`
	Custom       *EnumGroupBySortCustom `json:"custom"`
	Alphabetical *ValueSort             `json:"alphabetical"`
}

func (u *enumGroupBySortDeserializer) toStruct() EnumGroupBySort {
	return EnumGroupBySort{typ: u.Type, custom: u.Custom, alphabetical: u.Alphabetical}
}

func (u *EnumGroupBySort) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "custom":
		if u.custom == nil {
			return nil, fmt.Errorf("field \"custom\" is required")
		}
		return struct {
			Type   string                `json:"type"`
			Custom EnumGroupBySortCustom `json:"custom"`
		}{Type: "custom", Custom: *u.custom}, nil
	case "alphabetical":
		if u.alphabetical == nil {
			return nil, fmt.Errorf("field \"alphabetical\" is required")
		}
		return struct {
			Type         string    `json:"type"`
			Alphabetical ValueSort `json:"alphabetical"`
		}{Type: "alphabetical", Alphabetical: *u.alphabetical}, nil
	}
}

func (u EnumGroupBySort) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumGroupBySort) UnmarshalJSON(data []byte) error {
	var deser enumGroupBySortDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
	case "alphabetical":
		if u.alphabetical == nil {
			return fmt.Errorf("field \"alphabetical\" is required")
		}
	}
	return nil
}

func (u EnumGroupBySort) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumGroupBySort) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumGroupBySort) AcceptFuncs(customFunc func(EnumGroupBySortCustom) error, alphabeticalFunc func(ValueSort) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	case "alphabetical":
		if u.alphabetical == nil {
			return fmt.Errorf("field \"alphabetical\" is required")
		}
		return alphabeticalFunc(*u.alphabetical)
	}
}

func (u *EnumGroupBySort) CustomNoopSuccess(EnumGroupBySortCustom) error {
	return nil
}

func (u *EnumGroupBySort) AlphabeticalNoopSuccess(ValueSort) error {
	return nil
}

func (u *EnumGroupBySort) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumGroupBySort) Accept(v EnumGroupBySortVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(*u.custom)
	case "alphabetical":
		if u.alphabetical == nil {
			return fmt.Errorf("field \"alphabetical\" is required")
		}
		return v.VisitAlphabetical(*u.alphabetical)
	}
}

type EnumGroupBySortVisitor interface {
	VisitCustom(v EnumGroupBySortCustom) error
	VisitAlphabetical(v ValueSort) error
	VisitUnknown(typeName string) error
}

func (u *EnumGroupBySort) AcceptWithContext(ctx context.Context, v EnumGroupBySortVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustomWithContext(ctx, *u.custom)
	case "alphabetical":
		if u.alphabetical == nil {
			return fmt.Errorf("field \"alphabetical\" is required")
		}
		return v.VisitAlphabeticalWithContext(ctx, *u.alphabetical)
	}
}

type EnumGroupBySortVisitorWithContext interface {
	VisitCustomWithContext(ctx context.Context, v EnumGroupBySortCustom) error
	VisitAlphabeticalWithContext(ctx context.Context, v ValueSort) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumGroupBySortFromCustom(v EnumGroupBySortCustom) EnumGroupBySort {
	return EnumGroupBySort{typ: "custom", custom: &v}
}

func NewEnumGroupBySortFromAlphabetical(v ValueSort) EnumGroupBySort {
	return EnumGroupBySort{typ: "alphabetical", alphabetical: &v}
}

type EnumValueVisualisation struct {
	typ string
	raw *EnumRawVisualisation
}

type enumValueVisualisationDeserializer struct {
	Type string                `json:"type"`
	Raw  *EnumRawVisualisation `json:"raw"`
}

func (u *enumValueVisualisationDeserializer) toStruct() EnumValueVisualisation {
	return EnumValueVisualisation{typ: u.Type, raw: u.Raw}
}

func (u *EnumValueVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Raw  EnumRawVisualisation `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u EnumValueVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *EnumValueVisualisation) UnmarshalJSON(data []byte) error {
	var deser enumValueVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u EnumValueVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *EnumValueVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *EnumValueVisualisation) AcceptFuncs(rawFunc func(EnumRawVisualisation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *EnumValueVisualisation) RawNoopSuccess(EnumRawVisualisation) error {
	return nil
}

func (u *EnumValueVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *EnumValueVisualisation) Accept(v EnumValueVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type EnumValueVisualisationVisitor interface {
	VisitRaw(v EnumRawVisualisation) error
	VisitUnknown(typeName string) error
}

func (u *EnumValueVisualisation) AcceptWithContext(ctx context.Context, v EnumValueVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type EnumValueVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v EnumRawVisualisation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewEnumValueVisualisationFromRaw(v EnumRawVisualisation) EnumValueVisualisation {
	return EnumValueVisualisation{typ: "raw", raw: &v}
}

type FrequencyChartDefinition struct {
	typ string
	v1  *FrequencyChartDefinitionV1
}

type frequencyChartDefinitionDeserializer struct {
	Type string                      `json:"type"`
	V1   *FrequencyChartDefinitionV1 `json:"v1"`
}

func (u *frequencyChartDefinitionDeserializer) toStruct() FrequencyChartDefinition {
	return FrequencyChartDefinition{typ: u.Type, v1: u.V1}
}

func (u *FrequencyChartDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                     `json:"type"`
			V1   FrequencyChartDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u FrequencyChartDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FrequencyChartDefinition) UnmarshalJSON(data []byte) error {
	var deser frequencyChartDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u FrequencyChartDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FrequencyChartDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FrequencyChartDefinition) AcceptFuncs(v1Func func(FrequencyChartDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *FrequencyChartDefinition) V1NoopSuccess(FrequencyChartDefinitionV1) error {
	return nil
}

func (u *FrequencyChartDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FrequencyChartDefinition) Accept(v FrequencyChartDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type FrequencyChartDefinitionVisitor interface {
	VisitV1(v FrequencyChartDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *FrequencyChartDefinition) AcceptWithContext(ctx context.Context, v FrequencyChartDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type FrequencyChartDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v FrequencyChartDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFrequencyChartDefinitionFromV1(v FrequencyChartDefinitionV1) FrequencyChartDefinition {
	return FrequencyChartDefinition{typ: "v1", v1: &v}
}

type Geo3dDefinition struct {
	typ string
	v1  *Geo3dDefinitionV1
}

type geo3dDefinitionDeserializer struct {
	Type string             `json:"type"`
	V1   *Geo3dDefinitionV1 `json:"v1"`
}

func (u *geo3dDefinitionDeserializer) toStruct() Geo3dDefinition {
	return Geo3dDefinition{typ: u.Type, v1: u.V1}
}

func (u *Geo3dDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string            `json:"type"`
			V1   Geo3dDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u Geo3dDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dDefinition) UnmarshalJSON(data []byte) error {
	var deser geo3dDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u Geo3dDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dDefinition) AcceptFuncs(v1Func func(Geo3dDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *Geo3dDefinition) V1NoopSuccess(Geo3dDefinitionV1) error {
	return nil
}

func (u *Geo3dDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dDefinition) Accept(v Geo3dDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type Geo3dDefinitionVisitor interface {
	VisitV1(v Geo3dDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dDefinition) AcceptWithContext(ctx context.Context, v Geo3dDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type Geo3dDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v Geo3dDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dDefinitionFromV1(v Geo3dDefinitionV1) Geo3dDefinition {
	return Geo3dDefinition{typ: "v1", v1: &v}
}

type Geo3dModel struct {
	typ      string
	default_ *Geo3dDefaultModel
	custom   *Geo3dCustomModel
}

type geo3dModelDeserializer struct {
	Type    string             `json:"type"`
	Default *Geo3dDefaultModel `json:"default"`
	Custom  *Geo3dCustomModel  `json:"custom"`
}

func (u *geo3dModelDeserializer) toStruct() Geo3dModel {
	return Geo3dModel{typ: u.Type, default_: u.Default, custom: u.Custom}
}

func (u *Geo3dModel) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "default":
		if u.default_ == nil {
			return nil, fmt.Errorf("field \"default\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Default Geo3dDefaultModel `json:"default"`
		}{Type: "default", Default: *u.default_}, nil
	case "custom":
		if u.custom == nil {
			return nil, fmt.Errorf("field \"custom\" is required")
		}
		return struct {
			Type   string           `json:"type"`
			Custom Geo3dCustomModel `json:"custom"`
		}{Type: "custom", Custom: *u.custom}, nil
	}
}

func (u Geo3dModel) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dModel) UnmarshalJSON(data []byte) error {
	var deser geo3dModelDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "default":
		if u.default_ == nil {
			return fmt.Errorf("field \"default\" is required")
		}
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
	}
	return nil
}

func (u Geo3dModel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dModel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dModel) AcceptFuncs(default_Func func(Geo3dDefaultModel) error, customFunc func(Geo3dCustomModel) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "default":
		if u.default_ == nil {
			return fmt.Errorf("field \"default\" is required")
		}
		return default_Func(*u.default_)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	}
}

func (u *Geo3dModel) DefaultNoopSuccess(Geo3dDefaultModel) error {
	return nil
}

func (u *Geo3dModel) CustomNoopSuccess(Geo3dCustomModel) error {
	return nil
}

func (u *Geo3dModel) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dModel) Accept(v Geo3dModelVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "default":
		if u.default_ == nil {
			return fmt.Errorf("field \"default\" is required")
		}
		return v.VisitDefault(*u.default_)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(*u.custom)
	}
}

type Geo3dModelVisitor interface {
	VisitDefault(v Geo3dDefaultModel) error
	VisitCustom(v Geo3dCustomModel) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dModel) AcceptWithContext(ctx context.Context, v Geo3dModelVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "default":
		if u.default_ == nil {
			return fmt.Errorf("field \"default\" is required")
		}
		return v.VisitDefaultWithContext(ctx, *u.default_)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustomWithContext(ctx, *u.custom)
	}
}

type Geo3dModelVisitorWithContext interface {
	VisitDefaultWithContext(ctx context.Context, v Geo3dDefaultModel) error
	VisitCustomWithContext(ctx context.Context, v Geo3dCustomModel) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dModelFromDefault(v Geo3dDefaultModel) Geo3dModel {
	return Geo3dModel{typ: "default", default_: &v}
}

func NewGeo3dModelFromCustom(v Geo3dCustomModel) Geo3dModel {
	return Geo3dModel{typ: "custom", custom: &v}
}

type Geo3dOrientation struct {
	typ           string
	principalAxes *Geo3dOrientationPrincipalAxes
}

type geo3dOrientationDeserializer struct {
	Type          string                         `json:"type"`
	PrincipalAxes *Geo3dOrientationPrincipalAxes `json:"principalAxes"`
}

func (u *geo3dOrientationDeserializer) toStruct() Geo3dOrientation {
	return Geo3dOrientation{typ: u.Type, principalAxes: u.PrincipalAxes}
}

func (u *Geo3dOrientation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return nil, fmt.Errorf("field \"principalAxes\" is required")
		}
		return struct {
			Type          string                        `json:"type"`
			PrincipalAxes Geo3dOrientationPrincipalAxes `json:"principalAxes"`
		}{Type: "principalAxes", PrincipalAxes: *u.principalAxes}, nil
	}
}

func (u Geo3dOrientation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dOrientation) UnmarshalJSON(data []byte) error {
	var deser geo3dOrientationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
	}
	return nil
}

func (u Geo3dOrientation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dOrientation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dOrientation) AcceptFuncs(principalAxesFunc func(Geo3dOrientationPrincipalAxes) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
		return principalAxesFunc(*u.principalAxes)
	}
}

func (u *Geo3dOrientation) PrincipalAxesNoopSuccess(Geo3dOrientationPrincipalAxes) error {
	return nil
}

func (u *Geo3dOrientation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dOrientation) Accept(v Geo3dOrientationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
		return v.VisitPrincipalAxes(*u.principalAxes)
	}
}

type Geo3dOrientationVisitor interface {
	VisitPrincipalAxes(v Geo3dOrientationPrincipalAxes) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dOrientation) AcceptWithContext(ctx context.Context, v Geo3dOrientationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return fmt.Errorf("field \"principalAxes\" is required")
		}
		return v.VisitPrincipalAxesWithContext(ctx, *u.principalAxes)
	}
}

type Geo3dOrientationVisitorWithContext interface {
	VisitPrincipalAxesWithContext(ctx context.Context, v Geo3dOrientationPrincipalAxes) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dOrientationFromPrincipalAxes(v Geo3dOrientationPrincipalAxes) Geo3dOrientation {
	return Geo3dOrientation{typ: "principalAxes", principalAxes: &v}
}

type Geo3dPosition struct {
	typ   string
	wgs84 *Geo3dPositionWgs84
}

type geo3dPositionDeserializer struct {
	Type  string              `json:"type"`
	Wgs84 *Geo3dPositionWgs84 `json:"wgs84"`
}

func (u *geo3dPositionDeserializer) toStruct() Geo3dPosition {
	return Geo3dPosition{typ: u.Type, wgs84: u.Wgs84}
}

func (u *Geo3dPosition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return nil, fmt.Errorf("field \"wgs84\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Wgs84 Geo3dPositionWgs84 `json:"wgs84"`
		}{Type: "wgs84", Wgs84: *u.wgs84}, nil
	}
}

func (u Geo3dPosition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Geo3dPosition) UnmarshalJSON(data []byte) error {
	var deser geo3dPositionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
	}
	return nil
}

func (u Geo3dPosition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Geo3dPosition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Geo3dPosition) AcceptFuncs(wgs84Func func(Geo3dPositionWgs84) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
		return wgs84Func(*u.wgs84)
	}
}

func (u *Geo3dPosition) Wgs84NoopSuccess(Geo3dPositionWgs84) error {
	return nil
}

func (u *Geo3dPosition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Geo3dPosition) Accept(v Geo3dPositionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
		return v.VisitWgs84(*u.wgs84)
	}
}

type Geo3dPositionVisitor interface {
	VisitWgs84(v Geo3dPositionWgs84) error
	VisitUnknown(typeName string) error
}

func (u *Geo3dPosition) AcceptWithContext(ctx context.Context, v Geo3dPositionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return fmt.Errorf("field \"wgs84\" is required")
		}
		return v.VisitWgs84WithContext(ctx, *u.wgs84)
	}
}

type Geo3dPositionVisitorWithContext interface {
	VisitWgs84WithContext(ctx context.Context, v Geo3dPositionWgs84) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeo3dPositionFromWgs84(v Geo3dPositionWgs84) Geo3dPosition {
	return Geo3dPosition{typ: "wgs84", wgs84: &v}
}

// Additional static objects on the map, such as a point representing a tower
type GeoCustomFeature struct {
	typ   string
	point *GeoPoint
}

type geoCustomFeatureDeserializer struct {
	Type  string    `json:"type"`
	Point *GeoPoint `json:"point"`
}

func (u *geoCustomFeatureDeserializer) toStruct() GeoCustomFeature {
	return GeoCustomFeature{typ: u.Type, point: u.Point}
}

func (u *GeoCustomFeature) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "point":
		if u.point == nil {
			return nil, fmt.Errorf("field \"point\" is required")
		}
		return struct {
			Type  string   `json:"type"`
			Point GeoPoint `json:"point"`
		}{Type: "point", Point: *u.point}, nil
	}
}

func (u GeoCustomFeature) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *GeoCustomFeature) UnmarshalJSON(data []byte) error {
	var deser geoCustomFeatureDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "point":
		if u.point == nil {
			return fmt.Errorf("field \"point\" is required")
		}
	}
	return nil
}

func (u GeoCustomFeature) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *GeoCustomFeature) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *GeoCustomFeature) AcceptFuncs(pointFunc func(GeoPoint) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "point":
		if u.point == nil {
			return fmt.Errorf("field \"point\" is required")
		}
		return pointFunc(*u.point)
	}
}

func (u *GeoCustomFeature) PointNoopSuccess(GeoPoint) error {
	return nil
}

func (u *GeoCustomFeature) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *GeoCustomFeature) Accept(v GeoCustomFeatureVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "point":
		if u.point == nil {
			return fmt.Errorf("field \"point\" is required")
		}
		return v.VisitPoint(*u.point)
	}
}

type GeoCustomFeatureVisitor interface {
	VisitPoint(v GeoPoint) error
	VisitUnknown(typeName string) error
}

func (u *GeoCustomFeature) AcceptWithContext(ctx context.Context, v GeoCustomFeatureVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "point":
		if u.point == nil {
			return fmt.Errorf("field \"point\" is required")
		}
		return v.VisitPointWithContext(ctx, *u.point)
	}
}

type GeoCustomFeatureVisitorWithContext interface {
	VisitPointWithContext(ctx context.Context, v GeoPoint) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeoCustomFeatureFromPoint(v GeoPoint) GeoCustomFeature {
	return GeoCustomFeature{typ: "point", point: &v}
}

// Specifies how values of a secondary channel should be visualized.
type GeoSecondaryPlotVisualizationOption struct {
	typ      string
	asColors *ValueToColorMap
}

type geoSecondaryPlotVisualizationOptionDeserializer struct {
	Type     string           `json:"type"`
	AsColors *ValueToColorMap `json:"asColors"`
}

func (u *geoSecondaryPlotVisualizationOptionDeserializer) toStruct() GeoSecondaryPlotVisualizationOption {
	return GeoSecondaryPlotVisualizationOption{typ: u.Type, asColors: u.AsColors}
}

func (u *GeoSecondaryPlotVisualizationOption) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "asColors":
		if u.asColors == nil {
			return nil, fmt.Errorf("field \"asColors\" is required")
		}
		return struct {
			Type     string          `json:"type"`
			AsColors ValueToColorMap `json:"asColors"`
		}{Type: "asColors", AsColors: *u.asColors}, nil
	}
}

func (u GeoSecondaryPlotVisualizationOption) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *GeoSecondaryPlotVisualizationOption) UnmarshalJSON(data []byte) error {
	var deser geoSecondaryPlotVisualizationOptionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "asColors":
		if u.asColors == nil {
			return fmt.Errorf("field \"asColors\" is required")
		}
	}
	return nil
}

func (u GeoSecondaryPlotVisualizationOption) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *GeoSecondaryPlotVisualizationOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *GeoSecondaryPlotVisualizationOption) AcceptFuncs(asColorsFunc func(ValueToColorMap) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "asColors":
		if u.asColors == nil {
			return fmt.Errorf("field \"asColors\" is required")
		}
		return asColorsFunc(*u.asColors)
	}
}

func (u *GeoSecondaryPlotVisualizationOption) AsColorsNoopSuccess(ValueToColorMap) error {
	return nil
}

func (u *GeoSecondaryPlotVisualizationOption) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *GeoSecondaryPlotVisualizationOption) Accept(v GeoSecondaryPlotVisualizationOptionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "asColors":
		if u.asColors == nil {
			return fmt.Errorf("field \"asColors\" is required")
		}
		return v.VisitAsColors(*u.asColors)
	}
}

type GeoSecondaryPlotVisualizationOptionVisitor interface {
	VisitAsColors(v ValueToColorMap) error
	VisitUnknown(typeName string) error
}

func (u *GeoSecondaryPlotVisualizationOption) AcceptWithContext(ctx context.Context, v GeoSecondaryPlotVisualizationOptionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "asColors":
		if u.asColors == nil {
			return fmt.Errorf("field \"asColors\" is required")
		}
		return v.VisitAsColorsWithContext(ctx, *u.asColors)
	}
}

type GeoSecondaryPlotVisualizationOptionVisitorWithContext interface {
	VisitAsColorsWithContext(ctx context.Context, v ValueToColorMap) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeoSecondaryPlotVisualizationOptionFromAsColors(v ValueToColorMap) GeoSecondaryPlotVisualizationOption {
	return GeoSecondaryPlotVisualizationOption{typ: "asColors", asColors: &v}
}

type GeoVizDefinition struct {
	typ string
	v1  *GeoVizDefinitionV1
}

type geoVizDefinitionDeserializer struct {
	Type string              `json:"type"`
	V1   *GeoVizDefinitionV1 `json:"v1"`
}

func (u *geoVizDefinitionDeserializer) toStruct() GeoVizDefinition {
	return GeoVizDefinition{typ: u.Type, v1: u.V1}
}

func (u *GeoVizDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string             `json:"type"`
			V1   GeoVizDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u GeoVizDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *GeoVizDefinition) UnmarshalJSON(data []byte) error {
	var deser geoVizDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u GeoVizDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *GeoVizDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *GeoVizDefinition) AcceptFuncs(v1Func func(GeoVizDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *GeoVizDefinition) V1NoopSuccess(GeoVizDefinitionV1) error {
	return nil
}

func (u *GeoVizDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *GeoVizDefinition) Accept(v GeoVizDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type GeoVizDefinitionVisitor interface {
	VisitV1(v GeoVizDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *GeoVizDefinition) AcceptWithContext(ctx context.Context, v GeoVizDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type GeoVizDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v GeoVizDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewGeoVizDefinitionFromV1(v GeoVizDefinitionV1) GeoVizDefinition {
	return GeoVizDefinition{typ: "v1", v1: &v}
}

type HistogramChartDefinition struct {
	typ string
	v1  *HistogramChartDefinitionV1
}

type histogramChartDefinitionDeserializer struct {
	Type string                      `json:"type"`
	V1   *HistogramChartDefinitionV1 `json:"v1"`
}

func (u *histogramChartDefinitionDeserializer) toStruct() HistogramChartDefinition {
	return HistogramChartDefinition{typ: u.Type, v1: u.V1}
}

func (u *HistogramChartDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                     `json:"type"`
			V1   HistogramChartDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u HistogramChartDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *HistogramChartDefinition) UnmarshalJSON(data []byte) error {
	var deser histogramChartDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u HistogramChartDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *HistogramChartDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *HistogramChartDefinition) AcceptFuncs(v1Func func(HistogramChartDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *HistogramChartDefinition) V1NoopSuccess(HistogramChartDefinitionV1) error {
	return nil
}

func (u *HistogramChartDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *HistogramChartDefinition) Accept(v HistogramChartDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type HistogramChartDefinitionVisitor interface {
	VisitV1(v HistogramChartDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *HistogramChartDefinition) AcceptWithContext(ctx context.Context, v HistogramChartDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type HistogramChartDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v HistogramChartDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewHistogramChartDefinitionFromV1(v HistogramChartDefinitionV1) HistogramChartDefinition {
	return HistogramChartDefinition{typ: "v1", v1: &v}
}

type LineStyle struct {
	typ string
	v1  *LineStyleV1
}

type lineStyleDeserializer struct {
	Type string       `json:"type"`
	V1   *LineStyleV1 `json:"v1"`
}

func (u *lineStyleDeserializer) toStruct() LineStyle {
	return LineStyle{typ: u.Type, v1: u.V1}
}

func (u *LineStyle) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string      `json:"type"`
			V1   LineStyleV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u LineStyle) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LineStyle) UnmarshalJSON(data []byte) error {
	var deser lineStyleDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u LineStyle) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LineStyle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LineStyle) AcceptFuncs(v1Func func(LineStyleV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *LineStyle) V1NoopSuccess(LineStyleV1) error {
	return nil
}

func (u *LineStyle) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LineStyle) Accept(v LineStyleVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type LineStyleVisitor interface {
	VisitV1(v LineStyleV1) error
	VisitUnknown(typeName string) error
}

func (u *LineStyle) AcceptWithContext(ctx context.Context, v LineStyleVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type LineStyleVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v LineStyleV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLineStyleFromV1(v LineStyleV1) LineStyle {
	return LineStyle{typ: "v1", v1: &v}
}

type LogPanelDefinition struct {
	typ string
	v1  *LogPanelDefinitionV1
}

type logPanelDefinitionDeserializer struct {
	Type string                `json:"type"`
	V1   *LogPanelDefinitionV1 `json:"v1"`
}

func (u *logPanelDefinitionDeserializer) toStruct() LogPanelDefinition {
	return LogPanelDefinition{typ: u.Type, v1: u.V1}
}

func (u *LogPanelDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string               `json:"type"`
			V1   LogPanelDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u LogPanelDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LogPanelDefinition) UnmarshalJSON(data []byte) error {
	var deser logPanelDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u LogPanelDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LogPanelDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LogPanelDefinition) AcceptFuncs(v1Func func(LogPanelDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *LogPanelDefinition) V1NoopSuccess(LogPanelDefinitionV1) error {
	return nil
}

func (u *LogPanelDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LogPanelDefinition) Accept(v LogPanelDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type LogPanelDefinitionVisitor interface {
	VisitV1(v LogPanelDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *LogPanelDefinition) AcceptWithContext(ctx context.Context, v LogPanelDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type LogPanelDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v LogPanelDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLogPanelDefinitionFromV1(v LogPanelDefinitionV1) LogPanelDefinition {
	return LogPanelDefinition{typ: "v1", v1: &v}
}

type NumericGroupBySort struct {
	typ   string
	value *ValueSort
}

type numericGroupBySortDeserializer struct {
	Type  string     `json:"type"`
	Value *ValueSort `json:"value"`
}

func (u *numericGroupBySortDeserializer) toStruct() NumericGroupBySort {
	return NumericGroupBySort{typ: u.Type, value: u.Value}
}

func (u *NumericGroupBySort) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "value":
		if u.value == nil {
			return nil, fmt.Errorf("field \"value\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Value ValueSort `json:"value"`
		}{Type: "value", Value: *u.value}, nil
	}
}

func (u NumericGroupBySort) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericGroupBySort) UnmarshalJSON(data []byte) error {
	var deser numericGroupBySortDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
	}
	return nil
}

func (u NumericGroupBySort) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericGroupBySort) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericGroupBySort) AcceptFuncs(valueFunc func(ValueSort) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *NumericGroupBySort) ValueNoopSuccess(ValueSort) error {
	return nil
}

func (u *NumericGroupBySort) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericGroupBySort) Accept(v NumericGroupBySortVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(*u.value)
	}
}

type NumericGroupBySortVisitor interface {
	VisitValue(v ValueSort) error
	VisitUnknown(typeName string) error
}

func (u *NumericGroupBySort) AcceptWithContext(ctx context.Context, v NumericGroupBySortVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValueWithContext(ctx, *u.value)
	}
}

type NumericGroupBySortVisitorWithContext interface {
	VisitValueWithContext(ctx context.Context, v ValueSort) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericGroupBySortFromValue(v ValueSort) NumericGroupBySort {
	return NumericGroupBySort{typ: "value", value: &v}
}

type NumericValueVisualisation struct {
	typ      string
	raw      *NumericRawVisualisation
	barGauge *NumericBarGaugeVisualisation
}

type numericValueVisualisationDeserializer struct {
	Type     string                        `json:"type"`
	Raw      *NumericRawVisualisation      `json:"raw"`
	BarGauge *NumericBarGaugeVisualisation `json:"barGauge"`
}

func (u *numericValueVisualisationDeserializer) toStruct() NumericValueVisualisation {
	return NumericValueVisualisation{typ: u.Type, raw: u.Raw, barGauge: u.BarGauge}
}

func (u *NumericValueVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                  `json:"type"`
			Raw  NumericRawVisualisation `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "barGauge":
		if u.barGauge == nil {
			return nil, fmt.Errorf("field \"barGauge\" is required")
		}
		return struct {
			Type     string                       `json:"type"`
			BarGauge NumericBarGaugeVisualisation `json:"barGauge"`
		}{Type: "barGauge", BarGauge: *u.barGauge}, nil
	}
}

func (u NumericValueVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericValueVisualisation) UnmarshalJSON(data []byte) error {
	var deser numericValueVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "barGauge":
		if u.barGauge == nil {
			return fmt.Errorf("field \"barGauge\" is required")
		}
	}
	return nil
}

func (u NumericValueVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericValueVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericValueVisualisation) AcceptFuncs(rawFunc func(NumericRawVisualisation) error, barGaugeFunc func(NumericBarGaugeVisualisation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "barGauge":
		if u.barGauge == nil {
			return fmt.Errorf("field \"barGauge\" is required")
		}
		return barGaugeFunc(*u.barGauge)
	}
}

func (u *NumericValueVisualisation) RawNoopSuccess(NumericRawVisualisation) error {
	return nil
}

func (u *NumericValueVisualisation) BarGaugeNoopSuccess(NumericBarGaugeVisualisation) error {
	return nil
}

func (u *NumericValueVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericValueVisualisation) Accept(v NumericValueVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "barGauge":
		if u.barGauge == nil {
			return fmt.Errorf("field \"barGauge\" is required")
		}
		return v.VisitBarGauge(*u.barGauge)
	}
}

type NumericValueVisualisationVisitor interface {
	VisitRaw(v NumericRawVisualisation) error
	VisitBarGauge(v NumericBarGaugeVisualisation) error
	VisitUnknown(typeName string) error
}

func (u *NumericValueVisualisation) AcceptWithContext(ctx context.Context, v NumericValueVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "barGauge":
		if u.barGauge == nil {
			return fmt.Errorf("field \"barGauge\" is required")
		}
		return v.VisitBarGaugeWithContext(ctx, *u.barGauge)
	}
}

type NumericValueVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v NumericRawVisualisation) error
	VisitBarGaugeWithContext(ctx context.Context, v NumericBarGaugeVisualisation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericValueVisualisationFromRaw(v NumericRawVisualisation) NumericValueVisualisation {
	return NumericValueVisualisation{typ: "raw", raw: &v}
}

func NewNumericValueVisualisationFromBarGauge(v NumericBarGaugeVisualisation) NumericValueVisualisation {
	return NumericValueVisualisation{typ: "barGauge", barGauge: &v}
}

type NumericValueVisualisationV2 struct {
	typ string
	raw *NumericRawVisualisationV2
	bar *NumericBarVisualisationV2
}

type numericValueVisualisationV2Deserializer struct {
	Type string                     `json:"type"`
	Raw  *NumericRawVisualisationV2 `json:"raw"`
	Bar  *NumericBarVisualisationV2 `json:"bar"`
}

func (u *numericValueVisualisationV2Deserializer) toStruct() NumericValueVisualisationV2 {
	return NumericValueVisualisationV2{typ: u.Type, raw: u.Raw, bar: u.Bar}
}

func (u *NumericValueVisualisationV2) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			Raw  NumericRawVisualisationV2 `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	case "bar":
		if u.bar == nil {
			return nil, fmt.Errorf("field \"bar\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			Bar  NumericBarVisualisationV2 `json:"bar"`
		}{Type: "bar", Bar: *u.bar}, nil
	}
}

func (u NumericValueVisualisationV2) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NumericValueVisualisationV2) UnmarshalJSON(data []byte) error {
	var deser numericValueVisualisationV2Deserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
	}
	return nil
}

func (u NumericValueVisualisationV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NumericValueVisualisationV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NumericValueVisualisationV2) AcceptFuncs(rawFunc func(NumericRawVisualisationV2) error, barFunc func(NumericBarVisualisationV2) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return barFunc(*u.bar)
	}
}

func (u *NumericValueVisualisationV2) RawNoopSuccess(NumericRawVisualisationV2) error {
	return nil
}

func (u *NumericValueVisualisationV2) BarNoopSuccess(NumericBarVisualisationV2) error {
	return nil
}

func (u *NumericValueVisualisationV2) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NumericValueVisualisationV2) Accept(v NumericValueVisualisationV2Visitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBar(*u.bar)
	}
}

type NumericValueVisualisationV2Visitor interface {
	VisitRaw(v NumericRawVisualisationV2) error
	VisitBar(v NumericBarVisualisationV2) error
	VisitUnknown(typeName string) error
}

func (u *NumericValueVisualisationV2) AcceptWithContext(ctx context.Context, v NumericValueVisualisationV2VisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	case "bar":
		if u.bar == nil {
			return fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBarWithContext(ctx, *u.bar)
	}
}

type NumericValueVisualisationV2VisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v NumericRawVisualisationV2) error
	VisitBarWithContext(ctx context.Context, v NumericBarVisualisationV2) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNumericValueVisualisationV2FromRaw(v NumericRawVisualisationV2) NumericValueVisualisationV2 {
	return NumericValueVisualisationV2{typ: "raw", raw: &v}
}

func NewNumericValueVisualisationV2FromBar(v NumericBarVisualisationV2) NumericValueVisualisationV2 {
	return NumericValueVisualisationV2{typ: "bar", bar: &v}
}

type PersistValueOverlay struct {
	typ     string
	byValue *PersistByValue
	all     *PersistAll
}

type persistValueOverlayDeserializer struct {
	Type    string          `json:"type"`
	ByValue *PersistByValue `json:"byValue"`
	All     *PersistAll     `json:"all"`
}

func (u *persistValueOverlayDeserializer) toStruct() PersistValueOverlay {
	return PersistValueOverlay{typ: u.Type, byValue: u.ByValue, all: u.All}
}

func (u *PersistValueOverlay) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "byValue":
		if u.byValue == nil {
			return nil, fmt.Errorf("field \"byValue\" is required")
		}
		return struct {
			Type    string         `json:"type"`
			ByValue PersistByValue `json:"byValue"`
		}{Type: "byValue", ByValue: *u.byValue}, nil
	case "all":
		if u.all == nil {
			return nil, fmt.Errorf("field \"all\" is required")
		}
		return struct {
			Type string     `json:"type"`
			All  PersistAll `json:"all"`
		}{Type: "all", All: *u.all}, nil
	}
}

func (u PersistValueOverlay) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PersistValueOverlay) UnmarshalJSON(data []byte) error {
	var deser persistValueOverlayDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "byValue":
		if u.byValue == nil {
			return fmt.Errorf("field \"byValue\" is required")
		}
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
	}
	return nil
}

func (u PersistValueOverlay) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PersistValueOverlay) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PersistValueOverlay) AcceptFuncs(byValueFunc func(PersistByValue) error, allFunc func(PersistAll) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "byValue":
		if u.byValue == nil {
			return fmt.Errorf("field \"byValue\" is required")
		}
		return byValueFunc(*u.byValue)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return allFunc(*u.all)
	}
}

func (u *PersistValueOverlay) ByValueNoopSuccess(PersistByValue) error {
	return nil
}

func (u *PersistValueOverlay) AllNoopSuccess(PersistAll) error {
	return nil
}

func (u *PersistValueOverlay) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PersistValueOverlay) Accept(v PersistValueOverlayVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "byValue":
		if u.byValue == nil {
			return fmt.Errorf("field \"byValue\" is required")
		}
		return v.VisitByValue(*u.byValue)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAll(*u.all)
	}
}

type PersistValueOverlayVisitor interface {
	VisitByValue(v PersistByValue) error
	VisitAll(v PersistAll) error
	VisitUnknown(typeName string) error
}

func (u *PersistValueOverlay) AcceptWithContext(ctx context.Context, v PersistValueOverlayVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "byValue":
		if u.byValue == nil {
			return fmt.Errorf("field \"byValue\" is required")
		}
		return v.VisitByValueWithContext(ctx, *u.byValue)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAllWithContext(ctx, *u.all)
	}
}

type PersistValueOverlayVisitorWithContext interface {
	VisitByValueWithContext(ctx context.Context, v PersistByValue) error
	VisitAllWithContext(ctx context.Context, v PersistAll) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPersistValueOverlayFromByValue(v PersistByValue) PersistValueOverlay {
	return PersistValueOverlay{typ: "byValue", byValue: &v}
}

func NewPersistValueOverlayFromAll(v PersistAll) PersistValueOverlay {
	return PersistValueOverlay{typ: "all", all: &v}
}

type PlotlyPanelDefinition struct {
	typ string
	v1  *PlotlyPanelDefinitionV1
}

type plotlyPanelDefinitionDeserializer struct {
	Type string                   `json:"type"`
	V1   *PlotlyPanelDefinitionV1 `json:"v1"`
}

func (u *plotlyPanelDefinitionDeserializer) toStruct() PlotlyPanelDefinition {
	return PlotlyPanelDefinition{typ: u.Type, v1: u.V1}
}

func (u *PlotlyPanelDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                  `json:"type"`
			V1   PlotlyPanelDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u PlotlyPanelDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PlotlyPanelDefinition) UnmarshalJSON(data []byte) error {
	var deser plotlyPanelDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u PlotlyPanelDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PlotlyPanelDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PlotlyPanelDefinition) AcceptFuncs(v1Func func(PlotlyPanelDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *PlotlyPanelDefinition) V1NoopSuccess(PlotlyPanelDefinitionV1) error {
	return nil
}

func (u *PlotlyPanelDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PlotlyPanelDefinition) Accept(v PlotlyPanelDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type PlotlyPanelDefinitionVisitor interface {
	VisitV1(v PlotlyPanelDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *PlotlyPanelDefinition) AcceptWithContext(ctx context.Context, v PlotlyPanelDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type PlotlyPanelDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v PlotlyPanelDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPlotlyPanelDefinitionFromV1(v PlotlyPanelDefinitionV1) PlotlyPanelDefinition {
	return PlotlyPanelDefinition{typ: "v1", v1: &v}
}

type ProcedureVizDefinition struct {
	typ string
	v1  *ProcedureVizDefinitionV1
}

type procedureVizDefinitionDeserializer struct {
	Type string                    `json:"type"`
	V1   *ProcedureVizDefinitionV1 `json:"v1"`
}

func (u *procedureVizDefinitionDeserializer) toStruct() ProcedureVizDefinition {
	return ProcedureVizDefinition{typ: u.Type, v1: u.V1}
}

func (u *ProcedureVizDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                   `json:"type"`
			V1   ProcedureVizDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u ProcedureVizDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ProcedureVizDefinition) UnmarshalJSON(data []byte) error {
	var deser procedureVizDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u ProcedureVizDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ProcedureVizDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ProcedureVizDefinition) AcceptFuncs(v1Func func(ProcedureVizDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ProcedureVizDefinition) V1NoopSuccess(ProcedureVizDefinitionV1) error {
	return nil
}

func (u *ProcedureVizDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ProcedureVizDefinition) Accept(v ProcedureVizDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type ProcedureVizDefinitionVisitor interface {
	VisitV1(v ProcedureVizDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *ProcedureVizDefinition) AcceptWithContext(ctx context.Context, v ProcedureVizDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type ProcedureVizDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v ProcedureVizDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewProcedureVizDefinitionFromV1(v ProcedureVizDefinitionV1) ProcedureVizDefinition {
	return ProcedureVizDefinition{typ: "v1", v1: &v}
}

type RangeGroupBySort struct {
	typ   string
	value *ValueSort
}

type rangeGroupBySortDeserializer struct {
	Type  string     `json:"type"`
	Value *ValueSort `json:"value"`
}

func (u *rangeGroupBySortDeserializer) toStruct() RangeGroupBySort {
	return RangeGroupBySort{typ: u.Type, value: u.Value}
}

func (u *RangeGroupBySort) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "value":
		if u.value == nil {
			return nil, fmt.Errorf("field \"value\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Value ValueSort `json:"value"`
		}{Type: "value", Value: *u.value}, nil
	}
}

func (u RangeGroupBySort) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangeGroupBySort) UnmarshalJSON(data []byte) error {
	var deser rangeGroupBySortDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
	}
	return nil
}

func (u RangeGroupBySort) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangeGroupBySort) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangeGroupBySort) AcceptFuncs(valueFunc func(ValueSort) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *RangeGroupBySort) ValueNoopSuccess(ValueSort) error {
	return nil
}

func (u *RangeGroupBySort) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangeGroupBySort) Accept(v RangeGroupBySortVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(*u.value)
	}
}

type RangeGroupBySortVisitor interface {
	VisitValue(v ValueSort) error
	VisitUnknown(typeName string) error
}

func (u *RangeGroupBySort) AcceptWithContext(ctx context.Context, v RangeGroupBySortVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValueWithContext(ctx, *u.value)
	}
}

type RangeGroupBySortVisitorWithContext interface {
	VisitValueWithContext(ctx context.Context, v ValueSort) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangeGroupBySortFromValue(v ValueSort) RangeGroupBySort {
	return RangeGroupBySort{typ: "value", value: &v}
}

type RangeValueVisualisation struct {
	typ string
	raw *RangeRawVisualisation
}

type rangeValueVisualisationDeserializer struct {
	Type string                 `json:"type"`
	Raw  *RangeRawVisualisation `json:"raw"`
}

func (u *rangeValueVisualisationDeserializer) toStruct() RangeValueVisualisation {
	return RangeValueVisualisation{typ: u.Type, raw: u.Raw}
}

func (u *RangeValueVisualisation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "raw":
		if u.raw == nil {
			return nil, fmt.Errorf("field \"raw\" is required")
		}
		return struct {
			Type string                `json:"type"`
			Raw  RangeRawVisualisation `json:"raw"`
		}{Type: "raw", Raw: *u.raw}, nil
	}
}

func (u RangeValueVisualisation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RangeValueVisualisation) UnmarshalJSON(data []byte) error {
	var deser rangeValueVisualisationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
	}
	return nil
}

func (u RangeValueVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RangeValueVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RangeValueVisualisation) AcceptFuncs(rawFunc func(RangeRawVisualisation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *RangeValueVisualisation) RawNoopSuccess(RangeRawVisualisation) error {
	return nil
}

func (u *RangeValueVisualisation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RangeValueVisualisation) Accept(v RangeValueVisualisationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(*u.raw)
	}
}

type RangeValueVisualisationVisitor interface {
	VisitRaw(v RangeRawVisualisation) error
	VisitUnknown(typeName string) error
}

func (u *RangeValueVisualisation) AcceptWithContext(ctx context.Context, v RangeValueVisualisationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRawWithContext(ctx, *u.raw)
	}
}

type RangeValueVisualisationVisitorWithContext interface {
	VisitRawWithContext(ctx context.Context, v RangeRawVisualisation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRangeValueVisualisationFromRaw(v RangeRawVisualisation) RangeValueVisualisation {
	return RangeValueVisualisation{typ: "raw", raw: &v}
}

type TimeSeriesChartDefinition struct {
	typ string
	v1  *TimeSeriesChartDefinitionV1
}

type timeSeriesChartDefinitionDeserializer struct {
	Type string                       `json:"type"`
	V1   *TimeSeriesChartDefinitionV1 `json:"v1"`
}

func (u *timeSeriesChartDefinitionDeserializer) toStruct() TimeSeriesChartDefinition {
	return TimeSeriesChartDefinition{typ: u.Type, v1: u.V1}
}

func (u *TimeSeriesChartDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                      `json:"type"`
			V1   TimeSeriesChartDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u TimeSeriesChartDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimeSeriesChartDefinition) UnmarshalJSON(data []byte) error {
	var deser timeSeriesChartDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u TimeSeriesChartDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimeSeriesChartDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimeSeriesChartDefinition) AcceptFuncs(v1Func func(TimeSeriesChartDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *TimeSeriesChartDefinition) V1NoopSuccess(TimeSeriesChartDefinitionV1) error {
	return nil
}

func (u *TimeSeriesChartDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimeSeriesChartDefinition) Accept(v TimeSeriesChartDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type TimeSeriesChartDefinitionVisitor interface {
	VisitV1(v TimeSeriesChartDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *TimeSeriesChartDefinition) AcceptWithContext(ctx context.Context, v TimeSeriesChartDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type TimeSeriesChartDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v TimeSeriesChartDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimeSeriesChartDefinitionFromV1(v TimeSeriesChartDefinitionV1) TimeSeriesChartDefinition {
	return TimeSeriesChartDefinition{typ: "v1", v1: &v}
}

type TimeSeriesPlotConfig struct {
	typ     string
	numeric *TimeSeriesNumericPlot
	range_  *TimeSeriesRangePlot
	enum    *TimeSeriesEnumPlot
}

type timeSeriesPlotConfigDeserializer struct {
	Type    string                 `json:"type"`
	Numeric *TimeSeriesNumericPlot `json:"numeric"`
	Range   *TimeSeriesRangePlot   `json:"range"`
	Enum    *TimeSeriesEnumPlot    `json:"enum"`
}

func (u *timeSeriesPlotConfigDeserializer) toStruct() TimeSeriesPlotConfig {
	return TimeSeriesPlotConfig{typ: u.Type, numeric: u.Numeric, range_: u.Range, enum: u.Enum}
}

func (u *TimeSeriesPlotConfig) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string                `json:"type"`
			Numeric TimeSeriesNumericPlot `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "range":
		if u.range_ == nil {
			return nil, fmt.Errorf("field \"range\" is required")
		}
		return struct {
			Type  string              `json:"type"`
			Range TimeSeriesRangePlot `json:"range"`
		}{Type: "range", Range: *u.range_}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string             `json:"type"`
			Enum TimeSeriesEnumPlot `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	}
}

func (u TimeSeriesPlotConfig) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimeSeriesPlotConfig) UnmarshalJSON(data []byte) error {
	var deser timeSeriesPlotConfigDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	}
	return nil
}

func (u TimeSeriesPlotConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimeSeriesPlotConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimeSeriesPlotConfig) AcceptFuncs(numericFunc func(TimeSeriesNumericPlot) error, range_Func func(TimeSeriesRangePlot) error, enumFunc func(TimeSeriesEnumPlot) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	}
}

func (u *TimeSeriesPlotConfig) NumericNoopSuccess(TimeSeriesNumericPlot) error {
	return nil
}

func (u *TimeSeriesPlotConfig) RangeNoopSuccess(TimeSeriesRangePlot) error {
	return nil
}

func (u *TimeSeriesPlotConfig) EnumNoopSuccess(TimeSeriesEnumPlot) error {
	return nil
}

func (u *TimeSeriesPlotConfig) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimeSeriesPlotConfig) Accept(v TimeSeriesPlotConfigVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(*u.range_)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	}
}

type TimeSeriesPlotConfigVisitor interface {
	VisitNumeric(v TimeSeriesNumericPlot) error
	VisitRange(v TimeSeriesRangePlot) error
	VisitEnum(v TimeSeriesEnumPlot) error
	VisitUnknown(typeName string) error
}

func (u *TimeSeriesPlotConfig) AcceptWithContext(ctx context.Context, v TimeSeriesPlotConfigVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRangeWithContext(ctx, *u.range_)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	}
}

type TimeSeriesPlotConfigVisitorWithContext interface {
	VisitNumericWithContext(ctx context.Context, v TimeSeriesNumericPlot) error
	VisitRangeWithContext(ctx context.Context, v TimeSeriesRangePlot) error
	VisitEnumWithContext(ctx context.Context, v TimeSeriesEnumPlot) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimeSeriesPlotConfigFromNumeric(v TimeSeriesNumericPlot) TimeSeriesPlotConfig {
	return TimeSeriesPlotConfig{typ: "numeric", numeric: &v}
}

func NewTimeSeriesPlotConfigFromRange(v TimeSeriesRangePlot) TimeSeriesPlotConfig {
	return TimeSeriesPlotConfig{typ: "range", range_: &v}
}

func NewTimeSeriesPlotConfigFromEnum(v TimeSeriesEnumPlot) TimeSeriesPlotConfig {
	return TimeSeriesPlotConfig{typ: "enum", enum: &v}
}

type TraceComputeConfig struct {
	typ       string
	scatter3d *Scatter3dTraceComputeConfig
}

type traceComputeConfigDeserializer struct {
	Type      string                       `json:"type"`
	Scatter3d *Scatter3dTraceComputeConfig `json:"scatter3d"`
}

func (u *traceComputeConfigDeserializer) toStruct() TraceComputeConfig {
	return TraceComputeConfig{typ: u.Type, scatter3d: u.Scatter3d}
}

func (u *TraceComputeConfig) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return nil, fmt.Errorf("field \"scatter3d\" is required")
		}
		return struct {
			Type      string                      `json:"type"`
			Scatter3d Scatter3dTraceComputeConfig `json:"scatter3d"`
		}{Type: "scatter3d", Scatter3d: *u.scatter3d}, nil
	}
}

func (u TraceComputeConfig) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TraceComputeConfig) UnmarshalJSON(data []byte) error {
	var deser traceComputeConfigDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
	}
	return nil
}

func (u TraceComputeConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TraceComputeConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TraceComputeConfig) AcceptFuncs(scatter3dFunc func(Scatter3dTraceComputeConfig) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return scatter3dFunc(*u.scatter3d)
	}
}

func (u *TraceComputeConfig) Scatter3dNoopSuccess(Scatter3dTraceComputeConfig) error {
	return nil
}

func (u *TraceComputeConfig) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TraceComputeConfig) Accept(v TraceComputeConfigVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3d(*u.scatter3d)
	}
}

type TraceComputeConfigVisitor interface {
	VisitScatter3d(v Scatter3dTraceComputeConfig) error
	VisitUnknown(typeName string) error
}

func (u *TraceComputeConfig) AcceptWithContext(ctx context.Context, v TraceComputeConfigVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3dWithContext(ctx, *u.scatter3d)
	}
}

type TraceComputeConfigVisitorWithContext interface {
	VisitScatter3dWithContext(ctx context.Context, v Scatter3dTraceComputeConfig) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTraceComputeConfigFromScatter3d(v Scatter3dTraceComputeConfig) TraceComputeConfig {
	return TraceComputeConfig{typ: "scatter3d", scatter3d: &v}
}

type ValueTableCellConfig struct {
	typ        string
	numeric    *NumericCellConfig
	enum       *EnumCellConfig
	range_     *RangeCellConfig
	bitFlagMap *BitFlagMapCellConfig
}

type valueTableCellConfigDeserializer struct {
	Type       string                `json:"type"`
	Numeric    *NumericCellConfig    `json:"numeric"`
	Enum       *EnumCellConfig       `json:"enum"`
	Range      *RangeCellConfig      `json:"range"`
	BitFlagMap *BitFlagMapCellConfig `json:"bitFlagMap"`
}

func (u *valueTableCellConfigDeserializer) toStruct() ValueTableCellConfig {
	return ValueTableCellConfig{typ: u.Type, numeric: u.Numeric, enum: u.Enum, range_: u.Range, bitFlagMap: u.BitFlagMap}
}

func (u *ValueTableCellConfig) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string            `json:"type"`
			Numeric NumericCellConfig `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string         `json:"type"`
			Enum EnumCellConfig `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "range":
		if u.range_ == nil {
			return nil, fmt.Errorf("field \"range\" is required")
		}
		return struct {
			Type  string          `json:"type"`
			Range RangeCellConfig `json:"range"`
		}{Type: "range", Range: *u.range_}, nil
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return nil, fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return struct {
			Type       string               `json:"type"`
			BitFlagMap BitFlagMapCellConfig `json:"bitFlagMap"`
		}{Type: "bitFlagMap", BitFlagMap: *u.bitFlagMap}, nil
	}
}

func (u ValueTableCellConfig) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ValueTableCellConfig) UnmarshalJSON(data []byte) error {
	var deser valueTableCellConfigDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return fmt.Errorf("field \"bitFlagMap\" is required")
		}
	}
	return nil
}

func (u ValueTableCellConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ValueTableCellConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ValueTableCellConfig) AcceptFuncs(numericFunc func(NumericCellConfig) error, enumFunc func(EnumCellConfig) error, range_Func func(RangeCellConfig) error, bitFlagMapFunc func(BitFlagMapCellConfig) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return bitFlagMapFunc(*u.bitFlagMap)
	}
}

func (u *ValueTableCellConfig) NumericNoopSuccess(NumericCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) EnumNoopSuccess(EnumCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) RangeNoopSuccess(RangeCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) BitFlagMapNoopSuccess(BitFlagMapCellConfig) error {
	return nil
}

func (u *ValueTableCellConfig) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ValueTableCellConfig) Accept(v ValueTableCellConfigVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(*u.range_)
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return v.VisitBitFlagMap(*u.bitFlagMap)
	}
}

type ValueTableCellConfigVisitor interface {
	VisitNumeric(v NumericCellConfig) error
	VisitEnum(v EnumCellConfig) error
	VisitRange(v RangeCellConfig) error
	VisitBitFlagMap(v BitFlagMapCellConfig) error
	VisitUnknown(typeName string) error
}

func (u *ValueTableCellConfig) AcceptWithContext(ctx context.Context, v ValueTableCellConfigVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRangeWithContext(ctx, *u.range_)
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return v.VisitBitFlagMapWithContext(ctx, *u.bitFlagMap)
	}
}

type ValueTableCellConfigVisitorWithContext interface {
	VisitNumericWithContext(ctx context.Context, v NumericCellConfig) error
	VisitEnumWithContext(ctx context.Context, v EnumCellConfig) error
	VisitRangeWithContext(ctx context.Context, v RangeCellConfig) error
	VisitBitFlagMapWithContext(ctx context.Context, v BitFlagMapCellConfig) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewValueTableCellConfigFromNumeric(v NumericCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "numeric", numeric: &v}
}

func NewValueTableCellConfigFromEnum(v EnumCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "enum", enum: &v}
}

func NewValueTableCellConfigFromRange(v RangeCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "range", range_: &v}
}

func NewValueTableCellConfigFromBitFlagMap(v BitFlagMapCellConfig) ValueTableCellConfig {
	return ValueTableCellConfig{typ: "bitFlagMap", bitFlagMap: &v}
}

type ValueTableChannel struct {
	typ     string
	numeric *NumericValueChannel
	enum    *EnumValueChannel
	range_  *RangeValueChannel
}

type valueTableChannelDeserializer struct {
	Type    string               `json:"type"`
	Numeric *NumericValueChannel `json:"numeric"`
	Enum    *EnumValueChannel    `json:"enum"`
	Range   *RangeValueChannel   `json:"range"`
}

func (u *valueTableChannelDeserializer) toStruct() ValueTableChannel {
	return ValueTableChannel{typ: u.Type, numeric: u.Numeric, enum: u.Enum, range_: u.Range}
}

func (u *ValueTableChannel) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string              `json:"type"`
			Numeric NumericValueChannel `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string           `json:"type"`
			Enum EnumValueChannel `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "range":
		if u.range_ == nil {
			return nil, fmt.Errorf("field \"range\" is required")
		}
		return struct {
			Type  string            `json:"type"`
			Range RangeValueChannel `json:"range"`
		}{Type: "range", Range: *u.range_}, nil
	}
}

func (u ValueTableChannel) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ValueTableChannel) UnmarshalJSON(data []byte) error {
	var deser valueTableChannelDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
	}
	return nil
}

func (u ValueTableChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ValueTableChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ValueTableChannel) AcceptFuncs(numericFunc func(NumericValueChannel) error, enumFunc func(EnumValueChannel) error, range_Func func(RangeValueChannel) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	}
}

func (u *ValueTableChannel) NumericNoopSuccess(NumericValueChannel) error {
	return nil
}

func (u *ValueTableChannel) EnumNoopSuccess(EnumValueChannel) error {
	return nil
}

func (u *ValueTableChannel) RangeNoopSuccess(RangeValueChannel) error {
	return nil
}

func (u *ValueTableChannel) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ValueTableChannel) Accept(v ValueTableChannelVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(*u.range_)
	}
}

type ValueTableChannelVisitor interface {
	VisitNumeric(v NumericValueChannel) error
	VisitEnum(v EnumValueChannel) error
	VisitRange(v RangeValueChannel) error
	VisitUnknown(typeName string) error
}

func (u *ValueTableChannel) AcceptWithContext(ctx context.Context, v ValueTableChannelVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRangeWithContext(ctx, *u.range_)
	}
}

type ValueTableChannelVisitorWithContext interface {
	VisitNumericWithContext(ctx context.Context, v NumericValueChannel) error
	VisitEnumWithContext(ctx context.Context, v EnumValueChannel) error
	VisitRangeWithContext(ctx context.Context, v RangeValueChannel) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewValueTableChannelFromNumeric(v NumericValueChannel) ValueTableChannel {
	return ValueTableChannel{typ: "numeric", numeric: &v}
}

func NewValueTableChannelFromEnum(v EnumValueChannel) ValueTableChannel {
	return ValueTableChannel{typ: "enum", enum: &v}
}

func NewValueTableChannelFromRange(v RangeValueChannel) ValueTableChannel {
	return ValueTableChannel{typ: "range", range_: &v}
}

type ValueTableDefinition struct {
	typ string
	v1  *ValueTableDefinitionV1
	v2  *ValueTableDefinitionV2
}

type valueTableDefinitionDeserializer struct {
	Type string                  `json:"type"`
	V1   *ValueTableDefinitionV1 `json:"v1"`
	V2   *ValueTableDefinitionV2 `json:"v2"`
}

func (u *valueTableDefinitionDeserializer) toStruct() ValueTableDefinition {
	return ValueTableDefinition{typ: u.Type, v1: u.V1, v2: u.V2}
}

func (u *ValueTableDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                 `json:"type"`
			V1   ValueTableDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	case "v2":
		if u.v2 == nil {
			return nil, fmt.Errorf("field \"v2\" is required")
		}
		return struct {
			Type string                 `json:"type"`
			V2   ValueTableDefinitionV2 `json:"v2"`
		}{Type: "v2", V2: *u.v2}, nil
	}
}

func (u ValueTableDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ValueTableDefinition) UnmarshalJSON(data []byte) error {
	var deser valueTableDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
	}
	return nil
}

func (u ValueTableDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ValueTableDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ValueTableDefinition) AcceptFuncs(v1Func func(ValueTableDefinitionV1) error, v2Func func(ValueTableDefinitionV2) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *ValueTableDefinition) V1NoopSuccess(ValueTableDefinitionV1) error {
	return nil
}

func (u *ValueTableDefinition) V2NoopSuccess(ValueTableDefinitionV2) error {
	return nil
}

func (u *ValueTableDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ValueTableDefinition) Accept(v ValueTableDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(*u.v2)
	}
}

type ValueTableDefinitionVisitor interface {
	VisitV1(v ValueTableDefinitionV1) error
	VisitV2(v ValueTableDefinitionV2) error
	VisitUnknown(typeName string) error
}

func (u *ValueTableDefinition) AcceptWithContext(ctx context.Context, v ValueTableDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2WithContext(ctx, *u.v2)
	}
}

type ValueTableDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v ValueTableDefinitionV1) error
	VisitV2WithContext(ctx context.Context, v ValueTableDefinitionV2) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewValueTableDefinitionFromV1(v ValueTableDefinitionV1) ValueTableDefinition {
	return ValueTableDefinition{typ: "v1", v1: &v}
}

func NewValueTableDefinitionFromV2(v ValueTableDefinitionV2) ValueTableDefinition {
	return ValueTableDefinition{typ: "v2", v2: &v}
}

type ValueTableLayout struct {
	typ  string
	grid *ValueTableLayoutGrid
}

type valueTableLayoutDeserializer struct {
	Type string                `json:"type"`
	Grid *ValueTableLayoutGrid `json:"grid"`
}

func (u *valueTableLayoutDeserializer) toStruct() ValueTableLayout {
	return ValueTableLayout{typ: u.Type, grid: u.Grid}
}

func (u *ValueTableLayout) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "grid":
		if u.grid == nil {
			return nil, fmt.Errorf("field \"grid\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Grid ValueTableLayoutGrid `json:"grid"`
		}{Type: "grid", Grid: *u.grid}, nil
	}
}

func (u ValueTableLayout) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ValueTableLayout) UnmarshalJSON(data []byte) error {
	var deser valueTableLayoutDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "grid":
		if u.grid == nil {
			return fmt.Errorf("field \"grid\" is required")
		}
	}
	return nil
}

func (u ValueTableLayout) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ValueTableLayout) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ValueTableLayout) AcceptFuncs(gridFunc func(ValueTableLayoutGrid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "grid":
		if u.grid == nil {
			return fmt.Errorf("field \"grid\" is required")
		}
		return gridFunc(*u.grid)
	}
}

func (u *ValueTableLayout) GridNoopSuccess(ValueTableLayoutGrid) error {
	return nil
}

func (u *ValueTableLayout) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ValueTableLayout) Accept(v ValueTableLayoutVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "grid":
		if u.grid == nil {
			return fmt.Errorf("field \"grid\" is required")
		}
		return v.VisitGrid(*u.grid)
	}
}

type ValueTableLayoutVisitor interface {
	VisitGrid(v ValueTableLayoutGrid) error
	VisitUnknown(typeName string) error
}

func (u *ValueTableLayout) AcceptWithContext(ctx context.Context, v ValueTableLayoutVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "grid":
		if u.grid == nil {
			return fmt.Errorf("field \"grid\" is required")
		}
		return v.VisitGridWithContext(ctx, *u.grid)
	}
}

type ValueTableLayoutVisitorWithContext interface {
	VisitGridWithContext(ctx context.Context, v ValueTableLayoutGrid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewValueTableLayoutFromGrid(v ValueTableLayoutGrid) ValueTableLayout {
	return ValueTableLayout{typ: "grid", grid: &v}
}

// Specifies an assignment of colors across several values.
type ValueToColorMap struct {
	typ     string
	numeric *map[api.HexColor]float64
}

type valueToColorMapDeserializer struct {
	Type    string                    `json:"type"`
	Numeric *map[api.HexColor]float64 `json:"numeric"`
}

func (u *valueToColorMapDeserializer) toStruct() ValueToColorMap {
	return ValueToColorMap{typ: u.Type, numeric: u.Numeric}
}

func (u *ValueToColorMap) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string                   `json:"type"`
			Numeric map[api.HexColor]float64 `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	}
}

func (u ValueToColorMap) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ValueToColorMap) UnmarshalJSON(data []byte) error {
	var deser valueToColorMapDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	}
	return nil
}

func (u ValueToColorMap) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ValueToColorMap) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ValueToColorMap) AcceptFuncs(numericFunc func(map[api.HexColor]float64) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	}
}

func (u *ValueToColorMap) NumericNoopSuccess(map[api.HexColor]float64) error {
	return nil
}

func (u *ValueToColorMap) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ValueToColorMap) Accept(v ValueToColorMapVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	}
}

type ValueToColorMapVisitor interface {
	VisitNumeric(v map[api.HexColor]float64) error
	VisitUnknown(typeName string) error
}

func (u *ValueToColorMap) AcceptWithContext(ctx context.Context, v ValueToColorMapVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	}
}

type ValueToColorMapVisitorWithContext interface {
	VisitNumericWithContext(ctx context.Context, v map[api.HexColor]float64) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewValueToColorMapFromNumeric(v map[api.HexColor]float64) ValueToColorMap {
	return ValueToColorMap{typ: "numeric", numeric: &v}
}

type VideoVizDefinition struct {
	typ string
	v1  *VideoVizDefinitionV1
}

type videoVizDefinitionDeserializer struct {
	Type string                `json:"type"`
	V1   *VideoVizDefinitionV1 `json:"v1"`
}

func (u *videoVizDefinitionDeserializer) toStruct() VideoVizDefinition {
	return VideoVizDefinition{typ: u.Type, v1: u.V1}
}

func (u *VideoVizDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string               `json:"type"`
			V1   VideoVizDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u VideoVizDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VideoVizDefinition) UnmarshalJSON(data []byte) error {
	var deser videoVizDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u VideoVizDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VideoVizDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VideoVizDefinition) AcceptFuncs(v1Func func(VideoVizDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *VideoVizDefinition) V1NoopSuccess(VideoVizDefinitionV1) error {
	return nil
}

func (u *VideoVizDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VideoVizDefinition) Accept(v VideoVizDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type VideoVizDefinitionVisitor interface {
	VisitV1(v VideoVizDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *VideoVizDefinition) AcceptWithContext(ctx context.Context, v VideoVizDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type VideoVizDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v VideoVizDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVideoVizDefinitionFromV1(v VideoVizDefinitionV1) VideoVizDefinition {
	return VideoVizDefinition{typ: "v1", v1: &v}
}

type VizDefinition struct {
	typ        string
	cartesian  *CartesianChartDefinition
	checklist  *ChecklistChartDefinition
	frequency  *FrequencyChartDefinition
	geo        *GeoVizDefinition
	geo3d      *Geo3dDefinition
	histogram  *HistogramChartDefinition
	log        *LogPanelDefinition
	plotly     *PlotlyPanelDefinition
	timeSeries *TimeSeriesChartDefinition
	valueTable *ValueTableDefinition
	video      *VideoVizDefinition
	procedure  *ProcedureVizDefinition
}

type vizDefinitionDeserializer struct {
	Type       string                     `json:"type"`
	Cartesian  *CartesianChartDefinition  `json:"cartesian"`
	Checklist  *ChecklistChartDefinition  `json:"checklist"`
	Frequency  *FrequencyChartDefinition  `json:"frequency"`
	Geo        *GeoVizDefinition          `json:"geo"`
	Geo3d      *Geo3dDefinition           `json:"geo3d"`
	Histogram  *HistogramChartDefinition  `json:"histogram"`
	Log        *LogPanelDefinition        `json:"log"`
	Plotly     *PlotlyPanelDefinition     `json:"plotly"`
	TimeSeries *TimeSeriesChartDefinition `json:"timeSeries"`
	ValueTable *ValueTableDefinition      `json:"valueTable"`
	Video      *VideoVizDefinition        `json:"video"`
	Procedure  *ProcedureVizDefinition    `json:"procedure"`
}

func (u *vizDefinitionDeserializer) toStruct() VizDefinition {
	return VizDefinition{typ: u.Type, cartesian: u.Cartesian, checklist: u.Checklist, frequency: u.Frequency, geo: u.Geo, geo3d: u.Geo3d, histogram: u.Histogram, log: u.Log, plotly: u.Plotly, timeSeries: u.TimeSeries, valueTable: u.ValueTable, video: u.Video, procedure: u.Procedure}
}

func (u *VizDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return nil, fmt.Errorf("field \"cartesian\" is required")
		}
		return struct {
			Type      string                   `json:"type"`
			Cartesian CartesianChartDefinition `json:"cartesian"`
		}{Type: "cartesian", Cartesian: *u.cartesian}, nil
	case "checklist":
		if u.checklist == nil {
			return nil, fmt.Errorf("field \"checklist\" is required")
		}
		return struct {
			Type      string                   `json:"type"`
			Checklist ChecklistChartDefinition `json:"checklist"`
		}{Type: "checklist", Checklist: *u.checklist}, nil
	case "frequency":
		if u.frequency == nil {
			return nil, fmt.Errorf("field \"frequency\" is required")
		}
		return struct {
			Type      string                   `json:"type"`
			Frequency FrequencyChartDefinition `json:"frequency"`
		}{Type: "frequency", Frequency: *u.frequency}, nil
	case "geo":
		if u.geo == nil {
			return nil, fmt.Errorf("field \"geo\" is required")
		}
		return struct {
			Type string           `json:"type"`
			Geo  GeoVizDefinition `json:"geo"`
		}{Type: "geo", Geo: *u.geo}, nil
	case "geo3d":
		if u.geo3d == nil {
			return nil, fmt.Errorf("field \"geo3d\" is required")
		}
		return struct {
			Type  string          `json:"type"`
			Geo3d Geo3dDefinition `json:"geo3d"`
		}{Type: "geo3d", Geo3d: *u.geo3d}, nil
	case "histogram":
		if u.histogram == nil {
			return nil, fmt.Errorf("field \"histogram\" is required")
		}
		return struct {
			Type      string                   `json:"type"`
			Histogram HistogramChartDefinition `json:"histogram"`
		}{Type: "histogram", Histogram: *u.histogram}, nil
	case "log":
		if u.log == nil {
			return nil, fmt.Errorf("field \"log\" is required")
		}
		return struct {
			Type string             `json:"type"`
			Log  LogPanelDefinition `json:"log"`
		}{Type: "log", Log: *u.log}, nil
	case "plotly":
		if u.plotly == nil {
			return nil, fmt.Errorf("field \"plotly\" is required")
		}
		return struct {
			Type   string                `json:"type"`
			Plotly PlotlyPanelDefinition `json:"plotly"`
		}{Type: "plotly", Plotly: *u.plotly}, nil
	case "timeSeries":
		if u.timeSeries == nil {
			return nil, fmt.Errorf("field \"timeSeries\" is required")
		}
		return struct {
			Type       string                    `json:"type"`
			TimeSeries TimeSeriesChartDefinition `json:"timeSeries"`
		}{Type: "timeSeries", TimeSeries: *u.timeSeries}, nil
	case "valueTable":
		if u.valueTable == nil {
			return nil, fmt.Errorf("field \"valueTable\" is required")
		}
		return struct {
			Type       string               `json:"type"`
			ValueTable ValueTableDefinition `json:"valueTable"`
		}{Type: "valueTable", ValueTable: *u.valueTable}, nil
	case "video":
		if u.video == nil {
			return nil, fmt.Errorf("field \"video\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Video VideoVizDefinition `json:"video"`
		}{Type: "video", Video: *u.video}, nil
	case "procedure":
		if u.procedure == nil {
			return nil, fmt.Errorf("field \"procedure\" is required")
		}
		return struct {
			Type      string                 `json:"type"`
			Procedure ProcedureVizDefinition `json:"procedure"`
		}{Type: "procedure", Procedure: *u.procedure}, nil
	}
}

func (u VizDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VizDefinition) UnmarshalJSON(data []byte) error {
	var deser vizDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
	case "geo3d":
		if u.geo3d == nil {
			return fmt.Errorf("field \"geo3d\" is required")
		}
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
	case "plotly":
		if u.plotly == nil {
			return fmt.Errorf("field \"plotly\" is required")
		}
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
	case "valueTable":
		if u.valueTable == nil {
			return fmt.Errorf("field \"valueTable\" is required")
		}
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
	}
	return nil
}

func (u VizDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VizDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VizDefinition) AcceptFuncs(cartesianFunc func(CartesianChartDefinition) error, checklistFunc func(ChecklistChartDefinition) error, frequencyFunc func(FrequencyChartDefinition) error, geoFunc func(GeoVizDefinition) error, geo3dFunc func(Geo3dDefinition) error, histogramFunc func(HistogramChartDefinition) error, logFunc func(LogPanelDefinition) error, plotlyFunc func(PlotlyPanelDefinition) error, timeSeriesFunc func(TimeSeriesChartDefinition) error, valueTableFunc func(ValueTableDefinition) error, videoFunc func(VideoVizDefinition) error, procedureFunc func(ProcedureVizDefinition) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
		return checklistFunc(*u.checklist)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return frequencyFunc(*u.frequency)
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
		return geoFunc(*u.geo)
	case "geo3d":
		if u.geo3d == nil {
			return fmt.Errorf("field \"geo3d\" is required")
		}
		return geo3dFunc(*u.geo3d)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return histogramFunc(*u.histogram)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "plotly":
		if u.plotly == nil {
			return fmt.Errorf("field \"plotly\" is required")
		}
		return plotlyFunc(*u.plotly)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return timeSeriesFunc(*u.timeSeries)
	case "valueTable":
		if u.valueTable == nil {
			return fmt.Errorf("field \"valueTable\" is required")
		}
		return valueTableFunc(*u.valueTable)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
		return procedureFunc(*u.procedure)
	}
}

func (u *VizDefinition) CartesianNoopSuccess(CartesianChartDefinition) error {
	return nil
}

func (u *VizDefinition) ChecklistNoopSuccess(ChecklistChartDefinition) error {
	return nil
}

func (u *VizDefinition) FrequencyNoopSuccess(FrequencyChartDefinition) error {
	return nil
}

func (u *VizDefinition) GeoNoopSuccess(GeoVizDefinition) error {
	return nil
}

func (u *VizDefinition) Geo3dNoopSuccess(Geo3dDefinition) error {
	return nil
}

func (u *VizDefinition) HistogramNoopSuccess(HistogramChartDefinition) error {
	return nil
}

func (u *VizDefinition) LogNoopSuccess(LogPanelDefinition) error {
	return nil
}

func (u *VizDefinition) PlotlyNoopSuccess(PlotlyPanelDefinition) error {
	return nil
}

func (u *VizDefinition) TimeSeriesNoopSuccess(TimeSeriesChartDefinition) error {
	return nil
}

func (u *VizDefinition) ValueTableNoopSuccess(ValueTableDefinition) error {
	return nil
}

func (u *VizDefinition) VideoNoopSuccess(VideoVizDefinition) error {
	return nil
}

func (u *VizDefinition) ProcedureNoopSuccess(ProcedureVizDefinition) error {
	return nil
}

func (u *VizDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VizDefinition) Accept(v VizDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(*u.cartesian)
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
		return v.VisitChecklist(*u.checklist)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequency(*u.frequency)
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
		return v.VisitGeo(*u.geo)
	case "geo3d":
		if u.geo3d == nil {
			return fmt.Errorf("field \"geo3d\" is required")
		}
		return v.VisitGeo3d(*u.geo3d)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogram(*u.histogram)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(*u.log)
	case "plotly":
		if u.plotly == nil {
			return fmt.Errorf("field \"plotly\" is required")
		}
		return v.VisitPlotly(*u.plotly)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeries(*u.timeSeries)
	case "valueTable":
		if u.valueTable == nil {
			return fmt.Errorf("field \"valueTable\" is required")
		}
		return v.VisitValueTable(*u.valueTable)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(*u.video)
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
		return v.VisitProcedure(*u.procedure)
	}
}

type VizDefinitionVisitor interface {
	VisitCartesian(v CartesianChartDefinition) error
	VisitChecklist(v ChecklistChartDefinition) error
	VisitFrequency(v FrequencyChartDefinition) error
	VisitGeo(v GeoVizDefinition) error
	VisitGeo3d(v Geo3dDefinition) error
	VisitHistogram(v HistogramChartDefinition) error
	VisitLog(v LogPanelDefinition) error
	VisitPlotly(v PlotlyPanelDefinition) error
	VisitTimeSeries(v TimeSeriesChartDefinition) error
	VisitValueTable(v ValueTableDefinition) error
	VisitVideo(v VideoVizDefinition) error
	VisitProcedure(v ProcedureVizDefinition) error
	VisitUnknown(typeName string) error
}

func (u *VizDefinition) AcceptWithContext(ctx context.Context, v VizDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesianWithContext(ctx, *u.cartesian)
	case "checklist":
		if u.checklist == nil {
			return fmt.Errorf("field \"checklist\" is required")
		}
		return v.VisitChecklistWithContext(ctx, *u.checklist)
	case "frequency":
		if u.frequency == nil {
			return fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequencyWithContext(ctx, *u.frequency)
	case "geo":
		if u.geo == nil {
			return fmt.Errorf("field \"geo\" is required")
		}
		return v.VisitGeoWithContext(ctx, *u.geo)
	case "geo3d":
		if u.geo3d == nil {
			return fmt.Errorf("field \"geo3d\" is required")
		}
		return v.VisitGeo3dWithContext(ctx, *u.geo3d)
	case "histogram":
		if u.histogram == nil {
			return fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogramWithContext(ctx, *u.histogram)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLogWithContext(ctx, *u.log)
	case "plotly":
		if u.plotly == nil {
			return fmt.Errorf("field \"plotly\" is required")
		}
		return v.VisitPlotlyWithContext(ctx, *u.plotly)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeriesWithContext(ctx, *u.timeSeries)
	case "valueTable":
		if u.valueTable == nil {
			return fmt.Errorf("field \"valueTable\" is required")
		}
		return v.VisitValueTableWithContext(ctx, *u.valueTable)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideoWithContext(ctx, *u.video)
	case "procedure":
		if u.procedure == nil {
			return fmt.Errorf("field \"procedure\" is required")
		}
		return v.VisitProcedureWithContext(ctx, *u.procedure)
	}
}

type VizDefinitionVisitorWithContext interface {
	VisitCartesianWithContext(ctx context.Context, v CartesianChartDefinition) error
	VisitChecklistWithContext(ctx context.Context, v ChecklistChartDefinition) error
	VisitFrequencyWithContext(ctx context.Context, v FrequencyChartDefinition) error
	VisitGeoWithContext(ctx context.Context, v GeoVizDefinition) error
	VisitGeo3dWithContext(ctx context.Context, v Geo3dDefinition) error
	VisitHistogramWithContext(ctx context.Context, v HistogramChartDefinition) error
	VisitLogWithContext(ctx context.Context, v LogPanelDefinition) error
	VisitPlotlyWithContext(ctx context.Context, v PlotlyPanelDefinition) error
	VisitTimeSeriesWithContext(ctx context.Context, v TimeSeriesChartDefinition) error
	VisitValueTableWithContext(ctx context.Context, v ValueTableDefinition) error
	VisitVideoWithContext(ctx context.Context, v VideoVizDefinition) error
	VisitProcedureWithContext(ctx context.Context, v ProcedureVizDefinition) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVizDefinitionFromCartesian(v CartesianChartDefinition) VizDefinition {
	return VizDefinition{typ: "cartesian", cartesian: &v}
}

func NewVizDefinitionFromChecklist(v ChecklistChartDefinition) VizDefinition {
	return VizDefinition{typ: "checklist", checklist: &v}
}

func NewVizDefinitionFromFrequency(v FrequencyChartDefinition) VizDefinition {
	return VizDefinition{typ: "frequency", frequency: &v}
}

func NewVizDefinitionFromGeo(v GeoVizDefinition) VizDefinition {
	return VizDefinition{typ: "geo", geo: &v}
}

func NewVizDefinitionFromGeo3d(v Geo3dDefinition) VizDefinition {
	return VizDefinition{typ: "geo3d", geo3d: &v}
}

func NewVizDefinitionFromHistogram(v HistogramChartDefinition) VizDefinition {
	return VizDefinition{typ: "histogram", histogram: &v}
}

func NewVizDefinitionFromLog(v LogPanelDefinition) VizDefinition {
	return VizDefinition{typ: "log", log: &v}
}

func NewVizDefinitionFromPlotly(v PlotlyPanelDefinition) VizDefinition {
	return VizDefinition{typ: "plotly", plotly: &v}
}

func NewVizDefinitionFromTimeSeries(v TimeSeriesChartDefinition) VizDefinition {
	return VizDefinition{typ: "timeSeries", timeSeries: &v}
}

func NewVizDefinitionFromValueTable(v ValueTableDefinition) VizDefinition {
	return VizDefinition{typ: "valueTable", valueTable: &v}
}

func NewVizDefinitionFromVideo(v VideoVizDefinition) VizDefinition {
	return VizDefinition{typ: "video", video: &v}
}

func NewVizDefinitionFromProcedure(v ProcedureVizDefinition) VizDefinition {
	return VizDefinition{typ: "procedure", procedure: &v}
}
