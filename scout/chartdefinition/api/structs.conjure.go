// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/scout/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/channelvariables/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/comparisonrun/api"
	api3 "github.com/nominal-io/nominal-api-go/scout/compute/api"
	api4 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	api5 "github.com/nominal-io/nominal-api-go/scout/run/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
)

// This option indicates that disconnected values will always be connected with a line.
type AlwaysConnectDisconnectedValues struct{}

func (o AlwaysConnectDisconnectedValues) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AlwaysConnectDisconnectedValues) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AxisDisplayOptions struct {
	ShowTitle bool     `json:"showTitle"`
	AxisWidth *float64 `json:"axisWidth,omitempty"`
	// The scale type of the axis. If not specified, the default is LINEAR.
	ScaleType *AxisScaleType `conjure-docs:"The scale type of the axis. If not specified, the default is LINEAR." json:"scaleType,omitempty"`
}

func (o AxisDisplayOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AxisDisplayOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AxisRange struct {
	Start *float64 `json:"start,omitempty"`
	End   *float64 `json:"end,omitempty"`
}

func (o AxisRange) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AxisRange) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AxisThresholdVisualization struct {
	AxisId AxisId `json:"axisId"`
	// Determines it's current visibility in the time series chart.
	Visibility bool               `conjure-docs:"Determines it's current visibility in the time series chart." json:"visibility"`
	Thresholds AxisThresholdGroup `json:"thresholds"`
}

func (o AxisThresholdVisualization) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AxisThresholdVisualization) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The settings for a bit flag mapping. Each position should be unique. Position 0 represents the least significant bit
and position 31 represents the most significant bit.
*/
type BitFlag struct {
	Position int    `json:"position"`
	Label    string `json:"label"`
}

func (o BitFlag) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitFlag) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BitFlagMapCellConfig struct {
	Visualisation *BitFlagMapVisualisation `json:"visualisation,omitempty"`
}

func (o BitFlagMapCellConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitFlagMapCellConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The settings for a raw bit flag map visualisation.
type BitFlagMapRawVisualisation struct {
	// The color when any bit is high
	HighColor *api.HexColor `conjure-docs:"The color when any bit is high" json:"highColor,omitempty"`
	// The color when all bits are low
	LowColor *api.HexColor `conjure-docs:"The color when all bits are low" json:"lowColor,omitempty"`
	BitFlags []BitFlag     `json:"bitFlags"`
}

func (o BitFlagMapRawVisualisation) MarshalJSON() ([]byte, error) {
	if o.BitFlags == nil {
		o.BitFlags = make([]BitFlag, 0)
	}
	type _tmpBitFlagMapRawVisualisation BitFlagMapRawVisualisation
	return safejson.Marshal(_tmpBitFlagMapRawVisualisation(o))
}

func (o *BitFlagMapRawVisualisation) UnmarshalJSON(data []byte) error {
	type _tmpBitFlagMapRawVisualisation BitFlagMapRawVisualisation
	var rawBitFlagMapRawVisualisation _tmpBitFlagMapRawVisualisation
	if err := safejson.Unmarshal(data, &rawBitFlagMapRawVisualisation); err != nil {
		return err
	}
	if rawBitFlagMapRawVisualisation.BitFlags == nil {
		rawBitFlagMapRawVisualisation.BitFlags = make([]BitFlag, 0)
	}
	*o = BitFlagMapRawVisualisation(rawBitFlagMapRawVisualisation)
	return nil
}

func (o BitFlagMapRawVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BitFlagMapRawVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CartesianChartDefinitionV1 struct {
	Plots []CartesianPlot `json:"plots"`
	// Deprecated: Please use the workbook's eventRefs field instead.
	Events              *[]Event                  `json:"events,omitempty"`
	ComparisonRunGroups []api1.ComparisonRunGroup `json:"comparisonRunGroups"`
	Title               *string                   `json:"title,omitempty"`
	ValueAxes           []ValueAxis               `json:"valueAxes"`
	// If toggled true, will visually connect the points of the series
	ConnectPoints *bool `conjure-docs:"If toggled true, will visually connect the points of the series" json:"connectPoints,omitempty"`
}

func (o CartesianChartDefinitionV1) MarshalJSON() ([]byte, error) {
	if o.Plots == nil {
		o.Plots = make([]CartesianPlot, 0)
	}
	if o.ComparisonRunGroups == nil {
		o.ComparisonRunGroups = make([]api1.ComparisonRunGroup, 0)
	}
	if o.ValueAxes == nil {
		o.ValueAxes = make([]ValueAxis, 0)
	}
	type _tmpCartesianChartDefinitionV1 CartesianChartDefinitionV1
	return safejson.Marshal(_tmpCartesianChartDefinitionV1(o))
}

func (o *CartesianChartDefinitionV1) UnmarshalJSON(data []byte) error {
	type _tmpCartesianChartDefinitionV1 CartesianChartDefinitionV1
	var rawCartesianChartDefinitionV1 _tmpCartesianChartDefinitionV1
	if err := safejson.Unmarshal(data, &rawCartesianChartDefinitionV1); err != nil {
		return err
	}
	if rawCartesianChartDefinitionV1.Plots == nil {
		rawCartesianChartDefinitionV1.Plots = make([]CartesianPlot, 0)
	}
	if rawCartesianChartDefinitionV1.ComparisonRunGroups == nil {
		rawCartesianChartDefinitionV1.ComparisonRunGroups = make([]api1.ComparisonRunGroup, 0)
	}
	if rawCartesianChartDefinitionV1.ValueAxes == nil {
		rawCartesianChartDefinitionV1.ValueAxes = make([]ValueAxis, 0)
	}
	*o = CartesianChartDefinitionV1(rawCartesianChartDefinitionV1)
	return nil
}

func (o CartesianChartDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CartesianChartDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CartesianPlot struct {
	XVariableName api2.ChannelVariableName `json:"xVariableName"`
	YVariableName api2.ChannelVariableName `json:"yVariableName"`
	Enabled       *bool                    `json:"enabled,omitempty"`
	XAxisId       AxisId                   `json:"xAxisId"`
	YAxisId       AxisId                   `json:"yAxisId"`
	Color         api.HexColor             `json:"color"`
}

func (o CartesianPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CartesianPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChecklistChartDefinitionV1 struct {
	SelectedChecklistRids []string `json:"selectedChecklistRids"`
	Title                 *string  `json:"title,omitempty"`
}

func (o ChecklistChartDefinitionV1) MarshalJSON() ([]byte, error) {
	if o.SelectedChecklistRids == nil {
		o.SelectedChecklistRids = make([]string, 0)
	}
	type _tmpChecklistChartDefinitionV1 ChecklistChartDefinitionV1
	return safejson.Marshal(_tmpChecklistChartDefinitionV1(o))
}

func (o *ChecklistChartDefinitionV1) UnmarshalJSON(data []byte) error {
	type _tmpChecklistChartDefinitionV1 ChecklistChartDefinitionV1
	var rawChecklistChartDefinitionV1 _tmpChecklistChartDefinitionV1
	if err := safejson.Unmarshal(data, &rawChecklistChartDefinitionV1); err != nil {
		return err
	}
	if rawChecklistChartDefinitionV1.SelectedChecklistRids == nil {
		rawChecklistChartDefinitionV1.SelectedChecklistRids = make([]string, 0)
	}
	*o = ChecklistChartDefinitionV1(rawChecklistChartDefinitionV1)
	return nil
}

func (o ChecklistChartDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChecklistChartDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DefaultFill struct {
	Color api.HexColor `json:"color"`
}

func (o DefaultFill) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DefaultFill) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumCellConfig struct {
	Visualisation *EnumValueVisualisation `json:"visualisation,omitempty"`
	/*
	   Sorting configuration for grouped data rendering in a cell.
	   If undefined, will sort alphabetically by grouping.
	*/
	GroupBySort *EnumGroupBySort `conjure-docs:"Sorting configuration for grouped data rendering in a cell.\nIf undefined, will sort alphabetically by grouping." json:"groupBySort,omitempty"`
}

func (o EnumCellConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumCellConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumGroupBySortCustom struct {
	/*
	   Specify the values in the order they should appear.
	   Unspecified values will be sorted to the bottom.
	*/
	Order []string `conjure-docs:"Specify the values in the order they should appear.\nUnspecified values will be sorted to the bottom." json:"order"`
}

func (o EnumGroupBySortCustom) MarshalJSON() ([]byte, error) {
	if o.Order == nil {
		o.Order = make([]string, 0)
	}
	type _tmpEnumGroupBySortCustom EnumGroupBySortCustom
	return safejson.Marshal(_tmpEnumGroupBySortCustom(o))
}

func (o *EnumGroupBySortCustom) UnmarshalJSON(data []byte) error {
	type _tmpEnumGroupBySortCustom EnumGroupBySortCustom
	var rawEnumGroupBySortCustom _tmpEnumGroupBySortCustom
	if err := safejson.Unmarshal(data, &rawEnumGroupBySortCustom); err != nil {
		return err
	}
	if rawEnumGroupBySortCustom.Order == nil {
		rawEnumGroupBySortCustom.Order = make([]string, 0)
	}
	*o = EnumGroupBySortCustom(rawEnumGroupBySortCustom)
	return nil
}

func (o EnumGroupBySortCustom) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumGroupBySortCustom) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The settings for a raw enum visualisation.
type EnumRawVisualisation struct {
	ColorMap *map[string]api.HexColor `json:"colorMap,omitempty"`
}

func (o EnumRawVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumRawVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnumValueChannel struct {
	VariableName  api2.ChannelVariableName `json:"variableName"`
	Visualisation EnumValueVisualisation   `json:"visualisation"`
}

func (o EnumValueChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnumValueChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Event struct {
	DisplayName *string   `json:"displayName,omitempty"`
	EventUuid   uuid.UUID `json:"eventUuid"`
	IsPinned    bool      `json:"isPinned"`
}

func (o Event) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Event) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The root figure definition for a plotly instance
type Figure struct {
	Data   []Trace `json:"data"`
	Layout Layout  `json:"layout"`
	/*
	   The json config definition according to plotly's schema
	   https://plotly.com/python/figure-structure/#the-toplevel-config-attribute
	*/
	PlotlyConfig string `conjure-docs:"The json config definition according to plotly's schema\nhttps://plotly.com/python/figure-structure/#the-toplevel-config-attribute" json:"plotlyConfig"`
}

func (o Figure) MarshalJSON() ([]byte, error) {
	if o.Data == nil {
		o.Data = make([]Trace, 0)
	}
	type _tmpFigure Figure
	return safejson.Marshal(_tmpFigure(o))
}

func (o *Figure) UnmarshalJSON(data []byte) error {
	type _tmpFigure Figure
	var rawFigure _tmpFigure
	if err := safejson.Unmarshal(data, &rawFigure); err != nil {
		return err
	}
	if rawFigure.Data == nil {
		rawFigure.Data = make([]Trace, 0)
	}
	*o = Figure(rawFigure)
	return nil
}

func (o Figure) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Figure) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FrequencyChartDefinitionV1 struct {
	Plots []FrequencyPlot `json:"plots"`
	// Deprecated: Please use the workbook's eventRefs field instead.
	Events              *[]Event                  `json:"events,omitempty"`
	ComparisonRunGroups []api1.ComparisonRunGroup `json:"comparisonRunGroups"`
	Title               *string                   `json:"title,omitempty"`
	ValueAxes           []ValueAxis               `json:"valueAxes"`
}

func (o FrequencyChartDefinitionV1) MarshalJSON() ([]byte, error) {
	if o.Plots == nil {
		o.Plots = make([]FrequencyPlot, 0)
	}
	if o.ComparisonRunGroups == nil {
		o.ComparisonRunGroups = make([]api1.ComparisonRunGroup, 0)
	}
	if o.ValueAxes == nil {
		o.ValueAxes = make([]ValueAxis, 0)
	}
	type _tmpFrequencyChartDefinitionV1 FrequencyChartDefinitionV1
	return safejson.Marshal(_tmpFrequencyChartDefinitionV1(o))
}

func (o *FrequencyChartDefinitionV1) UnmarshalJSON(data []byte) error {
	type _tmpFrequencyChartDefinitionV1 FrequencyChartDefinitionV1
	var rawFrequencyChartDefinitionV1 _tmpFrequencyChartDefinitionV1
	if err := safejson.Unmarshal(data, &rawFrequencyChartDefinitionV1); err != nil {
		return err
	}
	if rawFrequencyChartDefinitionV1.Plots == nil {
		rawFrequencyChartDefinitionV1.Plots = make([]FrequencyPlot, 0)
	}
	if rawFrequencyChartDefinitionV1.ComparisonRunGroups == nil {
		rawFrequencyChartDefinitionV1.ComparisonRunGroups = make([]api1.ComparisonRunGroup, 0)
	}
	if rawFrequencyChartDefinitionV1.ValueAxes == nil {
		rawFrequencyChartDefinitionV1.ValueAxes = make([]ValueAxis, 0)
	}
	*o = FrequencyChartDefinitionV1(rawFrequencyChartDefinitionV1)
	return nil
}

func (o FrequencyChartDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FrequencyChartDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FrequencyPlot struct {
	VariableName api2.ChannelVariableName `json:"variableName"`
	Enabled      *bool                    `json:"enabled,omitempty"`
	YAxisId      AxisId                   `json:"yAxisId"`
	Color        api.HexColor             `json:"color"`
	LineStyle    LineStyle                `json:"lineStyle"`
}

func (o FrequencyPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FrequencyPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Geo3dCustomModel struct {
	AttachmentRid rids.AttachmentRid `json:"attachmentRid"`
	FileExtension string             `json:"fileExtension"`
}

func (o Geo3dCustomModel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Geo3dCustomModel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Geo3dDefinitionV1 struct {
	Plots []GeoPlot3d `json:"plots"`
	Title *string     `json:"title,omitempty"`
}

func (o Geo3dDefinitionV1) MarshalJSON() ([]byte, error) {
	if o.Plots == nil {
		o.Plots = make([]GeoPlot3d, 0)
	}
	type _tmpGeo3dDefinitionV1 Geo3dDefinitionV1
	return safejson.Marshal(_tmpGeo3dDefinitionV1(o))
}

func (o *Geo3dDefinitionV1) UnmarshalJSON(data []byte) error {
	type _tmpGeo3dDefinitionV1 Geo3dDefinitionV1
	var rawGeo3dDefinitionV1 _tmpGeo3dDefinitionV1
	if err := safejson.Unmarshal(data, &rawGeo3dDefinitionV1); err != nil {
		return err
	}
	if rawGeo3dDefinitionV1.Plots == nil {
		rawGeo3dDefinitionV1.Plots = make([]GeoPlot3d, 0)
	}
	*o = Geo3dDefinitionV1(rawGeo3dDefinitionV1)
	return nil
}

func (o Geo3dDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Geo3dDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Geo3dOrientationPrincipalAxes struct {
	HeadingVariableName *api2.ChannelVariableName `json:"headingVariableName,omitempty"`
	PitchVariableName   *api2.ChannelVariableName `json:"pitchVariableName,omitempty"`
	RollVariableName    *api2.ChannelVariableName `json:"rollVariableName,omitempty"`
}

func (o Geo3dOrientationPrincipalAxes) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Geo3dOrientationPrincipalAxes) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Geo3dPositionWgs84 struct {
	LatitudeVariableName  api2.ChannelVariableName  `json:"latitudeVariableName"`
	LongitudeVariableName api2.ChannelVariableName  `json:"longitudeVariableName"`
	HeightVariableName    *api2.ChannelVariableName `json:"heightVariableName,omitempty"`
}

func (o Geo3dPositionWgs84) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Geo3dPositionWgs84) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GeoAdditionalVariable struct {
	VariableName        api2.ChannelVariableName             `json:"variableName"`
	Label               *string                              `json:"label,omitempty"`
	VisualizationOption *GeoSecondaryPlotVisualizationOption `json:"visualizationOption,omitempty"`
}

func (o GeoAdditionalVariable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeoAdditionalVariable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GeoPlot3d struct {
	PlotId               string                        `json:"plotId"`
	Enabled              *bool                         `json:"enabled,omitempty"`
	Label                *string                       `json:"label,omitempty"`
	VisualizationOptions GeoPlot3dVisualizationOptions `json:"visualizationOptions"`
	Position             Geo3dPosition                 `json:"position"`
	Orientation          Geo3dOrientation              `json:"orientation"`
}

func (o GeoPlot3d) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeoPlot3d) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GeoPlot3dVisualizationOptions struct {
	Color     api.HexColor   `json:"color"`
	LineStyle GeoLine3dStyle `json:"lineStyle"`
	Model     *Geo3dModel    `json:"model,omitempty"`
}

func (o GeoPlot3dVisualizationOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeoPlot3dVisualizationOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GeoPlotFromLatLong struct {
	LatitudeVariableName  api2.ChannelVariableName `json:"latitudeVariableName"`
	LongitudeVariableName api2.ChannelVariableName `json:"longitudeVariableName"`
	// optional for backcompatibility
	SecondaryVariables   *[]GeoAdditionalVariable    `conjure-docs:"optional for backcompatibility" json:"secondaryVariables,omitempty"`
	Enabled              *bool                       `json:"enabled,omitempty"`
	Label                *string                     `json:"label,omitempty"`
	VisualizationOptions GeoPlotVisualizationOptions `json:"visualizationOptions"`
}

func (o GeoPlotFromLatLong) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeoPlotFromLatLong) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GeoPlotSecondaryVisibilityConfig struct {
	Visible      bool                      `json:"visible"`
	VariableName *api2.ChannelVariableName `json:"variableName,omitempty"`
}

func (o GeoPlotSecondaryVisibilityConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeoPlotSecondaryVisibilityConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GeoPlotVisualizationOptions struct {
	Color     api.HexColor `json:"color"`
	LineStyle GeoLineStyle `json:"lineStyle"`
	// If visible, overwrites any existing visualization options on the geo plot.
	SecondaryColorVisualization *GeoPlotSecondaryVisibilityConfig `conjure-docs:"If visible, overwrites any existing visualization options on the geo plot." json:"secondaryColorVisualization,omitempty"`
}

func (o GeoPlotVisualizationOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeoPlotVisualizationOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A static coordinate on the map
type GeoPoint struct {
	Label     *string                 `json:"label,omitempty"`
	Icon      string                  `json:"icon"`
	Latitude  float64                 `json:"latitude"`
	Longitude float64                 `json:"longitude"`
	Variables []GeoAdditionalVariable `json:"variables"`
}

func (o GeoPoint) MarshalJSON() ([]byte, error) {
	if o.Variables == nil {
		o.Variables = make([]GeoAdditionalVariable, 0)
	}
	type _tmpGeoPoint GeoPoint
	return safejson.Marshal(_tmpGeoPoint(o))
}

func (o *GeoPoint) UnmarshalJSON(data []byte) error {
	type _tmpGeoPoint GeoPoint
	var rawGeoPoint _tmpGeoPoint
	if err := safejson.Unmarshal(data, &rawGeoPoint); err != nil {
		return err
	}
	if rawGeoPoint.Variables == nil {
		rawGeoPoint.Variables = make([]GeoAdditionalVariable, 0)
	}
	*o = GeoPoint(rawGeoPoint)
	return nil
}

func (o GeoPoint) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeoPoint) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GeoVizDefinitionV1 struct {
	Plots             []GeoPlotFromLatLong  `json:"plots"`
	Title             *string               `json:"title,omitempty"`
	CustomFeatures    []GeoCustomFeature    `json:"customFeatures"`
	BaseTileset       *GeoBaseTileset       `json:"baseTileset,omitempty"`
	AdditionalTileset *GeoAdditionalTileset `json:"additionalTileset,omitempty"`
}

func (o GeoVizDefinitionV1) MarshalJSON() ([]byte, error) {
	if o.Plots == nil {
		o.Plots = make([]GeoPlotFromLatLong, 0)
	}
	if o.CustomFeatures == nil {
		o.CustomFeatures = make([]GeoCustomFeature, 0)
	}
	type _tmpGeoVizDefinitionV1 GeoVizDefinitionV1
	return safejson.Marshal(_tmpGeoVizDefinitionV1(o))
}

func (o *GeoVizDefinitionV1) UnmarshalJSON(data []byte) error {
	type _tmpGeoVizDefinitionV1 GeoVizDefinitionV1
	var rawGeoVizDefinitionV1 _tmpGeoVizDefinitionV1
	if err := safejson.Unmarshal(data, &rawGeoVizDefinitionV1); err != nil {
		return err
	}
	if rawGeoVizDefinitionV1.Plots == nil {
		rawGeoVizDefinitionV1.Plots = make([]GeoPlotFromLatLong, 0)
	}
	if rawGeoVizDefinitionV1.CustomFeatures == nil {
		rawGeoVizDefinitionV1.CustomFeatures = make([]GeoCustomFeature, 0)
	}
	*o = GeoVizDefinitionV1(rawGeoVizDefinitionV1)
	return nil
}

func (o GeoVizDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeoVizDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HistogramChartDefinitionV1 struct {
	Plots                 []HistogramPlot                      `json:"plots"`
	Title                 *string                              `json:"title,omitempty"`
	DisplaySettings       HistogramDisplaySettings             `json:"displaySettings"`
	NumericBucketStrategy *api3.NumericHistogramBucketStrategy `json:"numericBucketStrategy,omitempty"`
	ValueAxis             *ValueAxis                           `json:"valueAxis,omitempty"`
}

func (o HistogramChartDefinitionV1) MarshalJSON() ([]byte, error) {
	if o.Plots == nil {
		o.Plots = make([]HistogramPlot, 0)
	}
	type _tmpHistogramChartDefinitionV1 HistogramChartDefinitionV1
	return safejson.Marshal(_tmpHistogramChartDefinitionV1(o))
}

func (o *HistogramChartDefinitionV1) UnmarshalJSON(data []byte) error {
	type _tmpHistogramChartDefinitionV1 HistogramChartDefinitionV1
	var rawHistogramChartDefinitionV1 _tmpHistogramChartDefinitionV1
	if err := safejson.Unmarshal(data, &rawHistogramChartDefinitionV1); err != nil {
		return err
	}
	if rawHistogramChartDefinitionV1.Plots == nil {
		rawHistogramChartDefinitionV1.Plots = make([]HistogramPlot, 0)
	}
	*o = HistogramChartDefinitionV1(rawHistogramChartDefinitionV1)
	return nil
}

func (o HistogramChartDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramChartDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HistogramDisplaySettings struct {
	Stacked bool               `json:"stacked"`
	Sort    HistogramSortOrder `json:"sort"`
}

func (o HistogramDisplaySettings) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramDisplaySettings) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HistogramPlot struct {
	VariableName api2.ChannelVariableName `json:"variableName"`
	Enabled      *bool                    `json:"enabled,omitempty"`
	Color        api.HexColor             `json:"color"`
}

func (o HistogramPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Layout struct {
	/*
	   The json layout definition according to plotly's schema
	   https://plotly.com/python/figure-structure/#the-toplevel-layout-attribute
	*/
	PlotlyLayout string `conjure-docs:"The json layout definition according to plotly's schema\nhttps://plotly.com/python/figure-structure/#the-toplevel-layout-attribute" json:"plotlyLayout"`
}

func (o Layout) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Layout) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LineThreshold struct {
	Value     float64            `json:"value"`
	Label     *string            `json:"label,omitempty"`
	Color     api.HexColor       `json:"color"`
	LineStyle ThresholdLineStyle `json:"lineStyle"`
}

func (o LineThreshold) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LineThreshold) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Line thresholds are used to mark values or demarcate regions along a single axis.
type LineThresholdGroup struct {
	ShadingConfig ThresholdShadingConfig `json:"shadingConfig"`
	Lines         []LineThreshold        `json:"lines"`
	/*
	   To supplement a set of line thresholds, the default fill configures how the remaining space (either
	   above or below) should be colored. Transparent if empty.
	*/
	DefaultFill *DefaultFill `conjure-docs:"To supplement a set of line thresholds, the default fill configures how the remaining space (either\nabove or below) should be colored. Transparent if empty." json:"defaultFill,omitempty"`
}

func (o LineThresholdGroup) MarshalJSON() ([]byte, error) {
	if o.Lines == nil {
		o.Lines = make([]LineThreshold, 0)
	}
	type _tmpLineThresholdGroup LineThresholdGroup
	return safejson.Marshal(_tmpLineThresholdGroup(o))
}

func (o *LineThresholdGroup) UnmarshalJSON(data []byte) error {
	type _tmpLineThresholdGroup LineThresholdGroup
	var rawLineThresholdGroup _tmpLineThresholdGroup
	if err := safejson.Unmarshal(data, &rawLineThresholdGroup); err != nil {
		return err
	}
	if rawLineThresholdGroup.Lines == nil {
		rawLineThresholdGroup.Lines = make([]LineThreshold, 0)
	}
	*o = LineThresholdGroup(rawLineThresholdGroup)
	return nil
}

func (o LineThresholdGroup) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LineThresholdGroup) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A field to save additional column names on log panels with support for multiple variables
type LogChannel struct {
	LogChannelVariableName api2.ChannelVariableName `json:"logChannelVariableName"`
	VisibleLogColumnNames  []LogColumnName          `json:"visibleLogColumnNames"`
	TagFilters             LogTagFilter             `json:"tagFilters"`
}

func (o LogChannel) MarshalJSON() ([]byte, error) {
	if o.VisibleLogColumnNames == nil {
		o.VisibleLogColumnNames = make([]LogColumnName, 0)
	}
	if o.TagFilters == nil {
		o.TagFilters = make(map[string][]string, 0)
	}
	type _tmpLogChannel LogChannel
	return safejson.Marshal(_tmpLogChannel(o))
}

func (o *LogChannel) UnmarshalJSON(data []byte) error {
	type _tmpLogChannel LogChannel
	var rawLogChannel _tmpLogChannel
	if err := safejson.Unmarshal(data, &rawLogChannel); err != nil {
		return err
	}
	if rawLogChannel.VisibleLogColumnNames == nil {
		rawLogChannel.VisibleLogColumnNames = make([]LogColumnName, 0)
	}
	if rawLogChannel.TagFilters == nil {
		rawLogChannel.TagFilters = make(map[string][]string, 0)
	}
	*o = LogChannel(rawLogChannel)
	return nil
}

func (o LogChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogPanelDefinitionV1 struct {
	Title         *string                    `json:"title,omitempty"`
	LogChannels   []api2.ChannelVariableName `json:"logChannels"`
	LogChannelsV2 *[]LogChannel              `json:"logChannelsV2,omitempty"`
}

func (o LogPanelDefinitionV1) MarshalJSON() ([]byte, error) {
	if o.LogChannels == nil {
		o.LogChannels = make([]api2.ChannelVariableName, 0)
	}
	type _tmpLogPanelDefinitionV1 LogPanelDefinitionV1
	return safejson.Marshal(_tmpLogPanelDefinitionV1(o))
}

func (o *LogPanelDefinitionV1) UnmarshalJSON(data []byte) error {
	type _tmpLogPanelDefinitionV1 LogPanelDefinitionV1
	var rawLogPanelDefinitionV1 _tmpLogPanelDefinitionV1
	if err := safejson.Unmarshal(data, &rawLogPanelDefinitionV1); err != nil {
		return err
	}
	if rawLogPanelDefinitionV1.LogChannels == nil {
		rawLogPanelDefinitionV1.LogChannels = make([]api2.ChannelVariableName, 0)
	}
	*o = LogPanelDefinitionV1(rawLogPanelDefinitionV1)
	return nil
}

func (o LogPanelDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogPanelDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// This option indicates that disconnected values are never connected with a line.
type NeverConnectDisconnectedValues struct{}

func (o NeverConnectDisconnectedValues) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NeverConnectDisconnectedValues) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Number format for numeric cells, eg 1e4 | 10000 | 10,000.
type NumberFormat struct {
	SigFigs            *int                       `json:"sigFigs,omitempty"`
	DisplayOption      *NumberFormatDisplayOption `json:"displayOption,omitempty"`
	FixedDecimalPlaces *int                       `json:"fixedDecimalPlaces,omitempty"`
}

func (o NumberFormat) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumberFormat) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The settings for a bar gauge visualisation.
type NumericBarGaugeVisualisation struct {
	LowThreshold  float64 `json:"lowThreshold"`
	HighThreshold float64 `json:"highThreshold"`
}

func (o NumericBarGaugeVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericBarGaugeVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A numeric visualisation that will fill the cell from left to right with a colored background
representing where the value falls inside a set range.
The lowest and highest values in the thresholds determine the start and end of the range.
Middle threshold values will still affect the cell's coloration.
*/
type NumericBarVisualisationV2 struct {
	/*
	   Modifies the visualisation based on the highest threshold value that
	   the computed value equals or surpasses. The lowest and highest value will determine
	   the 0% and 100% values of the bar.
	*/
	Thresholds *[]Threshold `conjure-docs:"Modifies the visualisation based on the highest threshold value that\nthe computed value equals or surpasses. The lowest and highest value will determine\nthe 0% and 100% values of the bar." json:"thresholds,omitempty"`
}

func (o NumericBarVisualisationV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericBarVisualisationV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericCellConfig struct {
	Visualisation *NumericValueVisualisationV2 `json:"visualisation,omitempty"`
	NumberFormat  *NumberFormat                `json:"numberFormat,omitempty"`
	/*
	   Sorting configuration for grouped data rendering in a cell.
	   If undefined, will sort alphabetically by grouping.
	*/
	GroupBySort *NumericGroupBySort `conjure-docs:"Sorting configuration for grouped data rendering in a cell.\nIf undefined, will sort alphabetically by grouping." json:"groupBySort,omitempty"`
}

func (o NumericCellConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericCellConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericRawVisualisation struct{}

func (o NumericRawVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericRawVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A raw numeric visualisation with optional coloring based on numeric thresholds.
type NumericRawVisualisationV2 struct {
	/*
	   Modifies the visualisation based on the highest threshold value that
	   the computed value surpasses.
	*/
	Thresholds *[]Threshold `conjure-docs:"Modifies the visualisation based on the highest threshold value that\nthe computed value surpasses." json:"thresholds,omitempty"`
}

func (o NumericRawVisualisationV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericRawVisualisationV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NumericValueChannel struct {
	VariableName  api2.ChannelVariableName  `json:"variableName"`
	Visualisation NumericValueVisualisation `json:"visualisation"`
}

func (o NumericValueChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NumericValueChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PersistAll struct{}

func (o PersistAll) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PersistAll) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PersistByValue struct {
	Values []string `json:"values"`
}

func (o PersistByValue) MarshalJSON() ([]byte, error) {
	if o.Values == nil {
		o.Values = make([]string, 0)
	}
	type _tmpPersistByValue PersistByValue
	return safejson.Marshal(_tmpPersistByValue(o))
}

func (o *PersistByValue) UnmarshalJSON(data []byte) error {
	type _tmpPersistByValue PersistByValue
	var rawPersistByValue _tmpPersistByValue
	if err := safejson.Unmarshal(data, &rawPersistByValue); err != nil {
		return err
	}
	if rawPersistByValue.Values == nil {
		rawPersistByValue.Values = make([]string, 0)
	}
	*o = PersistByValue(rawPersistByValue)
	return nil
}

func (o PersistByValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PersistByValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PlotlyPanelDefinitionV1 struct {
	Title *string `json:"title,omitempty"`
	// A preset that will render a nominal-defined plotly figure with minimum necessary inputs
	Preset *PlotlyPreset `conjure-docs:"A preset that will render a nominal-defined plotly figure with minimum necessary inputs" json:"preset,omitempty"`
	// The plotly instance definition, with extra fields for nominal-specific inputs
	Figure Figure `conjure-docs:"The plotly instance definition, with extra fields for nominal-specific inputs" json:"figure"`
}

func (o PlotlyPanelDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PlotlyPanelDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ProcedureVizDefinitionV1 struct {
	Title        *string                     `json:"title,omitempty"`
	ExecutionRid *api4.ProcedureExecutionRid `json:"executionRid,omitempty"`
}

func (o ProcedureVizDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ProcedureVizDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RangeCellConfig struct {
	Visualisation *RangeValueVisualisation `json:"visualisation,omitempty"`
	/*
	   Sorting configuration for grouped data rendering in a cell.
	   If undefined, will sort alphabetically by grouping.
	*/
	GroupBySort *RangeGroupBySort `conjure-docs:"Sorting configuration for grouped data rendering in a cell.\nIf undefined, will sort alphabetically by grouping." json:"groupBySort,omitempty"`
}

func (o RangeCellConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangeCellConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The settings for a raw range visualisation.
type RangeRawVisualisation struct {
	RangeColor *api.HexColor `json:"rangeColor,omitempty"`
	// The string to display when the condition defined by the variable's function spec is met.
	RangeLabel   *string       `conjure-docs:"The string to display when the condition defined by the variable's function spec is met." json:"rangeLabel,omitempty"`
	NoRangeColor *api.HexColor `json:"noRangeColor,omitempty"`
	// The string to display when the condition defined by the variable's function spec is not met.
	NoRangeLabel *string `conjure-docs:"The string to display when the condition defined by the variable's function spec is not met." json:"noRangeLabel,omitempty"`
}

func (o RangeRawVisualisation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangeRawVisualisation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RangeValueChannel struct {
	VariableName  api2.ChannelVariableName `json:"variableName"`
	Visualisation RangeValueVisualisation  `json:"visualisation"`
}

func (o RangeValueChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RangeValueChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Scatter3dTraceComputeConfig struct {
	// Bucket computed data points by their proximity in space or in time
	DecimationStrategy *Scatter3dDecimationStrategy `conjure-docs:"Bucket computed data points by their proximity in space or in time" json:"decimationStrategy,omitempty"`
}

func (o Scatter3dTraceComputeConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Scatter3dTraceComputeConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type StalenessConfiguration struct {
	// The duration above which points are considered stale. By default this is 1 second.
	Threshold api5.Duration `conjure-docs:"The duration above which points are considered stale. By default this is 1 second." json:"threshold"`
	// Whether or not to visually connect stale points, i.e. points whose distance exceeds that of the configured threshold. By default this is true.
	ConnectStalePoints bool `conjure-docs:"Whether or not to visually connect stale points, i.e. points whose distance exceeds that of the configured threshold. By default this is true." json:"connectStalePoints"`
}

func (o StalenessConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StalenessConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Threshold struct {
	// The minimum value a number must be to .
	Value float64 `conjure-docs:"The minimum value a number must be to ." json:"value"`
	// The color to apply to the cell when the threshold is active.
	Color api.HexColor `conjure-docs:"The color to apply to the cell when the threshold is active." json:"color"`
	// A name for this threshold to display while editing.
	Label *string `conjure-docs:"A name for this threshold to display while editing." json:"label,omitempty"`
}

func (o Threshold) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Threshold) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
NOTE this is deprecated and will be translated to NeverConnectDisconnectedValues by the frontend.
This option indicates the duration below which disconnected values will always be connected with a line.
*/
type ThresholdDisconnectedValues struct {
	Type api5.Duration `json:"type"`
}

func (o ThresholdDisconnectedValues) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ThresholdDisconnectedValues) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimeSeriesChartDefinitionV1 struct {
	Rows                []TimeSeriesRow           `json:"rows"`
	ComparisonRunGroups []api1.ComparisonRunGroup `json:"comparisonRunGroups"`
	// Deprecated: Please use the workbook's eventRefs field instead.
	Events     *[]Event                      `json:"events,omitempty"`
	Title      *string                       `json:"title,omitempty"`
	ValueAxes  []ValueAxis                   `json:"valueAxes"`
	Thresholds *[]AxisThresholdVisualization `json:"thresholds,omitempty"`
	/*
	   Determines when disconnected values should be connected. By default, they are always connected.

	   Deprecated: Use stalenessConfiguration instead
	*/
	DisconnectedValues *DisconnectedValueVisualization `conjure-docs:"Determines when disconnected values should be connected. By default, they are always connected." json:"disconnectedValues,omitempty"`
	// Determines when to draw lines between points. By default, the staleness threshold is 1s and stale points are connected.
	StalenessConfiguration *StalenessConfiguration `conjure-docs:"Determines when to draw lines between points. By default, the staleness threshold is 1s and stale points are connected." json:"stalenessConfiguration,omitempty"`
}

func (o TimeSeriesChartDefinitionV1) MarshalJSON() ([]byte, error) {
	if o.Rows == nil {
		o.Rows = make([]TimeSeriesRow, 0)
	}
	if o.ComparisonRunGroups == nil {
		o.ComparisonRunGroups = make([]api1.ComparisonRunGroup, 0)
	}
	if o.ValueAxes == nil {
		o.ValueAxes = make([]ValueAxis, 0)
	}
	type _tmpTimeSeriesChartDefinitionV1 TimeSeriesChartDefinitionV1
	return safejson.Marshal(_tmpTimeSeriesChartDefinitionV1(o))
}

func (o *TimeSeriesChartDefinitionV1) UnmarshalJSON(data []byte) error {
	type _tmpTimeSeriesChartDefinitionV1 TimeSeriesChartDefinitionV1
	var rawTimeSeriesChartDefinitionV1 _tmpTimeSeriesChartDefinitionV1
	if err := safejson.Unmarshal(data, &rawTimeSeriesChartDefinitionV1); err != nil {
		return err
	}
	if rawTimeSeriesChartDefinitionV1.Rows == nil {
		rawTimeSeriesChartDefinitionV1.Rows = make([]TimeSeriesRow, 0)
	}
	if rawTimeSeriesChartDefinitionV1.ComparisonRunGroups == nil {
		rawTimeSeriesChartDefinitionV1.ComparisonRunGroups = make([]api1.ComparisonRunGroup, 0)
	}
	if rawTimeSeriesChartDefinitionV1.ValueAxes == nil {
		rawTimeSeriesChartDefinitionV1.ValueAxes = make([]ValueAxis, 0)
	}
	*o = TimeSeriesChartDefinitionV1(rawTimeSeriesChartDefinitionV1)
	return nil
}

func (o TimeSeriesChartDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeSeriesChartDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimeSeriesEnumPlot struct {
	// How to color the value ranges
	Color ColorStyle `conjure-docs:"How to color the value ranges" json:"color"`
	// Where to place the plot within the row
	Position Position `conjure-docs:"Where to place the plot within the row" json:"position"`
	/*
	   Render certain values' full-row/full-panel color overlays
	   even when not interacting with the plot
	*/
	PersistValueOverlays PersistValueOverlay `conjure-docs:"Render certain values' full-row/full-panel color overlays\neven when not interacting with the plot" json:"persistValueOverlays"`
	// How far to extend the overlay
	OverlayScope OverlayScope `conjure-docs:"How far to extend the overlay" json:"overlayScope"`
	/*
	   Whether to display the value ranges on the same line or stagger them
	   such that each value gets a line to itself
	*/
	DisplayInline bool `conjure-docs:"Whether to display the value ranges on the same line or stagger them\nsuch that each value gets a line to itself" json:"displayInline"`
}

func (o TimeSeriesEnumPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeSeriesEnumPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimeSeriesNumericPlot struct {
	Color     api.HexColor `json:"color"`
	LineStyle LineStyle    `json:"lineStyle"`
}

func (o TimeSeriesNumericPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeSeriesNumericPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimeSeriesPlot struct {
	VariableName api2.ChannelVariableName `json:"variableName"`
	Enabled      *bool                    `json:"enabled,omitempty"`
	YAxisId      AxisId                   `json:"yAxisId"`
	Color        api.HexColor             `json:"color"`
	LineStyle    LineStyle                `json:"lineStyle"`
}

func (o TimeSeriesPlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeSeriesPlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimeSeriesPlotV2 struct {
	VariableName api2.ChannelVariableName `json:"variableName"`
	Enabled      *bool                    `json:"enabled,omitempty"`
	YAxisId      AxisId                   `json:"yAxisId"`
	Type         TimeSeriesPlotConfig     `json:"type"`
}

func (o TimeSeriesPlotV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeSeriesPlotV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimeSeriesRangePlot struct {
	Color api.HexColor `json:"color"`
}

func (o TimeSeriesRangePlot) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeSeriesRangePlot) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimeSeriesRow struct {
	Title       *string             `json:"title,omitempty"`
	Plots       []TimeSeriesPlot    `json:"plots"`
	PlotsV2     *[]TimeSeriesPlotV2 `json:"plotsV2,omitempty"`
	RowFlexSize float64             `json:"rowFlexSize"`
	Enabled     *bool               `json:"enabled,omitempty"`
}

func (o TimeSeriesRow) MarshalJSON() ([]byte, error) {
	if o.Plots == nil {
		o.Plots = make([]TimeSeriesPlot, 0)
	}
	type _tmpTimeSeriesRow TimeSeriesRow
	return safejson.Marshal(_tmpTimeSeriesRow(o))
}

func (o *TimeSeriesRow) UnmarshalJSON(data []byte) error {
	type _tmpTimeSeriesRow TimeSeriesRow
	var rawTimeSeriesRow _tmpTimeSeriesRow
	if err := safejson.Unmarshal(data, &rawTimeSeriesRow); err != nil {
		return err
	}
	if rawTimeSeriesRow.Plots == nil {
		rawTimeSeriesRow.Plots = make([]TimeSeriesPlot, 0)
	}
	*o = TimeSeriesRow(rawTimeSeriesRow)
	return nil
}

func (o TimeSeriesRow) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeSeriesRow) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Trace struct {
	/*
	   The json trace definition according to plotly's schema
	   https://plotly.com/python/figure-structure/#the-toplevel-data-attribute
	*/
	PlotlyTrace string `conjure-docs:"The json trace definition according to plotly's schema\nhttps://plotly.com/python/figure-structure/#the-toplevel-data-attribute" json:"plotlyTrace"`
	// Information needed to substitute computed data arrays into the trace
	Compute *TraceCompute `conjure-docs:"Information needed to substitute computed data arrays into the trace" json:"compute,omitempty"`
}

func (o Trace) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Trace) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TraceCompute struct {
	// A map of plotly trace variables to the channel variables that should load into them
	TraceChannelVariables map[string]api2.ChannelVariableName `conjure-docs:"A map of plotly trace variables to the channel variables that should load into them" json:"traceChannelVariables"`
	Config                *TraceComputeConfig                 `json:"config,omitempty"`
}

func (o TraceCompute) MarshalJSON() ([]byte, error) {
	if o.TraceChannelVariables == nil {
		o.TraceChannelVariables = make(map[string]api2.ChannelVariableName, 0)
	}
	type _tmpTraceCompute TraceCompute
	return safejson.Marshal(_tmpTraceCompute(o))
}

func (o *TraceCompute) UnmarshalJSON(data []byte) error {
	type _tmpTraceCompute TraceCompute
	var rawTraceCompute _tmpTraceCompute
	if err := safejson.Unmarshal(data, &rawTraceCompute); err != nil {
		return err
	}
	if rawTraceCompute.TraceChannelVariables == nil {
		rawTraceCompute.TraceChannelVariables = make(map[string]api2.ChannelVariableName, 0)
	}
	*o = TraceCompute(rawTraceCompute)
	return nil
}

func (o TraceCompute) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TraceCompute) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ValueAxis struct {
	Id             string             `json:"id"`
	Title          string             `json:"title"`
	DisplayOptions AxisDisplayOptions `json:"displayOptions"`
	Range          AxisRange          `json:"range"`
	Limit          AxisRange          `json:"limit"`
	Position       AxisPosition       `json:"position"`
	DomainType     AxisDomainType     `json:"domainType"`
}

func (o ValueAxis) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueAxis) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ValueSort struct {
	/*
	   If true, numerics sort high to low, enums sort alphabetically descending, and ranges sort inRange groupings first.
	   If false, the opposite is true for each.
	*/
	IsDescending bool `conjure-docs:"If true, numerics sort high to low, enums sort alphabetically descending, and ranges sort inRange groupings first.\nIf false, the opposite is true for each." json:"isDescending"`
}

func (o ValueSort) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueSort) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ValueTableCell struct {
	VariableName string               `json:"variableName"`
	Config       ValueTableCellConfig `json:"config"`
}

func (o ValueTableCell) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueTableCell) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ValueTableDefinitionV1 struct {
	Title *string `json:"title,omitempty"`
	/*
	   Each channel to be displayed. Based on the data type, the visualisation
	   options and settings will be different.
	*/
	Channels []ValueTableChannel `conjure-docs:"Each channel to be displayed. Based on the data type, the visualisation\noptions and settings will be different." json:"channels"`
}

func (o ValueTableDefinitionV1) MarshalJSON() ([]byte, error) {
	if o.Channels == nil {
		o.Channels = make([]ValueTableChannel, 0)
	}
	type _tmpValueTableDefinitionV1 ValueTableDefinitionV1
	return safejson.Marshal(_tmpValueTableDefinitionV1(o))
}

func (o *ValueTableDefinitionV1) UnmarshalJSON(data []byte) error {
	type _tmpValueTableDefinitionV1 ValueTableDefinitionV1
	var rawValueTableDefinitionV1 _tmpValueTableDefinitionV1
	if err := safejson.Unmarshal(data, &rawValueTableDefinitionV1); err != nil {
		return err
	}
	if rawValueTableDefinitionV1.Channels == nil {
		rawValueTableDefinitionV1.Channels = make([]ValueTableChannel, 0)
	}
	*o = ValueTableDefinitionV1(rawValueTableDefinitionV1)
	return nil
}

func (o ValueTableDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueTableDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ValueTableDefinitionV2 struct {
	// The display title of the panel.
	Title *string `conjure-docs:"The display title of the panel." json:"title,omitempty"`
	// If true, display units in the cells when available.
	ShowUnits *bool `conjure-docs:"If true, display units in the cells when available." json:"showUnits,omitempty"`
	// If true, display staleness indicator in the cells when available.
	ShowStalenessIndicator *bool            `conjure-docs:"If true, display staleness indicator in the cells when available." json:"showStalenessIndicator,omitempty"`
	Layout                 ValueTableLayout `json:"layout"`
	// Configuration for showing staleness of values in the value table while streaming.
	StalenessIndicator *ValueTableStalenessConfig `conjure-docs:"Configuration for showing staleness of values in the value table while streaming." json:"stalenessIndicator,omitempty"`
}

func (o ValueTableDefinitionV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueTableDefinitionV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ValueTableGridRowColumnConfig struct {
	// The index of the row or column to apply this configuration to.
	Position   int                        `conjure-docs:"The index of the row or column to apply this configuration to." json:"position"`
	Header     *string                    `json:"header,omitempty"`
	CellConfig *ValueTableMultiCellConfig `json:"cellConfig,omitempty"`
}

func (o ValueTableGridRowColumnConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueTableGridRowColumnConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ValueTableGridValueTableCell struct {
	Row    int            `json:"row"`
	Column int            `json:"column"`
	Cell   ValueTableCell `json:"cell"`
}

func (o ValueTableGridValueTableCell) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueTableGridValueTableCell) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A 2D grid layout for the value table where cells are laid out in specific
rows and columns. Supports hierarchical cell visualisation configurations, favoring when present:
the cell's own definition, then the column's, then the row's, then the panel's.
*/
type ValueTableLayoutGrid struct {
	// If true, display row headers.
	ShowRowHeaders *bool `conjure-docs:"If true, display row headers." json:"showRowHeaders,omitempty"`
	// If true, display column headers.
	ShowColumnHeaders *bool `conjure-docs:"If true, display column headers." json:"showColumnHeaders,omitempty"`
	// If true, display channel names in the cells.
	ShowCellLabels *bool `conjure-docs:"If true, display channel names in the cells." json:"showCellLabels,omitempty"`
	// Panel-level defaults for cell visualisations
	GridDefaultCellConfigs ValueTableMultiCellConfig `conjure-docs:"Panel-level defaults for cell visualisations" json:"gridDefaultCellConfigs"`
	// Column-level configurations.
	ColumnConfigs []ValueTableGridRowColumnConfig `conjure-docs:"Column-level configurations." json:"columnConfigs"`
	// Row-level configurations.
	RowConfigs  []ValueTableGridRowColumnConfig `conjure-docs:"Row-level configurations." json:"rowConfigs"`
	RowCount    int                             `json:"rowCount"`
	ColumnCount int                             `json:"columnCount"`
	// An array of cells to display in the table.
	Cells []ValueTableGridValueTableCell `conjure-docs:"An array of cells to display in the table." json:"cells"`
}

func (o ValueTableLayoutGrid) MarshalJSON() ([]byte, error) {
	if o.ColumnConfigs == nil {
		o.ColumnConfigs = make([]ValueTableGridRowColumnConfig, 0)
	}
	if o.RowConfigs == nil {
		o.RowConfigs = make([]ValueTableGridRowColumnConfig, 0)
	}
	if o.Cells == nil {
		o.Cells = make([]ValueTableGridValueTableCell, 0)
	}
	type _tmpValueTableLayoutGrid ValueTableLayoutGrid
	return safejson.Marshal(_tmpValueTableLayoutGrid(o))
}

func (o *ValueTableLayoutGrid) UnmarshalJSON(data []byte) error {
	type _tmpValueTableLayoutGrid ValueTableLayoutGrid
	var rawValueTableLayoutGrid _tmpValueTableLayoutGrid
	if err := safejson.Unmarshal(data, &rawValueTableLayoutGrid); err != nil {
		return err
	}
	if rawValueTableLayoutGrid.ColumnConfigs == nil {
		rawValueTableLayoutGrid.ColumnConfigs = make([]ValueTableGridRowColumnConfig, 0)
	}
	if rawValueTableLayoutGrid.RowConfigs == nil {
		rawValueTableLayoutGrid.RowConfigs = make([]ValueTableGridRowColumnConfig, 0)
	}
	if rawValueTableLayoutGrid.Cells == nil {
		rawValueTableLayoutGrid.Cells = make([]ValueTableGridValueTableCell, 0)
	}
	*o = ValueTableLayoutGrid(rawValueTableLayoutGrid)
	return nil
}

func (o ValueTableLayoutGrid) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueTableLayoutGrid) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Configurations for each type of cell in a grouping of heterogenous cells, such as
for a row, for a column, or for the entire grid.
*/
type ValueTableMultiCellConfig struct {
	Range   *RangeCellConfig   `json:"range,omitempty"`
	Enum    *EnumCellConfig    `json:"enum,omitempty"`
	Numeric *NumericCellConfig `json:"numeric,omitempty"`
}

func (o ValueTableMultiCellConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueTableMultiCellConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Configuration for showing staleness of values while streaming
type ValueTableStalenessConfig struct {
	// If true, will not show any indication of staleness. Defaults to false
	HideStaleness *bool `conjure-docs:"If true, will not show any indication of staleness. Defaults to false" json:"hideStaleness,omitempty"`
}

func (o ValueTableStalenessConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValueTableStalenessConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Enhanced video panel data source to be compatible with multiple assets
type VideoPanelDataSource struct {
	AssetRid api4.AssetRid     `json:"assetRid"`
	RefName  DataSourceRefName `json:"refName"`
}

func (o VideoPanelDataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VideoPanelDataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type VideoVizDefinitionV1 struct {
	// Deprecated: Please use the workbook's eventRefs field instead.
	Events              *[]Event                  `json:"events,omitempty"`
	ComparisonRunGroups []api1.ComparisonRunGroup `json:"comparisonRunGroups"`
	Title               *string                   `json:"title,omitempty"`
	// Deprecated: Datasource field will be preferred over refName field to support multiple assets.
	RefName    *DataSourceRefName    `json:"refName,omitempty"`
	Datasource *VideoPanelDataSource `json:"datasource,omitempty"`
}

func (o VideoVizDefinitionV1) MarshalJSON() ([]byte, error) {
	if o.ComparisonRunGroups == nil {
		o.ComparisonRunGroups = make([]api1.ComparisonRunGroup, 0)
	}
	type _tmpVideoVizDefinitionV1 VideoVizDefinitionV1
	return safejson.Marshal(_tmpVideoVizDefinitionV1(o))
}

func (o *VideoVizDefinitionV1) UnmarshalJSON(data []byte) error {
	type _tmpVideoVizDefinitionV1 VideoVizDefinitionV1
	var rawVideoVizDefinitionV1 _tmpVideoVizDefinitionV1
	if err := safejson.Unmarshal(data, &rawVideoVizDefinitionV1); err != nil {
		return err
	}
	if rawVideoVizDefinitionV1.ComparisonRunGroups == nil {
		rawVideoVizDefinitionV1.ComparisonRunGroups = make([]api1.ComparisonRunGroup, 0)
	}
	*o = VideoVizDefinitionV1(rawVideoVizDefinitionV1)
	return nil
}

func (o VideoVizDefinitionV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VideoVizDefinitionV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
