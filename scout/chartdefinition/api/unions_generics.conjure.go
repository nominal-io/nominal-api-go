// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/scout/api"
)

type AxisThresholdGroupWithT[T any] AxisThresholdGroup

func (u *AxisThresholdGroupWithT[T]) Accept(ctx context.Context, v AxisThresholdGroupVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return result, fmt.Errorf("field \"lineThresholds\" is required")
		}
		return v.VisitLineThresholds(ctx, *u.lineThresholds)
	}
}

func (u *AxisThresholdGroupWithT[T]) AcceptFuncs(lineThresholdsFunc func(LineThresholdGroup) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return result, fmt.Errorf("field \"lineThresholds\" is required")
		}
		return lineThresholdsFunc(*u.lineThresholds)
	}
}

func (u *AxisThresholdGroupWithT[T]) LineThresholdsNoopSuccess(LineThresholdGroup) (T, error) {
	var result T
	return result, nil
}

func (u *AxisThresholdGroupWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type AxisThresholdGroupVisitorWithT[T any] interface {
	VisitLineThresholds(ctx context.Context, v LineThresholdGroup) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type BitFlagMapVisualisationWithT[T any] BitFlagMapVisualisation

func (u *BitFlagMapVisualisationWithT[T]) Accept(ctx context.Context, v BitFlagMapVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *BitFlagMapVisualisationWithT[T]) AcceptFuncs(rawFunc func(BitFlagMapRawVisualisation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *BitFlagMapVisualisationWithT[T]) RawNoopSuccess(BitFlagMapRawVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *BitFlagMapVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type BitFlagMapVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v BitFlagMapRawVisualisation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CartesianChartDefinitionWithT[T any] CartesianChartDefinition

func (u *CartesianChartDefinitionWithT[T]) Accept(ctx context.Context, v CartesianChartDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *CartesianChartDefinitionWithT[T]) AcceptFuncs(v1Func func(CartesianChartDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *CartesianChartDefinitionWithT[T]) V1NoopSuccess(CartesianChartDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *CartesianChartDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CartesianChartDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v CartesianChartDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ChecklistChartDefinitionWithT[T any] ChecklistChartDefinition

func (u *ChecklistChartDefinitionWithT[T]) Accept(ctx context.Context, v ChecklistChartDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *ChecklistChartDefinitionWithT[T]) AcceptFuncs(v1Func func(ChecklistChartDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ChecklistChartDefinitionWithT[T]) V1NoopSuccess(ChecklistChartDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistChartDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ChecklistChartDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v ChecklistChartDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ColorStyleWithT[T any] ColorStyle

func (u *ColorStyleWithT[T]) Accept(ctx context.Context, v ColorStyleVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "mapped":
		if u.mapped == nil {
			return result, fmt.Errorf("field \"mapped\" is required")
		}
		return v.VisitMapped(ctx, *u.mapped)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(ctx, *u.single)
	}
}

func (u *ColorStyleWithT[T]) AcceptFuncs(mappedFunc func(map[string]api.HexColor) (T, error), singleFunc func(api.HexColor) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "mapped":
		if u.mapped == nil {
			return result, fmt.Errorf("field \"mapped\" is required")
		}
		return mappedFunc(*u.mapped)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	}
}

func (u *ColorStyleWithT[T]) MappedNoopSuccess(map[string]api.HexColor) (T, error) {
	var result T
	return result, nil
}

func (u *ColorStyleWithT[T]) SingleNoopSuccess(api.HexColor) (T, error) {
	var result T
	return result, nil
}

func (u *ColorStyleWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ColorStyleVisitorWithT[T any] interface {
	VisitMapped(ctx context.Context, v map[string]api.HexColor) (T, error)
	VisitSingle(ctx context.Context, v api.HexColor) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type DecimalPlacesWithT[T any] DecimalPlaces

func (u *DecimalPlacesWithT[T]) Accept(ctx context.Context, v DecimalPlacesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "fixed":
		if u.fixed == nil {
			return result, fmt.Errorf("field \"fixed\" is required")
		}
		return v.VisitFixed(ctx, *u.fixed)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(ctx, *u.max)
	}
}

func (u *DecimalPlacesWithT[T]) AcceptFuncs(fixedFunc func(FixedDecimalPlaces) (T, error), maxFunc func(MaxDecimalPlaces) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fixed":
		if u.fixed == nil {
			return result, fmt.Errorf("field \"fixed\" is required")
		}
		return fixedFunc(*u.fixed)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	}
}

func (u *DecimalPlacesWithT[T]) FixedNoopSuccess(FixedDecimalPlaces) (T, error) {
	var result T
	return result, nil
}

func (u *DecimalPlacesWithT[T]) MaxNoopSuccess(MaxDecimalPlaces) (T, error) {
	var result T
	return result, nil
}

func (u *DecimalPlacesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DecimalPlacesVisitorWithT[T any] interface {
	VisitFixed(ctx context.Context, v FixedDecimalPlaces) (T, error)
	VisitMax(ctx context.Context, v MaxDecimalPlaces) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type DisconnectedValueVisualizationWithT[T any] DisconnectedValueVisualization

func (u *DisconnectedValueVisualizationWithT[T]) Accept(ctx context.Context, v DisconnectedValueVisualizationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return result, fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return v.VisitAlwaysConnect(ctx, *u.alwaysConnect)
	case "never":
		if u.never == nil {
			return result, fmt.Errorf("field \"never\" is required")
		}
		return v.VisitNever(ctx, *u.never)
	case "threshold":
		if u.threshold == nil {
			return result, fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThreshold(ctx, *u.threshold)
	}
}

func (u *DisconnectedValueVisualizationWithT[T]) AcceptFuncs(alwaysConnectFunc func(AlwaysConnectDisconnectedValues) (T, error), neverFunc func(NeverConnectDisconnectedValues) (T, error), thresholdFunc func(ThresholdDisconnectedValues) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return result, fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return alwaysConnectFunc(*u.alwaysConnect)
	case "never":
		if u.never == nil {
			return result, fmt.Errorf("field \"never\" is required")
		}
		return neverFunc(*u.never)
	case "threshold":
		if u.threshold == nil {
			return result, fmt.Errorf("field \"threshold\" is required")
		}
		return thresholdFunc(*u.threshold)
	}
}

func (u *DisconnectedValueVisualizationWithT[T]) AlwaysConnectNoopSuccess(AlwaysConnectDisconnectedValues) (T, error) {
	var result T
	return result, nil
}

func (u *DisconnectedValueVisualizationWithT[T]) NeverNoopSuccess(NeverConnectDisconnectedValues) (T, error) {
	var result T
	return result, nil
}

func (u *DisconnectedValueVisualizationWithT[T]) ThresholdNoopSuccess(ThresholdDisconnectedValues) (T, error) {
	var result T
	return result, nil
}

func (u *DisconnectedValueVisualizationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DisconnectedValueVisualizationVisitorWithT[T any] interface {
	VisitAlwaysConnect(ctx context.Context, v AlwaysConnectDisconnectedValues) (T, error)
	VisitNever(ctx context.Context, v NeverConnectDisconnectedValues) (T, error)
	VisitThreshold(ctx context.Context, v ThresholdDisconnectedValues) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EnumArrayVisualisationWithT[T any] EnumArrayVisualisation

func (u *EnumArrayVisualisationWithT[T]) Accept(ctx context.Context, v EnumArrayVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *EnumArrayVisualisationWithT[T]) AcceptFuncs(rawFunc func(EnumArrayRawVisualisation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *EnumArrayVisualisationWithT[T]) RawNoopSuccess(EnumArrayRawVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *EnumArrayVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EnumArrayVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v EnumArrayRawVisualisation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EnumDisplayStyleWithT[T any] EnumDisplayStyle

func (u *EnumDisplayStyleWithT[T]) Accept(ctx context.Context, v EnumDisplayStyleVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "stacked":
		if u.stacked == nil {
			return result, fmt.Errorf("field \"stacked\" is required")
		}
		return v.VisitStacked(ctx, *u.stacked)
	case "inline":
		if u.inline == nil {
			return result, fmt.Errorf("field \"inline\" is required")
		}
		return v.VisitInline(ctx, *u.inline)
	case "bar":
		if u.bar == nil {
			return result, fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBar(ctx, *u.bar)
	case "line":
		if u.line == nil {
			return result, fmt.Errorf("field \"line\" is required")
		}
		return v.VisitLine(ctx, *u.line)
	}
}

func (u *EnumDisplayStyleWithT[T]) AcceptFuncs(stackedFunc func(EnumDisplayStyleStacked) (T, error), inlineFunc func(EnumDisplayStyleInline) (T, error), barFunc func(EnumDisplayStyleBar) (T, error), lineFunc func(EnumDisplayStyleLine) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "stacked":
		if u.stacked == nil {
			return result, fmt.Errorf("field \"stacked\" is required")
		}
		return stackedFunc(*u.stacked)
	case "inline":
		if u.inline == nil {
			return result, fmt.Errorf("field \"inline\" is required")
		}
		return inlineFunc(*u.inline)
	case "bar":
		if u.bar == nil {
			return result, fmt.Errorf("field \"bar\" is required")
		}
		return barFunc(*u.bar)
	case "line":
		if u.line == nil {
			return result, fmt.Errorf("field \"line\" is required")
		}
		return lineFunc(*u.line)
	}
}

func (u *EnumDisplayStyleWithT[T]) StackedNoopSuccess(EnumDisplayStyleStacked) (T, error) {
	var result T
	return result, nil
}

func (u *EnumDisplayStyleWithT[T]) InlineNoopSuccess(EnumDisplayStyleInline) (T, error) {
	var result T
	return result, nil
}

func (u *EnumDisplayStyleWithT[T]) BarNoopSuccess(EnumDisplayStyleBar) (T, error) {
	var result T
	return result, nil
}

func (u *EnumDisplayStyleWithT[T]) LineNoopSuccess(EnumDisplayStyleLine) (T, error) {
	var result T
	return result, nil
}

func (u *EnumDisplayStyleWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EnumDisplayStyleVisitorWithT[T any] interface {
	VisitStacked(ctx context.Context, v EnumDisplayStyleStacked) (T, error)
	VisitInline(ctx context.Context, v EnumDisplayStyleInline) (T, error)
	VisitBar(ctx context.Context, v EnumDisplayStyleBar) (T, error)
	VisitLine(ctx context.Context, v EnumDisplayStyleLine) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EnumGroupBySortWithT[T any] EnumGroupBySort

func (u *EnumGroupBySortWithT[T]) Accept(ctx context.Context, v EnumGroupBySortVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "custom":
		if u.custom == nil {
			return result, fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(ctx, *u.custom)
	case "alphabetical":
		if u.alphabetical == nil {
			return result, fmt.Errorf("field \"alphabetical\" is required")
		}
		return v.VisitAlphabetical(ctx, *u.alphabetical)
	}
}

func (u *EnumGroupBySortWithT[T]) AcceptFuncs(customFunc func(EnumGroupBySortCustom) (T, error), alphabeticalFunc func(ValueSort) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "custom":
		if u.custom == nil {
			return result, fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	case "alphabetical":
		if u.alphabetical == nil {
			return result, fmt.Errorf("field \"alphabetical\" is required")
		}
		return alphabeticalFunc(*u.alphabetical)
	}
}

func (u *EnumGroupBySortWithT[T]) CustomNoopSuccess(EnumGroupBySortCustom) (T, error) {
	var result T
	return result, nil
}

func (u *EnumGroupBySortWithT[T]) AlphabeticalNoopSuccess(ValueSort) (T, error) {
	var result T
	return result, nil
}

func (u *EnumGroupBySortWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EnumGroupBySortVisitorWithT[T any] interface {
	VisitCustom(ctx context.Context, v EnumGroupBySortCustom) (T, error)
	VisitAlphabetical(ctx context.Context, v ValueSort) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EnumValueVisualisationWithT[T any] EnumValueVisualisation

func (u *EnumValueVisualisationWithT[T]) Accept(ctx context.Context, v EnumValueVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *EnumValueVisualisationWithT[T]) AcceptFuncs(rawFunc func(EnumRawVisualisation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *EnumValueVisualisationWithT[T]) RawNoopSuccess(EnumRawVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *EnumValueVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EnumValueVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v EnumRawVisualisation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FloatingLegendWithT[T any] FloatingLegend

func (u *FloatingLegendWithT[T]) Accept(ctx context.Context, v FloatingLegendVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "perRow":
		if u.perRow == nil {
			return result, fmt.Errorf("field \"perRow\" is required")
		}
		return v.VisitPerRow(ctx, *u.perRow)
	}
}

func (u *FloatingLegendWithT[T]) AcceptFuncs(perRowFunc func(PerRowFloatingLegends) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "perRow":
		if u.perRow == nil {
			return result, fmt.Errorf("field \"perRow\" is required")
		}
		return perRowFunc(*u.perRow)
	}
}

func (u *FloatingLegendWithT[T]) PerRowNoopSuccess(PerRowFloatingLegends) (T, error) {
	var result T
	return result, nil
}

func (u *FloatingLegendWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FloatingLegendVisitorWithT[T any] interface {
	VisitPerRow(ctx context.Context, v PerRowFloatingLegends) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FrequencyChartDefinitionWithT[T any] FrequencyChartDefinition

func (u *FrequencyChartDefinitionWithT[T]) Accept(ctx context.Context, v FrequencyChartDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(ctx, *u.v2)
	}
}

func (u *FrequencyChartDefinitionWithT[T]) AcceptFuncs(v1Func func(FrequencyChartDefinitionV1) (T, error), v2Func func(FrequencyChartDefinitionV2) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *FrequencyChartDefinitionWithT[T]) V1NoopSuccess(FrequencyChartDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyChartDefinitionWithT[T]) V2NoopSuccess(FrequencyChartDefinitionV2) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyChartDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FrequencyChartDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v FrequencyChartDefinitionV1) (T, error)
	VisitV2(ctx context.Context, v FrequencyChartDefinitionV2) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FrequencyPlotTypeWithT[T any] FrequencyPlotType

func (u *FrequencyPlotTypeWithT[T]) Accept(ctx context.Context, v FrequencyPlotTypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return v.VisitFft(ctx, *u.fft)
	case "periodogram":
		if u.periodogram == nil {
			return result, fmt.Errorf("field \"periodogram\" is required")
		}
		return v.VisitPeriodogram(ctx, *u.periodogram)
	case "psd":
		if u.psd == nil {
			return result, fmt.Errorf("field \"psd\" is required")
		}
		return v.VisitPsd(ctx, *u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return result, fmt.Errorf("field \"cpsd\" is required")
		}
		return v.VisitCpsd(ctx, *u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return result, fmt.Errorf("field \"nyquist\" is required")
		}
		return v.VisitNyquist(ctx, *u.nyquist)
	case "bode":
		if u.bode == nil {
			return result, fmt.Errorf("field \"bode\" is required")
		}
		return v.VisitBode(ctx, *u.bode)
	}
}

func (u *FrequencyPlotTypeWithT[T]) AcceptFuncs(fftFunc func(FrequencyPlotTypeFft) (T, error), periodogramFunc func(FrequencyPlotTypePeriodogram) (T, error), psdFunc func(FrequencyPlotTypePsd) (T, error), cpsdFunc func(FrequencyPlotTypeCpsd) (T, error), nyquistFunc func(FrequencyPlotTypeNyquist) (T, error), bodeFunc func(FrequencyPlotTypeBode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "fft":
		if u.fft == nil {
			return result, fmt.Errorf("field \"fft\" is required")
		}
		return fftFunc(*u.fft)
	case "periodogram":
		if u.periodogram == nil {
			return result, fmt.Errorf("field \"periodogram\" is required")
		}
		return periodogramFunc(*u.periodogram)
	case "psd":
		if u.psd == nil {
			return result, fmt.Errorf("field \"psd\" is required")
		}
		return psdFunc(*u.psd)
	case "cpsd":
		if u.cpsd == nil {
			return result, fmt.Errorf("field \"cpsd\" is required")
		}
		return cpsdFunc(*u.cpsd)
	case "nyquist":
		if u.nyquist == nil {
			return result, fmt.Errorf("field \"nyquist\" is required")
		}
		return nyquistFunc(*u.nyquist)
	case "bode":
		if u.bode == nil {
			return result, fmt.Errorf("field \"bode\" is required")
		}
		return bodeFunc(*u.bode)
	}
}

func (u *FrequencyPlotTypeWithT[T]) FftNoopSuccess(FrequencyPlotTypeFft) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyPlotTypeWithT[T]) PeriodogramNoopSuccess(FrequencyPlotTypePeriodogram) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyPlotTypeWithT[T]) PsdNoopSuccess(FrequencyPlotTypePsd) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyPlotTypeWithT[T]) CpsdNoopSuccess(FrequencyPlotTypeCpsd) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyPlotTypeWithT[T]) NyquistNoopSuccess(FrequencyPlotTypeNyquist) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyPlotTypeWithT[T]) BodeNoopSuccess(FrequencyPlotTypeBode) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyPlotTypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FrequencyPlotTypeVisitorWithT[T any] interface {
	VisitFft(ctx context.Context, v FrequencyPlotTypeFft) (T, error)
	VisitPeriodogram(ctx context.Context, v FrequencyPlotTypePeriodogram) (T, error)
	VisitPsd(ctx context.Context, v FrequencyPlotTypePsd) (T, error)
	VisitCpsd(ctx context.Context, v FrequencyPlotTypeCpsd) (T, error)
	VisitNyquist(ctx context.Context, v FrequencyPlotTypeNyquist) (T, error)
	VisitBode(ctx context.Context, v FrequencyPlotTypeBode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FrequencyPlotV2WithT[T any] FrequencyPlotV2

func (u *FrequencyPlotV2WithT[T]) Accept(ctx context.Context, v FrequencyPlotV2VisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(ctx, *u.single)
	case "multivariate":
		if u.multivariate == nil {
			return result, fmt.Errorf("field \"multivariate\" is required")
		}
		return v.VisitMultivariate(ctx, *u.multivariate)
	}
}

func (u *FrequencyPlotV2WithT[T]) AcceptFuncs(singleFunc func(FrequencyPlot) (T, error), multivariateFunc func(FrequencyPlotMultivariate) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	case "multivariate":
		if u.multivariate == nil {
			return result, fmt.Errorf("field \"multivariate\" is required")
		}
		return multivariateFunc(*u.multivariate)
	}
}

func (u *FrequencyPlotV2WithT[T]) SingleNoopSuccess(FrequencyPlot) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyPlotV2WithT[T]) MultivariateNoopSuccess(FrequencyPlotMultivariate) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyPlotV2WithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FrequencyPlotV2VisitorWithT[T any] interface {
	VisitSingle(ctx context.Context, v FrequencyPlot) (T, error)
	VisitMultivariate(ctx context.Context, v FrequencyPlotMultivariate) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dDefinitionWithT[T any] Geo3dDefinition

func (u *Geo3dDefinitionWithT[T]) Accept(ctx context.Context, v Geo3dDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *Geo3dDefinitionWithT[T]) AcceptFuncs(v1Func func(Geo3dDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *Geo3dDefinitionWithT[T]) V1NoopSuccess(Geo3dDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v Geo3dDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dModelWithT[T any] Geo3dModel

func (u *Geo3dModelWithT[T]) Accept(ctx context.Context, v Geo3dModelVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "default":
		if u.default_ == nil {
			return result, fmt.Errorf("field \"default\" is required")
		}
		return v.VisitDefault(ctx, *u.default_)
	case "custom":
		if u.custom == nil {
			return result, fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(ctx, *u.custom)
	}
}

func (u *Geo3dModelWithT[T]) AcceptFuncs(default_Func func(Geo3dDefaultModel) (T, error), customFunc func(Geo3dCustomModel) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "default":
		if u.default_ == nil {
			return result, fmt.Errorf("field \"default\" is required")
		}
		return default_Func(*u.default_)
	case "custom":
		if u.custom == nil {
			return result, fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	}
}

func (u *Geo3dModelWithT[T]) DefaultNoopSuccess(Geo3dDefaultModel) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dModelWithT[T]) CustomNoopSuccess(Geo3dCustomModel) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dModelWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dModelVisitorWithT[T any] interface {
	VisitDefault(ctx context.Context, v Geo3dDefaultModel) (T, error)
	VisitCustom(ctx context.Context, v Geo3dCustomModel) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dOrientationWithT[T any] Geo3dOrientation

func (u *Geo3dOrientationWithT[T]) Accept(ctx context.Context, v Geo3dOrientationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return result, fmt.Errorf("field \"principalAxes\" is required")
		}
		return v.VisitPrincipalAxes(ctx, *u.principalAxes)
	}
}

func (u *Geo3dOrientationWithT[T]) AcceptFuncs(principalAxesFunc func(Geo3dOrientationPrincipalAxes) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return result, fmt.Errorf("field \"principalAxes\" is required")
		}
		return principalAxesFunc(*u.principalAxes)
	}
}

func (u *Geo3dOrientationWithT[T]) PrincipalAxesNoopSuccess(Geo3dOrientationPrincipalAxes) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dOrientationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dOrientationVisitorWithT[T any] interface {
	VisitPrincipalAxes(ctx context.Context, v Geo3dOrientationPrincipalAxes) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dOrientationStaticWithT[T any] Geo3dOrientationStatic

func (u *Geo3dOrientationStaticWithT[T]) Accept(ctx context.Context, v Geo3dOrientationStaticVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return result, fmt.Errorf("field \"principalAxes\" is required")
		}
		return v.VisitPrincipalAxes(ctx, *u.principalAxes)
	}
}

func (u *Geo3dOrientationStaticWithT[T]) AcceptFuncs(principalAxesFunc func(Geo3dOrientationStaticPrincipalAxes) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return result, fmt.Errorf("field \"principalAxes\" is required")
		}
		return principalAxesFunc(*u.principalAxes)
	}
}

func (u *Geo3dOrientationStaticWithT[T]) PrincipalAxesNoopSuccess(Geo3dOrientationStaticPrincipalAxes) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dOrientationStaticWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dOrientationStaticVisitorWithT[T any] interface {
	VisitPrincipalAxes(ctx context.Context, v Geo3dOrientationStaticPrincipalAxes) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dPositionWithT[T any] Geo3dPosition

func (u *Geo3dPositionWithT[T]) Accept(ctx context.Context, v Geo3dPositionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return result, fmt.Errorf("field \"wgs84\" is required")
		}
		return v.VisitWgs84(ctx, *u.wgs84)
	case "ecef":
		if u.ecef == nil {
			return result, fmt.Errorf("field \"ecef\" is required")
		}
		return v.VisitEcef(ctx, *u.ecef)
	}
}

func (u *Geo3dPositionWithT[T]) AcceptFuncs(wgs84Func func(Geo3dPositionWgs84) (T, error), ecefFunc func(Geo3dPositionEcef) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return result, fmt.Errorf("field \"wgs84\" is required")
		}
		return wgs84Func(*u.wgs84)
	case "ecef":
		if u.ecef == nil {
			return result, fmt.Errorf("field \"ecef\" is required")
		}
		return ecefFunc(*u.ecef)
	}
}

func (u *Geo3dPositionWithT[T]) Wgs84NoopSuccess(Geo3dPositionWgs84) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dPositionWithT[T]) EcefNoopSuccess(Geo3dPositionEcef) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dPositionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dPositionVisitorWithT[T any] interface {
	VisitWgs84(ctx context.Context, v Geo3dPositionWgs84) (T, error)
	VisitEcef(ctx context.Context, v Geo3dPositionEcef) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dPositionStaticWithT[T any] Geo3dPositionStatic

func (u *Geo3dPositionStaticWithT[T]) Accept(ctx context.Context, v Geo3dPositionStaticVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return result, fmt.Errorf("field \"wgs84\" is required")
		}
		return v.VisitWgs84(ctx, *u.wgs84)
	case "ecef":
		if u.ecef == nil {
			return result, fmt.Errorf("field \"ecef\" is required")
		}
		return v.VisitEcef(ctx, *u.ecef)
	}
}

func (u *Geo3dPositionStaticWithT[T]) AcceptFuncs(wgs84Func func(Geo3dPositionStaticWgs84) (T, error), ecefFunc func(Geo3dPositionStaticEcef) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return result, fmt.Errorf("field \"wgs84\" is required")
		}
		return wgs84Func(*u.wgs84)
	case "ecef":
		if u.ecef == nil {
			return result, fmt.Errorf("field \"ecef\" is required")
		}
		return ecefFunc(*u.ecef)
	}
}

func (u *Geo3dPositionStaticWithT[T]) Wgs84NoopSuccess(Geo3dPositionStaticWgs84) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dPositionStaticWithT[T]) EcefNoopSuccess(Geo3dPositionStaticEcef) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dPositionStaticWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dPositionStaticVisitorWithT[T any] interface {
	VisitWgs84(ctx context.Context, v Geo3dPositionStaticWgs84) (T, error)
	VisitEcef(ctx context.Context, v Geo3dPositionStaticEcef) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dSensorOrientationConfigWithT[T any] Geo3dSensorOrientationConfig

func (u *Geo3dSensorOrientationConfigWithT[T]) Accept(ctx context.Context, v Geo3dSensorOrientationConfigVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "static":
		if u.static == nil {
			return result, fmt.Errorf("field \"static\" is required")
		}
		return v.VisitStatic(ctx, *u.static)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(ctx, *u.channel)
	case "nadir":
		if u.nadir == nil {
			return result, fmt.Errorf("field \"nadir\" is required")
		}
		return v.VisitNadir(ctx, *u.nadir)
	case "zenith":
		if u.zenith == nil {
			return result, fmt.Errorf("field \"zenith\" is required")
		}
		return v.VisitZenith(ctx, *u.zenith)
	}
}

func (u *Geo3dSensorOrientationConfigWithT[T]) AcceptFuncs(staticFunc func(Geo3dOrientationStatic) (T, error), channelFunc func(Geo3dOrientation) (T, error), nadirFunc func(Geo3dSensorOrientationNadir) (T, error), zenithFunc func(Geo3dSensorOrientationZenith) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "static":
		if u.static == nil {
			return result, fmt.Errorf("field \"static\" is required")
		}
		return staticFunc(*u.static)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "nadir":
		if u.nadir == nil {
			return result, fmt.Errorf("field \"nadir\" is required")
		}
		return nadirFunc(*u.nadir)
	case "zenith":
		if u.zenith == nil {
			return result, fmt.Errorf("field \"zenith\" is required")
		}
		return zenithFunc(*u.zenith)
	}
}

func (u *Geo3dSensorOrientationConfigWithT[T]) StaticNoopSuccess(Geo3dOrientationStatic) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dSensorOrientationConfigWithT[T]) ChannelNoopSuccess(Geo3dOrientation) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dSensorOrientationConfigWithT[T]) NadirNoopSuccess(Geo3dSensorOrientationNadir) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dSensorOrientationConfigWithT[T]) ZenithNoopSuccess(Geo3dSensorOrientationZenith) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dSensorOrientationConfigWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dSensorOrientationConfigVisitorWithT[T any] interface {
	VisitStatic(ctx context.Context, v Geo3dOrientationStatic) (T, error)
	VisitChannel(ctx context.Context, v Geo3dOrientation) (T, error)
	VisitNadir(ctx context.Context, v Geo3dSensorOrientationNadir) (T, error)
	VisitZenith(ctx context.Context, v Geo3dSensorOrientationZenith) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dSensorPositionConfigWithT[T any] Geo3dSensorPositionConfig

func (u *Geo3dSensorPositionConfigWithT[T]) Accept(ctx context.Context, v Geo3dSensorPositionConfigVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "static":
		if u.static == nil {
			return result, fmt.Errorf("field \"static\" is required")
		}
		return v.VisitStatic(ctx, *u.static)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(ctx, *u.channel)
	case "model":
		if u.model == nil {
			return result, fmt.Errorf("field \"model\" is required")
		}
		return v.VisitModel(ctx, *u.model)
	case "waypoint":
		if u.waypoint == nil {
			return result, fmt.Errorf("field \"waypoint\" is required")
		}
		return v.VisitWaypoint(ctx, *u.waypoint)
	}
}

func (u *Geo3dSensorPositionConfigWithT[T]) AcceptFuncs(staticFunc func(Geo3dPositionStatic) (T, error), channelFunc func(Geo3dPosition) (T, error), modelFunc func(string) (T, error), waypointFunc func(string) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "static":
		if u.static == nil {
			return result, fmt.Errorf("field \"static\" is required")
		}
		return staticFunc(*u.static)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "model":
		if u.model == nil {
			return result, fmt.Errorf("field \"model\" is required")
		}
		return modelFunc(*u.model)
	case "waypoint":
		if u.waypoint == nil {
			return result, fmt.Errorf("field \"waypoint\" is required")
		}
		return waypointFunc(*u.waypoint)
	}
}

func (u *Geo3dSensorPositionConfigWithT[T]) StaticNoopSuccess(Geo3dPositionStatic) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dSensorPositionConfigWithT[T]) ChannelNoopSuccess(Geo3dPosition) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dSensorPositionConfigWithT[T]) ModelNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dSensorPositionConfigWithT[T]) WaypointNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dSensorPositionConfigWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dSensorPositionConfigVisitorWithT[T any] interface {
	VisitStatic(ctx context.Context, v Geo3dPositionStatic) (T, error)
	VisitChannel(ctx context.Context, v Geo3dPosition) (T, error)
	VisitModel(ctx context.Context, v string) (T, error)
	VisitWaypoint(ctx context.Context, v string) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type GeoCustomFeatureWithT[T any] GeoCustomFeature

func (u *GeoCustomFeatureWithT[T]) Accept(ctx context.Context, v GeoCustomFeatureVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "point":
		if u.point == nil {
			return result, fmt.Errorf("field \"point\" is required")
		}
		return v.VisitPoint(ctx, *u.point)
	}
}

func (u *GeoCustomFeatureWithT[T]) AcceptFuncs(pointFunc func(GeoPoint) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "point":
		if u.point == nil {
			return result, fmt.Errorf("field \"point\" is required")
		}
		return pointFunc(*u.point)
	}
}

func (u *GeoCustomFeatureWithT[T]) PointNoopSuccess(GeoPoint) (T, error) {
	var result T
	return result, nil
}

func (u *GeoCustomFeatureWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type GeoCustomFeatureVisitorWithT[T any] interface {
	VisitPoint(ctx context.Context, v GeoPoint) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type GeoSecondaryPlotVisualizationOptionWithT[T any] GeoSecondaryPlotVisualizationOption

func (u *GeoSecondaryPlotVisualizationOptionWithT[T]) Accept(ctx context.Context, v GeoSecondaryPlotVisualizationOptionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "asColors":
		if u.asColors == nil {
			return result, fmt.Errorf("field \"asColors\" is required")
		}
		return v.VisitAsColors(ctx, *u.asColors)
	}
}

func (u *GeoSecondaryPlotVisualizationOptionWithT[T]) AcceptFuncs(asColorsFunc func(ValueToColorMap) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "asColors":
		if u.asColors == nil {
			return result, fmt.Errorf("field \"asColors\" is required")
		}
		return asColorsFunc(*u.asColors)
	}
}

func (u *GeoSecondaryPlotVisualizationOptionWithT[T]) AsColorsNoopSuccess(ValueToColorMap) (T, error) {
	var result T
	return result, nil
}

func (u *GeoSecondaryPlotVisualizationOptionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type GeoSecondaryPlotVisualizationOptionVisitorWithT[T any] interface {
	VisitAsColors(ctx context.Context, v ValueToColorMap) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type GeoVizDefinitionWithT[T any] GeoVizDefinition

func (u *GeoVizDefinitionWithT[T]) Accept(ctx context.Context, v GeoVizDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *GeoVizDefinitionWithT[T]) AcceptFuncs(v1Func func(GeoVizDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *GeoVizDefinitionWithT[T]) V1NoopSuccess(GeoVizDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *GeoVizDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type GeoVizDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v GeoVizDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type HistogramChartDefinitionWithT[T any] HistogramChartDefinition

func (u *HistogramChartDefinitionWithT[T]) Accept(ctx context.Context, v HistogramChartDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *HistogramChartDefinitionWithT[T]) AcceptFuncs(v1Func func(HistogramChartDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *HistogramChartDefinitionWithT[T]) V1NoopSuccess(HistogramChartDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *HistogramChartDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type HistogramChartDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v HistogramChartDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type LineStyleWithT[T any] LineStyle

func (u *LineStyleWithT[T]) Accept(ctx context.Context, v LineStyleVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *LineStyleWithT[T]) AcceptFuncs(v1Func func(LineStyleV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *LineStyleWithT[T]) V1NoopSuccess(LineStyleV1) (T, error) {
	var result T
	return result, nil
}

func (u *LineStyleWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LineStyleVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v LineStyleV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type LogPanelDefinitionWithT[T any] LogPanelDefinition

func (u *LogPanelDefinitionWithT[T]) Accept(ctx context.Context, v LogPanelDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *LogPanelDefinitionWithT[T]) AcceptFuncs(v1Func func(LogPanelDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *LogPanelDefinitionWithT[T]) V1NoopSuccess(LogPanelDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *LogPanelDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LogPanelDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v LogPanelDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericArrayVisualisationWithT[T any] NumericArrayVisualisation

func (u *NumericArrayVisualisationWithT[T]) Accept(ctx context.Context, v NumericArrayVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *NumericArrayVisualisationWithT[T]) AcceptFuncs(rawFunc func(NumericArrayRawVisualisation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *NumericArrayVisualisationWithT[T]) RawNoopSuccess(NumericArrayRawVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *NumericArrayVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericArrayVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v NumericArrayRawVisualisation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericGroupBySortWithT[T any] NumericGroupBySort

func (u *NumericGroupBySortWithT[T]) Accept(ctx context.Context, v NumericGroupBySortVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(ctx, *u.value)
	}
}

func (u *NumericGroupBySortWithT[T]) AcceptFuncs(valueFunc func(ValueSort) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *NumericGroupBySortWithT[T]) ValueNoopSuccess(ValueSort) (T, error) {
	var result T
	return result, nil
}

func (u *NumericGroupBySortWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericGroupBySortVisitorWithT[T any] interface {
	VisitValue(ctx context.Context, v ValueSort) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericValueVisualisationWithT[T any] NumericValueVisualisation

func (u *NumericValueVisualisationWithT[T]) Accept(ctx context.Context, v NumericValueVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "barGauge":
		if u.barGauge == nil {
			return result, fmt.Errorf("field \"barGauge\" is required")
		}
		return v.VisitBarGauge(ctx, *u.barGauge)
	}
}

func (u *NumericValueVisualisationWithT[T]) AcceptFuncs(rawFunc func(NumericRawVisualisation) (T, error), barGaugeFunc func(NumericBarGaugeVisualisation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "barGauge":
		if u.barGauge == nil {
			return result, fmt.Errorf("field \"barGauge\" is required")
		}
		return barGaugeFunc(*u.barGauge)
	}
}

func (u *NumericValueVisualisationWithT[T]) RawNoopSuccess(NumericRawVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *NumericValueVisualisationWithT[T]) BarGaugeNoopSuccess(NumericBarGaugeVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *NumericValueVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericValueVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v NumericRawVisualisation) (T, error)
	VisitBarGauge(ctx context.Context, v NumericBarGaugeVisualisation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericValueVisualisationV2WithT[T any] NumericValueVisualisationV2

func (u *NumericValueVisualisationV2WithT[T]) Accept(ctx context.Context, v NumericValueVisualisationV2VisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "bar":
		if u.bar == nil {
			return result, fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBar(ctx, *u.bar)
	}
}

func (u *NumericValueVisualisationV2WithT[T]) AcceptFuncs(rawFunc func(NumericRawVisualisationV2) (T, error), barFunc func(NumericBarVisualisationV2) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "bar":
		if u.bar == nil {
			return result, fmt.Errorf("field \"bar\" is required")
		}
		return barFunc(*u.bar)
	}
}

func (u *NumericValueVisualisationV2WithT[T]) RawNoopSuccess(NumericRawVisualisationV2) (T, error) {
	var result T
	return result, nil
}

func (u *NumericValueVisualisationV2WithT[T]) BarNoopSuccess(NumericBarVisualisationV2) (T, error) {
	var result T
	return result, nil
}

func (u *NumericValueVisualisationV2WithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericValueVisualisationV2VisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v NumericRawVisualisationV2) (T, error)
	VisitBar(ctx context.Context, v NumericBarVisualisationV2) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PanelBucketStrategyWithT[T any] PanelBucketStrategy

func (u *PanelBucketStrategyWithT[T]) Accept(ctx context.Context, v PanelBucketStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "auto":
		if u.auto == nil {
			return result, fmt.Errorf("field \"auto\" is required")
		}
		return v.VisitAuto(ctx, *u.auto)
	case "fixed":
		if u.fixed == nil {
			return result, fmt.Errorf("field \"fixed\" is required")
		}
		return v.VisitFixed(ctx, *u.fixed)
	case "duration":
		if u.duration == nil {
			return result, fmt.Errorf("field \"duration\" is required")
		}
		return v.VisitDuration(ctx, *u.duration)
	}
}

func (u *PanelBucketStrategyWithT[T]) AcceptFuncs(autoFunc func(PanelBucketStrategyAuto) (T, error), fixedFunc func(PanelBucketStrategyFixed) (T, error), durationFunc func(PanelBucketStrategyDuration) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "auto":
		if u.auto == nil {
			return result, fmt.Errorf("field \"auto\" is required")
		}
		return autoFunc(*u.auto)
	case "fixed":
		if u.fixed == nil {
			return result, fmt.Errorf("field \"fixed\" is required")
		}
		return fixedFunc(*u.fixed)
	case "duration":
		if u.duration == nil {
			return result, fmt.Errorf("field \"duration\" is required")
		}
		return durationFunc(*u.duration)
	}
}

func (u *PanelBucketStrategyWithT[T]) AutoNoopSuccess(PanelBucketStrategyAuto) (T, error) {
	var result T
	return result, nil
}

func (u *PanelBucketStrategyWithT[T]) FixedNoopSuccess(PanelBucketStrategyFixed) (T, error) {
	var result T
	return result, nil
}

func (u *PanelBucketStrategyWithT[T]) DurationNoopSuccess(PanelBucketStrategyDuration) (T, error) {
	var result T
	return result, nil
}

func (u *PanelBucketStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PanelBucketStrategyVisitorWithT[T any] interface {
	VisitAuto(ctx context.Context, v PanelBucketStrategyAuto) (T, error)
	VisitFixed(ctx context.Context, v PanelBucketStrategyFixed) (T, error)
	VisitDuration(ctx context.Context, v PanelBucketStrategyDuration) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PersistValueOverlayWithT[T any] PersistValueOverlay

func (u *PersistValueOverlayWithT[T]) Accept(ctx context.Context, v PersistValueOverlayVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "byValue":
		if u.byValue == nil {
			return result, fmt.Errorf("field \"byValue\" is required")
		}
		return v.VisitByValue(ctx, *u.byValue)
	case "all":
		if u.all == nil {
			return result, fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAll(ctx, *u.all)
	}
}

func (u *PersistValueOverlayWithT[T]) AcceptFuncs(byValueFunc func(PersistByValue) (T, error), allFunc func(PersistAll) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "byValue":
		if u.byValue == nil {
			return result, fmt.Errorf("field \"byValue\" is required")
		}
		return byValueFunc(*u.byValue)
	case "all":
		if u.all == nil {
			return result, fmt.Errorf("field \"all\" is required")
		}
		return allFunc(*u.all)
	}
}

func (u *PersistValueOverlayWithT[T]) ByValueNoopSuccess(PersistByValue) (T, error) {
	var result T
	return result, nil
}

func (u *PersistValueOverlayWithT[T]) AllNoopSuccess(PersistAll) (T, error) {
	var result T
	return result, nil
}

func (u *PersistValueOverlayWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PersistValueOverlayVisitorWithT[T any] interface {
	VisitByValue(ctx context.Context, v PersistByValue) (T, error)
	VisitAll(ctx context.Context, v PersistAll) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PlotColoringConfigurationWithT[T any] PlotColoringConfiguration

func (u *PlotColoringConfigurationWithT[T]) Accept(ctx context.Context, v PlotColoringConfigurationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "rowIndependent":
		if u.rowIndependent == nil {
			return result, fmt.Errorf("field \"rowIndependent\" is required")
		}
		return v.VisitRowIndependent(ctx, *u.rowIndependent)
	case "rowShared":
		if u.rowShared == nil {
			return result, fmt.Errorf("field \"rowShared\" is required")
		}
		return v.VisitRowShared(ctx, *u.rowShared)
	}
}

func (u *PlotColoringConfigurationWithT[T]) AcceptFuncs(rowIndependentFunc func(RowIndependentPlotColoringConfiguration) (T, error), rowSharedFunc func(RowSharedPlotColoringConfiguration) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "rowIndependent":
		if u.rowIndependent == nil {
			return result, fmt.Errorf("field \"rowIndependent\" is required")
		}
		return rowIndependentFunc(*u.rowIndependent)
	case "rowShared":
		if u.rowShared == nil {
			return result, fmt.Errorf("field \"rowShared\" is required")
		}
		return rowSharedFunc(*u.rowShared)
	}
}

func (u *PlotColoringConfigurationWithT[T]) RowIndependentNoopSuccess(RowIndependentPlotColoringConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *PlotColoringConfigurationWithT[T]) RowSharedNoopSuccess(RowSharedPlotColoringConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *PlotColoringConfigurationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PlotColoringConfigurationVisitorWithT[T any] interface {
	VisitRowIndependent(ctx context.Context, v RowIndependentPlotColoringConfiguration) (T, error)
	VisitRowShared(ctx context.Context, v RowSharedPlotColoringConfiguration) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PlotlyPanelDefinitionWithT[T any] PlotlyPanelDefinition

func (u *PlotlyPanelDefinitionWithT[T]) Accept(ctx context.Context, v PlotlyPanelDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *PlotlyPanelDefinitionWithT[T]) AcceptFuncs(v1Func func(PlotlyPanelDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *PlotlyPanelDefinitionWithT[T]) V1NoopSuccess(PlotlyPanelDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *PlotlyPanelDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PlotlyPanelDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v PlotlyPanelDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ProcedureVizDefinitionWithT[T any] ProcedureVizDefinition

func (u *ProcedureVizDefinitionWithT[T]) Accept(ctx context.Context, v ProcedureVizDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(ctx, *u.v2)
	}
}

func (u *ProcedureVizDefinitionWithT[T]) AcceptFuncs(v1Func func(ProcedureVizDefinitionV1) (T, error), v2Func func(ProcedureVizDefinitionV2) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *ProcedureVizDefinitionWithT[T]) V1NoopSuccess(ProcedureVizDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *ProcedureVizDefinitionWithT[T]) V2NoopSuccess(ProcedureVizDefinitionV2) (T, error) {
	var result T
	return result, nil
}

func (u *ProcedureVizDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ProcedureVizDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v ProcedureVizDefinitionV1) (T, error)
	VisitV2(ctx context.Context, v ProcedureVizDefinitionV2) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ProcedureVizIdWithT[T any] ProcedureVizId

func (u *ProcedureVizIdWithT[T]) Accept(ctx context.Context, v ProcedureVizIdVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "executionRid":
		if u.executionRid == nil {
			return result, fmt.Errorf("field \"executionRid\" is required")
		}
		return v.VisitExecutionRid(ctx, *u.executionRid)
	case "templateRid":
		if u.templateRid == nil {
			return result, fmt.Errorf("field \"templateRid\" is required")
		}
		return v.VisitTemplateRid(ctx, *u.templateRid)
	}
}

func (u *ProcedureVizIdWithT[T]) AcceptFuncs(executionRidFunc func(rids.ProcedureExecutionRid) (T, error), templateRidFunc func(rids.ProcedureRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "executionRid":
		if u.executionRid == nil {
			return result, fmt.Errorf("field \"executionRid\" is required")
		}
		return executionRidFunc(*u.executionRid)
	case "templateRid":
		if u.templateRid == nil {
			return result, fmt.Errorf("field \"templateRid\" is required")
		}
		return templateRidFunc(*u.templateRid)
	}
}

func (u *ProcedureVizIdWithT[T]) ExecutionRidNoopSuccess(rids.ProcedureExecutionRid) (T, error) {
	var result T
	return result, nil
}

func (u *ProcedureVizIdWithT[T]) TemplateRidNoopSuccess(rids.ProcedureRid) (T, error) {
	var result T
	return result, nil
}

func (u *ProcedureVizIdWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ProcedureVizIdVisitorWithT[T any] interface {
	VisitExecutionRid(ctx context.Context, v rids.ProcedureExecutionRid) (T, error)
	VisitTemplateRid(ctx context.Context, v rids.ProcedureRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type RangeGroupBySortWithT[T any] RangeGroupBySort

func (u *RangeGroupBySortWithT[T]) Accept(ctx context.Context, v RangeGroupBySortVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(ctx, *u.value)
	}
}

func (u *RangeGroupBySortWithT[T]) AcceptFuncs(valueFunc func(ValueSort) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *RangeGroupBySortWithT[T]) ValueNoopSuccess(ValueSort) (T, error) {
	var result T
	return result, nil
}

func (u *RangeGroupBySortWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type RangeGroupBySortVisitorWithT[T any] interface {
	VisitValue(ctx context.Context, v ValueSort) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type RangeValueVisualisationWithT[T any] RangeValueVisualisation

func (u *RangeValueVisualisationWithT[T]) Accept(ctx context.Context, v RangeValueVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *RangeValueVisualisationWithT[T]) AcceptFuncs(rawFunc func(RangeRawVisualisation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *RangeValueVisualisationWithT[T]) RawNoopSuccess(RangeRawVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *RangeValueVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type RangeValueVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v RangeRawVisualisation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type StalenessVisualisationWithT[T any] StalenessVisualisation

func (u *StalenessVisualisationWithT[T]) Accept(ctx context.Context, v StalenessVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "bar":
		if u.bar == nil {
			return result, fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBar(ctx, *u.bar)
	}
}

func (u *StalenessVisualisationWithT[T]) AcceptFuncs(rawFunc func(NumericRawVisualisationV2) (T, error), barFunc func(NumericBarVisualisationV2) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "bar":
		if u.bar == nil {
			return result, fmt.Errorf("field \"bar\" is required")
		}
		return barFunc(*u.bar)
	}
}

func (u *StalenessVisualisationWithT[T]) RawNoopSuccess(NumericRawVisualisationV2) (T, error) {
	var result T
	return result, nil
}

func (u *StalenessVisualisationWithT[T]) BarNoopSuccess(NumericBarVisualisationV2) (T, error) {
	var result T
	return result, nil
}

func (u *StalenessVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type StalenessVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v NumericRawVisualisationV2) (T, error)
	VisitBar(ctx context.Context, v NumericBarVisualisationV2) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type StructVisualisationWithT[T any] StructVisualisation

func (u *StructVisualisationWithT[T]) Accept(ctx context.Context, v StructVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *StructVisualisationWithT[T]) AcceptFuncs(rawFunc func(StructRawVisualisation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *StructVisualisationWithT[T]) RawNoopSuccess(StructRawVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *StructVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type StructVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v StructRawVisualisation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimeSeriesChartDefinitionWithT[T any] TimeSeriesChartDefinition

func (u *TimeSeriesChartDefinitionWithT[T]) Accept(ctx context.Context, v TimeSeriesChartDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *TimeSeriesChartDefinitionWithT[T]) AcceptFuncs(v1Func func(TimeSeriesChartDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *TimeSeriesChartDefinitionWithT[T]) V1NoopSuccess(TimeSeriesChartDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *TimeSeriesChartDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimeSeriesChartDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v TimeSeriesChartDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimeSeriesPlotConfigWithT[T any] TimeSeriesPlotConfig

func (u *TimeSeriesPlotConfigWithT[T]) Accept(ctx context.Context, v TimeSeriesPlotConfigVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(ctx, *u.range_)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	}
}

func (u *TimeSeriesPlotConfigWithT[T]) AcceptFuncs(numericFunc func(TimeSeriesNumericPlot) (T, error), range_Func func(TimeSeriesRangePlot) (T, error), enumFunc func(TimeSeriesEnumPlot) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	}
}

func (u *TimeSeriesPlotConfigWithT[T]) NumericNoopSuccess(TimeSeriesNumericPlot) (T, error) {
	var result T
	return result, nil
}

func (u *TimeSeriesPlotConfigWithT[T]) RangeNoopSuccess(TimeSeriesRangePlot) (T, error) {
	var result T
	return result, nil
}

func (u *TimeSeriesPlotConfigWithT[T]) EnumNoopSuccess(TimeSeriesEnumPlot) (T, error) {
	var result T
	return result, nil
}

func (u *TimeSeriesPlotConfigWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimeSeriesPlotConfigVisitorWithT[T any] interface {
	VisitNumeric(ctx context.Context, v TimeSeriesNumericPlot) (T, error)
	VisitRange(ctx context.Context, v TimeSeriesRangePlot) (T, error)
	VisitEnum(ctx context.Context, v TimeSeriesEnumPlot) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TraceComputeConfigWithT[T any] TraceComputeConfig

func (u *TraceComputeConfigWithT[T]) Accept(ctx context.Context, v TraceComputeConfigVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return result, fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3d(ctx, *u.scatter3d)
	}
}

func (u *TraceComputeConfigWithT[T]) AcceptFuncs(scatter3dFunc func(Scatter3dTraceComputeConfig) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return result, fmt.Errorf("field \"scatter3d\" is required")
		}
		return scatter3dFunc(*u.scatter3d)
	}
}

func (u *TraceComputeConfigWithT[T]) Scatter3dNoopSuccess(Scatter3dTraceComputeConfig) (T, error) {
	var result T
	return result, nil
}

func (u *TraceComputeConfigWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TraceComputeConfigVisitorWithT[T any] interface {
	VisitScatter3d(ctx context.Context, v Scatter3dTraceComputeConfig) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ValueTableCellConfigWithT[T any] ValueTableCellConfig

func (u *ValueTableCellConfigWithT[T]) Accept(ctx context.Context, v ValueTableCellConfigVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(ctx, *u.range_)
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return result, fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return v.VisitBitFlagMap(ctx, *u.bitFlagMap)
	case "staleness":
		if u.staleness == nil {
			return result, fmt.Errorf("field \"staleness\" is required")
		}
		return v.VisitStaleness(ctx, *u.staleness)
	case "numericArray":
		if u.numericArray == nil {
			return result, fmt.Errorf("field \"numericArray\" is required")
		}
		return v.VisitNumericArray(ctx, *u.numericArray)
	case "enumArray":
		if u.enumArray == nil {
			return result, fmt.Errorf("field \"enumArray\" is required")
		}
		return v.VisitEnumArray(ctx, *u.enumArray)
	case "struct":
		if u.struct_ == nil {
			return result, fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStruct(ctx, *u.struct_)
	}
}

func (u *ValueTableCellConfigWithT[T]) AcceptFuncs(numericFunc func(NumericCellConfig) (T, error), enumFunc func(EnumCellConfig) (T, error), range_Func func(RangeCellConfig) (T, error), bitFlagMapFunc func(BitFlagMapCellConfig) (T, error), stalenessFunc func(StalenessCellConfig) (T, error), numericArrayFunc func(NumericArrayCellConfig) (T, error), enumArrayFunc func(EnumArrayCellConfig) (T, error), struct_Func func(StructCellConfig) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return result, fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return bitFlagMapFunc(*u.bitFlagMap)
	case "staleness":
		if u.staleness == nil {
			return result, fmt.Errorf("field \"staleness\" is required")
		}
		return stalenessFunc(*u.staleness)
	case "numericArray":
		if u.numericArray == nil {
			return result, fmt.Errorf("field \"numericArray\" is required")
		}
		return numericArrayFunc(*u.numericArray)
	case "enumArray":
		if u.enumArray == nil {
			return result, fmt.Errorf("field \"enumArray\" is required")
		}
		return enumArrayFunc(*u.enumArray)
	case "struct":
		if u.struct_ == nil {
			return result, fmt.Errorf("field \"struct\" is required")
		}
		return struct_Func(*u.struct_)
	}
}

func (u *ValueTableCellConfigWithT[T]) NumericNoopSuccess(NumericCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) EnumNoopSuccess(EnumCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) RangeNoopSuccess(RangeCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) BitFlagMapNoopSuccess(BitFlagMapCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) StalenessNoopSuccess(StalenessCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) NumericArrayNoopSuccess(NumericArrayCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) EnumArrayNoopSuccess(EnumArrayCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) StructNoopSuccess(StructCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ValueTableCellConfigVisitorWithT[T any] interface {
	VisitNumeric(ctx context.Context, v NumericCellConfig) (T, error)
	VisitEnum(ctx context.Context, v EnumCellConfig) (T, error)
	VisitRange(ctx context.Context, v RangeCellConfig) (T, error)
	VisitBitFlagMap(ctx context.Context, v BitFlagMapCellConfig) (T, error)
	VisitStaleness(ctx context.Context, v StalenessCellConfig) (T, error)
	VisitNumericArray(ctx context.Context, v NumericArrayCellConfig) (T, error)
	VisitEnumArray(ctx context.Context, v EnumArrayCellConfig) (T, error)
	VisitStruct(ctx context.Context, v StructCellConfig) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ValueTableChannelWithT[T any] ValueTableChannel

func (u *ValueTableChannelWithT[T]) Accept(ctx context.Context, v ValueTableChannelVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(ctx, *u.range_)
	}
}

func (u *ValueTableChannelWithT[T]) AcceptFuncs(numericFunc func(NumericValueChannel) (T, error), enumFunc func(EnumValueChannel) (T, error), range_Func func(RangeValueChannel) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	}
}

func (u *ValueTableChannelWithT[T]) NumericNoopSuccess(NumericValueChannel) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableChannelWithT[T]) EnumNoopSuccess(EnumValueChannel) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableChannelWithT[T]) RangeNoopSuccess(RangeValueChannel) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableChannelWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ValueTableChannelVisitorWithT[T any] interface {
	VisitNumeric(ctx context.Context, v NumericValueChannel) (T, error)
	VisitEnum(ctx context.Context, v EnumValueChannel) (T, error)
	VisitRange(ctx context.Context, v RangeValueChannel) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ValueTableDefinitionWithT[T any] ValueTableDefinition

func (u *ValueTableDefinitionWithT[T]) Accept(ctx context.Context, v ValueTableDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(ctx, *u.v2)
	}
}

func (u *ValueTableDefinitionWithT[T]) AcceptFuncs(v1Func func(ValueTableDefinitionV1) (T, error), v2Func func(ValueTableDefinitionV2) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *ValueTableDefinitionWithT[T]) V1NoopSuccess(ValueTableDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableDefinitionWithT[T]) V2NoopSuccess(ValueTableDefinitionV2) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ValueTableDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v ValueTableDefinitionV1) (T, error)
	VisitV2(ctx context.Context, v ValueTableDefinitionV2) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ValueTableLayoutWithT[T any] ValueTableLayout

func (u *ValueTableLayoutWithT[T]) Accept(ctx context.Context, v ValueTableLayoutVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "grid":
		if u.grid == nil {
			return result, fmt.Errorf("field \"grid\" is required")
		}
		return v.VisitGrid(ctx, *u.grid)
	}
}

func (u *ValueTableLayoutWithT[T]) AcceptFuncs(gridFunc func(ValueTableLayoutGrid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "grid":
		if u.grid == nil {
			return result, fmt.Errorf("field \"grid\" is required")
		}
		return gridFunc(*u.grid)
	}
}

func (u *ValueTableLayoutWithT[T]) GridNoopSuccess(ValueTableLayoutGrid) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableLayoutWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ValueTableLayoutVisitorWithT[T any] interface {
	VisitGrid(ctx context.Context, v ValueTableLayoutGrid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ValueToColorMapWithT[T any] ValueToColorMap

func (u *ValueToColorMapWithT[T]) Accept(ctx context.Context, v ValueToColorMapVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	}
}

func (u *ValueToColorMapWithT[T]) AcceptFuncs(numericFunc func(map[api.HexColor]float64) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	}
}

func (u *ValueToColorMapWithT[T]) NumericNoopSuccess(map[api.HexColor]float64) (T, error) {
	var result T
	return result, nil
}

func (u *ValueToColorMapWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ValueToColorMapVisitorWithT[T any] interface {
	VisitNumeric(ctx context.Context, v map[api.HexColor]float64) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VideoVizDefinitionWithT[T any] VideoVizDefinition

func (u *VideoVizDefinitionWithT[T]) Accept(ctx context.Context, v VideoVizDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(ctx, *u.v2)
	}
}

func (u *VideoVizDefinitionWithT[T]) AcceptFuncs(v1Func func(VideoVizDefinitionV1) (T, error), v2Func func(VideoVizDefinitionV2) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *VideoVizDefinitionWithT[T]) V1NoopSuccess(VideoVizDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *VideoVizDefinitionWithT[T]) V2NoopSuccess(VideoVizDefinitionV2) (T, error) {
	var result T
	return result, nil
}

func (u *VideoVizDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VideoVizDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v VideoVizDefinitionV1) (T, error)
	VisitV2(ctx context.Context, v VideoVizDefinitionV2) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VizDefinitionWithT[T any] VizDefinition

func (u *VizDefinitionWithT[T]) Accept(ctx context.Context, v VizDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(ctx, *u.cartesian)
	case "checklist":
		if u.checklist == nil {
			return result, fmt.Errorf("field \"checklist\" is required")
		}
		return v.VisitChecklist(ctx, *u.checklist)
	case "frequency":
		if u.frequency == nil {
			return result, fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequency(ctx, *u.frequency)
	case "geo":
		if u.geo == nil {
			return result, fmt.Errorf("field \"geo\" is required")
		}
		return v.VisitGeo(ctx, *u.geo)
	case "geo3d":
		if u.geo3d == nil {
			return result, fmt.Errorf("field \"geo3d\" is required")
		}
		return v.VisitGeo3d(ctx, *u.geo3d)
	case "histogram":
		if u.histogram == nil {
			return result, fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogram(ctx, *u.histogram)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(ctx, *u.log)
	case "plotly":
		if u.plotly == nil {
			return result, fmt.Errorf("field \"plotly\" is required")
		}
		return v.VisitPlotly(ctx, *u.plotly)
	case "timeSeries":
		if u.timeSeries == nil {
			return result, fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeries(ctx, *u.timeSeries)
	case "valueTable":
		if u.valueTable == nil {
			return result, fmt.Errorf("field \"valueTable\" is required")
		}
		return v.VisitValueTable(ctx, *u.valueTable)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(ctx, *u.video)
	case "procedure":
		if u.procedure == nil {
			return result, fmt.Errorf("field \"procedure\" is required")
		}
		return v.VisitProcedure(ctx, *u.procedure)
	}
}

func (u *VizDefinitionWithT[T]) AcceptFuncs(cartesianFunc func(CartesianChartDefinition) (T, error), checklistFunc func(ChecklistChartDefinition) (T, error), frequencyFunc func(FrequencyChartDefinition) (T, error), geoFunc func(GeoVizDefinition) (T, error), geo3dFunc func(Geo3dDefinition) (T, error), histogramFunc func(HistogramChartDefinition) (T, error), logFunc func(LogPanelDefinition) (T, error), plotlyFunc func(PlotlyPanelDefinition) (T, error), timeSeriesFunc func(TimeSeriesChartDefinition) (T, error), valueTableFunc func(ValueTableDefinition) (T, error), videoFunc func(VideoVizDefinition) (T, error), procedureFunc func(ProcedureVizDefinition) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "checklist":
		if u.checklist == nil {
			return result, fmt.Errorf("field \"checklist\" is required")
		}
		return checklistFunc(*u.checklist)
	case "frequency":
		if u.frequency == nil {
			return result, fmt.Errorf("field \"frequency\" is required")
		}
		return frequencyFunc(*u.frequency)
	case "geo":
		if u.geo == nil {
			return result, fmt.Errorf("field \"geo\" is required")
		}
		return geoFunc(*u.geo)
	case "geo3d":
		if u.geo3d == nil {
			return result, fmt.Errorf("field \"geo3d\" is required")
		}
		return geo3dFunc(*u.geo3d)
	case "histogram":
		if u.histogram == nil {
			return result, fmt.Errorf("field \"histogram\" is required")
		}
		return histogramFunc(*u.histogram)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "plotly":
		if u.plotly == nil {
			return result, fmt.Errorf("field \"plotly\" is required")
		}
		return plotlyFunc(*u.plotly)
	case "timeSeries":
		if u.timeSeries == nil {
			return result, fmt.Errorf("field \"timeSeries\" is required")
		}
		return timeSeriesFunc(*u.timeSeries)
	case "valueTable":
		if u.valueTable == nil {
			return result, fmt.Errorf("field \"valueTable\" is required")
		}
		return valueTableFunc(*u.valueTable)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	case "procedure":
		if u.procedure == nil {
			return result, fmt.Errorf("field \"procedure\" is required")
		}
		return procedureFunc(*u.procedure)
	}
}

func (u *VizDefinitionWithT[T]) CartesianNoopSuccess(CartesianChartDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) ChecklistNoopSuccess(ChecklistChartDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) FrequencyNoopSuccess(FrequencyChartDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) GeoNoopSuccess(GeoVizDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) Geo3dNoopSuccess(Geo3dDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) HistogramNoopSuccess(HistogramChartDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) LogNoopSuccess(LogPanelDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) PlotlyNoopSuccess(PlotlyPanelDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) TimeSeriesNoopSuccess(TimeSeriesChartDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) ValueTableNoopSuccess(ValueTableDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) VideoNoopSuccess(VideoVizDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) ProcedureNoopSuccess(ProcedureVizDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VizDefinitionVisitorWithT[T any] interface {
	VisitCartesian(ctx context.Context, v CartesianChartDefinition) (T, error)
	VisitChecklist(ctx context.Context, v ChecklistChartDefinition) (T, error)
	VisitFrequency(ctx context.Context, v FrequencyChartDefinition) (T, error)
	VisitGeo(ctx context.Context, v GeoVizDefinition) (T, error)
	VisitGeo3d(ctx context.Context, v Geo3dDefinition) (T, error)
	VisitHistogram(ctx context.Context, v HistogramChartDefinition) (T, error)
	VisitLog(ctx context.Context, v LogPanelDefinition) (T, error)
	VisitPlotly(ctx context.Context, v PlotlyPanelDefinition) (T, error)
	VisitTimeSeries(ctx context.Context, v TimeSeriesChartDefinition) (T, error)
	VisitValueTable(ctx context.Context, v ValueTableDefinition) (T, error)
	VisitVideo(ctx context.Context, v VideoVizDefinition) (T, error)
	VisitProcedure(ctx context.Context, v ProcedureVizDefinition) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
