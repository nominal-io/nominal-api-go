// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/scout/api"
)

type AxisThresholdGroupWithT[T any] AxisThresholdGroup

func (u *AxisThresholdGroupWithT[T]) Accept(ctx context.Context, v AxisThresholdGroupVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return result, fmt.Errorf("field \"lineThresholds\" is required")
		}
		return v.VisitLineThresholds(ctx, *u.lineThresholds)
	}
}

func (u *AxisThresholdGroupWithT[T]) AcceptFuncs(lineThresholdsFunc func(LineThresholdGroup) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "lineThresholds":
		if u.lineThresholds == nil {
			return result, fmt.Errorf("field \"lineThresholds\" is required")
		}
		return lineThresholdsFunc(*u.lineThresholds)
	}
}

func (u *AxisThresholdGroupWithT[T]) LineThresholdsNoopSuccess(LineThresholdGroup) (T, error) {
	var result T
	return result, nil
}

func (u *AxisThresholdGroupWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type AxisThresholdGroupVisitorWithT[T any] interface {
	VisitLineThresholds(ctx context.Context, v LineThresholdGroup) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type BitFlagMapVisualisationWithT[T any] BitFlagMapVisualisation

func (u *BitFlagMapVisualisationWithT[T]) Accept(ctx context.Context, v BitFlagMapVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *BitFlagMapVisualisationWithT[T]) AcceptFuncs(rawFunc func(BitFlagMapRawVisualisation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *BitFlagMapVisualisationWithT[T]) RawNoopSuccess(BitFlagMapRawVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *BitFlagMapVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type BitFlagMapVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v BitFlagMapRawVisualisation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CartesianChartDefinitionWithT[T any] CartesianChartDefinition

func (u *CartesianChartDefinitionWithT[T]) Accept(ctx context.Context, v CartesianChartDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *CartesianChartDefinitionWithT[T]) AcceptFuncs(v1Func func(CartesianChartDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *CartesianChartDefinitionWithT[T]) V1NoopSuccess(CartesianChartDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *CartesianChartDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CartesianChartDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v CartesianChartDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ChecklistChartDefinitionWithT[T any] ChecklistChartDefinition

func (u *ChecklistChartDefinitionWithT[T]) Accept(ctx context.Context, v ChecklistChartDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *ChecklistChartDefinitionWithT[T]) AcceptFuncs(v1Func func(ChecklistChartDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ChecklistChartDefinitionWithT[T]) V1NoopSuccess(ChecklistChartDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistChartDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ChecklistChartDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v ChecklistChartDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ColorStyleWithT[T any] ColorStyle

func (u *ColorStyleWithT[T]) Accept(ctx context.Context, v ColorStyleVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "mapped":
		if u.mapped == nil {
			return result, fmt.Errorf("field \"mapped\" is required")
		}
		return v.VisitMapped(ctx, *u.mapped)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return v.VisitSingle(ctx, *u.single)
	}
}

func (u *ColorStyleWithT[T]) AcceptFuncs(mappedFunc func(map[string]api.HexColor) (T, error), singleFunc func(api.HexColor) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "mapped":
		if u.mapped == nil {
			return result, fmt.Errorf("field \"mapped\" is required")
		}
		return mappedFunc(*u.mapped)
	case "single":
		if u.single == nil {
			return result, fmt.Errorf("field \"single\" is required")
		}
		return singleFunc(*u.single)
	}
}

func (u *ColorStyleWithT[T]) MappedNoopSuccess(map[string]api.HexColor) (T, error) {
	var result T
	return result, nil
}

func (u *ColorStyleWithT[T]) SingleNoopSuccess(api.HexColor) (T, error) {
	var result T
	return result, nil
}

func (u *ColorStyleWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ColorStyleVisitorWithT[T any] interface {
	VisitMapped(ctx context.Context, v map[string]api.HexColor) (T, error)
	VisitSingle(ctx context.Context, v api.HexColor) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type DisconnectedValueVisualizationWithT[T any] DisconnectedValueVisualization

func (u *DisconnectedValueVisualizationWithT[T]) Accept(ctx context.Context, v DisconnectedValueVisualizationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return result, fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return v.VisitAlwaysConnect(ctx, *u.alwaysConnect)
	case "never":
		if u.never == nil {
			return result, fmt.Errorf("field \"never\" is required")
		}
		return v.VisitNever(ctx, *u.never)
	case "threshold":
		if u.threshold == nil {
			return result, fmt.Errorf("field \"threshold\" is required")
		}
		return v.VisitThreshold(ctx, *u.threshold)
	}
}

func (u *DisconnectedValueVisualizationWithT[T]) AcceptFuncs(alwaysConnectFunc func(AlwaysConnectDisconnectedValues) (T, error), neverFunc func(NeverConnectDisconnectedValues) (T, error), thresholdFunc func(ThresholdDisconnectedValues) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "alwaysConnect":
		if u.alwaysConnect == nil {
			return result, fmt.Errorf("field \"alwaysConnect\" is required")
		}
		return alwaysConnectFunc(*u.alwaysConnect)
	case "never":
		if u.never == nil {
			return result, fmt.Errorf("field \"never\" is required")
		}
		return neverFunc(*u.never)
	case "threshold":
		if u.threshold == nil {
			return result, fmt.Errorf("field \"threshold\" is required")
		}
		return thresholdFunc(*u.threshold)
	}
}

func (u *DisconnectedValueVisualizationWithT[T]) AlwaysConnectNoopSuccess(AlwaysConnectDisconnectedValues) (T, error) {
	var result T
	return result, nil
}

func (u *DisconnectedValueVisualizationWithT[T]) NeverNoopSuccess(NeverConnectDisconnectedValues) (T, error) {
	var result T
	return result, nil
}

func (u *DisconnectedValueVisualizationWithT[T]) ThresholdNoopSuccess(ThresholdDisconnectedValues) (T, error) {
	var result T
	return result, nil
}

func (u *DisconnectedValueVisualizationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DisconnectedValueVisualizationVisitorWithT[T any] interface {
	VisitAlwaysConnect(ctx context.Context, v AlwaysConnectDisconnectedValues) (T, error)
	VisitNever(ctx context.Context, v NeverConnectDisconnectedValues) (T, error)
	VisitThreshold(ctx context.Context, v ThresholdDisconnectedValues) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EnumGroupBySortWithT[T any] EnumGroupBySort

func (u *EnumGroupBySortWithT[T]) Accept(ctx context.Context, v EnumGroupBySortVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "custom":
		if u.custom == nil {
			return result, fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(ctx, *u.custom)
	case "alphabetical":
		if u.alphabetical == nil {
			return result, fmt.Errorf("field \"alphabetical\" is required")
		}
		return v.VisitAlphabetical(ctx, *u.alphabetical)
	}
}

func (u *EnumGroupBySortWithT[T]) AcceptFuncs(customFunc func(EnumGroupBySortCustom) (T, error), alphabeticalFunc func(ValueSort) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "custom":
		if u.custom == nil {
			return result, fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	case "alphabetical":
		if u.alphabetical == nil {
			return result, fmt.Errorf("field \"alphabetical\" is required")
		}
		return alphabeticalFunc(*u.alphabetical)
	}
}

func (u *EnumGroupBySortWithT[T]) CustomNoopSuccess(EnumGroupBySortCustom) (T, error) {
	var result T
	return result, nil
}

func (u *EnumGroupBySortWithT[T]) AlphabeticalNoopSuccess(ValueSort) (T, error) {
	var result T
	return result, nil
}

func (u *EnumGroupBySortWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EnumGroupBySortVisitorWithT[T any] interface {
	VisitCustom(ctx context.Context, v EnumGroupBySortCustom) (T, error)
	VisitAlphabetical(ctx context.Context, v ValueSort) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EnumValueVisualisationWithT[T any] EnumValueVisualisation

func (u *EnumValueVisualisationWithT[T]) Accept(ctx context.Context, v EnumValueVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *EnumValueVisualisationWithT[T]) AcceptFuncs(rawFunc func(EnumRawVisualisation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *EnumValueVisualisationWithT[T]) RawNoopSuccess(EnumRawVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *EnumValueVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EnumValueVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v EnumRawVisualisation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FrequencyChartDefinitionWithT[T any] FrequencyChartDefinition

func (u *FrequencyChartDefinitionWithT[T]) Accept(ctx context.Context, v FrequencyChartDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *FrequencyChartDefinitionWithT[T]) AcceptFuncs(v1Func func(FrequencyChartDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *FrequencyChartDefinitionWithT[T]) V1NoopSuccess(FrequencyChartDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *FrequencyChartDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FrequencyChartDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v FrequencyChartDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dDefinitionWithT[T any] Geo3dDefinition

func (u *Geo3dDefinitionWithT[T]) Accept(ctx context.Context, v Geo3dDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *Geo3dDefinitionWithT[T]) AcceptFuncs(v1Func func(Geo3dDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *Geo3dDefinitionWithT[T]) V1NoopSuccess(Geo3dDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v Geo3dDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dModelWithT[T any] Geo3dModel

func (u *Geo3dModelWithT[T]) Accept(ctx context.Context, v Geo3dModelVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "default":
		if u.default_ == nil {
			return result, fmt.Errorf("field \"default\" is required")
		}
		return v.VisitDefault(ctx, *u.default_)
	case "custom":
		if u.custom == nil {
			return result, fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(ctx, *u.custom)
	}
}

func (u *Geo3dModelWithT[T]) AcceptFuncs(default_Func func(Geo3dDefaultModel) (T, error), customFunc func(Geo3dCustomModel) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "default":
		if u.default_ == nil {
			return result, fmt.Errorf("field \"default\" is required")
		}
		return default_Func(*u.default_)
	case "custom":
		if u.custom == nil {
			return result, fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	}
}

func (u *Geo3dModelWithT[T]) DefaultNoopSuccess(Geo3dDefaultModel) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dModelWithT[T]) CustomNoopSuccess(Geo3dCustomModel) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dModelWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dModelVisitorWithT[T any] interface {
	VisitDefault(ctx context.Context, v Geo3dDefaultModel) (T, error)
	VisitCustom(ctx context.Context, v Geo3dCustomModel) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dOrientationWithT[T any] Geo3dOrientation

func (u *Geo3dOrientationWithT[T]) Accept(ctx context.Context, v Geo3dOrientationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return result, fmt.Errorf("field \"principalAxes\" is required")
		}
		return v.VisitPrincipalAxes(ctx, *u.principalAxes)
	}
}

func (u *Geo3dOrientationWithT[T]) AcceptFuncs(principalAxesFunc func(Geo3dOrientationPrincipalAxes) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "principalAxes":
		if u.principalAxes == nil {
			return result, fmt.Errorf("field \"principalAxes\" is required")
		}
		return principalAxesFunc(*u.principalAxes)
	}
}

func (u *Geo3dOrientationWithT[T]) PrincipalAxesNoopSuccess(Geo3dOrientationPrincipalAxes) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dOrientationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dOrientationVisitorWithT[T any] interface {
	VisitPrincipalAxes(ctx context.Context, v Geo3dOrientationPrincipalAxes) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type Geo3dPositionWithT[T any] Geo3dPosition

func (u *Geo3dPositionWithT[T]) Accept(ctx context.Context, v Geo3dPositionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return result, fmt.Errorf("field \"wgs84\" is required")
		}
		return v.VisitWgs84(ctx, *u.wgs84)
	}
}

func (u *Geo3dPositionWithT[T]) AcceptFuncs(wgs84Func func(Geo3dPositionWgs84) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "wgs84":
		if u.wgs84 == nil {
			return result, fmt.Errorf("field \"wgs84\" is required")
		}
		return wgs84Func(*u.wgs84)
	}
}

func (u *Geo3dPositionWithT[T]) Wgs84NoopSuccess(Geo3dPositionWgs84) (T, error) {
	var result T
	return result, nil
}

func (u *Geo3dPositionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type Geo3dPositionVisitorWithT[T any] interface {
	VisitWgs84(ctx context.Context, v Geo3dPositionWgs84) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type GeoCustomFeatureWithT[T any] GeoCustomFeature

func (u *GeoCustomFeatureWithT[T]) Accept(ctx context.Context, v GeoCustomFeatureVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "point":
		if u.point == nil {
			return result, fmt.Errorf("field \"point\" is required")
		}
		return v.VisitPoint(ctx, *u.point)
	}
}

func (u *GeoCustomFeatureWithT[T]) AcceptFuncs(pointFunc func(GeoPoint) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "point":
		if u.point == nil {
			return result, fmt.Errorf("field \"point\" is required")
		}
		return pointFunc(*u.point)
	}
}

func (u *GeoCustomFeatureWithT[T]) PointNoopSuccess(GeoPoint) (T, error) {
	var result T
	return result, nil
}

func (u *GeoCustomFeatureWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type GeoCustomFeatureVisitorWithT[T any] interface {
	VisitPoint(ctx context.Context, v GeoPoint) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type GeoSecondaryPlotVisualizationOptionWithT[T any] GeoSecondaryPlotVisualizationOption

func (u *GeoSecondaryPlotVisualizationOptionWithT[T]) Accept(ctx context.Context, v GeoSecondaryPlotVisualizationOptionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "asColors":
		if u.asColors == nil {
			return result, fmt.Errorf("field \"asColors\" is required")
		}
		return v.VisitAsColors(ctx, *u.asColors)
	}
}

func (u *GeoSecondaryPlotVisualizationOptionWithT[T]) AcceptFuncs(asColorsFunc func(ValueToColorMap) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "asColors":
		if u.asColors == nil {
			return result, fmt.Errorf("field \"asColors\" is required")
		}
		return asColorsFunc(*u.asColors)
	}
}

func (u *GeoSecondaryPlotVisualizationOptionWithT[T]) AsColorsNoopSuccess(ValueToColorMap) (T, error) {
	var result T
	return result, nil
}

func (u *GeoSecondaryPlotVisualizationOptionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type GeoSecondaryPlotVisualizationOptionVisitorWithT[T any] interface {
	VisitAsColors(ctx context.Context, v ValueToColorMap) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type GeoVizDefinitionWithT[T any] GeoVizDefinition

func (u *GeoVizDefinitionWithT[T]) Accept(ctx context.Context, v GeoVizDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *GeoVizDefinitionWithT[T]) AcceptFuncs(v1Func func(GeoVizDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *GeoVizDefinitionWithT[T]) V1NoopSuccess(GeoVizDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *GeoVizDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type GeoVizDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v GeoVizDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type HistogramChartDefinitionWithT[T any] HistogramChartDefinition

func (u *HistogramChartDefinitionWithT[T]) Accept(ctx context.Context, v HistogramChartDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *HistogramChartDefinitionWithT[T]) AcceptFuncs(v1Func func(HistogramChartDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *HistogramChartDefinitionWithT[T]) V1NoopSuccess(HistogramChartDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *HistogramChartDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type HistogramChartDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v HistogramChartDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type LineStyleWithT[T any] LineStyle

func (u *LineStyleWithT[T]) Accept(ctx context.Context, v LineStyleVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *LineStyleWithT[T]) AcceptFuncs(v1Func func(LineStyleV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *LineStyleWithT[T]) V1NoopSuccess(LineStyleV1) (T, error) {
	var result T
	return result, nil
}

func (u *LineStyleWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LineStyleVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v LineStyleV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type LogPanelDefinitionWithT[T any] LogPanelDefinition

func (u *LogPanelDefinitionWithT[T]) Accept(ctx context.Context, v LogPanelDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *LogPanelDefinitionWithT[T]) AcceptFuncs(v1Func func(LogPanelDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *LogPanelDefinitionWithT[T]) V1NoopSuccess(LogPanelDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *LogPanelDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LogPanelDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v LogPanelDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericGroupBySortWithT[T any] NumericGroupBySort

func (u *NumericGroupBySortWithT[T]) Accept(ctx context.Context, v NumericGroupBySortVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(ctx, *u.value)
	}
}

func (u *NumericGroupBySortWithT[T]) AcceptFuncs(valueFunc func(ValueSort) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *NumericGroupBySortWithT[T]) ValueNoopSuccess(ValueSort) (T, error) {
	var result T
	return result, nil
}

func (u *NumericGroupBySortWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericGroupBySortVisitorWithT[T any] interface {
	VisitValue(ctx context.Context, v ValueSort) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericValueVisualisationWithT[T any] NumericValueVisualisation

func (u *NumericValueVisualisationWithT[T]) Accept(ctx context.Context, v NumericValueVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "barGauge":
		if u.barGauge == nil {
			return result, fmt.Errorf("field \"barGauge\" is required")
		}
		return v.VisitBarGauge(ctx, *u.barGauge)
	}
}

func (u *NumericValueVisualisationWithT[T]) AcceptFuncs(rawFunc func(NumericRawVisualisation) (T, error), barGaugeFunc func(NumericBarGaugeVisualisation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "barGauge":
		if u.barGauge == nil {
			return result, fmt.Errorf("field \"barGauge\" is required")
		}
		return barGaugeFunc(*u.barGauge)
	}
}

func (u *NumericValueVisualisationWithT[T]) RawNoopSuccess(NumericRawVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *NumericValueVisualisationWithT[T]) BarGaugeNoopSuccess(NumericBarGaugeVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *NumericValueVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericValueVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v NumericRawVisualisation) (T, error)
	VisitBarGauge(ctx context.Context, v NumericBarGaugeVisualisation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NumericValueVisualisationV2WithT[T any] NumericValueVisualisationV2

func (u *NumericValueVisualisationV2WithT[T]) Accept(ctx context.Context, v NumericValueVisualisationV2VisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	case "bar":
		if u.bar == nil {
			return result, fmt.Errorf("field \"bar\" is required")
		}
		return v.VisitBar(ctx, *u.bar)
	}
}

func (u *NumericValueVisualisationV2WithT[T]) AcceptFuncs(rawFunc func(NumericRawVisualisationV2) (T, error), barFunc func(NumericBarVisualisationV2) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	case "bar":
		if u.bar == nil {
			return result, fmt.Errorf("field \"bar\" is required")
		}
		return barFunc(*u.bar)
	}
}

func (u *NumericValueVisualisationV2WithT[T]) RawNoopSuccess(NumericRawVisualisationV2) (T, error) {
	var result T
	return result, nil
}

func (u *NumericValueVisualisationV2WithT[T]) BarNoopSuccess(NumericBarVisualisationV2) (T, error) {
	var result T
	return result, nil
}

func (u *NumericValueVisualisationV2WithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NumericValueVisualisationV2VisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v NumericRawVisualisationV2) (T, error)
	VisitBar(ctx context.Context, v NumericBarVisualisationV2) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PersistValueOverlayWithT[T any] PersistValueOverlay

func (u *PersistValueOverlayWithT[T]) Accept(ctx context.Context, v PersistValueOverlayVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "byValue":
		if u.byValue == nil {
			return result, fmt.Errorf("field \"byValue\" is required")
		}
		return v.VisitByValue(ctx, *u.byValue)
	case "all":
		if u.all == nil {
			return result, fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAll(ctx, *u.all)
	}
}

func (u *PersistValueOverlayWithT[T]) AcceptFuncs(byValueFunc func(PersistByValue) (T, error), allFunc func(PersistAll) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "byValue":
		if u.byValue == nil {
			return result, fmt.Errorf("field \"byValue\" is required")
		}
		return byValueFunc(*u.byValue)
	case "all":
		if u.all == nil {
			return result, fmt.Errorf("field \"all\" is required")
		}
		return allFunc(*u.all)
	}
}

func (u *PersistValueOverlayWithT[T]) ByValueNoopSuccess(PersistByValue) (T, error) {
	var result T
	return result, nil
}

func (u *PersistValueOverlayWithT[T]) AllNoopSuccess(PersistAll) (T, error) {
	var result T
	return result, nil
}

func (u *PersistValueOverlayWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PersistValueOverlayVisitorWithT[T any] interface {
	VisitByValue(ctx context.Context, v PersistByValue) (T, error)
	VisitAll(ctx context.Context, v PersistAll) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PlotlyPanelDefinitionWithT[T any] PlotlyPanelDefinition

func (u *PlotlyPanelDefinitionWithT[T]) Accept(ctx context.Context, v PlotlyPanelDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *PlotlyPanelDefinitionWithT[T]) AcceptFuncs(v1Func func(PlotlyPanelDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *PlotlyPanelDefinitionWithT[T]) V1NoopSuccess(PlotlyPanelDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *PlotlyPanelDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PlotlyPanelDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v PlotlyPanelDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ProcedureVizDefinitionWithT[T any] ProcedureVizDefinition

func (u *ProcedureVizDefinitionWithT[T]) Accept(ctx context.Context, v ProcedureVizDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *ProcedureVizDefinitionWithT[T]) AcceptFuncs(v1Func func(ProcedureVizDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ProcedureVizDefinitionWithT[T]) V1NoopSuccess(ProcedureVizDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *ProcedureVizDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ProcedureVizDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v ProcedureVizDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type RangeGroupBySortWithT[T any] RangeGroupBySort

func (u *RangeGroupBySortWithT[T]) Accept(ctx context.Context, v RangeGroupBySortVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(ctx, *u.value)
	}
}

func (u *RangeGroupBySortWithT[T]) AcceptFuncs(valueFunc func(ValueSort) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *RangeGroupBySortWithT[T]) ValueNoopSuccess(ValueSort) (T, error) {
	var result T
	return result, nil
}

func (u *RangeGroupBySortWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type RangeGroupBySortVisitorWithT[T any] interface {
	VisitValue(ctx context.Context, v ValueSort) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type RangeValueVisualisationWithT[T any] RangeValueVisualisation

func (u *RangeValueVisualisationWithT[T]) Accept(ctx context.Context, v RangeValueVisualisationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return v.VisitRaw(ctx, *u.raw)
	}
}

func (u *RangeValueVisualisationWithT[T]) AcceptFuncs(rawFunc func(RangeRawVisualisation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "raw":
		if u.raw == nil {
			return result, fmt.Errorf("field \"raw\" is required")
		}
		return rawFunc(*u.raw)
	}
}

func (u *RangeValueVisualisationWithT[T]) RawNoopSuccess(RangeRawVisualisation) (T, error) {
	var result T
	return result, nil
}

func (u *RangeValueVisualisationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type RangeValueVisualisationVisitorWithT[T any] interface {
	VisitRaw(ctx context.Context, v RangeRawVisualisation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimeSeriesChartDefinitionWithT[T any] TimeSeriesChartDefinition

func (u *TimeSeriesChartDefinitionWithT[T]) Accept(ctx context.Context, v TimeSeriesChartDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *TimeSeriesChartDefinitionWithT[T]) AcceptFuncs(v1Func func(TimeSeriesChartDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *TimeSeriesChartDefinitionWithT[T]) V1NoopSuccess(TimeSeriesChartDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *TimeSeriesChartDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimeSeriesChartDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v TimeSeriesChartDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimeSeriesPlotConfigWithT[T any] TimeSeriesPlotConfig

func (u *TimeSeriesPlotConfigWithT[T]) Accept(ctx context.Context, v TimeSeriesPlotConfigVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(ctx, *u.range_)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	}
}

func (u *TimeSeriesPlotConfigWithT[T]) AcceptFuncs(numericFunc func(TimeSeriesNumericPlot) (T, error), range_Func func(TimeSeriesRangePlot) (T, error), enumFunc func(TimeSeriesEnumPlot) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	}
}

func (u *TimeSeriesPlotConfigWithT[T]) NumericNoopSuccess(TimeSeriesNumericPlot) (T, error) {
	var result T
	return result, nil
}

func (u *TimeSeriesPlotConfigWithT[T]) RangeNoopSuccess(TimeSeriesRangePlot) (T, error) {
	var result T
	return result, nil
}

func (u *TimeSeriesPlotConfigWithT[T]) EnumNoopSuccess(TimeSeriesEnumPlot) (T, error) {
	var result T
	return result, nil
}

func (u *TimeSeriesPlotConfigWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimeSeriesPlotConfigVisitorWithT[T any] interface {
	VisitNumeric(ctx context.Context, v TimeSeriesNumericPlot) (T, error)
	VisitRange(ctx context.Context, v TimeSeriesRangePlot) (T, error)
	VisitEnum(ctx context.Context, v TimeSeriesEnumPlot) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TraceComputeConfigWithT[T any] TraceComputeConfig

func (u *TraceComputeConfigWithT[T]) Accept(ctx context.Context, v TraceComputeConfigVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return result, fmt.Errorf("field \"scatter3d\" is required")
		}
		return v.VisitScatter3d(ctx, *u.scatter3d)
	}
}

func (u *TraceComputeConfigWithT[T]) AcceptFuncs(scatter3dFunc func(Scatter3dTraceComputeConfig) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "scatter3d":
		if u.scatter3d == nil {
			return result, fmt.Errorf("field \"scatter3d\" is required")
		}
		return scatter3dFunc(*u.scatter3d)
	}
}

func (u *TraceComputeConfigWithT[T]) Scatter3dNoopSuccess(Scatter3dTraceComputeConfig) (T, error) {
	var result T
	return result, nil
}

func (u *TraceComputeConfigWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TraceComputeConfigVisitorWithT[T any] interface {
	VisitScatter3d(ctx context.Context, v Scatter3dTraceComputeConfig) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ValueTableCellConfigWithT[T any] ValueTableCellConfig

func (u *ValueTableCellConfigWithT[T]) Accept(ctx context.Context, v ValueTableCellConfigVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(ctx, *u.range_)
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return result, fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return v.VisitBitFlagMap(ctx, *u.bitFlagMap)
	}
}

func (u *ValueTableCellConfigWithT[T]) AcceptFuncs(numericFunc func(NumericCellConfig) (T, error), enumFunc func(EnumCellConfig) (T, error), range_Func func(RangeCellConfig) (T, error), bitFlagMapFunc func(BitFlagMapCellConfig) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "bitFlagMap":
		if u.bitFlagMap == nil {
			return result, fmt.Errorf("field \"bitFlagMap\" is required")
		}
		return bitFlagMapFunc(*u.bitFlagMap)
	}
}

func (u *ValueTableCellConfigWithT[T]) NumericNoopSuccess(NumericCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) EnumNoopSuccess(EnumCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) RangeNoopSuccess(RangeCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) BitFlagMapNoopSuccess(BitFlagMapCellConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableCellConfigWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ValueTableCellConfigVisitorWithT[T any] interface {
	VisitNumeric(ctx context.Context, v NumericCellConfig) (T, error)
	VisitEnum(ctx context.Context, v EnumCellConfig) (T, error)
	VisitRange(ctx context.Context, v RangeCellConfig) (T, error)
	VisitBitFlagMap(ctx context.Context, v BitFlagMapCellConfig) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ValueTableChannelWithT[T any] ValueTableChannel

func (u *ValueTableChannelWithT[T]) Accept(ctx context.Context, v ValueTableChannelVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(ctx, *u.range_)
	}
}

func (u *ValueTableChannelWithT[T]) AcceptFuncs(numericFunc func(NumericValueChannel) (T, error), enumFunc func(EnumValueChannel) (T, error), range_Func func(RangeValueChannel) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	}
}

func (u *ValueTableChannelWithT[T]) NumericNoopSuccess(NumericValueChannel) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableChannelWithT[T]) EnumNoopSuccess(EnumValueChannel) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableChannelWithT[T]) RangeNoopSuccess(RangeValueChannel) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableChannelWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ValueTableChannelVisitorWithT[T any] interface {
	VisitNumeric(ctx context.Context, v NumericValueChannel) (T, error)
	VisitEnum(ctx context.Context, v EnumValueChannel) (T, error)
	VisitRange(ctx context.Context, v RangeValueChannel) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ValueTableDefinitionWithT[T any] ValueTableDefinition

func (u *ValueTableDefinitionWithT[T]) Accept(ctx context.Context, v ValueTableDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(ctx, *u.v2)
	}
}

func (u *ValueTableDefinitionWithT[T]) AcceptFuncs(v1Func func(ValueTableDefinitionV1) (T, error), v2Func func(ValueTableDefinitionV2) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *ValueTableDefinitionWithT[T]) V1NoopSuccess(ValueTableDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableDefinitionWithT[T]) V2NoopSuccess(ValueTableDefinitionV2) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ValueTableDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v ValueTableDefinitionV1) (T, error)
	VisitV2(ctx context.Context, v ValueTableDefinitionV2) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ValueTableLayoutWithT[T any] ValueTableLayout

func (u *ValueTableLayoutWithT[T]) Accept(ctx context.Context, v ValueTableLayoutVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "grid":
		if u.grid == nil {
			return result, fmt.Errorf("field \"grid\" is required")
		}
		return v.VisitGrid(ctx, *u.grid)
	}
}

func (u *ValueTableLayoutWithT[T]) AcceptFuncs(gridFunc func(ValueTableLayoutGrid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "grid":
		if u.grid == nil {
			return result, fmt.Errorf("field \"grid\" is required")
		}
		return gridFunc(*u.grid)
	}
}

func (u *ValueTableLayoutWithT[T]) GridNoopSuccess(ValueTableLayoutGrid) (T, error) {
	var result T
	return result, nil
}

func (u *ValueTableLayoutWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ValueTableLayoutVisitorWithT[T any] interface {
	VisitGrid(ctx context.Context, v ValueTableLayoutGrid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ValueToColorMapWithT[T any] ValueToColorMap

func (u *ValueToColorMapWithT[T]) Accept(ctx context.Context, v ValueToColorMapVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	}
}

func (u *ValueToColorMapWithT[T]) AcceptFuncs(numericFunc func(map[api.HexColor]float64) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	}
}

func (u *ValueToColorMapWithT[T]) NumericNoopSuccess(map[api.HexColor]float64) (T, error) {
	var result T
	return result, nil
}

func (u *ValueToColorMapWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ValueToColorMapVisitorWithT[T any] interface {
	VisitNumeric(ctx context.Context, v map[api.HexColor]float64) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VideoVizDefinitionWithT[T any] VideoVizDefinition

func (u *VideoVizDefinitionWithT[T]) Accept(ctx context.Context, v VideoVizDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *VideoVizDefinitionWithT[T]) AcceptFuncs(v1Func func(VideoVizDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *VideoVizDefinitionWithT[T]) V1NoopSuccess(VideoVizDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *VideoVizDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VideoVizDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v VideoVizDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VizDefinitionWithT[T any] VizDefinition

func (u *VizDefinitionWithT[T]) Accept(ctx context.Context, v VizDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return v.VisitCartesian(ctx, *u.cartesian)
	case "checklist":
		if u.checklist == nil {
			return result, fmt.Errorf("field \"checklist\" is required")
		}
		return v.VisitChecklist(ctx, *u.checklist)
	case "frequency":
		if u.frequency == nil {
			return result, fmt.Errorf("field \"frequency\" is required")
		}
		return v.VisitFrequency(ctx, *u.frequency)
	case "geo":
		if u.geo == nil {
			return result, fmt.Errorf("field \"geo\" is required")
		}
		return v.VisitGeo(ctx, *u.geo)
	case "geo3d":
		if u.geo3d == nil {
			return result, fmt.Errorf("field \"geo3d\" is required")
		}
		return v.VisitGeo3d(ctx, *u.geo3d)
	case "histogram":
		if u.histogram == nil {
			return result, fmt.Errorf("field \"histogram\" is required")
		}
		return v.VisitHistogram(ctx, *u.histogram)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(ctx, *u.log)
	case "plotly":
		if u.plotly == nil {
			return result, fmt.Errorf("field \"plotly\" is required")
		}
		return v.VisitPlotly(ctx, *u.plotly)
	case "timeSeries":
		if u.timeSeries == nil {
			return result, fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeries(ctx, *u.timeSeries)
	case "valueTable":
		if u.valueTable == nil {
			return result, fmt.Errorf("field \"valueTable\" is required")
		}
		return v.VisitValueTable(ctx, *u.valueTable)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(ctx, *u.video)
	case "procedure":
		if u.procedure == nil {
			return result, fmt.Errorf("field \"procedure\" is required")
		}
		return v.VisitProcedure(ctx, *u.procedure)
	}
}

func (u *VizDefinitionWithT[T]) AcceptFuncs(cartesianFunc func(CartesianChartDefinition) (T, error), checklistFunc func(ChecklistChartDefinition) (T, error), frequencyFunc func(FrequencyChartDefinition) (T, error), geoFunc func(GeoVizDefinition) (T, error), geo3dFunc func(Geo3dDefinition) (T, error), histogramFunc func(HistogramChartDefinition) (T, error), logFunc func(LogPanelDefinition) (T, error), plotlyFunc func(PlotlyPanelDefinition) (T, error), timeSeriesFunc func(TimeSeriesChartDefinition) (T, error), valueTableFunc func(ValueTableDefinition) (T, error), videoFunc func(VideoVizDefinition) (T, error), procedureFunc func(ProcedureVizDefinition) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "cartesian":
		if u.cartesian == nil {
			return result, fmt.Errorf("field \"cartesian\" is required")
		}
		return cartesianFunc(*u.cartesian)
	case "checklist":
		if u.checklist == nil {
			return result, fmt.Errorf("field \"checklist\" is required")
		}
		return checklistFunc(*u.checklist)
	case "frequency":
		if u.frequency == nil {
			return result, fmt.Errorf("field \"frequency\" is required")
		}
		return frequencyFunc(*u.frequency)
	case "geo":
		if u.geo == nil {
			return result, fmt.Errorf("field \"geo\" is required")
		}
		return geoFunc(*u.geo)
	case "geo3d":
		if u.geo3d == nil {
			return result, fmt.Errorf("field \"geo3d\" is required")
		}
		return geo3dFunc(*u.geo3d)
	case "histogram":
		if u.histogram == nil {
			return result, fmt.Errorf("field \"histogram\" is required")
		}
		return histogramFunc(*u.histogram)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "plotly":
		if u.plotly == nil {
			return result, fmt.Errorf("field \"plotly\" is required")
		}
		return plotlyFunc(*u.plotly)
	case "timeSeries":
		if u.timeSeries == nil {
			return result, fmt.Errorf("field \"timeSeries\" is required")
		}
		return timeSeriesFunc(*u.timeSeries)
	case "valueTable":
		if u.valueTable == nil {
			return result, fmt.Errorf("field \"valueTable\" is required")
		}
		return valueTableFunc(*u.valueTable)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	case "procedure":
		if u.procedure == nil {
			return result, fmt.Errorf("field \"procedure\" is required")
		}
		return procedureFunc(*u.procedure)
	}
}

func (u *VizDefinitionWithT[T]) CartesianNoopSuccess(CartesianChartDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) ChecklistNoopSuccess(ChecklistChartDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) FrequencyNoopSuccess(FrequencyChartDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) GeoNoopSuccess(GeoVizDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) Geo3dNoopSuccess(Geo3dDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) HistogramNoopSuccess(HistogramChartDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) LogNoopSuccess(LogPanelDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) PlotlyNoopSuccess(PlotlyPanelDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) TimeSeriesNoopSuccess(TimeSeriesChartDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) ValueTableNoopSuccess(ValueTableDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) VideoNoopSuccess(VideoVizDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) ProcedureNoopSuccess(ProcedureVizDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VizDefinitionVisitorWithT[T any] interface {
	VisitCartesian(ctx context.Context, v CartesianChartDefinition) (T, error)
	VisitChecklist(ctx context.Context, v ChecklistChartDefinition) (T, error)
	VisitFrequency(ctx context.Context, v FrequencyChartDefinition) (T, error)
	VisitGeo(ctx context.Context, v GeoVizDefinition) (T, error)
	VisitGeo3d(ctx context.Context, v Geo3dDefinition) (T, error)
	VisitHistogram(ctx context.Context, v HistogramChartDefinition) (T, error)
	VisitLog(ctx context.Context, v LogPanelDefinition) (T, error)
	VisitPlotly(ctx context.Context, v PlotlyPanelDefinition) (T, error)
	VisitTimeSeries(ctx context.Context, v TimeSeriesChartDefinition) (T, error)
	VisitValueTable(ctx context.Context, v ValueTableDefinition) (T, error)
	VisitVideo(ctx context.Context, v VideoVizDefinition) (T, error)
	VisitProcedure(ctx context.Context, v ProcedureVizDefinition) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
