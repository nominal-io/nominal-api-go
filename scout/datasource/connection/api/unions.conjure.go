// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/io/nominal/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type ConnectionDetails struct {
	typ            string
	timescale      *TimescaleConnectionDetails
	influx         *Influx2ConnectionDetails
	influx1        *Influx1ConnectionDetails
	nominal        *NominalConnectionDetails
	timestream     *TimestreamConnectionDetails
	visualCrossing *VisualCrossingConnectionDetails
	bigQuery       *BigQueryConnectionDetails
}

type connectionDetailsDeserializer struct {
	Type           string                           `json:"type"`
	Timescale      *TimescaleConnectionDetails      `json:"timescale"`
	Influx         *Influx2ConnectionDetails        `json:"influx"`
	Influx1        *Influx1ConnectionDetails        `json:"influx1"`
	Nominal        *NominalConnectionDetails        `json:"nominal"`
	Timestream     *TimestreamConnectionDetails     `json:"timestream"`
	VisualCrossing *VisualCrossingConnectionDetails `json:"visualCrossing"`
	BigQuery       *BigQueryConnectionDetails       `json:"bigQuery"`
}

func (u *connectionDetailsDeserializer) toStruct() ConnectionDetails {
	return ConnectionDetails{typ: u.Type, timescale: u.Timescale, influx: u.Influx, influx1: u.Influx1, nominal: u.Nominal, timestream: u.Timestream, visualCrossing: u.VisualCrossing, bigQuery: u.BigQuery}
}

func (u *ConnectionDetails) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timescale":
		if u.timescale == nil {
			return nil, fmt.Errorf("field \"timescale\" is required")
		}
		return struct {
			Type      string                     `json:"type"`
			Timescale TimescaleConnectionDetails `json:"timescale"`
		}{Type: "timescale", Timescale: *u.timescale}, nil
	case "influx":
		if u.influx == nil {
			return nil, fmt.Errorf("field \"influx\" is required")
		}
		return struct {
			Type   string                   `json:"type"`
			Influx Influx2ConnectionDetails `json:"influx"`
		}{Type: "influx", Influx: *u.influx}, nil
	case "influx1":
		if u.influx1 == nil {
			return nil, fmt.Errorf("field \"influx1\" is required")
		}
		return struct {
			Type    string                   `json:"type"`
			Influx1 Influx1ConnectionDetails `json:"influx1"`
		}{Type: "influx1", Influx1: *u.influx1}, nil
	case "nominal":
		if u.nominal == nil {
			return nil, fmt.Errorf("field \"nominal\" is required")
		}
		return struct {
			Type    string                   `json:"type"`
			Nominal NominalConnectionDetails `json:"nominal"`
		}{Type: "nominal", Nominal: *u.nominal}, nil
	case "timestream":
		if u.timestream == nil {
			return nil, fmt.Errorf("field \"timestream\" is required")
		}
		return struct {
			Type       string                      `json:"type"`
			Timestream TimestreamConnectionDetails `json:"timestream"`
		}{Type: "timestream", Timestream: *u.timestream}, nil
	case "visualCrossing":
		if u.visualCrossing == nil {
			return nil, fmt.Errorf("field \"visualCrossing\" is required")
		}
		return struct {
			Type           string                          `json:"type"`
			VisualCrossing VisualCrossingConnectionDetails `json:"visualCrossing"`
		}{Type: "visualCrossing", VisualCrossing: *u.visualCrossing}, nil
	case "bigQuery":
		if u.bigQuery == nil {
			return nil, fmt.Errorf("field \"bigQuery\" is required")
		}
		return struct {
			Type     string                    `json:"type"`
			BigQuery BigQueryConnectionDetails `json:"bigQuery"`
		}{Type: "bigQuery", BigQuery: *u.bigQuery}, nil
	}
}

func (u ConnectionDetails) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ConnectionDetails) UnmarshalJSON(data []byte) error {
	var deser connectionDetailsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timescale":
		if u.timescale == nil {
			return fmt.Errorf("field \"timescale\" is required")
		}
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
	case "influx1":
		if u.influx1 == nil {
			return fmt.Errorf("field \"influx1\" is required")
		}
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
	}
	return nil
}

func (u ConnectionDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ConnectionDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ConnectionDetails) AcceptFuncs(timescaleFunc func(TimescaleConnectionDetails) error, influxFunc func(Influx2ConnectionDetails) error, influx1Func func(Influx1ConnectionDetails) error, nominalFunc func(NominalConnectionDetails) error, timestreamFunc func(TimestreamConnectionDetails) error, visualCrossingFunc func(VisualCrossingConnectionDetails) error, bigQueryFunc func(BigQueryConnectionDetails) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timescale":
		if u.timescale == nil {
			return fmt.Errorf("field \"timescale\" is required")
		}
		return timescaleFunc(*u.timescale)
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
		return influxFunc(*u.influx)
	case "influx1":
		if u.influx1 == nil {
			return fmt.Errorf("field \"influx1\" is required")
		}
		return influx1Func(*u.influx1)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return nominalFunc(*u.nominal)
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
		return timestreamFunc(*u.timestream)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
		return visualCrossingFunc(*u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
		return bigQueryFunc(*u.bigQuery)
	}
}

func (u *ConnectionDetails) TimescaleNoopSuccess(TimescaleConnectionDetails) error {
	return nil
}

func (u *ConnectionDetails) InfluxNoopSuccess(Influx2ConnectionDetails) error {
	return nil
}

func (u *ConnectionDetails) Influx1NoopSuccess(Influx1ConnectionDetails) error {
	return nil
}

func (u *ConnectionDetails) NominalNoopSuccess(NominalConnectionDetails) error {
	return nil
}

func (u *ConnectionDetails) TimestreamNoopSuccess(TimestreamConnectionDetails) error {
	return nil
}

func (u *ConnectionDetails) VisualCrossingNoopSuccess(VisualCrossingConnectionDetails) error {
	return nil
}

func (u *ConnectionDetails) BigQueryNoopSuccess(BigQueryConnectionDetails) error {
	return nil
}

func (u *ConnectionDetails) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ConnectionDetails) Accept(v ConnectionDetailsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timescale":
		if u.timescale == nil {
			return fmt.Errorf("field \"timescale\" is required")
		}
		return v.VisitTimescale(*u.timescale)
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
		return v.VisitInflux(*u.influx)
	case "influx1":
		if u.influx1 == nil {
			return fmt.Errorf("field \"influx1\" is required")
		}
		return v.VisitInflux1(*u.influx1)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominal(*u.nominal)
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
		return v.VisitTimestream(*u.timestream)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
		return v.VisitVisualCrossing(*u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
		return v.VisitBigQuery(*u.bigQuery)
	}
}

type ConnectionDetailsVisitor interface {
	VisitTimescale(v TimescaleConnectionDetails) error
	VisitInflux(v Influx2ConnectionDetails) error
	VisitInflux1(v Influx1ConnectionDetails) error
	VisitNominal(v NominalConnectionDetails) error
	VisitTimestream(v TimestreamConnectionDetails) error
	VisitVisualCrossing(v VisualCrossingConnectionDetails) error
	VisitBigQuery(v BigQueryConnectionDetails) error
	VisitUnknown(typeName string) error
}

func (u *ConnectionDetails) AcceptWithContext(ctx context.Context, v ConnectionDetailsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timescale":
		if u.timescale == nil {
			return fmt.Errorf("field \"timescale\" is required")
		}
		return v.VisitTimescaleWithContext(ctx, *u.timescale)
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
		return v.VisitInfluxWithContext(ctx, *u.influx)
	case "influx1":
		if u.influx1 == nil {
			return fmt.Errorf("field \"influx1\" is required")
		}
		return v.VisitInflux1WithContext(ctx, *u.influx1)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominalWithContext(ctx, *u.nominal)
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
		return v.VisitTimestreamWithContext(ctx, *u.timestream)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
		return v.VisitVisualCrossingWithContext(ctx, *u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
		return v.VisitBigQueryWithContext(ctx, *u.bigQuery)
	}
}

type ConnectionDetailsVisitorWithContext interface {
	VisitTimescaleWithContext(ctx context.Context, v TimescaleConnectionDetails) error
	VisitInfluxWithContext(ctx context.Context, v Influx2ConnectionDetails) error
	VisitInflux1WithContext(ctx context.Context, v Influx1ConnectionDetails) error
	VisitNominalWithContext(ctx context.Context, v NominalConnectionDetails) error
	VisitTimestreamWithContext(ctx context.Context, v TimestreamConnectionDetails) error
	VisitVisualCrossingWithContext(ctx context.Context, v VisualCrossingConnectionDetails) error
	VisitBigQueryWithContext(ctx context.Context, v BigQueryConnectionDetails) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewConnectionDetailsFromTimescale(v TimescaleConnectionDetails) ConnectionDetails {
	return ConnectionDetails{typ: "timescale", timescale: &v}
}

func NewConnectionDetailsFromInflux(v Influx2ConnectionDetails) ConnectionDetails {
	return ConnectionDetails{typ: "influx", influx: &v}
}

func NewConnectionDetailsFromInflux1(v Influx1ConnectionDetails) ConnectionDetails {
	return ConnectionDetails{typ: "influx1", influx1: &v}
}

func NewConnectionDetailsFromNominal(v NominalConnectionDetails) ConnectionDetails {
	return ConnectionDetails{typ: "nominal", nominal: &v}
}

func NewConnectionDetailsFromTimestream(v TimestreamConnectionDetails) ConnectionDetails {
	return ConnectionDetails{typ: "timestream", timestream: &v}
}

func NewConnectionDetailsFromVisualCrossing(v VisualCrossingConnectionDetails) ConnectionDetails {
	return ConnectionDetails{typ: "visualCrossing", visualCrossing: &v}
}

func NewConnectionDetailsFromBigQuery(v BigQueryConnectionDetails) ConnectionDetails {
	return ConnectionDetails{typ: "bigQuery", bigQuery: &v}
}

type HeaderValue struct {
	typ       string
	plain     *string
	secretRid *SecretRid
}

type headerValueDeserializer struct {
	Type      string     `json:"type"`
	Plain     *string    `json:"plain"`
	SecretRid *SecretRid `json:"secretRid"`
}

func (u *headerValueDeserializer) toStruct() HeaderValue {
	return HeaderValue{typ: u.Type, plain: u.Plain, secretRid: u.SecretRid}
}

func (u *HeaderValue) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "plain":
		if u.plain == nil {
			return nil, fmt.Errorf("field \"plain\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Plain string `json:"plain"`
		}{Type: "plain", Plain: *u.plain}, nil
	case "secretRid":
		if u.secretRid == nil {
			return nil, fmt.Errorf("field \"secretRid\" is required")
		}
		return struct {
			Type      string    `json:"type"`
			SecretRid SecretRid `json:"secretRid"`
		}{Type: "secretRid", SecretRid: *u.secretRid}, nil
	}
}

func (u HeaderValue) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *HeaderValue) UnmarshalJSON(data []byte) error {
	var deser headerValueDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "plain":
		if u.plain == nil {
			return fmt.Errorf("field \"plain\" is required")
		}
	case "secretRid":
		if u.secretRid == nil {
			return fmt.Errorf("field \"secretRid\" is required")
		}
	}
	return nil
}

func (u HeaderValue) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *HeaderValue) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *HeaderValue) AcceptFuncs(plainFunc func(string) error, secretRidFunc func(SecretRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "plain":
		if u.plain == nil {
			return fmt.Errorf("field \"plain\" is required")
		}
		return plainFunc(*u.plain)
	case "secretRid":
		if u.secretRid == nil {
			return fmt.Errorf("field \"secretRid\" is required")
		}
		return secretRidFunc(*u.secretRid)
	}
}

func (u *HeaderValue) PlainNoopSuccess(string) error {
	return nil
}

func (u *HeaderValue) SecretRidNoopSuccess(SecretRid) error {
	return nil
}

func (u *HeaderValue) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *HeaderValue) Accept(v HeaderValueVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "plain":
		if u.plain == nil {
			return fmt.Errorf("field \"plain\" is required")
		}
		return v.VisitPlain(*u.plain)
	case "secretRid":
		if u.secretRid == nil {
			return fmt.Errorf("field \"secretRid\" is required")
		}
		return v.VisitSecretRid(*u.secretRid)
	}
}

type HeaderValueVisitor interface {
	VisitPlain(v string) error
	VisitSecretRid(v SecretRid) error
	VisitUnknown(typeName string) error
}

func (u *HeaderValue) AcceptWithContext(ctx context.Context, v HeaderValueVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "plain":
		if u.plain == nil {
			return fmt.Errorf("field \"plain\" is required")
		}
		return v.VisitPlainWithContext(ctx, *u.plain)
	case "secretRid":
		if u.secretRid == nil {
			return fmt.Errorf("field \"secretRid\" is required")
		}
		return v.VisitSecretRidWithContext(ctx, *u.secretRid)
	}
}

type HeaderValueVisitorWithContext interface {
	VisitPlainWithContext(ctx context.Context, v string) error
	VisitSecretRidWithContext(ctx context.Context, v SecretRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewHeaderValueFromPlain(v string) HeaderValue {
	return HeaderValue{typ: "plain", plain: &v}
}

func NewHeaderValueFromSecretRid(v SecretRid) HeaderValue {
	return HeaderValue{typ: "secretRid", secretRid: &v}
}

type InfluxChannelNameComponent struct {
	typ         string
	bucket      *api.Empty
	measurement *api.Empty
	field       *api.Empty
}

type influxChannelNameComponentDeserializer struct {
	Type        string     `json:"type"`
	Bucket      *api.Empty `json:"bucket"`
	Measurement *api.Empty `json:"measurement"`
	Field       *api.Empty `json:"field"`
}

func (u *influxChannelNameComponentDeserializer) toStruct() InfluxChannelNameComponent {
	return InfluxChannelNameComponent{typ: u.Type, bucket: u.Bucket, measurement: u.Measurement, field: u.Field}
}

func (u *InfluxChannelNameComponent) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "bucket":
		if u.bucket == nil {
			return nil, fmt.Errorf("field \"bucket\" is required")
		}
		return struct {
			Type   string    `json:"type"`
			Bucket api.Empty `json:"bucket"`
		}{Type: "bucket", Bucket: *u.bucket}, nil
	case "measurement":
		if u.measurement == nil {
			return nil, fmt.Errorf("field \"measurement\" is required")
		}
		return struct {
			Type        string    `json:"type"`
			Measurement api.Empty `json:"measurement"`
		}{Type: "measurement", Measurement: *u.measurement}, nil
	case "field":
		if u.field == nil {
			return nil, fmt.Errorf("field \"field\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Field api.Empty `json:"field"`
		}{Type: "field", Field: *u.field}, nil
	}
}

func (u InfluxChannelNameComponent) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *InfluxChannelNameComponent) UnmarshalJSON(data []byte) error {
	var deser influxChannelNameComponentDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "bucket":
		if u.bucket == nil {
			return fmt.Errorf("field \"bucket\" is required")
		}
	case "measurement":
		if u.measurement == nil {
			return fmt.Errorf("field \"measurement\" is required")
		}
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
	}
	return nil
}

func (u InfluxChannelNameComponent) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *InfluxChannelNameComponent) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *InfluxChannelNameComponent) AcceptFuncs(bucketFunc func(api.Empty) error, measurementFunc func(api.Empty) error, fieldFunc func(api.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "bucket":
		if u.bucket == nil {
			return fmt.Errorf("field \"bucket\" is required")
		}
		return bucketFunc(*u.bucket)
	case "measurement":
		if u.measurement == nil {
			return fmt.Errorf("field \"measurement\" is required")
		}
		return measurementFunc(*u.measurement)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return fieldFunc(*u.field)
	}
}

func (u *InfluxChannelNameComponent) BucketNoopSuccess(api.Empty) error {
	return nil
}

func (u *InfluxChannelNameComponent) MeasurementNoopSuccess(api.Empty) error {
	return nil
}

func (u *InfluxChannelNameComponent) FieldNoopSuccess(api.Empty) error {
	return nil
}

func (u *InfluxChannelNameComponent) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *InfluxChannelNameComponent) Accept(v InfluxChannelNameComponentVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "bucket":
		if u.bucket == nil {
			return fmt.Errorf("field \"bucket\" is required")
		}
		return v.VisitBucket(*u.bucket)
	case "measurement":
		if u.measurement == nil {
			return fmt.Errorf("field \"measurement\" is required")
		}
		return v.VisitMeasurement(*u.measurement)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return v.VisitField(*u.field)
	}
}

type InfluxChannelNameComponentVisitor interface {
	VisitBucket(v api.Empty) error
	VisitMeasurement(v api.Empty) error
	VisitField(v api.Empty) error
	VisitUnknown(typeName string) error
}

func (u *InfluxChannelNameComponent) AcceptWithContext(ctx context.Context, v InfluxChannelNameComponentVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "bucket":
		if u.bucket == nil {
			return fmt.Errorf("field \"bucket\" is required")
		}
		return v.VisitBucketWithContext(ctx, *u.bucket)
	case "measurement":
		if u.measurement == nil {
			return fmt.Errorf("field \"measurement\" is required")
		}
		return v.VisitMeasurementWithContext(ctx, *u.measurement)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return v.VisitFieldWithContext(ctx, *u.field)
	}
}

type InfluxChannelNameComponentVisitorWithContext interface {
	VisitBucketWithContext(ctx context.Context, v api.Empty) error
	VisitMeasurementWithContext(ctx context.Context, v api.Empty) error
	VisitFieldWithContext(ctx context.Context, v api.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewInfluxChannelNameComponentFromBucket(v api.Empty) InfluxChannelNameComponent {
	return InfluxChannelNameComponent{typ: "bucket", bucket: &v}
}

func NewInfluxChannelNameComponentFromMeasurement(v api.Empty) InfluxChannelNameComponent {
	return InfluxChannelNameComponent{typ: "measurement", measurement: &v}
}

func NewInfluxChannelNameComponentFromField(v api.Empty) InfluxChannelNameComponent {
	return InfluxChannelNameComponent{typ: "field", field: &v}
}

type InfluxScrapingFilter struct {
	typ              string
	not              *InfluxScrapingFilter
	matchBucket      *[]BucketName
	matchMeasurement *[]MeasurementName
}

type influxScrapingFilterDeserializer struct {
	Type             string                `json:"type"`
	Not              *InfluxScrapingFilter `json:"not"`
	MatchBucket      *[]BucketName         `json:"matchBucket"`
	MatchMeasurement *[]MeasurementName    `json:"matchMeasurement"`
}

func (u *influxScrapingFilterDeserializer) toStruct() InfluxScrapingFilter {
	return InfluxScrapingFilter{typ: u.Type, not: u.Not, matchBucket: u.MatchBucket, matchMeasurement: u.MatchMeasurement}
}

func (u *InfluxScrapingFilter) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Not  InfluxScrapingFilter `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	case "matchBucket":
		if u.matchBucket == nil {
			return nil, fmt.Errorf("field \"matchBucket\" is required")
		}
		return struct {
			Type        string       `json:"type"`
			MatchBucket []BucketName `json:"matchBucket"`
		}{Type: "matchBucket", MatchBucket: *u.matchBucket}, nil
	case "matchMeasurement":
		if u.matchMeasurement == nil {
			return nil, fmt.Errorf("field \"matchMeasurement\" is required")
		}
		return struct {
			Type             string            `json:"type"`
			MatchMeasurement []MeasurementName `json:"matchMeasurement"`
		}{Type: "matchMeasurement", MatchMeasurement: *u.matchMeasurement}, nil
	}
}

func (u InfluxScrapingFilter) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *InfluxScrapingFilter) UnmarshalJSON(data []byte) error {
	var deser influxScrapingFilterDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	case "matchBucket":
		if u.matchBucket == nil {
			return fmt.Errorf("field \"matchBucket\" is required")
		}
	case "matchMeasurement":
		if u.matchMeasurement == nil {
			return fmt.Errorf("field \"matchMeasurement\" is required")
		}
	}
	return nil
}

func (u InfluxScrapingFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *InfluxScrapingFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *InfluxScrapingFilter) AcceptFuncs(notFunc func(InfluxScrapingFilter) error, matchBucketFunc func([]BucketName) error, matchMeasurementFunc func([]MeasurementName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "matchBucket":
		if u.matchBucket == nil {
			return fmt.Errorf("field \"matchBucket\" is required")
		}
		return matchBucketFunc(*u.matchBucket)
	case "matchMeasurement":
		if u.matchMeasurement == nil {
			return fmt.Errorf("field \"matchMeasurement\" is required")
		}
		return matchMeasurementFunc(*u.matchMeasurement)
	}
}

func (u *InfluxScrapingFilter) NotNoopSuccess(InfluxScrapingFilter) error {
	return nil
}

func (u *InfluxScrapingFilter) MatchBucketNoopSuccess([]BucketName) error {
	return nil
}

func (u *InfluxScrapingFilter) MatchMeasurementNoopSuccess([]MeasurementName) error {
	return nil
}

func (u *InfluxScrapingFilter) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *InfluxScrapingFilter) Accept(v InfluxScrapingFilterVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	case "matchBucket":
		if u.matchBucket == nil {
			return fmt.Errorf("field \"matchBucket\" is required")
		}
		return v.VisitMatchBucket(*u.matchBucket)
	case "matchMeasurement":
		if u.matchMeasurement == nil {
			return fmt.Errorf("field \"matchMeasurement\" is required")
		}
		return v.VisitMatchMeasurement(*u.matchMeasurement)
	}
}

type InfluxScrapingFilterVisitor interface {
	VisitNot(v InfluxScrapingFilter) error
	VisitMatchBucket(v []BucketName) error
	VisitMatchMeasurement(v []MeasurementName) error
	VisitUnknown(typeName string) error
}

func (u *InfluxScrapingFilter) AcceptWithContext(ctx context.Context, v InfluxScrapingFilterVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	case "matchBucket":
		if u.matchBucket == nil {
			return fmt.Errorf("field \"matchBucket\" is required")
		}
		return v.VisitMatchBucketWithContext(ctx, *u.matchBucket)
	case "matchMeasurement":
		if u.matchMeasurement == nil {
			return fmt.Errorf("field \"matchMeasurement\" is required")
		}
		return v.VisitMatchMeasurementWithContext(ctx, *u.matchMeasurement)
	}
}

type InfluxScrapingFilterVisitorWithContext interface {
	VisitNotWithContext(ctx context.Context, v InfluxScrapingFilter) error
	VisitMatchBucketWithContext(ctx context.Context, v []BucketName) error
	VisitMatchMeasurementWithContext(ctx context.Context, v []MeasurementName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewInfluxScrapingFilterFromNot(v InfluxScrapingFilter) InfluxScrapingFilter {
	return InfluxScrapingFilter{typ: "not", not: &v}
}

func NewInfluxScrapingFilterFromMatchBucket(v []BucketName) InfluxScrapingFilter {
	return InfluxScrapingFilter{typ: "matchBucket", matchBucket: &v}
}

func NewInfluxScrapingFilterFromMatchMeasurement(v []MeasurementName) InfluxScrapingFilter {
	return InfluxScrapingFilter{typ: "matchMeasurement", matchMeasurement: &v}
}

type NominalChannelNameComponent struct {
	typ                string
	channel            *api.Empty
	valueOfTagWithName *api.TagName
}

type nominalChannelNameComponentDeserializer struct {
	Type               string       `json:"type"`
	Channel            *api.Empty   `json:"channel"`
	ValueOfTagWithName *api.TagName `json:"valueOfTagWithName"`
}

func (u *nominalChannelNameComponentDeserializer) toStruct() NominalChannelNameComponent {
	return NominalChannelNameComponent{typ: u.Type, channel: u.Channel, valueOfTagWithName: u.ValueOfTagWithName}
}

func (u *NominalChannelNameComponent) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "channel":
		if u.channel == nil {
			return nil, fmt.Errorf("field \"channel\" is required")
		}
		return struct {
			Type    string    `json:"type"`
			Channel api.Empty `json:"channel"`
		}{Type: "channel", Channel: *u.channel}, nil
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return nil, fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return struct {
			Type               string      `json:"type"`
			ValueOfTagWithName api.TagName `json:"valueOfTagWithName"`
		}{Type: "valueOfTagWithName", ValueOfTagWithName: *u.valueOfTagWithName}, nil
	}
}

func (u NominalChannelNameComponent) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *NominalChannelNameComponent) UnmarshalJSON(data []byte) error {
	var deser nominalChannelNameComponentDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
	}
	return nil
}

func (u NominalChannelNameComponent) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *NominalChannelNameComponent) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *NominalChannelNameComponent) AcceptFuncs(channelFunc func(api.Empty) error, valueOfTagWithNameFunc func(api.TagName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return valueOfTagWithNameFunc(*u.valueOfTagWithName)
	}
}

func (u *NominalChannelNameComponent) ChannelNoopSuccess(api.Empty) error {
	return nil
}

func (u *NominalChannelNameComponent) ValueOfTagWithNameNoopSuccess(api.TagName) error {
	return nil
}

func (u *NominalChannelNameComponent) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *NominalChannelNameComponent) Accept(v NominalChannelNameComponentVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(*u.channel)
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return v.VisitValueOfTagWithName(*u.valueOfTagWithName)
	}
}

type NominalChannelNameComponentVisitor interface {
	VisitChannel(v api.Empty) error
	VisitValueOfTagWithName(v api.TagName) error
	VisitUnknown(typeName string) error
}

func (u *NominalChannelNameComponent) AcceptWithContext(ctx context.Context, v NominalChannelNameComponentVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "channel":
		if u.channel == nil {
			return fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannelWithContext(ctx, *u.channel)
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return v.VisitValueOfTagWithNameWithContext(ctx, *u.valueOfTagWithName)
	}
}

type NominalChannelNameComponentVisitorWithContext interface {
	VisitChannelWithContext(ctx context.Context, v api.Empty) error
	VisitValueOfTagWithNameWithContext(ctx context.Context, v api.TagName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewNominalChannelNameComponentFromChannel(v api.Empty) NominalChannelNameComponent {
	return NominalChannelNameComponent{typ: "channel", channel: &v}
}

func NewNominalChannelNameComponentFromValueOfTagWithName(v api.TagName) NominalChannelNameComponent {
	return NominalChannelNameComponent{typ: "valueOfTagWithName", valueOfTagWithName: &v}
}

type PivotedTimescaleChannelNameComponent struct {
	typ   string
	table *api.Empty
	name  *api.Empty
}

type pivotedTimescaleChannelNameComponentDeserializer struct {
	Type  string     `json:"type"`
	Table *api.Empty `json:"table"`
	Name  *api.Empty `json:"name"`
}

func (u *pivotedTimescaleChannelNameComponentDeserializer) toStruct() PivotedTimescaleChannelNameComponent {
	return PivotedTimescaleChannelNameComponent{typ: u.Type, table: u.Table, name: u.Name}
}

func (u *PivotedTimescaleChannelNameComponent) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "table":
		if u.table == nil {
			return nil, fmt.Errorf("field \"table\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Table api.Empty `json:"table"`
		}{Type: "table", Table: *u.table}, nil
	case "name":
		if u.name == nil {
			return nil, fmt.Errorf("field \"name\" is required")
		}
		return struct {
			Type string    `json:"type"`
			Name api.Empty `json:"name"`
		}{Type: "name", Name: *u.name}, nil
	}
}

func (u PivotedTimescaleChannelNameComponent) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PivotedTimescaleChannelNameComponent) UnmarshalJSON(data []byte) error {
	var deser pivotedTimescaleChannelNameComponentDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
	case "name":
		if u.name == nil {
			return fmt.Errorf("field \"name\" is required")
		}
	}
	return nil
}

func (u PivotedTimescaleChannelNameComponent) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PivotedTimescaleChannelNameComponent) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PivotedTimescaleChannelNameComponent) AcceptFuncs(tableFunc func(api.Empty) error, nameFunc func(api.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
		return tableFunc(*u.table)
	case "name":
		if u.name == nil {
			return fmt.Errorf("field \"name\" is required")
		}
		return nameFunc(*u.name)
	}
}

func (u *PivotedTimescaleChannelNameComponent) TableNoopSuccess(api.Empty) error {
	return nil
}

func (u *PivotedTimescaleChannelNameComponent) NameNoopSuccess(api.Empty) error {
	return nil
}

func (u *PivotedTimescaleChannelNameComponent) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PivotedTimescaleChannelNameComponent) Accept(v PivotedTimescaleChannelNameComponentVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
		return v.VisitTable(*u.table)
	case "name":
		if u.name == nil {
			return fmt.Errorf("field \"name\" is required")
		}
		return v.VisitName(*u.name)
	}
}

type PivotedTimescaleChannelNameComponentVisitor interface {
	VisitTable(v api.Empty) error
	VisitName(v api.Empty) error
	VisitUnknown(typeName string) error
}

func (u *PivotedTimescaleChannelNameComponent) AcceptWithContext(ctx context.Context, v PivotedTimescaleChannelNameComponentVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
		return v.VisitTableWithContext(ctx, *u.table)
	case "name":
		if u.name == nil {
			return fmt.Errorf("field \"name\" is required")
		}
		return v.VisitNameWithContext(ctx, *u.name)
	}
}

type PivotedTimescaleChannelNameComponentVisitorWithContext interface {
	VisitTableWithContext(ctx context.Context, v api.Empty) error
	VisitNameWithContext(ctx context.Context, v api.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPivotedTimescaleChannelNameComponentFromTable(v api.Empty) PivotedTimescaleChannelNameComponent {
	return PivotedTimescaleChannelNameComponent{typ: "table", table: &v}
}

func NewPivotedTimescaleChannelNameComponentFromName(v api.Empty) PivotedTimescaleChannelNameComponent {
	return PivotedTimescaleChannelNameComponent{typ: "name", name: &v}
}

type ScrapingConfig struct {
	typ            string
	influx         *InfluxScrapingConfig
	nominal        *NominalScrapingConfig
	timestream     *TimestreamScrapingConfig
	timescale      *PivotedTimescaleScrapingConfig
	visualCrossing *VisualCrossingScrapingConfig
	bigQuery       *BigQueryScrapingConfig
}

type scrapingConfigDeserializer struct {
	Type           string                          `json:"type"`
	Influx         *InfluxScrapingConfig           `json:"influx"`
	Nominal        *NominalScrapingConfig          `json:"nominal"`
	Timestream     *TimestreamScrapingConfig       `json:"timestream"`
	Timescale      *PivotedTimescaleScrapingConfig `json:"timescale"`
	VisualCrossing *VisualCrossingScrapingConfig   `json:"visualCrossing"`
	BigQuery       *BigQueryScrapingConfig         `json:"bigQuery"`
}

func (u *scrapingConfigDeserializer) toStruct() ScrapingConfig {
	return ScrapingConfig{typ: u.Type, influx: u.Influx, nominal: u.Nominal, timestream: u.Timestream, timescale: u.Timescale, visualCrossing: u.VisualCrossing, bigQuery: u.BigQuery}
}

func (u *ScrapingConfig) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "influx":
		if u.influx == nil {
			return nil, fmt.Errorf("field \"influx\" is required")
		}
		return struct {
			Type   string               `json:"type"`
			Influx InfluxScrapingConfig `json:"influx"`
		}{Type: "influx", Influx: *u.influx}, nil
	case "nominal":
		if u.nominal == nil {
			return nil, fmt.Errorf("field \"nominal\" is required")
		}
		return struct {
			Type    string                `json:"type"`
			Nominal NominalScrapingConfig `json:"nominal"`
		}{Type: "nominal", Nominal: *u.nominal}, nil
	case "timestream":
		if u.timestream == nil {
			return nil, fmt.Errorf("field \"timestream\" is required")
		}
		return struct {
			Type       string                   `json:"type"`
			Timestream TimestreamScrapingConfig `json:"timestream"`
		}{Type: "timestream", Timestream: *u.timestream}, nil
	case "timescale":
		if u.timescale == nil {
			return nil, fmt.Errorf("field \"timescale\" is required")
		}
		return struct {
			Type      string                         `json:"type"`
			Timescale PivotedTimescaleScrapingConfig `json:"timescale"`
		}{Type: "timescale", Timescale: *u.timescale}, nil
	case "visualCrossing":
		if u.visualCrossing == nil {
			return nil, fmt.Errorf("field \"visualCrossing\" is required")
		}
		return struct {
			Type           string                       `json:"type"`
			VisualCrossing VisualCrossingScrapingConfig `json:"visualCrossing"`
		}{Type: "visualCrossing", VisualCrossing: *u.visualCrossing}, nil
	case "bigQuery":
		if u.bigQuery == nil {
			return nil, fmt.Errorf("field \"bigQuery\" is required")
		}
		return struct {
			Type     string                 `json:"type"`
			BigQuery BigQueryScrapingConfig `json:"bigQuery"`
		}{Type: "bigQuery", BigQuery: *u.bigQuery}, nil
	}
}

func (u ScrapingConfig) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ScrapingConfig) UnmarshalJSON(data []byte) error {
	var deser scrapingConfigDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
	case "timescale":
		if u.timescale == nil {
			return fmt.Errorf("field \"timescale\" is required")
		}
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
	}
	return nil
}

func (u ScrapingConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ScrapingConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ScrapingConfig) AcceptFuncs(influxFunc func(InfluxScrapingConfig) error, nominalFunc func(NominalScrapingConfig) error, timestreamFunc func(TimestreamScrapingConfig) error, timescaleFunc func(PivotedTimescaleScrapingConfig) error, visualCrossingFunc func(VisualCrossingScrapingConfig) error, bigQueryFunc func(BigQueryScrapingConfig) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
		return influxFunc(*u.influx)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return nominalFunc(*u.nominal)
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
		return timestreamFunc(*u.timestream)
	case "timescale":
		if u.timescale == nil {
			return fmt.Errorf("field \"timescale\" is required")
		}
		return timescaleFunc(*u.timescale)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
		return visualCrossingFunc(*u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
		return bigQueryFunc(*u.bigQuery)
	}
}

func (u *ScrapingConfig) InfluxNoopSuccess(InfluxScrapingConfig) error {
	return nil
}

func (u *ScrapingConfig) NominalNoopSuccess(NominalScrapingConfig) error {
	return nil
}

func (u *ScrapingConfig) TimestreamNoopSuccess(TimestreamScrapingConfig) error {
	return nil
}

func (u *ScrapingConfig) TimescaleNoopSuccess(PivotedTimescaleScrapingConfig) error {
	return nil
}

func (u *ScrapingConfig) VisualCrossingNoopSuccess(VisualCrossingScrapingConfig) error {
	return nil
}

func (u *ScrapingConfig) BigQueryNoopSuccess(BigQueryScrapingConfig) error {
	return nil
}

func (u *ScrapingConfig) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ScrapingConfig) Accept(v ScrapingConfigVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
		return v.VisitInflux(*u.influx)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominal(*u.nominal)
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
		return v.VisitTimestream(*u.timestream)
	case "timescale":
		if u.timescale == nil {
			return fmt.Errorf("field \"timescale\" is required")
		}
		return v.VisitTimescale(*u.timescale)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
		return v.VisitVisualCrossing(*u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
		return v.VisitBigQuery(*u.bigQuery)
	}
}

type ScrapingConfigVisitor interface {
	VisitInflux(v InfluxScrapingConfig) error
	VisitNominal(v NominalScrapingConfig) error
	VisitTimestream(v TimestreamScrapingConfig) error
	VisitTimescale(v PivotedTimescaleScrapingConfig) error
	VisitVisualCrossing(v VisualCrossingScrapingConfig) error
	VisitBigQuery(v BigQueryScrapingConfig) error
	VisitUnknown(typeName string) error
}

func (u *ScrapingConfig) AcceptWithContext(ctx context.Context, v ScrapingConfigVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
		return v.VisitInfluxWithContext(ctx, *u.influx)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominalWithContext(ctx, *u.nominal)
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
		return v.VisitTimestreamWithContext(ctx, *u.timestream)
	case "timescale":
		if u.timescale == nil {
			return fmt.Errorf("field \"timescale\" is required")
		}
		return v.VisitTimescaleWithContext(ctx, *u.timescale)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
		return v.VisitVisualCrossingWithContext(ctx, *u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
		return v.VisitBigQueryWithContext(ctx, *u.bigQuery)
	}
}

type ScrapingConfigVisitorWithContext interface {
	VisitInfluxWithContext(ctx context.Context, v InfluxScrapingConfig) error
	VisitNominalWithContext(ctx context.Context, v NominalScrapingConfig) error
	VisitTimestreamWithContext(ctx context.Context, v TimestreamScrapingConfig) error
	VisitTimescaleWithContext(ctx context.Context, v PivotedTimescaleScrapingConfig) error
	VisitVisualCrossingWithContext(ctx context.Context, v VisualCrossingScrapingConfig) error
	VisitBigQueryWithContext(ctx context.Context, v BigQueryScrapingConfig) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewScrapingConfigFromInflux(v InfluxScrapingConfig) ScrapingConfig {
	return ScrapingConfig{typ: "influx", influx: &v}
}

func NewScrapingConfigFromNominal(v NominalScrapingConfig) ScrapingConfig {
	return ScrapingConfig{typ: "nominal", nominal: &v}
}

func NewScrapingConfigFromTimestream(v TimestreamScrapingConfig) ScrapingConfig {
	return ScrapingConfig{typ: "timestream", timestream: &v}
}

func NewScrapingConfigFromTimescale(v PivotedTimescaleScrapingConfig) ScrapingConfig {
	return ScrapingConfig{typ: "timescale", timescale: &v}
}

func NewScrapingConfigFromVisualCrossing(v VisualCrossingScrapingConfig) ScrapingConfig {
	return ScrapingConfig{typ: "visualCrossing", visualCrossing: &v}
}

func NewScrapingConfigFromBigQuery(v BigQueryScrapingConfig) ScrapingConfig {
	return ScrapingConfig{typ: "bigQuery", bigQuery: &v}
}

type TimescaleScrapingFilter struct {
	typ         string
	not         *TimescaleScrapingFilter
	matchTable  *[]TableName
	matchSchema *[]SchemaName
}

type timescaleScrapingFilterDeserializer struct {
	Type        string                   `json:"type"`
	Not         *TimescaleScrapingFilter `json:"not"`
	MatchTable  *[]TableName             `json:"matchTable"`
	MatchSchema *[]SchemaName            `json:"matchSchema"`
}

func (u *timescaleScrapingFilterDeserializer) toStruct() TimescaleScrapingFilter {
	return TimescaleScrapingFilter{typ: u.Type, not: u.Not, matchTable: u.MatchTable, matchSchema: u.MatchSchema}
}

func (u *TimescaleScrapingFilter) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string                  `json:"type"`
			Not  TimescaleScrapingFilter `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	case "matchTable":
		if u.matchTable == nil {
			return nil, fmt.Errorf("field \"matchTable\" is required")
		}
		return struct {
			Type       string      `json:"type"`
			MatchTable []TableName `json:"matchTable"`
		}{Type: "matchTable", MatchTable: *u.matchTable}, nil
	case "matchSchema":
		if u.matchSchema == nil {
			return nil, fmt.Errorf("field \"matchSchema\" is required")
		}
		return struct {
			Type        string       `json:"type"`
			MatchSchema []SchemaName `json:"matchSchema"`
		}{Type: "matchSchema", MatchSchema: *u.matchSchema}, nil
	}
}

func (u TimescaleScrapingFilter) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimescaleScrapingFilter) UnmarshalJSON(data []byte) error {
	var deser timescaleScrapingFilterDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	case "matchTable":
		if u.matchTable == nil {
			return fmt.Errorf("field \"matchTable\" is required")
		}
	case "matchSchema":
		if u.matchSchema == nil {
			return fmt.Errorf("field \"matchSchema\" is required")
		}
	}
	return nil
}

func (u TimescaleScrapingFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimescaleScrapingFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimescaleScrapingFilter) AcceptFuncs(notFunc func(TimescaleScrapingFilter) error, matchTableFunc func([]TableName) error, matchSchemaFunc func([]SchemaName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "matchTable":
		if u.matchTable == nil {
			return fmt.Errorf("field \"matchTable\" is required")
		}
		return matchTableFunc(*u.matchTable)
	case "matchSchema":
		if u.matchSchema == nil {
			return fmt.Errorf("field \"matchSchema\" is required")
		}
		return matchSchemaFunc(*u.matchSchema)
	}
}

func (u *TimescaleScrapingFilter) NotNoopSuccess(TimescaleScrapingFilter) error {
	return nil
}

func (u *TimescaleScrapingFilter) MatchTableNoopSuccess([]TableName) error {
	return nil
}

func (u *TimescaleScrapingFilter) MatchSchemaNoopSuccess([]SchemaName) error {
	return nil
}

func (u *TimescaleScrapingFilter) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimescaleScrapingFilter) Accept(v TimescaleScrapingFilterVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	case "matchTable":
		if u.matchTable == nil {
			return fmt.Errorf("field \"matchTable\" is required")
		}
		return v.VisitMatchTable(*u.matchTable)
	case "matchSchema":
		if u.matchSchema == nil {
			return fmt.Errorf("field \"matchSchema\" is required")
		}
		return v.VisitMatchSchema(*u.matchSchema)
	}
}

type TimescaleScrapingFilterVisitor interface {
	VisitNot(v TimescaleScrapingFilter) error
	VisitMatchTable(v []TableName) error
	VisitMatchSchema(v []SchemaName) error
	VisitUnknown(typeName string) error
}

func (u *TimescaleScrapingFilter) AcceptWithContext(ctx context.Context, v TimescaleScrapingFilterVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	case "matchTable":
		if u.matchTable == nil {
			return fmt.Errorf("field \"matchTable\" is required")
		}
		return v.VisitMatchTableWithContext(ctx, *u.matchTable)
	case "matchSchema":
		if u.matchSchema == nil {
			return fmt.Errorf("field \"matchSchema\" is required")
		}
		return v.VisitMatchSchemaWithContext(ctx, *u.matchSchema)
	}
}

type TimescaleScrapingFilterVisitorWithContext interface {
	VisitNotWithContext(ctx context.Context, v TimescaleScrapingFilter) error
	VisitMatchTableWithContext(ctx context.Context, v []TableName) error
	VisitMatchSchemaWithContext(ctx context.Context, v []SchemaName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimescaleScrapingFilterFromNot(v TimescaleScrapingFilter) TimescaleScrapingFilter {
	return TimescaleScrapingFilter{typ: "not", not: &v}
}

func NewTimescaleScrapingFilterFromMatchTable(v []TableName) TimescaleScrapingFilter {
	return TimescaleScrapingFilter{typ: "matchTable", matchTable: &v}
}

func NewTimescaleScrapingFilterFromMatchSchema(v []SchemaName) TimescaleScrapingFilter {
	return TimescaleScrapingFilter{typ: "matchSchema", matchSchema: &v}
}

type TimestreamChannelNameComponent struct {
	typ                string
	table              *api.Empty
	measure            *api.Empty
	attribute          *api.Empty
	valueOfTagWithName *api.TagName
}

type timestreamChannelNameComponentDeserializer struct {
	Type               string       `json:"type"`
	Table              *api.Empty   `json:"table"`
	Measure            *api.Empty   `json:"measure"`
	Attribute          *api.Empty   `json:"attribute"`
	ValueOfTagWithName *api.TagName `json:"valueOfTagWithName"`
}

func (u *timestreamChannelNameComponentDeserializer) toStruct() TimestreamChannelNameComponent {
	return TimestreamChannelNameComponent{typ: u.Type, table: u.Table, measure: u.Measure, attribute: u.Attribute, valueOfTagWithName: u.ValueOfTagWithName}
}

func (u *TimestreamChannelNameComponent) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "table":
		if u.table == nil {
			return nil, fmt.Errorf("field \"table\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Table api.Empty `json:"table"`
		}{Type: "table", Table: *u.table}, nil
	case "measure":
		if u.measure == nil {
			return nil, fmt.Errorf("field \"measure\" is required")
		}
		return struct {
			Type    string    `json:"type"`
			Measure api.Empty `json:"measure"`
		}{Type: "measure", Measure: *u.measure}, nil
	case "attribute":
		if u.attribute == nil {
			return nil, fmt.Errorf("field \"attribute\" is required")
		}
		return struct {
			Type      string    `json:"type"`
			Attribute api.Empty `json:"attribute"`
		}{Type: "attribute", Attribute: *u.attribute}, nil
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return nil, fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return struct {
			Type               string      `json:"type"`
			ValueOfTagWithName api.TagName `json:"valueOfTagWithName"`
		}{Type: "valueOfTagWithName", ValueOfTagWithName: *u.valueOfTagWithName}, nil
	}
}

func (u TimestreamChannelNameComponent) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimestreamChannelNameComponent) UnmarshalJSON(data []byte) error {
	var deser timestreamChannelNameComponentDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
	case "measure":
		if u.measure == nil {
			return fmt.Errorf("field \"measure\" is required")
		}
	case "attribute":
		if u.attribute == nil {
			return fmt.Errorf("field \"attribute\" is required")
		}
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
	}
	return nil
}

func (u TimestreamChannelNameComponent) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimestreamChannelNameComponent) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimestreamChannelNameComponent) AcceptFuncs(tableFunc func(api.Empty) error, measureFunc func(api.Empty) error, attributeFunc func(api.Empty) error, valueOfTagWithNameFunc func(api.TagName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
		return tableFunc(*u.table)
	case "measure":
		if u.measure == nil {
			return fmt.Errorf("field \"measure\" is required")
		}
		return measureFunc(*u.measure)
	case "attribute":
		if u.attribute == nil {
			return fmt.Errorf("field \"attribute\" is required")
		}
		return attributeFunc(*u.attribute)
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return valueOfTagWithNameFunc(*u.valueOfTagWithName)
	}
}

func (u *TimestreamChannelNameComponent) TableNoopSuccess(api.Empty) error {
	return nil
}

func (u *TimestreamChannelNameComponent) MeasureNoopSuccess(api.Empty) error {
	return nil
}

func (u *TimestreamChannelNameComponent) AttributeNoopSuccess(api.Empty) error {
	return nil
}

func (u *TimestreamChannelNameComponent) ValueOfTagWithNameNoopSuccess(api.TagName) error {
	return nil
}

func (u *TimestreamChannelNameComponent) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimestreamChannelNameComponent) Accept(v TimestreamChannelNameComponentVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
		return v.VisitTable(*u.table)
	case "measure":
		if u.measure == nil {
			return fmt.Errorf("field \"measure\" is required")
		}
		return v.VisitMeasure(*u.measure)
	case "attribute":
		if u.attribute == nil {
			return fmt.Errorf("field \"attribute\" is required")
		}
		return v.VisitAttribute(*u.attribute)
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return v.VisitValueOfTagWithName(*u.valueOfTagWithName)
	}
}

type TimestreamChannelNameComponentVisitor interface {
	VisitTable(v api.Empty) error
	VisitMeasure(v api.Empty) error
	VisitAttribute(v api.Empty) error
	VisitValueOfTagWithName(v api.TagName) error
	VisitUnknown(typeName string) error
}

func (u *TimestreamChannelNameComponent) AcceptWithContext(ctx context.Context, v TimestreamChannelNameComponentVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
		return v.VisitTableWithContext(ctx, *u.table)
	case "measure":
		if u.measure == nil {
			return fmt.Errorf("field \"measure\" is required")
		}
		return v.VisitMeasureWithContext(ctx, *u.measure)
	case "attribute":
		if u.attribute == nil {
			return fmt.Errorf("field \"attribute\" is required")
		}
		return v.VisitAttributeWithContext(ctx, *u.attribute)
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return v.VisitValueOfTagWithNameWithContext(ctx, *u.valueOfTagWithName)
	}
}

type TimestreamChannelNameComponentVisitorWithContext interface {
	VisitTableWithContext(ctx context.Context, v api.Empty) error
	VisitMeasureWithContext(ctx context.Context, v api.Empty) error
	VisitAttributeWithContext(ctx context.Context, v api.Empty) error
	VisitValueOfTagWithNameWithContext(ctx context.Context, v api.TagName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimestreamChannelNameComponentFromTable(v api.Empty) TimestreamChannelNameComponent {
	return TimestreamChannelNameComponent{typ: "table", table: &v}
}

func NewTimestreamChannelNameComponentFromMeasure(v api.Empty) TimestreamChannelNameComponent {
	return TimestreamChannelNameComponent{typ: "measure", measure: &v}
}

func NewTimestreamChannelNameComponentFromAttribute(v api.Empty) TimestreamChannelNameComponent {
	return TimestreamChannelNameComponent{typ: "attribute", attribute: &v}
}

func NewTimestreamChannelNameComponentFromValueOfTagWithName(v api.TagName) TimestreamChannelNameComponent {
	return TimestreamChannelNameComponent{typ: "valueOfTagWithName", valueOfTagWithName: &v}
}

type TimestreamScrapingFilter struct {
	typ        string
	matchTable *[]TableName
}

type timestreamScrapingFilterDeserializer struct {
	Type       string       `json:"type"`
	MatchTable *[]TableName `json:"matchTable"`
}

func (u *timestreamScrapingFilterDeserializer) toStruct() TimestreamScrapingFilter {
	return TimestreamScrapingFilter{typ: u.Type, matchTable: u.MatchTable}
}

func (u *TimestreamScrapingFilter) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "matchTable":
		if u.matchTable == nil {
			return nil, fmt.Errorf("field \"matchTable\" is required")
		}
		return struct {
			Type       string      `json:"type"`
			MatchTable []TableName `json:"matchTable"`
		}{Type: "matchTable", MatchTable: *u.matchTable}, nil
	}
}

func (u TimestreamScrapingFilter) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimestreamScrapingFilter) UnmarshalJSON(data []byte) error {
	var deser timestreamScrapingFilterDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "matchTable":
		if u.matchTable == nil {
			return fmt.Errorf("field \"matchTable\" is required")
		}
	}
	return nil
}

func (u TimestreamScrapingFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimestreamScrapingFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimestreamScrapingFilter) AcceptFuncs(matchTableFunc func([]TableName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "matchTable":
		if u.matchTable == nil {
			return fmt.Errorf("field \"matchTable\" is required")
		}
		return matchTableFunc(*u.matchTable)
	}
}

func (u *TimestreamScrapingFilter) MatchTableNoopSuccess([]TableName) error {
	return nil
}

func (u *TimestreamScrapingFilter) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimestreamScrapingFilter) Accept(v TimestreamScrapingFilterVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "matchTable":
		if u.matchTable == nil {
			return fmt.Errorf("field \"matchTable\" is required")
		}
		return v.VisitMatchTable(*u.matchTable)
	}
}

type TimestreamScrapingFilterVisitor interface {
	VisitMatchTable(v []TableName) error
	VisitUnknown(typeName string) error
}

func (u *TimestreamScrapingFilter) AcceptWithContext(ctx context.Context, v TimestreamScrapingFilterVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "matchTable":
		if u.matchTable == nil {
			return fmt.Errorf("field \"matchTable\" is required")
		}
		return v.VisitMatchTableWithContext(ctx, *u.matchTable)
	}
}

type TimestreamScrapingFilterVisitorWithContext interface {
	VisitMatchTableWithContext(ctx context.Context, v []TableName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimestreamScrapingFilterFromMatchTable(v []TableName) TimestreamScrapingFilter {
	return TimestreamScrapingFilter{typ: "matchTable", matchTable: &v}
}
