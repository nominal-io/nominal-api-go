// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/io/nominal/api"
)

type ApiScrapingConfigWithT[T any] ApiScrapingConfig

func (u *ApiScrapingConfigWithT[T]) Accept(ctx context.Context, v ApiScrapingConfigVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "allChannels":
		if u.allChannels == nil {
			return result, fmt.Errorf("field \"allChannels\" is required")
		}
		return v.VisitAllChannels(ctx, *u.allChannels)
	case "channelAllowList":
		if u.channelAllowList == nil {
			return result, fmt.Errorf("field \"channelAllowList\" is required")
		}
		return v.VisitChannelAllowList(ctx, *u.channelAllowList)
	case "channelBlockList":
		if u.channelBlockList == nil {
			return result, fmt.Errorf("field \"channelBlockList\" is required")
		}
		return v.VisitChannelBlockList(ctx, *u.channelBlockList)
	}
}

func (u *ApiScrapingConfigWithT[T]) AcceptFuncs(allChannelsFunc func(AllChannelsConnectionsScrapingConfig) (T, error), channelAllowListFunc func(ChannelAllowListConnectionsScrapingConfig) (T, error), channelBlockListFunc func(ChannelBlockListConnectionsScrapingConfig) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "allChannels":
		if u.allChannels == nil {
			return result, fmt.Errorf("field \"allChannels\" is required")
		}
		return allChannelsFunc(*u.allChannels)
	case "channelAllowList":
		if u.channelAllowList == nil {
			return result, fmt.Errorf("field \"channelAllowList\" is required")
		}
		return channelAllowListFunc(*u.channelAllowList)
	case "channelBlockList":
		if u.channelBlockList == nil {
			return result, fmt.Errorf("field \"channelBlockList\" is required")
		}
		return channelBlockListFunc(*u.channelBlockList)
	}
}

func (u *ApiScrapingConfigWithT[T]) AllChannelsNoopSuccess(AllChannelsConnectionsScrapingConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ApiScrapingConfigWithT[T]) ChannelAllowListNoopSuccess(ChannelAllowListConnectionsScrapingConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ApiScrapingConfigWithT[T]) ChannelBlockListNoopSuccess(ChannelBlockListConnectionsScrapingConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ApiScrapingConfigWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ApiScrapingConfigVisitorWithT[T any] interface {
	VisitAllChannels(ctx context.Context, v AllChannelsConnectionsScrapingConfig) (T, error)
	VisitChannelAllowList(ctx context.Context, v ChannelAllowListConnectionsScrapingConfig) (T, error)
	VisitChannelBlockList(ctx context.Context, v ChannelBlockListConnectionsScrapingConfig) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ConnectionDetailsWithT[T any] ConnectionDetails

func (u *ConnectionDetailsWithT[T]) Accept(ctx context.Context, v ConnectionDetailsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "timescale":
		if u.timescale == nil {
			return result, fmt.Errorf("field \"timescale\" is required")
		}
		return v.VisitTimescale(ctx, *u.timescale)
	case "influx":
		if u.influx == nil {
			return result, fmt.Errorf("field \"influx\" is required")
		}
		return v.VisitInflux(ctx, *u.influx)
	case "influx1":
		if u.influx1 == nil {
			return result, fmt.Errorf("field \"influx1\" is required")
		}
		return v.VisitInflux1(ctx, *u.influx1)
	case "nominal":
		if u.nominal == nil {
			return result, fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominal(ctx, *u.nominal)
	case "timestream":
		if u.timestream == nil {
			return result, fmt.Errorf("field \"timestream\" is required")
		}
		return v.VisitTimestream(ctx, *u.timestream)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return result, fmt.Errorf("field \"visualCrossing\" is required")
		}
		return v.VisitVisualCrossing(ctx, *u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return result, fmt.Errorf("field \"bigQuery\" is required")
		}
		return v.VisitBigQuery(ctx, *u.bigQuery)
	case "api":
		if u.api == nil {
			return result, fmt.Errorf("field \"api\" is required")
		}
		return v.VisitApi(ctx, *u.api)
	}
}

func (u *ConnectionDetailsWithT[T]) AcceptFuncs(timescaleFunc func(TimescaleConnectionDetails) (T, error), influxFunc func(Influx2ConnectionDetails) (T, error), influx1Func func(Influx1ConnectionDetails) (T, error), nominalFunc func(NominalConnectionDetails) (T, error), timestreamFunc func(TimestreamConnectionDetails) (T, error), visualCrossingFunc func(VisualCrossingConnectionDetails) (T, error), bigQueryFunc func(BigQueryConnectionDetails) (T, error), apiFunc func(ApiConnectionDetails) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timescale":
		if u.timescale == nil {
			return result, fmt.Errorf("field \"timescale\" is required")
		}
		return timescaleFunc(*u.timescale)
	case "influx":
		if u.influx == nil {
			return result, fmt.Errorf("field \"influx\" is required")
		}
		return influxFunc(*u.influx)
	case "influx1":
		if u.influx1 == nil {
			return result, fmt.Errorf("field \"influx1\" is required")
		}
		return influx1Func(*u.influx1)
	case "nominal":
		if u.nominal == nil {
			return result, fmt.Errorf("field \"nominal\" is required")
		}
		return nominalFunc(*u.nominal)
	case "timestream":
		if u.timestream == nil {
			return result, fmt.Errorf("field \"timestream\" is required")
		}
		return timestreamFunc(*u.timestream)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return result, fmt.Errorf("field \"visualCrossing\" is required")
		}
		return visualCrossingFunc(*u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return result, fmt.Errorf("field \"bigQuery\" is required")
		}
		return bigQueryFunc(*u.bigQuery)
	case "api":
		if u.api == nil {
			return result, fmt.Errorf("field \"api\" is required")
		}
		return apiFunc(*u.api)
	}
}

func (u *ConnectionDetailsWithT[T]) TimescaleNoopSuccess(TimescaleConnectionDetails) (T, error) {
	var result T
	return result, nil
}

func (u *ConnectionDetailsWithT[T]) InfluxNoopSuccess(Influx2ConnectionDetails) (T, error) {
	var result T
	return result, nil
}

func (u *ConnectionDetailsWithT[T]) Influx1NoopSuccess(Influx1ConnectionDetails) (T, error) {
	var result T
	return result, nil
}

func (u *ConnectionDetailsWithT[T]) NominalNoopSuccess(NominalConnectionDetails) (T, error) {
	var result T
	return result, nil
}

func (u *ConnectionDetailsWithT[T]) TimestreamNoopSuccess(TimestreamConnectionDetails) (T, error) {
	var result T
	return result, nil
}

func (u *ConnectionDetailsWithT[T]) VisualCrossingNoopSuccess(VisualCrossingConnectionDetails) (T, error) {
	var result T
	return result, nil
}

func (u *ConnectionDetailsWithT[T]) BigQueryNoopSuccess(BigQueryConnectionDetails) (T, error) {
	var result T
	return result, nil
}

func (u *ConnectionDetailsWithT[T]) ApiNoopSuccess(ApiConnectionDetails) (T, error) {
	var result T
	return result, nil
}

func (u *ConnectionDetailsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ConnectionDetailsVisitorWithT[T any] interface {
	VisitTimescale(ctx context.Context, v TimescaleConnectionDetails) (T, error)
	VisitInflux(ctx context.Context, v Influx2ConnectionDetails) (T, error)
	VisitInflux1(ctx context.Context, v Influx1ConnectionDetails) (T, error)
	VisitNominal(ctx context.Context, v NominalConnectionDetails) (T, error)
	VisitTimestream(ctx context.Context, v TimestreamConnectionDetails) (T, error)
	VisitVisualCrossing(ctx context.Context, v VisualCrossingConnectionDetails) (T, error)
	VisitBigQuery(ctx context.Context, v BigQueryConnectionDetails) (T, error)
	VisitApi(ctx context.Context, v ApiConnectionDetails) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type HeaderValueWithT[T any] HeaderValue

func (u *HeaderValueWithT[T]) Accept(ctx context.Context, v HeaderValueVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "plain":
		if u.plain == nil {
			return result, fmt.Errorf("field \"plain\" is required")
		}
		return v.VisitPlain(ctx, *u.plain)
	case "secretRid":
		if u.secretRid == nil {
			return result, fmt.Errorf("field \"secretRid\" is required")
		}
		return v.VisitSecretRid(ctx, *u.secretRid)
	}
}

func (u *HeaderValueWithT[T]) AcceptFuncs(plainFunc func(string) (T, error), secretRidFunc func(SecretRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "plain":
		if u.plain == nil {
			return result, fmt.Errorf("field \"plain\" is required")
		}
		return plainFunc(*u.plain)
	case "secretRid":
		if u.secretRid == nil {
			return result, fmt.Errorf("field \"secretRid\" is required")
		}
		return secretRidFunc(*u.secretRid)
	}
}

func (u *HeaderValueWithT[T]) PlainNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *HeaderValueWithT[T]) SecretRidNoopSuccess(SecretRid) (T, error) {
	var result T
	return result, nil
}

func (u *HeaderValueWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type HeaderValueVisitorWithT[T any] interface {
	VisitPlain(ctx context.Context, v string) (T, error)
	VisitSecretRid(ctx context.Context, v SecretRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type InfluxChannelNameComponentWithT[T any] InfluxChannelNameComponent

func (u *InfluxChannelNameComponentWithT[T]) Accept(ctx context.Context, v InfluxChannelNameComponentVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "bucket":
		if u.bucket == nil {
			return result, fmt.Errorf("field \"bucket\" is required")
		}
		return v.VisitBucket(ctx, *u.bucket)
	case "measurement":
		if u.measurement == nil {
			return result, fmt.Errorf("field \"measurement\" is required")
		}
		return v.VisitMeasurement(ctx, *u.measurement)
	case "field":
		if u.field == nil {
			return result, fmt.Errorf("field \"field\" is required")
		}
		return v.VisitField(ctx, *u.field)
	}
}

func (u *InfluxChannelNameComponentWithT[T]) AcceptFuncs(bucketFunc func(api.Empty) (T, error), measurementFunc func(api.Empty) (T, error), fieldFunc func(api.Empty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "bucket":
		if u.bucket == nil {
			return result, fmt.Errorf("field \"bucket\" is required")
		}
		return bucketFunc(*u.bucket)
	case "measurement":
		if u.measurement == nil {
			return result, fmt.Errorf("field \"measurement\" is required")
		}
		return measurementFunc(*u.measurement)
	case "field":
		if u.field == nil {
			return result, fmt.Errorf("field \"field\" is required")
		}
		return fieldFunc(*u.field)
	}
}

func (u *InfluxChannelNameComponentWithT[T]) BucketNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *InfluxChannelNameComponentWithT[T]) MeasurementNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *InfluxChannelNameComponentWithT[T]) FieldNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *InfluxChannelNameComponentWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type InfluxChannelNameComponentVisitorWithT[T any] interface {
	VisitBucket(ctx context.Context, v api.Empty) (T, error)
	VisitMeasurement(ctx context.Context, v api.Empty) (T, error)
	VisitField(ctx context.Context, v api.Empty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type InfluxScrapingFilterWithT[T any] InfluxScrapingFilter

func (u *InfluxScrapingFilterWithT[T]) Accept(ctx context.Context, v InfluxScrapingFilterVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(ctx, *u.not)
	case "matchBucket":
		if u.matchBucket == nil {
			return result, fmt.Errorf("field \"matchBucket\" is required")
		}
		return v.VisitMatchBucket(ctx, *u.matchBucket)
	case "matchMeasurement":
		if u.matchMeasurement == nil {
			return result, fmt.Errorf("field \"matchMeasurement\" is required")
		}
		return v.VisitMatchMeasurement(ctx, *u.matchMeasurement)
	}
}

func (u *InfluxScrapingFilterWithT[T]) AcceptFuncs(notFunc func(InfluxScrapingFilter) (T, error), matchBucketFunc func([]BucketName) (T, error), matchMeasurementFunc func([]MeasurementName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "matchBucket":
		if u.matchBucket == nil {
			return result, fmt.Errorf("field \"matchBucket\" is required")
		}
		return matchBucketFunc(*u.matchBucket)
	case "matchMeasurement":
		if u.matchMeasurement == nil {
			return result, fmt.Errorf("field \"matchMeasurement\" is required")
		}
		return matchMeasurementFunc(*u.matchMeasurement)
	}
}

func (u *InfluxScrapingFilterWithT[T]) NotNoopSuccess(InfluxScrapingFilter) (T, error) {
	var result T
	return result, nil
}

func (u *InfluxScrapingFilterWithT[T]) MatchBucketNoopSuccess([]BucketName) (T, error) {
	var result T
	return result, nil
}

func (u *InfluxScrapingFilterWithT[T]) MatchMeasurementNoopSuccess([]MeasurementName) (T, error) {
	var result T
	return result, nil
}

func (u *InfluxScrapingFilterWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type InfluxScrapingFilterVisitorWithT[T any] interface {
	VisitNot(ctx context.Context, v InfluxScrapingFilter) (T, error)
	VisitMatchBucket(ctx context.Context, v []BucketName) (T, error)
	VisitMatchMeasurement(ctx context.Context, v []MeasurementName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type NominalChannelNameComponentWithT[T any] NominalChannelNameComponent

func (u *NominalChannelNameComponentWithT[T]) Accept(ctx context.Context, v NominalChannelNameComponentVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(ctx, *u.channel)
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return result, fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return v.VisitValueOfTagWithName(ctx, *u.valueOfTagWithName)
	}
}

func (u *NominalChannelNameComponentWithT[T]) AcceptFuncs(channelFunc func(api.Empty) (T, error), valueOfTagWithNameFunc func(api.TagName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return result, fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return valueOfTagWithNameFunc(*u.valueOfTagWithName)
	}
}

func (u *NominalChannelNameComponentWithT[T]) ChannelNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *NominalChannelNameComponentWithT[T]) ValueOfTagWithNameNoopSuccess(api.TagName) (T, error) {
	var result T
	return result, nil
}

func (u *NominalChannelNameComponentWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type NominalChannelNameComponentVisitorWithT[T any] interface {
	VisitChannel(ctx context.Context, v api.Empty) (T, error)
	VisitValueOfTagWithName(ctx context.Context, v api.TagName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PivotedTimescaleChannelNameComponentWithT[T any] PivotedTimescaleChannelNameComponent

func (u *PivotedTimescaleChannelNameComponentWithT[T]) Accept(ctx context.Context, v PivotedTimescaleChannelNameComponentVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "table":
		if u.table == nil {
			return result, fmt.Errorf("field \"table\" is required")
		}
		return v.VisitTable(ctx, *u.table)
	case "name":
		if u.name == nil {
			return result, fmt.Errorf("field \"name\" is required")
		}
		return v.VisitName(ctx, *u.name)
	}
}

func (u *PivotedTimescaleChannelNameComponentWithT[T]) AcceptFuncs(tableFunc func(api.Empty) (T, error), nameFunc func(api.Empty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "table":
		if u.table == nil {
			return result, fmt.Errorf("field \"table\" is required")
		}
		return tableFunc(*u.table)
	case "name":
		if u.name == nil {
			return result, fmt.Errorf("field \"name\" is required")
		}
		return nameFunc(*u.name)
	}
}

func (u *PivotedTimescaleChannelNameComponentWithT[T]) TableNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *PivotedTimescaleChannelNameComponentWithT[T]) NameNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *PivotedTimescaleChannelNameComponentWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PivotedTimescaleChannelNameComponentVisitorWithT[T any] interface {
	VisitTable(ctx context.Context, v api.Empty) (T, error)
	VisitName(ctx context.Context, v api.Empty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ScrapingConfigWithT[T any] ScrapingConfig

func (u *ScrapingConfigWithT[T]) Accept(ctx context.Context, v ScrapingConfigVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "influx":
		if u.influx == nil {
			return result, fmt.Errorf("field \"influx\" is required")
		}
		return v.VisitInflux(ctx, *u.influx)
	case "nominal":
		if u.nominal == nil {
			return result, fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominal(ctx, *u.nominal)
	case "timestream":
		if u.timestream == nil {
			return result, fmt.Errorf("field \"timestream\" is required")
		}
		return v.VisitTimestream(ctx, *u.timestream)
	case "timescale":
		if u.timescale == nil {
			return result, fmt.Errorf("field \"timescale\" is required")
		}
		return v.VisitTimescale(ctx, *u.timescale)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return result, fmt.Errorf("field \"visualCrossing\" is required")
		}
		return v.VisitVisualCrossing(ctx, *u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return result, fmt.Errorf("field \"bigQuery\" is required")
		}
		return v.VisitBigQuery(ctx, *u.bigQuery)
	case "api":
		if u.api == nil {
			return result, fmt.Errorf("field \"api\" is required")
		}
		return v.VisitApi(ctx, *u.api)
	}
}

func (u *ScrapingConfigWithT[T]) AcceptFuncs(influxFunc func(InfluxScrapingConfig) (T, error), nominalFunc func(NominalScrapingConfig) (T, error), timestreamFunc func(TimestreamScrapingConfig) (T, error), timescaleFunc func(PivotedTimescaleScrapingConfig) (T, error), visualCrossingFunc func(VisualCrossingScrapingConfig) (T, error), bigQueryFunc func(BigQueryScrapingConfig) (T, error), apiFunc func(ApiScrapingConfig) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "influx":
		if u.influx == nil {
			return result, fmt.Errorf("field \"influx\" is required")
		}
		return influxFunc(*u.influx)
	case "nominal":
		if u.nominal == nil {
			return result, fmt.Errorf("field \"nominal\" is required")
		}
		return nominalFunc(*u.nominal)
	case "timestream":
		if u.timestream == nil {
			return result, fmt.Errorf("field \"timestream\" is required")
		}
		return timestreamFunc(*u.timestream)
	case "timescale":
		if u.timescale == nil {
			return result, fmt.Errorf("field \"timescale\" is required")
		}
		return timescaleFunc(*u.timescale)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return result, fmt.Errorf("field \"visualCrossing\" is required")
		}
		return visualCrossingFunc(*u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return result, fmt.Errorf("field \"bigQuery\" is required")
		}
		return bigQueryFunc(*u.bigQuery)
	case "api":
		if u.api == nil {
			return result, fmt.Errorf("field \"api\" is required")
		}
		return apiFunc(*u.api)
	}
}

func (u *ScrapingConfigWithT[T]) InfluxNoopSuccess(InfluxScrapingConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ScrapingConfigWithT[T]) NominalNoopSuccess(NominalScrapingConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ScrapingConfigWithT[T]) TimestreamNoopSuccess(TimestreamScrapingConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ScrapingConfigWithT[T]) TimescaleNoopSuccess(PivotedTimescaleScrapingConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ScrapingConfigWithT[T]) VisualCrossingNoopSuccess(VisualCrossingScrapingConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ScrapingConfigWithT[T]) BigQueryNoopSuccess(BigQueryScrapingConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ScrapingConfigWithT[T]) ApiNoopSuccess(ApiScrapingConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ScrapingConfigWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ScrapingConfigVisitorWithT[T any] interface {
	VisitInflux(ctx context.Context, v InfluxScrapingConfig) (T, error)
	VisitNominal(ctx context.Context, v NominalScrapingConfig) (T, error)
	VisitTimestream(ctx context.Context, v TimestreamScrapingConfig) (T, error)
	VisitTimescale(ctx context.Context, v PivotedTimescaleScrapingConfig) (T, error)
	VisitVisualCrossing(ctx context.Context, v VisualCrossingScrapingConfig) (T, error)
	VisitBigQuery(ctx context.Context, v BigQueryScrapingConfig) (T, error)
	VisitApi(ctx context.Context, v ApiScrapingConfig) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimescaleScrapingFilterWithT[T any] TimescaleScrapingFilter

func (u *TimescaleScrapingFilterWithT[T]) Accept(ctx context.Context, v TimescaleScrapingFilterVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(ctx, *u.not)
	case "matchTable":
		if u.matchTable == nil {
			return result, fmt.Errorf("field \"matchTable\" is required")
		}
		return v.VisitMatchTable(ctx, *u.matchTable)
	case "matchSchema":
		if u.matchSchema == nil {
			return result, fmt.Errorf("field \"matchSchema\" is required")
		}
		return v.VisitMatchSchema(ctx, *u.matchSchema)
	}
}

func (u *TimescaleScrapingFilterWithT[T]) AcceptFuncs(notFunc func(TimescaleScrapingFilter) (T, error), matchTableFunc func([]TableName) (T, error), matchSchemaFunc func([]SchemaName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "matchTable":
		if u.matchTable == nil {
			return result, fmt.Errorf("field \"matchTable\" is required")
		}
		return matchTableFunc(*u.matchTable)
	case "matchSchema":
		if u.matchSchema == nil {
			return result, fmt.Errorf("field \"matchSchema\" is required")
		}
		return matchSchemaFunc(*u.matchSchema)
	}
}

func (u *TimescaleScrapingFilterWithT[T]) NotNoopSuccess(TimescaleScrapingFilter) (T, error) {
	var result T
	return result, nil
}

func (u *TimescaleScrapingFilterWithT[T]) MatchTableNoopSuccess([]TableName) (T, error) {
	var result T
	return result, nil
}

func (u *TimescaleScrapingFilterWithT[T]) MatchSchemaNoopSuccess([]SchemaName) (T, error) {
	var result T
	return result, nil
}

func (u *TimescaleScrapingFilterWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimescaleScrapingFilterVisitorWithT[T any] interface {
	VisitNot(ctx context.Context, v TimescaleScrapingFilter) (T, error)
	VisitMatchTable(ctx context.Context, v []TableName) (T, error)
	VisitMatchSchema(ctx context.Context, v []SchemaName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimestreamChannelNameComponentWithT[T any] TimestreamChannelNameComponent

func (u *TimestreamChannelNameComponentWithT[T]) Accept(ctx context.Context, v TimestreamChannelNameComponentVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "table":
		if u.table == nil {
			return result, fmt.Errorf("field \"table\" is required")
		}
		return v.VisitTable(ctx, *u.table)
	case "measure":
		if u.measure == nil {
			return result, fmt.Errorf("field \"measure\" is required")
		}
		return v.VisitMeasure(ctx, *u.measure)
	case "attribute":
		if u.attribute == nil {
			return result, fmt.Errorf("field \"attribute\" is required")
		}
		return v.VisitAttribute(ctx, *u.attribute)
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return result, fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return v.VisitValueOfTagWithName(ctx, *u.valueOfTagWithName)
	}
}

func (u *TimestreamChannelNameComponentWithT[T]) AcceptFuncs(tableFunc func(api.Empty) (T, error), measureFunc func(api.Empty) (T, error), attributeFunc func(api.Empty) (T, error), valueOfTagWithNameFunc func(api.TagName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "table":
		if u.table == nil {
			return result, fmt.Errorf("field \"table\" is required")
		}
		return tableFunc(*u.table)
	case "measure":
		if u.measure == nil {
			return result, fmt.Errorf("field \"measure\" is required")
		}
		return measureFunc(*u.measure)
	case "attribute":
		if u.attribute == nil {
			return result, fmt.Errorf("field \"attribute\" is required")
		}
		return attributeFunc(*u.attribute)
	case "valueOfTagWithName":
		if u.valueOfTagWithName == nil {
			return result, fmt.Errorf("field \"valueOfTagWithName\" is required")
		}
		return valueOfTagWithNameFunc(*u.valueOfTagWithName)
	}
}

func (u *TimestreamChannelNameComponentWithT[T]) TableNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *TimestreamChannelNameComponentWithT[T]) MeasureNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *TimestreamChannelNameComponentWithT[T]) AttributeNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *TimestreamChannelNameComponentWithT[T]) ValueOfTagWithNameNoopSuccess(api.TagName) (T, error) {
	var result T
	return result, nil
}

func (u *TimestreamChannelNameComponentWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimestreamChannelNameComponentVisitorWithT[T any] interface {
	VisitTable(ctx context.Context, v api.Empty) (T, error)
	VisitMeasure(ctx context.Context, v api.Empty) (T, error)
	VisitAttribute(ctx context.Context, v api.Empty) (T, error)
	VisitValueOfTagWithName(ctx context.Context, v api.TagName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimestreamScrapingFilterWithT[T any] TimestreamScrapingFilter

func (u *TimestreamScrapingFilterWithT[T]) Accept(ctx context.Context, v TimestreamScrapingFilterVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "matchTable":
		if u.matchTable == nil {
			return result, fmt.Errorf("field \"matchTable\" is required")
		}
		return v.VisitMatchTable(ctx, *u.matchTable)
	}
}

func (u *TimestreamScrapingFilterWithT[T]) AcceptFuncs(matchTableFunc func([]TableName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "matchTable":
		if u.matchTable == nil {
			return result, fmt.Errorf("field \"matchTable\" is required")
		}
		return matchTableFunc(*u.matchTable)
	}
}

func (u *TimestreamScrapingFilterWithT[T]) MatchTableNoopSuccess([]TableName) (T, error) {
	var result T
	return result, nil
}

func (u *TimestreamScrapingFilterWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimestreamScrapingFilterVisitorWithT[T any] interface {
	VisitMatchTable(ctx context.Context, v []TableName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
