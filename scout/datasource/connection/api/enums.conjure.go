// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"strings"
)

type TemporalUnit struct {
	val TemporalUnit_Value
}

type TemporalUnit_Value string

const (
	TemporalUnit_HOURS   TemporalUnit_Value = "HOURS"
	TemporalUnit_DAYS    TemporalUnit_Value = "DAYS"
	TemporalUnit_WEEKS   TemporalUnit_Value = "WEEKS"
	TemporalUnit_UNKNOWN TemporalUnit_Value = "UNKNOWN"
)

// TemporalUnit_Values returns all known variants of TemporalUnit.
func TemporalUnit_Values() []TemporalUnit_Value {
	return []TemporalUnit_Value{TemporalUnit_HOURS, TemporalUnit_DAYS, TemporalUnit_WEEKS}
}

func New_TemporalUnit(value TemporalUnit_Value) TemporalUnit {
	return TemporalUnit{val: value}
}

// IsUnknown returns false for all known variants of TemporalUnit and true otherwise.
func (e TemporalUnit) IsUnknown() bool {
	switch e.val {
	case TemporalUnit_HOURS, TemporalUnit_DAYS, TemporalUnit_WEEKS:
		return false
	}
	return true
}

func (e TemporalUnit) Value() TemporalUnit_Value {
	if e.IsUnknown() {
		return TemporalUnit_UNKNOWN
	}
	return e.val
}

func (e TemporalUnit) String() string {
	return string(e.val)
}

func (e TemporalUnit) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *TemporalUnit) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_TemporalUnit(TemporalUnit_Value(v))
	case "HOURS":
		*e = New_TemporalUnit(TemporalUnit_HOURS)
	case "DAYS":
		*e = New_TemporalUnit(TemporalUnit_DAYS)
	case "WEEKS":
		*e = New_TemporalUnit(TemporalUnit_WEEKS)
	}
	return nil
}

type VisualCrossingType struct {
	val VisualCrossingType_Value
}

type VisualCrossingType_Value string

const (
	VisualCrossingType_DOUBLE  VisualCrossingType_Value = "DOUBLE"
	VisualCrossingType_STRING  VisualCrossingType_Value = "STRING"
	VisualCrossingType_UNKNOWN VisualCrossingType_Value = "UNKNOWN"
)

// VisualCrossingType_Values returns all known variants of VisualCrossingType.
func VisualCrossingType_Values() []VisualCrossingType_Value {
	return []VisualCrossingType_Value{VisualCrossingType_DOUBLE, VisualCrossingType_STRING}
}

func New_VisualCrossingType(value VisualCrossingType_Value) VisualCrossingType {
	return VisualCrossingType{val: value}
}

// IsUnknown returns false for all known variants of VisualCrossingType and true otherwise.
func (e VisualCrossingType) IsUnknown() bool {
	switch e.val {
	case VisualCrossingType_DOUBLE, VisualCrossingType_STRING:
		return false
	}
	return true
}

func (e VisualCrossingType) Value() VisualCrossingType_Value {
	if e.IsUnknown() {
		return VisualCrossingType_UNKNOWN
	}
	return e.val
}

func (e VisualCrossingType) String() string {
	return string(e.val)
}

func (e VisualCrossingType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *VisualCrossingType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_VisualCrossingType(VisualCrossingType_Value(v))
	case "DOUBLE":
		*e = New_VisualCrossingType(VisualCrossingType_DOUBLE)
	case "STRING":
		*e = New_VisualCrossingType(VisualCrossingType_STRING)
	}
	return nil
}
