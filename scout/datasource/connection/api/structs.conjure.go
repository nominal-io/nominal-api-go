// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/scout/datasource/connection/api/influx"
	api1 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
)

type AllChannelsConnectionsScrapingConfig struct{}

func (o AllChannelsConnectionsScrapingConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AllChannelsConnectionsScrapingConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ApiConnectionDetails struct {
	// The URI to connect to hit the endpoints specified in the spec.
	ApiUri string `conjure-docs:"The URI to connect to hit the endpoints specified in the spec." json:"apiUri"`
	// Secret Rid of token secret stored in Secrets Service.
	TokenSecretRid SecretRid `conjure-docs:"Secret Rid of token secret stored in Secrets Service." json:"tokenSecretRid"`
}

func (o ApiConnectionDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ApiConnectionDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BigQueryChannelNameComponent struct {
	// Whether to include the project name in the channel name.
	IncludeProject bool `conjure-docs:"Whether to include the project name in the channel name." json:"includeProject"`
	// Whether to include the dataset name in the channel name.
	IncludeDataset bool `conjure-docs:"Whether to include the dataset name in the channel name." json:"includeDataset"`
	// Whether to include the table name in the channel name.
	IncludeTable bool `conjure-docs:"Whether to include the table name in the channel name." json:"includeTable"`
}

func (o BigQueryChannelNameComponent) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BigQueryChannelNameComponent) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BigQueryConnectionDetails struct {
	// The region of the BigQuery Project (e.g. "us-east1")
	Region LocationName `conjure-docs:"The region of the BigQuery Project (e.g. \"us-east1\")" json:"region"`
	// The name of the BigQuery Project
	Project ProjectName `conjure-docs:"The name of the BigQuery Project" json:"project"`
	// The name of the dataset within the project
	Dataset DatasetName `conjure-docs:"The name of the dataset within the project" json:"dataset"`
	// The name of the table within the dataset
	Table TableName `conjure-docs:"The name of the table within the dataset" json:"table"`
	// Secret Rid of service account key stored in Secrets Service.
	ServiceAccountKeySecretRid SecretRid `conjure-docs:"Secret Rid of service account key stored in Secrets Service." json:"serviceAccountKeySecretRid"`
}

func (o BigQueryConnectionDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BigQueryConnectionDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BigQueryScrapingConfig struct {
	// The name of the column that holds the timestamp.
	TimeColumn ColumnName `conjure-docs:"The name of the column that holds the timestamp." json:"timeColumn"`
	// The name of the columns that should be interpreted as tag columns
	TagColumns []ColumnName `conjure-docs:"The name of the columns that should be interpreted as tag columns" json:"tagColumns"`
	/*
	   channelNameComponents will be combined, together with separator, to form
	   a fully qualified channel name. By default, we don't add anything
	   to the column name.
	*/
	ChannelNameComponents *BigQueryChannelNameComponent `conjure-docs:"channelNameComponents will be combined, together with separator, to form\na fully qualified channel name. By default, we don't add anything\nto the column name." json:"channelNameComponents,omitempty"`
	/*
	   The separator that delimits the parts of the channel name. If
	   ommitted, the default is a ".".
	*/
	Separator *string `conjure-docs:"The separator that delimits the parts of the channel name. If\nommitted, the default is a \".\"." json:"separator,omitempty"`
}

func (o BigQueryScrapingConfig) MarshalJSON() ([]byte, error) {
	if o.TagColumns == nil {
		o.TagColumns = make([]ColumnName, 0)
	}
	type _tmpBigQueryScrapingConfig BigQueryScrapingConfig
	return safejson.Marshal(_tmpBigQueryScrapingConfig(o))
}

func (o *BigQueryScrapingConfig) UnmarshalJSON(data []byte) error {
	type _tmpBigQueryScrapingConfig BigQueryScrapingConfig
	var rawBigQueryScrapingConfig _tmpBigQueryScrapingConfig
	if err := safejson.Unmarshal(data, &rawBigQueryScrapingConfig); err != nil {
		return err
	}
	if rawBigQueryScrapingConfig.TagColumns == nil {
		rawBigQueryScrapingConfig.TagColumns = make([]ColumnName, 0)
	}
	*o = BigQueryScrapingConfig(rawBigQueryScrapingConfig)
	return nil
}

func (o BigQueryScrapingConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BigQueryScrapingConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelAllowListConnectionsScrapingConfig struct {
	// Only channels in this set will be scraped. Must not be empty.
	ChannelAllowList []api.Channel `conjure-docs:"Only channels in this set will be scraped. Must not be empty." json:"channelAllowList"`
}

func (o ChannelAllowListConnectionsScrapingConfig) MarshalJSON() ([]byte, error) {
	if o.ChannelAllowList == nil {
		o.ChannelAllowList = make([]api.Channel, 0)
	}
	type _tmpChannelAllowListConnectionsScrapingConfig ChannelAllowListConnectionsScrapingConfig
	return safejson.Marshal(_tmpChannelAllowListConnectionsScrapingConfig(o))
}

func (o *ChannelAllowListConnectionsScrapingConfig) UnmarshalJSON(data []byte) error {
	type _tmpChannelAllowListConnectionsScrapingConfig ChannelAllowListConnectionsScrapingConfig
	var rawChannelAllowListConnectionsScrapingConfig _tmpChannelAllowListConnectionsScrapingConfig
	if err := safejson.Unmarshal(data, &rawChannelAllowListConnectionsScrapingConfig); err != nil {
		return err
	}
	if rawChannelAllowListConnectionsScrapingConfig.ChannelAllowList == nil {
		rawChannelAllowListConnectionsScrapingConfig.ChannelAllowList = make([]api.Channel, 0)
	}
	*o = ChannelAllowListConnectionsScrapingConfig(rawChannelAllowListConnectionsScrapingConfig)
	return nil
}

func (o ChannelAllowListConnectionsScrapingConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelAllowListConnectionsScrapingConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelBlockListConnectionsScrapingConfig struct {
	// Only channels not in this set will be scraped. Must not be empty.
	ChannelBlockList []api.Channel `conjure-docs:"Only channels not in this set will be scraped. Must not be empty." json:"channelBlockList"`
}

func (o ChannelBlockListConnectionsScrapingConfig) MarshalJSON() ([]byte, error) {
	if o.ChannelBlockList == nil {
		o.ChannelBlockList = make([]api.Channel, 0)
	}
	type _tmpChannelBlockListConnectionsScrapingConfig ChannelBlockListConnectionsScrapingConfig
	return safejson.Marshal(_tmpChannelBlockListConnectionsScrapingConfig(o))
}

func (o *ChannelBlockListConnectionsScrapingConfig) UnmarshalJSON(data []byte) error {
	type _tmpChannelBlockListConnectionsScrapingConfig ChannelBlockListConnectionsScrapingConfig
	var rawChannelBlockListConnectionsScrapingConfig _tmpChannelBlockListConnectionsScrapingConfig
	if err := safejson.Unmarshal(data, &rawChannelBlockListConnectionsScrapingConfig); err != nil {
		return err
	}
	if rawChannelBlockListConnectionsScrapingConfig.ChannelBlockList == nil {
		rawChannelBlockListConnectionsScrapingConfig.ChannelBlockList = make([]api.Channel, 0)
	}
	*o = ChannelBlockListConnectionsScrapingConfig(rawChannelBlockListConnectionsScrapingConfig)
	return nil
}

func (o ChannelBlockListConnectionsScrapingConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelBlockListConnectionsScrapingConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Connection struct {
	Rid ConnectionRid `json:"rid"`
	// The display name of the connection. For example: "Nominal production TimescaleDB"
	DisplayName       string            `conjure-docs:"The display name of the connection. For example: \"Nominal production TimescaleDB\"" json:"displayName"`
	Description       *string           `json:"description,omitempty"`
	ConnectionDetails ConnectionDetails `json:"connectionDetails"`
	/*
	   Additional tag names that should be supplied to construct a fully qualified series. These are suggested,
	   rather than strictly required.
	*/
	RequiredTagNames []api.TagName     `conjure-docs:"Additional tag names that should be supplied to construct a fully qualified series. These are suggested,\nrather than strictly required." json:"requiredTagNames"`
	Metadata         map[string]string `json:"metadata"`
	Scraping         *ScrapingConfig   `json:"scraping,omitempty"`
	// The connection will be scraped iff this flag is set and scrapingConfig is present.
	ShouldScrape     bool             `conjure-docs:"The connection will be scraped iff this flag is set and scrapingConfig is present." json:"shouldScrape"`
	Limits           *LimitsConfig    `json:"limits,omitempty"`
	ConnectionStatus ConnectionStatus `json:"connectionStatus"`
	IsArchived       bool             `json:"isArchived"`
}

func (o Connection) MarshalJSON() ([]byte, error) {
	if o.RequiredTagNames == nil {
		o.RequiredTagNames = make([]api.TagName, 0)
	}
	if o.Metadata == nil {
		o.Metadata = make(map[string]string, 0)
	}
	type _tmpConnection Connection
	return safejson.Marshal(_tmpConnection(o))
}

func (o *Connection) UnmarshalJSON(data []byte) error {
	type _tmpConnection Connection
	var rawConnection _tmpConnection
	if err := safejson.Unmarshal(data, &rawConnection); err != nil {
		return err
	}
	if rawConnection.RequiredTagNames == nil {
		rawConnection.RequiredTagNames = make([]api.TagName, 0)
	}
	if rawConnection.Metadata == nil {
		rawConnection.Metadata = make(map[string]string, 0)
	}
	*o = Connection(rawConnection)
	return nil
}

func (o Connection) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Connection) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ConnectionPlottingConfiguration struct {
	// The maximum number of points to return per page for undecimated queries
	MaxUndecimatedPointsPerPage *int `conjure-docs:"The maximum number of points to return per page for undecimated queries" json:"maxUndecimatedPointsPerPage,omitempty"`
	// The maximum range (in nanoseconds) for unbounded queries
	MaxUnboundedRange *safelong.SafeLong `conjure-docs:"The maximum range (in nanoseconds) for unbounded queries" json:"maxUnboundedRange,omitempty"`
	// The maximum number of page reads per second for undecimated queries
	MaxUndecimatedPageReadsPerSecond *float64 `conjure-docs:"The maximum number of page reads per second for undecimated queries" json:"maxUndecimatedPageReadsPerSecond,omitempty"`
	// The maximum number of permits per second for queries
	MaxPermitsPerSecond *float64 `conjure-docs:"The maximum number of permits per second for queries" json:"maxPermitsPerSecond,omitempty"`
	// The maximum number of connections to the database
	MaxConnections *int `conjure-docs:"The maximum number of connections to the database" json:"maxConnections,omitempty"`
}

func (o ConnectionPlottingConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ConnectionPlottingConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ConnectionStatus struct {
	IsConnected bool `json:"isConnected"`
}

func (o ConnectionStatus) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ConnectionStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateConnection struct {
	Name              string            `json:"name"`
	Description       *string           `json:"description,omitempty"`
	ConnectionDetails ConnectionDetails `json:"connectionDetails"`
	// Metadata information about the connection which is not relevant to the DB connection itself.
	Metadata map[string]string `conjure-docs:"Metadata information about the connection which is not relevant to the DB connection itself." json:"metadata"`
	// Additional tag name that are required to construct a fully qualified series.
	RequiredTagNames []api.TagName `conjure-docs:"Additional tag name that are required to construct a fully qualified series." json:"requiredTagNames"`
	/*
	   In most cases, this does not to be set by the user. Throws if populated for Nominal connections, which
	   have their tags automatically indexed in the underlying database. Tags for external connections are
	   periodically scraped. Tags should only be updated  manually for Visual crossing connections.
	*/
	AvailableTagValues *map[api.TagName][]api.TagValue `conjure-docs:"In most cases, this does not to be set by the user. Throws if populated for Nominal connections, which \nhave their tags automatically indexed in the underlying database. Tags for external connections are \nperiodically scraped. Tags should only be updated  manually for Visual crossing connections." json:"availableTagValues,omitempty"`
	Scraping           *ScrapingConfig                 `json:"scraping,omitempty"`
	ShouldScrape       bool                            `json:"shouldScrape"`
	Limits             *LimitsConfig                   `json:"limits,omitempty"`
	/*
	   The workspace in which to create the connection. If not provided, the connection will be created in the default workspace for
	   the user's organization, if the default workspace for the organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the connection. If not provided, the connection will be created in the default workspace for\nthe user's organization, if the default workspace for the organization is configured." json:"workspace,omitempty"`
	/*
	   The markings to apply to the created connection.
	   If not provided, the connection will be visible to all users in the same workspace.
	*/
	MarkingRids []api1.MarkingRid `conjure-docs:"The markings to apply to the created connection.\nIf not provided, the connection will be visible to all users in the same workspace." json:"markingRids"`
}

func (o CreateConnection) MarshalJSON() ([]byte, error) {
	if o.Metadata == nil {
		o.Metadata = make(map[string]string, 0)
	}
	if o.RequiredTagNames == nil {
		o.RequiredTagNames = make([]api.TagName, 0)
	}
	if o.MarkingRids == nil {
		o.MarkingRids = make([]api1.MarkingRid, 0)
	}
	type _tmpCreateConnection CreateConnection
	return safejson.Marshal(_tmpCreateConnection(o))
}

func (o *CreateConnection) UnmarshalJSON(data []byte) error {
	type _tmpCreateConnection CreateConnection
	var rawCreateConnection _tmpCreateConnection
	if err := safejson.Unmarshal(data, &rawCreateConnection); err != nil {
		return err
	}
	if rawCreateConnection.Metadata == nil {
		rawCreateConnection.Metadata = make(map[string]string, 0)
	}
	if rawCreateConnection.RequiredTagNames == nil {
		rawCreateConnection.RequiredTagNames = make([]api.TagName, 0)
	}
	if rawCreateConnection.MarkingRids == nil {
		rawCreateConnection.MarkingRids = make([]api1.MarkingRid, 0)
	}
	*o = CreateConnection(rawCreateConnection)
	return nil
}

func (o CreateConnection) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateConnection) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Duration struct {
	Unit  TemporalUnit `json:"unit"`
	Count int          `json:"count"`
}

func (o Duration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Duration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Influx1ConnectionDetails struct {
	Host string `json:"host"`
	Port int    `json:"port"`
	// A map of header name to value
	Headers     map[string]HeaderValue `conjure-docs:"A map of header name to value" json:"headers"`
	Credentials *PasswordCredentials   `json:"credentials,omitempty"`
}

func (o Influx1ConnectionDetails) MarshalJSON() ([]byte, error) {
	if o.Headers == nil {
		o.Headers = make(map[string]HeaderValue, 0)
	}
	type _tmpInflux1ConnectionDetails Influx1ConnectionDetails
	return safejson.Marshal(_tmpInflux1ConnectionDetails(o))
}

func (o *Influx1ConnectionDetails) UnmarshalJSON(data []byte) error {
	type _tmpInflux1ConnectionDetails Influx1ConnectionDetails
	var rawInflux1ConnectionDetails _tmpInflux1ConnectionDetails
	if err := safejson.Unmarshal(data, &rawInflux1ConnectionDetails); err != nil {
		return err
	}
	if rawInflux1ConnectionDetails.Headers == nil {
		rawInflux1ConnectionDetails.Headers = make(map[string]HeaderValue, 0)
	}
	*o = Influx1ConnectionDetails(rawInflux1ConnectionDetails)
	return nil
}

func (o Influx1ConnectionDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Influx1ConnectionDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Influx2ConnectionDetails struct {
	Host string `json:"host"`
	Port int    `json:"port"`
	// A map of header name to value
	Headers map[string]HeaderValue `conjure-docs:"A map of header name to value" json:"headers"`
	Org     influx.OrgId           `json:"org"`
	// Secret Rid of token secret stored in Secrets Service.
	TokenSecretRid SecretRid `conjure-docs:"Secret Rid of token secret stored in Secrets Service." json:"tokenSecretRid"`
}

func (o Influx2ConnectionDetails) MarshalJSON() ([]byte, error) {
	if o.Headers == nil {
		o.Headers = make(map[string]HeaderValue, 0)
	}
	type _tmpInflux2ConnectionDetails Influx2ConnectionDetails
	return safejson.Marshal(_tmpInflux2ConnectionDetails(o))
}

func (o *Influx2ConnectionDetails) UnmarshalJSON(data []byte) error {
	type _tmpInflux2ConnectionDetails Influx2ConnectionDetails
	var rawInflux2ConnectionDetails _tmpInflux2ConnectionDetails
	if err := safejson.Unmarshal(data, &rawInflux2ConnectionDetails); err != nil {
		return err
	}
	if rawInflux2ConnectionDetails.Headers == nil {
		rawInflux2ConnectionDetails.Headers = make(map[string]HeaderValue, 0)
	}
	*o = Influx2ConnectionDetails(rawInflux2ConnectionDetails)
	return nil
}

func (o Influx2ConnectionDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Influx2ConnectionDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type InfluxScrapingConfig struct {
	// Filters are ANDed together
	Filter                      []InfluxScrapingFilter                  `conjure-docs:"Filters are ANDed together" json:"filter"`
	SeriesArchetypeConstruction InfluxSeriesArchetypeConstructionConfig `json:"seriesArchetypeConstruction"`
}

func (o InfluxScrapingConfig) MarshalJSON() ([]byte, error) {
	if o.Filter == nil {
		o.Filter = make([]InfluxScrapingFilter, 0)
	}
	type _tmpInfluxScrapingConfig InfluxScrapingConfig
	return safejson.Marshal(_tmpInfluxScrapingConfig(o))
}

func (o *InfluxScrapingConfig) UnmarshalJSON(data []byte) error {
	type _tmpInfluxScrapingConfig InfluxScrapingConfig
	var rawInfluxScrapingConfig _tmpInfluxScrapingConfig
	if err := safejson.Unmarshal(data, &rawInfluxScrapingConfig); err != nil {
		return err
	}
	if rawInfluxScrapingConfig.Filter == nil {
		rawInfluxScrapingConfig.Filter = make([]InfluxScrapingFilter, 0)
	}
	*o = InfluxScrapingConfig(rawInfluxScrapingConfig)
	return nil
}

func (o InfluxScrapingConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *InfluxScrapingConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
For example, for config of the form {components: [measurement, field, tag: vehicle], separator: "."} will construct a
channel that looks like vehicle_a.measurement.field. Tags will automatically be specified inside of the archetype.
*/
type InfluxSeriesArchetypeConstructionConfig struct {
	ChannelNameComponents []InfluxChannelNameComponent `json:"channelNameComponents"`
	Separator             string                       `json:"separator"`
}

func (o InfluxSeriesArchetypeConstructionConfig) MarshalJSON() ([]byte, error) {
	if o.ChannelNameComponents == nil {
		o.ChannelNameComponents = make([]InfluxChannelNameComponent, 0)
	}
	type _tmpInfluxSeriesArchetypeConstructionConfig InfluxSeriesArchetypeConstructionConfig
	return safejson.Marshal(_tmpInfluxSeriesArchetypeConstructionConfig(o))
}

func (o *InfluxSeriesArchetypeConstructionConfig) UnmarshalJSON(data []byte) error {
	type _tmpInfluxSeriesArchetypeConstructionConfig InfluxSeriesArchetypeConstructionConfig
	var rawInfluxSeriesArchetypeConstructionConfig _tmpInfluxSeriesArchetypeConstructionConfig
	if err := safejson.Unmarshal(data, &rawInfluxSeriesArchetypeConstructionConfig); err != nil {
		return err
	}
	if rawInfluxSeriesArchetypeConstructionConfig.ChannelNameComponents == nil {
		rawInfluxSeriesArchetypeConstructionConfig.ChannelNameComponents = make([]InfluxChannelNameComponent, 0)
	}
	*o = InfluxSeriesArchetypeConstructionConfig(rawInfluxSeriesArchetypeConstructionConfig)
	return nil
}

func (o InfluxSeriesArchetypeConstructionConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *InfluxSeriesArchetypeConstructionConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LimitsConfig struct {
	MaxQueryRange *Duration `json:"maxQueryRange,omitempty"`
}

func (o LimitsConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LimitsConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ListConnectionsResponse struct {
	Connections   []Connection `json:"connections"`
	NextPageToken *api.Token   `json:"nextPageToken,omitempty"`
}

func (o ListConnectionsResponse) MarshalJSON() ([]byte, error) {
	if o.Connections == nil {
		o.Connections = make([]Connection, 0)
	}
	type _tmpListConnectionsResponse ListConnectionsResponse
	return safejson.Marshal(_tmpListConnectionsResponse(o))
}

func (o *ListConnectionsResponse) UnmarshalJSON(data []byte) error {
	type _tmpListConnectionsResponse ListConnectionsResponse
	var rawListConnectionsResponse _tmpListConnectionsResponse
	if err := safejson.Unmarshal(data, &rawListConnectionsResponse); err != nil {
		return err
	}
	if rawListConnectionsResponse.Connections == nil {
		rawListConnectionsResponse.Connections = make([]Connection, 0)
	}
	*o = ListConnectionsResponse(rawListConnectionsResponse)
	return nil
}

func (o ListConnectionsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ListConnectionsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NominalConnectionDetails struct {
	NominalDataSourceRid rids.NominalDataSourceRid `json:"nominalDataSourceRid"`
}

func (o NominalConnectionDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NominalConnectionDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NominalScrapingConfig struct {
	/*
	   channelNameComponents will be combined, together with separator, to form
	   a fully qualified channel name.
	*/
	ChannelNameComponents []NominalChannelNameComponent `conjure-docs:"channelNameComponents will be combined, together with separator, to form\na fully qualified channel name." json:"channelNameComponents"`
	Separator             string                        `json:"separator"`
}

func (o NominalScrapingConfig) MarshalJSON() ([]byte, error) {
	if o.ChannelNameComponents == nil {
		o.ChannelNameComponents = make([]NominalChannelNameComponent, 0)
	}
	type _tmpNominalScrapingConfig NominalScrapingConfig
	return safejson.Marshal(_tmpNominalScrapingConfig(o))
}

func (o *NominalScrapingConfig) UnmarshalJSON(data []byte) error {
	type _tmpNominalScrapingConfig NominalScrapingConfig
	var rawNominalScrapingConfig _tmpNominalScrapingConfig
	if err := safejson.Unmarshal(data, &rawNominalScrapingConfig); err != nil {
		return err
	}
	if rawNominalScrapingConfig.ChannelNameComponents == nil {
		rawNominalScrapingConfig.ChannelNameComponents = make([]NominalChannelNameComponent, 0)
	}
	*o = NominalScrapingConfig(rawNominalScrapingConfig)
	return nil
}

func (o NominalScrapingConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NominalScrapingConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PasswordCredentials struct {
	Username string `json:"username"`
	// Secret Rid of password secret stored in Secrets Service.
	PasswordSecretRid SecretRid `conjure-docs:"Secret Rid of password secret stored in Secrets Service." json:"passwordSecretRid"`
}

func (o PasswordCredentials) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PasswordCredentials) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
This config is used to scrape data from a Timescale database that has a pivoted schema.
time | name           | value | device

	1   | temperature    | 1     | a
*/
type PivotedTimescaleScrapingConfig struct {
	/*
	   In order for data to be picked up by the scraper, it must match all
	   filters in this list. To exclude chunks of data, it's possible to use
	   a not filter.
	*/
	Filter []TimescaleScrapingFilter `conjure-docs:"In order for data to be picked up by the scraper, it must match all\nfilters in this list. To exclude chunks of data, it's possible to use \na not filter." json:"filter"`
	// The name of the column that holds the timestamp.
	TimeColumn ColumnName `conjure-docs:"The name of the column that holds the timestamp." json:"timeColumn"`
	// The name of the column that holds the series name.
	NameColumn ColumnName `conjure-docs:"The name of the column that holds the series name." json:"nameColumn"`
	// The name of the column that holds the series values.
	ValueColumn ColumnName `conjure-docs:"The name of the column that holds the series values." json:"valueColumn"`
	/*
	   The names of the columns that comprise a dimension. They should have a database index for efficient filtering. We do not discover
	   dimensions based on hypertable schema because they are not necessarily configured properly.
	*/
	DimensionColumns []ColumnName `conjure-docs:"The names of the columns that comprise a dimension. They should have a database index for efficient filtering. We do not discover\ndimensions based on hypertable schema because they are not necessarily configured properly." json:"dimensionColumns"`
	/*
	   channelNameComponents will be combined, together with separator, to form
	   a fully qualified channel name.
	*/
	ChannelNameComponents []PivotedTimescaleChannelNameComponent `conjure-docs:"channelNameComponents will be combined, together with separator, to form\na fully qualified channel name." json:"channelNameComponents"`
	Separator             string                                 `json:"separator"`
}

func (o PivotedTimescaleScrapingConfig) MarshalJSON() ([]byte, error) {
	if o.Filter == nil {
		o.Filter = make([]TimescaleScrapingFilter, 0)
	}
	if o.DimensionColumns == nil {
		o.DimensionColumns = make([]ColumnName, 0)
	}
	if o.ChannelNameComponents == nil {
		o.ChannelNameComponents = make([]PivotedTimescaleChannelNameComponent, 0)
	}
	type _tmpPivotedTimescaleScrapingConfig PivotedTimescaleScrapingConfig
	return safejson.Marshal(_tmpPivotedTimescaleScrapingConfig(o))
}

func (o *PivotedTimescaleScrapingConfig) UnmarshalJSON(data []byte) error {
	type _tmpPivotedTimescaleScrapingConfig PivotedTimescaleScrapingConfig
	var rawPivotedTimescaleScrapingConfig _tmpPivotedTimescaleScrapingConfig
	if err := safejson.Unmarshal(data, &rawPivotedTimescaleScrapingConfig); err != nil {
		return err
	}
	if rawPivotedTimescaleScrapingConfig.Filter == nil {
		rawPivotedTimescaleScrapingConfig.Filter = make([]TimescaleScrapingFilter, 0)
	}
	if rawPivotedTimescaleScrapingConfig.DimensionColumns == nil {
		rawPivotedTimescaleScrapingConfig.DimensionColumns = make([]ColumnName, 0)
	}
	if rawPivotedTimescaleScrapingConfig.ChannelNameComponents == nil {
		rawPivotedTimescaleScrapingConfig.ChannelNameComponents = make([]PivotedTimescaleChannelNameComponent, 0)
	}
	*o = PivotedTimescaleScrapingConfig(rawPivotedTimescaleScrapingConfig)
	return nil
}

func (o PivotedTimescaleScrapingConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PivotedTimescaleScrapingConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PopulateSeriesRequest struct {
	StartTime *datetime.DateTime `json:"startTime,omitempty"`
	EndTime   *datetime.DateTime `json:"endTime,omitempty"`
}

func (o PopulateSeriesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PopulateSeriesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimescaleConnectionDetails struct {
	Database string `json:"database"`
	Host     string `json:"host"`
	Port     int    `json:"port"`
	// This is also the reference to the secret containing the password
	Username string `conjure-docs:"This is also the reference to the secret containing the password" json:"username"`
	// Secret Rid of password secret stored in Secrets Service.
	PasswordSecretRid SecretRid `conjure-docs:"Secret Rid of password secret stored in Secrets Service." json:"passwordSecretRid"`
}

func (o TimescaleConnectionDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimescaleConnectionDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimestreamConnectionDetails struct {
	// The role ARN owned by Nominal that has permission to assume the externalRoleArn.
	NominalRoleArn string `conjure-docs:"The role ARN owned by Nominal that has permission to assume the externalRoleArn." json:"nominalRoleArn"`
	// AWS region that contains the Nominal role.
	NominalRoleRegion string `conjure-docs:"AWS region that contains the Nominal role." json:"nominalRoleRegion"`
	// AWS region that contains the Timestream instance.
	ExternalRegion string `conjure-docs:"AWS region that contains the Timestream instance." json:"externalRegion"`
	// The role ARN used to make queries to Timestream. This role is owned by the AWS account that owns the Timestream instance.
	ExternalRoleArn string `conjure-docs:"The role ARN used to make queries to Timestream. This role is owned by the AWS account that owns the Timestream instance." json:"externalRoleArn"`
	// Database inside of the Timestream instance to connect to.
	Database string `conjure-docs:"Database inside of the Timestream instance to connect to." json:"database"`
}

func (o TimestreamConnectionDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimestreamConnectionDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimestreamScrapingConfig struct {
	/*
	   In order for data to be picked up by the scraper, it must match all
	   filters in this list.
	*/
	Filter []TimestreamScrapingFilter `conjure-docs:"In order for data to be picked up by the scraper, it must match all\nfilters in this list." json:"filter"`
	/*
	   channelNameComponents will be combined, together with separator, to form
	   a fully qualified channel name.
	*/
	ChannelNameComponents []TimestreamChannelNameComponent `conjure-docs:"channelNameComponents will be combined, together with separator, to form\na fully qualified channel name." json:"channelNameComponents"`
	Separator             string                           `json:"separator"`
	/*
	   The maximum time in hours to look back over series data to find unique measure and tag combinations.
	   If not specified, the default look back period will be used.
	*/
	MaxLookBackPeriodHours *int `conjure-docs:"The maximum time in hours to look back over series data to find unique measure and tag combinations.\nIf not specified, the default look back period will be used." json:"maxLookBackPeriodHours,omitempty"`
}

func (o TimestreamScrapingConfig) MarshalJSON() ([]byte, error) {
	if o.Filter == nil {
		o.Filter = make([]TimestreamScrapingFilter, 0)
	}
	if o.ChannelNameComponents == nil {
		o.ChannelNameComponents = make([]TimestreamChannelNameComponent, 0)
	}
	type _tmpTimestreamScrapingConfig TimestreamScrapingConfig
	return safejson.Marshal(_tmpTimestreamScrapingConfig(o))
}

func (o *TimestreamScrapingConfig) UnmarshalJSON(data []byte) error {
	type _tmpTimestreamScrapingConfig TimestreamScrapingConfig
	var rawTimestreamScrapingConfig _tmpTimestreamScrapingConfig
	if err := safejson.Unmarshal(data, &rawTimestreamScrapingConfig); err != nil {
		return err
	}
	if rawTimestreamScrapingConfig.Filter == nil {
		rawTimestreamScrapingConfig.Filter = make([]TimestreamScrapingFilter, 0)
	}
	if rawTimestreamScrapingConfig.ChannelNameComponents == nil {
		rawTimestreamScrapingConfig.ChannelNameComponents = make([]TimestreamChannelNameComponent, 0)
	}
	*o = TimestreamScrapingConfig(rawTimestreamScrapingConfig)
	return nil
}

func (o TimestreamScrapingConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimestreamScrapingConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Fields that are empty will be treated as a no-op update.
type UpdateConnectionRequest struct {
	Name              *string            `json:"name,omitempty"`
	Description       *string            `json:"description,omitempty"`
	Metadata          *map[string]string `json:"metadata,omitempty"`
	ConnectionDetails *ConnectionDetails `json:"connectionDetails,omitempty"`
	RequiredTagNames  *[]api.TagName     `json:"requiredTagNames,omitempty"`
	/*
	   In most cases, this does not to be set by the user. Throws if populated for Nominal connections, which
	   have their tags automatically indexed in the underlying database. Tags for external connections are
	   periodically scraped. Tags should only be updated manually for Visual crossing connections.
	*/
	AvailableTagValues *map[api.TagName][]api.TagValue `conjure-docs:"In most cases, this does not to be set by the user. Throws if populated for Nominal connections, which \nhave their tags automatically indexed in the underlying database. Tags for external connections are \nperiodically scraped. Tags should only be updated manually for Visual crossing connections." json:"availableTagValues,omitempty"`
	Scraping           *ScrapingConfig                 `json:"scraping,omitempty"`
	ShouldScrape       *bool                           `json:"shouldScrape,omitempty"`
	Limits             *LimitsConfig                   `json:"limits,omitempty"`
}

func (o UpdateConnectionRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateConnectionRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Deprecated and not used for anything anymore, see record VisualCrossingAvailableSeries instead.
type VisualCrossingAvailableSeries struct {
	Channel     api.Channel        `json:"channel"`
	Unit        *api.Unit          `json:"unit,omitempty"`
	Description *string            `json:"description,omitempty"`
	Type        VisualCrossingType `json:"type"`
}

func (o VisualCrossingAvailableSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VisualCrossingAvailableSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type VisualCrossingConnectionDetails struct {
	// Secret Rid of API key stored in Secrets Service.
	ApiKeySecretRid SecretRid `conjure-docs:"Secret Rid of API key stored in Secrets Service." json:"apiKeySecretRid"`
}

func (o VisualCrossingConnectionDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VisualCrossingConnectionDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type VisualCrossingScrapingConfig struct {
	/*
	   list of available channels

	   Deprecated: No longer used for anything
	*/
	AvailableSeries []VisualCrossingAvailableSeries `conjure-docs:"list of available channels" json:"availableSeries"`
}

func (o VisualCrossingScrapingConfig) MarshalJSON() ([]byte, error) {
	if o.AvailableSeries == nil {
		o.AvailableSeries = make([]VisualCrossingAvailableSeries, 0)
	}
	type _tmpVisualCrossingScrapingConfig VisualCrossingScrapingConfig
	return safejson.Marshal(_tmpVisualCrossingScrapingConfig(o))
}

func (o *VisualCrossingScrapingConfig) UnmarshalJSON(data []byte) error {
	type _tmpVisualCrossingScrapingConfig VisualCrossingScrapingConfig
	var rawVisualCrossingScrapingConfig _tmpVisualCrossingScrapingConfig
	if err := safejson.Unmarshal(data, &rawVisualCrossingScrapingConfig); err != nil {
		return err
	}
	if rawVisualCrossingScrapingConfig.AvailableSeries == nil {
		rawVisualCrossingScrapingConfig.AvailableSeries = make([]VisualCrossingAvailableSeries, 0)
	}
	*o = VisualCrossingScrapingConfig(rawVisualCrossingScrapingConfig)
	return nil
}

func (o VisualCrossingScrapingConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VisualCrossingScrapingConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
