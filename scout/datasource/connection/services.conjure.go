// Code generated by conjure-go. DO NOT EDIT.

package connection

import (
	"context"
	"fmt"
	"net/url"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/scout/datasource/connection/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	werror "github.com/palantir/witchcraft-go-error"
)

/*
Nominal periodically scrapes connected databases (Connections) in order to maintain a database of all
series that can be read from that database. This service is responsible for executing the scrape, and can
be used manually to trigger a rescrape for any reason (for example, when updating a schema).
*/
type ConnectionBootstrapperServiceClient interface {
	/*
	   Populates the connection with series, by querying within the requested time range. If start or end are both omitted,
	   will query the last 7 days by default. If one of start or end is omitted, will query a 7 day range from the provided
	   start or end. Will throw if the requested range is larger than 30 days.
	*/
	PopulateSeries(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid, requestArg api.PopulateSeriesRequest) error
}

type connectionBootstrapperServiceClient struct {
	client httpclient.Client
}

func NewConnectionBootstrapperServiceClient(client httpclient.Client) ConnectionBootstrapperServiceClient {
	return &connectionBootstrapperServiceClient{client: client}
}

func (c *connectionBootstrapperServiceClient) PopulateSeries(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid, requestArg api.PopulateSeriesRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("PopulateSeries"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/data-source/connection/v1/%s/populateSeries", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "populateSeries failed")
	}
	return nil
}

/*
Nominal periodically scrapes connected databases (Connections) in order to maintain a database of all
series that can be read from that database. This service is responsible for executing the scrape, and can
be used manually to trigger a rescrape for any reason (for example, when updating a schema).
*/
type ConnectionBootstrapperServiceClientWithAuth interface {
	/*
	   Populates the connection with series, by querying within the requested time range. If start or end are both omitted,
	   will query the last 7 days by default. If one of start or end is omitted, will query a 7 day range from the provided
	   start or end. Will throw if the requested range is larger than 30 days.
	*/
	PopulateSeries(ctx context.Context, ridArg api.ConnectionRid, requestArg api.PopulateSeriesRequest) error
}

func NewConnectionBootstrapperServiceClientWithAuth(client ConnectionBootstrapperServiceClient, authHeader bearertoken.Token) ConnectionBootstrapperServiceClientWithAuth {
	return &connectionBootstrapperServiceClientWithAuth{client: client, authHeader: authHeader}
}

type connectionBootstrapperServiceClientWithAuth struct {
	client     ConnectionBootstrapperServiceClient
	authHeader bearertoken.Token
}

func (c *connectionBootstrapperServiceClientWithAuth) PopulateSeries(ctx context.Context, ridArg api.ConnectionRid, requestArg api.PopulateSeriesRequest) error {
	return c.client.PopulateSeries(ctx, c.authHeader, ridArg, requestArg)
}

func NewConnectionBootstrapperServiceClientWithTokenProvider(client ConnectionBootstrapperServiceClient, tokenProvider httpclient.TokenProvider) ConnectionBootstrapperServiceClientWithAuth {
	return &connectionBootstrapperServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type connectionBootstrapperServiceClientWithTokenProvider struct {
	client        ConnectionBootstrapperServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *connectionBootstrapperServiceClientWithTokenProvider) PopulateSeries(ctx context.Context, ridArg api.ConnectionRid, requestArg api.PopulateSeriesRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.PopulateSeries(ctx, bearertoken.Token(token), ridArg, requestArg)
}

/*
A Connection contains the relevant metadata and information to be used as a data source for runs.
The Connection Service is responsible for creating, updating, and retrieving database connections.
*/
type ConnectionServiceClient interface {
	// Creates a new connection.
	CreateConnection(ctx context.Context, authHeader bearertoken.Token, createConnectionArg api.CreateConnection) (api.Connection, error)
	// Updates an existing connection.
	UpdateConnection(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid, requestArg api.UpdateConnectionRequest) (api.Connection, error)
	// Updates an existing connection status.
	UpdateConnectionStatus(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid, requestArg api.ConnectionStatus) error
	/*
	   Adds available tag key/value pairs to the connection. If a tag name already exists, the values will be merged.
	   This is primarily an internal endpoint to update tags for external connections as they are periodically
	   scraped. This endpoint should only be called by clients for Visual crossing connections. Throws if called for
	   Nominal connections which have their tags automatically indexed in the underlying Database.
	*/
	AddAvailableTags(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid, tagsArg map[api1.TagName][]api1.TagValue) (api.Connection, error)
	// Gets a connection by its RID.
	GetConnection(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid) (api.Connection, error)
	// Gets a set of connections by their RIDs.
	GetConnections(ctx context.Context, authHeader bearertoken.Token, ridsArg []api.ConnectionRid) ([]api.Connection, error)
	// Lists all connections.
	ListConnections(ctx context.Context, authHeader bearertoken.Token, includeArchivedArg *bool, workspacesArg []rids.WorkspaceRid) ([]api.Connection, error)
	// Archives a connection, which simply tags the connection for a client to filter.
	ArchiveConnection(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid) error
	// Undoes the archiving of a connection.
	UnarchiveConnection(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid) error
}

type connectionServiceClient struct {
	client httpclient.Client
}

func NewConnectionServiceClient(client httpclient.Client) ConnectionServiceClient {
	return &connectionServiceClient{client: client}
}

func (c *connectionServiceClient) CreateConnection(ctx context.Context, authHeader bearertoken.Token, createConnectionArg api.CreateConnection) (api.Connection, error) {
	var defaultReturnVal api.Connection
	var returnVal *api.Connection
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateConnection"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/data-source/connection/v1/connections"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(createConnectionArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createConnection failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createConnection response cannot be nil")
	}
	return *returnVal, nil
}

func (c *connectionServiceClient) UpdateConnection(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid, requestArg api.UpdateConnectionRequest) (api.Connection, error) {
	var defaultReturnVal api.Connection
	var returnVal *api.Connection
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateConnection"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/data-source/connection/v1/connection/%s/details", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateConnection failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateConnection response cannot be nil")
	}
	return *returnVal, nil
}

func (c *connectionServiceClient) UpdateConnectionStatus(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid, requestArg api.ConnectionStatus) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateConnectionStatus"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/data-source/connection/v1/connection/%s/status", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "updateConnectionStatus failed")
	}
	return nil
}

func (c *connectionServiceClient) AddAvailableTags(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid, tagsArg map[api1.TagName][]api1.TagValue) (api.Connection, error) {
	var defaultReturnVal api.Connection
	var returnVal *api.Connection
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("AddAvailableTags"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/data-source/connection/v1/connection/%s/available-tags", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(tagsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "addAvailableTags failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "addAvailableTags response cannot be nil")
	}
	return *returnVal, nil
}

func (c *connectionServiceClient) GetConnection(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid) (api.Connection, error) {
	var defaultReturnVal api.Connection
	var returnVal *api.Connection
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetConnection"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/data-source/connection/v1/connection/%s", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getConnection failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getConnection response cannot be nil")
	}
	return *returnVal, nil
}

func (c *connectionServiceClient) GetConnections(ctx context.Context, authHeader bearertoken.Token, ridsArg []api.ConnectionRid) ([]api.Connection, error) {
	var returnVal []api.Connection
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetConnections"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/data-source/connection/v1/connection/multiple"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(ridsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getConnections failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getConnections response cannot be nil")
	}
	return returnVal, nil
}

func (c *connectionServiceClient) ListConnections(ctx context.Context, authHeader bearertoken.Token, includeArchivedArg *bool, workspacesArg []rids.WorkspaceRid) ([]api.Connection, error) {
	var returnVal []api.Connection
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ListConnections"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/data-source/connection/v1/connections"))
	queryParams := make(url.Values)
	if includeArchivedArg != nil {
		queryParams.Set("includeArchived", fmt.Sprint(*includeArchivedArg))
	}
	for _, v := range workspacesArg {
		queryParams.Add("workspaces", fmt.Sprint(v))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "listConnections failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "listConnections response cannot be nil")
	}
	return returnVal, nil
}

func (c *connectionServiceClient) ArchiveConnection(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ArchiveConnection"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/data-source/connection/v1/connections/%s/archive", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "archiveConnection failed")
	}
	return nil
}

func (c *connectionServiceClient) UnarchiveConnection(ctx context.Context, authHeader bearertoken.Token, ridArg api.ConnectionRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UnarchiveConnection"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/data-source/connection/v1/connections/%s/unarchive", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "unarchiveConnection failed")
	}
	return nil
}

/*
A Connection contains the relevant metadata and information to be used as a data source for runs.
The Connection Service is responsible for creating, updating, and retrieving database connections.
*/
type ConnectionServiceClientWithAuth interface {
	// Creates a new connection.
	CreateConnection(ctx context.Context, createConnectionArg api.CreateConnection) (api.Connection, error)
	// Updates an existing connection.
	UpdateConnection(ctx context.Context, ridArg api.ConnectionRid, requestArg api.UpdateConnectionRequest) (api.Connection, error)
	// Updates an existing connection status.
	UpdateConnectionStatus(ctx context.Context, ridArg api.ConnectionRid, requestArg api.ConnectionStatus) error
	/*
	   Adds available tag key/value pairs to the connection. If a tag name already exists, the values will be merged.
	   This is primarily an internal endpoint to update tags for external connections as they are periodically
	   scraped. This endpoint should only be called by clients for Visual crossing connections. Throws if called for
	   Nominal connections which have their tags automatically indexed in the underlying Database.
	*/
	AddAvailableTags(ctx context.Context, ridArg api.ConnectionRid, tagsArg map[api1.TagName][]api1.TagValue) (api.Connection, error)
	// Gets a connection by its RID.
	GetConnection(ctx context.Context, ridArg api.ConnectionRid) (api.Connection, error)
	// Gets a set of connections by their RIDs.
	GetConnections(ctx context.Context, ridsArg []api.ConnectionRid) ([]api.Connection, error)
	// Lists all connections.
	ListConnections(ctx context.Context, includeArchivedArg *bool, workspacesArg []rids.WorkspaceRid) ([]api.Connection, error)
	// Archives a connection, which simply tags the connection for a client to filter.
	ArchiveConnection(ctx context.Context, ridArg api.ConnectionRid) error
	// Undoes the archiving of a connection.
	UnarchiveConnection(ctx context.Context, ridArg api.ConnectionRid) error
}

func NewConnectionServiceClientWithAuth(client ConnectionServiceClient, authHeader bearertoken.Token) ConnectionServiceClientWithAuth {
	return &connectionServiceClientWithAuth{client: client, authHeader: authHeader}
}

type connectionServiceClientWithAuth struct {
	client     ConnectionServiceClient
	authHeader bearertoken.Token
}

func (c *connectionServiceClientWithAuth) CreateConnection(ctx context.Context, createConnectionArg api.CreateConnection) (api.Connection, error) {
	return c.client.CreateConnection(ctx, c.authHeader, createConnectionArg)
}

func (c *connectionServiceClientWithAuth) UpdateConnection(ctx context.Context, ridArg api.ConnectionRid, requestArg api.UpdateConnectionRequest) (api.Connection, error) {
	return c.client.UpdateConnection(ctx, c.authHeader, ridArg, requestArg)
}

func (c *connectionServiceClientWithAuth) UpdateConnectionStatus(ctx context.Context, ridArg api.ConnectionRid, requestArg api.ConnectionStatus) error {
	return c.client.UpdateConnectionStatus(ctx, c.authHeader, ridArg, requestArg)
}

func (c *connectionServiceClientWithAuth) AddAvailableTags(ctx context.Context, ridArg api.ConnectionRid, tagsArg map[api1.TagName][]api1.TagValue) (api.Connection, error) {
	return c.client.AddAvailableTags(ctx, c.authHeader, ridArg, tagsArg)
}

func (c *connectionServiceClientWithAuth) GetConnection(ctx context.Context, ridArg api.ConnectionRid) (api.Connection, error) {
	return c.client.GetConnection(ctx, c.authHeader, ridArg)
}

func (c *connectionServiceClientWithAuth) GetConnections(ctx context.Context, ridsArg []api.ConnectionRid) ([]api.Connection, error) {
	return c.client.GetConnections(ctx, c.authHeader, ridsArg)
}

func (c *connectionServiceClientWithAuth) ListConnections(ctx context.Context, includeArchivedArg *bool, workspacesArg []rids.WorkspaceRid) ([]api.Connection, error) {
	return c.client.ListConnections(ctx, c.authHeader, includeArchivedArg, workspacesArg)
}

func (c *connectionServiceClientWithAuth) ArchiveConnection(ctx context.Context, ridArg api.ConnectionRid) error {
	return c.client.ArchiveConnection(ctx, c.authHeader, ridArg)
}

func (c *connectionServiceClientWithAuth) UnarchiveConnection(ctx context.Context, ridArg api.ConnectionRid) error {
	return c.client.UnarchiveConnection(ctx, c.authHeader, ridArg)
}

func NewConnectionServiceClientWithTokenProvider(client ConnectionServiceClient, tokenProvider httpclient.TokenProvider) ConnectionServiceClientWithAuth {
	return &connectionServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type connectionServiceClientWithTokenProvider struct {
	client        ConnectionServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *connectionServiceClientWithTokenProvider) CreateConnection(ctx context.Context, createConnectionArg api.CreateConnection) (api.Connection, error) {
	var defaultReturnVal api.Connection
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateConnection(ctx, bearertoken.Token(token), createConnectionArg)
}

func (c *connectionServiceClientWithTokenProvider) UpdateConnection(ctx context.Context, ridArg api.ConnectionRid, requestArg api.UpdateConnectionRequest) (api.Connection, error) {
	var defaultReturnVal api.Connection
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateConnection(ctx, bearertoken.Token(token), ridArg, requestArg)
}

func (c *connectionServiceClientWithTokenProvider) UpdateConnectionStatus(ctx context.Context, ridArg api.ConnectionRid, requestArg api.ConnectionStatus) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.UpdateConnectionStatus(ctx, bearertoken.Token(token), ridArg, requestArg)
}

func (c *connectionServiceClientWithTokenProvider) AddAvailableTags(ctx context.Context, ridArg api.ConnectionRid, tagsArg map[api1.TagName][]api1.TagValue) (api.Connection, error) {
	var defaultReturnVal api.Connection
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.AddAvailableTags(ctx, bearertoken.Token(token), ridArg, tagsArg)
}

func (c *connectionServiceClientWithTokenProvider) GetConnection(ctx context.Context, ridArg api.ConnectionRid) (api.Connection, error) {
	var defaultReturnVal api.Connection
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetConnection(ctx, bearertoken.Token(token), ridArg)
}

func (c *connectionServiceClientWithTokenProvider) GetConnections(ctx context.Context, ridsArg []api.ConnectionRid) ([]api.Connection, error) {
	var defaultReturnVal []api.Connection
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetConnections(ctx, bearertoken.Token(token), ridsArg)
}

func (c *connectionServiceClientWithTokenProvider) ListConnections(ctx context.Context, includeArchivedArg *bool, workspacesArg []rids.WorkspaceRid) ([]api.Connection, error) {
	var defaultReturnVal []api.Connection
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ListConnections(ctx, bearertoken.Token(token), includeArchivedArg, workspacesArg)
}

func (c *connectionServiceClientWithTokenProvider) ArchiveConnection(ctx context.Context, ridArg api.ConnectionRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.ArchiveConnection(ctx, bearertoken.Token(token), ridArg)
}

func (c *connectionServiceClientWithTokenProvider) UnarchiveConnection(ctx context.Context, ridArg api.ConnectionRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.UnarchiveConnection(ctx, bearertoken.Token(token), ridArg)
}
