// Code generated by conjure-go. DO NOT EDIT.

package catalog

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/io/nominal/api"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type AbsoluteTimestamp struct {
	typ             string
	iso8601         *Iso8601Timestamp
	epochOfTimeUnit *EpochTimestamp
	customFormat    *CustomTimestamp
}

type absoluteTimestampDeserializer struct {
	Type            string            `json:"type"`
	Iso8601         *Iso8601Timestamp `json:"iso8601"`
	EpochOfTimeUnit *EpochTimestamp   `json:"epochOfTimeUnit"`
	CustomFormat    *CustomTimestamp  `json:"customFormat"`
}

func (u *absoluteTimestampDeserializer) toStruct() AbsoluteTimestamp {
	return AbsoluteTimestamp{typ: u.Type, iso8601: u.Iso8601, epochOfTimeUnit: u.EpochOfTimeUnit, customFormat: u.CustomFormat}
}

func (u *AbsoluteTimestamp) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return nil, fmt.Errorf("field \"iso8601\" is required")
		}
		return struct {
			Type    string           `json:"type"`
			Iso8601 Iso8601Timestamp `json:"iso8601"`
		}{Type: "iso8601", Iso8601: *u.iso8601}, nil
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return nil, fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return struct {
			Type            string         `json:"type"`
			EpochOfTimeUnit EpochTimestamp `json:"epochOfTimeUnit"`
		}{Type: "epochOfTimeUnit", EpochOfTimeUnit: *u.epochOfTimeUnit}, nil
	case "customFormat":
		if u.customFormat == nil {
			return nil, fmt.Errorf("field \"customFormat\" is required")
		}
		return struct {
			Type         string          `json:"type"`
			CustomFormat CustomTimestamp `json:"customFormat"`
		}{Type: "customFormat", CustomFormat: *u.customFormat}, nil
	}
}

func (u AbsoluteTimestamp) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *AbsoluteTimestamp) UnmarshalJSON(data []byte) error {
	var deser absoluteTimestampDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
	case "customFormat":
		if u.customFormat == nil {
			return fmt.Errorf("field \"customFormat\" is required")
		}
	}
	return nil
}

func (u AbsoluteTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *AbsoluteTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *AbsoluteTimestamp) AcceptFuncs(iso8601Func func(Iso8601Timestamp) error, epochOfTimeUnitFunc func(EpochTimestamp) error, customFormatFunc func(CustomTimestamp) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
		return iso8601Func(*u.iso8601)
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return epochOfTimeUnitFunc(*u.epochOfTimeUnit)
	case "customFormat":
		if u.customFormat == nil {
			return fmt.Errorf("field \"customFormat\" is required")
		}
		return customFormatFunc(*u.customFormat)
	}
}

func (u *AbsoluteTimestamp) Iso8601NoopSuccess(Iso8601Timestamp) error {
	return nil
}

func (u *AbsoluteTimestamp) EpochOfTimeUnitNoopSuccess(EpochTimestamp) error {
	return nil
}

func (u *AbsoluteTimestamp) CustomFormatNoopSuccess(CustomTimestamp) error {
	return nil
}

func (u *AbsoluteTimestamp) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *AbsoluteTimestamp) Accept(v AbsoluteTimestampVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
		return v.VisitIso8601(*u.iso8601)
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return v.VisitEpochOfTimeUnit(*u.epochOfTimeUnit)
	case "customFormat":
		if u.customFormat == nil {
			return fmt.Errorf("field \"customFormat\" is required")
		}
		return v.VisitCustomFormat(*u.customFormat)
	}
}

type AbsoluteTimestampVisitor interface {
	VisitIso8601(v Iso8601Timestamp) error
	VisitEpochOfTimeUnit(v EpochTimestamp) error
	VisitCustomFormat(v CustomTimestamp) error
	VisitUnknown(typeName string) error
}

func (u *AbsoluteTimestamp) AcceptWithContext(ctx context.Context, v AbsoluteTimestampVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
		return v.VisitIso8601WithContext(ctx, *u.iso8601)
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return v.VisitEpochOfTimeUnitWithContext(ctx, *u.epochOfTimeUnit)
	case "customFormat":
		if u.customFormat == nil {
			return fmt.Errorf("field \"customFormat\" is required")
		}
		return v.VisitCustomFormatWithContext(ctx, *u.customFormat)
	}
}

type AbsoluteTimestampVisitorWithContext interface {
	VisitIso8601WithContext(ctx context.Context, v Iso8601Timestamp) error
	VisitEpochOfTimeUnitWithContext(ctx context.Context, v EpochTimestamp) error
	VisitCustomFormatWithContext(ctx context.Context, v CustomTimestamp) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAbsoluteTimestampFromIso8601(v Iso8601Timestamp) AbsoluteTimestamp {
	return AbsoluteTimestamp{typ: "iso8601", iso8601: &v}
}

func NewAbsoluteTimestampFromEpochOfTimeUnit(v EpochTimestamp) AbsoluteTimestamp {
	return AbsoluteTimestamp{typ: "epochOfTimeUnit", epochOfTimeUnit: &v}
}

func NewAbsoluteTimestampFromCustomFormat(v CustomTimestamp) AbsoluteTimestamp {
	return AbsoluteTimestamp{typ: "customFormat", customFormat: &v}
}

type Handle struct {
	typ string
	s3  *S3Handle
}

type handleDeserializer struct {
	Type string    `json:"type"`
	S3   *S3Handle `json:"s3"`
}

func (u *handleDeserializer) toStruct() Handle {
	return Handle{typ: u.Type, s3: u.S3}
}

func (u *Handle) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "s3":
		if u.s3 == nil {
			return nil, fmt.Errorf("field \"s3\" is required")
		}
		return struct {
			Type string   `json:"type"`
			S3   S3Handle `json:"s3"`
		}{Type: "s3", S3: *u.s3}, nil
	}
}

func (u Handle) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Handle) UnmarshalJSON(data []byte) error {
	var deser handleDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
	}
	return nil
}

func (u Handle) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Handle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Handle) AcceptFuncs(s3Func func(S3Handle) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return s3Func(*u.s3)
	}
}

func (u *Handle) S3NoopSuccess(S3Handle) error {
	return nil
}

func (u *Handle) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Handle) Accept(v HandleVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3(*u.s3)
	}
}

type HandleVisitor interface {
	VisitS3(v S3Handle) error
	VisitUnknown(typeName string) error
}

func (u *Handle) AcceptWithContext(ctx context.Context, v HandleVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3WithContext(ctx, *u.s3)
	}
}

type HandleVisitorWithContext interface {
	VisitS3WithContext(ctx context.Context, v S3Handle) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewHandleFromS3(v S3Handle) Handle {
	return Handle{typ: "s3", s3: &v}
}

type SearchDatasetFilesQuery struct {
	typ       string
	timeRange *TimeRangeFilter
	fileTags  *map[api.TagName]api.TagValue
	and       *[]SearchDatasetFilesQuery
	or        *[]SearchDatasetFilesQuery
}

type searchDatasetFilesQueryDeserializer struct {
	Type      string                        `json:"type"`
	TimeRange *TimeRangeFilter              `json:"timeRange"`
	FileTags  *map[api.TagName]api.TagValue `json:"fileTags"`
	And       *[]SearchDatasetFilesQuery    `json:"and"`
	Or        *[]SearchDatasetFilesQuery    `json:"or"`
}

func (u *searchDatasetFilesQueryDeserializer) toStruct() SearchDatasetFilesQuery {
	return SearchDatasetFilesQuery{typ: u.Type, timeRange: u.TimeRange, fileTags: u.FileTags, and: u.And, or: u.Or}
}

func (u *SearchDatasetFilesQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timeRange":
		if u.timeRange == nil {
			return nil, fmt.Errorf("field \"timeRange\" is required")
		}
		return struct {
			Type      string          `json:"type"`
			TimeRange TimeRangeFilter `json:"timeRange"`
		}{Type: "timeRange", TimeRange: *u.timeRange}, nil
	case "fileTags":
		if u.fileTags == nil {
			return nil, fmt.Errorf("field \"fileTags\" is required")
		}
		return struct {
			Type     string                       `json:"type"`
			FileTags map[api.TagName]api.TagValue `json:"fileTags"`
		}{Type: "fileTags", FileTags: *u.fileTags}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			And  []SearchDatasetFilesQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			Or   []SearchDatasetFilesQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	}
}

func (u SearchDatasetFilesQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchDatasetFilesQuery) UnmarshalJSON(data []byte) error {
	var deser searchDatasetFilesQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
	case "fileTags":
		if u.fileTags == nil {
			return fmt.Errorf("field \"fileTags\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	}
	return nil
}

func (u SearchDatasetFilesQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchDatasetFilesQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchDatasetFilesQuery) AcceptFuncs(timeRangeFunc func(TimeRangeFilter) error, fileTagsFunc func(map[api.TagName]api.TagValue) error, andFunc func([]SearchDatasetFilesQuery) error, orFunc func([]SearchDatasetFilesQuery) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
		return timeRangeFunc(*u.timeRange)
	case "fileTags":
		if u.fileTags == nil {
			return fmt.Errorf("field \"fileTags\" is required")
		}
		return fileTagsFunc(*u.fileTags)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	}
}

func (u *SearchDatasetFilesQuery) TimeRangeNoopSuccess(TimeRangeFilter) error {
	return nil
}

func (u *SearchDatasetFilesQuery) FileTagsNoopSuccess(map[api.TagName]api.TagValue) error {
	return nil
}

func (u *SearchDatasetFilesQuery) AndNoopSuccess([]SearchDatasetFilesQuery) error {
	return nil
}

func (u *SearchDatasetFilesQuery) OrNoopSuccess([]SearchDatasetFilesQuery) error {
	return nil
}

func (u *SearchDatasetFilesQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchDatasetFilesQuery) Accept(v SearchDatasetFilesQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
		return v.VisitTimeRange(*u.timeRange)
	case "fileTags":
		if u.fileTags == nil {
			return fmt.Errorf("field \"fileTags\" is required")
		}
		return v.VisitFileTags(*u.fileTags)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	}
}

type SearchDatasetFilesQueryVisitor interface {
	VisitTimeRange(v TimeRangeFilter) error
	VisitFileTags(v map[api.TagName]api.TagValue) error
	VisitAnd(v []SearchDatasetFilesQuery) error
	VisitOr(v []SearchDatasetFilesQuery) error
	VisitUnknown(typeName string) error
}

func (u *SearchDatasetFilesQuery) AcceptWithContext(ctx context.Context, v SearchDatasetFilesQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
		return v.VisitTimeRangeWithContext(ctx, *u.timeRange)
	case "fileTags":
		if u.fileTags == nil {
			return fmt.Errorf("field \"fileTags\" is required")
		}
		return v.VisitFileTagsWithContext(ctx, *u.fileTags)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	}
}

type SearchDatasetFilesQueryVisitorWithContext interface {
	VisitTimeRangeWithContext(ctx context.Context, v TimeRangeFilter) error
	VisitFileTagsWithContext(ctx context.Context, v map[api.TagName]api.TagValue) error
	VisitAndWithContext(ctx context.Context, v []SearchDatasetFilesQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchDatasetFilesQuery) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchDatasetFilesQueryFromTimeRange(v TimeRangeFilter) SearchDatasetFilesQuery {
	return SearchDatasetFilesQuery{typ: "timeRange", timeRange: &v}
}

func NewSearchDatasetFilesQueryFromFileTags(v map[api.TagName]api.TagValue) SearchDatasetFilesQuery {
	return SearchDatasetFilesQuery{typ: "fileTags", fileTags: &v}
}

func NewSearchDatasetFilesQueryFromAnd(v []SearchDatasetFilesQuery) SearchDatasetFilesQuery {
	return SearchDatasetFilesQuery{typ: "and", and: &v}
}

func NewSearchDatasetFilesQueryFromOr(v []SearchDatasetFilesQuery) SearchDatasetFilesQuery {
	return SearchDatasetFilesQuery{typ: "or", or: &v}
}

type SearchDatasetsQuery struct {
	typ                     string
	searchText              *string
	exactMatch              *string
	label                   *api.Label
	properties              *api.Property
	ingestStatus            *IngestStatus
	ingestedBeforeInclusive *datetime.DateTime
	ingestedAfterInclusive  *datetime.DateTime
	archiveStatus           *bool
	and                     *[]SearchDatasetsQuery
	or                      *[]SearchDatasetsQuery
	workspace               *rids.WorkspaceRid
}

type searchDatasetsQueryDeserializer struct {
	Type                    string                 `json:"type"`
	SearchText              *string                `json:"searchText"`
	ExactMatch              *string                `json:"exactMatch"`
	Label                   *api.Label             `json:"label"`
	Properties              *api.Property          `json:"properties"`
	IngestStatus            *IngestStatus          `json:"ingestStatus"`
	IngestedBeforeInclusive *datetime.DateTime     `json:"ingestedBeforeInclusive"`
	IngestedAfterInclusive  *datetime.DateTime     `json:"ingestedAfterInclusive"`
	ArchiveStatus           *bool                  `json:"archiveStatus"`
	And                     *[]SearchDatasetsQuery `json:"and"`
	Or                      *[]SearchDatasetsQuery `json:"or"`
	Workspace               *rids.WorkspaceRid     `json:"workspace"`
}

func (u *searchDatasetsQueryDeserializer) toStruct() SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: u.Type, searchText: u.SearchText, exactMatch: u.ExactMatch, label: u.Label, properties: u.Properties, ingestStatus: u.IngestStatus, ingestedBeforeInclusive: u.IngestedBeforeInclusive, ingestedAfterInclusive: u.IngestedAfterInclusive, archiveStatus: u.ArchiveStatus, and: u.And, or: u.Or, workspace: u.Workspace}
}

func (u *SearchDatasetsQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "exactMatch":
		if u.exactMatch == nil {
			return nil, fmt.Errorf("field \"exactMatch\" is required")
		}
		return struct {
			Type       string `json:"type"`
			ExactMatch string `json:"exactMatch"`
		}{Type: "exactMatch", ExactMatch: *u.exactMatch}, nil
	case "label":
		if u.label == nil {
			return nil, fmt.Errorf("field \"label\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Label api.Label `json:"label"`
		}{Type: "label", Label: *u.label}, nil
	case "properties":
		if u.properties == nil {
			return nil, fmt.Errorf("field \"properties\" is required")
		}
		return struct {
			Type       string       `json:"type"`
			Properties api.Property `json:"properties"`
		}{Type: "properties", Properties: *u.properties}, nil
	case "ingestStatus":
		if u.ingestStatus == nil {
			return nil, fmt.Errorf("field \"ingestStatus\" is required")
		}
		return struct {
			Type         string       `json:"type"`
			IngestStatus IngestStatus `json:"ingestStatus"`
		}{Type: "ingestStatus", IngestStatus: *u.ingestStatus}, nil
	case "ingestedBeforeInclusive":
		if u.ingestedBeforeInclusive == nil {
			return nil, fmt.Errorf("field \"ingestedBeforeInclusive\" is required")
		}
		return struct {
			Type                    string            `json:"type"`
			IngestedBeforeInclusive datetime.DateTime `json:"ingestedBeforeInclusive"`
		}{Type: "ingestedBeforeInclusive", IngestedBeforeInclusive: *u.ingestedBeforeInclusive}, nil
	case "ingestedAfterInclusive":
		if u.ingestedAfterInclusive == nil {
			return nil, fmt.Errorf("field \"ingestedAfterInclusive\" is required")
		}
		return struct {
			Type                   string            `json:"type"`
			IngestedAfterInclusive datetime.DateTime `json:"ingestedAfterInclusive"`
		}{Type: "ingestedAfterInclusive", IngestedAfterInclusive: *u.ingestedAfterInclusive}, nil
	case "archiveStatus":
		if u.archiveStatus == nil {
			return nil, fmt.Errorf("field \"archiveStatus\" is required")
		}
		return struct {
			Type          string `json:"type"`
			ArchiveStatus bool   `json:"archiveStatus"`
		}{Type: "archiveStatus", ArchiveStatus: *u.archiveStatus}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string                `json:"type"`
			And  []SearchDatasetsQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string                `json:"type"`
			Or   []SearchDatasetsQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	}
}

func (u SearchDatasetsQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchDatasetsQuery) UnmarshalJSON(data []byte) error {
	var deser searchDatasetsQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
	case "ingestStatus":
		if u.ingestStatus == nil {
			return fmt.Errorf("field \"ingestStatus\" is required")
		}
	case "ingestedBeforeInclusive":
		if u.ingestedBeforeInclusive == nil {
			return fmt.Errorf("field \"ingestedBeforeInclusive\" is required")
		}
	case "ingestedAfterInclusive":
		if u.ingestedAfterInclusive == nil {
			return fmt.Errorf("field \"ingestedAfterInclusive\" is required")
		}
	case "archiveStatus":
		if u.archiveStatus == nil {
			return fmt.Errorf("field \"archiveStatus\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	}
	return nil
}

func (u SearchDatasetsQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchDatasetsQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchDatasetsQuery) AcceptFuncs(searchTextFunc func(string) error, exactMatchFunc func(string) error, labelFunc func(api.Label) error, propertiesFunc func(api.Property) error, ingestStatusFunc func(IngestStatus) error, ingestedBeforeInclusiveFunc func(datetime.DateTime) error, ingestedAfterInclusiveFunc func(datetime.DateTime) error, archiveStatusFunc func(bool) error, andFunc func([]SearchDatasetsQuery) error, orFunc func([]SearchDatasetsQuery) error, workspaceFunc func(rids.WorkspaceRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return exactMatchFunc(*u.exactMatch)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
		return propertiesFunc(*u.properties)
	case "ingestStatus":
		if u.ingestStatus == nil {
			return fmt.Errorf("field \"ingestStatus\" is required")
		}
		return ingestStatusFunc(*u.ingestStatus)
	case "ingestedBeforeInclusive":
		if u.ingestedBeforeInclusive == nil {
			return fmt.Errorf("field \"ingestedBeforeInclusive\" is required")
		}
		return ingestedBeforeInclusiveFunc(*u.ingestedBeforeInclusive)
	case "ingestedAfterInclusive":
		if u.ingestedAfterInclusive == nil {
			return fmt.Errorf("field \"ingestedAfterInclusive\" is required")
		}
		return ingestedAfterInclusiveFunc(*u.ingestedAfterInclusive)
	case "archiveStatus":
		if u.archiveStatus == nil {
			return fmt.Errorf("field \"archiveStatus\" is required")
		}
		return archiveStatusFunc(*u.archiveStatus)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchDatasetsQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *SearchDatasetsQuery) ExactMatchNoopSuccess(string) error {
	return nil
}

func (u *SearchDatasetsQuery) LabelNoopSuccess(api.Label) error {
	return nil
}

func (u *SearchDatasetsQuery) PropertiesNoopSuccess(api.Property) error {
	return nil
}

func (u *SearchDatasetsQuery) IngestStatusNoopSuccess(IngestStatus) error {
	return nil
}

func (u *SearchDatasetsQuery) IngestedBeforeInclusiveNoopSuccess(datetime.DateTime) error {
	return nil
}

func (u *SearchDatasetsQuery) IngestedAfterInclusiveNoopSuccess(datetime.DateTime) error {
	return nil
}

func (u *SearchDatasetsQuery) ArchiveStatusNoopSuccess(bool) error {
	return nil
}

func (u *SearchDatasetsQuery) AndNoopSuccess([]SearchDatasetsQuery) error {
	return nil
}

func (u *SearchDatasetsQuery) OrNoopSuccess([]SearchDatasetsQuery) error {
	return nil
}

func (u *SearchDatasetsQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *SearchDatasetsQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchDatasetsQuery) Accept(v SearchDatasetsQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatch(*u.exactMatch)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(*u.label)
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
		return v.VisitProperties(*u.properties)
	case "ingestStatus":
		if u.ingestStatus == nil {
			return fmt.Errorf("field \"ingestStatus\" is required")
		}
		return v.VisitIngestStatus(*u.ingestStatus)
	case "ingestedBeforeInclusive":
		if u.ingestedBeforeInclusive == nil {
			return fmt.Errorf("field \"ingestedBeforeInclusive\" is required")
		}
		return v.VisitIngestedBeforeInclusive(*u.ingestedBeforeInclusive)
	case "ingestedAfterInclusive":
		if u.ingestedAfterInclusive == nil {
			return fmt.Errorf("field \"ingestedAfterInclusive\" is required")
		}
		return v.VisitIngestedAfterInclusive(*u.ingestedAfterInclusive)
	case "archiveStatus":
		if u.archiveStatus == nil {
			return fmt.Errorf("field \"archiveStatus\" is required")
		}
		return v.VisitArchiveStatus(*u.archiveStatus)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	}
}

type SearchDatasetsQueryVisitor interface {
	VisitSearchText(v string) error
	VisitExactMatch(v string) error
	VisitLabel(v api.Label) error
	VisitProperties(v api.Property) error
	VisitIngestStatus(v IngestStatus) error
	VisitIngestedBeforeInclusive(v datetime.DateTime) error
	VisitIngestedAfterInclusive(v datetime.DateTime) error
	VisitArchiveStatus(v bool) error
	VisitAnd(v []SearchDatasetsQuery) error
	VisitOr(v []SearchDatasetsQuery) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitUnknown(typeName string) error
}

func (u *SearchDatasetsQuery) AcceptWithContext(ctx context.Context, v SearchDatasetsQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatchWithContext(ctx, *u.exactMatch)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabelWithContext(ctx, *u.label)
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
		return v.VisitPropertiesWithContext(ctx, *u.properties)
	case "ingestStatus":
		if u.ingestStatus == nil {
			return fmt.Errorf("field \"ingestStatus\" is required")
		}
		return v.VisitIngestStatusWithContext(ctx, *u.ingestStatus)
	case "ingestedBeforeInclusive":
		if u.ingestedBeforeInclusive == nil {
			return fmt.Errorf("field \"ingestedBeforeInclusive\" is required")
		}
		return v.VisitIngestedBeforeInclusiveWithContext(ctx, *u.ingestedBeforeInclusive)
	case "ingestedAfterInclusive":
		if u.ingestedAfterInclusive == nil {
			return fmt.Errorf("field \"ingestedAfterInclusive\" is required")
		}
		return v.VisitIngestedAfterInclusiveWithContext(ctx, *u.ingestedAfterInclusive)
	case "archiveStatus":
		if u.archiveStatus == nil {
			return fmt.Errorf("field \"archiveStatus\" is required")
		}
		return v.VisitArchiveStatusWithContext(ctx, *u.archiveStatus)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	}
}

type SearchDatasetsQueryVisitorWithContext interface {
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitExactMatchWithContext(ctx context.Context, v string) error
	VisitLabelWithContext(ctx context.Context, v api.Label) error
	VisitPropertiesWithContext(ctx context.Context, v api.Property) error
	VisitIngestStatusWithContext(ctx context.Context, v IngestStatus) error
	VisitIngestedBeforeInclusiveWithContext(ctx context.Context, v datetime.DateTime) error
	VisitIngestedAfterInclusiveWithContext(ctx context.Context, v datetime.DateTime) error
	VisitArchiveStatusWithContext(ctx context.Context, v bool) error
	VisitAndWithContext(ctx context.Context, v []SearchDatasetsQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchDatasetsQuery) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchDatasetsQueryFromSearchText(v string) SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: "searchText", searchText: &v}
}

func NewSearchDatasetsQueryFromExactMatch(v string) SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: "exactMatch", exactMatch: &v}
}

func NewSearchDatasetsQueryFromLabel(v api.Label) SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: "label", label: &v}
}

func NewSearchDatasetsQueryFromProperties(v api.Property) SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: "properties", properties: &v}
}

func NewSearchDatasetsQueryFromIngestStatus(v IngestStatus) SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: "ingestStatus", ingestStatus: &v}
}

func NewSearchDatasetsQueryFromIngestedBeforeInclusive(v datetime.DateTime) SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: "ingestedBeforeInclusive", ingestedBeforeInclusive: &v}
}

func NewSearchDatasetsQueryFromIngestedAfterInclusive(v datetime.DateTime) SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: "ingestedAfterInclusive", ingestedAfterInclusive: &v}
}

func NewSearchDatasetsQueryFromArchiveStatus(v bool) SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: "archiveStatus", archiveStatus: &v}
}

func NewSearchDatasetsQueryFromAnd(v []SearchDatasetsQuery) SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: "and", and: &v}
}

func NewSearchDatasetsQueryFromOr(v []SearchDatasetsQuery) SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: "or", or: &v}
}

func NewSearchDatasetsQueryFromWorkspace(v rids.WorkspaceRid) SearchDatasetsQuery {
	return SearchDatasetsQuery{typ: "workspace", workspace: &v}
}

type TimestampType struct {
	typ      string
	relative *RelativeTimestamp
	absolute *AbsoluteTimestamp
}

type timestampTypeDeserializer struct {
	Type     string             `json:"type"`
	Relative *RelativeTimestamp `json:"relative"`
	Absolute *AbsoluteTimestamp `json:"absolute"`
}

func (u *timestampTypeDeserializer) toStruct() TimestampType {
	return TimestampType{typ: u.Type, relative: u.Relative, absolute: u.Absolute}
}

func (u *TimestampType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "relative":
		if u.relative == nil {
			return nil, fmt.Errorf("field \"relative\" is required")
		}
		return struct {
			Type     string            `json:"type"`
			Relative RelativeTimestamp `json:"relative"`
		}{Type: "relative", Relative: *u.relative}, nil
	case "absolute":
		if u.absolute == nil {
			return nil, fmt.Errorf("field \"absolute\" is required")
		}
		return struct {
			Type     string            `json:"type"`
			Absolute AbsoluteTimestamp `json:"absolute"`
		}{Type: "absolute", Absolute: *u.absolute}, nil
	}
}

func (u TimestampType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimestampType) UnmarshalJSON(data []byte) error {
	var deser timestampTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
	}
	return nil
}

func (u TimestampType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimestampType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimestampType) AcceptFuncs(relativeFunc func(RelativeTimestamp) error, absoluteFunc func(AbsoluteTimestamp) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return relativeFunc(*u.relative)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return absoluteFunc(*u.absolute)
	}
}

func (u *TimestampType) RelativeNoopSuccess(RelativeTimestamp) error {
	return nil
}

func (u *TimestampType) AbsoluteNoopSuccess(AbsoluteTimestamp) error {
	return nil
}

func (u *TimestampType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimestampType) Accept(v TimestampTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelative(*u.relative)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsolute(*u.absolute)
	}
}

type TimestampTypeVisitor interface {
	VisitRelative(v RelativeTimestamp) error
	VisitAbsolute(v AbsoluteTimestamp) error
	VisitUnknown(typeName string) error
}

func (u *TimestampType) AcceptWithContext(ctx context.Context, v TimestampTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelativeWithContext(ctx, *u.relative)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsoluteWithContext(ctx, *u.absolute)
	}
}

type TimestampTypeVisitorWithContext interface {
	VisitRelativeWithContext(ctx context.Context, v RelativeTimestamp) error
	VisitAbsoluteWithContext(ctx context.Context, v AbsoluteTimestamp) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimestampTypeFromRelative(v RelativeTimestamp) TimestampType {
	return TimestampType{typ: "relative", relative: &v}
}

func NewTimestampTypeFromAbsolute(v AbsoluteTimestamp) TimestampType {
	return TimestampType{typ: "absolute", absolute: &v}
}
