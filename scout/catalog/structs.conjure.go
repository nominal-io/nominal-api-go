// Code generated by conjure-go. DO NOT EDIT.

package catalog

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/ingest/api"
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/io/nominal/datasource"
	api2 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
)

type AddFileToDataset struct {
	Handle            Handle             `json:"handle"`
	TimestampMetadata *TimestampMetadata `json:"timestampMetadata,omitempty"`
	IngestTagMetadata *IngestTagMetadata `json:"ingestTagMetadata,omitempty"`
	OriginFileHandles *[]S3Handle        `json:"originFileHandles,omitempty"`
	IngestJobRid      *api.IngestJobRid  `json:"ingestJobRid,omitempty"`
}

func (o AddFileToDataset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AddFileToDataset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AllPropertiesAndLabelsResponse struct {
	Properties map[api1.PropertyName][]api1.PropertyValue `json:"properties"`
	Labels     []api1.Label                               `json:"labels"`
}

func (o AllPropertiesAndLabelsResponse) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[api1.PropertyName][]api1.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api1.Label, 0)
	}
	type _tmpAllPropertiesAndLabelsResponse AllPropertiesAndLabelsResponse
	return safejson.Marshal(_tmpAllPropertiesAndLabelsResponse(o))
}

func (o *AllPropertiesAndLabelsResponse) UnmarshalJSON(data []byte) error {
	type _tmpAllPropertiesAndLabelsResponse AllPropertiesAndLabelsResponse
	var rawAllPropertiesAndLabelsResponse _tmpAllPropertiesAndLabelsResponse
	if err := safejson.Unmarshal(data, &rawAllPropertiesAndLabelsResponse); err != nil {
		return err
	}
	if rawAllPropertiesAndLabelsResponse.Properties == nil {
		rawAllPropertiesAndLabelsResponse.Properties = make(map[api1.PropertyName][]api1.PropertyValue, 0)
	}
	if rawAllPropertiesAndLabelsResponse.Labels == nil {
		rawAllPropertiesAndLabelsResponse.Labels = make([]api1.Label, 0)
	}
	*o = AllPropertiesAndLabelsResponse(rawAllPropertiesAndLabelsResponse)
	return nil
}

func (o AllPropertiesAndLabelsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AllPropertiesAndLabelsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Bounds struct {
	Start api1.Timestamp           `json:"start"`
	End   api1.Timestamp           `json:"end"`
	Type  datasource.TimestampType `json:"type"`
}

func (o Bounds) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Bounds) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Channel struct {
	Uuid        uuid.UUID `json:"uuid"`
	Name        string    `json:"name"`
	DatasetUuid uuid.UUID `json:"datasetUuid"`
}

func (o Channel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Channel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelConfig struct {
	// If set, will construct a prefix tree for channels of the dataset using the given delimiter.
	PrefixTreeDelimiter *string `conjure-docs:"If set, will construct a prefix tree for channels of the dataset using the given delimiter." json:"prefixTreeDelimiter,omitempty"`
}

func (o ChannelConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelDetails struct {
	Uuid           uuid.UUID         `json:"uuid"`
	Name           string            `json:"name"`
	OriginMetadata map[string]string `json:"originMetadata"`
	CsvIndex       int               `json:"csvIndex"`
	DatasetUuid    uuid.UUID         `json:"datasetUuid"`
	Handle         Handle            `json:"handle"`
}

func (o ChannelDetails) MarshalJSON() ([]byte, error) {
	if o.OriginMetadata == nil {
		o.OriginMetadata = make(map[string]string, 0)
	}
	type _tmpChannelDetails ChannelDetails
	return safejson.Marshal(_tmpChannelDetails(o))
}

func (o *ChannelDetails) UnmarshalJSON(data []byte) error {
	type _tmpChannelDetails ChannelDetails
	var rawChannelDetails _tmpChannelDetails
	if err := safejson.Unmarshal(data, &rawChannelDetails); err != nil {
		return err
	}
	if rawChannelDetails.OriginMetadata == nil {
		rawChannelDetails.OriginMetadata = make(map[string]string, 0)
	}
	*o = ChannelDetails(rawChannelDetails)
	return nil
}

func (o ChannelDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateDataset struct {
	Name string `json:"name"`
	// Deprecated: Handles should only be specified when adding files to datasets
	Handle *Handle `json:"handle,omitempty"`
	// Deprecated: Deprecated in favor of properties
	Metadata       map[string]string                        `json:"metadata"`
	OriginMetadata DatasetOriginMetadata                    `json:"originMetadata"`
	Labels         []api1.Label                             `json:"labels"`
	Properties     map[api1.PropertyName]api1.PropertyValue `json:"properties"`
	Description    *string                                  `json:"description,omitempty"`
	// Granularity of dataset timestamps. Defaults to nanoseconds.
	Granularity *api1.Granularity `conjure-docs:"Granularity of dataset timestamps. Defaults to nanoseconds." json:"granularity,omitempty"`
	/*
	   If true, the dataset should be ingested to the v2 tables and is compatible with streaming.

	   Deprecated: Regardless of what value is specified, this flag is treated as true by the service.
	*/
	IsV2Dataset *bool `conjure-docs:"If true, the dataset should be ingested to the v2 tables and is compatible with streaming." json:"isV2Dataset,omitempty"`
	/*
	   The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for
	   the user's organization, if the default workspace for the organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for\nthe user's organization, if the default workspace for the organization is configured." json:"workspace,omitempty"`
	/*
	   The markings to apply to the created dataset.
	   If not provided, the dataset will be visible to all users in the same workspace.
	*/
	MarkingRids []api2.MarkingRid `conjure-docs:"The markings to apply to the created dataset.\nIf not provided, the dataset will be visible to all users in the same workspace." json:"markingRids"`
}

func (o CreateDataset) MarshalJSON() ([]byte, error) {
	if o.Metadata == nil {
		o.Metadata = make(map[string]string, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api1.Label, 0)
	}
	if o.Properties == nil {
		o.Properties = make(map[api1.PropertyName]api1.PropertyValue, 0)
	}
	if o.MarkingRids == nil {
		o.MarkingRids = make([]api2.MarkingRid, 0)
	}
	type _tmpCreateDataset CreateDataset
	return safejson.Marshal(_tmpCreateDataset(o))
}

func (o *CreateDataset) UnmarshalJSON(data []byte) error {
	type _tmpCreateDataset CreateDataset
	var rawCreateDataset _tmpCreateDataset
	if err := safejson.Unmarshal(data, &rawCreateDataset); err != nil {
		return err
	}
	if rawCreateDataset.Metadata == nil {
		rawCreateDataset.Metadata = make(map[string]string, 0)
	}
	if rawCreateDataset.Labels == nil {
		rawCreateDataset.Labels = make([]api1.Label, 0)
	}
	if rawCreateDataset.Properties == nil {
		rawCreateDataset.Properties = make(map[api1.PropertyName]api1.PropertyValue, 0)
	}
	if rawCreateDataset.MarkingRids == nil {
		rawCreateDataset.MarkingRids = make([]api2.MarkingRid, 0)
	}
	*o = CreateDataset(rawCreateDataset)
	return nil
}

func (o CreateDataset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateDataset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CustomTimestamp struct {
	// The format string should be in the format of the `DateTimeFormatter` class in Java.
	Format string `conjure-docs:"The format string should be in the format of the \"DateTimeFormatter\" class in Java." json:"format"`
	// Year is accepted as an optional field for cases like IRIG time format, and will be assumed as current year if not provided.
	DefaultYear *int `conjure-docs:"Year is accepted as an optional field for cases like IRIG time format, and will be assumed as current year if not provided." json:"defaultYear,omitempty"`
	// Default day of year is accepted as an optional field for cases like IRIG time format and will be overridden by day of year in time format.
	DefaultDayOfYear *int `conjure-docs:"Default day of year is accepted as an optional field for cases like IRIG time format and will be overridden by day of year in time format." json:"defaultDayOfYear,omitempty"`
}

func (o CustomTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CustomTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Dataset struct {
	Rid  rid.ResourceIdentifier `json:"rid"`
	Name string                 `json:"name"`
	// Deprecated: Deprecated. Use DatasetFile#handle
	Handle         *Handle                                  `json:"handle,omitempty"`
	Description    *string                                  `json:"description,omitempty"`
	OriginMetadata DatasetOriginMetadata                    `json:"originMetadata"`
	Bounds         *Bounds                                  `json:"bounds,omitempty"`
	Properties     map[api1.PropertyName]api1.PropertyValue `json:"properties"`
	Labels         []api1.Label                             `json:"labels"`
	TimestampType  WeakTimestampType                        `json:"timestampType"`
	AllowStreaming bool                                     `json:"allowStreaming"`
	Granularity    api1.Granularity                         `json:"granularity"`
}

func (o Dataset) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[api1.PropertyName]api1.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api1.Label, 0)
	}
	type _tmpDataset Dataset
	return safejson.Marshal(_tmpDataset(o))
}

func (o *Dataset) UnmarshalJSON(data []byte) error {
	type _tmpDataset Dataset
	var rawDataset _tmpDataset
	if err := safejson.Unmarshal(data, &rawDataset); err != nil {
		return err
	}
	if rawDataset.Properties == nil {
		rawDataset.Properties = make(map[api1.PropertyName]api1.PropertyValue, 0)
	}
	if rawDataset.Labels == nil {
		rawDataset.Labels = make([]api1.Label, 0)
	}
	*o = Dataset(rawDataset)
	return nil
}

func (o Dataset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Dataset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DatasetFile struct {
	Id         datasource.DatasetFileId `json:"id"`
	DatasetRid rids.DatasetRid          `json:"datasetRid"`
	Name       string                   `json:"name"`
	Handle     Handle                   `json:"handle"`
	Bounds     *Bounds                  `json:"bounds,omitempty"`
	// Timestamp that the file was received and stored, but not processed or made available to consumers.
	UploadedAt datetime.DateTime `conjure-docs:"Timestamp that the file was received and stored, but not processed or made available to consumers." json:"uploadedAt"`
	/*
	   Timestamp that the file is ingested at and made available for processing. If the file has failed to be
	   ingested for any reason or is still being processed, then this value will be empty.
	*/
	IngestedAt        *datetime.DateTime  `conjure-docs:"Timestamp that the file is ingested at and made available for processing. If the file has failed to be\ningested for any reason or is still being processed, then this value will be empty." json:"ingestedAt,omitempty"`
	IngestStatus      api1.IngestStatusV2 `json:"ingestStatus"`
	TimestampMetadata *TimestampMetadata  `json:"timestampMetadata,omitempty"`
	IngestTagMetadata *IngestTagMetadata  `json:"ingestTagMetadata,omitempty"`
	OriginFilePaths   *[]string           `json:"originFilePaths,omitempty"`
	IngestJobRid      *api.IngestJobRid   `json:"ingestJobRid,omitempty"`
	// Timestamp that the file is deleted at, only present if the file has been deleted.
	DeletedAt *datetime.DateTime `conjure-docs:"Timestamp that the file is deleted at, only present if the file has been deleted." json:"deletedAt,omitempty"`
}

func (o DatasetFile) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DatasetFile) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DatasetFileSortOptions struct {
	IsDescending bool                 `json:"isDescending"`
	Field        DatasetFileSortField `json:"field"`
}

func (o DatasetFileSortOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DatasetFileSortOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Pre-signed URI that can be used to download the original file directly. Expires if the download has
not been initiated within 1 minute.
*/
type DatasetFileUri struct {
	Uri string `json:"uri"`
}

func (o DatasetFileUri) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DatasetFileUri) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DatasetFilesPage struct {
	Files    []DatasetFile `json:"files"`
	NextPage *api1.Token   `json:"nextPage,omitempty"`
}

func (o DatasetFilesPage) MarshalJSON() ([]byte, error) {
	if o.Files == nil {
		o.Files = make([]DatasetFile, 0)
	}
	type _tmpDatasetFilesPage DatasetFilesPage
	return safejson.Marshal(_tmpDatasetFilesPage(o))
}

func (o *DatasetFilesPage) UnmarshalJSON(data []byte) error {
	type _tmpDatasetFilesPage DatasetFilesPage
	var rawDatasetFilesPage _tmpDatasetFilesPage
	if err := safejson.Unmarshal(data, &rawDatasetFilesPage); err != nil {
		return err
	}
	if rawDatasetFilesPage.Files == nil {
		rawDatasetFilesPage.Files = make([]DatasetFile, 0)
	}
	*o = DatasetFilesPage(rawDatasetFilesPage)
	return nil
}

func (o DatasetFilesPage) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DatasetFilesPage) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DatasetOriginMetadata struct {
	// Deprecated in favor of FileOriginMetadata
	Path *string `conjure-docs:"Deprecated in favor of FileOriginMetadata" json:"path,omitempty"`
	// Deprecated in favor of FileOriginMetadata
	XSeriesIsAbsolute *bool `conjure-docs:"Deprecated in favor of FileOriginMetadata" json:"xSeriesIsAbsolute,omitempty"`
	// Deprecated in favor of FileOriginMetadata
	SchemaDirectivePath *string `conjure-docs:"Deprecated in favor of FileOriginMetadata" json:"schemaDirectivePath,omitempty"`
	// Deprecated in favor of FileOriginMetadata
	XSeriesColumnName *string `conjure-docs:"Deprecated in favor of FileOriginMetadata" json:"xSeriesColumnName,omitempty"`
	// Deprecated in favor of FileOriginMetadata
	XSeriesTimeUnit *api1.TimeUnit `conjure-docs:"Deprecated in favor of FileOriginMetadata" json:"xSeriesTimeUnit,omitempty"`
	// Deprecated in favor of FileOriginMetadata
	TimestampMetadata *TimestampMetadata `conjure-docs:"Deprecated in favor of FileOriginMetadata" json:"timestampMetadata,omitempty"`
	ChannelConfig     *ChannelConfig     `json:"channelConfig,omitempty"`
}

func (o DatasetOriginMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DatasetOriginMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnrichedDataset struct {
	Rid         rid.ResourceIdentifier `json:"rid"`
	Uuid        uuid.UUID              `json:"uuid"`
	Name        string                 `json:"name"`
	Description *string                `json:"description,omitempty"`
	DisplayName string                 `json:"displayName"`
	// Deprecated: Deprecated in favor of properties.
	Metadata *map[string]string `json:"metadata,omitempty"`
	// Deprecated: Deprecated. Use DatasetFile#handle
	Handle     *Handle           `json:"handle,omitempty"`
	IngestDate datetime.DateTime `json:"ingestDate"`
	// Deprecated: Deprecated. Use lastIngestStatus.
	IngestStatus     *IngestStatus                            `json:"ingestStatus,omitempty"`
	OriginMetadata   DatasetOriginMetadata                    `json:"originMetadata"`
	LastIngestStatus api1.IngestStatusV2                      `json:"lastIngestStatus"`
	RetentionPolicy  RetentionPolicy                          `json:"retentionPolicy"`
	Source           *string                                  `json:"source,omitempty"`
	Bounds           *Bounds                                  `json:"bounds,omitempty"`
	TimestampType    WeakTimestampType                        `json:"timestampType"`
	Labels           []api1.Label                             `json:"labels"`
	Properties       map[api1.PropertyName]api1.PropertyValue `json:"properties"`
	Granularity      api1.Granularity                         `json:"granularity"`
	AllowStreaming   bool                                     `json:"allowStreaming"`
}

func (o EnrichedDataset) MarshalJSON() ([]byte, error) {
	if o.Labels == nil {
		o.Labels = make([]api1.Label, 0)
	}
	if o.Properties == nil {
		o.Properties = make(map[api1.PropertyName]api1.PropertyValue, 0)
	}
	type _tmpEnrichedDataset EnrichedDataset
	return safejson.Marshal(_tmpEnrichedDataset(o))
}

func (o *EnrichedDataset) UnmarshalJSON(data []byte) error {
	type _tmpEnrichedDataset EnrichedDataset
	var rawEnrichedDataset _tmpEnrichedDataset
	if err := safejson.Unmarshal(data, &rawEnrichedDataset); err != nil {
		return err
	}
	if rawEnrichedDataset.Labels == nil {
		rawEnrichedDataset.Labels = make([]api1.Label, 0)
	}
	if rawEnrichedDataset.Properties == nil {
		rawEnrichedDataset.Properties = make(map[api1.PropertyName]api1.PropertyValue, 0)
	}
	*o = EnrichedDataset(rawEnrichedDataset)
	return nil
}

func (o EnrichedDataset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnrichedDataset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EpochTimestamp struct {
	TimeUnit api1.TimeUnit `json:"timeUnit"`
}

func (o EpochTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EpochTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetChannelsForDatasetsRequest struct {
	DatasetUuids []uuid.UUID `json:"datasetUuids"`
}

func (o GetChannelsForDatasetsRequest) MarshalJSON() ([]byte, error) {
	if o.DatasetUuids == nil {
		o.DatasetUuids = make([]uuid.UUID, 0)
	}
	type _tmpGetChannelsForDatasetsRequest GetChannelsForDatasetsRequest
	return safejson.Marshal(_tmpGetChannelsForDatasetsRequest(o))
}

func (o *GetChannelsForDatasetsRequest) UnmarshalJSON(data []byte) error {
	type _tmpGetChannelsForDatasetsRequest GetChannelsForDatasetsRequest
	var rawGetChannelsForDatasetsRequest _tmpGetChannelsForDatasetsRequest
	if err := safejson.Unmarshal(data, &rawGetChannelsForDatasetsRequest); err != nil {
		return err
	}
	if rawGetChannelsForDatasetsRequest.DatasetUuids == nil {
		rawGetChannelsForDatasetsRequest.DatasetUuids = make([]uuid.UUID, 0)
	}
	*o = GetChannelsForDatasetsRequest(rawGetChannelsForDatasetsRequest)
	return nil
}

func (o GetChannelsForDatasetsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetChannelsForDatasetsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetDatasetsRequest struct {
	DatasetRids []rid.ResourceIdentifier `json:"datasetRids"`
}

func (o GetDatasetsRequest) MarshalJSON() ([]byte, error) {
	if o.DatasetRids == nil {
		o.DatasetRids = make([]rid.ResourceIdentifier, 0)
	}
	type _tmpGetDatasetsRequest GetDatasetsRequest
	return safejson.Marshal(_tmpGetDatasetsRequest(o))
}

func (o *GetDatasetsRequest) UnmarshalJSON(data []byte) error {
	type _tmpGetDatasetsRequest GetDatasetsRequest
	var rawGetDatasetsRequest _tmpGetDatasetsRequest
	if err := safejson.Unmarshal(data, &rawGetDatasetsRequest); err != nil {
		return err
	}
	if rawGetDatasetsRequest.DatasetRids == nil {
		rawGetDatasetsRequest.DatasetRids = make([]rid.ResourceIdentifier, 0)
	}
	*o = GetDatasetsRequest(rawGetDatasetsRequest)
	return nil
}

func (o GetDatasetsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetDatasetsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetDetailsForChannelsRequest struct {
	ChannelUuids []uuid.UUID `json:"channelUuids"`
}

func (o GetDetailsForChannelsRequest) MarshalJSON() ([]byte, error) {
	if o.ChannelUuids == nil {
		o.ChannelUuids = make([]uuid.UUID, 0)
	}
	type _tmpGetDetailsForChannelsRequest GetDetailsForChannelsRequest
	return safejson.Marshal(_tmpGetDetailsForChannelsRequest(o))
}

func (o *GetDetailsForChannelsRequest) UnmarshalJSON(data []byte) error {
	type _tmpGetDetailsForChannelsRequest GetDetailsForChannelsRequest
	var rawGetDetailsForChannelsRequest _tmpGetDetailsForChannelsRequest
	if err := safejson.Unmarshal(data, &rawGetDetailsForChannelsRequest); err != nil {
		return err
	}
	if rawGetDetailsForChannelsRequest.ChannelUuids == nil {
		rawGetDetailsForChannelsRequest.ChannelUuids = make([]uuid.UUID, 0)
	}
	*o = GetDetailsForChannelsRequest(rawGetDetailsForChannelsRequest)
	return nil
}

func (o GetDetailsForChannelsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetDetailsForChannelsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetHandlesForDatasetsRequest struct {
	DatasetUuids []uuid.UUID `json:"datasetUuids"`
}

func (o GetHandlesForDatasetsRequest) MarshalJSON() ([]byte, error) {
	if o.DatasetUuids == nil {
		o.DatasetUuids = make([]uuid.UUID, 0)
	}
	type _tmpGetHandlesForDatasetsRequest GetHandlesForDatasetsRequest
	return safejson.Marshal(_tmpGetHandlesForDatasetsRequest(o))
}

func (o *GetHandlesForDatasetsRequest) UnmarshalJSON(data []byte) error {
	type _tmpGetHandlesForDatasetsRequest GetHandlesForDatasetsRequest
	var rawGetHandlesForDatasetsRequest _tmpGetHandlesForDatasetsRequest
	if err := safejson.Unmarshal(data, &rawGetHandlesForDatasetsRequest); err != nil {
		return err
	}
	if rawGetHandlesForDatasetsRequest.DatasetUuids == nil {
		rawGetHandlesForDatasetsRequest.DatasetUuids = make([]uuid.UUID, 0)
	}
	*o = GetHandlesForDatasetsRequest(rawGetHandlesForDatasetsRequest)
	return nil
}

func (o GetHandlesForDatasetsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetHandlesForDatasetsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestProgressV2 struct {
	// Timestamp at start of ingest
	StartTime datetime.DateTime `conjure-docs:"Timestamp at start of ingest" json:"startTime"`
	// Timestamp at end of ingest, empty if still in progress
	EndTime *datetime.DateTime `conjure-docs:"Timestamp at end of ingest, empty if still in progress" json:"endTime,omitempty"`
	// Status of ingest, contains error if failed
	IngestStatus api1.IngestStatusV2 `conjure-docs:"Status of ingest, contains error if failed" json:"ingestStatus"`
	// Whether ingest duration can be reliably calculated
	Incalculable *bool `conjure-docs:"Whether ingest duration can be reliably calculated" json:"incalculable,omitempty"`
}

func (o IngestProgressV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestProgressV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The tags used when ingesting the dataset file.
type IngestTagMetadata struct {
	// A map of tag names to column names to derive the tag values from.
	TagColumns         map[api1.TagName]api1.ColumnName `conjure-docs:"A map of tag names to column names to derive the tag values from." json:"tagColumns"`
	AdditionalFileTags map[api1.TagName]api1.TagValue   `json:"additionalFileTags"`
}

func (o IngestTagMetadata) MarshalJSON() ([]byte, error) {
	if o.TagColumns == nil {
		o.TagColumns = make(map[api1.TagName]api1.ColumnName, 0)
	}
	if o.AdditionalFileTags == nil {
		o.AdditionalFileTags = make(map[api1.TagName]api1.TagValue, 0)
	}
	type _tmpIngestTagMetadata IngestTagMetadata
	return safejson.Marshal(_tmpIngestTagMetadata(o))
}

func (o *IngestTagMetadata) UnmarshalJSON(data []byte) error {
	type _tmpIngestTagMetadata IngestTagMetadata
	var rawIngestTagMetadata _tmpIngestTagMetadata
	if err := safejson.Unmarshal(data, &rawIngestTagMetadata); err != nil {
		return err
	}
	if rawIngestTagMetadata.TagColumns == nil {
		rawIngestTagMetadata.TagColumns = make(map[api1.TagName]api1.ColumnName, 0)
	}
	if rawIngestTagMetadata.AdditionalFileTags == nil {
		rawIngestTagMetadata.AdditionalFileTags = make(map[api1.TagName]api1.TagValue, 0)
	}
	*o = IngestTagMetadata(rawIngestTagMetadata)
	return nil
}

func (o IngestTagMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestTagMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Iso8601Timestamp struct{}

func (o Iso8601Timestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Iso8601Timestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type MarkFileIngestError struct {
	ErrorResult api1.ErrorResult `json:"errorResult"`
}

func (o MarkFileIngestError) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MarkFileIngestError) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type MarkFileIngestSuccessful struct {
	Bounds Bounds `json:"bounds"`
	/*
	   The ingestion timestamp is produced by CSV splitter and stored directly in the clickhouse table.
	   It's produced externally and passed here to handle retries and failures, and must be nanosecond precision.
	   Two files cannot have the same ingested at timestamp.
	*/
	IngestedAt api1.Timestamp `conjure-docs:"The ingestion timestamp is produced by CSV splitter and stored directly in the clickhouse table.\nIt's produced externally and passed here to handle retries and failures, and must be nanosecond precision.\nTwo files cannot have the same ingested at timestamp." json:"ingestedAt"`
}

func (o MarkFileIngestSuccessful) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MarkFileIngestSuccessful) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Pre-signed URI that can be used to download an origin file directly. Expires if the download has
not been initiated within 1 minute.
*/
type OriginFileUri struct {
	Uri  string `json:"uri"`
	Path string `json:"path"`
}

func (o OriginFileUri) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *OriginFileUri) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RelativeTimestamp struct {
	TimeUnit api1.TimeUnit      `json:"timeUnit"`
	Offset   *datetime.DateTime `json:"offset,omitempty"`
}

func (o RelativeTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RelativeTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RetentionPolicy struct {
	Type       RetentionPolicyType `json:"type"`
	ExpiryDays *int                `json:"expiryDays,omitempty"`
}

func (o RetentionPolicy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RetentionPolicy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type S3Handle struct {
	Bucket string `json:"bucket"`
	Key    string `json:"key"`
}

func (o S3Handle) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *S3Handle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchDatasetFilesRequest struct {
	DatasetRid rids.DatasetRid         `json:"datasetRid"`
	Query      SearchDatasetFilesQuery `json:"query"`
	// Defaults to 100. Will throw if larger than 1000.
	PageSize    *int                   `conjure-docs:"Defaults to 100. Will throw if larger than 1000." json:"pageSize,omitempty"`
	Token       *api1.Token            `json:"token,omitempty"`
	SortOptions DatasetFileSortOptions `json:"sortOptions"`
}

func (o SearchDatasetFilesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchDatasetFilesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchDatasetFilesResponse struct {
	Results       []DatasetFile `json:"results"`
	NextPageToken *api1.Token   `json:"nextPageToken,omitempty"`
}

func (o SearchDatasetFilesResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]DatasetFile, 0)
	}
	type _tmpSearchDatasetFilesResponse SearchDatasetFilesResponse
	return safejson.Marshal(_tmpSearchDatasetFilesResponse(o))
}

func (o *SearchDatasetFilesResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchDatasetFilesResponse SearchDatasetFilesResponse
	var rawSearchDatasetFilesResponse _tmpSearchDatasetFilesResponse
	if err := safejson.Unmarshal(data, &rawSearchDatasetFilesResponse); err != nil {
		return err
	}
	if rawSearchDatasetFilesResponse.Results == nil {
		rawSearchDatasetFilesResponse.Results = make([]DatasetFile, 0)
	}
	*o = SearchDatasetFilesResponse(rawSearchDatasetFilesResponse)
	return nil
}

func (o SearchDatasetFilesResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchDatasetFilesResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchDatasetsRequest struct {
	Query SearchDatasetsQuery `json:"query"`
	// Defaults to 100. Will throw if larger than 1000.
	PageSize    *int        `conjure-docs:"Defaults to 100. Will throw if larger than 1000." json:"pageSize,omitempty"`
	Token       *api1.Token `json:"token,omitempty"`
	SortOptions SortOptions `json:"sortOptions"`
}

func (o SearchDatasetsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchDatasetsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchDatasetsResponse struct {
	Results       []EnrichedDataset `json:"results"`
	NextPageToken *api1.Token       `json:"nextPageToken,omitempty"`
}

func (o SearchDatasetsResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]EnrichedDataset, 0)
	}
	type _tmpSearchDatasetsResponse SearchDatasetsResponse
	return safejson.Marshal(_tmpSearchDatasetsResponse(o))
}

func (o *SearchDatasetsResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchDatasetsResponse SearchDatasetsResponse
	var rawSearchDatasetsResponse _tmpSearchDatasetsResponse
	if err := safejson.Unmarshal(data, &rawSearchDatasetsResponse); err != nil {
		return err
	}
	if rawSearchDatasetsResponse.Results == nil {
		rawSearchDatasetsResponse.Results = make([]EnrichedDataset, 0)
	}
	*o = SearchDatasetsResponse(rawSearchDatasetsResponse)
	return nil
}

func (o SearchDatasetsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchDatasetsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SkipRowsConfig struct {
	HeaderRowIndex    int `json:"headerRowIndex"`
	DataStartRowIndex int `json:"dataStartRowIndex"`
}

func (o SkipRowsConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SkipRowsConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SortOptions struct {
	IsDescending bool      `json:"isDescending"`
	Field        SortField `json:"field"`
}

func (o SortOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SortOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// searches for files that intersect with the specified range.
type TimeRangeFilter struct {
	Start *UtcTimestamp `json:"start,omitempty"`
	End   *UtcTimestamp `json:"end,omitempty"`
}

func (o TimeRangeFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeRangeFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimestampMetadata struct {
	SeriesName    string        `json:"seriesName"`
	TimestampType TimestampType `json:"timestampType"`
}

func (o TimestampMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimestampMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UnitConfig struct {
	// If set, will extract the series unit from the column metadata of the ingested file.
	UnitMetadataKey string `conjure-docs:"If set, will extract the series unit from the column metadata of the ingested file." json:"unitMetadataKey"`
}

func (o UnitConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnitConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateBoundsRequest struct {
	Bounds Bounds `json:"bounds"`
}

func (o UpdateBoundsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateBoundsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateDatasetMetadata struct {
	Name        *string                                   `json:"name,omitempty"`
	Description *string                                   `json:"description,omitempty"`
	Labels      *[]api1.Label                             `json:"labels,omitempty"`
	Properties  *map[api1.PropertyName]api1.PropertyValue `json:"properties,omitempty"`
}

func (o UpdateDatasetMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateDatasetMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateIngestStatus struct {
	Status      IngestStatus `json:"status"`
	DatasetUuid uuid.UUID    `json:"datasetUuid"`
}

func (o UpdateIngestStatus) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateIngestStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateIngestStatusV2 struct {
	Status      api1.IngestStatusV2 `json:"status"`
	DatasetUuid uuid.UUID           `json:"datasetUuid"`
}

func (o UpdateIngestStatusV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateIngestStatusV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UtcTimestamp struct {
	SecondsSinceEpoch safelong.SafeLong `json:"secondsSinceEpoch"`
}

func (o UtcTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UtcTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
