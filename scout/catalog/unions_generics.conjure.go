// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package catalog

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/io/nominal/api"
	"github.com/palantir/pkg/datetime"
)

type AbsoluteTimestampWithT[T any] AbsoluteTimestamp

func (u *AbsoluteTimestampWithT[T]) Accept(ctx context.Context, v AbsoluteTimestampVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return result, fmt.Errorf("field \"iso8601\" is required")
		}
		return v.VisitIso8601(ctx, *u.iso8601)
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return result, fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return v.VisitEpochOfTimeUnit(ctx, *u.epochOfTimeUnit)
	case "customFormat":
		if u.customFormat == nil {
			return result, fmt.Errorf("field \"customFormat\" is required")
		}
		return v.VisitCustomFormat(ctx, *u.customFormat)
	}
}

func (u *AbsoluteTimestampWithT[T]) AcceptFuncs(iso8601Func func(Iso8601Timestamp) (T, error), epochOfTimeUnitFunc func(EpochTimestamp) (T, error), customFormatFunc func(CustomTimestamp) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return result, fmt.Errorf("field \"iso8601\" is required")
		}
		return iso8601Func(*u.iso8601)
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return result, fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return epochOfTimeUnitFunc(*u.epochOfTimeUnit)
	case "customFormat":
		if u.customFormat == nil {
			return result, fmt.Errorf("field \"customFormat\" is required")
		}
		return customFormatFunc(*u.customFormat)
	}
}

func (u *AbsoluteTimestampWithT[T]) Iso8601NoopSuccess(Iso8601Timestamp) (T, error) {
	var result T
	return result, nil
}

func (u *AbsoluteTimestampWithT[T]) EpochOfTimeUnitNoopSuccess(EpochTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *AbsoluteTimestampWithT[T]) CustomFormatNoopSuccess(CustomTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *AbsoluteTimestampWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type AbsoluteTimestampVisitorWithT[T any] interface {
	VisitIso8601(ctx context.Context, v Iso8601Timestamp) (T, error)
	VisitEpochOfTimeUnit(ctx context.Context, v EpochTimestamp) (T, error)
	VisitCustomFormat(ctx context.Context, v CustomTimestamp) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type HandleWithT[T any] Handle

func (u *HandleWithT[T]) Accept(ctx context.Context, v HandleVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "s3":
		if u.s3 == nil {
			return result, fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3(ctx, *u.s3)
	}
}

func (u *HandleWithT[T]) AcceptFuncs(s3Func func(S3Handle) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "s3":
		if u.s3 == nil {
			return result, fmt.Errorf("field \"s3\" is required")
		}
		return s3Func(*u.s3)
	}
}

func (u *HandleWithT[T]) S3NoopSuccess(S3Handle) (T, error) {
	var result T
	return result, nil
}

func (u *HandleWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type HandleVisitorWithT[T any] interface {
	VisitS3(ctx context.Context, v S3Handle) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SearchDatasetFilesQueryWithT[T any] SearchDatasetFilesQuery

func (u *SearchDatasetFilesQueryWithT[T]) Accept(ctx context.Context, v SearchDatasetFilesQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "timeRange":
		if u.timeRange == nil {
			return result, fmt.Errorf("field \"timeRange\" is required")
		}
		return v.VisitTimeRange(ctx, *u.timeRange)
	case "fileTags":
		if u.fileTags == nil {
			return result, fmt.Errorf("field \"fileTags\" is required")
		}
		return v.VisitFileTags(ctx, *u.fileTags)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	}
}

func (u *SearchDatasetFilesQueryWithT[T]) AcceptFuncs(timeRangeFunc func(TimeRangeFilter) (T, error), fileTagsFunc func(map[api.TagName]api.TagValue) (T, error), andFunc func([]SearchDatasetFilesQuery) (T, error), orFunc func([]SearchDatasetFilesQuery) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timeRange":
		if u.timeRange == nil {
			return result, fmt.Errorf("field \"timeRange\" is required")
		}
		return timeRangeFunc(*u.timeRange)
	case "fileTags":
		if u.fileTags == nil {
			return result, fmt.Errorf("field \"fileTags\" is required")
		}
		return fileTagsFunc(*u.fileTags)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	}
}

func (u *SearchDatasetFilesQueryWithT[T]) TimeRangeNoopSuccess(TimeRangeFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetFilesQueryWithT[T]) FileTagsNoopSuccess(map[api.TagName]api.TagValue) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetFilesQueryWithT[T]) AndNoopSuccess([]SearchDatasetFilesQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetFilesQueryWithT[T]) OrNoopSuccess([]SearchDatasetFilesQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetFilesQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchDatasetFilesQueryVisitorWithT[T any] interface {
	VisitTimeRange(ctx context.Context, v TimeRangeFilter) (T, error)
	VisitFileTags(ctx context.Context, v map[api.TagName]api.TagValue) (T, error)
	VisitAnd(ctx context.Context, v []SearchDatasetFilesQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchDatasetFilesQuery) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SearchDatasetsQueryWithT[T any] SearchDatasetsQuery

func (u *SearchDatasetsQueryWithT[T]) Accept(ctx context.Context, v SearchDatasetsQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(ctx, *u.searchText)
	case "exactMatch":
		if u.exactMatch == nil {
			return result, fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatch(ctx, *u.exactMatch)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(ctx, *u.label)
	case "properties":
		if u.properties == nil {
			return result, fmt.Errorf("field \"properties\" is required")
		}
		return v.VisitProperties(ctx, *u.properties)
	case "ingestStatus":
		if u.ingestStatus == nil {
			return result, fmt.Errorf("field \"ingestStatus\" is required")
		}
		return v.VisitIngestStatus(ctx, *u.ingestStatus)
	case "ingestedBeforeInclusive":
		if u.ingestedBeforeInclusive == nil {
			return result, fmt.Errorf("field \"ingestedBeforeInclusive\" is required")
		}
		return v.VisitIngestedBeforeInclusive(ctx, *u.ingestedBeforeInclusive)
	case "ingestedAfterInclusive":
		if u.ingestedAfterInclusive == nil {
			return result, fmt.Errorf("field \"ingestedAfterInclusive\" is required")
		}
		return v.VisitIngestedAfterInclusive(ctx, *u.ingestedAfterInclusive)
	case "archiveStatus":
		if u.archiveStatus == nil {
			return result, fmt.Errorf("field \"archiveStatus\" is required")
		}
		return v.VisitArchiveStatus(ctx, *u.archiveStatus)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	}
}

func (u *SearchDatasetsQueryWithT[T]) AcceptFuncs(searchTextFunc func(string) (T, error), exactMatchFunc func(string) (T, error), labelFunc func(api.Label) (T, error), propertiesFunc func(api.Property) (T, error), ingestStatusFunc func(IngestStatus) (T, error), ingestedBeforeInclusiveFunc func(datetime.DateTime) (T, error), ingestedAfterInclusiveFunc func(datetime.DateTime) (T, error), archiveStatusFunc func(bool) (T, error), andFunc func([]SearchDatasetsQuery) (T, error), orFunc func([]SearchDatasetsQuery) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "exactMatch":
		if u.exactMatch == nil {
			return result, fmt.Errorf("field \"exactMatch\" is required")
		}
		return exactMatchFunc(*u.exactMatch)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "properties":
		if u.properties == nil {
			return result, fmt.Errorf("field \"properties\" is required")
		}
		return propertiesFunc(*u.properties)
	case "ingestStatus":
		if u.ingestStatus == nil {
			return result, fmt.Errorf("field \"ingestStatus\" is required")
		}
		return ingestStatusFunc(*u.ingestStatus)
	case "ingestedBeforeInclusive":
		if u.ingestedBeforeInclusive == nil {
			return result, fmt.Errorf("field \"ingestedBeforeInclusive\" is required")
		}
		return ingestedBeforeInclusiveFunc(*u.ingestedBeforeInclusive)
	case "ingestedAfterInclusive":
		if u.ingestedAfterInclusive == nil {
			return result, fmt.Errorf("field \"ingestedAfterInclusive\" is required")
		}
		return ingestedAfterInclusiveFunc(*u.ingestedAfterInclusive)
	case "archiveStatus":
		if u.archiveStatus == nil {
			return result, fmt.Errorf("field \"archiveStatus\" is required")
		}
		return archiveStatusFunc(*u.archiveStatus)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchDatasetsQueryWithT[T]) SearchTextNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetsQueryWithT[T]) ExactMatchNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetsQueryWithT[T]) LabelNoopSuccess(api.Label) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetsQueryWithT[T]) PropertiesNoopSuccess(api.Property) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetsQueryWithT[T]) IngestStatusNoopSuccess(IngestStatus) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetsQueryWithT[T]) IngestedBeforeInclusiveNoopSuccess(datetime.DateTime) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetsQueryWithT[T]) IngestedAfterInclusiveNoopSuccess(datetime.DateTime) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetsQueryWithT[T]) ArchiveStatusNoopSuccess(bool) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetsQueryWithT[T]) AndNoopSuccess([]SearchDatasetsQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetsQueryWithT[T]) OrNoopSuccess([]SearchDatasetsQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetsQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchDatasetsQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchDatasetsQueryVisitorWithT[T any] interface {
	VisitSearchText(ctx context.Context, v string) (T, error)
	VisitExactMatch(ctx context.Context, v string) (T, error)
	VisitLabel(ctx context.Context, v api.Label) (T, error)
	VisitProperties(ctx context.Context, v api.Property) (T, error)
	VisitIngestStatus(ctx context.Context, v IngestStatus) (T, error)
	VisitIngestedBeforeInclusive(ctx context.Context, v datetime.DateTime) (T, error)
	VisitIngestedAfterInclusive(ctx context.Context, v datetime.DateTime) (T, error)
	VisitArchiveStatus(ctx context.Context, v bool) (T, error)
	VisitAnd(ctx context.Context, v []SearchDatasetsQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchDatasetsQuery) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimestampTypeWithT[T any] TimestampType

func (u *TimestampTypeWithT[T]) Accept(ctx context.Context, v TimestampTypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "relative":
		if u.relative == nil {
			return result, fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelative(ctx, *u.relative)
	case "absolute":
		if u.absolute == nil {
			return result, fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsolute(ctx, *u.absolute)
	}
}

func (u *TimestampTypeWithT[T]) AcceptFuncs(relativeFunc func(RelativeTimestamp) (T, error), absoluteFunc func(AbsoluteTimestamp) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "relative":
		if u.relative == nil {
			return result, fmt.Errorf("field \"relative\" is required")
		}
		return relativeFunc(*u.relative)
	case "absolute":
		if u.absolute == nil {
			return result, fmt.Errorf("field \"absolute\" is required")
		}
		return absoluteFunc(*u.absolute)
	}
}

func (u *TimestampTypeWithT[T]) RelativeNoopSuccess(RelativeTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *TimestampTypeWithT[T]) AbsoluteNoopSuccess(AbsoluteTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *TimestampTypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimestampTypeVisitorWithT[T any] interface {
	VisitRelative(ctx context.Context, v RelativeTimestamp) (T, error)
	VisitAbsolute(ctx context.Context, v AbsoluteTimestamp) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
