// Code generated by conjure-go. DO NOT EDIT.

package catalog

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/internal/conjureerrors"
	"github.com/nominal-io/nominal-api/io/nominal/api"
	"github.com/nominal-io/nominal-api/io/nominal/datasource"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type cannotAddToLegacyDataset struct {
	DatasetRid rid.ResourceIdentifier `json:"datasetRid"`
}

func (o cannotAddToLegacyDataset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *cannotAddToLegacyDataset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCannotAddToLegacyDataset returns new instance of CannotAddToLegacyDataset error.
func NewCannotAddToLegacyDataset(datasetRidArg rid.ResourceIdentifier) *CannotAddToLegacyDataset {
	return &CannotAddToLegacyDataset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cannotAddToLegacyDataset: cannotAddToLegacyDataset{DatasetRid: datasetRidArg}}
}

// WrapWithCannotAddToLegacyDataset returns new instance of CannotAddToLegacyDataset error wrapping an existing error.
func WrapWithCannotAddToLegacyDataset(err error, datasetRidArg rid.ResourceIdentifier) *CannotAddToLegacyDataset {
	return &CannotAddToLegacyDataset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, cannotAddToLegacyDataset: cannotAddToLegacyDataset{DatasetRid: datasetRidArg}}
}

// CannotAddToLegacyDataset is an error type.
// The current dataset is legacy and does not support multiple files. Please re-ingest this dataset.
type CannotAddToLegacyDataset struct {
	errorInstanceID uuid.UUID
	cannotAddToLegacyDataset
	cause error
	stack werror.StackTrace
}

// IsCannotAddToLegacyDataset returns true if err is an instance of CannotAddToLegacyDataset.
func IsCannotAddToLegacyDataset(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CannotAddToLegacyDataset)
	return ok
}

func (e *CannotAddToLegacyDataset) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Catalog:CannotAddToLegacyDataset (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CannotAddToLegacyDataset) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CannotAddToLegacyDataset) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CannotAddToLegacyDataset) Message() string {
	return "INVALID_ARGUMENT Catalog:CannotAddToLegacyDataset"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CannotAddToLegacyDataset) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CannotAddToLegacyDataset) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CannotAddToLegacyDataset) Name() string {
	return "Catalog:CannotAddToLegacyDataset"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CannotAddToLegacyDataset) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CannotAddToLegacyDataset) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CannotAddToLegacyDataset) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotAddToLegacyDataset) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CannotAddToLegacyDataset) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotAddToLegacyDataset) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CannotAddToLegacyDataset) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.cannotAddToLegacyDataset)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Catalog:CannotAddToLegacyDataset", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CannotAddToLegacyDataset) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters cannotAddToLegacyDataset
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.cannotAddToLegacyDataset = parameters
	return nil
}

type channelNotFound struct {
	ChannelRid rid.ResourceIdentifier `json:"channelRid"`
}

func (o channelNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *channelNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewChannelNotFound returns new instance of ChannelNotFound error.
func NewChannelNotFound(channelRidArg rid.ResourceIdentifier) *ChannelNotFound {
	return &ChannelNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), channelNotFound: channelNotFound{ChannelRid: channelRidArg}}
}

// WrapWithChannelNotFound returns new instance of ChannelNotFound error wrapping an existing error.
func WrapWithChannelNotFound(err error, channelRidArg rid.ResourceIdentifier) *ChannelNotFound {
	return &ChannelNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, channelNotFound: channelNotFound{ChannelRid: channelRidArg}}
}

// ChannelNotFound is an error type.
type ChannelNotFound struct {
	errorInstanceID uuid.UUID
	channelNotFound
	cause error
	stack werror.StackTrace
}

// IsChannelNotFound returns true if err is an instance of ChannelNotFound.
func IsChannelNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ChannelNotFound)
	return ok
}

func (e *ChannelNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Catalog:ChannelNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ChannelNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ChannelNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ChannelNotFound) Message() string {
	return "NOT_FOUND Catalog:ChannelNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ChannelNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ChannelNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *ChannelNotFound) Name() string {
	return "Catalog:ChannelNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ChannelNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ChannelNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"channelRid": e.ChannelRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ChannelNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"channelRid": e.ChannelRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChannelNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ChannelNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChannelNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ChannelNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.channelNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Catalog:ChannelNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ChannelNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters channelNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.channelNotFound = parameters
	return nil
}

type conflictOnDatasetCreation struct{}

func (o conflictOnDatasetCreation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *conflictOnDatasetCreation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConflictOnDatasetCreation returns new instance of ConflictOnDatasetCreation error.
func NewConflictOnDatasetCreation() *ConflictOnDatasetCreation {
	return &ConflictOnDatasetCreation{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), conflictOnDatasetCreation: conflictOnDatasetCreation{}}
}

// WrapWithConflictOnDatasetCreation returns new instance of ConflictOnDatasetCreation error wrapping an existing error.
func WrapWithConflictOnDatasetCreation(err error) *ConflictOnDatasetCreation {
	return &ConflictOnDatasetCreation{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, conflictOnDatasetCreation: conflictOnDatasetCreation{}}
}

// ConflictOnDatasetCreation is an error type.
type ConflictOnDatasetCreation struct {
	errorInstanceID uuid.UUID
	conflictOnDatasetCreation
	cause error
	stack werror.StackTrace
}

// IsConflictOnDatasetCreation returns true if err is an instance of ConflictOnDatasetCreation.
func IsConflictOnDatasetCreation(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConflictOnDatasetCreation)
	return ok
}

func (e *ConflictOnDatasetCreation) Error() string {
	return fmt.Sprintf("CONFLICT Catalog:ConflictOnDatasetCreation (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConflictOnDatasetCreation) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConflictOnDatasetCreation) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConflictOnDatasetCreation) Message() string {
	return "CONFLICT Catalog:ConflictOnDatasetCreation"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConflictOnDatasetCreation) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConflictOnDatasetCreation) Code() errors.ErrorCode {
	return errors.Conflict
}

// Name returns an error name identifying error type.
func (e *ConflictOnDatasetCreation) Name() string {
	return "Catalog:ConflictOnDatasetCreation"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConflictOnDatasetCreation) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConflictOnDatasetCreation) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConflictOnDatasetCreation) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConflictOnDatasetCreation) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConflictOnDatasetCreation) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConflictOnDatasetCreation) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConflictOnDatasetCreation) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.conflictOnDatasetCreation)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Conflict, ErrorName: "Catalog:ConflictOnDatasetCreation", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConflictOnDatasetCreation) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters conflictOnDatasetCreation
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.conflictOnDatasetCreation = parameters
	return nil
}

type conflictOnDatasetFileCreateOrUpdate struct{}

func (o conflictOnDatasetFileCreateOrUpdate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *conflictOnDatasetFileCreateOrUpdate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConflictOnDatasetFileCreateOrUpdate returns new instance of ConflictOnDatasetFileCreateOrUpdate error.
func NewConflictOnDatasetFileCreateOrUpdate() *ConflictOnDatasetFileCreateOrUpdate {
	return &ConflictOnDatasetFileCreateOrUpdate{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), conflictOnDatasetFileCreateOrUpdate: conflictOnDatasetFileCreateOrUpdate{}}
}

// WrapWithConflictOnDatasetFileCreateOrUpdate returns new instance of ConflictOnDatasetFileCreateOrUpdate error wrapping an existing error.
func WrapWithConflictOnDatasetFileCreateOrUpdate(err error) *ConflictOnDatasetFileCreateOrUpdate {
	return &ConflictOnDatasetFileCreateOrUpdate{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, conflictOnDatasetFileCreateOrUpdate: conflictOnDatasetFileCreateOrUpdate{}}
}

// ConflictOnDatasetFileCreateOrUpdate is an error type.
/*
Dataset files must have globally unique S3 paths on creation.
On update, the ingested_at timestamp must be unique.
*/
type ConflictOnDatasetFileCreateOrUpdate struct {
	errorInstanceID uuid.UUID
	conflictOnDatasetFileCreateOrUpdate
	cause error
	stack werror.StackTrace
}

// IsConflictOnDatasetFileCreateOrUpdate returns true if err is an instance of ConflictOnDatasetFileCreateOrUpdate.
func IsConflictOnDatasetFileCreateOrUpdate(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConflictOnDatasetFileCreateOrUpdate)
	return ok
}

func (e *ConflictOnDatasetFileCreateOrUpdate) Error() string {
	return fmt.Sprintf("CONFLICT Catalog:ConflictOnDatasetFileCreateOrUpdate (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConflictOnDatasetFileCreateOrUpdate) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConflictOnDatasetFileCreateOrUpdate) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConflictOnDatasetFileCreateOrUpdate) Message() string {
	return "CONFLICT Catalog:ConflictOnDatasetFileCreateOrUpdate"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConflictOnDatasetFileCreateOrUpdate) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConflictOnDatasetFileCreateOrUpdate) Code() errors.ErrorCode {
	return errors.Conflict
}

// Name returns an error name identifying error type.
func (e *ConflictOnDatasetFileCreateOrUpdate) Name() string {
	return "Catalog:ConflictOnDatasetFileCreateOrUpdate"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConflictOnDatasetFileCreateOrUpdate) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConflictOnDatasetFileCreateOrUpdate) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConflictOnDatasetFileCreateOrUpdate) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConflictOnDatasetFileCreateOrUpdate) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConflictOnDatasetFileCreateOrUpdate) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConflictOnDatasetFileCreateOrUpdate) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConflictOnDatasetFileCreateOrUpdate) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.conflictOnDatasetFileCreateOrUpdate)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Conflict, ErrorName: "Catalog:ConflictOnDatasetFileCreateOrUpdate", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConflictOnDatasetFileCreateOrUpdate) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters conflictOnDatasetFileCreateOrUpdate
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.conflictOnDatasetFileCreateOrUpdate = parameters
	return nil
}

type conflictOnSeriesCreation struct {
	DatasetRid rid.ResourceIdentifier `json:"datasetRid"`
	CsvIndex   *int                   `json:"csvIndex,omitempty"`
}

func (o conflictOnSeriesCreation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *conflictOnSeriesCreation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConflictOnSeriesCreation returns new instance of ConflictOnSeriesCreation error.
func NewConflictOnSeriesCreation(datasetRidArg rid.ResourceIdentifier, csvIndexArg *int) *ConflictOnSeriesCreation {
	return &ConflictOnSeriesCreation{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), conflictOnSeriesCreation: conflictOnSeriesCreation{DatasetRid: datasetRidArg, CsvIndex: csvIndexArg}}
}

// WrapWithConflictOnSeriesCreation returns new instance of ConflictOnSeriesCreation error wrapping an existing error.
func WrapWithConflictOnSeriesCreation(err error, datasetRidArg rid.ResourceIdentifier, csvIndexArg *int) *ConflictOnSeriesCreation {
	return &ConflictOnSeriesCreation{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, conflictOnSeriesCreation: conflictOnSeriesCreation{DatasetRid: datasetRidArg, CsvIndex: csvIndexArg}}
}

// ConflictOnSeriesCreation is an error type.
type ConflictOnSeriesCreation struct {
	errorInstanceID uuid.UUID
	conflictOnSeriesCreation
	cause error
	stack werror.StackTrace
}

// IsConflictOnSeriesCreation returns true if err is an instance of ConflictOnSeriesCreation.
func IsConflictOnSeriesCreation(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConflictOnSeriesCreation)
	return ok
}

func (e *ConflictOnSeriesCreation) Error() string {
	return fmt.Sprintf("CONFLICT Catalog:ConflictOnSeriesCreation (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConflictOnSeriesCreation) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConflictOnSeriesCreation) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConflictOnSeriesCreation) Message() string {
	return "CONFLICT Catalog:ConflictOnSeriesCreation"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConflictOnSeriesCreation) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConflictOnSeriesCreation) Code() errors.ErrorCode {
	return errors.Conflict
}

// Name returns an error name identifying error type.
func (e *ConflictOnSeriesCreation) Name() string {
	return "Catalog:ConflictOnSeriesCreation"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConflictOnSeriesCreation) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConflictOnSeriesCreation) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "csvIndex": e.CsvIndex}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConflictOnSeriesCreation) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "csvIndex": e.CsvIndex, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConflictOnSeriesCreation) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConflictOnSeriesCreation) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConflictOnSeriesCreation) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConflictOnSeriesCreation) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.conflictOnSeriesCreation)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Conflict, ErrorName: "Catalog:ConflictOnSeriesCreation", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConflictOnSeriesCreation) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters conflictOnSeriesCreation
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.conflictOnSeriesCreation = parameters
	return nil
}

type datasetExistsInOtherWorkspace struct {
	DatasetRid   rid.ResourceIdentifier `json:"datasetRid"`
	WorkspaceRid rids.WorkspaceRid      `json:"workspaceRid"`
}

func (o datasetExistsInOtherWorkspace) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *datasetExistsInOtherWorkspace) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDatasetExistsInOtherWorkspace returns new instance of DatasetExistsInOtherWorkspace error.
func NewDatasetExistsInOtherWorkspace(datasetRidArg rid.ResourceIdentifier, workspaceRidArg rids.WorkspaceRid) *DatasetExistsInOtherWorkspace {
	return &DatasetExistsInOtherWorkspace{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), datasetExistsInOtherWorkspace: datasetExistsInOtherWorkspace{DatasetRid: datasetRidArg, WorkspaceRid: workspaceRidArg}}
}

// WrapWithDatasetExistsInOtherWorkspace returns new instance of DatasetExistsInOtherWorkspace error wrapping an existing error.
func WrapWithDatasetExistsInOtherWorkspace(err error, datasetRidArg rid.ResourceIdentifier, workspaceRidArg rids.WorkspaceRid) *DatasetExistsInOtherWorkspace {
	return &DatasetExistsInOtherWorkspace{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, datasetExistsInOtherWorkspace: datasetExistsInOtherWorkspace{DatasetRid: datasetRidArg, WorkspaceRid: workspaceRidArg}}
}

// DatasetExistsInOtherWorkspace is an error type.
// The dataset with the requested path already exists in another workspace.
type DatasetExistsInOtherWorkspace struct {
	errorInstanceID uuid.UUID
	datasetExistsInOtherWorkspace
	cause error
	stack werror.StackTrace
}

// IsDatasetExistsInOtherWorkspace returns true if err is an instance of DatasetExistsInOtherWorkspace.
func IsDatasetExistsInOtherWorkspace(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DatasetExistsInOtherWorkspace)
	return ok
}

func (e *DatasetExistsInOtherWorkspace) Error() string {
	return fmt.Sprintf("CONFLICT Catalog:DatasetExistsInOtherWorkspace (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DatasetExistsInOtherWorkspace) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DatasetExistsInOtherWorkspace) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DatasetExistsInOtherWorkspace) Message() string {
	return "CONFLICT Catalog:DatasetExistsInOtherWorkspace"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DatasetExistsInOtherWorkspace) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DatasetExistsInOtherWorkspace) Code() errors.ErrorCode {
	return errors.Conflict
}

// Name returns an error name identifying error type.
func (e *DatasetExistsInOtherWorkspace) Name() string {
	return "Catalog:DatasetExistsInOtherWorkspace"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DatasetExistsInOtherWorkspace) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DatasetExistsInOtherWorkspace) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "workspaceRid": e.WorkspaceRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DatasetExistsInOtherWorkspace) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "workspaceRid": e.WorkspaceRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetExistsInOtherWorkspace) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DatasetExistsInOtherWorkspace) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetExistsInOtherWorkspace) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DatasetExistsInOtherWorkspace) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.datasetExistsInOtherWorkspace)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Conflict, ErrorName: "Catalog:DatasetExistsInOtherWorkspace", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DatasetExistsInOtherWorkspace) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters datasetExistsInOtherWorkspace
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.datasetExistsInOtherWorkspace = parameters
	return nil
}

type datasetFileNotFound struct {
	DatasetRid rid.ResourceIdentifier   `json:"datasetRid"`
	FileId     datasource.DatasetFileId `json:"fileId"`
}

func (o datasetFileNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *datasetFileNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDatasetFileNotFound returns new instance of DatasetFileNotFound error.
func NewDatasetFileNotFound(datasetRidArg rid.ResourceIdentifier, fileIdArg datasource.DatasetFileId) *DatasetFileNotFound {
	return &DatasetFileNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), datasetFileNotFound: datasetFileNotFound{DatasetRid: datasetRidArg, FileId: fileIdArg}}
}

// WrapWithDatasetFileNotFound returns new instance of DatasetFileNotFound error wrapping an existing error.
func WrapWithDatasetFileNotFound(err error, datasetRidArg rid.ResourceIdentifier, fileIdArg datasource.DatasetFileId) *DatasetFileNotFound {
	return &DatasetFileNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, datasetFileNotFound: datasetFileNotFound{DatasetRid: datasetRidArg, FileId: fileIdArg}}
}

// DatasetFileNotFound is an error type.
type DatasetFileNotFound struct {
	errorInstanceID uuid.UUID
	datasetFileNotFound
	cause error
	stack werror.StackTrace
}

// IsDatasetFileNotFound returns true if err is an instance of DatasetFileNotFound.
func IsDatasetFileNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DatasetFileNotFound)
	return ok
}

func (e *DatasetFileNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Catalog:DatasetFileNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DatasetFileNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DatasetFileNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DatasetFileNotFound) Message() string {
	return "NOT_FOUND Catalog:DatasetFileNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DatasetFileNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DatasetFileNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *DatasetFileNotFound) Name() string {
	return "Catalog:DatasetFileNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DatasetFileNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DatasetFileNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "fileId": e.FileId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DatasetFileNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "fileId": e.FileId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetFileNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DatasetFileNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetFileNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DatasetFileNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.datasetFileNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Catalog:DatasetFileNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DatasetFileNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters datasetFileNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.datasetFileNotFound = parameters
	return nil
}

type datasetNotFound struct {
	DatasetRid rid.ResourceIdentifier `json:"datasetRid"`
}

func (o datasetNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *datasetNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDatasetNotFound returns new instance of DatasetNotFound error.
func NewDatasetNotFound(datasetRidArg rid.ResourceIdentifier) *DatasetNotFound {
	return &DatasetNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), datasetNotFound: datasetNotFound{DatasetRid: datasetRidArg}}
}

// WrapWithDatasetNotFound returns new instance of DatasetNotFound error wrapping an existing error.
func WrapWithDatasetNotFound(err error, datasetRidArg rid.ResourceIdentifier) *DatasetNotFound {
	return &DatasetNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, datasetNotFound: datasetNotFound{DatasetRid: datasetRidArg}}
}

// DatasetNotFound is an error type.
type DatasetNotFound struct {
	errorInstanceID uuid.UUID
	datasetNotFound
	cause error
	stack werror.StackTrace
}

// IsDatasetNotFound returns true if err is an instance of DatasetNotFound.
func IsDatasetNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DatasetNotFound)
	return ok
}

func (e *DatasetNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Catalog:DatasetNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DatasetNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DatasetNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DatasetNotFound) Message() string {
	return "NOT_FOUND Catalog:DatasetNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DatasetNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DatasetNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *DatasetNotFound) Name() string {
	return "Catalog:DatasetNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DatasetNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DatasetNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DatasetNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DatasetNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DatasetNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.datasetNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Catalog:DatasetNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DatasetNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters datasetNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.datasetNotFound = parameters
	return nil
}

type datasetsNotFound struct {
	DatasetRid []rid.ResourceIdentifier `json:"datasetRid"`
}

func (o datasetsNotFound) MarshalJSON() ([]byte, error) {
	if o.DatasetRid == nil {
		o.DatasetRid = make([]rid.ResourceIdentifier, 0)
	}
	type _tmpdatasetsNotFound datasetsNotFound
	return safejson.Marshal(_tmpdatasetsNotFound(o))
}

func (o *datasetsNotFound) UnmarshalJSON(data []byte) error {
	type _tmpdatasetsNotFound datasetsNotFound
	var rawdatasetsNotFound _tmpdatasetsNotFound
	if err := safejson.Unmarshal(data, &rawdatasetsNotFound); err != nil {
		return err
	}
	if rawdatasetsNotFound.DatasetRid == nil {
		rawdatasetsNotFound.DatasetRid = make([]rid.ResourceIdentifier, 0)
	}
	*o = datasetsNotFound(rawdatasetsNotFound)
	return nil
}

func (o datasetsNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *datasetsNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDatasetsNotFound returns new instance of DatasetsNotFound error.
func NewDatasetsNotFound(datasetRidArg []rid.ResourceIdentifier) *DatasetsNotFound {
	return &DatasetsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), datasetsNotFound: datasetsNotFound{DatasetRid: datasetRidArg}}
}

// WrapWithDatasetsNotFound returns new instance of DatasetsNotFound error wrapping an existing error.
func WrapWithDatasetsNotFound(err error, datasetRidArg []rid.ResourceIdentifier) *DatasetsNotFound {
	return &DatasetsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, datasetsNotFound: datasetsNotFound{DatasetRid: datasetRidArg}}
}

// DatasetsNotFound is an error type.
type DatasetsNotFound struct {
	errorInstanceID uuid.UUID
	datasetsNotFound
	cause error
	stack werror.StackTrace
}

// IsDatasetsNotFound returns true if err is an instance of DatasetsNotFound.
func IsDatasetsNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DatasetsNotFound)
	return ok
}

func (e *DatasetsNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Catalog:DatasetsNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DatasetsNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DatasetsNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DatasetsNotFound) Message() string {
	return "NOT_FOUND Catalog:DatasetsNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DatasetsNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DatasetsNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *DatasetsNotFound) Name() string {
	return "Catalog:DatasetsNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DatasetsNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DatasetsNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DatasetsNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetsNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DatasetsNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetsNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DatasetsNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.datasetsNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Catalog:DatasetsNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DatasetsNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters datasetsNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.datasetsNotFound = parameters
	return nil
}

type granularityMismatch struct {
	DatasetRid rid.ResourceIdentifier `json:"datasetRid"`
}

func (o granularityMismatch) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *granularityMismatch) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewGranularityMismatch returns new instance of GranularityMismatch error.
func NewGranularityMismatch(datasetRidArg rid.ResourceIdentifier) *GranularityMismatch {
	return &GranularityMismatch{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), granularityMismatch: granularityMismatch{DatasetRid: datasetRidArg}}
}

// WrapWithGranularityMismatch returns new instance of GranularityMismatch error wrapping an existing error.
func WrapWithGranularityMismatch(err error, datasetRidArg rid.ResourceIdentifier) *GranularityMismatch {
	return &GranularityMismatch{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, granularityMismatch: granularityMismatch{DatasetRid: datasetRidArg}}
}

// GranularityMismatch is an error type.
// Different time units are not allowed for the same dataset. Must be either all nanoseconds or all picoseconds.
type GranularityMismatch struct {
	errorInstanceID uuid.UUID
	granularityMismatch
	cause error
	stack werror.StackTrace
}

// IsGranularityMismatch returns true if err is an instance of GranularityMismatch.
func IsGranularityMismatch(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*GranularityMismatch)
	return ok
}

func (e *GranularityMismatch) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Catalog:GranularityMismatch (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *GranularityMismatch) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *GranularityMismatch) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *GranularityMismatch) Message() string {
	return "INVALID_ARGUMENT Catalog:GranularityMismatch"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *GranularityMismatch) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *GranularityMismatch) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *GranularityMismatch) Name() string {
	return "Catalog:GranularityMismatch"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *GranularityMismatch) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *GranularityMismatch) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *GranularityMismatch) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *GranularityMismatch) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *GranularityMismatch) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *GranularityMismatch) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e GranularityMismatch) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.granularityMismatch)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Catalog:GranularityMismatch", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *GranularityMismatch) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters granularityMismatch
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.granularityMismatch = parameters
	return nil
}

type invalidStateForAddingAdditionalFile struct {
	State             *api.IngestStatusV2 `json:"state,omitempty"`
	TimestampMetadata *TimestampMetadata  `json:"timestampMetadata,omitempty"`
}

func (o invalidStateForAddingAdditionalFile) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidStateForAddingAdditionalFile) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidStateForAddingAdditionalFile returns new instance of InvalidStateForAddingAdditionalFile error.
func NewInvalidStateForAddingAdditionalFile(stateArg *api.IngestStatusV2, timestampMetadataArg *TimestampMetadata) *InvalidStateForAddingAdditionalFile {
	return &InvalidStateForAddingAdditionalFile{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidStateForAddingAdditionalFile: invalidStateForAddingAdditionalFile{State: stateArg, TimestampMetadata: timestampMetadataArg}}
}

// WrapWithInvalidStateForAddingAdditionalFile returns new instance of InvalidStateForAddingAdditionalFile error wrapping an existing error.
func WrapWithInvalidStateForAddingAdditionalFile(err error, stateArg *api.IngestStatusV2, timestampMetadataArg *TimestampMetadata) *InvalidStateForAddingAdditionalFile {
	return &InvalidStateForAddingAdditionalFile{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidStateForAddingAdditionalFile: invalidStateForAddingAdditionalFile{State: stateArg, TimestampMetadata: timestampMetadataArg}}
}

// InvalidStateForAddingAdditionalFile is an error type.
/*
The current dataset is not in a valid state for uploading an
additional file - it is either failed or still ingesting the
previous file.
*/
type InvalidStateForAddingAdditionalFile struct {
	errorInstanceID uuid.UUID
	invalidStateForAddingAdditionalFile
	cause error
	stack werror.StackTrace
}

// IsInvalidStateForAddingAdditionalFile returns true if err is an instance of InvalidStateForAddingAdditionalFile.
func IsInvalidStateForAddingAdditionalFile(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidStateForAddingAdditionalFile)
	return ok
}

func (e *InvalidStateForAddingAdditionalFile) Error() string {
	return fmt.Sprintf("CONFLICT Catalog:InvalidStateForAddingAdditionalFile (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidStateForAddingAdditionalFile) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidStateForAddingAdditionalFile) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidStateForAddingAdditionalFile) Message() string {
	return "CONFLICT Catalog:InvalidStateForAddingAdditionalFile"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidStateForAddingAdditionalFile) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidStateForAddingAdditionalFile) Code() errors.ErrorCode {
	return errors.Conflict
}

// Name returns an error name identifying error type.
func (e *InvalidStateForAddingAdditionalFile) Name() string {
	return "Catalog:InvalidStateForAddingAdditionalFile"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidStateForAddingAdditionalFile) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidStateForAddingAdditionalFile) Parameters() map[string]interface{} {
	return map[string]interface{}{"state": e.State, "timestampMetadata": e.TimestampMetadata}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidStateForAddingAdditionalFile) safeParams() map[string]interface{} {
	return map[string]interface{}{"state": e.State, "timestampMetadata": e.TimestampMetadata, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidStateForAddingAdditionalFile) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidStateForAddingAdditionalFile) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidStateForAddingAdditionalFile) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidStateForAddingAdditionalFile) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidStateForAddingAdditionalFile)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Conflict, ErrorName: "Catalog:InvalidStateForAddingAdditionalFile", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidStateForAddingAdditionalFile) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidStateForAddingAdditionalFile
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidStateForAddingAdditionalFile = parameters
	return nil
}

type runNotFound struct {
	RunRid rid.ResourceIdentifier `json:"runRid"`
}

func (o runNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *runNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewRunNotFound returns new instance of RunNotFound error.
func NewRunNotFound(runRidArg rid.ResourceIdentifier) *RunNotFound {
	return &RunNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), runNotFound: runNotFound{RunRid: runRidArg}}
}

// WrapWithRunNotFound returns new instance of RunNotFound error wrapping an existing error.
func WrapWithRunNotFound(err error, runRidArg rid.ResourceIdentifier) *RunNotFound {
	return &RunNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, runNotFound: runNotFound{RunRid: runRidArg}}
}

// RunNotFound is an error type.
type RunNotFound struct {
	errorInstanceID uuid.UUID
	runNotFound
	cause error
	stack werror.StackTrace
}

// IsRunNotFound returns true if err is an instance of RunNotFound.
func IsRunNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*RunNotFound)
	return ok
}

func (e *RunNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Scout:RunNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *RunNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *RunNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *RunNotFound) Message() string {
	return "NOT_FOUND Scout:RunNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *RunNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *RunNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *RunNotFound) Name() string {
	return "Scout:RunNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *RunNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *RunNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"runRid": e.RunRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *RunNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"runRid": e.RunRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *RunNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *RunNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *RunNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e RunNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.runNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Scout:RunNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *RunNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters runNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.runNotFound = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Catalog:CannotAddToLegacyDataset", reflect.TypeOf(CannotAddToLegacyDataset{}))
	conjureerrors.RegisterErrorType("Catalog:ChannelNotFound", reflect.TypeOf(ChannelNotFound{}))
	conjureerrors.RegisterErrorType("Catalog:ConflictOnDatasetCreation", reflect.TypeOf(ConflictOnDatasetCreation{}))
	conjureerrors.RegisterErrorType("Catalog:ConflictOnDatasetFileCreateOrUpdate", reflect.TypeOf(ConflictOnDatasetFileCreateOrUpdate{}))
	conjureerrors.RegisterErrorType("Catalog:ConflictOnSeriesCreation", reflect.TypeOf(ConflictOnSeriesCreation{}))
	conjureerrors.RegisterErrorType("Catalog:DatasetExistsInOtherWorkspace", reflect.TypeOf(DatasetExistsInOtherWorkspace{}))
	conjureerrors.RegisterErrorType("Catalog:DatasetFileNotFound", reflect.TypeOf(DatasetFileNotFound{}))
	conjureerrors.RegisterErrorType("Catalog:DatasetNotFound", reflect.TypeOf(DatasetNotFound{}))
	conjureerrors.RegisterErrorType("Catalog:DatasetsNotFound", reflect.TypeOf(DatasetsNotFound{}))
	conjureerrors.RegisterErrorType("Catalog:GranularityMismatch", reflect.TypeOf(GranularityMismatch{}))
	conjureerrors.RegisterErrorType("Catalog:InvalidStateForAddingAdditionalFile", reflect.TypeOf(InvalidStateForAddingAdditionalFile{}))
	conjureerrors.RegisterErrorType("Scout:RunNotFound", reflect.TypeOf(RunNotFound{}))
}
