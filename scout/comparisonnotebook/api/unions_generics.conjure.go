// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	api2 "github.com/nominal-io/nominal-api/io/nominal/api"
	api3 "github.com/nominal-io/nominal-api/scout/api"
	api1 "github.com/nominal-io/nominal-api/scout/rids/api"
	"github.com/nominal-io/nominal-api/scout/run/api"
)

type AggregationTypeWithT[T any] AggregationType

func (u *AggregationTypeWithT[T]) Accept(ctx context.Context, v AggregationTypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(ctx, *u.max)
	case "min":
		if u.min == nil {
			return result, fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(ctx, *u.min)
	case "mean":
		if u.mean == nil {
			return result, fmt.Errorf("field \"mean\" is required")
		}
		return v.VisitMean(ctx, *u.mean)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return result, fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviation(ctx, *u.standardDeviation)
	case "count":
		if u.count == nil {
			return result, fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCount(ctx, *u.count)
	}
}

func (u *AggregationTypeWithT[T]) AcceptFuncs(maxFunc func(Max) (T, error), minFunc func(Min) (T, error), meanFunc func(Mean) (T, error), standardDeviationFunc func(StandardDeviation) (T, error), countFunc func(Count) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "max":
		if u.max == nil {
			return result, fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "min":
		if u.min == nil {
			return result, fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "mean":
		if u.mean == nil {
			return result, fmt.Errorf("field \"mean\" is required")
		}
		return meanFunc(*u.mean)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return result, fmt.Errorf("field \"standardDeviation\" is required")
		}
		return standardDeviationFunc(*u.standardDeviation)
	case "count":
		if u.count == nil {
			return result, fmt.Errorf("field \"count\" is required")
		}
		return countFunc(*u.count)
	}
}

func (u *AggregationTypeWithT[T]) MaxNoopSuccess(Max) (T, error) {
	var result T
	return result, nil
}

func (u *AggregationTypeWithT[T]) MinNoopSuccess(Min) (T, error) {
	var result T
	return result, nil
}

func (u *AggregationTypeWithT[T]) MeanNoopSuccess(Mean) (T, error) {
	var result T
	return result, nil
}

func (u *AggregationTypeWithT[T]) StandardDeviationNoopSuccess(StandardDeviation) (T, error) {
	var result T
	return result, nil
}

func (u *AggregationTypeWithT[T]) CountNoopSuccess(Count) (T, error) {
	var result T
	return result, nil
}

func (u *AggregationTypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type AggregationTypeVisitorWithT[T any] interface {
	VisitMax(ctx context.Context, v Max) (T, error)
	VisitMin(ctx context.Context, v Min) (T, error)
	VisitMean(ctx context.Context, v Mean) (T, error)
	VisitStandardDeviation(ctx context.Context, v StandardDeviation) (T, error)
	VisitCount(ctx context.Context, v Count) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComparisonScatterPlotColoringOptionWithT[T any] ComparisonScatterPlotColoringOption

func (u *ComparisonScatterPlotColoringOptionWithT[T]) Accept(ctx context.Context, v ComparisonScatterPlotColoringOptionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "byVariable":
		if u.byVariable == nil {
			return result, fmt.Errorf("field \"byVariable\" is required")
		}
		return v.VisitByVariable(ctx, *u.byVariable)
	}
}

func (u *ComparisonScatterPlotColoringOptionWithT[T]) AcceptFuncs(byVariableFunc func(ColorByVariableConfiguration) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "byVariable":
		if u.byVariable == nil {
			return result, fmt.Errorf("field \"byVariable\" is required")
		}
		return byVariableFunc(*u.byVariable)
	}
}

func (u *ComparisonScatterPlotColoringOptionWithT[T]) ByVariableNoopSuccess(ColorByVariableConfiguration) (T, error) {
	var result T
	return result, nil
}

func (u *ComparisonScatterPlotColoringOptionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComparisonScatterPlotColoringOptionVisitorWithT[T any] interface {
	VisitByVariable(ctx context.Context, v ColorByVariableConfiguration) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComparisonScatterPlotDefinitionWithT[T any] ComparisonScatterPlotDefinition

func (u *ComparisonScatterPlotDefinitionWithT[T]) Accept(ctx context.Context, v ComparisonScatterPlotDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *ComparisonScatterPlotDefinitionWithT[T]) AcceptFuncs(v1Func func(ComparisonScatterPlotDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ComparisonScatterPlotDefinitionWithT[T]) V1NoopSuccess(ComparisonScatterPlotDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *ComparisonScatterPlotDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComparisonScatterPlotDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v ComparisonScatterPlotDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComparisonTableDefinitionWithT[T any] ComparisonTableDefinition

func (u *ComparisonTableDefinitionWithT[T]) Accept(ctx context.Context, v ComparisonTableDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(ctx, *u.v2)
	}
}

func (u *ComparisonTableDefinitionWithT[T]) AcceptFuncs(v1Func func(ComparisonTableDefinitionV1) (T, error), v2Func func(ComparisonTableDefinitionV2) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return result, fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *ComparisonTableDefinitionWithT[T]) V1NoopSuccess(ComparisonTableDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *ComparisonTableDefinitionWithT[T]) V2NoopSuccess(ComparisonTableDefinitionV2) (T, error) {
	var result T
	return result, nil
}

func (u *ComparisonTableDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComparisonTableDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v ComparisonTableDefinitionV1) (T, error)
	VisitV2(ctx context.Context, v ComparisonTableDefinitionV2) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComparisonTimeSeriesPlotDefinitionWithT[T any] ComparisonTimeSeriesPlotDefinition

func (u *ComparisonTimeSeriesPlotDefinitionWithT[T]) Accept(ctx context.Context, v ComparisonTimeSeriesPlotDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *ComparisonTimeSeriesPlotDefinitionWithT[T]) AcceptFuncs(v1Func func(ComparisonTimeSeriesPlotDefinitionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ComparisonTimeSeriesPlotDefinitionWithT[T]) V1NoopSuccess(ComparisonTimeSeriesPlotDefinitionV1) (T, error) {
	var result T
	return result, nil
}

func (u *ComparisonTimeSeriesPlotDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComparisonTimeSeriesPlotDefinitionVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v ComparisonTimeSeriesPlotDefinitionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComparisonWorkbookDataScopeWithT[T any] ComparisonWorkbookDataScope

func (u *ComparisonWorkbookDataScopeWithT[T]) Accept(ctx context.Context, v ComparisonWorkbookDataScopeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "runs":
		if u.runs == nil {
			return result, fmt.Errorf("field \"runs\" is required")
		}
		return v.VisitRuns(ctx, *u.runs)
	case "assets":
		if u.assets == nil {
			return result, fmt.Errorf("field \"assets\" is required")
		}
		return v.VisitAssets(ctx, *u.assets)
	}
}

func (u *ComparisonWorkbookDataScopeWithT[T]) AcceptFuncs(runsFunc func([]api.RunRid) (T, error), assetsFunc func([]api1.AssetRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "runs":
		if u.runs == nil {
			return result, fmt.Errorf("field \"runs\" is required")
		}
		return runsFunc(*u.runs)
	case "assets":
		if u.assets == nil {
			return result, fmt.Errorf("field \"assets\" is required")
		}
		return assetsFunc(*u.assets)
	}
}

func (u *ComparisonWorkbookDataScopeWithT[T]) RunsNoopSuccess([]api.RunRid) (T, error) {
	var result T
	return result, nil
}

func (u *ComparisonWorkbookDataScopeWithT[T]) AssetsNoopSuccess([]api1.AssetRid) (T, error) {
	var result T
	return result, nil
}

func (u *ComparisonWorkbookDataScopeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComparisonWorkbookDataScopeVisitorWithT[T any] interface {
	VisitRuns(ctx context.Context, v []api.RunRid) (T, error)
	VisitAssets(ctx context.Context, v []api1.AssetRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SupplementalComparisonWorkbookContextWithT[T any] SupplementalComparisonWorkbookContext

func (u *SupplementalComparisonWorkbookContextWithT[T]) Accept(ctx context.Context, v SupplementalComparisonWorkbookContextVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "none":
		if u.none == nil {
			return result, fmt.Errorf("field \"none\" is required")
		}
		return v.VisitNone(ctx, *u.none)
	case "rangeAggregation":
		if u.rangeAggregation == nil {
			return result, fmt.Errorf("field \"rangeAggregation\" is required")
		}
		return v.VisitRangeAggregation(ctx, *u.rangeAggregation)
	}
}

func (u *SupplementalComparisonWorkbookContextWithT[T]) AcceptFuncs(noneFunc func(api2.Empty) (T, error), rangeAggregationFunc func(RangeAggregationContext) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "none":
		if u.none == nil {
			return result, fmt.Errorf("field \"none\" is required")
		}
		return noneFunc(*u.none)
	case "rangeAggregation":
		if u.rangeAggregation == nil {
			return result, fmt.Errorf("field \"rangeAggregation\" is required")
		}
		return rangeAggregationFunc(*u.rangeAggregation)
	}
}

func (u *SupplementalComparisonWorkbookContextWithT[T]) NoneNoopSuccess(api2.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *SupplementalComparisonWorkbookContextWithT[T]) RangeAggregationNoopSuccess(RangeAggregationContext) (T, error) {
	var result T
	return result, nil
}

func (u *SupplementalComparisonWorkbookContextWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SupplementalComparisonWorkbookContextVisitorWithT[T any] interface {
	VisitNone(ctx context.Context, v api2.Empty) (T, error)
	VisitRangeAggregation(ctx context.Context, v RangeAggregationContext) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimeWindowWithT[T any] TimeWindow

func (u *TimeWindowWithT[T]) Accept(ctx context.Context, v TimeWindowVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "relative":
		if u.relative == nil {
			return result, fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelative(ctx, *u.relative)
	case "fixed":
		if u.fixed == nil {
			return result, fmt.Errorf("field \"fixed\" is required")
		}
		return v.VisitFixed(ctx, *u.fixed)
	}
}

func (u *TimeWindowWithT[T]) AcceptFuncs(relativeFunc func(api.Duration) (T, error), fixedFunc func(TimestampedRange) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "relative":
		if u.relative == nil {
			return result, fmt.Errorf("field \"relative\" is required")
		}
		return relativeFunc(*u.relative)
	case "fixed":
		if u.fixed == nil {
			return result, fmt.Errorf("field \"fixed\" is required")
		}
		return fixedFunc(*u.fixed)
	}
}

func (u *TimeWindowWithT[T]) RelativeNoopSuccess(api.Duration) (T, error) {
	var result T
	return result, nil
}

func (u *TimeWindowWithT[T]) FixedNoopSuccess(TimestampedRange) (T, error) {
	var result T
	return result, nil
}

func (u *TimeWindowWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimeWindowVisitorWithT[T any] interface {
	VisitRelative(ctx context.Context, v api.Duration) (T, error)
	VisitFixed(ctx context.Context, v TimestampedRange) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VariableLocatorWithT[T any] VariableLocator

func (u *VariableLocatorWithT[T]) Accept(ctx context.Context, v VariableLocatorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "comparisonWorkbookVariable":
		if u.comparisonWorkbookVariable == nil {
			return result, fmt.Errorf("field \"comparisonWorkbookVariable\" is required")
		}
		return v.VisitComparisonWorkbookVariable(ctx, *u.comparisonWorkbookVariable)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(ctx, *u.series)
	}
}

func (u *VariableLocatorWithT[T]) AcceptFuncs(comparisonWorkbookVariableFunc func(VariableName) (T, error), seriesFunc func(api3.ChannelLocator) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "comparisonWorkbookVariable":
		if u.comparisonWorkbookVariable == nil {
			return result, fmt.Errorf("field \"comparisonWorkbookVariable\" is required")
		}
		return comparisonWorkbookVariableFunc(*u.comparisonWorkbookVariable)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	}
}

func (u *VariableLocatorWithT[T]) ComparisonWorkbookVariableNoopSuccess(VariableName) (T, error) {
	var result T
	return result, nil
}

func (u *VariableLocatorWithT[T]) SeriesNoopSuccess(api3.ChannelLocator) (T, error) {
	var result T
	return result, nil
}

func (u *VariableLocatorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VariableLocatorVisitorWithT[T any] interface {
	VisitComparisonWorkbookVariable(ctx context.Context, v VariableName) (T, error)
	VisitSeries(ctx context.Context, v api3.ChannelLocator) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VizDefinitionWithT[T any] VizDefinition

func (u *VizDefinitionWithT[T]) Accept(ctx context.Context, v VizDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "table":
		if u.table == nil {
			return result, fmt.Errorf("field \"table\" is required")
		}
		return v.VisitTable(ctx, *u.table)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(ctx, *u.scatter)
	case "timeSeries":
		if u.timeSeries == nil {
			return result, fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeries(ctx, *u.timeSeries)
	}
}

func (u *VizDefinitionWithT[T]) AcceptFuncs(tableFunc func(ComparisonTableDefinition) (T, error), scatterFunc func(ComparisonScatterPlotDefinition) (T, error), timeSeriesFunc func(ComparisonTimeSeriesPlotDefinition) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "table":
		if u.table == nil {
			return result, fmt.Errorf("field \"table\" is required")
		}
		return tableFunc(*u.table)
	case "scatter":
		if u.scatter == nil {
			return result, fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	case "timeSeries":
		if u.timeSeries == nil {
			return result, fmt.Errorf("field \"timeSeries\" is required")
		}
		return timeSeriesFunc(*u.timeSeries)
	}
}

func (u *VizDefinitionWithT[T]) TableNoopSuccess(ComparisonTableDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) ScatterNoopSuccess(ComparisonScatterPlotDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) TimeSeriesNoopSuccess(ComparisonTimeSeriesPlotDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *VizDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VizDefinitionVisitorWithT[T any] interface {
	VisitTable(ctx context.Context, v ComparisonTableDefinition) (T, error)
	VisitScatter(ctx context.Context, v ComparisonScatterPlotDefinition) (T, error)
	VisitTimeSeries(ctx context.Context, v ComparisonTimeSeriesPlotDefinition) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
