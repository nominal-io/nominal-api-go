// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	api2 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	api3 "github.com/nominal-io/nominal-api-go/scout/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/nominal-io/nominal-api-go/scout/run/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type AggregationType struct {
	typ               string
	max               *Max
	min               *Min
	mean              *Mean
	standardDeviation *StandardDeviation
	count             *Count
}

type aggregationTypeDeserializer struct {
	Type              string             `json:"type"`
	Max               *Max               `json:"max"`
	Min               *Min               `json:"min"`
	Mean              *Mean              `json:"mean"`
	StandardDeviation *StandardDeviation `json:"standardDeviation"`
	Count             *Count             `json:"count"`
}

func (u *aggregationTypeDeserializer) toStruct() AggregationType {
	return AggregationType{typ: u.Type, max: u.Max, min: u.Min, mean: u.Mean, standardDeviation: u.StandardDeviation, count: u.Count}
}

func (u *AggregationType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "max":
		if u.max == nil {
			return nil, fmt.Errorf("field \"max\" is required")
		}
		return struct {
			Type string `json:"type"`
			Max  Max    `json:"max"`
		}{Type: "max", Max: *u.max}, nil
	case "min":
		if u.min == nil {
			return nil, fmt.Errorf("field \"min\" is required")
		}
		return struct {
			Type string `json:"type"`
			Min  Min    `json:"min"`
		}{Type: "min", Min: *u.min}, nil
	case "mean":
		if u.mean == nil {
			return nil, fmt.Errorf("field \"mean\" is required")
		}
		return struct {
			Type string `json:"type"`
			Mean Mean   `json:"mean"`
		}{Type: "mean", Mean: *u.mean}, nil
	case "standardDeviation":
		if u.standardDeviation == nil {
			return nil, fmt.Errorf("field \"standardDeviation\" is required")
		}
		return struct {
			Type              string            `json:"type"`
			StandardDeviation StandardDeviation `json:"standardDeviation"`
		}{Type: "standardDeviation", StandardDeviation: *u.standardDeviation}, nil
	case "count":
		if u.count == nil {
			return nil, fmt.Errorf("field \"count\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Count Count  `json:"count"`
		}{Type: "count", Count: *u.count}, nil
	}
}

func (u AggregationType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *AggregationType) UnmarshalJSON(data []byte) error {
	var deser aggregationTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
	}
	return nil
}

func (u AggregationType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *AggregationType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *AggregationType) AcceptFuncs(maxFunc func(Max) error, minFunc func(Min) error, meanFunc func(Mean) error, standardDeviationFunc func(StandardDeviation) error, countFunc func(Count) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return maxFunc(*u.max)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return minFunc(*u.min)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return meanFunc(*u.mean)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return standardDeviationFunc(*u.standardDeviation)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return countFunc(*u.count)
	}
}

func (u *AggregationType) MaxNoopSuccess(Max) error {
	return nil
}

func (u *AggregationType) MinNoopSuccess(Min) error {
	return nil
}

func (u *AggregationType) MeanNoopSuccess(Mean) error {
	return nil
}

func (u *AggregationType) StandardDeviationNoopSuccess(StandardDeviation) error {
	return nil
}

func (u *AggregationType) CountNoopSuccess(Count) error {
	return nil
}

func (u *AggregationType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *AggregationType) Accept(v AggregationTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMax(*u.max)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMin(*u.min)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return v.VisitMean(*u.mean)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviation(*u.standardDeviation)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCount(*u.count)
	}
}

type AggregationTypeVisitor interface {
	VisitMax(v Max) error
	VisitMin(v Min) error
	VisitMean(v Mean) error
	VisitStandardDeviation(v StandardDeviation) error
	VisitCount(v Count) error
	VisitUnknown(typeName string) error
}

func (u *AggregationType) AcceptWithContext(ctx context.Context, v AggregationTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "max":
		if u.max == nil {
			return fmt.Errorf("field \"max\" is required")
		}
		return v.VisitMaxWithContext(ctx, *u.max)
	case "min":
		if u.min == nil {
			return fmt.Errorf("field \"min\" is required")
		}
		return v.VisitMinWithContext(ctx, *u.min)
	case "mean":
		if u.mean == nil {
			return fmt.Errorf("field \"mean\" is required")
		}
		return v.VisitMeanWithContext(ctx, *u.mean)
	case "standardDeviation":
		if u.standardDeviation == nil {
			return fmt.Errorf("field \"standardDeviation\" is required")
		}
		return v.VisitStandardDeviationWithContext(ctx, *u.standardDeviation)
	case "count":
		if u.count == nil {
			return fmt.Errorf("field \"count\" is required")
		}
		return v.VisitCountWithContext(ctx, *u.count)
	}
}

type AggregationTypeVisitorWithContext interface {
	VisitMaxWithContext(ctx context.Context, v Max) error
	VisitMinWithContext(ctx context.Context, v Min) error
	VisitMeanWithContext(ctx context.Context, v Mean) error
	VisitStandardDeviationWithContext(ctx context.Context, v StandardDeviation) error
	VisitCountWithContext(ctx context.Context, v Count) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAggregationTypeFromMax(v Max) AggregationType {
	return AggregationType{typ: "max", max: &v}
}

func NewAggregationTypeFromMin(v Min) AggregationType {
	return AggregationType{typ: "min", min: &v}
}

func NewAggregationTypeFromMean(v Mean) AggregationType {
	return AggregationType{typ: "mean", mean: &v}
}

func NewAggregationTypeFromStandardDeviation(v StandardDeviation) AggregationType {
	return AggregationType{typ: "standardDeviation", standardDeviation: &v}
}

func NewAggregationTypeFromCount(v Count) AggregationType {
	return AggregationType{typ: "count", count: &v}
}

type ComparisonScatterPlotColoringOption struct {
	typ        string
	byVariable *ColorByVariableConfiguration
}

type comparisonScatterPlotColoringOptionDeserializer struct {
	Type       string                        `json:"type"`
	ByVariable *ColorByVariableConfiguration `json:"byVariable"`
}

func (u *comparisonScatterPlotColoringOptionDeserializer) toStruct() ComparisonScatterPlotColoringOption {
	return ComparisonScatterPlotColoringOption{typ: u.Type, byVariable: u.ByVariable}
}

func (u *ComparisonScatterPlotColoringOption) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "byVariable":
		if u.byVariable == nil {
			return nil, fmt.Errorf("field \"byVariable\" is required")
		}
		return struct {
			Type       string                       `json:"type"`
			ByVariable ColorByVariableConfiguration `json:"byVariable"`
		}{Type: "byVariable", ByVariable: *u.byVariable}, nil
	}
}

func (u ComparisonScatterPlotColoringOption) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComparisonScatterPlotColoringOption) UnmarshalJSON(data []byte) error {
	var deser comparisonScatterPlotColoringOptionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "byVariable":
		if u.byVariable == nil {
			return fmt.Errorf("field \"byVariable\" is required")
		}
	}
	return nil
}

func (u ComparisonScatterPlotColoringOption) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComparisonScatterPlotColoringOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComparisonScatterPlotColoringOption) AcceptFuncs(byVariableFunc func(ColorByVariableConfiguration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "byVariable":
		if u.byVariable == nil {
			return fmt.Errorf("field \"byVariable\" is required")
		}
		return byVariableFunc(*u.byVariable)
	}
}

func (u *ComparisonScatterPlotColoringOption) ByVariableNoopSuccess(ColorByVariableConfiguration) error {
	return nil
}

func (u *ComparisonScatterPlotColoringOption) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComparisonScatterPlotColoringOption) Accept(v ComparisonScatterPlotColoringOptionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "byVariable":
		if u.byVariable == nil {
			return fmt.Errorf("field \"byVariable\" is required")
		}
		return v.VisitByVariable(*u.byVariable)
	}
}

type ComparisonScatterPlotColoringOptionVisitor interface {
	VisitByVariable(v ColorByVariableConfiguration) error
	VisitUnknown(typeName string) error
}

func (u *ComparisonScatterPlotColoringOption) AcceptWithContext(ctx context.Context, v ComparisonScatterPlotColoringOptionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "byVariable":
		if u.byVariable == nil {
			return fmt.Errorf("field \"byVariable\" is required")
		}
		return v.VisitByVariableWithContext(ctx, *u.byVariable)
	}
}

type ComparisonScatterPlotColoringOptionVisitorWithContext interface {
	VisitByVariableWithContext(ctx context.Context, v ColorByVariableConfiguration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComparisonScatterPlotColoringOptionFromByVariable(v ColorByVariableConfiguration) ComparisonScatterPlotColoringOption {
	return ComparisonScatterPlotColoringOption{typ: "byVariable", byVariable: &v}
}

type ComparisonScatterPlotDefinition struct {
	typ string
	v1  *ComparisonScatterPlotDefinitionV1
}

type comparisonScatterPlotDefinitionDeserializer struct {
	Type string                             `json:"type"`
	V1   *ComparisonScatterPlotDefinitionV1 `json:"v1"`
}

func (u *comparisonScatterPlotDefinitionDeserializer) toStruct() ComparisonScatterPlotDefinition {
	return ComparisonScatterPlotDefinition{typ: u.Type, v1: u.V1}
}

func (u *ComparisonScatterPlotDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                            `json:"type"`
			V1   ComparisonScatterPlotDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u ComparisonScatterPlotDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComparisonScatterPlotDefinition) UnmarshalJSON(data []byte) error {
	var deser comparisonScatterPlotDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u ComparisonScatterPlotDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComparisonScatterPlotDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComparisonScatterPlotDefinition) AcceptFuncs(v1Func func(ComparisonScatterPlotDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ComparisonScatterPlotDefinition) V1NoopSuccess(ComparisonScatterPlotDefinitionV1) error {
	return nil
}

func (u *ComparisonScatterPlotDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComparisonScatterPlotDefinition) Accept(v ComparisonScatterPlotDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type ComparisonScatterPlotDefinitionVisitor interface {
	VisitV1(v ComparisonScatterPlotDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *ComparisonScatterPlotDefinition) AcceptWithContext(ctx context.Context, v ComparisonScatterPlotDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type ComparisonScatterPlotDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v ComparisonScatterPlotDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComparisonScatterPlotDefinitionFromV1(v ComparisonScatterPlotDefinitionV1) ComparisonScatterPlotDefinition {
	return ComparisonScatterPlotDefinition{typ: "v1", v1: &v}
}

type ComparisonTableDefinition struct {
	typ string
	v1  *ComparisonTableDefinitionV1
	v2  *ComparisonTableDefinitionV2
}

type comparisonTableDefinitionDeserializer struct {
	Type string                       `json:"type"`
	V1   *ComparisonTableDefinitionV1 `json:"v1"`
	V2   *ComparisonTableDefinitionV2 `json:"v2"`
}

func (u *comparisonTableDefinitionDeserializer) toStruct() ComparisonTableDefinition {
	return ComparisonTableDefinition{typ: u.Type, v1: u.V1, v2: u.V2}
}

func (u *ComparisonTableDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                      `json:"type"`
			V1   ComparisonTableDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	case "v2":
		if u.v2 == nil {
			return nil, fmt.Errorf("field \"v2\" is required")
		}
		return struct {
			Type string                      `json:"type"`
			V2   ComparisonTableDefinitionV2 `json:"v2"`
		}{Type: "v2", V2: *u.v2}, nil
	}
}

func (u ComparisonTableDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComparisonTableDefinition) UnmarshalJSON(data []byte) error {
	var deser comparisonTableDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
	}
	return nil
}

func (u ComparisonTableDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComparisonTableDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComparisonTableDefinition) AcceptFuncs(v1Func func(ComparisonTableDefinitionV1) error, v2Func func(ComparisonTableDefinitionV2) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v2Func(*u.v2)
	}
}

func (u *ComparisonTableDefinition) V1NoopSuccess(ComparisonTableDefinitionV1) error {
	return nil
}

func (u *ComparisonTableDefinition) V2NoopSuccess(ComparisonTableDefinitionV2) error {
	return nil
}

func (u *ComparisonTableDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComparisonTableDefinition) Accept(v ComparisonTableDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2(*u.v2)
	}
}

type ComparisonTableDefinitionVisitor interface {
	VisitV1(v ComparisonTableDefinitionV1) error
	VisitV2(v ComparisonTableDefinitionV2) error
	VisitUnknown(typeName string) error
}

func (u *ComparisonTableDefinition) AcceptWithContext(ctx context.Context, v ComparisonTableDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	case "v2":
		if u.v2 == nil {
			return fmt.Errorf("field \"v2\" is required")
		}
		return v.VisitV2WithContext(ctx, *u.v2)
	}
}

type ComparisonTableDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v ComparisonTableDefinitionV1) error
	VisitV2WithContext(ctx context.Context, v ComparisonTableDefinitionV2) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComparisonTableDefinitionFromV1(v ComparisonTableDefinitionV1) ComparisonTableDefinition {
	return ComparisonTableDefinition{typ: "v1", v1: &v}
}

func NewComparisonTableDefinitionFromV2(v ComparisonTableDefinitionV2) ComparisonTableDefinition {
	return ComparisonTableDefinition{typ: "v2", v2: &v}
}

type ComparisonTimeSeriesPlotDefinition struct {
	typ string
	v1  *ComparisonTimeSeriesPlotDefinitionV1
}

type comparisonTimeSeriesPlotDefinitionDeserializer struct {
	Type string                                `json:"type"`
	V1   *ComparisonTimeSeriesPlotDefinitionV1 `json:"v1"`
}

func (u *comparisonTimeSeriesPlotDefinitionDeserializer) toStruct() ComparisonTimeSeriesPlotDefinition {
	return ComparisonTimeSeriesPlotDefinition{typ: u.Type, v1: u.V1}
}

func (u *ComparisonTimeSeriesPlotDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                               `json:"type"`
			V1   ComparisonTimeSeriesPlotDefinitionV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u ComparisonTimeSeriesPlotDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComparisonTimeSeriesPlotDefinition) UnmarshalJSON(data []byte) error {
	var deser comparisonTimeSeriesPlotDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u ComparisonTimeSeriesPlotDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComparisonTimeSeriesPlotDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComparisonTimeSeriesPlotDefinition) AcceptFuncs(v1Func func(ComparisonTimeSeriesPlotDefinitionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ComparisonTimeSeriesPlotDefinition) V1NoopSuccess(ComparisonTimeSeriesPlotDefinitionV1) error {
	return nil
}

func (u *ComparisonTimeSeriesPlotDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComparisonTimeSeriesPlotDefinition) Accept(v ComparisonTimeSeriesPlotDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type ComparisonTimeSeriesPlotDefinitionVisitor interface {
	VisitV1(v ComparisonTimeSeriesPlotDefinitionV1) error
	VisitUnknown(typeName string) error
}

func (u *ComparisonTimeSeriesPlotDefinition) AcceptWithContext(ctx context.Context, v ComparisonTimeSeriesPlotDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type ComparisonTimeSeriesPlotDefinitionVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v ComparisonTimeSeriesPlotDefinitionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComparisonTimeSeriesPlotDefinitionFromV1(v ComparisonTimeSeriesPlotDefinitionV1) ComparisonTimeSeriesPlotDefinition {
	return ComparisonTimeSeriesPlotDefinition{typ: "v1", v1: &v}
}

type ComparisonWorkbookDataScope struct {
	typ    string
	runs   *[]api.RunRid
	assets *[]api1.AssetRid
}

type comparisonWorkbookDataScopeDeserializer struct {
	Type   string           `json:"type"`
	Runs   *[]api.RunRid    `json:"runs"`
	Assets *[]api1.AssetRid `json:"assets"`
}

func (u *comparisonWorkbookDataScopeDeserializer) toStruct() ComparisonWorkbookDataScope {
	return ComparisonWorkbookDataScope{typ: u.Type, runs: u.Runs, assets: u.Assets}
}

func (u *ComparisonWorkbookDataScope) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "runs":
		if u.runs == nil {
			return nil, fmt.Errorf("field \"runs\" is required")
		}
		return struct {
			Type string       `json:"type"`
			Runs []api.RunRid `json:"runs"`
		}{Type: "runs", Runs: *u.runs}, nil
	case "assets":
		if u.assets == nil {
			return nil, fmt.Errorf("field \"assets\" is required")
		}
		return struct {
			Type   string          `json:"type"`
			Assets []api1.AssetRid `json:"assets"`
		}{Type: "assets", Assets: *u.assets}, nil
	}
}

func (u ComparisonWorkbookDataScope) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComparisonWorkbookDataScope) UnmarshalJSON(data []byte) error {
	var deser comparisonWorkbookDataScopeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "runs":
		if u.runs == nil {
			return fmt.Errorf("field \"runs\" is required")
		}
	case "assets":
		if u.assets == nil {
			return fmt.Errorf("field \"assets\" is required")
		}
	}
	return nil
}

func (u ComparisonWorkbookDataScope) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComparisonWorkbookDataScope) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComparisonWorkbookDataScope) AcceptFuncs(runsFunc func([]api.RunRid) error, assetsFunc func([]api1.AssetRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "runs":
		if u.runs == nil {
			return fmt.Errorf("field \"runs\" is required")
		}
		return runsFunc(*u.runs)
	case "assets":
		if u.assets == nil {
			return fmt.Errorf("field \"assets\" is required")
		}
		return assetsFunc(*u.assets)
	}
}

func (u *ComparisonWorkbookDataScope) RunsNoopSuccess([]api.RunRid) error {
	return nil
}

func (u *ComparisonWorkbookDataScope) AssetsNoopSuccess([]api1.AssetRid) error {
	return nil
}

func (u *ComparisonWorkbookDataScope) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComparisonWorkbookDataScope) Accept(v ComparisonWorkbookDataScopeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "runs":
		if u.runs == nil {
			return fmt.Errorf("field \"runs\" is required")
		}
		return v.VisitRuns(*u.runs)
	case "assets":
		if u.assets == nil {
			return fmt.Errorf("field \"assets\" is required")
		}
		return v.VisitAssets(*u.assets)
	}
}

type ComparisonWorkbookDataScopeVisitor interface {
	VisitRuns(v []api.RunRid) error
	VisitAssets(v []api1.AssetRid) error
	VisitUnknown(typeName string) error
}

func (u *ComparisonWorkbookDataScope) AcceptWithContext(ctx context.Context, v ComparisonWorkbookDataScopeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "runs":
		if u.runs == nil {
			return fmt.Errorf("field \"runs\" is required")
		}
		return v.VisitRunsWithContext(ctx, *u.runs)
	case "assets":
		if u.assets == nil {
			return fmt.Errorf("field \"assets\" is required")
		}
		return v.VisitAssetsWithContext(ctx, *u.assets)
	}
}

type ComparisonWorkbookDataScopeVisitorWithContext interface {
	VisitRunsWithContext(ctx context.Context, v []api.RunRid) error
	VisitAssetsWithContext(ctx context.Context, v []api1.AssetRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComparisonWorkbookDataScopeFromRuns(v []api.RunRid) ComparisonWorkbookDataScope {
	return ComparisonWorkbookDataScope{typ: "runs", runs: &v}
}

func NewComparisonWorkbookDataScopeFromAssets(v []api1.AssetRid) ComparisonWorkbookDataScope {
	return ComparisonWorkbookDataScope{typ: "assets", assets: &v}
}

/*
This is used to allow variables to specify additional context that does not fit well into the general shape of
a compute node. For example, a range aggregation variable represents a bulk computation across several inputs,
whose context is specified here instead.
*/
type SupplementalComparisonWorkbookContext struct {
	typ              string
	none             *api2.Empty
	rangeAggregation *RangeAggregationContext
}

type supplementalComparisonWorkbookContextDeserializer struct {
	Type             string                   `json:"type"`
	None             *api2.Empty              `json:"none"`
	RangeAggregation *RangeAggregationContext `json:"rangeAggregation"`
}

func (u *supplementalComparisonWorkbookContextDeserializer) toStruct() SupplementalComparisonWorkbookContext {
	return SupplementalComparisonWorkbookContext{typ: u.Type, none: u.None, rangeAggregation: u.RangeAggregation}
}

func (u *SupplementalComparisonWorkbookContext) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "none":
		if u.none == nil {
			return nil, fmt.Errorf("field \"none\" is required")
		}
		return struct {
			Type string     `json:"type"`
			None api2.Empty `json:"none"`
		}{Type: "none", None: *u.none}, nil
	case "rangeAggregation":
		if u.rangeAggregation == nil {
			return nil, fmt.Errorf("field \"rangeAggregation\" is required")
		}
		return struct {
			Type             string                  `json:"type"`
			RangeAggregation RangeAggregationContext `json:"rangeAggregation"`
		}{Type: "rangeAggregation", RangeAggregation: *u.rangeAggregation}, nil
	}
}

func (u SupplementalComparisonWorkbookContext) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SupplementalComparisonWorkbookContext) UnmarshalJSON(data []byte) error {
	var deser supplementalComparisonWorkbookContextDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "none":
		if u.none == nil {
			return fmt.Errorf("field \"none\" is required")
		}
	case "rangeAggregation":
		if u.rangeAggregation == nil {
			return fmt.Errorf("field \"rangeAggregation\" is required")
		}
	}
	return nil
}

func (u SupplementalComparisonWorkbookContext) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SupplementalComparisonWorkbookContext) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SupplementalComparisonWorkbookContext) AcceptFuncs(noneFunc func(api2.Empty) error, rangeAggregationFunc func(RangeAggregationContext) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "none":
		if u.none == nil {
			return fmt.Errorf("field \"none\" is required")
		}
		return noneFunc(*u.none)
	case "rangeAggregation":
		if u.rangeAggregation == nil {
			return fmt.Errorf("field \"rangeAggregation\" is required")
		}
		return rangeAggregationFunc(*u.rangeAggregation)
	}
}

func (u *SupplementalComparisonWorkbookContext) NoneNoopSuccess(api2.Empty) error {
	return nil
}

func (u *SupplementalComparisonWorkbookContext) RangeAggregationNoopSuccess(RangeAggregationContext) error {
	return nil
}

func (u *SupplementalComparisonWorkbookContext) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SupplementalComparisonWorkbookContext) Accept(v SupplementalComparisonWorkbookContextVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "none":
		if u.none == nil {
			return fmt.Errorf("field \"none\" is required")
		}
		return v.VisitNone(*u.none)
	case "rangeAggregation":
		if u.rangeAggregation == nil {
			return fmt.Errorf("field \"rangeAggregation\" is required")
		}
		return v.VisitRangeAggregation(*u.rangeAggregation)
	}
}

type SupplementalComparisonWorkbookContextVisitor interface {
	VisitNone(v api2.Empty) error
	VisitRangeAggregation(v RangeAggregationContext) error
	VisitUnknown(typeName string) error
}

func (u *SupplementalComparisonWorkbookContext) AcceptWithContext(ctx context.Context, v SupplementalComparisonWorkbookContextVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "none":
		if u.none == nil {
			return fmt.Errorf("field \"none\" is required")
		}
		return v.VisitNoneWithContext(ctx, *u.none)
	case "rangeAggregation":
		if u.rangeAggregation == nil {
			return fmt.Errorf("field \"rangeAggregation\" is required")
		}
		return v.VisitRangeAggregationWithContext(ctx, *u.rangeAggregation)
	}
}

type SupplementalComparisonWorkbookContextVisitorWithContext interface {
	VisitNoneWithContext(ctx context.Context, v api2.Empty) error
	VisitRangeAggregationWithContext(ctx context.Context, v RangeAggregationContext) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSupplementalComparisonWorkbookContextFromNone(v api2.Empty) SupplementalComparisonWorkbookContext {
	return SupplementalComparisonWorkbookContext{typ: "none", none: &v}
}

func NewSupplementalComparisonWorkbookContextFromRangeAggregation(v RangeAggregationContext) SupplementalComparisonWorkbookContext {
	return SupplementalComparisonWorkbookContext{typ: "rangeAggregation", rangeAggregation: &v}
}

type TimeWindow struct {
	typ      string
	relative *api.Duration
	fixed    *TimestampedRange
}

type timeWindowDeserializer struct {
	Type     string            `json:"type"`
	Relative *api.Duration     `json:"relative"`
	Fixed    *TimestampedRange `json:"fixed"`
}

func (u *timeWindowDeserializer) toStruct() TimeWindow {
	return TimeWindow{typ: u.Type, relative: u.Relative, fixed: u.Fixed}
}

func (u *TimeWindow) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "relative":
		if u.relative == nil {
			return nil, fmt.Errorf("field \"relative\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Relative api.Duration `json:"relative"`
		}{Type: "relative", Relative: *u.relative}, nil
	case "fixed":
		if u.fixed == nil {
			return nil, fmt.Errorf("field \"fixed\" is required")
		}
		return struct {
			Type  string           `json:"type"`
			Fixed TimestampedRange `json:"fixed"`
		}{Type: "fixed", Fixed: *u.fixed}, nil
	}
}

func (u TimeWindow) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimeWindow) UnmarshalJSON(data []byte) error {
	var deser timeWindowDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
	}
	return nil
}

func (u TimeWindow) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimeWindow) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimeWindow) AcceptFuncs(relativeFunc func(api.Duration) error, fixedFunc func(TimestampedRange) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return relativeFunc(*u.relative)
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
		return fixedFunc(*u.fixed)
	}
}

func (u *TimeWindow) RelativeNoopSuccess(api.Duration) error {
	return nil
}

func (u *TimeWindow) FixedNoopSuccess(TimestampedRange) error {
	return nil
}

func (u *TimeWindow) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimeWindow) Accept(v TimeWindowVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelative(*u.relative)
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
		return v.VisitFixed(*u.fixed)
	}
}

type TimeWindowVisitor interface {
	VisitRelative(v api.Duration) error
	VisitFixed(v TimestampedRange) error
	VisitUnknown(typeName string) error
}

func (u *TimeWindow) AcceptWithContext(ctx context.Context, v TimeWindowVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelativeWithContext(ctx, *u.relative)
	case "fixed":
		if u.fixed == nil {
			return fmt.Errorf("field \"fixed\" is required")
		}
		return v.VisitFixedWithContext(ctx, *u.fixed)
	}
}

type TimeWindowVisitorWithContext interface {
	VisitRelativeWithContext(ctx context.Context, v api.Duration) error
	VisitFixedWithContext(ctx context.Context, v TimestampedRange) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimeWindowFromRelative(v api.Duration) TimeWindow {
	return TimeWindow{typ: "relative", relative: &v}
}

func NewTimeWindowFromFixed(v TimestampedRange) TimeWindow {
	return TimeWindow{typ: "fixed", fixed: &v}
}

type VariableLocator struct {
	typ                        string
	comparisonWorkbookVariable *VariableName
	series                     *api3.ChannelLocator
}

type variableLocatorDeserializer struct {
	Type                       string               `json:"type"`
	ComparisonWorkbookVariable *VariableName        `json:"comparisonWorkbookVariable"`
	Series                     *api3.ChannelLocator `json:"series"`
}

func (u *variableLocatorDeserializer) toStruct() VariableLocator {
	return VariableLocator{typ: u.Type, comparisonWorkbookVariable: u.ComparisonWorkbookVariable, series: u.Series}
}

func (u *VariableLocator) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "comparisonWorkbookVariable":
		if u.comparisonWorkbookVariable == nil {
			return nil, fmt.Errorf("field \"comparisonWorkbookVariable\" is required")
		}
		return struct {
			Type                       string       `json:"type"`
			ComparisonWorkbookVariable VariableName `json:"comparisonWorkbookVariable"`
		}{Type: "comparisonWorkbookVariable", ComparisonWorkbookVariable: *u.comparisonWorkbookVariable}, nil
	case "series":
		if u.series == nil {
			return nil, fmt.Errorf("field \"series\" is required")
		}
		return struct {
			Type   string              `json:"type"`
			Series api3.ChannelLocator `json:"series"`
		}{Type: "series", Series: *u.series}, nil
	}
}

func (u VariableLocator) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VariableLocator) UnmarshalJSON(data []byte) error {
	var deser variableLocatorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "comparisonWorkbookVariable":
		if u.comparisonWorkbookVariable == nil {
			return fmt.Errorf("field \"comparisonWorkbookVariable\" is required")
		}
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
	}
	return nil
}

func (u VariableLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VariableLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VariableLocator) AcceptFuncs(comparisonWorkbookVariableFunc func(VariableName) error, seriesFunc func(api3.ChannelLocator) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "comparisonWorkbookVariable":
		if u.comparisonWorkbookVariable == nil {
			return fmt.Errorf("field \"comparisonWorkbookVariable\" is required")
		}
		return comparisonWorkbookVariableFunc(*u.comparisonWorkbookVariable)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	}
}

func (u *VariableLocator) ComparisonWorkbookVariableNoopSuccess(VariableName) error {
	return nil
}

func (u *VariableLocator) SeriesNoopSuccess(api3.ChannelLocator) error {
	return nil
}

func (u *VariableLocator) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VariableLocator) Accept(v VariableLocatorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "comparisonWorkbookVariable":
		if u.comparisonWorkbookVariable == nil {
			return fmt.Errorf("field \"comparisonWorkbookVariable\" is required")
		}
		return v.VisitComparisonWorkbookVariable(*u.comparisonWorkbookVariable)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(*u.series)
	}
}

type VariableLocatorVisitor interface {
	VisitComparisonWorkbookVariable(v VariableName) error
	VisitSeries(v api3.ChannelLocator) error
	VisitUnknown(typeName string) error
}

func (u *VariableLocator) AcceptWithContext(ctx context.Context, v VariableLocatorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "comparisonWorkbookVariable":
		if u.comparisonWorkbookVariable == nil {
			return fmt.Errorf("field \"comparisonWorkbookVariable\" is required")
		}
		return v.VisitComparisonWorkbookVariableWithContext(ctx, *u.comparisonWorkbookVariable)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeriesWithContext(ctx, *u.series)
	}
}

type VariableLocatorVisitorWithContext interface {
	VisitComparisonWorkbookVariableWithContext(ctx context.Context, v VariableName) error
	VisitSeriesWithContext(ctx context.Context, v api3.ChannelLocator) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVariableLocatorFromComparisonWorkbookVariable(v VariableName) VariableLocator {
	return VariableLocator{typ: "comparisonWorkbookVariable", comparisonWorkbookVariable: &v}
}

func NewVariableLocatorFromSeries(v api3.ChannelLocator) VariableLocator {
	return VariableLocator{typ: "series", series: &v}
}

type VizDefinition struct {
	typ        string
	table      *ComparisonTableDefinition
	scatter    *ComparisonScatterPlotDefinition
	timeSeries *ComparisonTimeSeriesPlotDefinition
}

type vizDefinitionDeserializer struct {
	Type       string                              `json:"type"`
	Table      *ComparisonTableDefinition          `json:"table"`
	Scatter    *ComparisonScatterPlotDefinition    `json:"scatter"`
	TimeSeries *ComparisonTimeSeriesPlotDefinition `json:"timeSeries"`
}

func (u *vizDefinitionDeserializer) toStruct() VizDefinition {
	return VizDefinition{typ: u.Type, table: u.Table, scatter: u.Scatter, timeSeries: u.TimeSeries}
}

func (u *VizDefinition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "table":
		if u.table == nil {
			return nil, fmt.Errorf("field \"table\" is required")
		}
		return struct {
			Type  string                    `json:"type"`
			Table ComparisonTableDefinition `json:"table"`
		}{Type: "table", Table: *u.table}, nil
	case "scatter":
		if u.scatter == nil {
			return nil, fmt.Errorf("field \"scatter\" is required")
		}
		return struct {
			Type    string                          `json:"type"`
			Scatter ComparisonScatterPlotDefinition `json:"scatter"`
		}{Type: "scatter", Scatter: *u.scatter}, nil
	case "timeSeries":
		if u.timeSeries == nil {
			return nil, fmt.Errorf("field \"timeSeries\" is required")
		}
		return struct {
			Type       string                             `json:"type"`
			TimeSeries ComparisonTimeSeriesPlotDefinition `json:"timeSeries"`
		}{Type: "timeSeries", TimeSeries: *u.timeSeries}, nil
	}
}

func (u VizDefinition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VizDefinition) UnmarshalJSON(data []byte) error {
	var deser vizDefinitionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
	}
	return nil
}

func (u VizDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VizDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VizDefinition) AcceptFuncs(tableFunc func(ComparisonTableDefinition) error, scatterFunc func(ComparisonScatterPlotDefinition) error, timeSeriesFunc func(ComparisonTimeSeriesPlotDefinition) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
		return tableFunc(*u.table)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return scatterFunc(*u.scatter)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return timeSeriesFunc(*u.timeSeries)
	}
}

func (u *VizDefinition) TableNoopSuccess(ComparisonTableDefinition) error {
	return nil
}

func (u *VizDefinition) ScatterNoopSuccess(ComparisonScatterPlotDefinition) error {
	return nil
}

func (u *VizDefinition) TimeSeriesNoopSuccess(ComparisonTimeSeriesPlotDefinition) error {
	return nil
}

func (u *VizDefinition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VizDefinition) Accept(v VizDefinitionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
		return v.VisitTable(*u.table)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatter(*u.scatter)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeries(*u.timeSeries)
	}
}

type VizDefinitionVisitor interface {
	VisitTable(v ComparisonTableDefinition) error
	VisitScatter(v ComparisonScatterPlotDefinition) error
	VisitTimeSeries(v ComparisonTimeSeriesPlotDefinition) error
	VisitUnknown(typeName string) error
}

func (u *VizDefinition) AcceptWithContext(ctx context.Context, v VizDefinitionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "table":
		if u.table == nil {
			return fmt.Errorf("field \"table\" is required")
		}
		return v.VisitTableWithContext(ctx, *u.table)
	case "scatter":
		if u.scatter == nil {
			return fmt.Errorf("field \"scatter\" is required")
		}
		return v.VisitScatterWithContext(ctx, *u.scatter)
	case "timeSeries":
		if u.timeSeries == nil {
			return fmt.Errorf("field \"timeSeries\" is required")
		}
		return v.VisitTimeSeriesWithContext(ctx, *u.timeSeries)
	}
}

type VizDefinitionVisitorWithContext interface {
	VisitTableWithContext(ctx context.Context, v ComparisonTableDefinition) error
	VisitScatterWithContext(ctx context.Context, v ComparisonScatterPlotDefinition) error
	VisitTimeSeriesWithContext(ctx context.Context, v ComparisonTimeSeriesPlotDefinition) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVizDefinitionFromTable(v ComparisonTableDefinition) VizDefinition {
	return VizDefinition{typ: "table", table: &v}
}

func NewVizDefinitionFromScatter(v ComparisonScatterPlotDefinition) VizDefinition {
	return VizDefinition{typ: "scatter", scatter: &v}
}

func NewVizDefinitionFromTimeSeries(v ComparisonTimeSeriesPlotDefinition) VizDefinition {
	return VizDefinition{typ: "timeSeries", timeSeries: &v}
}
