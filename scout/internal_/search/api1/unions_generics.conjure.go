// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api1

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/scout/internal_/search/api"
	"github.com/nominal-io/nominal-api-go/scout/metadata"
)

type SearchQueryWithT[T any] SearchQuery

func (u *SearchQueryWithT[T]) Accept(ctx context.Context, v SearchQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "dateTimeField":
		if u.dateTimeField == nil {
			return result, fmt.Errorf("field \"dateTimeField\" is required")
		}
		return v.VisitDateTimeField(ctx, *u.dateTimeField)
	case "stringField":
		if u.stringField == nil {
			return result, fmt.Errorf("field \"stringField\" is required")
		}
		return v.VisitStringField(ctx, *u.stringField)
	case "timestampField":
		if u.timestampField == nil {
			return result, fmt.Errorf("field \"timestampField\" is required")
		}
		return v.VisitTimestampField(ctx, *u.timestampField)
	case "longField":
		if u.longField == nil {
			return result, fmt.Errorf("field \"longField\" is required")
		}
		return v.VisitLongField(ctx, *u.longField)
	case "booleanField":
		if u.booleanField == nil {
			return result, fmt.Errorf("field \"booleanField\" is required")
		}
		return v.VisitBooleanField(ctx, *u.booleanField)
	case "exactMatch":
		if u.exactMatch == nil {
			return result, fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatch(ctx, *u.exactMatch)
	case "stringArrayExactMatch":
		if u.stringArrayExactMatch == nil {
			return result, fmt.Errorf("field \"stringArrayExactMatch\" is required")
		}
		return v.VisitStringArrayExactMatch(ctx, *u.stringArrayExactMatch)
	case "stringArrayLength":
		if u.stringArrayLength == nil {
			return result, fmt.Errorf("field \"stringArrayLength\" is required")
		}
		return v.VisitStringArrayLength(ctx, *u.stringArrayLength)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(ctx, *u.searchText)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(ctx, *u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(ctx, *u.not)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	case "createdAt":
		if u.createdAt == nil {
			return result, fmt.Errorf("field \"createdAt\" is required")
		}
		return v.VisitCreatedAt(ctx, *u.createdAt)
	case "archivedStatus":
		if u.archivedStatus == nil {
			return result, fmt.Errorf("field \"archivedStatus\" is required")
		}
		return v.VisitArchivedStatus(ctx, *u.archivedStatus)
	case "isPublished":
		if u.isPublished == nil {
			return result, fmt.Errorf("field \"isPublished\" is required")
		}
		return v.VisitIsPublished(ctx, *u.isPublished)
	}
}

func (u *SearchQueryWithT[T]) AcceptFuncs(dateTimeFieldFunc func(api.DateTimeField) (T, error), stringFieldFunc func(api.StringField) (T, error), timestampFieldFunc func(api.TimestampField) (T, error), longFieldFunc func(api.LongField) (T, error), booleanFieldFunc func(api.BooleanField) (T, error), exactMatchFunc func(string) (T, error), stringArrayExactMatchFunc func(api.StringArrayField) (T, error), stringArrayLengthFunc func(metadata.StringArrayLengthQuery) (T, error), searchTextFunc func(string) (T, error), labelFunc func(api1.Label) (T, error), propertyFunc func(api1.Property) (T, error), andFunc func([]SearchQuery) (T, error), orFunc func([]SearchQuery) (T, error), notFunc func(SearchQuery) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), createdAtFunc func(metadata.CreatedAtQuery) (T, error), archivedStatusFunc func(api1.ArchivedStatus) (T, error), isPublishedFunc func(bool) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dateTimeField":
		if u.dateTimeField == nil {
			return result, fmt.Errorf("field \"dateTimeField\" is required")
		}
		return dateTimeFieldFunc(*u.dateTimeField)
	case "stringField":
		if u.stringField == nil {
			return result, fmt.Errorf("field \"stringField\" is required")
		}
		return stringFieldFunc(*u.stringField)
	case "timestampField":
		if u.timestampField == nil {
			return result, fmt.Errorf("field \"timestampField\" is required")
		}
		return timestampFieldFunc(*u.timestampField)
	case "longField":
		if u.longField == nil {
			return result, fmt.Errorf("field \"longField\" is required")
		}
		return longFieldFunc(*u.longField)
	case "booleanField":
		if u.booleanField == nil {
			return result, fmt.Errorf("field \"booleanField\" is required")
		}
		return booleanFieldFunc(*u.booleanField)
	case "exactMatch":
		if u.exactMatch == nil {
			return result, fmt.Errorf("field \"exactMatch\" is required")
		}
		return exactMatchFunc(*u.exactMatch)
	case "stringArrayExactMatch":
		if u.stringArrayExactMatch == nil {
			return result, fmt.Errorf("field \"stringArrayExactMatch\" is required")
		}
		return stringArrayExactMatchFunc(*u.stringArrayExactMatch)
	case "stringArrayLength":
		if u.stringArrayLength == nil {
			return result, fmt.Errorf("field \"stringArrayLength\" is required")
		}
		return stringArrayLengthFunc(*u.stringArrayLength)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	case "createdAt":
		if u.createdAt == nil {
			return result, fmt.Errorf("field \"createdAt\" is required")
		}
		return createdAtFunc(*u.createdAt)
	case "archivedStatus":
		if u.archivedStatus == nil {
			return result, fmt.Errorf("field \"archivedStatus\" is required")
		}
		return archivedStatusFunc(*u.archivedStatus)
	case "isPublished":
		if u.isPublished == nil {
			return result, fmt.Errorf("field \"isPublished\" is required")
		}
		return isPublishedFunc(*u.isPublished)
	}
}

func (u *SearchQueryWithT[T]) DateTimeFieldNoopSuccess(api.DateTimeField) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) StringFieldNoopSuccess(api.StringField) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) TimestampFieldNoopSuccess(api.TimestampField) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) LongFieldNoopSuccess(api.LongField) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) BooleanFieldNoopSuccess(api.BooleanField) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) ExactMatchNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) StringArrayExactMatchNoopSuccess(api.StringArrayField) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) StringArrayLengthNoopSuccess(metadata.StringArrayLengthQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) SearchTextNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) LabelNoopSuccess(api1.Label) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) PropertyNoopSuccess(api1.Property) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) AndNoopSuccess([]SearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) OrNoopSuccess([]SearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) NotNoopSuccess(SearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) CreatedAtNoopSuccess(metadata.CreatedAtQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) ArchivedStatusNoopSuccess(api1.ArchivedStatus) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) IsPublishedNoopSuccess(bool) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchQueryVisitorWithT[T any] interface {
	VisitDateTimeField(ctx context.Context, v api.DateTimeField) (T, error)
	VisitStringField(ctx context.Context, v api.StringField) (T, error)
	VisitTimestampField(ctx context.Context, v api.TimestampField) (T, error)
	VisitLongField(ctx context.Context, v api.LongField) (T, error)
	VisitBooleanField(ctx context.Context, v api.BooleanField) (T, error)
	VisitExactMatch(ctx context.Context, v string) (T, error)
	VisitStringArrayExactMatch(ctx context.Context, v api.StringArrayField) (T, error)
	VisitStringArrayLength(ctx context.Context, v metadata.StringArrayLengthQuery) (T, error)
	VisitSearchText(ctx context.Context, v string) (T, error)
	VisitLabel(ctx context.Context, v api1.Label) (T, error)
	VisitProperty(ctx context.Context, v api1.Property) (T, error)
	VisitAnd(ctx context.Context, v []SearchQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchQuery) (T, error)
	VisitNot(ctx context.Context, v SearchQuery) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitCreatedAt(ctx context.Context, v metadata.CreatedAtQuery) (T, error)
	VisitArchivedStatus(ctx context.Context, v api1.ArchivedStatus) (T, error)
	VisitIsPublished(ctx context.Context, v bool) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
