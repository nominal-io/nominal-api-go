// Code generated by conjure-go. DO NOT EDIT.

package api1

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/scout/internal_/search/api"
	"github.com/nominal-io/nominal-api-go/scout/metadata"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type SearchQuery struct {
	typ                   string
	dateTimeField         *api.DateTimeField
	stringField           *api.StringField
	timestampField        *api.TimestampField
	longField             *api.LongField
	booleanField          *api.BooleanField
	exactMatch            *string
	stringArrayExactMatch *api.StringArrayField
	stringArrayLength     *metadata.StringArrayLengthQuery
	searchText            *string
	label                 *api1.Label
	property              *api1.Property
	and                   *[]SearchQuery
	or                    *[]SearchQuery
	not                   *SearchQuery
	workspace             *rids.WorkspaceRid
	createdAt             *metadata.CreatedAtQuery
	archivedStatus        *api1.ArchivedStatus
	isPublished           *bool
}

type searchQueryDeserializer struct {
	Type                  string                           `json:"type"`
	DateTimeField         *api.DateTimeField               `json:"dateTimeField"`
	StringField           *api.StringField                 `json:"stringField"`
	TimestampField        *api.TimestampField              `json:"timestampField"`
	LongField             *api.LongField                   `json:"longField"`
	BooleanField          *api.BooleanField                `json:"booleanField"`
	ExactMatch            *string                          `json:"exactMatch"`
	StringArrayExactMatch *api.StringArrayField            `json:"stringArrayExactMatch"`
	StringArrayLength     *metadata.StringArrayLengthQuery `json:"stringArrayLength"`
	SearchText            *string                          `json:"searchText"`
	Label                 *api1.Label                      `json:"label"`
	Property              *api1.Property                   `json:"property"`
	And                   *[]SearchQuery                   `json:"and"`
	Or                    *[]SearchQuery                   `json:"or"`
	Not                   *SearchQuery                     `json:"not"`
	Workspace             *rids.WorkspaceRid               `json:"workspace"`
	CreatedAt             *metadata.CreatedAtQuery         `json:"createdAt"`
	ArchivedStatus        *api1.ArchivedStatus             `json:"archivedStatus"`
	IsPublished           *bool                            `json:"isPublished"`
}

func (u *searchQueryDeserializer) toStruct() SearchQuery {
	return SearchQuery{typ: u.Type, dateTimeField: u.DateTimeField, stringField: u.StringField, timestampField: u.TimestampField, longField: u.LongField, booleanField: u.BooleanField, exactMatch: u.ExactMatch, stringArrayExactMatch: u.StringArrayExactMatch, stringArrayLength: u.StringArrayLength, searchText: u.SearchText, label: u.Label, property: u.Property, and: u.And, or: u.Or, not: u.Not, workspace: u.Workspace, createdAt: u.CreatedAt, archivedStatus: u.ArchivedStatus, isPublished: u.IsPublished}
}

func (u *SearchQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "dateTimeField":
		if u.dateTimeField == nil {
			return nil, fmt.Errorf("field \"dateTimeField\" is required")
		}
		return struct {
			Type          string            `json:"type"`
			DateTimeField api.DateTimeField `json:"dateTimeField"`
		}{Type: "dateTimeField", DateTimeField: *u.dateTimeField}, nil
	case "stringField":
		if u.stringField == nil {
			return nil, fmt.Errorf("field \"stringField\" is required")
		}
		return struct {
			Type        string          `json:"type"`
			StringField api.StringField `json:"stringField"`
		}{Type: "stringField", StringField: *u.stringField}, nil
	case "timestampField":
		if u.timestampField == nil {
			return nil, fmt.Errorf("field \"timestampField\" is required")
		}
		return struct {
			Type           string             `json:"type"`
			TimestampField api.TimestampField `json:"timestampField"`
		}{Type: "timestampField", TimestampField: *u.timestampField}, nil
	case "longField":
		if u.longField == nil {
			return nil, fmt.Errorf("field \"longField\" is required")
		}
		return struct {
			Type      string        `json:"type"`
			LongField api.LongField `json:"longField"`
		}{Type: "longField", LongField: *u.longField}, nil
	case "booleanField":
		if u.booleanField == nil {
			return nil, fmt.Errorf("field \"booleanField\" is required")
		}
		return struct {
			Type         string           `json:"type"`
			BooleanField api.BooleanField `json:"booleanField"`
		}{Type: "booleanField", BooleanField: *u.booleanField}, nil
	case "exactMatch":
		if u.exactMatch == nil {
			return nil, fmt.Errorf("field \"exactMatch\" is required")
		}
		return struct {
			Type       string `json:"type"`
			ExactMatch string `json:"exactMatch"`
		}{Type: "exactMatch", ExactMatch: *u.exactMatch}, nil
	case "stringArrayExactMatch":
		if u.stringArrayExactMatch == nil {
			return nil, fmt.Errorf("field \"stringArrayExactMatch\" is required")
		}
		return struct {
			Type                  string               `json:"type"`
			StringArrayExactMatch api.StringArrayField `json:"stringArrayExactMatch"`
		}{Type: "stringArrayExactMatch", StringArrayExactMatch: *u.stringArrayExactMatch}, nil
	case "stringArrayLength":
		if u.stringArrayLength == nil {
			return nil, fmt.Errorf("field \"stringArrayLength\" is required")
		}
		return struct {
			Type              string                          `json:"type"`
			StringArrayLength metadata.StringArrayLengthQuery `json:"stringArrayLength"`
		}{Type: "stringArrayLength", StringArrayLength: *u.stringArrayLength}, nil
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "label":
		if u.label == nil {
			return nil, fmt.Errorf("field \"label\" is required")
		}
		return struct {
			Type  string     `json:"type"`
			Label api1.Label `json:"label"`
		}{Type: "label", Label: *u.label}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string        `json:"type"`
			Property api1.Property `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string        `json:"type"`
			And  []SearchQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Or   []SearchQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string      `json:"type"`
			Not  SearchQuery `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	case "createdAt":
		if u.createdAt == nil {
			return nil, fmt.Errorf("field \"createdAt\" is required")
		}
		return struct {
			Type      string                  `json:"type"`
			CreatedAt metadata.CreatedAtQuery `json:"createdAt"`
		}{Type: "createdAt", CreatedAt: *u.createdAt}, nil
	case "archivedStatus":
		if u.archivedStatus == nil {
			return nil, fmt.Errorf("field \"archivedStatus\" is required")
		}
		return struct {
			Type           string              `json:"type"`
			ArchivedStatus api1.ArchivedStatus `json:"archivedStatus"`
		}{Type: "archivedStatus", ArchivedStatus: *u.archivedStatus}, nil
	case "isPublished":
		if u.isPublished == nil {
			return nil, fmt.Errorf("field \"isPublished\" is required")
		}
		return struct {
			Type        string `json:"type"`
			IsPublished bool   `json:"isPublished"`
		}{Type: "isPublished", IsPublished: *u.isPublished}, nil
	}
}

func (u SearchQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchQuery) UnmarshalJSON(data []byte) error {
	var deser searchQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "dateTimeField":
		if u.dateTimeField == nil {
			return fmt.Errorf("field \"dateTimeField\" is required")
		}
	case "stringField":
		if u.stringField == nil {
			return fmt.Errorf("field \"stringField\" is required")
		}
	case "timestampField":
		if u.timestampField == nil {
			return fmt.Errorf("field \"timestampField\" is required")
		}
	case "longField":
		if u.longField == nil {
			return fmt.Errorf("field \"longField\" is required")
		}
	case "booleanField":
		if u.booleanField == nil {
			return fmt.Errorf("field \"booleanField\" is required")
		}
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
	case "stringArrayExactMatch":
		if u.stringArrayExactMatch == nil {
			return fmt.Errorf("field \"stringArrayExactMatch\" is required")
		}
	case "stringArrayLength":
		if u.stringArrayLength == nil {
			return fmt.Errorf("field \"stringArrayLength\" is required")
		}
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	case "createdAt":
		if u.createdAt == nil {
			return fmt.Errorf("field \"createdAt\" is required")
		}
	case "archivedStatus":
		if u.archivedStatus == nil {
			return fmt.Errorf("field \"archivedStatus\" is required")
		}
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
	}
	return nil
}

func (u SearchQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchQuery) AcceptFuncs(dateTimeFieldFunc func(api.DateTimeField) error, stringFieldFunc func(api.StringField) error, timestampFieldFunc func(api.TimestampField) error, longFieldFunc func(api.LongField) error, booleanFieldFunc func(api.BooleanField) error, exactMatchFunc func(string) error, stringArrayExactMatchFunc func(api.StringArrayField) error, stringArrayLengthFunc func(metadata.StringArrayLengthQuery) error, searchTextFunc func(string) error, labelFunc func(api1.Label) error, propertyFunc func(api1.Property) error, andFunc func([]SearchQuery) error, orFunc func([]SearchQuery) error, notFunc func(SearchQuery) error, workspaceFunc func(rids.WorkspaceRid) error, createdAtFunc func(metadata.CreatedAtQuery) error, archivedStatusFunc func(api1.ArchivedStatus) error, isPublishedFunc func(bool) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dateTimeField":
		if u.dateTimeField == nil {
			return fmt.Errorf("field \"dateTimeField\" is required")
		}
		return dateTimeFieldFunc(*u.dateTimeField)
	case "stringField":
		if u.stringField == nil {
			return fmt.Errorf("field \"stringField\" is required")
		}
		return stringFieldFunc(*u.stringField)
	case "timestampField":
		if u.timestampField == nil {
			return fmt.Errorf("field \"timestampField\" is required")
		}
		return timestampFieldFunc(*u.timestampField)
	case "longField":
		if u.longField == nil {
			return fmt.Errorf("field \"longField\" is required")
		}
		return longFieldFunc(*u.longField)
	case "booleanField":
		if u.booleanField == nil {
			return fmt.Errorf("field \"booleanField\" is required")
		}
		return booleanFieldFunc(*u.booleanField)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return exactMatchFunc(*u.exactMatch)
	case "stringArrayExactMatch":
		if u.stringArrayExactMatch == nil {
			return fmt.Errorf("field \"stringArrayExactMatch\" is required")
		}
		return stringArrayExactMatchFunc(*u.stringArrayExactMatch)
	case "stringArrayLength":
		if u.stringArrayLength == nil {
			return fmt.Errorf("field \"stringArrayLength\" is required")
		}
		return stringArrayLengthFunc(*u.stringArrayLength)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	case "createdAt":
		if u.createdAt == nil {
			return fmt.Errorf("field \"createdAt\" is required")
		}
		return createdAtFunc(*u.createdAt)
	case "archivedStatus":
		if u.archivedStatus == nil {
			return fmt.Errorf("field \"archivedStatus\" is required")
		}
		return archivedStatusFunc(*u.archivedStatus)
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
		return isPublishedFunc(*u.isPublished)
	}
}

func (u *SearchQuery) DateTimeFieldNoopSuccess(api.DateTimeField) error {
	return nil
}

func (u *SearchQuery) StringFieldNoopSuccess(api.StringField) error {
	return nil
}

func (u *SearchQuery) TimestampFieldNoopSuccess(api.TimestampField) error {
	return nil
}

func (u *SearchQuery) LongFieldNoopSuccess(api.LongField) error {
	return nil
}

func (u *SearchQuery) BooleanFieldNoopSuccess(api.BooleanField) error {
	return nil
}

func (u *SearchQuery) ExactMatchNoopSuccess(string) error {
	return nil
}

func (u *SearchQuery) StringArrayExactMatchNoopSuccess(api.StringArrayField) error {
	return nil
}

func (u *SearchQuery) StringArrayLengthNoopSuccess(metadata.StringArrayLengthQuery) error {
	return nil
}

func (u *SearchQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *SearchQuery) LabelNoopSuccess(api1.Label) error {
	return nil
}

func (u *SearchQuery) PropertyNoopSuccess(api1.Property) error {
	return nil
}

func (u *SearchQuery) AndNoopSuccess([]SearchQuery) error {
	return nil
}

func (u *SearchQuery) OrNoopSuccess([]SearchQuery) error {
	return nil
}

func (u *SearchQuery) NotNoopSuccess(SearchQuery) error {
	return nil
}

func (u *SearchQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *SearchQuery) CreatedAtNoopSuccess(metadata.CreatedAtQuery) error {
	return nil
}

func (u *SearchQuery) ArchivedStatusNoopSuccess(api1.ArchivedStatus) error {
	return nil
}

func (u *SearchQuery) IsPublishedNoopSuccess(bool) error {
	return nil
}

func (u *SearchQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchQuery) Accept(v SearchQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "dateTimeField":
		if u.dateTimeField == nil {
			return fmt.Errorf("field \"dateTimeField\" is required")
		}
		return v.VisitDateTimeField(*u.dateTimeField)
	case "stringField":
		if u.stringField == nil {
			return fmt.Errorf("field \"stringField\" is required")
		}
		return v.VisitStringField(*u.stringField)
	case "timestampField":
		if u.timestampField == nil {
			return fmt.Errorf("field \"timestampField\" is required")
		}
		return v.VisitTimestampField(*u.timestampField)
	case "longField":
		if u.longField == nil {
			return fmt.Errorf("field \"longField\" is required")
		}
		return v.VisitLongField(*u.longField)
	case "booleanField":
		if u.booleanField == nil {
			return fmt.Errorf("field \"booleanField\" is required")
		}
		return v.VisitBooleanField(*u.booleanField)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatch(*u.exactMatch)
	case "stringArrayExactMatch":
		if u.stringArrayExactMatch == nil {
			return fmt.Errorf("field \"stringArrayExactMatch\" is required")
		}
		return v.VisitStringArrayExactMatch(*u.stringArrayExactMatch)
	case "stringArrayLength":
		if u.stringArrayLength == nil {
			return fmt.Errorf("field \"stringArrayLength\" is required")
		}
		return v.VisitStringArrayLength(*u.stringArrayLength)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	case "createdAt":
		if u.createdAt == nil {
			return fmt.Errorf("field \"createdAt\" is required")
		}
		return v.VisitCreatedAt(*u.createdAt)
	case "archivedStatus":
		if u.archivedStatus == nil {
			return fmt.Errorf("field \"archivedStatus\" is required")
		}
		return v.VisitArchivedStatus(*u.archivedStatus)
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
		return v.VisitIsPublished(*u.isPublished)
	}
}

type SearchQueryVisitor interface {
	VisitDateTimeField(v api.DateTimeField) error
	VisitStringField(v api.StringField) error
	VisitTimestampField(v api.TimestampField) error
	VisitLongField(v api.LongField) error
	VisitBooleanField(v api.BooleanField) error
	VisitExactMatch(v string) error
	VisitStringArrayExactMatch(v api.StringArrayField) error
	VisitStringArrayLength(v metadata.StringArrayLengthQuery) error
	VisitSearchText(v string) error
	VisitLabel(v api1.Label) error
	VisitProperty(v api1.Property) error
	VisitAnd(v []SearchQuery) error
	VisitOr(v []SearchQuery) error
	VisitNot(v SearchQuery) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitCreatedAt(v metadata.CreatedAtQuery) error
	VisitArchivedStatus(v api1.ArchivedStatus) error
	VisitIsPublished(v bool) error
	VisitUnknown(typeName string) error
}

func (u *SearchQuery) AcceptWithContext(ctx context.Context, v SearchQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "dateTimeField":
		if u.dateTimeField == nil {
			return fmt.Errorf("field \"dateTimeField\" is required")
		}
		return v.VisitDateTimeFieldWithContext(ctx, *u.dateTimeField)
	case "stringField":
		if u.stringField == nil {
			return fmt.Errorf("field \"stringField\" is required")
		}
		return v.VisitStringFieldWithContext(ctx, *u.stringField)
	case "timestampField":
		if u.timestampField == nil {
			return fmt.Errorf("field \"timestampField\" is required")
		}
		return v.VisitTimestampFieldWithContext(ctx, *u.timestampField)
	case "longField":
		if u.longField == nil {
			return fmt.Errorf("field \"longField\" is required")
		}
		return v.VisitLongFieldWithContext(ctx, *u.longField)
	case "booleanField":
		if u.booleanField == nil {
			return fmt.Errorf("field \"booleanField\" is required")
		}
		return v.VisitBooleanFieldWithContext(ctx, *u.booleanField)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatchWithContext(ctx, *u.exactMatch)
	case "stringArrayExactMatch":
		if u.stringArrayExactMatch == nil {
			return fmt.Errorf("field \"stringArrayExactMatch\" is required")
		}
		return v.VisitStringArrayExactMatchWithContext(ctx, *u.stringArrayExactMatch)
	case "stringArrayLength":
		if u.stringArrayLength == nil {
			return fmt.Errorf("field \"stringArrayLength\" is required")
		}
		return v.VisitStringArrayLengthWithContext(ctx, *u.stringArrayLength)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabelWithContext(ctx, *u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	case "createdAt":
		if u.createdAt == nil {
			return fmt.Errorf("field \"createdAt\" is required")
		}
		return v.VisitCreatedAtWithContext(ctx, *u.createdAt)
	case "archivedStatus":
		if u.archivedStatus == nil {
			return fmt.Errorf("field \"archivedStatus\" is required")
		}
		return v.VisitArchivedStatusWithContext(ctx, *u.archivedStatus)
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
		return v.VisitIsPublishedWithContext(ctx, *u.isPublished)
	}
}

type SearchQueryVisitorWithContext interface {
	VisitDateTimeFieldWithContext(ctx context.Context, v api.DateTimeField) error
	VisitStringFieldWithContext(ctx context.Context, v api.StringField) error
	VisitTimestampFieldWithContext(ctx context.Context, v api.TimestampField) error
	VisitLongFieldWithContext(ctx context.Context, v api.LongField) error
	VisitBooleanFieldWithContext(ctx context.Context, v api.BooleanField) error
	VisitExactMatchWithContext(ctx context.Context, v string) error
	VisitStringArrayExactMatchWithContext(ctx context.Context, v api.StringArrayField) error
	VisitStringArrayLengthWithContext(ctx context.Context, v metadata.StringArrayLengthQuery) error
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitLabelWithContext(ctx context.Context, v api1.Label) error
	VisitPropertyWithContext(ctx context.Context, v api1.Property) error
	VisitAndWithContext(ctx context.Context, v []SearchQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchQuery) error
	VisitNotWithContext(ctx context.Context, v SearchQuery) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitCreatedAtWithContext(ctx context.Context, v metadata.CreatedAtQuery) error
	VisitArchivedStatusWithContext(ctx context.Context, v api1.ArchivedStatus) error
	VisitIsPublishedWithContext(ctx context.Context, v bool) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchQueryFromDateTimeField(v api.DateTimeField) SearchQuery {
	return SearchQuery{typ: "dateTimeField", dateTimeField: &v}
}

func NewSearchQueryFromStringField(v api.StringField) SearchQuery {
	return SearchQuery{typ: "stringField", stringField: &v}
}

func NewSearchQueryFromTimestampField(v api.TimestampField) SearchQuery {
	return SearchQuery{typ: "timestampField", timestampField: &v}
}

func NewSearchQueryFromLongField(v api.LongField) SearchQuery {
	return SearchQuery{typ: "longField", longField: &v}
}

func NewSearchQueryFromBooleanField(v api.BooleanField) SearchQuery {
	return SearchQuery{typ: "booleanField", booleanField: &v}
}

func NewSearchQueryFromExactMatch(v string) SearchQuery {
	return SearchQuery{typ: "exactMatch", exactMatch: &v}
}

func NewSearchQueryFromStringArrayExactMatch(v api.StringArrayField) SearchQuery {
	return SearchQuery{typ: "stringArrayExactMatch", stringArrayExactMatch: &v}
}

func NewSearchQueryFromStringArrayLength(v metadata.StringArrayLengthQuery) SearchQuery {
	return SearchQuery{typ: "stringArrayLength", stringArrayLength: &v}
}

func NewSearchQueryFromSearchText(v string) SearchQuery {
	return SearchQuery{typ: "searchText", searchText: &v}
}

func NewSearchQueryFromLabel(v api1.Label) SearchQuery {
	return SearchQuery{typ: "label", label: &v}
}

func NewSearchQueryFromProperty(v api1.Property) SearchQuery {
	return SearchQuery{typ: "property", property: &v}
}

func NewSearchQueryFromAnd(v []SearchQuery) SearchQuery {
	return SearchQuery{typ: "and", and: &v}
}

func NewSearchQueryFromOr(v []SearchQuery) SearchQuery {
	return SearchQuery{typ: "or", or: &v}
}

func NewSearchQueryFromNot(v SearchQuery) SearchQuery {
	return SearchQuery{typ: "not", not: &v}
}

func NewSearchQueryFromWorkspace(v rids.WorkspaceRid) SearchQuery {
	return SearchQuery{typ: "workspace", workspace: &v}
}

func NewSearchQueryFromCreatedAt(v metadata.CreatedAtQuery) SearchQuery {
	return SearchQuery{typ: "createdAt", createdAt: &v}
}

func NewSearchQueryFromArchivedStatus(v api1.ArchivedStatus) SearchQuery {
	return SearchQuery{typ: "archivedStatus", archivedStatus: &v}
}

func NewSearchQueryFromIsPublished(v bool) SearchQuery {
	return SearchQuery{typ: "isPublished", isPublished: &v}
}
