// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api1

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/scout/checks/api"
)

type JobResultWithT[T any] JobResult

func (u *JobResultWithT[T]) Accept(ctx context.Context, v JobResultVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "checkJobResult":
		if u.checkJobResult == nil {
			return result, fmt.Errorf("field \"checkJobResult\" is required")
		}
		return v.VisitCheckJobResult(ctx, *u.checkJobResult)
	}
}

func (u *JobResultWithT[T]) AcceptFuncs(checkJobResultFunc func(CheckJobResult) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "checkJobResult":
		if u.checkJobResult == nil {
			return result, fmt.Errorf("field \"checkJobResult\" is required")
		}
		return checkJobResultFunc(*u.checkJobResult)
	}
}

func (u *JobResultWithT[T]) CheckJobResultNoopSuccess(CheckJobResult) (T, error) {
	var result T
	return result, nil
}

func (u *JobResultWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type JobResultVisitorWithT[T any] interface {
	VisitCheckJobResult(ctx context.Context, v CheckJobResult) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type JobStatusWithT[T any] JobStatus

func (u *JobStatusWithT[T]) Accept(ctx context.Context, v JobStatusVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgress(ctx, *u.inProgress)
	case "completed":
		if u.completed == nil {
			return result, fmt.Errorf("field \"completed\" is required")
		}
		return v.VisitCompleted(ctx, *u.completed)
	case "failed":
		if u.failed == nil {
			return result, fmt.Errorf("field \"failed\" is required")
		}
		return v.VisitFailed(ctx, *u.failed)
	}
}

func (u *JobStatusWithT[T]) AcceptFuncs(inProgressFunc func(api.InProgress) (T, error), completedFunc func(Completed) (T, error), failedFunc func(api.Failed) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return inProgressFunc(*u.inProgress)
	case "completed":
		if u.completed == nil {
			return result, fmt.Errorf("field \"completed\" is required")
		}
		return completedFunc(*u.completed)
	case "failed":
		if u.failed == nil {
			return result, fmt.Errorf("field \"failed\" is required")
		}
		return failedFunc(*u.failed)
	}
}

func (u *JobStatusWithT[T]) InProgressNoopSuccess(api.InProgress) (T, error) {
	var result T
	return result, nil
}

func (u *JobStatusWithT[T]) CompletedNoopSuccess(Completed) (T, error) {
	var result T
	return result, nil
}

func (u *JobStatusWithT[T]) FailedNoopSuccess(api.Failed) (T, error) {
	var result T
	return result, nil
}

func (u *JobStatusWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type JobStatusVisitorWithT[T any] interface {
	VisitInProgress(ctx context.Context, v api.InProgress) (T, error)
	VisitCompleted(ctx context.Context, v Completed) (T, error)
	VisitFailed(ctx context.Context, v api.Failed) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
