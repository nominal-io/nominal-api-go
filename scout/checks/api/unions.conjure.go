// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api3 "github.com/nominal-io/nominal-api-go/scout/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/compute/api"
	api11 "github.com/nominal-io/nominal-api-go/scout/compute/api1"
	api1 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type CheckCondition struct {
	typ                      string
	numRanges                *NumRangesConditionV1
	numRangesV2              *NumRangesConditionV2
	numRangesV3              *NumRangesConditionV3
	parameterizedNumRangesV1 *ParameterizedNumRangesConditionV1
}

type checkConditionDeserializer struct {
	Type                     string                             `json:"type"`
	NumRanges                *NumRangesConditionV1              `json:"numRanges"`
	NumRangesV2              *NumRangesConditionV2              `json:"numRangesV2"`
	NumRangesV3              *NumRangesConditionV3              `json:"numRangesV3"`
	ParameterizedNumRangesV1 *ParameterizedNumRangesConditionV1 `json:"parameterizedNumRangesV1"`
}

func (u *checkConditionDeserializer) toStruct() CheckCondition {
	return CheckCondition{typ: u.Type, numRanges: u.NumRanges, numRangesV2: u.NumRangesV2, numRangesV3: u.NumRangesV3, parameterizedNumRangesV1: u.ParameterizedNumRangesV1}
}

func (u *CheckCondition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numRanges":
		if u.numRanges == nil {
			return nil, fmt.Errorf("field \"numRanges\" is required")
		}
		return struct {
			Type      string               `json:"type"`
			NumRanges NumRangesConditionV1 `json:"numRanges"`
		}{Type: "numRanges", NumRanges: *u.numRanges}, nil
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return nil, fmt.Errorf("field \"numRangesV2\" is required")
		}
		return struct {
			Type        string               `json:"type"`
			NumRangesV2 NumRangesConditionV2 `json:"numRangesV2"`
		}{Type: "numRangesV2", NumRangesV2: *u.numRangesV2}, nil
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return nil, fmt.Errorf("field \"numRangesV3\" is required")
		}
		return struct {
			Type        string               `json:"type"`
			NumRangesV3 NumRangesConditionV3 `json:"numRangesV3"`
		}{Type: "numRangesV3", NumRangesV3: *u.numRangesV3}, nil
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return nil, fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return struct {
			Type                     string                            `json:"type"`
			ParameterizedNumRangesV1 ParameterizedNumRangesConditionV1 `json:"parameterizedNumRangesV1"`
		}{Type: "parameterizedNumRangesV1", ParameterizedNumRangesV1: *u.parameterizedNumRangesV1}, nil
	}
}

func (u CheckCondition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CheckCondition) UnmarshalJSON(data []byte) error {
	var deser checkConditionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numRanges":
		if u.numRanges == nil {
			return fmt.Errorf("field \"numRanges\" is required")
		}
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return fmt.Errorf("field \"numRangesV2\" is required")
		}
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return fmt.Errorf("field \"numRangesV3\" is required")
		}
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
	}
	return nil
}

func (u CheckCondition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CheckCondition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CheckCondition) AcceptFuncs(numRangesFunc func(NumRangesConditionV1) error, numRangesV2Func func(NumRangesConditionV2) error, numRangesV3Func func(NumRangesConditionV3) error, parameterizedNumRangesV1Func func(ParameterizedNumRangesConditionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numRanges":
		if u.numRanges == nil {
			return fmt.Errorf("field \"numRanges\" is required")
		}
		return numRangesFunc(*u.numRanges)
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return fmt.Errorf("field \"numRangesV2\" is required")
		}
		return numRangesV2Func(*u.numRangesV2)
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return fmt.Errorf("field \"numRangesV3\" is required")
		}
		return numRangesV3Func(*u.numRangesV3)
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return parameterizedNumRangesV1Func(*u.parameterizedNumRangesV1)
	}
}

func (u *CheckCondition) NumRangesNoopSuccess(NumRangesConditionV1) error {
	return nil
}

func (u *CheckCondition) NumRangesV2NoopSuccess(NumRangesConditionV2) error {
	return nil
}

func (u *CheckCondition) NumRangesV3NoopSuccess(NumRangesConditionV3) error {
	return nil
}

func (u *CheckCondition) ParameterizedNumRangesV1NoopSuccess(ParameterizedNumRangesConditionV1) error {
	return nil
}

func (u *CheckCondition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CheckCondition) Accept(v CheckConditionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numRanges":
		if u.numRanges == nil {
			return fmt.Errorf("field \"numRanges\" is required")
		}
		return v.VisitNumRanges(*u.numRanges)
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return fmt.Errorf("field \"numRangesV2\" is required")
		}
		return v.VisitNumRangesV2(*u.numRangesV2)
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return fmt.Errorf("field \"numRangesV3\" is required")
		}
		return v.VisitNumRangesV3(*u.numRangesV3)
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return v.VisitParameterizedNumRangesV1(*u.parameterizedNumRangesV1)
	}
}

type CheckConditionVisitor interface {
	VisitNumRanges(v NumRangesConditionV1) error
	VisitNumRangesV2(v NumRangesConditionV2) error
	VisitNumRangesV3(v NumRangesConditionV3) error
	VisitParameterizedNumRangesV1(v ParameterizedNumRangesConditionV1) error
	VisitUnknown(typeName string) error
}

func (u *CheckCondition) AcceptWithContext(ctx context.Context, v CheckConditionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numRanges":
		if u.numRanges == nil {
			return fmt.Errorf("field \"numRanges\" is required")
		}
		return v.VisitNumRangesWithContext(ctx, *u.numRanges)
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return fmt.Errorf("field \"numRangesV2\" is required")
		}
		return v.VisitNumRangesV2WithContext(ctx, *u.numRangesV2)
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return fmt.Errorf("field \"numRangesV3\" is required")
		}
		return v.VisitNumRangesV3WithContext(ctx, *u.numRangesV3)
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return v.VisitParameterizedNumRangesV1WithContext(ctx, *u.parameterizedNumRangesV1)
	}
}

type CheckConditionVisitorWithContext interface {
	VisitNumRangesWithContext(ctx context.Context, v NumRangesConditionV1) error
	VisitNumRangesV2WithContext(ctx context.Context, v NumRangesConditionV2) error
	VisitNumRangesV3WithContext(ctx context.Context, v NumRangesConditionV3) error
	VisitParameterizedNumRangesV1WithContext(ctx context.Context, v ParameterizedNumRangesConditionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCheckConditionFromNumRanges(v NumRangesConditionV1) CheckCondition {
	return CheckCondition{typ: "numRanges", numRanges: &v}
}

func NewCheckConditionFromNumRangesV2(v NumRangesConditionV2) CheckCondition {
	return CheckCondition{typ: "numRangesV2", numRangesV2: &v}
}

func NewCheckConditionFromNumRangesV3(v NumRangesConditionV3) CheckCondition {
	return CheckCondition{typ: "numRangesV3", numRangesV3: &v}
}

func NewCheckConditionFromParameterizedNumRangesV1(v ParameterizedNumRangesConditionV1) CheckCondition {
	return CheckCondition{typ: "parameterizedNumRangesV1", parameterizedNumRangesV1: &v}
}

type ChecklistEntry struct {
	typ   string
	check *Check
}

type checklistEntryDeserializer struct {
	Type  string `json:"type"`
	Check *Check `json:"check"`
}

func (u *checklistEntryDeserializer) toStruct() ChecklistEntry {
	return ChecklistEntry{typ: u.Type, check: u.Check}
}

func (u *ChecklistEntry) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "check":
		if u.check == nil {
			return nil, fmt.Errorf("field \"check\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Check Check  `json:"check"`
		}{Type: "check", Check: *u.check}, nil
	}
}

func (u ChecklistEntry) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ChecklistEntry) UnmarshalJSON(data []byte) error {
	var deser checklistEntryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
	}
	return nil
}

func (u ChecklistEntry) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ChecklistEntry) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ChecklistEntry) AcceptFuncs(checkFunc func(Check) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
		return checkFunc(*u.check)
	}
}

func (u *ChecklistEntry) CheckNoopSuccess(Check) error {
	return nil
}

func (u *ChecklistEntry) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ChecklistEntry) Accept(v ChecklistEntryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
		return v.VisitCheck(*u.check)
	}
}

type ChecklistEntryVisitor interface {
	VisitCheck(v Check) error
	VisitUnknown(typeName string) error
}

func (u *ChecklistEntry) AcceptWithContext(ctx context.Context, v ChecklistEntryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
		return v.VisitCheckWithContext(ctx, *u.check)
	}
}

type ChecklistEntryVisitorWithContext interface {
	VisitCheckWithContext(ctx context.Context, v Check) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewChecklistEntryFromCheck(v Check) ChecklistEntry {
	return ChecklistEntry{typ: "check", check: &v}
}

type ChecklistSearchQuery struct {
	typ                 string
	and                 *[]ChecklistSearchQuery
	or                  *[]ChecklistSearchQuery
	searchText          *string
	label               *api.Label
	labels              *api1.LabelsFilter
	property            *api.Property
	properties          *api1.PropertiesFilter
	authorRid           *api1.UserRid
	assigneeRid         *api1.UserRid
	isPublished         *bool
	not                 *ChecklistSearchQuery
	workspace           *rids.WorkspaceRid
	authorIsCurrentUser *bool
	authorRids          *[]api1.UserRid
	isArchived          *bool
}

type checklistSearchQueryDeserializer struct {
	Type                string                  `json:"type"`
	And                 *[]ChecklistSearchQuery `json:"and"`
	Or                  *[]ChecklistSearchQuery `json:"or"`
	SearchText          *string                 `json:"searchText"`
	Label               *api.Label              `json:"label"`
	Labels              *api1.LabelsFilter      `json:"labels"`
	Property            *api.Property           `json:"property"`
	Properties          *api1.PropertiesFilter  `json:"properties"`
	AuthorRid           *api1.UserRid           `json:"authorRid"`
	AssigneeRid         *api1.UserRid           `json:"assigneeRid"`
	IsPublished         *bool                   `json:"isPublished"`
	Not                 *ChecklistSearchQuery   `json:"not"`
	Workspace           *rids.WorkspaceRid      `json:"workspace"`
	AuthorIsCurrentUser *bool                   `json:"authorIsCurrentUser"`
	AuthorRids          *[]api1.UserRid         `json:"authorRids"`
	IsArchived          *bool                   `json:"isArchived"`
}

func (u *checklistSearchQueryDeserializer) toStruct() ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: u.Type, and: u.And, or: u.Or, searchText: u.SearchText, label: u.Label, labels: u.Labels, property: u.Property, properties: u.Properties, authorRid: u.AuthorRid, assigneeRid: u.AssigneeRid, isPublished: u.IsPublished, not: u.Not, workspace: u.Workspace, authorIsCurrentUser: u.AuthorIsCurrentUser, authorRids: u.AuthorRids, isArchived: u.IsArchived}
}

func (u *ChecklistSearchQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string                 `json:"type"`
			And  []ChecklistSearchQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string                 `json:"type"`
			Or   []ChecklistSearchQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "label":
		if u.label == nil {
			return nil, fmt.Errorf("field \"label\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Label api.Label `json:"label"`
		}{Type: "label", Label: *u.label}, nil
	case "labels":
		if u.labels == nil {
			return nil, fmt.Errorf("field \"labels\" is required")
		}
		return struct {
			Type   string            `json:"type"`
			Labels api1.LabelsFilter `json:"labels"`
		}{Type: "labels", Labels: *u.labels}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Property api.Property `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "properties":
		if u.properties == nil {
			return nil, fmt.Errorf("field \"properties\" is required")
		}
		return struct {
			Type       string                `json:"type"`
			Properties api1.PropertiesFilter `json:"properties"`
		}{Type: "properties", Properties: *u.properties}, nil
	case "authorRid":
		if u.authorRid == nil {
			return nil, fmt.Errorf("field \"authorRid\" is required")
		}
		return struct {
			Type      string       `json:"type"`
			AuthorRid api1.UserRid `json:"authorRid"`
		}{Type: "authorRid", AuthorRid: *u.authorRid}, nil
	case "assigneeRid":
		if u.assigneeRid == nil {
			return nil, fmt.Errorf("field \"assigneeRid\" is required")
		}
		return struct {
			Type        string       `json:"type"`
			AssigneeRid api1.UserRid `json:"assigneeRid"`
		}{Type: "assigneeRid", AssigneeRid: *u.assigneeRid}, nil
	case "isPublished":
		if u.isPublished == nil {
			return nil, fmt.Errorf("field \"isPublished\" is required")
		}
		return struct {
			Type        string `json:"type"`
			IsPublished bool   `json:"isPublished"`
		}{Type: "isPublished", IsPublished: *u.isPublished}, nil
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Not  ChecklistSearchQuery `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	case "authorIsCurrentUser":
		if u.authorIsCurrentUser == nil {
			return nil, fmt.Errorf("field \"authorIsCurrentUser\" is required")
		}
		return struct {
			Type                string `json:"type"`
			AuthorIsCurrentUser bool   `json:"authorIsCurrentUser"`
		}{Type: "authorIsCurrentUser", AuthorIsCurrentUser: *u.authorIsCurrentUser}, nil
	case "authorRids":
		if u.authorRids == nil {
			return nil, fmt.Errorf("field \"authorRids\" is required")
		}
		return struct {
			Type       string         `json:"type"`
			AuthorRids []api1.UserRid `json:"authorRids"`
		}{Type: "authorRids", AuthorRids: *u.authorRids}, nil
	case "isArchived":
		if u.isArchived == nil {
			return nil, fmt.Errorf("field \"isArchived\" is required")
		}
		return struct {
			Type       string `json:"type"`
			IsArchived bool   `json:"isArchived"`
		}{Type: "isArchived", IsArchived: *u.isArchived}, nil
	}
}

func (u ChecklistSearchQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ChecklistSearchQuery) UnmarshalJSON(data []byte) error {
	var deser checklistSearchQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
	case "labels":
		if u.labels == nil {
			return fmt.Errorf("field \"labels\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
	case "authorRid":
		if u.authorRid == nil {
			return fmt.Errorf("field \"authorRid\" is required")
		}
	case "assigneeRid":
		if u.assigneeRid == nil {
			return fmt.Errorf("field \"assigneeRid\" is required")
		}
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	case "authorIsCurrentUser":
		if u.authorIsCurrentUser == nil {
			return fmt.Errorf("field \"authorIsCurrentUser\" is required")
		}
	case "authorRids":
		if u.authorRids == nil {
			return fmt.Errorf("field \"authorRids\" is required")
		}
	case "isArchived":
		if u.isArchived == nil {
			return fmt.Errorf("field \"isArchived\" is required")
		}
	}
	return nil
}

func (u ChecklistSearchQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ChecklistSearchQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ChecklistSearchQuery) AcceptFuncs(andFunc func([]ChecklistSearchQuery) error, orFunc func([]ChecklistSearchQuery) error, searchTextFunc func(string) error, labelFunc func(api.Label) error, labelsFunc func(api1.LabelsFilter) error, propertyFunc func(api.Property) error, propertiesFunc func(api1.PropertiesFilter) error, authorRidFunc func(api1.UserRid) error, assigneeRidFunc func(api1.UserRid) error, isPublishedFunc func(bool) error, notFunc func(ChecklistSearchQuery) error, workspaceFunc func(rids.WorkspaceRid) error, authorIsCurrentUserFunc func(bool) error, authorRidsFunc func([]api1.UserRid) error, isArchivedFunc func(bool) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "labels":
		if u.labels == nil {
			return fmt.Errorf("field \"labels\" is required")
		}
		return labelsFunc(*u.labels)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
		return propertiesFunc(*u.properties)
	case "authorRid":
		if u.authorRid == nil {
			return fmt.Errorf("field \"authorRid\" is required")
		}
		return authorRidFunc(*u.authorRid)
	case "assigneeRid":
		if u.assigneeRid == nil {
			return fmt.Errorf("field \"assigneeRid\" is required")
		}
		return assigneeRidFunc(*u.assigneeRid)
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
		return isPublishedFunc(*u.isPublished)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	case "authorIsCurrentUser":
		if u.authorIsCurrentUser == nil {
			return fmt.Errorf("field \"authorIsCurrentUser\" is required")
		}
		return authorIsCurrentUserFunc(*u.authorIsCurrentUser)
	case "authorRids":
		if u.authorRids == nil {
			return fmt.Errorf("field \"authorRids\" is required")
		}
		return authorRidsFunc(*u.authorRids)
	case "isArchived":
		if u.isArchived == nil {
			return fmt.Errorf("field \"isArchived\" is required")
		}
		return isArchivedFunc(*u.isArchived)
	}
}

func (u *ChecklistSearchQuery) AndNoopSuccess([]ChecklistSearchQuery) error {
	return nil
}

func (u *ChecklistSearchQuery) OrNoopSuccess([]ChecklistSearchQuery) error {
	return nil
}

func (u *ChecklistSearchQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *ChecklistSearchQuery) LabelNoopSuccess(api.Label) error {
	return nil
}

func (u *ChecklistSearchQuery) LabelsNoopSuccess(api1.LabelsFilter) error {
	return nil
}

func (u *ChecklistSearchQuery) PropertyNoopSuccess(api.Property) error {
	return nil
}

func (u *ChecklistSearchQuery) PropertiesNoopSuccess(api1.PropertiesFilter) error {
	return nil
}

func (u *ChecklistSearchQuery) AuthorRidNoopSuccess(api1.UserRid) error {
	return nil
}

func (u *ChecklistSearchQuery) AssigneeRidNoopSuccess(api1.UserRid) error {
	return nil
}

func (u *ChecklistSearchQuery) IsPublishedNoopSuccess(bool) error {
	return nil
}

func (u *ChecklistSearchQuery) NotNoopSuccess(ChecklistSearchQuery) error {
	return nil
}

func (u *ChecklistSearchQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *ChecklistSearchQuery) AuthorIsCurrentUserNoopSuccess(bool) error {
	return nil
}

func (u *ChecklistSearchQuery) AuthorRidsNoopSuccess([]api1.UserRid) error {
	return nil
}

func (u *ChecklistSearchQuery) IsArchivedNoopSuccess(bool) error {
	return nil
}

func (u *ChecklistSearchQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ChecklistSearchQuery) Accept(v ChecklistSearchQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(*u.label)
	case "labels":
		if u.labels == nil {
			return fmt.Errorf("field \"labels\" is required")
		}
		return v.VisitLabels(*u.labels)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
		return v.VisitProperties(*u.properties)
	case "authorRid":
		if u.authorRid == nil {
			return fmt.Errorf("field \"authorRid\" is required")
		}
		return v.VisitAuthorRid(*u.authorRid)
	case "assigneeRid":
		if u.assigneeRid == nil {
			return fmt.Errorf("field \"assigneeRid\" is required")
		}
		return v.VisitAssigneeRid(*u.assigneeRid)
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
		return v.VisitIsPublished(*u.isPublished)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	case "authorIsCurrentUser":
		if u.authorIsCurrentUser == nil {
			return fmt.Errorf("field \"authorIsCurrentUser\" is required")
		}
		return v.VisitAuthorIsCurrentUser(*u.authorIsCurrentUser)
	case "authorRids":
		if u.authorRids == nil {
			return fmt.Errorf("field \"authorRids\" is required")
		}
		return v.VisitAuthorRids(*u.authorRids)
	case "isArchived":
		if u.isArchived == nil {
			return fmt.Errorf("field \"isArchived\" is required")
		}
		return v.VisitIsArchived(*u.isArchived)
	}
}

type ChecklistSearchQueryVisitor interface {
	VisitAnd(v []ChecklistSearchQuery) error
	VisitOr(v []ChecklistSearchQuery) error
	VisitSearchText(v string) error
	VisitLabel(v api.Label) error
	VisitLabels(v api1.LabelsFilter) error
	VisitProperty(v api.Property) error
	VisitProperties(v api1.PropertiesFilter) error
	VisitAuthorRid(v api1.UserRid) error
	VisitAssigneeRid(v api1.UserRid) error
	VisitIsPublished(v bool) error
	VisitNot(v ChecklistSearchQuery) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitAuthorIsCurrentUser(v bool) error
	VisitAuthorRids(v []api1.UserRid) error
	VisitIsArchived(v bool) error
	VisitUnknown(typeName string) error
}

func (u *ChecklistSearchQuery) AcceptWithContext(ctx context.Context, v ChecklistSearchQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabelWithContext(ctx, *u.label)
	case "labels":
		if u.labels == nil {
			return fmt.Errorf("field \"labels\" is required")
		}
		return v.VisitLabelsWithContext(ctx, *u.labels)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
		return v.VisitPropertiesWithContext(ctx, *u.properties)
	case "authorRid":
		if u.authorRid == nil {
			return fmt.Errorf("field \"authorRid\" is required")
		}
		return v.VisitAuthorRidWithContext(ctx, *u.authorRid)
	case "assigneeRid":
		if u.assigneeRid == nil {
			return fmt.Errorf("field \"assigneeRid\" is required")
		}
		return v.VisitAssigneeRidWithContext(ctx, *u.assigneeRid)
	case "isPublished":
		if u.isPublished == nil {
			return fmt.Errorf("field \"isPublished\" is required")
		}
		return v.VisitIsPublishedWithContext(ctx, *u.isPublished)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	case "authorIsCurrentUser":
		if u.authorIsCurrentUser == nil {
			return fmt.Errorf("field \"authorIsCurrentUser\" is required")
		}
		return v.VisitAuthorIsCurrentUserWithContext(ctx, *u.authorIsCurrentUser)
	case "authorRids":
		if u.authorRids == nil {
			return fmt.Errorf("field \"authorRids\" is required")
		}
		return v.VisitAuthorRidsWithContext(ctx, *u.authorRids)
	case "isArchived":
		if u.isArchived == nil {
			return fmt.Errorf("field \"isArchived\" is required")
		}
		return v.VisitIsArchivedWithContext(ctx, *u.isArchived)
	}
}

type ChecklistSearchQueryVisitorWithContext interface {
	VisitAndWithContext(ctx context.Context, v []ChecklistSearchQuery) error
	VisitOrWithContext(ctx context.Context, v []ChecklistSearchQuery) error
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitLabelWithContext(ctx context.Context, v api.Label) error
	VisitLabelsWithContext(ctx context.Context, v api1.LabelsFilter) error
	VisitPropertyWithContext(ctx context.Context, v api.Property) error
	VisitPropertiesWithContext(ctx context.Context, v api1.PropertiesFilter) error
	VisitAuthorRidWithContext(ctx context.Context, v api1.UserRid) error
	VisitAssigneeRidWithContext(ctx context.Context, v api1.UserRid) error
	VisitIsPublishedWithContext(ctx context.Context, v bool) error
	VisitNotWithContext(ctx context.Context, v ChecklistSearchQuery) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitAuthorIsCurrentUserWithContext(ctx context.Context, v bool) error
	VisitAuthorRidsWithContext(ctx context.Context, v []api1.UserRid) error
	VisitIsArchivedWithContext(ctx context.Context, v bool) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewChecklistSearchQueryFromAnd(v []ChecklistSearchQuery) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "and", and: &v}
}

func NewChecklistSearchQueryFromOr(v []ChecklistSearchQuery) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "or", or: &v}
}

func NewChecklistSearchQueryFromSearchText(v string) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "searchText", searchText: &v}
}

func NewChecklistSearchQueryFromLabel(v api.Label) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "label", label: &v}
}

func NewChecklistSearchQueryFromLabels(v api1.LabelsFilter) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "labels", labels: &v}
}

func NewChecklistSearchQueryFromProperty(v api.Property) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "property", property: &v}
}

func NewChecklistSearchQueryFromProperties(v api1.PropertiesFilter) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "properties", properties: &v}
}

func NewChecklistSearchQueryFromAuthorRid(v api1.UserRid) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "authorRid", authorRid: &v}
}

func NewChecklistSearchQueryFromAssigneeRid(v api1.UserRid) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "assigneeRid", assigneeRid: &v}
}

func NewChecklistSearchQueryFromIsPublished(v bool) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "isPublished", isPublished: &v}
}

func NewChecklistSearchQueryFromNot(v ChecklistSearchQuery) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "not", not: &v}
}

func NewChecklistSearchQueryFromWorkspace(v rids.WorkspaceRid) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "workspace", workspace: &v}
}

func NewChecklistSearchQueryFromAuthorIsCurrentUser(v bool) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "authorIsCurrentUser", authorIsCurrentUser: &v}
}

func NewChecklistSearchQueryFromAuthorRids(v []api1.UserRid) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "authorRids", authorRids: &v}
}

func NewChecklistSearchQueryFromIsArchived(v bool) ChecklistSearchQuery {
	return ChecklistSearchQuery{typ: "isArchived", isArchived: &v}
}

type CreateChecklistEntryRequest struct {
	typ         string
	createCheck *CreateCheckRequest
}

type createChecklistEntryRequestDeserializer struct {
	Type        string              `json:"type"`
	CreateCheck *CreateCheckRequest `json:"createCheck"`
}

func (u *createChecklistEntryRequestDeserializer) toStruct() CreateChecklistEntryRequest {
	return CreateChecklistEntryRequest{typ: u.Type, createCheck: u.CreateCheck}
}

func (u *CreateChecklistEntryRequest) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return nil, fmt.Errorf("field \"createCheck\" is required")
		}
		return struct {
			Type        string             `json:"type"`
			CreateCheck CreateCheckRequest `json:"createCheck"`
		}{Type: "createCheck", CreateCheck: *u.createCheck}, nil
	}
}

func (u CreateChecklistEntryRequest) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CreateChecklistEntryRequest) UnmarshalJSON(data []byte) error {
	var deser createChecklistEntryRequestDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "createCheck":
		if u.createCheck == nil {
			return fmt.Errorf("field \"createCheck\" is required")
		}
	}
	return nil
}

func (u CreateChecklistEntryRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CreateChecklistEntryRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CreateChecklistEntryRequest) AcceptFuncs(createCheckFunc func(CreateCheckRequest) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return fmt.Errorf("field \"createCheck\" is required")
		}
		return createCheckFunc(*u.createCheck)
	}
}

func (u *CreateChecklistEntryRequest) CreateCheckNoopSuccess(CreateCheckRequest) error {
	return nil
}

func (u *CreateChecklistEntryRequest) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CreateChecklistEntryRequest) Accept(v CreateChecklistEntryRequestVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return fmt.Errorf("field \"createCheck\" is required")
		}
		return v.VisitCreateCheck(*u.createCheck)
	}
}

type CreateChecklistEntryRequestVisitor interface {
	VisitCreateCheck(v CreateCheckRequest) error
	VisitUnknown(typeName string) error
}

func (u *CreateChecklistEntryRequest) AcceptWithContext(ctx context.Context, v CreateChecklistEntryRequestVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return fmt.Errorf("field \"createCheck\" is required")
		}
		return v.VisitCreateCheckWithContext(ctx, *u.createCheck)
	}
}

type CreateChecklistEntryRequestVisitorWithContext interface {
	VisitCreateCheckWithContext(ctx context.Context, v CreateCheckRequest) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCreateChecklistEntryRequestFromCreateCheck(v CreateCheckRequest) CreateChecklistEntryRequest {
	return CreateChecklistEntryRequest{typ: "createCheck", createCheck: &v}
}

type FunctionNode struct {
	typ     string
	enum    *api11.EnumSeries
	numeric *api11.NumericSeries
	ranges  *api11.RangeSeries
}

type functionNodeDeserializer struct {
	Type    string               `json:"type"`
	Enum    *api11.EnumSeries    `json:"enum"`
	Numeric *api11.NumericSeries `json:"numeric"`
	Ranges  *api11.RangeSeries   `json:"ranges"`
}

func (u *functionNodeDeserializer) toStruct() FunctionNode {
	return FunctionNode{typ: u.Type, enum: u.Enum, numeric: u.Numeric, ranges: u.Ranges}
}

func (u *FunctionNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string           `json:"type"`
			Enum api11.EnumSeries `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string              `json:"type"`
			Numeric api11.NumericSeries `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "ranges":
		if u.ranges == nil {
			return nil, fmt.Errorf("field \"ranges\" is required")
		}
		return struct {
			Type   string            `json:"type"`
			Ranges api11.RangeSeries `json:"ranges"`
		}{Type: "ranges", Ranges: *u.ranges}, nil
	}
}

func (u FunctionNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FunctionNode) UnmarshalJSON(data []byte) error {
	var deser functionNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
	}
	return nil
}

func (u FunctionNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FunctionNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FunctionNode) AcceptFuncs(enumFunc func(api11.EnumSeries) error, numericFunc func(api11.NumericSeries) error, rangesFunc func(api11.RangeSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	}
}

func (u *FunctionNode) EnumNoopSuccess(api11.EnumSeries) error {
	return nil
}

func (u *FunctionNode) NumericNoopSuccess(api11.NumericSeries) error {
	return nil
}

func (u *FunctionNode) RangesNoopSuccess(api11.RangeSeries) error {
	return nil
}

func (u *FunctionNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FunctionNode) Accept(v FunctionNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(*u.ranges)
	}
}

type FunctionNodeVisitor interface {
	VisitEnum(v api11.EnumSeries) error
	VisitNumeric(v api11.NumericSeries) error
	VisitRanges(v api11.RangeSeries) error
	VisitUnknown(typeName string) error
}

func (u *FunctionNode) AcceptWithContext(ctx context.Context, v FunctionNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRangesWithContext(ctx, *u.ranges)
	}
}

type FunctionNodeVisitorWithContext interface {
	VisitEnumWithContext(ctx context.Context, v api11.EnumSeries) error
	VisitNumericWithContext(ctx context.Context, v api11.NumericSeries) error
	VisitRangesWithContext(ctx context.Context, v api11.RangeSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFunctionNodeFromEnum(v api11.EnumSeries) FunctionNode {
	return FunctionNode{typ: "enum", enum: &v}
}

func NewFunctionNodeFromNumeric(v api11.NumericSeries) FunctionNode {
	return FunctionNode{typ: "numeric", numeric: &v}
}

func NewFunctionNodeFromRanges(v api11.RangeSeries) FunctionNode {
	return FunctionNode{typ: "ranges", ranges: &v}
}

type JobSpec struct {
	typ     string
	check   *DeprecatedCheckJobSpec
	checkV2 *CheckJobSpec
}

type jobSpecDeserializer struct {
	Type    string                  `json:"type"`
	Check   *DeprecatedCheckJobSpec `json:"check"`
	CheckV2 *CheckJobSpec           `json:"checkV2"`
}

func (u *jobSpecDeserializer) toStruct() JobSpec {
	return JobSpec{typ: u.Type, check: u.Check, checkV2: u.CheckV2}
}

func (u *JobSpec) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "check":
		if u.check == nil {
			return nil, fmt.Errorf("field \"check\" is required")
		}
		return struct {
			Type  string                 `json:"type"`
			Check DeprecatedCheckJobSpec `json:"check"`
		}{Type: "check", Check: *u.check}, nil
	case "checkV2":
		if u.checkV2 == nil {
			return nil, fmt.Errorf("field \"checkV2\" is required")
		}
		return struct {
			Type    string       `json:"type"`
			CheckV2 CheckJobSpec `json:"checkV2"`
		}{Type: "checkV2", CheckV2: *u.checkV2}, nil
	}
}

func (u JobSpec) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *JobSpec) UnmarshalJSON(data []byte) error {
	var deser jobSpecDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
	case "checkV2":
		if u.checkV2 == nil {
			return fmt.Errorf("field \"checkV2\" is required")
		}
	}
	return nil
}

func (u JobSpec) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *JobSpec) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *JobSpec) AcceptFuncs(checkFunc func(DeprecatedCheckJobSpec) error, checkV2Func func(CheckJobSpec) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
		return checkFunc(*u.check)
	case "checkV2":
		if u.checkV2 == nil {
			return fmt.Errorf("field \"checkV2\" is required")
		}
		return checkV2Func(*u.checkV2)
	}
}

func (u *JobSpec) CheckNoopSuccess(DeprecatedCheckJobSpec) error {
	return nil
}

func (u *JobSpec) CheckV2NoopSuccess(CheckJobSpec) error {
	return nil
}

func (u *JobSpec) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *JobSpec) Accept(v JobSpecVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
		return v.VisitCheck(*u.check)
	case "checkV2":
		if u.checkV2 == nil {
			return fmt.Errorf("field \"checkV2\" is required")
		}
		return v.VisitCheckV2(*u.checkV2)
	}
}

type JobSpecVisitor interface {
	VisitCheck(v DeprecatedCheckJobSpec) error
	VisitCheckV2(v CheckJobSpec) error
	VisitUnknown(typeName string) error
}

func (u *JobSpec) AcceptWithContext(ctx context.Context, v JobSpecVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
		return v.VisitCheckWithContext(ctx, *u.check)
	case "checkV2":
		if u.checkV2 == nil {
			return fmt.Errorf("field \"checkV2\" is required")
		}
		return v.VisitCheckV2WithContext(ctx, *u.checkV2)
	}
}

type JobSpecVisitorWithContext interface {
	VisitCheckWithContext(ctx context.Context, v DeprecatedCheckJobSpec) error
	VisitCheckV2WithContext(ctx context.Context, v CheckJobSpec) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewJobSpecFromCheck(v DeprecatedCheckJobSpec) JobSpec {
	return JobSpec{typ: "check", check: &v}
}

func NewJobSpecFromCheckV2(v CheckJobSpec) JobSpec {
	return JobSpec{typ: "checkV2", checkV2: &v}
}

type UnresolvedCheckCondition struct {
	typ                      string
	numRangesV2              *UnresolvedNumRangesConditionV2
	numRangesV3              *UnresolvedNumRangesConditionV3
	parameterizedNumRangesV1 *UnresolvedParameterizedNumRangesConditionV1
}

type unresolvedCheckConditionDeserializer struct {
	Type                     string                                       `json:"type"`
	NumRangesV2              *UnresolvedNumRangesConditionV2              `json:"numRangesV2"`
	NumRangesV3              *UnresolvedNumRangesConditionV3              `json:"numRangesV3"`
	ParameterizedNumRangesV1 *UnresolvedParameterizedNumRangesConditionV1 `json:"parameterizedNumRangesV1"`
}

func (u *unresolvedCheckConditionDeserializer) toStruct() UnresolvedCheckCondition {
	return UnresolvedCheckCondition{typ: u.Type, numRangesV2: u.NumRangesV2, numRangesV3: u.NumRangesV3, parameterizedNumRangesV1: u.ParameterizedNumRangesV1}
}

func (u *UnresolvedCheckCondition) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return nil, fmt.Errorf("field \"numRangesV2\" is required")
		}
		return struct {
			Type        string                         `json:"type"`
			NumRangesV2 UnresolvedNumRangesConditionV2 `json:"numRangesV2"`
		}{Type: "numRangesV2", NumRangesV2: *u.numRangesV2}, nil
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return nil, fmt.Errorf("field \"numRangesV3\" is required")
		}
		return struct {
			Type        string                         `json:"type"`
			NumRangesV3 UnresolvedNumRangesConditionV3 `json:"numRangesV3"`
		}{Type: "numRangesV3", NumRangesV3: *u.numRangesV3}, nil
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return nil, fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return struct {
			Type                     string                                      `json:"type"`
			ParameterizedNumRangesV1 UnresolvedParameterizedNumRangesConditionV1 `json:"parameterizedNumRangesV1"`
		}{Type: "parameterizedNumRangesV1", ParameterizedNumRangesV1: *u.parameterizedNumRangesV1}, nil
	}
}

func (u UnresolvedCheckCondition) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UnresolvedCheckCondition) UnmarshalJSON(data []byte) error {
	var deser unresolvedCheckConditionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return fmt.Errorf("field \"numRangesV2\" is required")
		}
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return fmt.Errorf("field \"numRangesV3\" is required")
		}
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
	}
	return nil
}

func (u UnresolvedCheckCondition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UnresolvedCheckCondition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UnresolvedCheckCondition) AcceptFuncs(numRangesV2Func func(UnresolvedNumRangesConditionV2) error, numRangesV3Func func(UnresolvedNumRangesConditionV3) error, parameterizedNumRangesV1Func func(UnresolvedParameterizedNumRangesConditionV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return fmt.Errorf("field \"numRangesV2\" is required")
		}
		return numRangesV2Func(*u.numRangesV2)
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return fmt.Errorf("field \"numRangesV3\" is required")
		}
		return numRangesV3Func(*u.numRangesV3)
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return parameterizedNumRangesV1Func(*u.parameterizedNumRangesV1)
	}
}

func (u *UnresolvedCheckCondition) NumRangesV2NoopSuccess(UnresolvedNumRangesConditionV2) error {
	return nil
}

func (u *UnresolvedCheckCondition) NumRangesV3NoopSuccess(UnresolvedNumRangesConditionV3) error {
	return nil
}

func (u *UnresolvedCheckCondition) ParameterizedNumRangesV1NoopSuccess(UnresolvedParameterizedNumRangesConditionV1) error {
	return nil
}

func (u *UnresolvedCheckCondition) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UnresolvedCheckCondition) Accept(v UnresolvedCheckConditionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return fmt.Errorf("field \"numRangesV2\" is required")
		}
		return v.VisitNumRangesV2(*u.numRangesV2)
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return fmt.Errorf("field \"numRangesV3\" is required")
		}
		return v.VisitNumRangesV3(*u.numRangesV3)
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return v.VisitParameterizedNumRangesV1(*u.parameterizedNumRangesV1)
	}
}

type UnresolvedCheckConditionVisitor interface {
	VisitNumRangesV2(v UnresolvedNumRangesConditionV2) error
	VisitNumRangesV3(v UnresolvedNumRangesConditionV3) error
	VisitParameterizedNumRangesV1(v UnresolvedParameterizedNumRangesConditionV1) error
	VisitUnknown(typeName string) error
}

func (u *UnresolvedCheckCondition) AcceptWithContext(ctx context.Context, v UnresolvedCheckConditionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return fmt.Errorf("field \"numRangesV2\" is required")
		}
		return v.VisitNumRangesV2WithContext(ctx, *u.numRangesV2)
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return fmt.Errorf("field \"numRangesV3\" is required")
		}
		return v.VisitNumRangesV3WithContext(ctx, *u.numRangesV3)
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return v.VisitParameterizedNumRangesV1WithContext(ctx, *u.parameterizedNumRangesV1)
	}
}

type UnresolvedCheckConditionVisitorWithContext interface {
	VisitNumRangesV2WithContext(ctx context.Context, v UnresolvedNumRangesConditionV2) error
	VisitNumRangesV3WithContext(ctx context.Context, v UnresolvedNumRangesConditionV3) error
	VisitParameterizedNumRangesV1WithContext(ctx context.Context, v UnresolvedParameterizedNumRangesConditionV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnresolvedCheckConditionFromNumRangesV2(v UnresolvedNumRangesConditionV2) UnresolvedCheckCondition {
	return UnresolvedCheckCondition{typ: "numRangesV2", numRangesV2: &v}
}

func NewUnresolvedCheckConditionFromNumRangesV3(v UnresolvedNumRangesConditionV3) UnresolvedCheckCondition {
	return UnresolvedCheckCondition{typ: "numRangesV3", numRangesV3: &v}
}

func NewUnresolvedCheckConditionFromParameterizedNumRangesV1(v UnresolvedParameterizedNumRangesConditionV1) UnresolvedCheckCondition {
	return UnresolvedCheckCondition{typ: "parameterizedNumRangesV1", parameterizedNumRangesV1: &v}
}

type UnresolvedVariableLocator struct {
	typ               string
	checklistVariable *api2.VariableName
	computeNode       *UnresolvedComputeNodeWithContext
	series            *api3.ChannelLocator
	timestamp         *TimestampLocator
}

type unresolvedVariableLocatorDeserializer struct {
	Type              string                            `json:"type"`
	ChecklistVariable *api2.VariableName                `json:"checklistVariable"`
	ComputeNode       *UnresolvedComputeNodeWithContext `json:"computeNode"`
	Series            *api3.ChannelLocator              `json:"series"`
	Timestamp         *TimestampLocator                 `json:"timestamp"`
}

func (u *unresolvedVariableLocatorDeserializer) toStruct() UnresolvedVariableLocator {
	return UnresolvedVariableLocator{typ: u.Type, checklistVariable: u.ChecklistVariable, computeNode: u.ComputeNode, series: u.Series, timestamp: u.Timestamp}
}

func (u *UnresolvedVariableLocator) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return nil, fmt.Errorf("field \"checklistVariable\" is required")
		}
		return struct {
			Type              string            `json:"type"`
			ChecklistVariable api2.VariableName `json:"checklistVariable"`
		}{Type: "checklistVariable", ChecklistVariable: *u.checklistVariable}, nil
	case "computeNode":
		if u.computeNode == nil {
			return nil, fmt.Errorf("field \"computeNode\" is required")
		}
		return struct {
			Type        string                           `json:"type"`
			ComputeNode UnresolvedComputeNodeWithContext `json:"computeNode"`
		}{Type: "computeNode", ComputeNode: *u.computeNode}, nil
	case "series":
		if u.series == nil {
			return nil, fmt.Errorf("field \"series\" is required")
		}
		return struct {
			Type   string              `json:"type"`
			Series api3.ChannelLocator `json:"series"`
		}{Type: "series", Series: *u.series}, nil
	case "timestamp":
		if u.timestamp == nil {
			return nil, fmt.Errorf("field \"timestamp\" is required")
		}
		return struct {
			Type      string           `json:"type"`
			Timestamp TimestampLocator `json:"timestamp"`
		}{Type: "timestamp", Timestamp: *u.timestamp}, nil
	}
}

func (u UnresolvedVariableLocator) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UnresolvedVariableLocator) UnmarshalJSON(data []byte) error {
	var deser unresolvedVariableLocatorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "checklistVariable":
		if u.checklistVariable == nil {
			return fmt.Errorf("field \"checklistVariable\" is required")
		}
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
	}
	return nil
}

func (u UnresolvedVariableLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UnresolvedVariableLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UnresolvedVariableLocator) AcceptFuncs(checklistVariableFunc func(api2.VariableName) error, computeNodeFunc func(UnresolvedComputeNodeWithContext) error, seriesFunc func(api3.ChannelLocator) error, timestampFunc func(TimestampLocator) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return fmt.Errorf("field \"checklistVariable\" is required")
		}
		return checklistVariableFunc(*u.checklistVariable)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return computeNodeFunc(*u.computeNode)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return timestampFunc(*u.timestamp)
	}
}

func (u *UnresolvedVariableLocator) ChecklistVariableNoopSuccess(api2.VariableName) error {
	return nil
}

func (u *UnresolvedVariableLocator) ComputeNodeNoopSuccess(UnresolvedComputeNodeWithContext) error {
	return nil
}

func (u *UnresolvedVariableLocator) SeriesNoopSuccess(api3.ChannelLocator) error {
	return nil
}

func (u *UnresolvedVariableLocator) TimestampNoopSuccess(TimestampLocator) error {
	return nil
}

func (u *UnresolvedVariableLocator) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UnresolvedVariableLocator) Accept(v UnresolvedVariableLocatorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return fmt.Errorf("field \"checklistVariable\" is required")
		}
		return v.VisitChecklistVariable(*u.checklistVariable)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return v.VisitComputeNode(*u.computeNode)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(*u.series)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestamp(*u.timestamp)
	}
}

type UnresolvedVariableLocatorVisitor interface {
	VisitChecklistVariable(v api2.VariableName) error
	VisitComputeNode(v UnresolvedComputeNodeWithContext) error
	VisitSeries(v api3.ChannelLocator) error
	VisitTimestamp(v TimestampLocator) error
	VisitUnknown(typeName string) error
}

func (u *UnresolvedVariableLocator) AcceptWithContext(ctx context.Context, v UnresolvedVariableLocatorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return fmt.Errorf("field \"checklistVariable\" is required")
		}
		return v.VisitChecklistVariableWithContext(ctx, *u.checklistVariable)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return v.VisitComputeNodeWithContext(ctx, *u.computeNode)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeriesWithContext(ctx, *u.series)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestampWithContext(ctx, *u.timestamp)
	}
}

type UnresolvedVariableLocatorVisitorWithContext interface {
	VisitChecklistVariableWithContext(ctx context.Context, v api2.VariableName) error
	VisitComputeNodeWithContext(ctx context.Context, v UnresolvedComputeNodeWithContext) error
	VisitSeriesWithContext(ctx context.Context, v api3.ChannelLocator) error
	VisitTimestampWithContext(ctx context.Context, v TimestampLocator) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnresolvedVariableLocatorFromChecklistVariable(v api2.VariableName) UnresolvedVariableLocator {
	return UnresolvedVariableLocator{typ: "checklistVariable", checklistVariable: &v}
}

func NewUnresolvedVariableLocatorFromComputeNode(v UnresolvedComputeNodeWithContext) UnresolvedVariableLocator {
	return UnresolvedVariableLocator{typ: "computeNode", computeNode: &v}
}

func NewUnresolvedVariableLocatorFromSeries(v api3.ChannelLocator) UnresolvedVariableLocator {
	return UnresolvedVariableLocator{typ: "series", series: &v}
}

func NewUnresolvedVariableLocatorFromTimestamp(v TimestampLocator) UnresolvedVariableLocator {
	return UnresolvedVariableLocator{typ: "timestamp", timestamp: &v}
}

type UpdateChecklistEntryRequest struct {
	typ         string
	createCheck *CreateCheckRequest
	check       *api1.CheckRid
}

type updateChecklistEntryRequestDeserializer struct {
	Type        string              `json:"type"`
	CreateCheck *CreateCheckRequest `json:"createCheck"`
	Check       *api1.CheckRid      `json:"check"`
}

func (u *updateChecklistEntryRequestDeserializer) toStruct() UpdateChecklistEntryRequest {
	return UpdateChecklistEntryRequest{typ: u.Type, createCheck: u.CreateCheck, check: u.Check}
}

func (u *UpdateChecklistEntryRequest) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return nil, fmt.Errorf("field \"createCheck\" is required")
		}
		return struct {
			Type        string             `json:"type"`
			CreateCheck CreateCheckRequest `json:"createCheck"`
		}{Type: "createCheck", CreateCheck: *u.createCheck}, nil
	case "check":
		if u.check == nil {
			return nil, fmt.Errorf("field \"check\" is required")
		}
		return struct {
			Type  string        `json:"type"`
			Check api1.CheckRid `json:"check"`
		}{Type: "check", Check: *u.check}, nil
	}
}

func (u UpdateChecklistEntryRequest) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UpdateChecklistEntryRequest) UnmarshalJSON(data []byte) error {
	var deser updateChecklistEntryRequestDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "createCheck":
		if u.createCheck == nil {
			return fmt.Errorf("field \"createCheck\" is required")
		}
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
	}
	return nil
}

func (u UpdateChecklistEntryRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UpdateChecklistEntryRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UpdateChecklistEntryRequest) AcceptFuncs(createCheckFunc func(CreateCheckRequest) error, checkFunc func(api1.CheckRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return fmt.Errorf("field \"createCheck\" is required")
		}
		return createCheckFunc(*u.createCheck)
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
		return checkFunc(*u.check)
	}
}

func (u *UpdateChecklistEntryRequest) CreateCheckNoopSuccess(CreateCheckRequest) error {
	return nil
}

func (u *UpdateChecklistEntryRequest) CheckNoopSuccess(api1.CheckRid) error {
	return nil
}

func (u *UpdateChecklistEntryRequest) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UpdateChecklistEntryRequest) Accept(v UpdateChecklistEntryRequestVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return fmt.Errorf("field \"createCheck\" is required")
		}
		return v.VisitCreateCheck(*u.createCheck)
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
		return v.VisitCheck(*u.check)
	}
}

type UpdateChecklistEntryRequestVisitor interface {
	VisitCreateCheck(v CreateCheckRequest) error
	VisitCheck(v api1.CheckRid) error
	VisitUnknown(typeName string) error
}

func (u *UpdateChecklistEntryRequest) AcceptWithContext(ctx context.Context, v UpdateChecklistEntryRequestVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return fmt.Errorf("field \"createCheck\" is required")
		}
		return v.VisitCreateCheckWithContext(ctx, *u.createCheck)
	case "check":
		if u.check == nil {
			return fmt.Errorf("field \"check\" is required")
		}
		return v.VisitCheckWithContext(ctx, *u.check)
	}
}

type UpdateChecklistEntryRequestVisitorWithContext interface {
	VisitCreateCheckWithContext(ctx context.Context, v CreateCheckRequest) error
	VisitCheckWithContext(ctx context.Context, v api1.CheckRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUpdateChecklistEntryRequestFromCreateCheck(v CreateCheckRequest) UpdateChecklistEntryRequest {
	return UpdateChecklistEntryRequest{typ: "createCheck", createCheck: &v}
}

func NewUpdateChecklistEntryRequestFromCheck(v api1.CheckRid) UpdateChecklistEntryRequest {
	return UpdateChecklistEntryRequest{typ: "check", check: &v}
}

type VariableLocator struct {
	typ               string
	checklistVariable *api2.VariableName
	computeNode       *ComputeNodeWithContext
	series            *api3.ChannelLocator
	timestamp         *TimestampLocator
}

type variableLocatorDeserializer struct {
	Type              string                  `json:"type"`
	ChecklistVariable *api2.VariableName      `json:"checklistVariable"`
	ComputeNode       *ComputeNodeWithContext `json:"computeNode"`
	Series            *api3.ChannelLocator    `json:"series"`
	Timestamp         *TimestampLocator       `json:"timestamp"`
}

func (u *variableLocatorDeserializer) toStruct() VariableLocator {
	return VariableLocator{typ: u.Type, checklistVariable: u.ChecklistVariable, computeNode: u.ComputeNode, series: u.Series, timestamp: u.Timestamp}
}

func (u *VariableLocator) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return nil, fmt.Errorf("field \"checklistVariable\" is required")
		}
		return struct {
			Type              string            `json:"type"`
			ChecklistVariable api2.VariableName `json:"checklistVariable"`
		}{Type: "checklistVariable", ChecklistVariable: *u.checklistVariable}, nil
	case "computeNode":
		if u.computeNode == nil {
			return nil, fmt.Errorf("field \"computeNode\" is required")
		}
		return struct {
			Type        string                 `json:"type"`
			ComputeNode ComputeNodeWithContext `json:"computeNode"`
		}{Type: "computeNode", ComputeNode: *u.computeNode}, nil
	case "series":
		if u.series == nil {
			return nil, fmt.Errorf("field \"series\" is required")
		}
		return struct {
			Type   string              `json:"type"`
			Series api3.ChannelLocator `json:"series"`
		}{Type: "series", Series: *u.series}, nil
	case "timestamp":
		if u.timestamp == nil {
			return nil, fmt.Errorf("field \"timestamp\" is required")
		}
		return struct {
			Type      string           `json:"type"`
			Timestamp TimestampLocator `json:"timestamp"`
		}{Type: "timestamp", Timestamp: *u.timestamp}, nil
	}
}

func (u VariableLocator) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VariableLocator) UnmarshalJSON(data []byte) error {
	var deser variableLocatorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "checklistVariable":
		if u.checklistVariable == nil {
			return fmt.Errorf("field \"checklistVariable\" is required")
		}
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
	}
	return nil
}

func (u VariableLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VariableLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VariableLocator) AcceptFuncs(checklistVariableFunc func(api2.VariableName) error, computeNodeFunc func(ComputeNodeWithContext) error, seriesFunc func(api3.ChannelLocator) error, timestampFunc func(TimestampLocator) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return fmt.Errorf("field \"checklistVariable\" is required")
		}
		return checklistVariableFunc(*u.checklistVariable)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return computeNodeFunc(*u.computeNode)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return timestampFunc(*u.timestamp)
	}
}

func (u *VariableLocator) ChecklistVariableNoopSuccess(api2.VariableName) error {
	return nil
}

func (u *VariableLocator) ComputeNodeNoopSuccess(ComputeNodeWithContext) error {
	return nil
}

func (u *VariableLocator) SeriesNoopSuccess(api3.ChannelLocator) error {
	return nil
}

func (u *VariableLocator) TimestampNoopSuccess(TimestampLocator) error {
	return nil
}

func (u *VariableLocator) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VariableLocator) Accept(v VariableLocatorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return fmt.Errorf("field \"checklistVariable\" is required")
		}
		return v.VisitChecklistVariable(*u.checklistVariable)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return v.VisitComputeNode(*u.computeNode)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(*u.series)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestamp(*u.timestamp)
	}
}

type VariableLocatorVisitor interface {
	VisitChecklistVariable(v api2.VariableName) error
	VisitComputeNode(v ComputeNodeWithContext) error
	VisitSeries(v api3.ChannelLocator) error
	VisitTimestamp(v TimestampLocator) error
	VisitUnknown(typeName string) error
}

func (u *VariableLocator) AcceptWithContext(ctx context.Context, v VariableLocatorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return fmt.Errorf("field \"checklistVariable\" is required")
		}
		return v.VisitChecklistVariableWithContext(ctx, *u.checklistVariable)
	case "computeNode":
		if u.computeNode == nil {
			return fmt.Errorf("field \"computeNode\" is required")
		}
		return v.VisitComputeNodeWithContext(ctx, *u.computeNode)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeriesWithContext(ctx, *u.series)
	case "timestamp":
		if u.timestamp == nil {
			return fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestampWithContext(ctx, *u.timestamp)
	}
}

type VariableLocatorVisitorWithContext interface {
	VisitChecklistVariableWithContext(ctx context.Context, v api2.VariableName) error
	VisitComputeNodeWithContext(ctx context.Context, v ComputeNodeWithContext) error
	VisitSeriesWithContext(ctx context.Context, v api3.ChannelLocator) error
	VisitTimestampWithContext(ctx context.Context, v TimestampLocator) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVariableLocatorFromChecklistVariable(v api2.VariableName) VariableLocator {
	return VariableLocator{typ: "checklistVariable", checklistVariable: &v}
}

func NewVariableLocatorFromComputeNode(v ComputeNodeWithContext) VariableLocator {
	return VariableLocator{typ: "computeNode", computeNode: &v}
}

func NewVariableLocatorFromSeries(v api3.ChannelLocator) VariableLocator {
	return VariableLocator{typ: "series", series: &v}
}

func NewVariableLocatorFromTimestamp(v TimestampLocator) VariableLocator {
	return VariableLocator{typ: "timestamp", timestamp: &v}
}
