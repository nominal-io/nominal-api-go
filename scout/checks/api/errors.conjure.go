// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type assetsNotFound struct {
	AssetRid []api.AssetRid `json:"assetRid"`
}

func (o assetsNotFound) MarshalJSON() ([]byte, error) {
	if o.AssetRid == nil {
		o.AssetRid = make([]api.AssetRid, 0)
	}
	type _tmpassetsNotFound assetsNotFound
	return safejson.Marshal(_tmpassetsNotFound(o))
}

func (o *assetsNotFound) UnmarshalJSON(data []byte) error {
	type _tmpassetsNotFound assetsNotFound
	var rawassetsNotFound _tmpassetsNotFound
	if err := safejson.Unmarshal(data, &rawassetsNotFound); err != nil {
		return err
	}
	if rawassetsNotFound.AssetRid == nil {
		rawassetsNotFound.AssetRid = make([]api.AssetRid, 0)
	}
	*o = assetsNotFound(rawassetsNotFound)
	return nil
}

func (o assetsNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *assetsNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewAssetsNotFound returns new instance of AssetsNotFound error.
func NewAssetsNotFound(assetRidArg []api.AssetRid) *AssetsNotFound {
	return &AssetsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), assetsNotFound: assetsNotFound{AssetRid: assetRidArg}}
}

// WrapWithAssetsNotFound returns new instance of AssetsNotFound error wrapping an existing error.
func WrapWithAssetsNotFound(err error, assetRidArg []api.AssetRid) *AssetsNotFound {
	return &AssetsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, assetsNotFound: assetsNotFound{AssetRid: assetRidArg}}
}

// AssetsNotFound is an error type.
type AssetsNotFound struct {
	errorInstanceID uuid.UUID
	assetsNotFound
	cause error
	stack werror.StackTrace
}

// IsAssetsNotFound returns true if err is an instance of AssetsNotFound.
func IsAssetsNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*AssetsNotFound)
	return ok
}

func (e *AssetsNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Checks:AssetsNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *AssetsNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *AssetsNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *AssetsNotFound) Message() string {
	return "NOT_FOUND Checks:AssetsNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *AssetsNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *AssetsNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *AssetsNotFound) Name() string {
	return "Checks:AssetsNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *AssetsNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *AssetsNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"assetRid": e.AssetRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *AssetsNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"assetRid": e.AssetRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *AssetsNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *AssetsNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *AssetsNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e AssetsNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.assetsNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Checks:AssetsNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *AssetsNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters assetsNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.assetsNotFound = parameters
	return nil
}

type checkNotFound struct {
	CheckRid api.CheckRid `json:"checkRid"`
}

func (o checkNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *checkNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCheckNotFound returns new instance of CheckNotFound error.
func NewCheckNotFound(checkRidArg api.CheckRid) *CheckNotFound {
	return &CheckNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), checkNotFound: checkNotFound{CheckRid: checkRidArg}}
}

// WrapWithCheckNotFound returns new instance of CheckNotFound error wrapping an existing error.
func WrapWithCheckNotFound(err error, checkRidArg api.CheckRid) *CheckNotFound {
	return &CheckNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, checkNotFound: checkNotFound{CheckRid: checkRidArg}}
}

// CheckNotFound is an error type.
type CheckNotFound struct {
	errorInstanceID uuid.UUID
	checkNotFound
	cause error
	stack werror.StackTrace
}

// IsCheckNotFound returns true if err is an instance of CheckNotFound.
func IsCheckNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CheckNotFound)
	return ok
}

func (e *CheckNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Checks:CheckNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CheckNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CheckNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CheckNotFound) Message() string {
	return "NOT_FOUND Checks:CheckNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CheckNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CheckNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *CheckNotFound) Name() string {
	return "Checks:CheckNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CheckNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CheckNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"checkRid": e.CheckRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CheckNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"checkRid": e.CheckRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CheckNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CheckNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CheckNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CheckNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.checkNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Checks:CheckNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CheckNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters checkNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.checkNotFound = parameters
	return nil
}

type checklistNotFound struct {
	ChecklistRid api.ChecklistRid `json:"checklistRid"`
}

func (o checklistNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *checklistNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewChecklistNotFound returns new instance of ChecklistNotFound error.
func NewChecklistNotFound(checklistRidArg api.ChecklistRid) *ChecklistNotFound {
	return &ChecklistNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), checklistNotFound: checklistNotFound{ChecklistRid: checklistRidArg}}
}

// WrapWithChecklistNotFound returns new instance of ChecklistNotFound error wrapping an existing error.
func WrapWithChecklistNotFound(err error, checklistRidArg api.ChecklistRid) *ChecklistNotFound {
	return &ChecklistNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, checklistNotFound: checklistNotFound{ChecklistRid: checklistRidArg}}
}

// ChecklistNotFound is an error type.
type ChecklistNotFound struct {
	errorInstanceID uuid.UUID
	checklistNotFound
	cause error
	stack werror.StackTrace
}

// IsChecklistNotFound returns true if err is an instance of ChecklistNotFound.
func IsChecklistNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ChecklistNotFound)
	return ok
}

func (e *ChecklistNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Checks:ChecklistNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ChecklistNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ChecklistNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ChecklistNotFound) Message() string {
	return "NOT_FOUND Checks:ChecklistNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ChecklistNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ChecklistNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *ChecklistNotFound) Name() string {
	return "Checks:ChecklistNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ChecklistNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ChecklistNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"checklistRid": e.ChecklistRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ChecklistNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"checklistRid": e.ChecklistRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecklistNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ChecklistNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecklistNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ChecklistNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.checklistNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Checks:ChecklistNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ChecklistNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters checklistNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.checklistNotFound = parameters
	return nil
}

type checklistsCircularDependency struct {
	Rid api.ChecklistRid `json:"rid"`
}

func (o checklistsCircularDependency) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *checklistsCircularDependency) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewChecklistsCircularDependency returns new instance of ChecklistsCircularDependency error.
func NewChecklistsCircularDependency(ridArg api.ChecklistRid) *ChecklistsCircularDependency {
	return &ChecklistsCircularDependency{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), checklistsCircularDependency: checklistsCircularDependency{Rid: ridArg}}
}

// WrapWithChecklistsCircularDependency returns new instance of ChecklistsCircularDependency error wrapping an existing error.
func WrapWithChecklistsCircularDependency(err error, ridArg api.ChecklistRid) *ChecklistsCircularDependency {
	return &ChecklistsCircularDependency{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, checklistsCircularDependency: checklistsCircularDependency{Rid: ridArg}}
}

// ChecklistsCircularDependency is an error type.
type ChecklistsCircularDependency struct {
	errorInstanceID uuid.UUID
	checklistsCircularDependency
	cause error
	stack werror.StackTrace
}

// IsChecklistsCircularDependency returns true if err is an instance of ChecklistsCircularDependency.
func IsChecklistsCircularDependency(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ChecklistsCircularDependency)
	return ok
}

func (e *ChecklistsCircularDependency) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Checks:ChecklistsCircularDependency (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ChecklistsCircularDependency) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ChecklistsCircularDependency) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ChecklistsCircularDependency) Message() string {
	return "INVALID_ARGUMENT Checks:ChecklistsCircularDependency"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ChecklistsCircularDependency) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ChecklistsCircularDependency) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ChecklistsCircularDependency) Name() string {
	return "Checks:ChecklistsCircularDependency"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ChecklistsCircularDependency) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ChecklistsCircularDependency) Parameters() map[string]interface{} {
	return map[string]interface{}{"rid": e.Rid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ChecklistsCircularDependency) safeParams() map[string]interface{} {
	return map[string]interface{}{"rid": e.Rid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecklistsCircularDependency) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ChecklistsCircularDependency) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecklistsCircularDependency) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ChecklistsCircularDependency) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.checklistsCircularDependency)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Checks:ChecklistsCircularDependency", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ChecklistsCircularDependency) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters checklistsCircularDependency
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.checklistsCircularDependency = parameters
	return nil
}

type checklistsExceededMaxDepth struct{}

func (o checklistsExceededMaxDepth) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *checklistsExceededMaxDepth) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewChecklistsExceededMaxDepth returns new instance of ChecklistsExceededMaxDepth error.
func NewChecklistsExceededMaxDepth() *ChecklistsExceededMaxDepth {
	return &ChecklistsExceededMaxDepth{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), checklistsExceededMaxDepth: checklistsExceededMaxDepth{}}
}

// WrapWithChecklistsExceededMaxDepth returns new instance of ChecklistsExceededMaxDepth error wrapping an existing error.
func WrapWithChecklistsExceededMaxDepth(err error) *ChecklistsExceededMaxDepth {
	return &ChecklistsExceededMaxDepth{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, checklistsExceededMaxDepth: checklistsExceededMaxDepth{}}
}

// ChecklistsExceededMaxDepth is an error type.
type ChecklistsExceededMaxDepth struct {
	errorInstanceID uuid.UUID
	checklistsExceededMaxDepth
	cause error
	stack werror.StackTrace
}

// IsChecklistsExceededMaxDepth returns true if err is an instance of ChecklistsExceededMaxDepth.
func IsChecklistsExceededMaxDepth(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ChecklistsExceededMaxDepth)
	return ok
}

func (e *ChecklistsExceededMaxDepth) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Checks:ChecklistsExceededMaxDepth (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ChecklistsExceededMaxDepth) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ChecklistsExceededMaxDepth) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ChecklistsExceededMaxDepth) Message() string {
	return "INVALID_ARGUMENT Checks:ChecklistsExceededMaxDepth"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ChecklistsExceededMaxDepth) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ChecklistsExceededMaxDepth) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ChecklistsExceededMaxDepth) Name() string {
	return "Checks:ChecklistsExceededMaxDepth"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ChecklistsExceededMaxDepth) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ChecklistsExceededMaxDepth) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ChecklistsExceededMaxDepth) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecklistsExceededMaxDepth) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ChecklistsExceededMaxDepth) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecklistsExceededMaxDepth) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ChecklistsExceededMaxDepth) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.checklistsExceededMaxDepth)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Checks:ChecklistsExceededMaxDepth", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ChecklistsExceededMaxDepth) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters checklistsExceededMaxDepth
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.checklistsExceededMaxDepth = parameters
	return nil
}

type checklistsNotFound struct {
	ChecklistRids []api.ChecklistRid `json:"checklistRids"`
}

func (o checklistsNotFound) MarshalJSON() ([]byte, error) {
	if o.ChecklistRids == nil {
		o.ChecklistRids = make([]api.ChecklistRid, 0)
	}
	type _tmpchecklistsNotFound checklistsNotFound
	return safejson.Marshal(_tmpchecklistsNotFound(o))
}

func (o *checklistsNotFound) UnmarshalJSON(data []byte) error {
	type _tmpchecklistsNotFound checklistsNotFound
	var rawchecklistsNotFound _tmpchecklistsNotFound
	if err := safejson.Unmarshal(data, &rawchecklistsNotFound); err != nil {
		return err
	}
	if rawchecklistsNotFound.ChecklistRids == nil {
		rawchecklistsNotFound.ChecklistRids = make([]api.ChecklistRid, 0)
	}
	*o = checklistsNotFound(rawchecklistsNotFound)
	return nil
}

func (o checklistsNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *checklistsNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewChecklistsNotFound returns new instance of ChecklistsNotFound error.
func NewChecklistsNotFound(checklistRidsArg []api.ChecklistRid) *ChecklistsNotFound {
	return &ChecklistsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), checklistsNotFound: checklistsNotFound{ChecklistRids: checklistRidsArg}}
}

// WrapWithChecklistsNotFound returns new instance of ChecklistsNotFound error wrapping an existing error.
func WrapWithChecklistsNotFound(err error, checklistRidsArg []api.ChecklistRid) *ChecklistsNotFound {
	return &ChecklistsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, checklistsNotFound: checklistsNotFound{ChecklistRids: checklistRidsArg}}
}

// ChecklistsNotFound is an error type.
type ChecklistsNotFound struct {
	errorInstanceID uuid.UUID
	checklistsNotFound
	cause error
	stack werror.StackTrace
}

// IsChecklistsNotFound returns true if err is an instance of ChecklistsNotFound.
func IsChecklistsNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ChecklistsNotFound)
	return ok
}

func (e *ChecklistsNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Checks:ChecklistsNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ChecklistsNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ChecklistsNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ChecklistsNotFound) Message() string {
	return "NOT_FOUND Checks:ChecklistsNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ChecklistsNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ChecklistsNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *ChecklistsNotFound) Name() string {
	return "Checks:ChecklistsNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ChecklistsNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ChecklistsNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"checklistRids": e.ChecklistRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ChecklistsNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"checklistRids": e.ChecklistRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecklistsNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ChecklistsNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecklistsNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ChecklistsNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.checklistsNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Checks:ChecklistsNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ChecklistsNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters checklistsNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.checklistsNotFound = parameters
	return nil
}

type checksNotFound struct {
	CheckRids []api.CheckRid `json:"checkRids"`
}

func (o checksNotFound) MarshalJSON() ([]byte, error) {
	if o.CheckRids == nil {
		o.CheckRids = make([]api.CheckRid, 0)
	}
	type _tmpchecksNotFound checksNotFound
	return safejson.Marshal(_tmpchecksNotFound(o))
}

func (o *checksNotFound) UnmarshalJSON(data []byte) error {
	type _tmpchecksNotFound checksNotFound
	var rawchecksNotFound _tmpchecksNotFound
	if err := safejson.Unmarshal(data, &rawchecksNotFound); err != nil {
		return err
	}
	if rawchecksNotFound.CheckRids == nil {
		rawchecksNotFound.CheckRids = make([]api.CheckRid, 0)
	}
	*o = checksNotFound(rawchecksNotFound)
	return nil
}

func (o checksNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *checksNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewChecksNotFound returns new instance of ChecksNotFound error.
func NewChecksNotFound(checkRidsArg []api.CheckRid) *ChecksNotFound {
	return &ChecksNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), checksNotFound: checksNotFound{CheckRids: checkRidsArg}}
}

// WrapWithChecksNotFound returns new instance of ChecksNotFound error wrapping an existing error.
func WrapWithChecksNotFound(err error, checkRidsArg []api.CheckRid) *ChecksNotFound {
	return &ChecksNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, checksNotFound: checksNotFound{CheckRids: checkRidsArg}}
}

// ChecksNotFound is an error type.
type ChecksNotFound struct {
	errorInstanceID uuid.UUID
	checksNotFound
	cause error
	stack werror.StackTrace
}

// IsChecksNotFound returns true if err is an instance of ChecksNotFound.
func IsChecksNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ChecksNotFound)
	return ok
}

func (e *ChecksNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Checks:ChecksNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ChecksNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ChecksNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ChecksNotFound) Message() string {
	return "NOT_FOUND Checks:ChecksNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ChecksNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ChecksNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *ChecksNotFound) Name() string {
	return "Checks:ChecksNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ChecksNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ChecksNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"checkRids": e.CheckRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ChecksNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"checkRids": e.CheckRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecksNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ChecksNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecksNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ChecksNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.checksNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Checks:ChecksNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ChecksNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters checksNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.checksNotFound = parameters
	return nil
}

type commitToArchivedChecklist struct {
	ChecklistRid api.ChecklistRid `json:"checklistRid"`
}

func (o commitToArchivedChecklist) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *commitToArchivedChecklist) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCommitToArchivedChecklist returns new instance of CommitToArchivedChecklist error.
func NewCommitToArchivedChecklist(checklistRidArg api.ChecklistRid) *CommitToArchivedChecklist {
	return &CommitToArchivedChecklist{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), commitToArchivedChecklist: commitToArchivedChecklist{ChecklistRid: checklistRidArg}}
}

// WrapWithCommitToArchivedChecklist returns new instance of CommitToArchivedChecklist error wrapping an existing error.
func WrapWithCommitToArchivedChecklist(err error, checklistRidArg api.ChecklistRid) *CommitToArchivedChecklist {
	return &CommitToArchivedChecklist{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, commitToArchivedChecklist: commitToArchivedChecklist{ChecklistRid: checklistRidArg}}
}

// CommitToArchivedChecklist is an error type.
type CommitToArchivedChecklist struct {
	errorInstanceID uuid.UUID
	commitToArchivedChecklist
	cause error
	stack werror.StackTrace
}

// IsCommitToArchivedChecklist returns true if err is an instance of CommitToArchivedChecklist.
func IsCommitToArchivedChecklist(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CommitToArchivedChecklist)
	return ok
}

func (e *CommitToArchivedChecklist) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Checks:CommitToArchivedChecklist (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CommitToArchivedChecklist) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CommitToArchivedChecklist) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CommitToArchivedChecklist) Message() string {
	return "INVALID_ARGUMENT Checks:CommitToArchivedChecklist"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CommitToArchivedChecklist) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CommitToArchivedChecklist) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CommitToArchivedChecklist) Name() string {
	return "Checks:CommitToArchivedChecklist"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CommitToArchivedChecklist) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CommitToArchivedChecklist) Parameters() map[string]interface{} {
	return map[string]interface{}{"checklistRid": e.ChecklistRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CommitToArchivedChecklist) safeParams() map[string]interface{} {
	return map[string]interface{}{"checklistRid": e.ChecklistRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CommitToArchivedChecklist) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CommitToArchivedChecklist) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CommitToArchivedChecklist) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CommitToArchivedChecklist) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.commitToArchivedChecklist)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Checks:CommitToArchivedChecklist", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CommitToArchivedChecklist) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters commitToArchivedChecklist
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.commitToArchivedChecklist = parameters
	return nil
}

type jobNotFound struct {
	JobRid JobRid `json:"jobRid"`
}

func (o jobNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *jobNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewJobNotFound returns new instance of JobNotFound error.
func NewJobNotFound(jobRidArg JobRid) *JobNotFound {
	return &JobNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), jobNotFound: jobNotFound{JobRid: jobRidArg}}
}

// WrapWithJobNotFound returns new instance of JobNotFound error wrapping an existing error.
func WrapWithJobNotFound(err error, jobRidArg JobRid) *JobNotFound {
	return &JobNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, jobNotFound: jobNotFound{JobRid: jobRidArg}}
}

// JobNotFound is an error type.
type JobNotFound struct {
	errorInstanceID uuid.UUID
	jobNotFound
	cause error
	stack werror.StackTrace
}

// IsJobNotFound returns true if err is an instance of JobNotFound.
func IsJobNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*JobNotFound)
	return ok
}

func (e *JobNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND JobService:JobNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *JobNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *JobNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *JobNotFound) Message() string {
	return "NOT_FOUND JobService:JobNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *JobNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *JobNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *JobNotFound) Name() string {
	return "JobService:JobNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *JobNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *JobNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"jobRid": e.JobRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *JobNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"jobRid": e.JobRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *JobNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *JobNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *JobNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e JobNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.jobNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "JobService:JobNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *JobNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters jobNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.jobNotFound = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Checks:AssetsNotFound", reflect.TypeOf(AssetsNotFound{}))
	conjureerrors.RegisterErrorType("Checks:CheckNotFound", reflect.TypeOf(CheckNotFound{}))
	conjureerrors.RegisterErrorType("Checks:ChecklistNotFound", reflect.TypeOf(ChecklistNotFound{}))
	conjureerrors.RegisterErrorType("Checks:ChecklistsCircularDependency", reflect.TypeOf(ChecklistsCircularDependency{}))
	conjureerrors.RegisterErrorType("Checks:ChecklistsExceededMaxDepth", reflect.TypeOf(ChecklistsExceededMaxDepth{}))
	conjureerrors.RegisterErrorType("Checks:ChecklistsNotFound", reflect.TypeOf(ChecklistsNotFound{}))
	conjureerrors.RegisterErrorType("Checks:ChecksNotFound", reflect.TypeOf(ChecksNotFound{}))
	conjureerrors.RegisterErrorType("Checks:CommitToArchivedChecklist", reflect.TypeOf(CommitToArchivedChecklist{}))
	conjureerrors.RegisterErrorType("JobService:JobNotFound", reflect.TypeOf(JobNotFound{}))
}
