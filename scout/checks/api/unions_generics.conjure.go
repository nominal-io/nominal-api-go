// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/io/nominal/api"
	api3 "github.com/nominal-io/nominal-api/scout/api"
	api2 "github.com/nominal-io/nominal-api/scout/compute/api"
	api1 "github.com/nominal-io/nominal-api/scout/rids/api"
)

type CheckConditionWithT[T any] CheckCondition

func (u *CheckConditionWithT[T]) Accept(ctx context.Context, v CheckConditionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numRanges":
		if u.numRanges == nil {
			return result, fmt.Errorf("field \"numRanges\" is required")
		}
		return v.VisitNumRanges(ctx, *u.numRanges)
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return result, fmt.Errorf("field \"numRangesV2\" is required")
		}
		return v.VisitNumRangesV2(ctx, *u.numRangesV2)
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return result, fmt.Errorf("field \"numRangesV3\" is required")
		}
		return v.VisitNumRangesV3(ctx, *u.numRangesV3)
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return result, fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return v.VisitParameterizedNumRangesV1(ctx, *u.parameterizedNumRangesV1)
	}
}

func (u *CheckConditionWithT[T]) AcceptFuncs(numRangesFunc func(NumRangesConditionV1) (T, error), numRangesV2Func func(NumRangesConditionV2) (T, error), numRangesV3Func func(NumRangesConditionV3) (T, error), parameterizedNumRangesV1Func func(ParameterizedNumRangesConditionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numRanges":
		if u.numRanges == nil {
			return result, fmt.Errorf("field \"numRanges\" is required")
		}
		return numRangesFunc(*u.numRanges)
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return result, fmt.Errorf("field \"numRangesV2\" is required")
		}
		return numRangesV2Func(*u.numRangesV2)
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return result, fmt.Errorf("field \"numRangesV3\" is required")
		}
		return numRangesV3Func(*u.numRangesV3)
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return result, fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return parameterizedNumRangesV1Func(*u.parameterizedNumRangesV1)
	}
}

func (u *CheckConditionWithT[T]) NumRangesNoopSuccess(NumRangesConditionV1) (T, error) {
	var result T
	return result, nil
}

func (u *CheckConditionWithT[T]) NumRangesV2NoopSuccess(NumRangesConditionV2) (T, error) {
	var result T
	return result, nil
}

func (u *CheckConditionWithT[T]) NumRangesV3NoopSuccess(NumRangesConditionV3) (T, error) {
	var result T
	return result, nil
}

func (u *CheckConditionWithT[T]) ParameterizedNumRangesV1NoopSuccess(ParameterizedNumRangesConditionV1) (T, error) {
	var result T
	return result, nil
}

func (u *CheckConditionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CheckConditionVisitorWithT[T any] interface {
	VisitNumRanges(ctx context.Context, v NumRangesConditionV1) (T, error)
	VisitNumRangesV2(ctx context.Context, v NumRangesConditionV2) (T, error)
	VisitNumRangesV3(ctx context.Context, v NumRangesConditionV3) (T, error)
	VisitParameterizedNumRangesV1(ctx context.Context, v ParameterizedNumRangesConditionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ChecklistEntryWithT[T any] ChecklistEntry

func (u *ChecklistEntryWithT[T]) Accept(ctx context.Context, v ChecklistEntryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "check":
		if u.check == nil {
			return result, fmt.Errorf("field \"check\" is required")
		}
		return v.VisitCheck(ctx, *u.check)
	}
}

func (u *ChecklistEntryWithT[T]) AcceptFuncs(checkFunc func(Check) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "check":
		if u.check == nil {
			return result, fmt.Errorf("field \"check\" is required")
		}
		return checkFunc(*u.check)
	}
}

func (u *ChecklistEntryWithT[T]) CheckNoopSuccess(Check) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistEntryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ChecklistEntryVisitorWithT[T any] interface {
	VisitCheck(ctx context.Context, v Check) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ChecklistSearchQueryWithT[T any] ChecklistSearchQuery

func (u *ChecklistSearchQueryWithT[T]) Accept(ctx context.Context, v ChecklistSearchQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(ctx, *u.searchText)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(ctx, *u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	case "authorRid":
		if u.authorRid == nil {
			return result, fmt.Errorf("field \"authorRid\" is required")
		}
		return v.VisitAuthorRid(ctx, *u.authorRid)
	case "assigneeRid":
		if u.assigneeRid == nil {
			return result, fmt.Errorf("field \"assigneeRid\" is required")
		}
		return v.VisitAssigneeRid(ctx, *u.assigneeRid)
	case "isPublished":
		if u.isPublished == nil {
			return result, fmt.Errorf("field \"isPublished\" is required")
		}
		return v.VisitIsPublished(ctx, *u.isPublished)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(ctx, *u.not)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	}
}

func (u *ChecklistSearchQueryWithT[T]) AcceptFuncs(andFunc func([]ChecklistSearchQuery) (T, error), orFunc func([]ChecklistSearchQuery) (T, error), searchTextFunc func(string) (T, error), labelFunc func(api.Label) (T, error), propertyFunc func(api.Property) (T, error), authorRidFunc func(api1.UserRid) (T, error), assigneeRidFunc func(api1.UserRid) (T, error), isPublishedFunc func(bool) (T, error), notFunc func(ChecklistSearchQuery) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "authorRid":
		if u.authorRid == nil {
			return result, fmt.Errorf("field \"authorRid\" is required")
		}
		return authorRidFunc(*u.authorRid)
	case "assigneeRid":
		if u.assigneeRid == nil {
			return result, fmt.Errorf("field \"assigneeRid\" is required")
		}
		return assigneeRidFunc(*u.assigneeRid)
	case "isPublished":
		if u.isPublished == nil {
			return result, fmt.Errorf("field \"isPublished\" is required")
		}
		return isPublishedFunc(*u.isPublished)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *ChecklistSearchQueryWithT[T]) AndNoopSuccess([]ChecklistSearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistSearchQueryWithT[T]) OrNoopSuccess([]ChecklistSearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistSearchQueryWithT[T]) SearchTextNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistSearchQueryWithT[T]) LabelNoopSuccess(api.Label) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistSearchQueryWithT[T]) PropertyNoopSuccess(api.Property) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistSearchQueryWithT[T]) AuthorRidNoopSuccess(api1.UserRid) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistSearchQueryWithT[T]) AssigneeRidNoopSuccess(api1.UserRid) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistSearchQueryWithT[T]) IsPublishedNoopSuccess(bool) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistSearchQueryWithT[T]) NotNoopSuccess(ChecklistSearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistSearchQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistSearchQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ChecklistSearchQueryVisitorWithT[T any] interface {
	VisitAnd(ctx context.Context, v []ChecklistSearchQuery) (T, error)
	VisitOr(ctx context.Context, v []ChecklistSearchQuery) (T, error)
	VisitSearchText(ctx context.Context, v string) (T, error)
	VisitLabel(ctx context.Context, v api.Label) (T, error)
	VisitProperty(ctx context.Context, v api.Property) (T, error)
	VisitAuthorRid(ctx context.Context, v api1.UserRid) (T, error)
	VisitAssigneeRid(ctx context.Context, v api1.UserRid) (T, error)
	VisitIsPublished(ctx context.Context, v bool) (T, error)
	VisitNot(ctx context.Context, v ChecklistSearchQuery) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CreateChecklistEntryRequestWithT[T any] CreateChecklistEntryRequest

func (u *CreateChecklistEntryRequestWithT[T]) Accept(ctx context.Context, v CreateChecklistEntryRequestVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return result, fmt.Errorf("field \"createCheck\" is required")
		}
		return v.VisitCreateCheck(ctx, *u.createCheck)
	}
}

func (u *CreateChecklistEntryRequestWithT[T]) AcceptFuncs(createCheckFunc func(CreateCheckRequest) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return result, fmt.Errorf("field \"createCheck\" is required")
		}
		return createCheckFunc(*u.createCheck)
	}
}

func (u *CreateChecklistEntryRequestWithT[T]) CreateCheckNoopSuccess(CreateCheckRequest) (T, error) {
	var result T
	return result, nil
}

func (u *CreateChecklistEntryRequestWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CreateChecklistEntryRequestVisitorWithT[T any] interface {
	VisitCreateCheck(ctx context.Context, v CreateCheckRequest) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FunctionNodeWithT[T any] FunctionNode

func (u *FunctionNodeWithT[T]) Accept(ctx context.Context, v FunctionNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(ctx, *u.ranges)
	}
}

func (u *FunctionNodeWithT[T]) AcceptFuncs(enumFunc func(api2.EnumSeries) (T, error), numericFunc func(api2.NumericSeries) (T, error), rangesFunc func(api2.RangeSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	}
}

func (u *FunctionNodeWithT[T]) EnumNoopSuccess(api2.EnumSeries) (T, error) {
	var result T
	return result, nil
}

func (u *FunctionNodeWithT[T]) NumericNoopSuccess(api2.NumericSeries) (T, error) {
	var result T
	return result, nil
}

func (u *FunctionNodeWithT[T]) RangesNoopSuccess(api2.RangeSeries) (T, error) {
	var result T
	return result, nil
}

func (u *FunctionNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FunctionNodeVisitorWithT[T any] interface {
	VisitEnum(ctx context.Context, v api2.EnumSeries) (T, error)
	VisitNumeric(ctx context.Context, v api2.NumericSeries) (T, error)
	VisitRanges(ctx context.Context, v api2.RangeSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type JobSpecWithT[T any] JobSpec

func (u *JobSpecWithT[T]) Accept(ctx context.Context, v JobSpecVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "check":
		if u.check == nil {
			return result, fmt.Errorf("field \"check\" is required")
		}
		return v.VisitCheck(ctx, *u.check)
	case "checkV2":
		if u.checkV2 == nil {
			return result, fmt.Errorf("field \"checkV2\" is required")
		}
		return v.VisitCheckV2(ctx, *u.checkV2)
	}
}

func (u *JobSpecWithT[T]) AcceptFuncs(checkFunc func(DeprecatedCheckJobSpec) (T, error), checkV2Func func(CheckJobSpec) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "check":
		if u.check == nil {
			return result, fmt.Errorf("field \"check\" is required")
		}
		return checkFunc(*u.check)
	case "checkV2":
		if u.checkV2 == nil {
			return result, fmt.Errorf("field \"checkV2\" is required")
		}
		return checkV2Func(*u.checkV2)
	}
}

func (u *JobSpecWithT[T]) CheckNoopSuccess(DeprecatedCheckJobSpec) (T, error) {
	var result T
	return result, nil
}

func (u *JobSpecWithT[T]) CheckV2NoopSuccess(CheckJobSpec) (T, error) {
	var result T
	return result, nil
}

func (u *JobSpecWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type JobSpecVisitorWithT[T any] interface {
	VisitCheck(ctx context.Context, v DeprecatedCheckJobSpec) (T, error)
	VisitCheckV2(ctx context.Context, v CheckJobSpec) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UnresolvedCheckConditionWithT[T any] UnresolvedCheckCondition

func (u *UnresolvedCheckConditionWithT[T]) Accept(ctx context.Context, v UnresolvedCheckConditionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return result, fmt.Errorf("field \"numRangesV2\" is required")
		}
		return v.VisitNumRangesV2(ctx, *u.numRangesV2)
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return result, fmt.Errorf("field \"numRangesV3\" is required")
		}
		return v.VisitNumRangesV3(ctx, *u.numRangesV3)
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return result, fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return v.VisitParameterizedNumRangesV1(ctx, *u.parameterizedNumRangesV1)
	}
}

func (u *UnresolvedCheckConditionWithT[T]) AcceptFuncs(numRangesV2Func func(UnresolvedNumRangesConditionV2) (T, error), numRangesV3Func func(UnresolvedNumRangesConditionV3) (T, error), parameterizedNumRangesV1Func func(UnresolvedParameterizedNumRangesConditionV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "numRangesV2":
		if u.numRangesV2 == nil {
			return result, fmt.Errorf("field \"numRangesV2\" is required")
		}
		return numRangesV2Func(*u.numRangesV2)
	case "numRangesV3":
		if u.numRangesV3 == nil {
			return result, fmt.Errorf("field \"numRangesV3\" is required")
		}
		return numRangesV3Func(*u.numRangesV3)
	case "parameterizedNumRangesV1":
		if u.parameterizedNumRangesV1 == nil {
			return result, fmt.Errorf("field \"parameterizedNumRangesV1\" is required")
		}
		return parameterizedNumRangesV1Func(*u.parameterizedNumRangesV1)
	}
}

func (u *UnresolvedCheckConditionWithT[T]) NumRangesV2NoopSuccess(UnresolvedNumRangesConditionV2) (T, error) {
	var result T
	return result, nil
}

func (u *UnresolvedCheckConditionWithT[T]) NumRangesV3NoopSuccess(UnresolvedNumRangesConditionV3) (T, error) {
	var result T
	return result, nil
}

func (u *UnresolvedCheckConditionWithT[T]) ParameterizedNumRangesV1NoopSuccess(UnresolvedParameterizedNumRangesConditionV1) (T, error) {
	var result T
	return result, nil
}

func (u *UnresolvedCheckConditionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UnresolvedCheckConditionVisitorWithT[T any] interface {
	VisitNumRangesV2(ctx context.Context, v UnresolvedNumRangesConditionV2) (T, error)
	VisitNumRangesV3(ctx context.Context, v UnresolvedNumRangesConditionV3) (T, error)
	VisitParameterizedNumRangesV1(ctx context.Context, v UnresolvedParameterizedNumRangesConditionV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UnresolvedVariableLocatorWithT[T any] UnresolvedVariableLocator

func (u *UnresolvedVariableLocatorWithT[T]) Accept(ctx context.Context, v UnresolvedVariableLocatorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return result, fmt.Errorf("field \"checklistVariable\" is required")
		}
		return v.VisitChecklistVariable(ctx, *u.checklistVariable)
	case "computeNode":
		if u.computeNode == nil {
			return result, fmt.Errorf("field \"computeNode\" is required")
		}
		return v.VisitComputeNode(ctx, *u.computeNode)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(ctx, *u.series)
	case "timestamp":
		if u.timestamp == nil {
			return result, fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestamp(ctx, *u.timestamp)
	}
}

func (u *UnresolvedVariableLocatorWithT[T]) AcceptFuncs(checklistVariableFunc func(api2.VariableName) (T, error), computeNodeFunc func(UnresolvedComputeNodeWithContext) (T, error), seriesFunc func(api3.ChannelLocator) (T, error), timestampFunc func(TimestampLocator) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return result, fmt.Errorf("field \"checklistVariable\" is required")
		}
		return checklistVariableFunc(*u.checklistVariable)
	case "computeNode":
		if u.computeNode == nil {
			return result, fmt.Errorf("field \"computeNode\" is required")
		}
		return computeNodeFunc(*u.computeNode)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "timestamp":
		if u.timestamp == nil {
			return result, fmt.Errorf("field \"timestamp\" is required")
		}
		return timestampFunc(*u.timestamp)
	}
}

func (u *UnresolvedVariableLocatorWithT[T]) ChecklistVariableNoopSuccess(api2.VariableName) (T, error) {
	var result T
	return result, nil
}

func (u *UnresolvedVariableLocatorWithT[T]) ComputeNodeNoopSuccess(UnresolvedComputeNodeWithContext) (T, error) {
	var result T
	return result, nil
}

func (u *UnresolvedVariableLocatorWithT[T]) SeriesNoopSuccess(api3.ChannelLocator) (T, error) {
	var result T
	return result, nil
}

func (u *UnresolvedVariableLocatorWithT[T]) TimestampNoopSuccess(TimestampLocator) (T, error) {
	var result T
	return result, nil
}

func (u *UnresolvedVariableLocatorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UnresolvedVariableLocatorVisitorWithT[T any] interface {
	VisitChecklistVariable(ctx context.Context, v api2.VariableName) (T, error)
	VisitComputeNode(ctx context.Context, v UnresolvedComputeNodeWithContext) (T, error)
	VisitSeries(ctx context.Context, v api3.ChannelLocator) (T, error)
	VisitTimestamp(ctx context.Context, v TimestampLocator) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UpdateChecklistEntryRequestWithT[T any] UpdateChecklistEntryRequest

func (u *UpdateChecklistEntryRequestWithT[T]) Accept(ctx context.Context, v UpdateChecklistEntryRequestVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return result, fmt.Errorf("field \"createCheck\" is required")
		}
		return v.VisitCreateCheck(ctx, *u.createCheck)
	case "check":
		if u.check == nil {
			return result, fmt.Errorf("field \"check\" is required")
		}
		return v.VisitCheck(ctx, *u.check)
	}
}

func (u *UpdateChecklistEntryRequestWithT[T]) AcceptFuncs(createCheckFunc func(CreateCheckRequest) (T, error), checkFunc func(api1.CheckRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "createCheck":
		if u.createCheck == nil {
			return result, fmt.Errorf("field \"createCheck\" is required")
		}
		return createCheckFunc(*u.createCheck)
	case "check":
		if u.check == nil {
			return result, fmt.Errorf("field \"check\" is required")
		}
		return checkFunc(*u.check)
	}
}

func (u *UpdateChecklistEntryRequestWithT[T]) CreateCheckNoopSuccess(CreateCheckRequest) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateChecklistEntryRequestWithT[T]) CheckNoopSuccess(api1.CheckRid) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateChecklistEntryRequestWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UpdateChecklistEntryRequestVisitorWithT[T any] interface {
	VisitCreateCheck(ctx context.Context, v CreateCheckRequest) (T, error)
	VisitCheck(ctx context.Context, v api1.CheckRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VariableLocatorWithT[T any] VariableLocator

func (u *VariableLocatorWithT[T]) Accept(ctx context.Context, v VariableLocatorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return result, fmt.Errorf("field \"checklistVariable\" is required")
		}
		return v.VisitChecklistVariable(ctx, *u.checklistVariable)
	case "computeNode":
		if u.computeNode == nil {
			return result, fmt.Errorf("field \"computeNode\" is required")
		}
		return v.VisitComputeNode(ctx, *u.computeNode)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(ctx, *u.series)
	case "timestamp":
		if u.timestamp == nil {
			return result, fmt.Errorf("field \"timestamp\" is required")
		}
		return v.VisitTimestamp(ctx, *u.timestamp)
	}
}

func (u *VariableLocatorWithT[T]) AcceptFuncs(checklistVariableFunc func(api2.VariableName) (T, error), computeNodeFunc func(ComputeNodeWithContext) (T, error), seriesFunc func(api3.ChannelLocator) (T, error), timestampFunc func(TimestampLocator) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "checklistVariable":
		if u.checklistVariable == nil {
			return result, fmt.Errorf("field \"checklistVariable\" is required")
		}
		return checklistVariableFunc(*u.checklistVariable)
	case "computeNode":
		if u.computeNode == nil {
			return result, fmt.Errorf("field \"computeNode\" is required")
		}
		return computeNodeFunc(*u.computeNode)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	case "timestamp":
		if u.timestamp == nil {
			return result, fmt.Errorf("field \"timestamp\" is required")
		}
		return timestampFunc(*u.timestamp)
	}
}

func (u *VariableLocatorWithT[T]) ChecklistVariableNoopSuccess(api2.VariableName) (T, error) {
	var result T
	return result, nil
}

func (u *VariableLocatorWithT[T]) ComputeNodeNoopSuccess(ComputeNodeWithContext) (T, error) {
	var result T
	return result, nil
}

func (u *VariableLocatorWithT[T]) SeriesNoopSuccess(api3.ChannelLocator) (T, error) {
	var result T
	return result, nil
}

func (u *VariableLocatorWithT[T]) TimestampNoopSuccess(TimestampLocator) (T, error) {
	var result T
	return result, nil
}

func (u *VariableLocatorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VariableLocatorVisitorWithT[T any] interface {
	VisitChecklistVariable(ctx context.Context, v api2.VariableName) (T, error)
	VisitComputeNode(ctx context.Context, v ComputeNodeWithContext) (T, error)
	VisitSeries(ctx context.Context, v api3.ChannelLocator) (T, error)
	VisitTimestamp(ctx context.Context, v TimestampLocator) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
