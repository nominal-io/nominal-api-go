// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"
	"net/url"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/internal/conjureerrors"
	api2 "github.com/nominal-io/nominal-api/scout/api"
	"github.com/nominal-io/nominal-api/scout/rids/api"
	api1 "github.com/nominal-io/nominal-api/scout/versioning/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	werror "github.com/palantir/witchcraft-go-error"
)

/*
The Checklist Service is responsible for managing checklists and checks.
A checklist is a collection of checks that can be executed against a set of data sources.
*/
type ChecklistServiceClient interface {
	// Creates a new checklist with the provided checks.
	Create(ctx context.Context, authHeader bearertoken.Token, requestArg CreateChecklistRequest) (VersionedChecklist, error)
	/*
	   Creates a permanent commit with a commit message.
	   Throws if the checklist or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you commit to an archived checklist.
	*/
	Commit(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, requestArg CommitChecklistRequest) (VersionedChecklist, error)
	/*
	   Creates a commit that may be compacted, e.g cleaned up and not exist anymore.
	   Throws if the checklist or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you save to an archived checklist.
	*/
	SaveWorkingState(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, requestArg SaveChecklistRequest) (VersionedChecklist, error)
	/*
	   Merges the given branch to the "main" branch.
	   Throws if the checklist or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you merge with an archived checklist.
	*/
	MergeToMain(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid, requestArg MergeToMainRequest) (VersionedChecklist, error)
	/*
	   Updates the data source ref names for all checks within a checklist.
	   Throws if the checklist doesn't exist.
	*/
	UpdateDataSourceRefNames(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, refNameUpdatesArg map[api2.DataSourceRefName]api2.DataSourceRefName) (VersionedChecklist, error)
	// Updates the metadata of a checklist.
	UpdateMetadata(ctx context.Context, authHeader bearertoken.Token, ridArg api.ChecklistRid, requestArg UpdateChecklistMetadataRequest) (ChecklistMetadata, error)
	/*
	   Specify at most one of (branch, commit).
	   If neither is specified, branch = "main" is the default.
	*/
	Get(ctx context.Context, authHeader bearertoken.Token, ridArg api.ChecklistRid, branchArg *api1.BranchName, commitArg *api1.CommitId) (VersionedChecklist, error)
	// Returns the pinned commit for each provided checklist reference.
	BatchGet(ctx context.Context, authHeader bearertoken.Token, checklistRefsArg []PinnedChecklistRef) ([]VersionedChecklist, error)
	// Returns the metadata for each provided checklist.
	BatchGetMetadata(ctx context.Context, authHeader bearertoken.Token, requestArg BatchGetChecklistMetadataRequest) (BatchGetChecklistMetadataResponse, error)
	// Results will be the latest commit on main for each checklist.
	Search(ctx context.Context, authHeader bearertoken.Token, requestArg SearchChecklistsRequest) (VersionedChecklistPage, error)
	// Archives the provided checklists.
	Archive(ctx context.Context, authHeader bearertoken.Token, requestArg ArchiveChecklistsRequest) error
	// Unarchives the provided checklists.
	Unarchive(ctx context.Context, authHeader bearertoken.Token, requestArg UnarchiveChecklistsRequest) error
	// Returns the check with the given rid.
	GetCheck(ctx context.Context, authHeader bearertoken.Token, ridArg api.CheckRid) (Check, error)
	// Returns the checks with the given rids.
	BatchGetChecks(ctx context.Context, authHeader bearertoken.Token, ridsArg []api.CheckRid) ([]Check, error)
	// Returns all labels and properties.
	GetAllLabelsAndProperties(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) (GetAllLabelsAndPropertiesResponse, error)
}

type checklistServiceClient struct {
	client httpclient.Client
}

func NewChecklistServiceClient(client httpclient.Client) ChecklistServiceClient {
	return &checklistServiceClient{client: client}
}

func (c *checklistServiceClient) Create(ctx context.Context, authHeader bearertoken.Token, requestArg CreateChecklistRequest) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	var returnVal *VersionedChecklist
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Create"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "create failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "create response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistServiceClient) Commit(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, requestArg CommitChecklistRequest) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	var returnVal *VersionedChecklist
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Commit"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/%s/commit", url.PathEscape(fmt.Sprint(checklistRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	queryParams := make(url.Values)
	if branchArg != nil {
		queryParams.Set("branch", fmt.Sprint(*branchArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "commit failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "commit response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistServiceClient) SaveWorkingState(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, requestArg SaveChecklistRequest) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	var returnVal *VersionedChecklist
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SaveWorkingState"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/%s/save-working-state", url.PathEscape(fmt.Sprint(checklistRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	queryParams := make(url.Values)
	if branchArg != nil {
		queryParams.Set("branch", fmt.Sprint(*branchArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "saveWorkingState failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "saveWorkingState response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistServiceClient) MergeToMain(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid, requestArg MergeToMainRequest) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	var returnVal *VersionedChecklist
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("MergeToMain"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/%s/merge-to-main", url.PathEscape(fmt.Sprint(checklistRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "mergeToMain failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "mergeToMain response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistServiceClient) UpdateDataSourceRefNames(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, refNameUpdatesArg map[api2.DataSourceRefName]api2.DataSourceRefName) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	var returnVal *VersionedChecklist
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateDataSourceRefNames"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/%s/update-ref-names", url.PathEscape(fmt.Sprint(checklistRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(refNameUpdatesArg))
	queryParams := make(url.Values)
	if branchArg != nil {
		queryParams.Set("branch", fmt.Sprint(*branchArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateDataSourceRefNames failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateDataSourceRefNames response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistServiceClient) UpdateMetadata(ctx context.Context, authHeader bearertoken.Token, ridArg api.ChecklistRid, requestArg UpdateChecklistMetadataRequest) (ChecklistMetadata, error) {
	var defaultReturnVal ChecklistMetadata
	var returnVal *ChecklistMetadata
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateMetadata"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/%s/update-metadata", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateMetadata failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateMetadata response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistServiceClient) Get(ctx context.Context, authHeader bearertoken.Token, ridArg api.ChecklistRid, branchArg *api1.BranchName, commitArg *api1.CommitId) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	var returnVal *VersionedChecklist
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Get"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/%s", url.PathEscape(fmt.Sprint(ridArg))))
	queryParams := make(url.Values)
	if branchArg != nil {
		queryParams.Set("branch", fmt.Sprint(*branchArg))
	}
	if commitArg != nil {
		queryParams.Set("commit", fmt.Sprint(*commitArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "get failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "get response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistServiceClient) BatchGet(ctx context.Context, authHeader bearertoken.Token, checklistRefsArg []PinnedChecklistRef) ([]VersionedChecklist, error) {
	var returnVal []VersionedChecklist
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGet"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/batch-get"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(checklistRefsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGet failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGet response cannot be nil")
	}
	return returnVal, nil
}

func (c *checklistServiceClient) BatchGetMetadata(ctx context.Context, authHeader bearertoken.Token, requestArg BatchGetChecklistMetadataRequest) (BatchGetChecklistMetadataResponse, error) {
	var defaultReturnVal BatchGetChecklistMetadataResponse
	var returnVal *BatchGetChecklistMetadataResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGetMetadata"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/batch-get-metadata"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "batchGetMetadata failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "batchGetMetadata response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistServiceClient) Search(ctx context.Context, authHeader bearertoken.Token, requestArg SearchChecklistsRequest) (VersionedChecklistPage, error) {
	var defaultReturnVal VersionedChecklistPage
	var returnVal *VersionedChecklistPage
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Search"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/search"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "search failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "search response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistServiceClient) Archive(ctx context.Context, authHeader bearertoken.Token, requestArg ArchiveChecklistsRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Archive"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/archive"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "archive failed")
	}
	return nil
}

func (c *checklistServiceClient) Unarchive(ctx context.Context, authHeader bearertoken.Token, requestArg UnarchiveChecklistsRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Unarchive"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/unarchive"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "unarchive failed")
	}
	return nil
}

func (c *checklistServiceClient) GetCheck(ctx context.Context, authHeader bearertoken.Token, ridArg api.CheckRid) (Check, error) {
	var defaultReturnVal Check
	var returnVal *Check
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetCheck"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/check/%s", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getCheck failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getCheck response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistServiceClient) BatchGetChecks(ctx context.Context, authHeader bearertoken.Token, ridsArg []api.CheckRid) ([]Check, error) {
	var returnVal []Check
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGetChecks"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/check/batch-get"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(ridsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGetChecks failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGetChecks response cannot be nil")
	}
	return returnVal, nil
}

func (c *checklistServiceClient) GetAllLabelsAndProperties(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) (GetAllLabelsAndPropertiesResponse, error) {
	var defaultReturnVal GetAllLabelsAndPropertiesResponse
	var returnVal *GetAllLabelsAndPropertiesResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetAllLabelsAndProperties"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/checklists/get-all-labels-properties"))
	queryParams := make(url.Values)
	for _, v := range workspacesArg {
		queryParams.Add("workspaces", fmt.Sprint(v))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getAllLabelsAndProperties failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getAllLabelsAndProperties response cannot be nil")
	}
	return *returnVal, nil
}

/*
The Checklist Service is responsible for managing checklists and checks.
A checklist is a collection of checks that can be executed against a set of data sources.
*/
type ChecklistServiceClientWithAuth interface {
	// Creates a new checklist with the provided checks.
	Create(ctx context.Context, requestArg CreateChecklistRequest) (VersionedChecklist, error)
	/*
	   Creates a permanent commit with a commit message.
	   Throws if the checklist or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you commit to an archived checklist.
	*/
	Commit(ctx context.Context, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, requestArg CommitChecklistRequest) (VersionedChecklist, error)
	/*
	   Creates a commit that may be compacted, e.g cleaned up and not exist anymore.
	   Throws if the checklist or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you save to an archived checklist.
	*/
	SaveWorkingState(ctx context.Context, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, requestArg SaveChecklistRequest) (VersionedChecklist, error)
	/*
	   Merges the given branch to the "main" branch.
	   Throws if the checklist or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you merge with an archived checklist.
	*/
	MergeToMain(ctx context.Context, checklistRidArg api.ChecklistRid, requestArg MergeToMainRequest) (VersionedChecklist, error)
	/*
	   Updates the data source ref names for all checks within a checklist.
	   Throws if the checklist doesn't exist.
	*/
	UpdateDataSourceRefNames(ctx context.Context, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, refNameUpdatesArg map[api2.DataSourceRefName]api2.DataSourceRefName) (VersionedChecklist, error)
	// Updates the metadata of a checklist.
	UpdateMetadata(ctx context.Context, ridArg api.ChecklistRid, requestArg UpdateChecklistMetadataRequest) (ChecklistMetadata, error)
	/*
	   Specify at most one of (branch, commit).
	   If neither is specified, branch = "main" is the default.
	*/
	Get(ctx context.Context, ridArg api.ChecklistRid, branchArg *api1.BranchName, commitArg *api1.CommitId) (VersionedChecklist, error)
	// Returns the pinned commit for each provided checklist reference.
	BatchGet(ctx context.Context, checklistRefsArg []PinnedChecklistRef) ([]VersionedChecklist, error)
	// Returns the metadata for each provided checklist.
	BatchGetMetadata(ctx context.Context, requestArg BatchGetChecklistMetadataRequest) (BatchGetChecklistMetadataResponse, error)
	// Results will be the latest commit on main for each checklist.
	Search(ctx context.Context, requestArg SearchChecklistsRequest) (VersionedChecklistPage, error)
	// Archives the provided checklists.
	Archive(ctx context.Context, requestArg ArchiveChecklistsRequest) error
	// Unarchives the provided checklists.
	Unarchive(ctx context.Context, requestArg UnarchiveChecklistsRequest) error
	// Returns the check with the given rid.
	GetCheck(ctx context.Context, ridArg api.CheckRid) (Check, error)
	// Returns the checks with the given rids.
	BatchGetChecks(ctx context.Context, ridsArg []api.CheckRid) ([]Check, error)
	// Returns all labels and properties.
	GetAllLabelsAndProperties(ctx context.Context, workspacesArg []rids.WorkspaceRid) (GetAllLabelsAndPropertiesResponse, error)
}

func NewChecklistServiceClientWithAuth(client ChecklistServiceClient, authHeader bearertoken.Token) ChecklistServiceClientWithAuth {
	return &checklistServiceClientWithAuth{client: client, authHeader: authHeader}
}

type checklistServiceClientWithAuth struct {
	client     ChecklistServiceClient
	authHeader bearertoken.Token
}

func (c *checklistServiceClientWithAuth) Create(ctx context.Context, requestArg CreateChecklistRequest) (VersionedChecklist, error) {
	return c.client.Create(ctx, c.authHeader, requestArg)
}

func (c *checklistServiceClientWithAuth) Commit(ctx context.Context, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, requestArg CommitChecklistRequest) (VersionedChecklist, error) {
	return c.client.Commit(ctx, c.authHeader, checklistRidArg, branchArg, requestArg)
}

func (c *checklistServiceClientWithAuth) SaveWorkingState(ctx context.Context, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, requestArg SaveChecklistRequest) (VersionedChecklist, error) {
	return c.client.SaveWorkingState(ctx, c.authHeader, checklistRidArg, branchArg, requestArg)
}

func (c *checklistServiceClientWithAuth) MergeToMain(ctx context.Context, checklistRidArg api.ChecklistRid, requestArg MergeToMainRequest) (VersionedChecklist, error) {
	return c.client.MergeToMain(ctx, c.authHeader, checklistRidArg, requestArg)
}

func (c *checklistServiceClientWithAuth) UpdateDataSourceRefNames(ctx context.Context, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, refNameUpdatesArg map[api2.DataSourceRefName]api2.DataSourceRefName) (VersionedChecklist, error) {
	return c.client.UpdateDataSourceRefNames(ctx, c.authHeader, checklistRidArg, branchArg, refNameUpdatesArg)
}

func (c *checklistServiceClientWithAuth) UpdateMetadata(ctx context.Context, ridArg api.ChecklistRid, requestArg UpdateChecklistMetadataRequest) (ChecklistMetadata, error) {
	return c.client.UpdateMetadata(ctx, c.authHeader, ridArg, requestArg)
}

func (c *checklistServiceClientWithAuth) Get(ctx context.Context, ridArg api.ChecklistRid, branchArg *api1.BranchName, commitArg *api1.CommitId) (VersionedChecklist, error) {
	return c.client.Get(ctx, c.authHeader, ridArg, branchArg, commitArg)
}

func (c *checklistServiceClientWithAuth) BatchGet(ctx context.Context, checklistRefsArg []PinnedChecklistRef) ([]VersionedChecklist, error) {
	return c.client.BatchGet(ctx, c.authHeader, checklistRefsArg)
}

func (c *checklistServiceClientWithAuth) BatchGetMetadata(ctx context.Context, requestArg BatchGetChecklistMetadataRequest) (BatchGetChecklistMetadataResponse, error) {
	return c.client.BatchGetMetadata(ctx, c.authHeader, requestArg)
}

func (c *checklistServiceClientWithAuth) Search(ctx context.Context, requestArg SearchChecklistsRequest) (VersionedChecklistPage, error) {
	return c.client.Search(ctx, c.authHeader, requestArg)
}

func (c *checklistServiceClientWithAuth) Archive(ctx context.Context, requestArg ArchiveChecklistsRequest) error {
	return c.client.Archive(ctx, c.authHeader, requestArg)
}

func (c *checklistServiceClientWithAuth) Unarchive(ctx context.Context, requestArg UnarchiveChecklistsRequest) error {
	return c.client.Unarchive(ctx, c.authHeader, requestArg)
}

func (c *checklistServiceClientWithAuth) GetCheck(ctx context.Context, ridArg api.CheckRid) (Check, error) {
	return c.client.GetCheck(ctx, c.authHeader, ridArg)
}

func (c *checklistServiceClientWithAuth) BatchGetChecks(ctx context.Context, ridsArg []api.CheckRid) ([]Check, error) {
	return c.client.BatchGetChecks(ctx, c.authHeader, ridsArg)
}

func (c *checklistServiceClientWithAuth) GetAllLabelsAndProperties(ctx context.Context, workspacesArg []rids.WorkspaceRid) (GetAllLabelsAndPropertiesResponse, error) {
	return c.client.GetAllLabelsAndProperties(ctx, c.authHeader, workspacesArg)
}

func NewChecklistServiceClientWithTokenProvider(client ChecklistServiceClient, tokenProvider httpclient.TokenProvider) ChecklistServiceClientWithAuth {
	return &checklistServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type checklistServiceClientWithTokenProvider struct {
	client        ChecklistServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *checklistServiceClientWithTokenProvider) Create(ctx context.Context, requestArg CreateChecklistRequest) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Create(ctx, bearertoken.Token(token), requestArg)
}

func (c *checklistServiceClientWithTokenProvider) Commit(ctx context.Context, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, requestArg CommitChecklistRequest) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Commit(ctx, bearertoken.Token(token), checklistRidArg, branchArg, requestArg)
}

func (c *checklistServiceClientWithTokenProvider) SaveWorkingState(ctx context.Context, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, requestArg SaveChecklistRequest) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.SaveWorkingState(ctx, bearertoken.Token(token), checklistRidArg, branchArg, requestArg)
}

func (c *checklistServiceClientWithTokenProvider) MergeToMain(ctx context.Context, checklistRidArg api.ChecklistRid, requestArg MergeToMainRequest) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.MergeToMain(ctx, bearertoken.Token(token), checklistRidArg, requestArg)
}

func (c *checklistServiceClientWithTokenProvider) UpdateDataSourceRefNames(ctx context.Context, checklistRidArg api.ChecklistRid, branchArg *api1.BranchName, refNameUpdatesArg map[api2.DataSourceRefName]api2.DataSourceRefName) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateDataSourceRefNames(ctx, bearertoken.Token(token), checklistRidArg, branchArg, refNameUpdatesArg)
}

func (c *checklistServiceClientWithTokenProvider) UpdateMetadata(ctx context.Context, ridArg api.ChecklistRid, requestArg UpdateChecklistMetadataRequest) (ChecklistMetadata, error) {
	var defaultReturnVal ChecklistMetadata
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateMetadata(ctx, bearertoken.Token(token), ridArg, requestArg)
}

func (c *checklistServiceClientWithTokenProvider) Get(ctx context.Context, ridArg api.ChecklistRid, branchArg *api1.BranchName, commitArg *api1.CommitId) (VersionedChecklist, error) {
	var defaultReturnVal VersionedChecklist
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Get(ctx, bearertoken.Token(token), ridArg, branchArg, commitArg)
}

func (c *checklistServiceClientWithTokenProvider) BatchGet(ctx context.Context, checklistRefsArg []PinnedChecklistRef) ([]VersionedChecklist, error) {
	var defaultReturnVal []VersionedChecklist
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGet(ctx, bearertoken.Token(token), checklistRefsArg)
}

func (c *checklistServiceClientWithTokenProvider) BatchGetMetadata(ctx context.Context, requestArg BatchGetChecklistMetadataRequest) (BatchGetChecklistMetadataResponse, error) {
	var defaultReturnVal BatchGetChecklistMetadataResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGetMetadata(ctx, bearertoken.Token(token), requestArg)
}

func (c *checklistServiceClientWithTokenProvider) Search(ctx context.Context, requestArg SearchChecklistsRequest) (VersionedChecklistPage, error) {
	var defaultReturnVal VersionedChecklistPage
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Search(ctx, bearertoken.Token(token), requestArg)
}

func (c *checklistServiceClientWithTokenProvider) Archive(ctx context.Context, requestArg ArchiveChecklistsRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Archive(ctx, bearertoken.Token(token), requestArg)
}

func (c *checklistServiceClientWithTokenProvider) Unarchive(ctx context.Context, requestArg UnarchiveChecklistsRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Unarchive(ctx, bearertoken.Token(token), requestArg)
}

func (c *checklistServiceClientWithTokenProvider) GetCheck(ctx context.Context, ridArg api.CheckRid) (Check, error) {
	var defaultReturnVal Check
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetCheck(ctx, bearertoken.Token(token), ridArg)
}

func (c *checklistServiceClientWithTokenProvider) BatchGetChecks(ctx context.Context, ridsArg []api.CheckRid) ([]Check, error) {
	var defaultReturnVal []Check
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGetChecks(ctx, bearertoken.Token(token), ridsArg)
}

func (c *checklistServiceClientWithTokenProvider) GetAllLabelsAndProperties(ctx context.Context, workspacesArg []rids.WorkspaceRid) (GetAllLabelsAndPropertiesResponse, error) {
	var defaultReturnVal GetAllLabelsAndPropertiesResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetAllLabelsAndProperties(ctx, bearertoken.Token(token), workspacesArg)
}
