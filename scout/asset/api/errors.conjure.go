// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	api2 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/api"
	"github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type assetNotFound struct {
	AssetRid api.AssetRid `json:"assetRid"`
}

func (o assetNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *assetNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewAssetNotFound returns new instance of AssetNotFound error.
func NewAssetNotFound(assetRidArg api.AssetRid) *AssetNotFound {
	return &AssetNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), assetNotFound: assetNotFound{AssetRid: assetRidArg}}
}

// WrapWithAssetNotFound returns new instance of AssetNotFound error wrapping an existing error.
func WrapWithAssetNotFound(err error, assetRidArg api.AssetRid) *AssetNotFound {
	return &AssetNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, assetNotFound: assetNotFound{AssetRid: assetRidArg}}
}

// AssetNotFound is an error type.
type AssetNotFound struct {
	errorInstanceID uuid.UUID
	assetNotFound
	cause error
	stack werror.StackTrace
}

// IsAssetNotFound returns true if err is an instance of AssetNotFound.
func IsAssetNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*AssetNotFound)
	return ok
}

func (e *AssetNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Assets:AssetNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *AssetNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *AssetNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *AssetNotFound) Message() string {
	return "NOT_FOUND Assets:AssetNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *AssetNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *AssetNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *AssetNotFound) Name() string {
	return "Assets:AssetNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *AssetNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *AssetNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"assetRid": e.AssetRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *AssetNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"assetRid": e.AssetRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *AssetNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *AssetNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *AssetNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e AssetNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.assetNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Assets:AssetNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *AssetNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters assetNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.assetNotFound = parameters
	return nil
}

type assetsNotFound struct {
	AssetRids []api.AssetRid `json:"assetRids"`
}

func (o assetsNotFound) MarshalJSON() ([]byte, error) {
	if o.AssetRids == nil {
		o.AssetRids = make([]api.AssetRid, 0)
	}
	type _tmpassetsNotFound assetsNotFound
	return safejson.Marshal(_tmpassetsNotFound(o))
}

func (o *assetsNotFound) UnmarshalJSON(data []byte) error {
	type _tmpassetsNotFound assetsNotFound
	var rawassetsNotFound _tmpassetsNotFound
	if err := safejson.Unmarshal(data, &rawassetsNotFound); err != nil {
		return err
	}
	if rawassetsNotFound.AssetRids == nil {
		rawassetsNotFound.AssetRids = make([]api.AssetRid, 0)
	}
	*o = assetsNotFound(rawassetsNotFound)
	return nil
}

func (o assetsNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *assetsNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewAssetsNotFound returns new instance of AssetsNotFound error.
func NewAssetsNotFound(assetRidsArg []api.AssetRid) *AssetsNotFound {
	return &AssetsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), assetsNotFound: assetsNotFound{AssetRids: assetRidsArg}}
}

// WrapWithAssetsNotFound returns new instance of AssetsNotFound error wrapping an existing error.
func WrapWithAssetsNotFound(err error, assetRidsArg []api.AssetRid) *AssetsNotFound {
	return &AssetsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, assetsNotFound: assetsNotFound{AssetRids: assetRidsArg}}
}

// AssetsNotFound is an error type.
type AssetsNotFound struct {
	errorInstanceID uuid.UUID
	assetsNotFound
	cause error
	stack werror.StackTrace
}

// IsAssetsNotFound returns true if err is an instance of AssetsNotFound.
func IsAssetsNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*AssetsNotFound)
	return ok
}

func (e *AssetsNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Assets:AssetsNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *AssetsNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *AssetsNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *AssetsNotFound) Message() string {
	return "NOT_FOUND Assets:AssetsNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *AssetsNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *AssetsNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *AssetsNotFound) Name() string {
	return "Assets:AssetsNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *AssetsNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *AssetsNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"assetRids": e.AssetRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *AssetsNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"assetRids": e.AssetRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *AssetsNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *AssetsNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *AssetsNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e AssetsNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.assetsNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Assets:AssetsNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *AssetsNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters assetsNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.assetsNotFound = parameters
	return nil
}

type duplicateDataScopeNames struct {
	Names []api1.DataSourceRefName `json:"names"`
}

func (o duplicateDataScopeNames) MarshalJSON() ([]byte, error) {
	if o.Names == nil {
		o.Names = make([]api1.DataSourceRefName, 0)
	}
	type _tmpduplicateDataScopeNames duplicateDataScopeNames
	return safejson.Marshal(_tmpduplicateDataScopeNames(o))
}

func (o *duplicateDataScopeNames) UnmarshalJSON(data []byte) error {
	type _tmpduplicateDataScopeNames duplicateDataScopeNames
	var rawduplicateDataScopeNames _tmpduplicateDataScopeNames
	if err := safejson.Unmarshal(data, &rawduplicateDataScopeNames); err != nil {
		return err
	}
	if rawduplicateDataScopeNames.Names == nil {
		rawduplicateDataScopeNames.Names = make([]api1.DataSourceRefName, 0)
	}
	*o = duplicateDataScopeNames(rawduplicateDataScopeNames)
	return nil
}

func (o duplicateDataScopeNames) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *duplicateDataScopeNames) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDuplicateDataScopeNames returns new instance of DuplicateDataScopeNames error.
func NewDuplicateDataScopeNames(namesArg []api1.DataSourceRefName) *DuplicateDataScopeNames {
	return &DuplicateDataScopeNames{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), duplicateDataScopeNames: duplicateDataScopeNames{Names: namesArg}}
}

// WrapWithDuplicateDataScopeNames returns new instance of DuplicateDataScopeNames error wrapping an existing error.
func WrapWithDuplicateDataScopeNames(err error, namesArg []api1.DataSourceRefName) *DuplicateDataScopeNames {
	return &DuplicateDataScopeNames{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, duplicateDataScopeNames: duplicateDataScopeNames{Names: namesArg}}
}

// DuplicateDataScopeNames is an error type.
// Multiple data scopes within the same asset share the same refname
type DuplicateDataScopeNames struct {
	errorInstanceID uuid.UUID
	duplicateDataScopeNames
	cause error
	stack werror.StackTrace
}

// IsDuplicateDataScopeNames returns true if err is an instance of DuplicateDataScopeNames.
func IsDuplicateDataScopeNames(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DuplicateDataScopeNames)
	return ok
}

func (e *DuplicateDataScopeNames) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Assets:DuplicateDataScopeNames (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DuplicateDataScopeNames) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DuplicateDataScopeNames) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DuplicateDataScopeNames) Message() string {
	return "INVALID_ARGUMENT Assets:DuplicateDataScopeNames"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DuplicateDataScopeNames) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DuplicateDataScopeNames) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *DuplicateDataScopeNames) Name() string {
	return "Assets:DuplicateDataScopeNames"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DuplicateDataScopeNames) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DuplicateDataScopeNames) Parameters() map[string]interface{} {
	return map[string]interface{}{"names": e.Names}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DuplicateDataScopeNames) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DuplicateDataScopeNames) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DuplicateDataScopeNames) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"names": e.Names}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DuplicateDataScopeNames) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DuplicateDataScopeNames) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.duplicateDataScopeNames)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Assets:DuplicateDataScopeNames", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DuplicateDataScopeNames) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters duplicateDataScopeNames
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.duplicateDataScopeNames = parameters
	return nil
}

type typeAlreadyExists struct {
	TypeName string `json:"typeName"`
}

func (o typeAlreadyExists) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *typeAlreadyExists) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTypeAlreadyExists returns new instance of TypeAlreadyExists error.
func NewTypeAlreadyExists(typeNameArg string) *TypeAlreadyExists {
	return &TypeAlreadyExists{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), typeAlreadyExists: typeAlreadyExists{TypeName: typeNameArg}}
}

// WrapWithTypeAlreadyExists returns new instance of TypeAlreadyExists error wrapping an existing error.
func WrapWithTypeAlreadyExists(err error, typeNameArg string) *TypeAlreadyExists {
	return &TypeAlreadyExists{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, typeAlreadyExists: typeAlreadyExists{TypeName: typeNameArg}}
}

// TypeAlreadyExists is an error type.
type TypeAlreadyExists struct {
	errorInstanceID uuid.UUID
	typeAlreadyExists
	cause error
	stack werror.StackTrace
}

// IsTypeAlreadyExists returns true if err is an instance of TypeAlreadyExists.
func IsTypeAlreadyExists(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TypeAlreadyExists)
	return ok
}

func (e *TypeAlreadyExists) Error() string {
	return fmt.Sprintf("CONFLICT Assets:TypeAlreadyExists (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TypeAlreadyExists) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TypeAlreadyExists) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TypeAlreadyExists) Message() string {
	return "CONFLICT Assets:TypeAlreadyExists"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TypeAlreadyExists) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TypeAlreadyExists) Code() errors.ErrorCode {
	return errors.Conflict
}

// Name returns an error name identifying error type.
func (e *TypeAlreadyExists) Name() string {
	return "Assets:TypeAlreadyExists"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TypeAlreadyExists) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TypeAlreadyExists) Parameters() map[string]interface{} {
	return map[string]interface{}{"typeName": e.TypeName}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TypeAlreadyExists) safeParams() map[string]interface{} {
	return map[string]interface{}{"typeName": e.TypeName, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TypeAlreadyExists) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TypeAlreadyExists) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TypeAlreadyExists) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TypeAlreadyExists) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.typeAlreadyExists)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Conflict, ErrorName: "Assets:TypeAlreadyExists", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TypeAlreadyExists) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters typeAlreadyExists
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.typeAlreadyExists = parameters
	return nil
}

type typeCheckFailed struct {
	MissingProperties []api2.PropertyName `json:"missingProperties"`
}

func (o typeCheckFailed) MarshalJSON() ([]byte, error) {
	if o.MissingProperties == nil {
		o.MissingProperties = make([]api2.PropertyName, 0)
	}
	type _tmptypeCheckFailed typeCheckFailed
	return safejson.Marshal(_tmptypeCheckFailed(o))
}

func (o *typeCheckFailed) UnmarshalJSON(data []byte) error {
	type _tmptypeCheckFailed typeCheckFailed
	var rawtypeCheckFailed _tmptypeCheckFailed
	if err := safejson.Unmarshal(data, &rawtypeCheckFailed); err != nil {
		return err
	}
	if rawtypeCheckFailed.MissingProperties == nil {
		rawtypeCheckFailed.MissingProperties = make([]api2.PropertyName, 0)
	}
	*o = typeCheckFailed(rawtypeCheckFailed)
	return nil
}

func (o typeCheckFailed) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *typeCheckFailed) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTypeCheckFailed returns new instance of TypeCheckFailed error.
func NewTypeCheckFailed(missingPropertiesArg []api2.PropertyName) *TypeCheckFailed {
	return &TypeCheckFailed{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), typeCheckFailed: typeCheckFailed{MissingProperties: missingPropertiesArg}}
}

// WrapWithTypeCheckFailed returns new instance of TypeCheckFailed error wrapping an existing error.
func WrapWithTypeCheckFailed(err error, missingPropertiesArg []api2.PropertyName) *TypeCheckFailed {
	return &TypeCheckFailed{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, typeCheckFailed: typeCheckFailed{MissingProperties: missingPropertiesArg}}
}

// TypeCheckFailed is an error type.
// The type check failed for the following properties.
type TypeCheckFailed struct {
	errorInstanceID uuid.UUID
	typeCheckFailed
	cause error
	stack werror.StackTrace
}

// IsTypeCheckFailed returns true if err is an instance of TypeCheckFailed.
func IsTypeCheckFailed(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TypeCheckFailed)
	return ok
}

func (e *TypeCheckFailed) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Assets:TypeCheckFailed (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TypeCheckFailed) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TypeCheckFailed) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TypeCheckFailed) Message() string {
	return "INVALID_ARGUMENT Assets:TypeCheckFailed"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TypeCheckFailed) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TypeCheckFailed) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TypeCheckFailed) Name() string {
	return "Assets:TypeCheckFailed"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TypeCheckFailed) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TypeCheckFailed) Parameters() map[string]interface{} {
	return map[string]interface{}{"missingProperties": e.MissingProperties}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TypeCheckFailed) safeParams() map[string]interface{} {
	return map[string]interface{}{"missingProperties": e.MissingProperties, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TypeCheckFailed) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TypeCheckFailed) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TypeCheckFailed) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TypeCheckFailed) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.typeCheckFailed)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Assets:TypeCheckFailed", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TypeCheckFailed) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters typeCheckFailed
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.typeCheckFailed = parameters
	return nil
}

type typeNotFound struct {
	Rid api.TypeRid `json:"rid"`
}

func (o typeNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *typeNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTypeNotFound returns new instance of TypeNotFound error.
func NewTypeNotFound(ridArg api.TypeRid) *TypeNotFound {
	return &TypeNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), typeNotFound: typeNotFound{Rid: ridArg}}
}

// WrapWithTypeNotFound returns new instance of TypeNotFound error wrapping an existing error.
func WrapWithTypeNotFound(err error, ridArg api.TypeRid) *TypeNotFound {
	return &TypeNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, typeNotFound: typeNotFound{Rid: ridArg}}
}

// TypeNotFound is an error type.
type TypeNotFound struct {
	errorInstanceID uuid.UUID
	typeNotFound
	cause error
	stack werror.StackTrace
}

// IsTypeNotFound returns true if err is an instance of TypeNotFound.
func IsTypeNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TypeNotFound)
	return ok
}

func (e *TypeNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Assets:TypeNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TypeNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TypeNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TypeNotFound) Message() string {
	return "NOT_FOUND Assets:TypeNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TypeNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TypeNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *TypeNotFound) Name() string {
	return "Assets:TypeNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TypeNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TypeNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"rid": e.Rid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TypeNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"rid": e.Rid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TypeNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TypeNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TypeNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TypeNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.typeNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Assets:TypeNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TypeNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters typeNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.typeNotFound = parameters
	return nil
}

type typeReferencedByAssets struct {
	Rid api.TypeRid `json:"rid"`
}

func (o typeReferencedByAssets) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *typeReferencedByAssets) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTypeReferencedByAssets returns new instance of TypeReferencedByAssets error.
func NewTypeReferencedByAssets(ridArg api.TypeRid) *TypeReferencedByAssets {
	return &TypeReferencedByAssets{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), typeReferencedByAssets: typeReferencedByAssets{Rid: ridArg}}
}

// WrapWithTypeReferencedByAssets returns new instance of TypeReferencedByAssets error wrapping an existing error.
func WrapWithTypeReferencedByAssets(err error, ridArg api.TypeRid) *TypeReferencedByAssets {
	return &TypeReferencedByAssets{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, typeReferencedByAssets: typeReferencedByAssets{Rid: ridArg}}
}

// TypeReferencedByAssets is an error type.
// The type is referenced by one or more assets and cannot be deleted.
type TypeReferencedByAssets struct {
	errorInstanceID uuid.UUID
	typeReferencedByAssets
	cause error
	stack werror.StackTrace
}

// IsTypeReferencedByAssets returns true if err is an instance of TypeReferencedByAssets.
func IsTypeReferencedByAssets(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TypeReferencedByAssets)
	return ok
}

func (e *TypeReferencedByAssets) Error() string {
	return fmt.Sprintf("PERMISSION_DENIED Assets:TypeReferencedByAssets (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TypeReferencedByAssets) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TypeReferencedByAssets) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TypeReferencedByAssets) Message() string {
	return "PERMISSION_DENIED Assets:TypeReferencedByAssets"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TypeReferencedByAssets) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TypeReferencedByAssets) Code() errors.ErrorCode {
	return errors.PermissionDenied
}

// Name returns an error name identifying error type.
func (e *TypeReferencedByAssets) Name() string {
	return "Assets:TypeReferencedByAssets"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TypeReferencedByAssets) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TypeReferencedByAssets) Parameters() map[string]interface{} {
	return map[string]interface{}{"rid": e.Rid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TypeReferencedByAssets) safeParams() map[string]interface{} {
	return map[string]interface{}{"rid": e.Rid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TypeReferencedByAssets) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TypeReferencedByAssets) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TypeReferencedByAssets) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TypeReferencedByAssets) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.typeReferencedByAssets)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.PermissionDenied, ErrorName: "Assets:TypeReferencedByAssets", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TypeReferencedByAssets) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters typeReferencedByAssets
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.typeReferencedByAssets = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Assets:AssetNotFound", reflect.TypeOf(AssetNotFound{}))
	conjureerrors.RegisterErrorType("Assets:AssetsNotFound", reflect.TypeOf(AssetsNotFound{}))
	conjureerrors.RegisterErrorType("Assets:DuplicateDataScopeNames", reflect.TypeOf(DuplicateDataScopeNames{}))
	conjureerrors.RegisterErrorType("Assets:TypeAlreadyExists", reflect.TypeOf(TypeAlreadyExists{}))
	conjureerrors.RegisterErrorType("Assets:TypeCheckFailed", reflect.TypeOf(TypeCheckFailed{}))
	conjureerrors.RegisterErrorType("Assets:TypeNotFound", reflect.TypeOf(TypeNotFound{}))
	conjureerrors.RegisterErrorType("Assets:TypeReferencedByAssets", reflect.TypeOf(TypeReferencedByAssets{}))
}
