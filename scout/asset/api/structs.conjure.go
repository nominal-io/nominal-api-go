// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api/api/rids"
	api1 "github.com/nominal-io/nominal-api/io/nominal/api"
	api3 "github.com/nominal-io/nominal-api/scout/api"
	"github.com/nominal-io/nominal-api/scout/rids/api"
	api2 "github.com/nominal-io/nominal-api/scout/run/api"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type AddDataScopesToAssetRequest struct {
	/*
	   The data scopes to add to the asset.

	   Throws if any existing data scopes have data scope names that conflict with the data scope names
	   in the request.
	*/
	DataScopes []CreateAssetDataScope `conjure-docs:"The data scopes to add to the asset.\n\nThrows if any existing data scopes have data scope names that conflict with the data scope names\nin the request." json:"dataScopes"`
}

func (o AddDataScopesToAssetRequest) MarshalJSON() ([]byte, error) {
	if o.DataScopes == nil {
		o.DataScopes = make([]CreateAssetDataScope, 0)
	}
	type _tmpAddDataScopesToAssetRequest AddDataScopesToAssetRequest
	return safejson.Marshal(_tmpAddDataScopesToAssetRequest(o))
}

func (o *AddDataScopesToAssetRequest) UnmarshalJSON(data []byte) error {
	type _tmpAddDataScopesToAssetRequest AddDataScopesToAssetRequest
	var rawAddDataScopesToAssetRequest _tmpAddDataScopesToAssetRequest
	if err := safejson.Unmarshal(data, &rawAddDataScopesToAssetRequest); err != nil {
		return err
	}
	if rawAddDataScopesToAssetRequest.DataScopes == nil {
		rawAddDataScopesToAssetRequest.DataScopes = make([]CreateAssetDataScope, 0)
	}
	*o = AddDataScopesToAssetRequest(rawAddDataScopesToAssetRequest)
	return nil
}

func (o AddDataScopesToAssetRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AddDataScopesToAssetRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Asset struct {
	Rid         api.AssetRid                             `json:"rid"`
	Title       string                                   `json:"title"`
	Description *string                                  `json:"description,omitempty"`
	Properties  map[api1.PropertyName]api1.PropertyValue `json:"properties"`
	/*
	   Labels associated with the asset. These labels do not have a time dimension.
	   To associate labels with a range of time, create a time range on the asset with labels.
	*/
	Labels []api1.Label `conjure-docs:"Labels associated with the asset. These labels do not have a time dimension.\nTo associate labels with a range of time, create a time range on the asset with labels." json:"labels"`
	/*
	   Links associated with the asset. These links do not have a time dimension.
	   To associate links with a range of time, create a time range on the asset with links.
	*/
	Links []api2.Link `conjure-docs:"Links associated with the asset. These links do not have a time dimension.\nTo associate links with a range of time, create a time range on the asset with links." json:"links"`
	// The data scopes associated with the asset.
	DataScopes  []DataScope             `conjure-docs:"The data scopes associated with the asset." json:"dataScopes"`
	CreatedBy   *rid.ResourceIdentifier `json:"createdBy,omitempty"`
	CreatedAt   datetime.DateTime       `json:"createdAt"`
	UpdatedAt   datetime.DateTime       `json:"updatedAt"`
	Attachments []rids.AttachmentRid    `json:"attachments"`
	Type        *api.TypeRid            `json:"type,omitempty"`
	// Auto created assets are considered staged by default.
	IsStaged   bool `conjure-docs:"Auto created assets are considered staged by default." json:"isStaged"`
	IsArchived bool `json:"isArchived"`
}

func (o Asset) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[api1.PropertyName]api1.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api1.Label, 0)
	}
	if o.Links == nil {
		o.Links = make([]api2.Link, 0)
	}
	if o.DataScopes == nil {
		o.DataScopes = make([]DataScope, 0)
	}
	if o.Attachments == nil {
		o.Attachments = make([]rids.AttachmentRid, 0)
	}
	type _tmpAsset Asset
	return safejson.Marshal(_tmpAsset(o))
}

func (o *Asset) UnmarshalJSON(data []byte) error {
	type _tmpAsset Asset
	var rawAsset _tmpAsset
	if err := safejson.Unmarshal(data, &rawAsset); err != nil {
		return err
	}
	if rawAsset.Properties == nil {
		rawAsset.Properties = make(map[api1.PropertyName]api1.PropertyValue, 0)
	}
	if rawAsset.Labels == nil {
		rawAsset.Labels = make([]api1.Label, 0)
	}
	if rawAsset.Links == nil {
		rawAsset.Links = make([]api2.Link, 0)
	}
	if rawAsset.DataScopes == nil {
		rawAsset.DataScopes = make([]DataScope, 0)
	}
	if rawAsset.Attachments == nil {
		rawAsset.Attachments = make([]rids.AttachmentRid, 0)
	}
	*o = Asset(rawAsset)
	return nil
}

func (o Asset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Asset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AssetSortOptions struct {
	IsDescending bool `json:"isDescending"`
	// Deprecated: use SortKey with SortField union type instead
	Field *SortField `json:"field,omitempty"`
	/*
	   Field to sort by. Includes both field and property-based sorting.
	   Must be supplied if field is not provided separately.
	*/
	SortKey *SortKey `conjure-docs:"Field to sort by. Includes both field and property-based sorting.\nMust be supplied if field is not provided separately." json:"sortKey,omitempty"`
}

func (o AssetSortOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AssetSortOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AssetTypeDataScopeConfig struct {
	SuggestedRefName *string `json:"suggestedRefName,omitempty"`
	/*
	   Tag names that should be supplied to downscope data for an asset of the asset type. These are not
	   enforced.
	*/
	Tags TagConfig `conjure-docs:"Tag names that should be supplied to downscope data for an asset of the asset type. These are not \nenforced." json:"tags"`
}

func (o AssetTypeDataScopeConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AssetTypeDataScopeConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelMetadata struct {
	Name        Channel              `json:"name"`
	DataSource  api2.DataSource      `json:"dataSource"`
	Unit        *api2.Unit           `json:"unit,omitempty"`
	Description *string              `json:"description,omitempty"`
	DataType    *api1.SeriesDataType `json:"dataType,omitempty"`
}

func (o ChannelMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateAssetDataScope struct {
	// The name of the data scope. The name is guaranteed to be be unique within the context of an asset.
	DataScopeName api3.DataSourceRefName `conjure-docs:"The name of the data scope. The name is guaranteed to be be unique within the context of an asset." json:"dataScopeName"`
	DataSource    api2.DataSource        `json:"dataSource"`
	Offset        *api2.Duration         `json:"offset,omitempty"`
	/*
	   Filters the data source to series matching these tag values. The filtered set of series should be
	   the ones that belong to the asset.
	*/
	SeriesTags map[api1.TagName]api1.TagValue `conjure-docs:"Filters the data source to series matching these tag values. The filtered set of series should be\nthe ones that belong to the asset." json:"seriesTags"`
}

func (o CreateAssetDataScope) MarshalJSON() ([]byte, error) {
	if o.SeriesTags == nil {
		o.SeriesTags = make(map[api1.TagName]api1.TagValue, 0)
	}
	type _tmpCreateAssetDataScope CreateAssetDataScope
	return safejson.Marshal(_tmpCreateAssetDataScope(o))
}

func (o *CreateAssetDataScope) UnmarshalJSON(data []byte) error {
	type _tmpCreateAssetDataScope CreateAssetDataScope
	var rawCreateAssetDataScope _tmpCreateAssetDataScope
	if err := safejson.Unmarshal(data, &rawCreateAssetDataScope); err != nil {
		return err
	}
	if rawCreateAssetDataScope.SeriesTags == nil {
		rawCreateAssetDataScope.SeriesTags = make(map[api1.TagName]api1.TagValue, 0)
	}
	*o = CreateAssetDataScope(rawCreateAssetDataScope)
	return nil
}

func (o CreateAssetDataScope) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateAssetDataScope) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateAssetRequest struct {
	Title       string                                   `json:"title"`
	Description *string                                  `json:"description,omitempty"`
	Properties  map[api1.PropertyName]api1.PropertyValue `json:"properties"`
	Labels      []api1.Label                             `json:"labels"`
	Links       []api2.Link                              `json:"links"`
	// The data scopes associated with the asset.
	DataScopes  []CreateAssetDataScope `conjure-docs:"The data scopes associated with the asset." json:"dataScopes"`
	Attachments []rids.AttachmentRid   `json:"attachments"`
	Type        *api.TypeRid           `json:"type,omitempty"`
	/*
	   The workspace in which to create the asset. If not provided, the asset will be created in
	   the default workspace for the user's organization, if the default workspace for the
	   organization is configured.
	   All data scopes, attachments, and the optional asset type must be in the same workspace.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the asset. If not provided, the asset will be created in\nthe default workspace for the user's organization, if the default workspace for the\norganization is configured.\nAll data scopes, attachments, and the optional asset type must be in the same workspace." json:"workspace,omitempty"`
}

func (o CreateAssetRequest) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[api1.PropertyName]api1.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api1.Label, 0)
	}
	if o.Links == nil {
		o.Links = make([]api2.Link, 0)
	}
	if o.DataScopes == nil {
		o.DataScopes = make([]CreateAssetDataScope, 0)
	}
	if o.Attachments == nil {
		o.Attachments = make([]rids.AttachmentRid, 0)
	}
	type _tmpCreateAssetRequest CreateAssetRequest
	return safejson.Marshal(_tmpCreateAssetRequest(o))
}

func (o *CreateAssetRequest) UnmarshalJSON(data []byte) error {
	type _tmpCreateAssetRequest CreateAssetRequest
	var rawCreateAssetRequest _tmpCreateAssetRequest
	if err := safejson.Unmarshal(data, &rawCreateAssetRequest); err != nil {
		return err
	}
	if rawCreateAssetRequest.Properties == nil {
		rawCreateAssetRequest.Properties = make(map[api1.PropertyName]api1.PropertyValue, 0)
	}
	if rawCreateAssetRequest.Labels == nil {
		rawCreateAssetRequest.Labels = make([]api1.Label, 0)
	}
	if rawCreateAssetRequest.Links == nil {
		rawCreateAssetRequest.Links = make([]api2.Link, 0)
	}
	if rawCreateAssetRequest.DataScopes == nil {
		rawCreateAssetRequest.DataScopes = make([]CreateAssetDataScope, 0)
	}
	if rawCreateAssetRequest.Attachments == nil {
		rawCreateAssetRequest.Attachments = make([]rids.AttachmentRid, 0)
	}
	*o = CreateAssetRequest(rawCreateAssetRequest)
	return nil
}

func (o CreateAssetRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateAssetRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateTypeRequest struct {
	Name            string                               `json:"name"`
	PropertyConfigs map[api1.PropertyName]PropertyConfig `json:"propertyConfigs"`
	Description     *string                              `json:"description,omitempty"`
	IconName        *string                              `json:"iconName,omitempty"`
	/*
	   The workspace in which to create the asset type. If not provided, the asset type will be created in
	   the default workspace for the user's organization, if the default workspace for the
	   organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the asset type. If not provided, the asset type will be created in\nthe default workspace for the user's organization, if the default workspace for the\norganization is configured." json:"workspace,omitempty"`
	/*
	   The configuration outlines what a data scope should provide when added to an asset of this type. It is
	   referenced at data scope creation time, but does not actively modify existing data scopes.
	*/
	DatasourceConfigs *map[rids.DataSourceRid]AssetTypeDataScopeConfig `conjure-docs:"The configuration outlines what a data scope should provide when added to an asset of this type. It is \nreferenced at data scope creation time, but does not actively modify existing data scopes." json:"datasourceConfigs,omitempty"`
}

func (o CreateTypeRequest) MarshalJSON() ([]byte, error) {
	if o.PropertyConfigs == nil {
		o.PropertyConfigs = make(map[api1.PropertyName]PropertyConfig, 0)
	}
	type _tmpCreateTypeRequest CreateTypeRequest
	return safejson.Marshal(_tmpCreateTypeRequest(o))
}

func (o *CreateTypeRequest) UnmarshalJSON(data []byte) error {
	type _tmpCreateTypeRequest CreateTypeRequest
	var rawCreateTypeRequest _tmpCreateTypeRequest
	if err := safejson.Unmarshal(data, &rawCreateTypeRequest); err != nil {
		return err
	}
	if rawCreateTypeRequest.PropertyConfigs == nil {
		rawCreateTypeRequest.PropertyConfigs = make(map[api1.PropertyName]PropertyConfig, 0)
	}
	*o = CreateTypeRequest(rawCreateTypeRequest)
	return nil
}

func (o CreateTypeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateTypeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataScope struct {
	// The name of the data scope. The name is guaranteed to be be unique within the context of an asset.
	DataScopeName api3.DataSourceRefName `conjure-docs:"The name of the data scope. The name is guaranteed to be be unique within the context of an asset." json:"dataScopeName"`
	DataSource    api2.DataSource        `json:"dataSource"`
	Offset        *api2.Duration         `json:"offset,omitempty"`
	TimestampType api2.WeakTimestampType `json:"timestampType"`
	/*
	   Filters the data source to series matching these tag values. The filtered set of series should be
	   the ones that belong to the asset.
	*/
	SeriesTags map[api1.TagName]api1.TagValue `conjure-docs:"Filters the data source to series matching these tag values. The filtered set of series should be\nthe ones that belong to the asset." json:"seriesTags"`
}

func (o DataScope) MarshalJSON() ([]byte, error) {
	if o.SeriesTags == nil {
		o.SeriesTags = make(map[api1.TagName]api1.TagValue, 0)
	}
	type _tmpDataScope DataScope
	return safejson.Marshal(_tmpDataScope(o))
}

func (o *DataScope) UnmarshalJSON(data []byte) error {
	type _tmpDataScope DataScope
	var rawDataScope _tmpDataScope
	if err := safejson.Unmarshal(data, &rawDataScope); err != nil {
		return err
	}
	if rawDataScope.SeriesTags == nil {
		rawDataScope.SeriesTags = make(map[api1.TagName]api1.TagValue, 0)
	}
	*o = DataScope(rawDataScope)
	return nil
}

func (o DataScope) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataScope) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PropertyConfig struct {
	IsRequired  bool    `json:"isRequired"`
	Description *string `json:"description,omitempty"`
}

func (o PropertyConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PropertyConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The request to remove the type from the asset.
type RemoveType struct{}

func (o RemoveType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RemoveType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchAssetChannelsRequest struct {
	SearchText string `json:"searchText"`
	// If not empty, will filter to channels from the selected data scope names.
	DataScopeNameFilter *[]api3.DataSourceRefName `conjure-docs:"If not empty, will filter to channels from the selected data scope names." json:"dataScopeNameFilter,omitempty"`
	NextPageToken       *api1.Token               `json:"nextPageToken,omitempty"`
	// Defaults to 1000. Will throw if larger than 10000. Default pageSize is 100.
	PageSize *int `conjure-docs:"Defaults to 1000. Will throw if larger than 10000. Default pageSize is 100." json:"pageSize,omitempty"`
}

func (o SearchAssetChannelsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchAssetChannelsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchAssetChannelsResponse struct {
	Results       []ChannelMetadata `json:"results"`
	NextPageToken *api1.Token       `json:"nextPageToken,omitempty"`
}

func (o SearchAssetChannelsResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ChannelMetadata, 0)
	}
	type _tmpSearchAssetChannelsResponse SearchAssetChannelsResponse
	return safejson.Marshal(_tmpSearchAssetChannelsResponse(o))
}

func (o *SearchAssetChannelsResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchAssetChannelsResponse SearchAssetChannelsResponse
	var rawSearchAssetChannelsResponse _tmpSearchAssetChannelsResponse
	if err := safejson.Unmarshal(data, &rawSearchAssetChannelsResponse); err != nil {
		return err
	}
	if rawSearchAssetChannelsResponse.Results == nil {
		rawSearchAssetChannelsResponse.Results = make([]ChannelMetadata, 0)
	}
	*o = SearchAssetChannelsResponse(rawSearchAssetChannelsResponse)
	return nil
}

func (o SearchAssetChannelsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchAssetChannelsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchAssetsRequest struct {
	Sort AssetSortOptions `json:"sort"`
	// Page sizes greater than 10_000 will be rejected. Default pageSize is 100.
	PageSize      *int              `conjure-docs:"Page sizes greater than 10_000 will be rejected. Default pageSize is 100." json:"pageSize,omitempty"`
	NextPageToken *api1.Token       `json:"nextPageToken,omitempty"`
	Query         SearchAssetsQuery `json:"query"`
	// Default search status is NOT_ARCHIVED if none are provided. Allows for including archived assets in search.
	ArchivedStatuses *[]api1.ArchivedStatus `conjure-docs:"Default search status is NOT_ARCHIVED if none are provided. Allows for including archived assets in search." json:"archivedStatuses,omitempty"`
}

func (o SearchAssetsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchAssetsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchAssetsResponse struct {
	Results       []Asset     `json:"results"`
	NextPageToken *api1.Token `json:"nextPageToken,omitempty"`
}

func (o SearchAssetsResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]Asset, 0)
	}
	type _tmpSearchAssetsResponse SearchAssetsResponse
	return safejson.Marshal(_tmpSearchAssetsResponse(o))
}

func (o *SearchAssetsResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchAssetsResponse SearchAssetsResponse
	var rawSearchAssetsResponse _tmpSearchAssetsResponse
	if err := safejson.Unmarshal(data, &rawSearchAssetsResponse); err != nil {
		return err
	}
	if rawSearchAssetsResponse.Results == nil {
		rawSearchAssetsResponse.Results = make([]Asset, 0)
	}
	*o = SearchAssetsResponse(rawSearchAssetsResponse)
	return nil
}

func (o SearchAssetsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchAssetsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchTypesRequest struct {
	Sort TypeSortOptions `json:"sort"`
	// Page sizes greater than 10_000 will be rejected. Default pageSize is 100.
	PageSize      *int             `conjure-docs:"Page sizes greater than 10_000 will be rejected. Default pageSize is 100." json:"pageSize,omitempty"`
	NextPageToken *api1.Token      `json:"nextPageToken,omitempty"`
	Query         SearchTypesQuery `json:"query"`
	// Default search status is NOT_ARCHIVED if none are provided. Allows for including archived assets in search.
	ArchivedStatuses *[]api1.ArchivedStatus `conjure-docs:"Default search status is NOT_ARCHIVED if none are provided. Allows for including archived assets in search." json:"archivedStatuses,omitempty"`
}

func (o SearchTypesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchTypesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchTypesResponse struct {
	Results       []Type      `json:"results"`
	NextPageToken *api1.Token `json:"nextPageToken,omitempty"`
}

func (o SearchTypesResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]Type, 0)
	}
	type _tmpSearchTypesResponse SearchTypesResponse
	return safejson.Marshal(_tmpSearchTypesResponse(o))
}

func (o *SearchTypesResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchTypesResponse SearchTypesResponse
	var rawSearchTypesResponse _tmpSearchTypesResponse
	if err := safejson.Unmarshal(data, &rawSearchTypesResponse); err != nil {
		return err
	}
	if rawSearchTypesResponse.Results == nil {
		rawSearchTypesResponse.Results = make([]Type, 0)
	}
	*o = SearchTypesResponse(rawSearchTypesResponse)
	return nil
}

func (o SearchTypesResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchTypesResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SortProperty struct {
	Name api1.PropertyName `json:"name"`
}

func (o SortProperty) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SortProperty) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Type struct {
	Rid             api.TypeRid                          `json:"rid"`
	Name            string                               `json:"name"`
	Description     *string                              `json:"description,omitempty"`
	PropertyConfigs map[api1.PropertyName]PropertyConfig `json:"propertyConfigs"`
	CreatedAt       datetime.DateTime                    `json:"createdAt"`
	// The name of the icon to display for the type. This name maps to a Lucide icon in the frontend.
	IconName *string `conjure-docs:"The name of the icon to display for the type. This name maps to a Lucide icon in the frontend." json:"iconName,omitempty"`
	/*
	   The configuration outlines what a data scope should provide when added to an asset of this type. It is
	   referenced at data scope creation time, but does not actively modify existing data scopes.
	*/
	DatasourceConfigs map[rids.DataSourceRid]AssetTypeDataScopeConfig `conjure-docs:"The configuration outlines what a data scope should provide when added to an asset of this type. It is \nreferenced at data scope creation time, but does not actively modify existing data scopes." json:"datasourceConfigs"`
}

func (o Type) MarshalJSON() ([]byte, error) {
	if o.PropertyConfigs == nil {
		o.PropertyConfigs = make(map[api1.PropertyName]PropertyConfig, 0)
	}
	if o.DatasourceConfigs == nil {
		o.DatasourceConfigs = make(map[rids.DataSourceRid]AssetTypeDataScopeConfig, 0)
	}
	type _tmpType Type
	return safejson.Marshal(_tmpType(o))
}

func (o *Type) UnmarshalJSON(data []byte) error {
	type _tmpType Type
	var rawType _tmpType
	if err := safejson.Unmarshal(data, &rawType); err != nil {
		return err
	}
	if rawType.PropertyConfigs == nil {
		rawType.PropertyConfigs = make(map[api1.PropertyName]PropertyConfig, 0)
	}
	if rawType.DatasourceConfigs == nil {
		rawType.DatasourceConfigs = make(map[rids.DataSourceRid]AssetTypeDataScopeConfig, 0)
	}
	*o = Type(rawType)
	return nil
}

func (o Type) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Type) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TypeSortOptions struct {
	IsDescending bool      `json:"isDescending"`
	Field        SortField `json:"field"`
}

func (o TypeSortOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TypeSortOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateAssetRefNamesRequest struct {
	DataScopeRefNameUpdates map[api3.DataSourceRefName]api3.DataSourceRefName `json:"dataScopeRefNameUpdates"`
}

func (o UpdateAssetRefNamesRequest) MarshalJSON() ([]byte, error) {
	if o.DataScopeRefNameUpdates == nil {
		o.DataScopeRefNameUpdates = make(map[api3.DataSourceRefName]api3.DataSourceRefName, 0)
	}
	type _tmpUpdateAssetRefNamesRequest UpdateAssetRefNamesRequest
	return safejson.Marshal(_tmpUpdateAssetRefNamesRequest(o))
}

func (o *UpdateAssetRefNamesRequest) UnmarshalJSON(data []byte) error {
	type _tmpUpdateAssetRefNamesRequest UpdateAssetRefNamesRequest
	var rawUpdateAssetRefNamesRequest _tmpUpdateAssetRefNamesRequest
	if err := safejson.Unmarshal(data, &rawUpdateAssetRefNamesRequest); err != nil {
		return err
	}
	if rawUpdateAssetRefNamesRequest.DataScopeRefNameUpdates == nil {
		rawUpdateAssetRefNamesRequest.DataScopeRefNameUpdates = make(map[api3.DataSourceRefName]api3.DataSourceRefName, 0)
	}
	*o = UpdateAssetRefNamesRequest(rawUpdateAssetRefNamesRequest)
	return nil
}

func (o UpdateAssetRefNamesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateAssetRefNamesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateAssetRequest struct {
	Title       *string                                   `json:"title,omitempty"`
	Description *string                                   `json:"description,omitempty"`
	Properties  *map[api1.PropertyName]api1.PropertyValue `json:"properties,omitempty"`
	Labels      *[]api1.Label                             `json:"labels,omitempty"`
	Links       *[]api2.Link                              `json:"links,omitempty"`
	// The data scopes for the asset. This will replace all existing data scopes with the scopes specified.
	DataScopes *[]CreateAssetDataScope  `conjure-docs:"The data scopes for the asset. This will replace all existing data scopes with the scopes specified." json:"dataScopes,omitempty"`
	Type       *UpdateOrRemoveAssetType `json:"type,omitempty"`
	IsStaged   *bool                    `json:"isStaged,omitempty"`
}

func (o UpdateAssetRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateAssetRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateAttachmentsRequest struct {
	AttachmentsToAdd    []rids.AttachmentRid `json:"attachmentsToAdd"`
	AttachmentsToRemove []rids.AttachmentRid `json:"attachmentsToRemove"`
}

func (o UpdateAttachmentsRequest) MarshalJSON() ([]byte, error) {
	if o.AttachmentsToAdd == nil {
		o.AttachmentsToAdd = make([]rids.AttachmentRid, 0)
	}
	if o.AttachmentsToRemove == nil {
		o.AttachmentsToRemove = make([]rids.AttachmentRid, 0)
	}
	type _tmpUpdateAttachmentsRequest UpdateAttachmentsRequest
	return safejson.Marshal(_tmpUpdateAttachmentsRequest(o))
}

func (o *UpdateAttachmentsRequest) UnmarshalJSON(data []byte) error {
	type _tmpUpdateAttachmentsRequest UpdateAttachmentsRequest
	var rawUpdateAttachmentsRequest _tmpUpdateAttachmentsRequest
	if err := safejson.Unmarshal(data, &rawUpdateAttachmentsRequest); err != nil {
		return err
	}
	if rawUpdateAttachmentsRequest.AttachmentsToAdd == nil {
		rawUpdateAttachmentsRequest.AttachmentsToAdd = make([]rids.AttachmentRid, 0)
	}
	if rawUpdateAttachmentsRequest.AttachmentsToRemove == nil {
		rawUpdateAttachmentsRequest.AttachmentsToRemove = make([]rids.AttachmentRid, 0)
	}
	*o = UpdateAttachmentsRequest(rawUpdateAttachmentsRequest)
	return nil
}

func (o UpdateAttachmentsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateAttachmentsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The request to update a type. The request will replace all existing properties with the properties
specified in the request.
*/
type UpdateTypeRequest struct {
	Name            *string                               `json:"name,omitempty"`
	PropertyConfigs *map[api1.PropertyName]PropertyConfig `json:"propertyConfigs,omitempty"`
	Description     *string                               `json:"description,omitempty"`
	IconName        *string                               `json:"iconName,omitempty"`
	/*
	   The configuration outlines what a data scope should provide when added to an asset of this type. It is
	   referenced at data scope creation time, but does not actively modify existing data scopes.
	*/
	DatasourceConfigs *map[rids.DataSourceRid]AssetTypeDataScopeConfig `conjure-docs:"The configuration outlines what a data scope should provide when added to an asset of this type. It is \nreferenced at data scope creation time, but does not actively modify existing data scopes." json:"datasourceConfigs,omitempty"`
}

func (o UpdateTypeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateTypeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
