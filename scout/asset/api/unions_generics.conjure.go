// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/rids/api"
)

type SearchAssetsQueryWithT[T any] SearchAssetsQuery

func (u *SearchAssetsQueryWithT[T]) Accept(ctx context.Context, v SearchAssetsQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(ctx, *u.searchText)
	case "exactSubstring":
		if u.exactSubstring == nil {
			return result, fmt.Errorf("field \"exactSubstring\" is required")
		}
		return v.VisitExactSubstring(ctx, *u.exactSubstring)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(ctx, *u.label)
	case "labels":
		if u.labels == nil {
			return result, fmt.Errorf("field \"labels\" is required")
		}
		return v.VisitLabels(ctx, *u.labels)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	case "properties":
		if u.properties == nil {
			return result, fmt.Errorf("field \"properties\" is required")
		}
		return v.VisitProperties(ctx, *u.properties)
	case "typeRid":
		if u.typeRid == nil {
			return result, fmt.Errorf("field \"typeRid\" is required")
		}
		return v.VisitTypeRid(ctx, *u.typeRid)
	case "assetTypes":
		if u.assetTypes == nil {
			return result, fmt.Errorf("field \"assetTypes\" is required")
		}
		return v.VisitAssetTypes(ctx, *u.assetTypes)
	case "isStaged":
		if u.isStaged == nil {
			return result, fmt.Errorf("field \"isStaged\" is required")
		}
		return v.VisitIsStaged(ctx, *u.isStaged)
	case "archived":
		if u.archived == nil {
			return result, fmt.Errorf("field \"archived\" is required")
		}
		return v.VisitArchived(ctx, *u.archived)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	}
}

func (u *SearchAssetsQueryWithT[T]) AcceptFuncs(searchTextFunc func(string) (T, error), exactSubstringFunc func(string) (T, error), labelFunc func(api.Label) (T, error), labelsFunc func(api1.LabelsFilter) (T, error), propertyFunc func(api.Property) (T, error), propertiesFunc func(api1.PropertiesFilter) (T, error), typeRidFunc func(api1.TypeRid) (T, error), assetTypesFunc func(AssetTypesFilter) (T, error), isStagedFunc func(bool) (T, error), archivedFunc func(bool) (T, error), andFunc func([]SearchAssetsQuery) (T, error), orFunc func([]SearchAssetsQuery) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "exactSubstring":
		if u.exactSubstring == nil {
			return result, fmt.Errorf("field \"exactSubstring\" is required")
		}
		return exactSubstringFunc(*u.exactSubstring)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "labels":
		if u.labels == nil {
			return result, fmt.Errorf("field \"labels\" is required")
		}
		return labelsFunc(*u.labels)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "properties":
		if u.properties == nil {
			return result, fmt.Errorf("field \"properties\" is required")
		}
		return propertiesFunc(*u.properties)
	case "typeRid":
		if u.typeRid == nil {
			return result, fmt.Errorf("field \"typeRid\" is required")
		}
		return typeRidFunc(*u.typeRid)
	case "assetTypes":
		if u.assetTypes == nil {
			return result, fmt.Errorf("field \"assetTypes\" is required")
		}
		return assetTypesFunc(*u.assetTypes)
	case "isStaged":
		if u.isStaged == nil {
			return result, fmt.Errorf("field \"isStaged\" is required")
		}
		return isStagedFunc(*u.isStaged)
	case "archived":
		if u.archived == nil {
			return result, fmt.Errorf("field \"archived\" is required")
		}
		return archivedFunc(*u.archived)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchAssetsQueryWithT[T]) SearchTextNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) ExactSubstringNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) LabelNoopSuccess(api.Label) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) LabelsNoopSuccess(api1.LabelsFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) PropertyNoopSuccess(api.Property) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) PropertiesNoopSuccess(api1.PropertiesFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) TypeRidNoopSuccess(api1.TypeRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) AssetTypesNoopSuccess(AssetTypesFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) IsStagedNoopSuccess(bool) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) ArchivedNoopSuccess(bool) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) AndNoopSuccess([]SearchAssetsQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) OrNoopSuccess([]SearchAssetsQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchAssetsQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchAssetsQueryVisitorWithT[T any] interface {
	VisitSearchText(ctx context.Context, v string) (T, error)
	VisitExactSubstring(ctx context.Context, v string) (T, error)
	VisitLabel(ctx context.Context, v api.Label) (T, error)
	VisitLabels(ctx context.Context, v api1.LabelsFilter) (T, error)
	VisitProperty(ctx context.Context, v api.Property) (T, error)
	VisitProperties(ctx context.Context, v api1.PropertiesFilter) (T, error)
	VisitTypeRid(ctx context.Context, v api1.TypeRid) (T, error)
	VisitAssetTypes(ctx context.Context, v AssetTypesFilter) (T, error)
	VisitIsStaged(ctx context.Context, v bool) (T, error)
	VisitArchived(ctx context.Context, v bool) (T, error)
	VisitAnd(ctx context.Context, v []SearchAssetsQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchAssetsQuery) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SearchTypesQueryWithT[T any] SearchTypesQuery

func (u *SearchTypesQueryWithT[T]) Accept(ctx context.Context, v SearchTypesQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(ctx, *u.searchText)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	case "configuredDatasource":
		if u.configuredDatasource == nil {
			return result, fmt.Errorf("field \"configuredDatasource\" is required")
		}
		return v.VisitConfiguredDatasource(ctx, *u.configuredDatasource)
	}
}

func (u *SearchTypesQueryWithT[T]) AcceptFuncs(searchTextFunc func(string) (T, error), propertyFunc func(api.PropertyName) (T, error), andFunc func([]SearchTypesQuery) (T, error), orFunc func([]SearchTypesQuery) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), configuredDatasourceFunc func(rids.DataSourceRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	case "configuredDatasource":
		if u.configuredDatasource == nil {
			return result, fmt.Errorf("field \"configuredDatasource\" is required")
		}
		return configuredDatasourceFunc(*u.configuredDatasource)
	}
}

func (u *SearchTypesQueryWithT[T]) SearchTextNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTypesQueryWithT[T]) PropertyNoopSuccess(api.PropertyName) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTypesQueryWithT[T]) AndNoopSuccess([]SearchTypesQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTypesQueryWithT[T]) OrNoopSuccess([]SearchTypesQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTypesQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTypesQueryWithT[T]) ConfiguredDatasourceNoopSuccess(rids.DataSourceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchTypesQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchTypesQueryVisitorWithT[T any] interface {
	VisitSearchText(ctx context.Context, v string) (T, error)
	VisitProperty(ctx context.Context, v api.PropertyName) (T, error)
	VisitAnd(ctx context.Context, v []SearchTypesQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchTypesQuery) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitConfiguredDatasource(ctx context.Context, v rids.DataSourceRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SortKeyWithT[T any] SortKey

func (u *SortKeyWithT[T]) Accept(ctx context.Context, v SortKeyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "field":
		if u.field == nil {
			return result, fmt.Errorf("field \"field\" is required")
		}
		return v.VisitField(ctx, *u.field)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	}
}

func (u *SortKeyWithT[T]) AcceptFuncs(fieldFunc func(AssetSortField) (T, error), propertyFunc func(SortProperty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "field":
		if u.field == nil {
			return result, fmt.Errorf("field \"field\" is required")
		}
		return fieldFunc(*u.field)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	}
}

func (u *SortKeyWithT[T]) FieldNoopSuccess(AssetSortField) (T, error) {
	var result T
	return result, nil
}

func (u *SortKeyWithT[T]) PropertyNoopSuccess(SortProperty) (T, error) {
	var result T
	return result, nil
}

func (u *SortKeyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SortKeyVisitorWithT[T any] interface {
	VisitField(ctx context.Context, v AssetSortField) (T, error)
	VisitProperty(ctx context.Context, v SortProperty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TagConfigWithT[T any] TagConfig

func (u *TagConfigWithT[T]) Accept(ctx context.Context, v TagConfigVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *TagConfigWithT[T]) AcceptFuncs(v1Func func([]api.TagName) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *TagConfigWithT[T]) V1NoopSuccess([]api.TagName) (T, error) {
	var result T
	return result, nil
}

func (u *TagConfigWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TagConfigVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v []api.TagName) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UpdateOrRemoveAssetTypeWithT[T any] UpdateOrRemoveAssetType

func (u *UpdateOrRemoveAssetTypeWithT[T]) Accept(ctx context.Context, v UpdateOrRemoveAssetTypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "typeRid":
		if u.typeRid == nil {
			return result, fmt.Errorf("field \"typeRid\" is required")
		}
		return v.VisitTypeRid(ctx, *u.typeRid)
	case "removeType":
		if u.removeType == nil {
			return result, fmt.Errorf("field \"removeType\" is required")
		}
		return v.VisitRemoveType(ctx, *u.removeType)
	}
}

func (u *UpdateOrRemoveAssetTypeWithT[T]) AcceptFuncs(typeRidFunc func(api1.TypeRid) (T, error), removeTypeFunc func(RemoveType) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "typeRid":
		if u.typeRid == nil {
			return result, fmt.Errorf("field \"typeRid\" is required")
		}
		return typeRidFunc(*u.typeRid)
	case "removeType":
		if u.removeType == nil {
			return result, fmt.Errorf("field \"removeType\" is required")
		}
		return removeTypeFunc(*u.removeType)
	}
}

func (u *UpdateOrRemoveAssetTypeWithT[T]) TypeRidNoopSuccess(api1.TypeRid) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateOrRemoveAssetTypeWithT[T]) RemoveTypeNoopSuccess(RemoveType) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateOrRemoveAssetTypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UpdateOrRemoveAssetTypeVisitorWithT[T any] interface {
	VisitTypeRid(ctx context.Context, v api1.TypeRid) (T, error)
	VisitRemoveType(ctx context.Context, v RemoveType) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
