// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type SearchAssetsQuery struct {
	typ            string
	searchText     *string
	exactSubstring *string
	label          *api.Label
	property       *api.Property
	typeRid        *api1.TypeRid
	and            *[]SearchAssetsQuery
	or             *[]SearchAssetsQuery
	isStaged       *bool
	workspace      *rids.WorkspaceRid
}

type searchAssetsQueryDeserializer struct {
	Type           string               `json:"type"`
	SearchText     *string              `json:"searchText"`
	ExactSubstring *string              `json:"exactSubstring"`
	Label          *api.Label           `json:"label"`
	Property       *api.Property        `json:"property"`
	TypeRid        *api1.TypeRid        `json:"typeRid"`
	And            *[]SearchAssetsQuery `json:"and"`
	Or             *[]SearchAssetsQuery `json:"or"`
	IsStaged       *bool                `json:"isStaged"`
	Workspace      *rids.WorkspaceRid   `json:"workspace"`
}

func (u *searchAssetsQueryDeserializer) toStruct() SearchAssetsQuery {
	return SearchAssetsQuery{typ: u.Type, searchText: u.SearchText, exactSubstring: u.ExactSubstring, label: u.Label, property: u.Property, typeRid: u.TypeRid, and: u.And, or: u.Or, isStaged: u.IsStaged, workspace: u.Workspace}
}

func (u *SearchAssetsQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "exactSubstring":
		if u.exactSubstring == nil {
			return nil, fmt.Errorf("field \"exactSubstring\" is required")
		}
		return struct {
			Type           string `json:"type"`
			ExactSubstring string `json:"exactSubstring"`
		}{Type: "exactSubstring", ExactSubstring: *u.exactSubstring}, nil
	case "label":
		if u.label == nil {
			return nil, fmt.Errorf("field \"label\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Label api.Label `json:"label"`
		}{Type: "label", Label: *u.label}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Property api.Property `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "typeRid":
		if u.typeRid == nil {
			return nil, fmt.Errorf("field \"typeRid\" is required")
		}
		return struct {
			Type    string       `json:"type"`
			TypeRid api1.TypeRid `json:"typeRid"`
		}{Type: "typeRid", TypeRid: *u.typeRid}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string              `json:"type"`
			And  []SearchAssetsQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string              `json:"type"`
			Or   []SearchAssetsQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "isStaged":
		if u.isStaged == nil {
			return nil, fmt.Errorf("field \"isStaged\" is required")
		}
		return struct {
			Type     string `json:"type"`
			IsStaged bool   `json:"isStaged"`
		}{Type: "isStaged", IsStaged: *u.isStaged}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	}
}

func (u SearchAssetsQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchAssetsQuery) UnmarshalJSON(data []byte) error {
	var deser searchAssetsQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "exactSubstring":
		if u.exactSubstring == nil {
			return fmt.Errorf("field \"exactSubstring\" is required")
		}
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "typeRid":
		if u.typeRid == nil {
			return fmt.Errorf("field \"typeRid\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "isStaged":
		if u.isStaged == nil {
			return fmt.Errorf("field \"isStaged\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	}
	return nil
}

func (u SearchAssetsQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchAssetsQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchAssetsQuery) AcceptFuncs(searchTextFunc func(string) error, exactSubstringFunc func(string) error, labelFunc func(api.Label) error, propertyFunc func(api.Property) error, typeRidFunc func(api1.TypeRid) error, andFunc func([]SearchAssetsQuery) error, orFunc func([]SearchAssetsQuery) error, isStagedFunc func(bool) error, workspaceFunc func(rids.WorkspaceRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "exactSubstring":
		if u.exactSubstring == nil {
			return fmt.Errorf("field \"exactSubstring\" is required")
		}
		return exactSubstringFunc(*u.exactSubstring)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "typeRid":
		if u.typeRid == nil {
			return fmt.Errorf("field \"typeRid\" is required")
		}
		return typeRidFunc(*u.typeRid)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "isStaged":
		if u.isStaged == nil {
			return fmt.Errorf("field \"isStaged\" is required")
		}
		return isStagedFunc(*u.isStaged)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchAssetsQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *SearchAssetsQuery) ExactSubstringNoopSuccess(string) error {
	return nil
}

func (u *SearchAssetsQuery) LabelNoopSuccess(api.Label) error {
	return nil
}

func (u *SearchAssetsQuery) PropertyNoopSuccess(api.Property) error {
	return nil
}

func (u *SearchAssetsQuery) TypeRidNoopSuccess(api1.TypeRid) error {
	return nil
}

func (u *SearchAssetsQuery) AndNoopSuccess([]SearchAssetsQuery) error {
	return nil
}

func (u *SearchAssetsQuery) OrNoopSuccess([]SearchAssetsQuery) error {
	return nil
}

func (u *SearchAssetsQuery) IsStagedNoopSuccess(bool) error {
	return nil
}

func (u *SearchAssetsQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *SearchAssetsQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchAssetsQuery) Accept(v SearchAssetsQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "exactSubstring":
		if u.exactSubstring == nil {
			return fmt.Errorf("field \"exactSubstring\" is required")
		}
		return v.VisitExactSubstring(*u.exactSubstring)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "typeRid":
		if u.typeRid == nil {
			return fmt.Errorf("field \"typeRid\" is required")
		}
		return v.VisitTypeRid(*u.typeRid)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "isStaged":
		if u.isStaged == nil {
			return fmt.Errorf("field \"isStaged\" is required")
		}
		return v.VisitIsStaged(*u.isStaged)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	}
}

type SearchAssetsQueryVisitor interface {
	VisitSearchText(v string) error
	VisitExactSubstring(v string) error
	VisitLabel(v api.Label) error
	VisitProperty(v api.Property) error
	VisitTypeRid(v api1.TypeRid) error
	VisitAnd(v []SearchAssetsQuery) error
	VisitOr(v []SearchAssetsQuery) error
	VisitIsStaged(v bool) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitUnknown(typeName string) error
}

func (u *SearchAssetsQuery) AcceptWithContext(ctx context.Context, v SearchAssetsQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "exactSubstring":
		if u.exactSubstring == nil {
			return fmt.Errorf("field \"exactSubstring\" is required")
		}
		return v.VisitExactSubstringWithContext(ctx, *u.exactSubstring)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabelWithContext(ctx, *u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "typeRid":
		if u.typeRid == nil {
			return fmt.Errorf("field \"typeRid\" is required")
		}
		return v.VisitTypeRidWithContext(ctx, *u.typeRid)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "isStaged":
		if u.isStaged == nil {
			return fmt.Errorf("field \"isStaged\" is required")
		}
		return v.VisitIsStagedWithContext(ctx, *u.isStaged)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	}
}

type SearchAssetsQueryVisitorWithContext interface {
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitExactSubstringWithContext(ctx context.Context, v string) error
	VisitLabelWithContext(ctx context.Context, v api.Label) error
	VisitPropertyWithContext(ctx context.Context, v api.Property) error
	VisitTypeRidWithContext(ctx context.Context, v api1.TypeRid) error
	VisitAndWithContext(ctx context.Context, v []SearchAssetsQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchAssetsQuery) error
	VisitIsStagedWithContext(ctx context.Context, v bool) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchAssetsQueryFromSearchText(v string) SearchAssetsQuery {
	return SearchAssetsQuery{typ: "searchText", searchText: &v}
}

func NewSearchAssetsQueryFromExactSubstring(v string) SearchAssetsQuery {
	return SearchAssetsQuery{typ: "exactSubstring", exactSubstring: &v}
}

func NewSearchAssetsQueryFromLabel(v api.Label) SearchAssetsQuery {
	return SearchAssetsQuery{typ: "label", label: &v}
}

func NewSearchAssetsQueryFromProperty(v api.Property) SearchAssetsQuery {
	return SearchAssetsQuery{typ: "property", property: &v}
}

func NewSearchAssetsQueryFromTypeRid(v api1.TypeRid) SearchAssetsQuery {
	return SearchAssetsQuery{typ: "typeRid", typeRid: &v}
}

func NewSearchAssetsQueryFromAnd(v []SearchAssetsQuery) SearchAssetsQuery {
	return SearchAssetsQuery{typ: "and", and: &v}
}

func NewSearchAssetsQueryFromOr(v []SearchAssetsQuery) SearchAssetsQuery {
	return SearchAssetsQuery{typ: "or", or: &v}
}

func NewSearchAssetsQueryFromIsStaged(v bool) SearchAssetsQuery {
	return SearchAssetsQuery{typ: "isStaged", isStaged: &v}
}

func NewSearchAssetsQueryFromWorkspace(v rids.WorkspaceRid) SearchAssetsQuery {
	return SearchAssetsQuery{typ: "workspace", workspace: &v}
}

type SearchTypesQuery struct {
	typ                  string
	searchText           *string
	property             *api.PropertyName
	and                  *[]SearchTypesQuery
	or                   *[]SearchTypesQuery
	workspace            *rids.WorkspaceRid
	configuredDatasource *rids.DataSourceRid
}

type searchTypesQueryDeserializer struct {
	Type                 string              `json:"type"`
	SearchText           *string             `json:"searchText"`
	Property             *api.PropertyName   `json:"property"`
	And                  *[]SearchTypesQuery `json:"and"`
	Or                   *[]SearchTypesQuery `json:"or"`
	Workspace            *rids.WorkspaceRid  `json:"workspace"`
	ConfiguredDatasource *rids.DataSourceRid `json:"configuredDatasource"`
}

func (u *searchTypesQueryDeserializer) toStruct() SearchTypesQuery {
	return SearchTypesQuery{typ: u.Type, searchText: u.SearchText, property: u.Property, and: u.And, or: u.Or, workspace: u.Workspace, configuredDatasource: u.ConfiguredDatasource}
}

func (u *SearchTypesQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string           `json:"type"`
			Property api.PropertyName `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string             `json:"type"`
			And  []SearchTypesQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string             `json:"type"`
			Or   []SearchTypesQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	case "configuredDatasource":
		if u.configuredDatasource == nil {
			return nil, fmt.Errorf("field \"configuredDatasource\" is required")
		}
		return struct {
			Type                 string             `json:"type"`
			ConfiguredDatasource rids.DataSourceRid `json:"configuredDatasource"`
		}{Type: "configuredDatasource", ConfiguredDatasource: *u.configuredDatasource}, nil
	}
}

func (u SearchTypesQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchTypesQuery) UnmarshalJSON(data []byte) error {
	var deser searchTypesQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	case "configuredDatasource":
		if u.configuredDatasource == nil {
			return fmt.Errorf("field \"configuredDatasource\" is required")
		}
	}
	return nil
}

func (u SearchTypesQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchTypesQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchTypesQuery) AcceptFuncs(searchTextFunc func(string) error, propertyFunc func(api.PropertyName) error, andFunc func([]SearchTypesQuery) error, orFunc func([]SearchTypesQuery) error, workspaceFunc func(rids.WorkspaceRid) error, configuredDatasourceFunc func(rids.DataSourceRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	case "configuredDatasource":
		if u.configuredDatasource == nil {
			return fmt.Errorf("field \"configuredDatasource\" is required")
		}
		return configuredDatasourceFunc(*u.configuredDatasource)
	}
}

func (u *SearchTypesQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *SearchTypesQuery) PropertyNoopSuccess(api.PropertyName) error {
	return nil
}

func (u *SearchTypesQuery) AndNoopSuccess([]SearchTypesQuery) error {
	return nil
}

func (u *SearchTypesQuery) OrNoopSuccess([]SearchTypesQuery) error {
	return nil
}

func (u *SearchTypesQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *SearchTypesQuery) ConfiguredDatasourceNoopSuccess(rids.DataSourceRid) error {
	return nil
}

func (u *SearchTypesQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchTypesQuery) Accept(v SearchTypesQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	case "configuredDatasource":
		if u.configuredDatasource == nil {
			return fmt.Errorf("field \"configuredDatasource\" is required")
		}
		return v.VisitConfiguredDatasource(*u.configuredDatasource)
	}
}

type SearchTypesQueryVisitor interface {
	VisitSearchText(v string) error
	VisitProperty(v api.PropertyName) error
	VisitAnd(v []SearchTypesQuery) error
	VisitOr(v []SearchTypesQuery) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitConfiguredDatasource(v rids.DataSourceRid) error
	VisitUnknown(typeName string) error
}

func (u *SearchTypesQuery) AcceptWithContext(ctx context.Context, v SearchTypesQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	case "configuredDatasource":
		if u.configuredDatasource == nil {
			return fmt.Errorf("field \"configuredDatasource\" is required")
		}
		return v.VisitConfiguredDatasourceWithContext(ctx, *u.configuredDatasource)
	}
}

type SearchTypesQueryVisitorWithContext interface {
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitPropertyWithContext(ctx context.Context, v api.PropertyName) error
	VisitAndWithContext(ctx context.Context, v []SearchTypesQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchTypesQuery) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitConfiguredDatasourceWithContext(ctx context.Context, v rids.DataSourceRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchTypesQueryFromSearchText(v string) SearchTypesQuery {
	return SearchTypesQuery{typ: "searchText", searchText: &v}
}

func NewSearchTypesQueryFromProperty(v api.PropertyName) SearchTypesQuery {
	return SearchTypesQuery{typ: "property", property: &v}
}

func NewSearchTypesQueryFromAnd(v []SearchTypesQuery) SearchTypesQuery {
	return SearchTypesQuery{typ: "and", and: &v}
}

func NewSearchTypesQueryFromOr(v []SearchTypesQuery) SearchTypesQuery {
	return SearchTypesQuery{typ: "or", or: &v}
}

func NewSearchTypesQueryFromWorkspace(v rids.WorkspaceRid) SearchTypesQuery {
	return SearchTypesQuery{typ: "workspace", workspace: &v}
}

func NewSearchTypesQueryFromConfiguredDatasource(v rids.DataSourceRid) SearchTypesQuery {
	return SearchTypesQuery{typ: "configuredDatasource", configuredDatasource: &v}
}

type SortKey struct {
	typ      string
	field    *SortField
	property *SortProperty
}

type sortKeyDeserializer struct {
	Type     string        `json:"type"`
	Field    *SortField    `json:"field"`
	Property *SortProperty `json:"property"`
}

func (u *sortKeyDeserializer) toStruct() SortKey {
	return SortKey{typ: u.Type, field: u.Field, property: u.Property}
}

func (u *SortKey) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "field":
		if u.field == nil {
			return nil, fmt.Errorf("field \"field\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Field SortField `json:"field"`
		}{Type: "field", Field: *u.field}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Property SortProperty `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	}
}

func (u SortKey) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SortKey) UnmarshalJSON(data []byte) error {
	var deser sortKeyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	}
	return nil
}

func (u SortKey) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SortKey) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SortKey) AcceptFuncs(fieldFunc func(SortField) error, propertyFunc func(SortProperty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return fieldFunc(*u.field)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	}
}

func (u *SortKey) FieldNoopSuccess(SortField) error {
	return nil
}

func (u *SortKey) PropertyNoopSuccess(SortProperty) error {
	return nil
}

func (u *SortKey) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SortKey) Accept(v SortKeyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return v.VisitField(*u.field)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	}
}

type SortKeyVisitor interface {
	VisitField(v SortField) error
	VisitProperty(v SortProperty) error
	VisitUnknown(typeName string) error
}

func (u *SortKey) AcceptWithContext(ctx context.Context, v SortKeyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return v.VisitFieldWithContext(ctx, *u.field)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	}
}

type SortKeyVisitorWithContext interface {
	VisitFieldWithContext(ctx context.Context, v SortField) error
	VisitPropertyWithContext(ctx context.Context, v SortProperty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSortKeyFromField(v SortField) SortKey {
	return SortKey{typ: "field", field: &v}
}

func NewSortKeyFromProperty(v SortProperty) SortKey {
	return SortKey{typ: "property", property: &v}
}

type TagConfig struct {
	typ string
	v1  *[]api.TagName
}

type tagConfigDeserializer struct {
	Type string         `json:"type"`
	V1   *[]api.TagName `json:"v1"`
}

func (u *tagConfigDeserializer) toStruct() TagConfig {
	return TagConfig{typ: u.Type, v1: u.V1}
}

func (u *TagConfig) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string        `json:"type"`
			V1   []api.TagName `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u TagConfig) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TagConfig) UnmarshalJSON(data []byte) error {
	var deser tagConfigDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u TagConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TagConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TagConfig) AcceptFuncs(v1Func func([]api.TagName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *TagConfig) V1NoopSuccess([]api.TagName) error {
	return nil
}

func (u *TagConfig) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TagConfig) Accept(v TagConfigVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type TagConfigVisitor interface {
	VisitV1(v []api.TagName) error
	VisitUnknown(typeName string) error
}

func (u *TagConfig) AcceptWithContext(ctx context.Context, v TagConfigVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type TagConfigVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v []api.TagName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTagConfigFromV1(v []api.TagName) TagConfig {
	return TagConfig{typ: "v1", v1: &v}
}

/*
The request to update the type of the asset. The request will replace the existing type with the type
specified in the request if a typeRID is provided. Otherwise, the type will be removed from the asset.
*/
type UpdateOrRemoveAssetType struct {
	typ        string
	typeRid    *api1.TypeRid
	removeType *RemoveType
}

type updateOrRemoveAssetTypeDeserializer struct {
	Type       string        `json:"type"`
	TypeRid    *api1.TypeRid `json:"typeRid"`
	RemoveType *RemoveType   `json:"removeType"`
}

func (u *updateOrRemoveAssetTypeDeserializer) toStruct() UpdateOrRemoveAssetType {
	return UpdateOrRemoveAssetType{typ: u.Type, typeRid: u.TypeRid, removeType: u.RemoveType}
}

func (u *UpdateOrRemoveAssetType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "typeRid":
		if u.typeRid == nil {
			return nil, fmt.Errorf("field \"typeRid\" is required")
		}
		return struct {
			Type    string       `json:"type"`
			TypeRid api1.TypeRid `json:"typeRid"`
		}{Type: "typeRid", TypeRid: *u.typeRid}, nil
	case "removeType":
		if u.removeType == nil {
			return nil, fmt.Errorf("field \"removeType\" is required")
		}
		return struct {
			Type       string     `json:"type"`
			RemoveType RemoveType `json:"removeType"`
		}{Type: "removeType", RemoveType: *u.removeType}, nil
	}
}

func (u UpdateOrRemoveAssetType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UpdateOrRemoveAssetType) UnmarshalJSON(data []byte) error {
	var deser updateOrRemoveAssetTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "typeRid":
		if u.typeRid == nil {
			return fmt.Errorf("field \"typeRid\" is required")
		}
	case "removeType":
		if u.removeType == nil {
			return fmt.Errorf("field \"removeType\" is required")
		}
	}
	return nil
}

func (u UpdateOrRemoveAssetType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UpdateOrRemoveAssetType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UpdateOrRemoveAssetType) AcceptFuncs(typeRidFunc func(api1.TypeRid) error, removeTypeFunc func(RemoveType) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "typeRid":
		if u.typeRid == nil {
			return fmt.Errorf("field \"typeRid\" is required")
		}
		return typeRidFunc(*u.typeRid)
	case "removeType":
		if u.removeType == nil {
			return fmt.Errorf("field \"removeType\" is required")
		}
		return removeTypeFunc(*u.removeType)
	}
}

func (u *UpdateOrRemoveAssetType) TypeRidNoopSuccess(api1.TypeRid) error {
	return nil
}

func (u *UpdateOrRemoveAssetType) RemoveTypeNoopSuccess(RemoveType) error {
	return nil
}

func (u *UpdateOrRemoveAssetType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UpdateOrRemoveAssetType) Accept(v UpdateOrRemoveAssetTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "typeRid":
		if u.typeRid == nil {
			return fmt.Errorf("field \"typeRid\" is required")
		}
		return v.VisitTypeRid(*u.typeRid)
	case "removeType":
		if u.removeType == nil {
			return fmt.Errorf("field \"removeType\" is required")
		}
		return v.VisitRemoveType(*u.removeType)
	}
}

type UpdateOrRemoveAssetTypeVisitor interface {
	VisitTypeRid(v api1.TypeRid) error
	VisitRemoveType(v RemoveType) error
	VisitUnknown(typeName string) error
}

func (u *UpdateOrRemoveAssetType) AcceptWithContext(ctx context.Context, v UpdateOrRemoveAssetTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "typeRid":
		if u.typeRid == nil {
			return fmt.Errorf("field \"typeRid\" is required")
		}
		return v.VisitTypeRidWithContext(ctx, *u.typeRid)
	case "removeType":
		if u.removeType == nil {
			return fmt.Errorf("field \"removeType\" is required")
		}
		return v.VisitRemoveTypeWithContext(ctx, *u.removeType)
	}
}

type UpdateOrRemoveAssetTypeVisitorWithContext interface {
	VisitTypeRidWithContext(ctx context.Context, v api1.TypeRid) error
	VisitRemoveTypeWithContext(ctx context.Context, v RemoveType) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUpdateOrRemoveAssetTypeFromTypeRid(v api1.TypeRid) UpdateOrRemoveAssetType {
	return UpdateOrRemoveAssetType{typ: "typeRid", typeRid: &v}
}

func NewUpdateOrRemoveAssetTypeFromRemoveType(v RemoveType) UpdateOrRemoveAssetType {
	return UpdateOrRemoveAssetType{typ: "removeType", removeType: &v}
}
