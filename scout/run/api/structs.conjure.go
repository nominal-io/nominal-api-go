// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api3 "github.com/nominal-io/nominal-api-go/scout/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/internal_/search/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
)

type AllRunsPropertiesAndLabelsResponse struct {
	Properties map[api.PropertyName][]api.PropertyValue `json:"properties"`
	Labels     []api.Label                              `json:"labels"`
}

func (o AllRunsPropertiesAndLabelsResponse) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName][]api.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	type _tmpAllRunsPropertiesAndLabelsResponse AllRunsPropertiesAndLabelsResponse
	return safejson.Marshal(_tmpAllRunsPropertiesAndLabelsResponse(o))
}

func (o *AllRunsPropertiesAndLabelsResponse) UnmarshalJSON(data []byte) error {
	type _tmpAllRunsPropertiesAndLabelsResponse AllRunsPropertiesAndLabelsResponse
	var rawAllRunsPropertiesAndLabelsResponse _tmpAllRunsPropertiesAndLabelsResponse
	if err := safejson.Unmarshal(data, &rawAllRunsPropertiesAndLabelsResponse); err != nil {
		return err
	}
	if rawAllRunsPropertiesAndLabelsResponse.Properties == nil {
		rawAllRunsPropertiesAndLabelsResponse.Properties = make(map[api.PropertyName][]api.PropertyValue, 0)
	}
	if rawAllRunsPropertiesAndLabelsResponse.Labels == nil {
		rawAllRunsPropertiesAndLabelsResponse.Labels = make([]api.Label, 0)
	}
	*o = AllRunsPropertiesAndLabelsResponse(rawAllRunsPropertiesAndLabelsResponse)
	return nil
}

func (o AllRunsPropertiesAndLabelsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AllRunsPropertiesAndLabelsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelMetadata struct {
	Name        api.Channel         `json:"name"`
	DataSource  DataSource          `json:"dataSource"`
	Unit        *Unit               `json:"unit,omitempty"`
	Description *string             `json:"description,omitempty"`
	DataType    *api.SeriesDataType `json:"dataType,omitempty"`
}

func (o ChannelMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CheckAlertStatesFilter struct {
	CheckAlertState api1.CheckAlertState `json:"checkAlertState"`
	Operator        api2.Operator        `json:"operator"`
	Threshold       safelong.SafeLong    `json:"threshold"`
}

func (o CheckAlertStatesFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CheckAlertStatesFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateOrUpdateRunRequest struct {
	/*
	   If a run with the same rid already exists, it will be updated.
	   Otherwise, a new run will be created.
	*/
	RunRid           *RunRid          `conjure-docs:"If a run with the same rid already exists, it will be updated.\nOtherwise, a new run will be created." json:"runRid,omitempty"`
	CreateRunRequest CreateRunRequest `json:"createRunRequest"`
}

func (o CreateOrUpdateRunRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateOrUpdateRunRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// For write requests, we want to allow for optional fields
type CreateRunDataSource struct {
	/*
	   One of dataSource and dataSourceRid must be present.
	   dataSourceRid takes precedence.

	   Deprecated: Use dataSourceRid instead.
	*/
	DataSource *DataSource `conjure-docs:"One of dataSource and dataSourceRid must be present.\ndataSourceRid takes precedence." json:"dataSource,omitempty"`
	/*
	   One of dataSource and dataSourceRid must be present.
	   dataSourceRid takes precedence.
	*/
	DataSourceRid *rids.DataSourceRid `conjure-docs:"One of dataSource and dataSourceRid must be present.\ndataSourceRid takes precedence." json:"dataSourceRid,omitempty"`
	Offset        *Duration           `json:"offset,omitempty"`
	// Used to resolve logical series for this data source.
	SeriesTags map[api.TagName]api.TagValue `conjure-docs:"Used to resolve logical series for this data source." json:"seriesTags"`
}

func (o CreateRunDataSource) MarshalJSON() ([]byte, error) {
	if o.SeriesTags == nil {
		o.SeriesTags = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpCreateRunDataSource CreateRunDataSource
	return safejson.Marshal(_tmpCreateRunDataSource(o))
}

func (o *CreateRunDataSource) UnmarshalJSON(data []byte) error {
	type _tmpCreateRunDataSource CreateRunDataSource
	var rawCreateRunDataSource _tmpCreateRunDataSource
	if err := safejson.Unmarshal(data, &rawCreateRunDataSource); err != nil {
		return err
	}
	if rawCreateRunDataSource.SeriesTags == nil {
		rawCreateRunDataSource.SeriesTags = make(map[api.TagName]api.TagValue, 0)
	}
	*o = CreateRunDataSource(rawCreateRunDataSource)
	return nil
}

func (o CreateRunDataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateRunDataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateRunRequest struct {
	Title       string                                         `json:"title"`
	Description string                                         `json:"description"`
	StartTime   UtcTimestamp                                   `json:"startTime"`
	EndTime     *UtcTimestamp                                  `json:"endTime,omitempty"`
	Properties  map[api.PropertyName]api.PropertyValue         `json:"properties"`
	Labels      []api.Label                                    `json:"labels"`
	Links       []Link                                         `json:"links"`
	RunPrefix   *string                                        `json:"runPrefix,omitempty"`
	DataSources map[api3.DataSourceRefName]CreateRunDataSource `json:"dataSources"`
	Attachments []rids.AttachmentRid                           `json:"attachments"`
	// Deprecated: Use assets
	Asset  *api1.AssetRid  `json:"asset,omitempty"`
	Assets []api1.AssetRid `json:"assets"`
	/*
	   The workspace in which to create the run. If not provided, the run will be created in
	   the default workspace for the user's organization, if the default workspace for the
	   organization is configured.
	   All data sources, attachments, and assets must be in the same workspace.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the run. If not provided, the run will be created in\nthe default workspace for the user's organization, if the default workspace for the\norganization is configured.\nAll data sources, attachments, and assets must be in the same workspace." json:"workspace,omitempty"`
}

func (o CreateRunRequest) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	if o.Links == nil {
		o.Links = make([]Link, 0)
	}
	if o.DataSources == nil {
		o.DataSources = make(map[api3.DataSourceRefName]CreateRunDataSource, 0)
	}
	if o.Attachments == nil {
		o.Attachments = make([]rids.AttachmentRid, 0)
	}
	if o.Assets == nil {
		o.Assets = make([]api1.AssetRid, 0)
	}
	type _tmpCreateRunRequest CreateRunRequest
	return safejson.Marshal(_tmpCreateRunRequest(o))
}

func (o *CreateRunRequest) UnmarshalJSON(data []byte) error {
	type _tmpCreateRunRequest CreateRunRequest
	var rawCreateRunRequest _tmpCreateRunRequest
	if err := safejson.Unmarshal(data, &rawCreateRunRequest); err != nil {
		return err
	}
	if rawCreateRunRequest.Properties == nil {
		rawCreateRunRequest.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if rawCreateRunRequest.Labels == nil {
		rawCreateRunRequest.Labels = make([]api.Label, 0)
	}
	if rawCreateRunRequest.Links == nil {
		rawCreateRunRequest.Links = make([]Link, 0)
	}
	if rawCreateRunRequest.DataSources == nil {
		rawCreateRunRequest.DataSources = make(map[api3.DataSourceRefName]CreateRunDataSource, 0)
	}
	if rawCreateRunRequest.Attachments == nil {
		rawCreateRunRequest.Attachments = make([]rids.AttachmentRid, 0)
	}
	if rawCreateRunRequest.Assets == nil {
		rawCreateRunRequest.Assets = make([]api1.AssetRid, 0)
	}
	*o = CreateRunRequest(rawCreateRunRequest)
	return nil
}

func (o CreateRunRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateRunRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataReviewAlertMetrics struct {
	PendingReview           int `json:"pendingReview"`
	ClosedWithIgnore        int `json:"closedWithIgnore"`
	ClosedWithFurtherAction int `json:"closedWithFurtherAction"`
}

func (o DataReviewAlertMetrics) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataReviewAlertMetrics) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataReviewCheckMetrics struct {
	PendingExecution                       int `json:"pendingExecution"`
	Executing                              int `json:"executing"`
	PassingAutomatic                       int `json:"passingAutomatic"`
	PendingReview                          int `json:"pendingReview"`
	ClosedWithIgnore                       int `json:"closedWithIgnore"`
	ClosedWithFurtherAction                int `json:"closedWithFurtherAction"`
	FailedToExecutePendingReview           int `json:"failedToExecutePendingReview"`
	FailedToExecuteClosedWithIgnore        int `json:"failedToExecuteClosedWithIgnore"`
	FailedToExecuteClosedWithFurtherAction int `json:"failedToExecuteClosedWithFurtherAction"`
}

func (o DataReviewCheckMetrics) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataReviewCheckMetrics) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataReviewMetrics struct {
	Checks DataReviewCheckMetrics `json:"checks"`
	Alerts DataReviewAlertMetrics `json:"alerts"`
}

func (o DataReviewMetrics) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataReviewMetrics) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataSourceSeriesTag struct {
	Name  api.TagName  `json:"name"`
	Value api.TagValue `json:"value"`
}

func (o DataSourceSeriesTag) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataSourceSeriesTag) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Duration struct {
	Seconds safelong.SafeLong `json:"seconds"`
	Nanos   safelong.SafeLong `json:"nanos"`
	Picos   *int              `json:"picos,omitempty"`
}

func (o Duration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Duration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetRunByIdRequest struct {
	RunNumber safelong.SafeLong `json:"runNumber"`
	RunPrefix *string           `json:"runPrefix,omitempty"`
	/*
	   The workspace in which to query for the run. If not provided, the run
	   will be queried in the default workspace for the user's organization,
	   if the default workspace for the organization is configured and the user
	   has access to it.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to query for the run. If not provided, the run\nwill be queried in the default workspace for the user's organization,\nif the default workspace for the organization is configured and the user\nhas access to it." json:"workspace,omitempty"`
}

func (o GetRunByIdRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetRunByIdRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetRunsByAssetRequest struct {
	Asset         api1.AssetRid `json:"asset"`
	NextPageToken *uuid.UUID    `json:"nextPageToken,omitempty"`
}

func (o GetRunsByAssetRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetRunsByAssetRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Link struct {
	Title *string `json:"title,omitempty"`
	Url   string  `json:"url"`
}

func (o Link) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Link) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Scoped to the org-level, intended to help the frontend
prevent users from submitting invalid ref names, ex.
using a `dataset` ref name for a `connection` data source
*/
type RefNameAndType struct {
	Name api3.DataSourceRefName `json:"name"`
	Type DataSourceType         `json:"type"`
}

func (o RefNameAndType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RefNameAndType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RunDataReviewSummary struct {
	EvaluationStatus             RunDataReviewEvaluationStatus `json:"evaluationStatus"`
	TotalIssueCount              int                           `json:"totalIssueCount"`
	ReviewedIssueCount           int                           `json:"reviewedIssueCount"`
	IssuesWithFurtherActionCount int                           `json:"issuesWithFurtherActionCount"`
	ExecutionErrorCount          int                           `json:"executionErrorCount"`
}

func (o RunDataReviewSummary) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RunDataReviewSummary) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// For read requests, we want to require all fields
type RunDataSource struct {
	DataSource DataSource `json:"dataSource"`
	/*
	   This offset is used for small time-sync corrections. Notably, it is
	   not the offset to move a relative data source to the start of the run.
	*/
	Offset Duration `conjure-docs:"This offset is used for small time-sync corrections. Notably, it is\nnot the offset to move a relative data source to the start of the run." json:"offset"`
	// Included for convenience, duplicated from the key of the map
	RefName       api3.DataSourceRefName `conjure-docs:"Included for convenience, duplicated from the key of the map" json:"refName"`
	TimestampType WeakTimestampType      `json:"timestampType"`
	// Used to resolve logical series for this data source.
	SeriesTags map[api.TagName]api.TagValue `conjure-docs:"Used to resolve logical series for this data source." json:"seriesTags"`
}

func (o RunDataSource) MarshalJSON() ([]byte, error) {
	if o.SeriesTags == nil {
		o.SeriesTags = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpRunDataSource RunDataSource
	return safejson.Marshal(_tmpRunDataSource(o))
}

func (o *RunDataSource) UnmarshalJSON(data []byte) error {
	type _tmpRunDataSource RunDataSource
	var rawRunDataSource _tmpRunDataSource
	if err := safejson.Unmarshal(data, &rawRunDataSource); err != nil {
		return err
	}
	if rawRunDataSource.SeriesTags == nil {
		rawRunDataSource.SeriesTags = make(map[api.TagName]api.TagValue, 0)
	}
	*o = RunDataSource(rawRunDataSource)
	return nil
}

func (o RunDataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RunDataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchRunChannelsRequest struct {
	SearchText string `json:"searchText"`
	// If not empty, will filter to channels from the selected DataSourceRefNames.
	RefNameFilter              *[]api3.DataSourceRefName                `conjure-docs:"If not empty, will filter to channels from the selected DataSourceRefNames." json:"refNameFilter,omitempty"`
	PreviouslySelectedChannels map[api3.DataSourceRefName][]api.Channel `json:"previouslySelectedChannels"`
	NextPageToken              *api.Token                               `json:"nextPageToken,omitempty"`
	// Defaults to 1000. Will throw if larger than 1000.
	PageSize *int `conjure-docs:"Defaults to 1000. Will throw if larger than 1000." json:"pageSize,omitempty"`
}

func (o SearchRunChannelsRequest) MarshalJSON() ([]byte, error) {
	if o.PreviouslySelectedChannels == nil {
		o.PreviouslySelectedChannels = make(map[api3.DataSourceRefName][]api.Channel, 0)
	}
	type _tmpSearchRunChannelsRequest SearchRunChannelsRequest
	return safejson.Marshal(_tmpSearchRunChannelsRequest(o))
}

func (o *SearchRunChannelsRequest) UnmarshalJSON(data []byte) error {
	type _tmpSearchRunChannelsRequest SearchRunChannelsRequest
	var rawSearchRunChannelsRequest _tmpSearchRunChannelsRequest
	if err := safejson.Unmarshal(data, &rawSearchRunChannelsRequest); err != nil {
		return err
	}
	if rawSearchRunChannelsRequest.PreviouslySelectedChannels == nil {
		rawSearchRunChannelsRequest.PreviouslySelectedChannels = make(map[api3.DataSourceRefName][]api.Channel, 0)
	}
	*o = SearchRunChannelsRequest(rawSearchRunChannelsRequest)
	return nil
}

func (o SearchRunChannelsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchRunChannelsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchRunChannelsResponse struct {
	Results       []ChannelMetadata `json:"results"`
	NextPageToken *api.Token        `json:"nextPageToken,omitempty"`
}

func (o SearchRunChannelsResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ChannelMetadata, 0)
	}
	type _tmpSearchRunChannelsResponse SearchRunChannelsResponse
	return safejson.Marshal(_tmpSearchRunChannelsResponse(o))
}

func (o *SearchRunChannelsResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchRunChannelsResponse SearchRunChannelsResponse
	var rawSearchRunChannelsResponse _tmpSearchRunChannelsResponse
	if err := safejson.Unmarshal(data, &rawSearchRunChannelsResponse); err != nil {
		return err
	}
	if rawSearchRunChannelsResponse.Results == nil {
		rawSearchRunChannelsResponse.Results = make([]ChannelMetadata, 0)
	}
	*o = SearchRunChannelsResponse(rawSearchRunChannelsResponse)
	return nil
}

func (o SearchRunChannelsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchRunChannelsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchRunsRequest struct {
	Sort SortOptions `json:"sort"`
	// Will reject page sizes greater than 1000.
	PageSize      int         `conjure-docs:"Will reject page sizes greater than 1000." json:"pageSize"`
	NextPageToken *api.Token  `json:"nextPageToken,omitempty"`
	Query         SearchQuery `json:"query"`
	// Default search status is NOT_ARCHIVED if none are provided. Allows for including archived runs in search.
	ArchivedStatuses *[]api.ArchivedStatus `conjure-docs:"Default search status is NOT_ARCHIVED if none are provided. Allows for including archived runs in search." json:"archivedStatuses,omitempty"`
}

func (o SearchRunsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchRunsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SortOptions struct {
	IsDescending bool `json:"isDescending"`
	// Deprecated: use SortKey with SortField union type instead
	Field *SortField `json:"field,omitempty"`
	// Field to sort by. Includes both field and property-based sorting.
	SortKey *SortKey `conjure-docs:"Field to sort by. Includes both field and property-based sorting." json:"sortKey,omitempty"`
}

func (o SortOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SortOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SortProperty struct {
	Name api.PropertyName `json:"name"`
}

func (o SortProperty) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SortProperty) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// searches for runs that have at least some intersection with the specified range.
type TimeRangeFilter struct {
	Start *UtcTimestamp `json:"start,omitempty"`
	End   *UtcTimestamp `json:"end,omitempty"`
}

func (o TimeRangeFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeRangeFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Unit struct {
	// Deprecated: use the units service for additional display metadata
	Name   *string `json:"name,omitempty"`
	Symbol string  `json:"symbol"`
}

func (o Unit) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Unit) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateAttachmentsRequest struct {
	AttachmentsToAdd    []rids.AttachmentRid `json:"attachmentsToAdd"`
	AttachmentsToRemove []rids.AttachmentRid `json:"attachmentsToRemove"`
}

func (o UpdateAttachmentsRequest) MarshalJSON() ([]byte, error) {
	if o.AttachmentsToAdd == nil {
		o.AttachmentsToAdd = make([]rids.AttachmentRid, 0)
	}
	if o.AttachmentsToRemove == nil {
		o.AttachmentsToRemove = make([]rids.AttachmentRid, 0)
	}
	type _tmpUpdateAttachmentsRequest UpdateAttachmentsRequest
	return safejson.Marshal(_tmpUpdateAttachmentsRequest(o))
}

func (o *UpdateAttachmentsRequest) UnmarshalJSON(data []byte) error {
	type _tmpUpdateAttachmentsRequest UpdateAttachmentsRequest
	var rawUpdateAttachmentsRequest _tmpUpdateAttachmentsRequest
	if err := safejson.Unmarshal(data, &rawUpdateAttachmentsRequest); err != nil {
		return err
	}
	if rawUpdateAttachmentsRequest.AttachmentsToAdd == nil {
		rawUpdateAttachmentsRequest.AttachmentsToAdd = make([]rids.AttachmentRid, 0)
	}
	if rawUpdateAttachmentsRequest.AttachmentsToRemove == nil {
		rawUpdateAttachmentsRequest.AttachmentsToRemove = make([]rids.AttachmentRid, 0)
	}
	*o = UpdateAttachmentsRequest(rawUpdateAttachmentsRequest)
	return nil
}

func (o UpdateAttachmentsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateAttachmentsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateRunRequest struct {
	Title       *string                                 `json:"title,omitempty"`
	Description *string                                 `json:"description,omitempty"`
	StartTime   *UtcTimestamp                           `json:"startTime,omitempty"`
	EndTime     *UtcTimestamp                           `json:"endTime,omitempty"`
	Properties  *map[api.PropertyName]api.PropertyValue `json:"properties,omitempty"`
	Labels      *[]api.Label                            `json:"labels,omitempty"`
	Links       *[]Link                                 `json:"links,omitempty"`
	// Pass in an empty string to remove the run prefix.
	RunPrefix   *string                                         `conjure-docs:"Pass in an empty string to remove the run prefix." json:"runPrefix,omitempty"`
	DataSources *map[api3.DataSourceRefName]CreateRunDataSource `json:"dataSources,omitempty"`
	Attachments *[]rids.AttachmentRid                           `json:"attachments,omitempty"`
	// Deprecated: Use assets
	Asset  *api1.AssetRid  `json:"asset,omitempty"`
	Assets []api1.AssetRid `json:"assets"`
}

func (o UpdateRunRequest) MarshalJSON() ([]byte, error) {
	if o.Assets == nil {
		o.Assets = make([]api1.AssetRid, 0)
	}
	type _tmpUpdateRunRequest UpdateRunRequest
	return safejson.Marshal(_tmpUpdateRunRequest(o))
}

func (o *UpdateRunRequest) UnmarshalJSON(data []byte) error {
	type _tmpUpdateRunRequest UpdateRunRequest
	var rawUpdateRunRequest _tmpUpdateRunRequest
	if err := safejson.Unmarshal(data, &rawUpdateRunRequest); err != nil {
		return err
	}
	if rawUpdateRunRequest.Assets == nil {
		rawUpdateRunRequest.Assets = make([]api1.AssetRid, 0)
	}
	*o = UpdateRunRequest(rawUpdateRunRequest)
	return nil
}

func (o UpdateRunRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateRunRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UtcTimestamp struct {
	SecondsSinceEpoch safelong.SafeLong  `json:"secondsSinceEpoch"`
	OffsetNanoseconds *safelong.SafeLong `json:"offsetNanoseconds,omitempty"`
}

func (o UtcTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UtcTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
