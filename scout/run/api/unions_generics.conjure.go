// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/api"
	"github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/safelong"
)

type DataSourceWithT[T any] DataSource

func (u *DataSourceWithT[T]) Accept(ctx context.Context, v DataSourceVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "dataset":
		if u.dataset == nil {
			return result, fmt.Errorf("field \"dataset\" is required")
		}
		return v.VisitDataset(ctx, *u.dataset)
	case "connection":
		if u.connection == nil {
			return result, fmt.Errorf("field \"connection\" is required")
		}
		return v.VisitConnection(ctx, *u.connection)
	case "logSet":
		if u.logSet == nil {
			return result, fmt.Errorf("field \"logSet\" is required")
		}
		return v.VisitLogSet(ctx, *u.logSet)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(ctx, *u.video)
	}
}

func (u *DataSourceWithT[T]) AcceptFuncs(datasetFunc func(rids.DatasetRid) (T, error), connectionFunc func(ConnectionRid) (T, error), logSetFunc func(LogSetRid) (T, error), videoFunc func(rids.VideoRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dataset":
		if u.dataset == nil {
			return result, fmt.Errorf("field \"dataset\" is required")
		}
		return datasetFunc(*u.dataset)
	case "connection":
		if u.connection == nil {
			return result, fmt.Errorf("field \"connection\" is required")
		}
		return connectionFunc(*u.connection)
	case "logSet":
		if u.logSet == nil {
			return result, fmt.Errorf("field \"logSet\" is required")
		}
		return logSetFunc(*u.logSet)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	}
}

func (u *DataSourceWithT[T]) DatasetNoopSuccess(rids.DatasetRid) (T, error) {
	var result T
	return result, nil
}

func (u *DataSourceWithT[T]) ConnectionNoopSuccess(ConnectionRid) (T, error) {
	var result T
	return result, nil
}

func (u *DataSourceWithT[T]) LogSetNoopSuccess(LogSetRid) (T, error) {
	var result T
	return result, nil
}

func (u *DataSourceWithT[T]) VideoNoopSuccess(rids.VideoRid) (T, error) {
	var result T
	return result, nil
}

func (u *DataSourceWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DataSourceVisitorWithT[T any] interface {
	VisitDataset(ctx context.Context, v rids.DatasetRid) (T, error)
	VisitConnection(ctx context.Context, v ConnectionRid) (T, error)
	VisitLogSet(ctx context.Context, v LogSetRid) (T, error)
	VisitVideo(ctx context.Context, v rids.VideoRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SearchQueryWithT[T any] SearchQuery

func (u *SearchQueryWithT[T]) Accept(ctx context.Context, v SearchQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return result, fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return v.VisitStartTimeInclusive(ctx, *u.startTimeInclusive)
	case "startTime":
		if u.startTime == nil {
			return result, fmt.Errorf("field \"startTime\" is required")
		}
		return v.VisitStartTime(ctx, *u.startTime)
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return result, fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return v.VisitEndTimeInclusive(ctx, *u.endTimeInclusive)
	case "endTime":
		if u.endTime == nil {
			return result, fmt.Errorf("field \"endTime\" is required")
		}
		return v.VisitEndTime(ctx, *u.endTime)
	case "timeRange":
		if u.timeRange == nil {
			return result, fmt.Errorf("field \"timeRange\" is required")
		}
		return v.VisitTimeRange(ctx, *u.timeRange)
	case "createdAt":
		if u.createdAt == nil {
			return result, fmt.Errorf("field \"createdAt\" is required")
		}
		return v.VisitCreatedAt(ctx, *u.createdAt)
	case "exactMatch":
		if u.exactMatch == nil {
			return result, fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatch(ctx, *u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(ctx, *u.searchText)
	case "asset":
		if u.asset == nil {
			return result, fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAsset(ctx, *u.asset)
	case "assets":
		if u.assets == nil {
			return result, fmt.Errorf("field \"assets\" is required")
		}
		return v.VisitAssets(ctx, *u.assets)
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return result, fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return v.VisitIsSingleAsset(ctx, *u.isSingleAsset)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(ctx, *u.label)
	case "labels":
		if u.labels == nil {
			return result, fmt.Errorf("field \"labels\" is required")
		}
		return v.VisitLabels(ctx, *u.labels)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	case "properties":
		if u.properties == nil {
			return result, fmt.Errorf("field \"properties\" is required")
		}
		return v.VisitProperties(ctx, *u.properties)
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return result, fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return v.VisitDataSourceSeriesTag(ctx, *u.dataSourceSeriesTag)
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return result, fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return v.VisitDataSourceRefName(ctx, *u.dataSourceRefName)
	case "dataSource":
		if u.dataSource == nil {
			return result, fmt.Errorf("field \"dataSource\" is required")
		}
		return v.VisitDataSource(ctx, *u.dataSource)
	case "runNumber":
		if u.runNumber == nil {
			return result, fmt.Errorf("field \"runNumber\" is required")
		}
		return v.VisitRunNumber(ctx, *u.runNumber)
	case "runPrefix":
		if u.runPrefix == nil {
			return result, fmt.Errorf("field \"runPrefix\" is required")
		}
		return v.VisitRunPrefix(ctx, *u.runPrefix)
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return result, fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return v.VisitCheckAlertStatesFilter(ctx, *u.checkAlertStatesFilter)
	case "archived":
		if u.archived == nil {
			return result, fmt.Errorf("field \"archived\" is required")
		}
		return v.VisitArchived(ctx, *u.archived)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(ctx, *u.not)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	}
}

func (u *SearchQueryWithT[T]) AcceptFuncs(startTimeInclusiveFunc func(UtcTimestamp) (T, error), startTimeFunc func(TimeframeFilter) (T, error), endTimeInclusiveFunc func(UtcTimestamp) (T, error), endTimeFunc func(TimeframeFilter) (T, error), timeRangeFunc func(TimeRangeFilter) (T, error), createdAtFunc func(TimeframeFilter) (T, error), exactMatchFunc func(string) (T, error), searchTextFunc func(string) (T, error), assetFunc func(api.AssetRid) (T, error), assetsFunc func(AssetsFilter) (T, error), isSingleAssetFunc func(bool) (T, error), labelFunc func(api1.Label) (T, error), labelsFunc func(api.LabelsFilter) (T, error), propertyFunc func(api1.Property) (T, error), propertiesFunc func(api.PropertiesFilter) (T, error), dataSourceSeriesTagFunc func(DataSourceSeriesTag) (T, error), dataSourceRefNameFunc func(api2.DataSourceRefName) (T, error), dataSourceFunc func(DataSource) (T, error), runNumberFunc func(safelong.SafeLong) (T, error), runPrefixFunc func(string) (T, error), checkAlertStatesFilterFunc func(CheckAlertStatesFilter) (T, error), archivedFunc func(bool) (T, error), andFunc func([]SearchQuery) (T, error), orFunc func([]SearchQuery) (T, error), notFunc func(SearchQuery) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return result, fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return startTimeInclusiveFunc(*u.startTimeInclusive)
	case "startTime":
		if u.startTime == nil {
			return result, fmt.Errorf("field \"startTime\" is required")
		}
		return startTimeFunc(*u.startTime)
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return result, fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return endTimeInclusiveFunc(*u.endTimeInclusive)
	case "endTime":
		if u.endTime == nil {
			return result, fmt.Errorf("field \"endTime\" is required")
		}
		return endTimeFunc(*u.endTime)
	case "timeRange":
		if u.timeRange == nil {
			return result, fmt.Errorf("field \"timeRange\" is required")
		}
		return timeRangeFunc(*u.timeRange)
	case "createdAt":
		if u.createdAt == nil {
			return result, fmt.Errorf("field \"createdAt\" is required")
		}
		return createdAtFunc(*u.createdAt)
	case "exactMatch":
		if u.exactMatch == nil {
			return result, fmt.Errorf("field \"exactMatch\" is required")
		}
		return exactMatchFunc(*u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "asset":
		if u.asset == nil {
			return result, fmt.Errorf("field \"asset\" is required")
		}
		return assetFunc(*u.asset)
	case "assets":
		if u.assets == nil {
			return result, fmt.Errorf("field \"assets\" is required")
		}
		return assetsFunc(*u.assets)
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return result, fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return isSingleAssetFunc(*u.isSingleAsset)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "labels":
		if u.labels == nil {
			return result, fmt.Errorf("field \"labels\" is required")
		}
		return labelsFunc(*u.labels)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "properties":
		if u.properties == nil {
			return result, fmt.Errorf("field \"properties\" is required")
		}
		return propertiesFunc(*u.properties)
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return result, fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return dataSourceSeriesTagFunc(*u.dataSourceSeriesTag)
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return result, fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return dataSourceRefNameFunc(*u.dataSourceRefName)
	case "dataSource":
		if u.dataSource == nil {
			return result, fmt.Errorf("field \"dataSource\" is required")
		}
		return dataSourceFunc(*u.dataSource)
	case "runNumber":
		if u.runNumber == nil {
			return result, fmt.Errorf("field \"runNumber\" is required")
		}
		return runNumberFunc(*u.runNumber)
	case "runPrefix":
		if u.runPrefix == nil {
			return result, fmt.Errorf("field \"runPrefix\" is required")
		}
		return runPrefixFunc(*u.runPrefix)
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return result, fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return checkAlertStatesFilterFunc(*u.checkAlertStatesFilter)
	case "archived":
		if u.archived == nil {
			return result, fmt.Errorf("field \"archived\" is required")
		}
		return archivedFunc(*u.archived)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchQueryWithT[T]) StartTimeInclusiveNoopSuccess(UtcTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) StartTimeNoopSuccess(TimeframeFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) EndTimeInclusiveNoopSuccess(UtcTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) EndTimeNoopSuccess(TimeframeFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) TimeRangeNoopSuccess(TimeRangeFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) CreatedAtNoopSuccess(TimeframeFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) ExactMatchNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) SearchTextNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) AssetNoopSuccess(api.AssetRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) AssetsNoopSuccess(AssetsFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) IsSingleAssetNoopSuccess(bool) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) LabelNoopSuccess(api1.Label) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) LabelsNoopSuccess(api.LabelsFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) PropertyNoopSuccess(api1.Property) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) PropertiesNoopSuccess(api.PropertiesFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) DataSourceSeriesTagNoopSuccess(DataSourceSeriesTag) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) DataSourceRefNameNoopSuccess(api2.DataSourceRefName) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) DataSourceNoopSuccess(DataSource) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) RunNumberNoopSuccess(safelong.SafeLong) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) RunPrefixNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) CheckAlertStatesFilterNoopSuccess(CheckAlertStatesFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) ArchivedNoopSuccess(bool) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) AndNoopSuccess([]SearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) OrNoopSuccess([]SearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) NotNoopSuccess(SearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchQueryVisitorWithT[T any] interface {
	VisitStartTimeInclusive(ctx context.Context, v UtcTimestamp) (T, error)
	VisitStartTime(ctx context.Context, v TimeframeFilter) (T, error)
	VisitEndTimeInclusive(ctx context.Context, v UtcTimestamp) (T, error)
	VisitEndTime(ctx context.Context, v TimeframeFilter) (T, error)
	VisitTimeRange(ctx context.Context, v TimeRangeFilter) (T, error)
	VisitCreatedAt(ctx context.Context, v TimeframeFilter) (T, error)
	VisitExactMatch(ctx context.Context, v string) (T, error)
	VisitSearchText(ctx context.Context, v string) (T, error)
	VisitAsset(ctx context.Context, v api.AssetRid) (T, error)
	VisitAssets(ctx context.Context, v AssetsFilter) (T, error)
	VisitIsSingleAsset(ctx context.Context, v bool) (T, error)
	VisitLabel(ctx context.Context, v api1.Label) (T, error)
	VisitLabels(ctx context.Context, v api.LabelsFilter) (T, error)
	VisitProperty(ctx context.Context, v api1.Property) (T, error)
	VisitProperties(ctx context.Context, v api.PropertiesFilter) (T, error)
	VisitDataSourceSeriesTag(ctx context.Context, v DataSourceSeriesTag) (T, error)
	VisitDataSourceRefName(ctx context.Context, v api2.DataSourceRefName) (T, error)
	VisitDataSource(ctx context.Context, v DataSource) (T, error)
	VisitRunNumber(ctx context.Context, v safelong.SafeLong) (T, error)
	VisitRunPrefix(ctx context.Context, v string) (T, error)
	VisitCheckAlertStatesFilter(ctx context.Context, v CheckAlertStatesFilter) (T, error)
	VisitArchived(ctx context.Context, v bool) (T, error)
	VisitAnd(ctx context.Context, v []SearchQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchQuery) (T, error)
	VisitNot(ctx context.Context, v SearchQuery) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SortKeyWithT[T any] SortKey

func (u *SortKeyWithT[T]) Accept(ctx context.Context, v SortKeyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "field":
		if u.field == nil {
			return result, fmt.Errorf("field \"field\" is required")
		}
		return v.VisitField(ctx, *u.field)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	}
}

func (u *SortKeyWithT[T]) AcceptFuncs(fieldFunc func(SortField) (T, error), propertyFunc func(SortProperty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "field":
		if u.field == nil {
			return result, fmt.Errorf("field \"field\" is required")
		}
		return fieldFunc(*u.field)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	}
}

func (u *SortKeyWithT[T]) FieldNoopSuccess(SortField) (T, error) {
	var result T
	return result, nil
}

func (u *SortKeyWithT[T]) PropertyNoopSuccess(SortProperty) (T, error) {
	var result T
	return result, nil
}

func (u *SortKeyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SortKeyVisitorWithT[T any] interface {
	VisitField(ctx context.Context, v SortField) (T, error)
	VisitProperty(ctx context.Context, v SortProperty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimeframeFilterWithT[T any] TimeframeFilter

func (u *TimeframeFilterWithT[T]) Accept(ctx context.Context, v TimeframeFilterVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "custom":
		if u.custom == nil {
			return result, fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(ctx, *u.custom)
	case "preset":
		if u.preset == nil {
			return result, fmt.Errorf("field \"preset\" is required")
		}
		return v.VisitPreset(ctx, *u.preset)
	}
}

func (u *TimeframeFilterWithT[T]) AcceptFuncs(customFunc func(CustomTimeframeFilter) (T, error), presetFunc func(PresetTimeframeFilter) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "custom":
		if u.custom == nil {
			return result, fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	case "preset":
		if u.preset == nil {
			return result, fmt.Errorf("field \"preset\" is required")
		}
		return presetFunc(*u.preset)
	}
}

func (u *TimeframeFilterWithT[T]) CustomNoopSuccess(CustomTimeframeFilter) (T, error) {
	var result T
	return result, nil
}

func (u *TimeframeFilterWithT[T]) PresetNoopSuccess(PresetTimeframeFilter) (T, error) {
	var result T
	return result, nil
}

func (u *TimeframeFilterWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimeframeFilterVisitorWithT[T any] interface {
	VisitCustom(ctx context.Context, v CustomTimeframeFilter) (T, error)
	VisitPreset(ctx context.Context, v PresetTimeframeFilter) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
