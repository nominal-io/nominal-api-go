// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/api/rids"
	api1 "github.com/nominal-io/nominal-api/io/nominal/api"
	api2 "github.com/nominal-io/nominal-api/scout/api"
	"github.com/nominal-io/nominal-api/scout/rids/api"
	"github.com/palantir/pkg/safelong"
)

type DataSourceWithT[T any] DataSource

func (u *DataSourceWithT[T]) Accept(ctx context.Context, v DataSourceVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "dataset":
		if u.dataset == nil {
			return result, fmt.Errorf("field \"dataset\" is required")
		}
		return v.VisitDataset(ctx, *u.dataset)
	case "connection":
		if u.connection == nil {
			return result, fmt.Errorf("field \"connection\" is required")
		}
		return v.VisitConnection(ctx, *u.connection)
	case "logSet":
		if u.logSet == nil {
			return result, fmt.Errorf("field \"logSet\" is required")
		}
		return v.VisitLogSet(ctx, *u.logSet)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(ctx, *u.video)
	}
}

func (u *DataSourceWithT[T]) AcceptFuncs(datasetFunc func(rids.DatasetRid) (T, error), connectionFunc func(ConnectionRid) (T, error), logSetFunc func(LogSetRid) (T, error), videoFunc func(rids.VideoRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dataset":
		if u.dataset == nil {
			return result, fmt.Errorf("field \"dataset\" is required")
		}
		return datasetFunc(*u.dataset)
	case "connection":
		if u.connection == nil {
			return result, fmt.Errorf("field \"connection\" is required")
		}
		return connectionFunc(*u.connection)
	case "logSet":
		if u.logSet == nil {
			return result, fmt.Errorf("field \"logSet\" is required")
		}
		return logSetFunc(*u.logSet)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	}
}

func (u *DataSourceWithT[T]) DatasetNoopSuccess(rids.DatasetRid) (T, error) {
	var result T
	return result, nil
}

func (u *DataSourceWithT[T]) ConnectionNoopSuccess(ConnectionRid) (T, error) {
	var result T
	return result, nil
}

func (u *DataSourceWithT[T]) LogSetNoopSuccess(LogSetRid) (T, error) {
	var result T
	return result, nil
}

func (u *DataSourceWithT[T]) VideoNoopSuccess(rids.VideoRid) (T, error) {
	var result T
	return result, nil
}

func (u *DataSourceWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DataSourceVisitorWithT[T any] interface {
	VisitDataset(ctx context.Context, v rids.DatasetRid) (T, error)
	VisitConnection(ctx context.Context, v ConnectionRid) (T, error)
	VisitLogSet(ctx context.Context, v LogSetRid) (T, error)
	VisitVideo(ctx context.Context, v rids.VideoRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SearchQueryWithT[T any] SearchQuery

func (u *SearchQueryWithT[T]) Accept(ctx context.Context, v SearchQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return result, fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return v.VisitStartTimeInclusive(ctx, *u.startTimeInclusive)
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return result, fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return v.VisitEndTimeInclusive(ctx, *u.endTimeInclusive)
	case "timeRange":
		if u.timeRange == nil {
			return result, fmt.Errorf("field \"timeRange\" is required")
		}
		return v.VisitTimeRange(ctx, *u.timeRange)
	case "exactMatch":
		if u.exactMatch == nil {
			return result, fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatch(ctx, *u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(ctx, *u.searchText)
	case "asset":
		if u.asset == nil {
			return result, fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAsset(ctx, *u.asset)
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return result, fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return v.VisitIsSingleAsset(ctx, *u.isSingleAsset)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(ctx, *u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return result, fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return v.VisitDataSourceSeriesTag(ctx, *u.dataSourceSeriesTag)
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return result, fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return v.VisitDataSourceRefName(ctx, *u.dataSourceRefName)
	case "dataSource":
		if u.dataSource == nil {
			return result, fmt.Errorf("field \"dataSource\" is required")
		}
		return v.VisitDataSource(ctx, *u.dataSource)
	case "runNumber":
		if u.runNumber == nil {
			return result, fmt.Errorf("field \"runNumber\" is required")
		}
		return v.VisitRunNumber(ctx, *u.runNumber)
	case "runPrefix":
		if u.runPrefix == nil {
			return result, fmt.Errorf("field \"runPrefix\" is required")
		}
		return v.VisitRunPrefix(ctx, *u.runPrefix)
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return result, fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return v.VisitCheckAlertStatesFilter(ctx, *u.checkAlertStatesFilter)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(ctx, *u.not)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	}
}

func (u *SearchQueryWithT[T]) AcceptFuncs(startTimeInclusiveFunc func(UtcTimestamp) (T, error), endTimeInclusiveFunc func(UtcTimestamp) (T, error), timeRangeFunc func(TimeRangeFilter) (T, error), exactMatchFunc func(string) (T, error), searchTextFunc func(string) (T, error), assetFunc func(api.AssetRid) (T, error), isSingleAssetFunc func(bool) (T, error), labelFunc func(api1.Label) (T, error), propertyFunc func(api1.Property) (T, error), dataSourceSeriesTagFunc func(DataSourceSeriesTag) (T, error), dataSourceRefNameFunc func(api2.DataSourceRefName) (T, error), dataSourceFunc func(DataSource) (T, error), runNumberFunc func(safelong.SafeLong) (T, error), runPrefixFunc func(string) (T, error), checkAlertStatesFilterFunc func(CheckAlertStatesFilter) (T, error), andFunc func([]SearchQuery) (T, error), orFunc func([]SearchQuery) (T, error), notFunc func(SearchQuery) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return result, fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return startTimeInclusiveFunc(*u.startTimeInclusive)
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return result, fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return endTimeInclusiveFunc(*u.endTimeInclusive)
	case "timeRange":
		if u.timeRange == nil {
			return result, fmt.Errorf("field \"timeRange\" is required")
		}
		return timeRangeFunc(*u.timeRange)
	case "exactMatch":
		if u.exactMatch == nil {
			return result, fmt.Errorf("field \"exactMatch\" is required")
		}
		return exactMatchFunc(*u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "asset":
		if u.asset == nil {
			return result, fmt.Errorf("field \"asset\" is required")
		}
		return assetFunc(*u.asset)
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return result, fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return isSingleAssetFunc(*u.isSingleAsset)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return result, fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return dataSourceSeriesTagFunc(*u.dataSourceSeriesTag)
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return result, fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return dataSourceRefNameFunc(*u.dataSourceRefName)
	case "dataSource":
		if u.dataSource == nil {
			return result, fmt.Errorf("field \"dataSource\" is required")
		}
		return dataSourceFunc(*u.dataSource)
	case "runNumber":
		if u.runNumber == nil {
			return result, fmt.Errorf("field \"runNumber\" is required")
		}
		return runNumberFunc(*u.runNumber)
	case "runPrefix":
		if u.runPrefix == nil {
			return result, fmt.Errorf("field \"runPrefix\" is required")
		}
		return runPrefixFunc(*u.runPrefix)
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return result, fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return checkAlertStatesFilterFunc(*u.checkAlertStatesFilter)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchQueryWithT[T]) StartTimeInclusiveNoopSuccess(UtcTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) EndTimeInclusiveNoopSuccess(UtcTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) TimeRangeNoopSuccess(TimeRangeFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) ExactMatchNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) SearchTextNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) AssetNoopSuccess(api.AssetRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) IsSingleAssetNoopSuccess(bool) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) LabelNoopSuccess(api1.Label) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) PropertyNoopSuccess(api1.Property) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) DataSourceSeriesTagNoopSuccess(DataSourceSeriesTag) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) DataSourceRefNameNoopSuccess(api2.DataSourceRefName) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) DataSourceNoopSuccess(DataSource) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) RunNumberNoopSuccess(safelong.SafeLong) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) RunPrefixNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) CheckAlertStatesFilterNoopSuccess(CheckAlertStatesFilter) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) AndNoopSuccess([]SearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) OrNoopSuccess([]SearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) NotNoopSuccess(SearchQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchQueryVisitorWithT[T any] interface {
	VisitStartTimeInclusive(ctx context.Context, v UtcTimestamp) (T, error)
	VisitEndTimeInclusive(ctx context.Context, v UtcTimestamp) (T, error)
	VisitTimeRange(ctx context.Context, v TimeRangeFilter) (T, error)
	VisitExactMatch(ctx context.Context, v string) (T, error)
	VisitSearchText(ctx context.Context, v string) (T, error)
	VisitAsset(ctx context.Context, v api.AssetRid) (T, error)
	VisitIsSingleAsset(ctx context.Context, v bool) (T, error)
	VisitLabel(ctx context.Context, v api1.Label) (T, error)
	VisitProperty(ctx context.Context, v api1.Property) (T, error)
	VisitDataSourceSeriesTag(ctx context.Context, v DataSourceSeriesTag) (T, error)
	VisitDataSourceRefName(ctx context.Context, v api2.DataSourceRefName) (T, error)
	VisitDataSource(ctx context.Context, v DataSource) (T, error)
	VisitRunNumber(ctx context.Context, v safelong.SafeLong) (T, error)
	VisitRunPrefix(ctx context.Context, v string) (T, error)
	VisitCheckAlertStatesFilter(ctx context.Context, v CheckAlertStatesFilter) (T, error)
	VisitAnd(ctx context.Context, v []SearchQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchQuery) (T, error)
	VisitNot(ctx context.Context, v SearchQuery) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SortKeyWithT[T any] SortKey

func (u *SortKeyWithT[T]) Accept(ctx context.Context, v SortKeyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "field":
		if u.field == nil {
			return result, fmt.Errorf("field \"field\" is required")
		}
		return v.VisitField(ctx, *u.field)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	}
}

func (u *SortKeyWithT[T]) AcceptFuncs(fieldFunc func(SortField) (T, error), propertyFunc func(SortProperty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "field":
		if u.field == nil {
			return result, fmt.Errorf("field \"field\" is required")
		}
		return fieldFunc(*u.field)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	}
}

func (u *SortKeyWithT[T]) FieldNoopSuccess(SortField) (T, error) {
	var result T
	return result, nil
}

func (u *SortKeyWithT[T]) PropertyNoopSuccess(SortProperty) (T, error) {
	var result T
	return result, nil
}

func (u *SortKeyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SortKeyVisitorWithT[T any] interface {
	VisitField(ctx context.Context, v SortField) (T, error)
	VisitProperty(ctx context.Context, v SortProperty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
