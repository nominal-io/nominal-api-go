// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/api"
	"github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
)

type DataSource struct {
	typ        string
	dataset    *rids.DatasetRid
	connection *ConnectionRid
	logSet     *LogSetRid
	video      *rids.VideoRid
}

type dataSourceDeserializer struct {
	Type       string           `json:"type"`
	Dataset    *rids.DatasetRid `json:"dataset"`
	Connection *ConnectionRid   `json:"connection"`
	LogSet     *LogSetRid       `json:"logSet"`
	Video      *rids.VideoRid   `json:"video"`
}

func (u *dataSourceDeserializer) toStruct() DataSource {
	return DataSource{typ: u.Type, dataset: u.Dataset, connection: u.Connection, logSet: u.LogSet, video: u.Video}
}

func (u *DataSource) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "dataset":
		if u.dataset == nil {
			return nil, fmt.Errorf("field \"dataset\" is required")
		}
		return struct {
			Type    string          `json:"type"`
			Dataset rids.DatasetRid `json:"dataset"`
		}{Type: "dataset", Dataset: *u.dataset}, nil
	case "connection":
		if u.connection == nil {
			return nil, fmt.Errorf("field \"connection\" is required")
		}
		return struct {
			Type       string        `json:"type"`
			Connection ConnectionRid `json:"connection"`
		}{Type: "connection", Connection: *u.connection}, nil
	case "logSet":
		if u.logSet == nil {
			return nil, fmt.Errorf("field \"logSet\" is required")
		}
		return struct {
			Type   string    `json:"type"`
			LogSet LogSetRid `json:"logSet"`
		}{Type: "logSet", LogSet: *u.logSet}, nil
	case "video":
		if u.video == nil {
			return nil, fmt.Errorf("field \"video\" is required")
		}
		return struct {
			Type  string        `json:"type"`
			Video rids.VideoRid `json:"video"`
		}{Type: "video", Video: *u.video}, nil
	}
}

func (u DataSource) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DataSource) UnmarshalJSON(data []byte) error {
	var deser dataSourceDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
	case "connection":
		if u.connection == nil {
			return fmt.Errorf("field \"connection\" is required")
		}
	case "logSet":
		if u.logSet == nil {
			return fmt.Errorf("field \"logSet\" is required")
		}
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
	}
	return nil
}

func (u DataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DataSource) AcceptFuncs(datasetFunc func(rids.DatasetRid) error, connectionFunc func(ConnectionRid) error, logSetFunc func(LogSetRid) error, videoFunc func(rids.VideoRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
		return datasetFunc(*u.dataset)
	case "connection":
		if u.connection == nil {
			return fmt.Errorf("field \"connection\" is required")
		}
		return connectionFunc(*u.connection)
	case "logSet":
		if u.logSet == nil {
			return fmt.Errorf("field \"logSet\" is required")
		}
		return logSetFunc(*u.logSet)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	}
}

func (u *DataSource) DatasetNoopSuccess(rids.DatasetRid) error {
	return nil
}

func (u *DataSource) ConnectionNoopSuccess(ConnectionRid) error {
	return nil
}

func (u *DataSource) LogSetNoopSuccess(LogSetRid) error {
	return nil
}

func (u *DataSource) VideoNoopSuccess(rids.VideoRid) error {
	return nil
}

func (u *DataSource) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DataSource) Accept(v DataSourceVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
		return v.VisitDataset(*u.dataset)
	case "connection":
		if u.connection == nil {
			return fmt.Errorf("field \"connection\" is required")
		}
		return v.VisitConnection(*u.connection)
	case "logSet":
		if u.logSet == nil {
			return fmt.Errorf("field \"logSet\" is required")
		}
		return v.VisitLogSet(*u.logSet)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(*u.video)
	}
}

type DataSourceVisitor interface {
	VisitDataset(v rids.DatasetRid) error
	VisitConnection(v ConnectionRid) error
	VisitLogSet(v LogSetRid) error
	VisitVideo(v rids.VideoRid) error
	VisitUnknown(typeName string) error
}

func (u *DataSource) AcceptWithContext(ctx context.Context, v DataSourceVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
		return v.VisitDatasetWithContext(ctx, *u.dataset)
	case "connection":
		if u.connection == nil {
			return fmt.Errorf("field \"connection\" is required")
		}
		return v.VisitConnectionWithContext(ctx, *u.connection)
	case "logSet":
		if u.logSet == nil {
			return fmt.Errorf("field \"logSet\" is required")
		}
		return v.VisitLogSetWithContext(ctx, *u.logSet)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideoWithContext(ctx, *u.video)
	}
}

type DataSourceVisitorWithContext interface {
	VisitDatasetWithContext(ctx context.Context, v rids.DatasetRid) error
	VisitConnectionWithContext(ctx context.Context, v ConnectionRid) error
	VisitLogSetWithContext(ctx context.Context, v LogSetRid) error
	VisitVideoWithContext(ctx context.Context, v rids.VideoRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDataSourceFromDataset(v rids.DatasetRid) DataSource {
	return DataSource{typ: "dataset", dataset: &v}
}

func NewDataSourceFromConnection(v ConnectionRid) DataSource {
	return DataSource{typ: "connection", connection: &v}
}

func NewDataSourceFromLogSet(v LogSetRid) DataSource {
	return DataSource{typ: "logSet", logSet: &v}
}

func NewDataSourceFromVideo(v rids.VideoRid) DataSource {
	return DataSource{typ: "video", video: &v}
}

type SearchQuery struct {
	typ                    string
	startTimeInclusive     *UtcTimestamp
	startTime              *TimeframeFilter
	endTimeInclusive       *UtcTimestamp
	endTime                *TimeframeFilter
	timeRange              *TimeRangeFilter
	createdAt              *TimeframeFilter
	exactMatch             *string
	searchText             *string
	asset                  *api.AssetRid
	assets                 *AssetsFilter
	isSingleAsset          *bool
	label                  *api1.Label
	labels                 *api.LabelsFilter
	property               *api1.Property
	properties             *api.PropertiesFilter
	dataSourceSeriesTag    *DataSourceSeriesTag
	dataSourceRefName      *api2.DataSourceRefName
	dataSource             *DataSource
	runNumber              *safelong.SafeLong
	runPrefix              *string
	checkAlertStatesFilter *CheckAlertStatesFilter
	archived               *bool
	and                    *[]SearchQuery
	or                     *[]SearchQuery
	not                    *SearchQuery
	workspace              *rids.WorkspaceRid
}

type searchQueryDeserializer struct {
	Type                   string                  `json:"type"`
	StartTimeInclusive     *UtcTimestamp           `json:"startTimeInclusive"`
	StartTime              *TimeframeFilter        `json:"startTime"`
	EndTimeInclusive       *UtcTimestamp           `json:"endTimeInclusive"`
	EndTime                *TimeframeFilter        `json:"endTime"`
	TimeRange              *TimeRangeFilter        `json:"timeRange"`
	CreatedAt              *TimeframeFilter        `json:"createdAt"`
	ExactMatch             *string                 `json:"exactMatch"`
	SearchText             *string                 `json:"searchText"`
	Asset                  *api.AssetRid           `json:"asset"`
	Assets                 *AssetsFilter           `json:"assets"`
	IsSingleAsset          *bool                   `json:"isSingleAsset"`
	Label                  *api1.Label             `json:"label"`
	Labels                 *api.LabelsFilter       `json:"labels"`
	Property               *api1.Property          `json:"property"`
	Properties             *api.PropertiesFilter   `json:"properties"`
	DataSourceSeriesTag    *DataSourceSeriesTag    `json:"dataSourceSeriesTag"`
	DataSourceRefName      *api2.DataSourceRefName `json:"dataSourceRefName"`
	DataSource             *DataSource             `json:"dataSource"`
	RunNumber              *safelong.SafeLong      `json:"runNumber"`
	RunPrefix              *string                 `json:"runPrefix"`
	CheckAlertStatesFilter *CheckAlertStatesFilter `json:"checkAlertStatesFilter"`
	Archived               *bool                   `json:"archived"`
	And                    *[]SearchQuery          `json:"and"`
	Or                     *[]SearchQuery          `json:"or"`
	Not                    *SearchQuery            `json:"not"`
	Workspace              *rids.WorkspaceRid      `json:"workspace"`
}

func (u *searchQueryDeserializer) toStruct() SearchQuery {
	return SearchQuery{typ: u.Type, startTimeInclusive: u.StartTimeInclusive, startTime: u.StartTime, endTimeInclusive: u.EndTimeInclusive, endTime: u.EndTime, timeRange: u.TimeRange, createdAt: u.CreatedAt, exactMatch: u.ExactMatch, searchText: u.SearchText, asset: u.Asset, assets: u.Assets, isSingleAsset: u.IsSingleAsset, label: u.Label, labels: u.Labels, property: u.Property, properties: u.Properties, dataSourceSeriesTag: u.DataSourceSeriesTag, dataSourceRefName: u.DataSourceRefName, dataSource: u.DataSource, runNumber: u.RunNumber, runPrefix: u.RunPrefix, checkAlertStatesFilter: u.CheckAlertStatesFilter, archived: u.Archived, and: u.And, or: u.Or, not: u.Not, workspace: u.Workspace}
}

func (u *SearchQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return nil, fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return struct {
			Type               string       `json:"type"`
			StartTimeInclusive UtcTimestamp `json:"startTimeInclusive"`
		}{Type: "startTimeInclusive", StartTimeInclusive: *u.startTimeInclusive}, nil
	case "startTime":
		if u.startTime == nil {
			return nil, fmt.Errorf("field \"startTime\" is required")
		}
		return struct {
			Type      string          `json:"type"`
			StartTime TimeframeFilter `json:"startTime"`
		}{Type: "startTime", StartTime: *u.startTime}, nil
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return nil, fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return struct {
			Type             string       `json:"type"`
			EndTimeInclusive UtcTimestamp `json:"endTimeInclusive"`
		}{Type: "endTimeInclusive", EndTimeInclusive: *u.endTimeInclusive}, nil
	case "endTime":
		if u.endTime == nil {
			return nil, fmt.Errorf("field \"endTime\" is required")
		}
		return struct {
			Type    string          `json:"type"`
			EndTime TimeframeFilter `json:"endTime"`
		}{Type: "endTime", EndTime: *u.endTime}, nil
	case "timeRange":
		if u.timeRange == nil {
			return nil, fmt.Errorf("field \"timeRange\" is required")
		}
		return struct {
			Type      string          `json:"type"`
			TimeRange TimeRangeFilter `json:"timeRange"`
		}{Type: "timeRange", TimeRange: *u.timeRange}, nil
	case "createdAt":
		if u.createdAt == nil {
			return nil, fmt.Errorf("field \"createdAt\" is required")
		}
		return struct {
			Type      string          `json:"type"`
			CreatedAt TimeframeFilter `json:"createdAt"`
		}{Type: "createdAt", CreatedAt: *u.createdAt}, nil
	case "exactMatch":
		if u.exactMatch == nil {
			return nil, fmt.Errorf("field \"exactMatch\" is required")
		}
		return struct {
			Type       string `json:"type"`
			ExactMatch string `json:"exactMatch"`
		}{Type: "exactMatch", ExactMatch: *u.exactMatch}, nil
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "asset":
		if u.asset == nil {
			return nil, fmt.Errorf("field \"asset\" is required")
		}
		return struct {
			Type  string       `json:"type"`
			Asset api.AssetRid `json:"asset"`
		}{Type: "asset", Asset: *u.asset}, nil
	case "assets":
		if u.assets == nil {
			return nil, fmt.Errorf("field \"assets\" is required")
		}
		return struct {
			Type   string       `json:"type"`
			Assets AssetsFilter `json:"assets"`
		}{Type: "assets", Assets: *u.assets}, nil
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return nil, fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return struct {
			Type          string `json:"type"`
			IsSingleAsset bool   `json:"isSingleAsset"`
		}{Type: "isSingleAsset", IsSingleAsset: *u.isSingleAsset}, nil
	case "label":
		if u.label == nil {
			return nil, fmt.Errorf("field \"label\" is required")
		}
		return struct {
			Type  string     `json:"type"`
			Label api1.Label `json:"label"`
		}{Type: "label", Label: *u.label}, nil
	case "labels":
		if u.labels == nil {
			return nil, fmt.Errorf("field \"labels\" is required")
		}
		return struct {
			Type   string           `json:"type"`
			Labels api.LabelsFilter `json:"labels"`
		}{Type: "labels", Labels: *u.labels}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string        `json:"type"`
			Property api1.Property `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "properties":
		if u.properties == nil {
			return nil, fmt.Errorf("field \"properties\" is required")
		}
		return struct {
			Type       string               `json:"type"`
			Properties api.PropertiesFilter `json:"properties"`
		}{Type: "properties", Properties: *u.properties}, nil
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return nil, fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return struct {
			Type                string              `json:"type"`
			DataSourceSeriesTag DataSourceSeriesTag `json:"dataSourceSeriesTag"`
		}{Type: "dataSourceSeriesTag", DataSourceSeriesTag: *u.dataSourceSeriesTag}, nil
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return nil, fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return struct {
			Type              string                 `json:"type"`
			DataSourceRefName api2.DataSourceRefName `json:"dataSourceRefName"`
		}{Type: "dataSourceRefName", DataSourceRefName: *u.dataSourceRefName}, nil
	case "dataSource":
		if u.dataSource == nil {
			return nil, fmt.Errorf("field \"dataSource\" is required")
		}
		return struct {
			Type       string     `json:"type"`
			DataSource DataSource `json:"dataSource"`
		}{Type: "dataSource", DataSource: *u.dataSource}, nil
	case "runNumber":
		if u.runNumber == nil {
			return nil, fmt.Errorf("field \"runNumber\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			RunNumber safelong.SafeLong `json:"runNumber"`
		}{Type: "runNumber", RunNumber: *u.runNumber}, nil
	case "runPrefix":
		if u.runPrefix == nil {
			return nil, fmt.Errorf("field \"runPrefix\" is required")
		}
		return struct {
			Type      string `json:"type"`
			RunPrefix string `json:"runPrefix"`
		}{Type: "runPrefix", RunPrefix: *u.runPrefix}, nil
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return nil, fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return struct {
			Type                   string                 `json:"type"`
			CheckAlertStatesFilter CheckAlertStatesFilter `json:"checkAlertStatesFilter"`
		}{Type: "checkAlertStatesFilter", CheckAlertStatesFilter: *u.checkAlertStatesFilter}, nil
	case "archived":
		if u.archived == nil {
			return nil, fmt.Errorf("field \"archived\" is required")
		}
		return struct {
			Type     string `json:"type"`
			Archived bool   `json:"archived"`
		}{Type: "archived", Archived: *u.archived}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string        `json:"type"`
			And  []SearchQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Or   []SearchQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string      `json:"type"`
			Not  SearchQuery `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	}
}

func (u SearchQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchQuery) UnmarshalJSON(data []byte) error {
	var deser searchQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return fmt.Errorf("field \"startTimeInclusive\" is required")
		}
	case "startTime":
		if u.startTime == nil {
			return fmt.Errorf("field \"startTime\" is required")
		}
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return fmt.Errorf("field \"endTimeInclusive\" is required")
		}
	case "endTime":
		if u.endTime == nil {
			return fmt.Errorf("field \"endTime\" is required")
		}
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
	case "createdAt":
		if u.createdAt == nil {
			return fmt.Errorf("field \"createdAt\" is required")
		}
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
	case "assets":
		if u.assets == nil {
			return fmt.Errorf("field \"assets\" is required")
		}
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return fmt.Errorf("field \"isSingleAsset\" is required")
		}
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
	case "labels":
		if u.labels == nil {
			return fmt.Errorf("field \"labels\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return fmt.Errorf("field \"dataSourceRefName\" is required")
		}
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
	case "runNumber":
		if u.runNumber == nil {
			return fmt.Errorf("field \"runNumber\" is required")
		}
	case "runPrefix":
		if u.runPrefix == nil {
			return fmt.Errorf("field \"runPrefix\" is required")
		}
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
	case "archived":
		if u.archived == nil {
			return fmt.Errorf("field \"archived\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	}
	return nil
}

func (u SearchQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchQuery) AcceptFuncs(startTimeInclusiveFunc func(UtcTimestamp) error, startTimeFunc func(TimeframeFilter) error, endTimeInclusiveFunc func(UtcTimestamp) error, endTimeFunc func(TimeframeFilter) error, timeRangeFunc func(TimeRangeFilter) error, createdAtFunc func(TimeframeFilter) error, exactMatchFunc func(string) error, searchTextFunc func(string) error, assetFunc func(api.AssetRid) error, assetsFunc func(AssetsFilter) error, isSingleAssetFunc func(bool) error, labelFunc func(api1.Label) error, labelsFunc func(api.LabelsFilter) error, propertyFunc func(api1.Property) error, propertiesFunc func(api.PropertiesFilter) error, dataSourceSeriesTagFunc func(DataSourceSeriesTag) error, dataSourceRefNameFunc func(api2.DataSourceRefName) error, dataSourceFunc func(DataSource) error, runNumberFunc func(safelong.SafeLong) error, runPrefixFunc func(string) error, checkAlertStatesFilterFunc func(CheckAlertStatesFilter) error, archivedFunc func(bool) error, andFunc func([]SearchQuery) error, orFunc func([]SearchQuery) error, notFunc func(SearchQuery) error, workspaceFunc func(rids.WorkspaceRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return startTimeInclusiveFunc(*u.startTimeInclusive)
	case "startTime":
		if u.startTime == nil {
			return fmt.Errorf("field \"startTime\" is required")
		}
		return startTimeFunc(*u.startTime)
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return endTimeInclusiveFunc(*u.endTimeInclusive)
	case "endTime":
		if u.endTime == nil {
			return fmt.Errorf("field \"endTime\" is required")
		}
		return endTimeFunc(*u.endTime)
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
		return timeRangeFunc(*u.timeRange)
	case "createdAt":
		if u.createdAt == nil {
			return fmt.Errorf("field \"createdAt\" is required")
		}
		return createdAtFunc(*u.createdAt)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return exactMatchFunc(*u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return assetFunc(*u.asset)
	case "assets":
		if u.assets == nil {
			return fmt.Errorf("field \"assets\" is required")
		}
		return assetsFunc(*u.assets)
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return isSingleAssetFunc(*u.isSingleAsset)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "labels":
		if u.labels == nil {
			return fmt.Errorf("field \"labels\" is required")
		}
		return labelsFunc(*u.labels)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
		return propertiesFunc(*u.properties)
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return dataSourceSeriesTagFunc(*u.dataSourceSeriesTag)
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return dataSourceRefNameFunc(*u.dataSourceRefName)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return dataSourceFunc(*u.dataSource)
	case "runNumber":
		if u.runNumber == nil {
			return fmt.Errorf("field \"runNumber\" is required")
		}
		return runNumberFunc(*u.runNumber)
	case "runPrefix":
		if u.runPrefix == nil {
			return fmt.Errorf("field \"runPrefix\" is required")
		}
		return runPrefixFunc(*u.runPrefix)
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return checkAlertStatesFilterFunc(*u.checkAlertStatesFilter)
	case "archived":
		if u.archived == nil {
			return fmt.Errorf("field \"archived\" is required")
		}
		return archivedFunc(*u.archived)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchQuery) StartTimeInclusiveNoopSuccess(UtcTimestamp) error {
	return nil
}

func (u *SearchQuery) StartTimeNoopSuccess(TimeframeFilter) error {
	return nil
}

func (u *SearchQuery) EndTimeInclusiveNoopSuccess(UtcTimestamp) error {
	return nil
}

func (u *SearchQuery) EndTimeNoopSuccess(TimeframeFilter) error {
	return nil
}

func (u *SearchQuery) TimeRangeNoopSuccess(TimeRangeFilter) error {
	return nil
}

func (u *SearchQuery) CreatedAtNoopSuccess(TimeframeFilter) error {
	return nil
}

func (u *SearchQuery) ExactMatchNoopSuccess(string) error {
	return nil
}

func (u *SearchQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *SearchQuery) AssetNoopSuccess(api.AssetRid) error {
	return nil
}

func (u *SearchQuery) AssetsNoopSuccess(AssetsFilter) error {
	return nil
}

func (u *SearchQuery) IsSingleAssetNoopSuccess(bool) error {
	return nil
}

func (u *SearchQuery) LabelNoopSuccess(api1.Label) error {
	return nil
}

func (u *SearchQuery) LabelsNoopSuccess(api.LabelsFilter) error {
	return nil
}

func (u *SearchQuery) PropertyNoopSuccess(api1.Property) error {
	return nil
}

func (u *SearchQuery) PropertiesNoopSuccess(api.PropertiesFilter) error {
	return nil
}

func (u *SearchQuery) DataSourceSeriesTagNoopSuccess(DataSourceSeriesTag) error {
	return nil
}

func (u *SearchQuery) DataSourceRefNameNoopSuccess(api2.DataSourceRefName) error {
	return nil
}

func (u *SearchQuery) DataSourceNoopSuccess(DataSource) error {
	return nil
}

func (u *SearchQuery) RunNumberNoopSuccess(safelong.SafeLong) error {
	return nil
}

func (u *SearchQuery) RunPrefixNoopSuccess(string) error {
	return nil
}

func (u *SearchQuery) CheckAlertStatesFilterNoopSuccess(CheckAlertStatesFilter) error {
	return nil
}

func (u *SearchQuery) ArchivedNoopSuccess(bool) error {
	return nil
}

func (u *SearchQuery) AndNoopSuccess([]SearchQuery) error {
	return nil
}

func (u *SearchQuery) OrNoopSuccess([]SearchQuery) error {
	return nil
}

func (u *SearchQuery) NotNoopSuccess(SearchQuery) error {
	return nil
}

func (u *SearchQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *SearchQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchQuery) Accept(v SearchQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return v.VisitStartTimeInclusive(*u.startTimeInclusive)
	case "startTime":
		if u.startTime == nil {
			return fmt.Errorf("field \"startTime\" is required")
		}
		return v.VisitStartTime(*u.startTime)
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return v.VisitEndTimeInclusive(*u.endTimeInclusive)
	case "endTime":
		if u.endTime == nil {
			return fmt.Errorf("field \"endTime\" is required")
		}
		return v.VisitEndTime(*u.endTime)
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
		return v.VisitTimeRange(*u.timeRange)
	case "createdAt":
		if u.createdAt == nil {
			return fmt.Errorf("field \"createdAt\" is required")
		}
		return v.VisitCreatedAt(*u.createdAt)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatch(*u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAsset(*u.asset)
	case "assets":
		if u.assets == nil {
			return fmt.Errorf("field \"assets\" is required")
		}
		return v.VisitAssets(*u.assets)
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return v.VisitIsSingleAsset(*u.isSingleAsset)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(*u.label)
	case "labels":
		if u.labels == nil {
			return fmt.Errorf("field \"labels\" is required")
		}
		return v.VisitLabels(*u.labels)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
		return v.VisitProperties(*u.properties)
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return v.VisitDataSourceSeriesTag(*u.dataSourceSeriesTag)
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return v.VisitDataSourceRefName(*u.dataSourceRefName)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return v.VisitDataSource(*u.dataSource)
	case "runNumber":
		if u.runNumber == nil {
			return fmt.Errorf("field \"runNumber\" is required")
		}
		return v.VisitRunNumber(*u.runNumber)
	case "runPrefix":
		if u.runPrefix == nil {
			return fmt.Errorf("field \"runPrefix\" is required")
		}
		return v.VisitRunPrefix(*u.runPrefix)
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return v.VisitCheckAlertStatesFilter(*u.checkAlertStatesFilter)
	case "archived":
		if u.archived == nil {
			return fmt.Errorf("field \"archived\" is required")
		}
		return v.VisitArchived(*u.archived)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	}
}

type SearchQueryVisitor interface {
	VisitStartTimeInclusive(v UtcTimestamp) error
	VisitStartTime(v TimeframeFilter) error
	VisitEndTimeInclusive(v UtcTimestamp) error
	VisitEndTime(v TimeframeFilter) error
	VisitTimeRange(v TimeRangeFilter) error
	VisitCreatedAt(v TimeframeFilter) error
	VisitExactMatch(v string) error
	VisitSearchText(v string) error
	VisitAsset(v api.AssetRid) error
	VisitAssets(v AssetsFilter) error
	VisitIsSingleAsset(v bool) error
	VisitLabel(v api1.Label) error
	VisitLabels(v api.LabelsFilter) error
	VisitProperty(v api1.Property) error
	VisitProperties(v api.PropertiesFilter) error
	VisitDataSourceSeriesTag(v DataSourceSeriesTag) error
	VisitDataSourceRefName(v api2.DataSourceRefName) error
	VisitDataSource(v DataSource) error
	VisitRunNumber(v safelong.SafeLong) error
	VisitRunPrefix(v string) error
	VisitCheckAlertStatesFilter(v CheckAlertStatesFilter) error
	VisitArchived(v bool) error
	VisitAnd(v []SearchQuery) error
	VisitOr(v []SearchQuery) error
	VisitNot(v SearchQuery) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitUnknown(typeName string) error
}

func (u *SearchQuery) AcceptWithContext(ctx context.Context, v SearchQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return v.VisitStartTimeInclusiveWithContext(ctx, *u.startTimeInclusive)
	case "startTime":
		if u.startTime == nil {
			return fmt.Errorf("field \"startTime\" is required")
		}
		return v.VisitStartTimeWithContext(ctx, *u.startTime)
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return v.VisitEndTimeInclusiveWithContext(ctx, *u.endTimeInclusive)
	case "endTime":
		if u.endTime == nil {
			return fmt.Errorf("field \"endTime\" is required")
		}
		return v.VisitEndTimeWithContext(ctx, *u.endTime)
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
		return v.VisitTimeRangeWithContext(ctx, *u.timeRange)
	case "createdAt":
		if u.createdAt == nil {
			return fmt.Errorf("field \"createdAt\" is required")
		}
		return v.VisitCreatedAtWithContext(ctx, *u.createdAt)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatchWithContext(ctx, *u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAssetWithContext(ctx, *u.asset)
	case "assets":
		if u.assets == nil {
			return fmt.Errorf("field \"assets\" is required")
		}
		return v.VisitAssetsWithContext(ctx, *u.assets)
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return v.VisitIsSingleAssetWithContext(ctx, *u.isSingleAsset)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabelWithContext(ctx, *u.label)
	case "labels":
		if u.labels == nil {
			return fmt.Errorf("field \"labels\" is required")
		}
		return v.VisitLabelsWithContext(ctx, *u.labels)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "properties":
		if u.properties == nil {
			return fmt.Errorf("field \"properties\" is required")
		}
		return v.VisitPropertiesWithContext(ctx, *u.properties)
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return v.VisitDataSourceSeriesTagWithContext(ctx, *u.dataSourceSeriesTag)
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return v.VisitDataSourceRefNameWithContext(ctx, *u.dataSourceRefName)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return v.VisitDataSourceWithContext(ctx, *u.dataSource)
	case "runNumber":
		if u.runNumber == nil {
			return fmt.Errorf("field \"runNumber\" is required")
		}
		return v.VisitRunNumberWithContext(ctx, *u.runNumber)
	case "runPrefix":
		if u.runPrefix == nil {
			return fmt.Errorf("field \"runPrefix\" is required")
		}
		return v.VisitRunPrefixWithContext(ctx, *u.runPrefix)
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return v.VisitCheckAlertStatesFilterWithContext(ctx, *u.checkAlertStatesFilter)
	case "archived":
		if u.archived == nil {
			return fmt.Errorf("field \"archived\" is required")
		}
		return v.VisitArchivedWithContext(ctx, *u.archived)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	}
}

type SearchQueryVisitorWithContext interface {
	VisitStartTimeInclusiveWithContext(ctx context.Context, v UtcTimestamp) error
	VisitStartTimeWithContext(ctx context.Context, v TimeframeFilter) error
	VisitEndTimeInclusiveWithContext(ctx context.Context, v UtcTimestamp) error
	VisitEndTimeWithContext(ctx context.Context, v TimeframeFilter) error
	VisitTimeRangeWithContext(ctx context.Context, v TimeRangeFilter) error
	VisitCreatedAtWithContext(ctx context.Context, v TimeframeFilter) error
	VisitExactMatchWithContext(ctx context.Context, v string) error
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitAssetWithContext(ctx context.Context, v api.AssetRid) error
	VisitAssetsWithContext(ctx context.Context, v AssetsFilter) error
	VisitIsSingleAssetWithContext(ctx context.Context, v bool) error
	VisitLabelWithContext(ctx context.Context, v api1.Label) error
	VisitLabelsWithContext(ctx context.Context, v api.LabelsFilter) error
	VisitPropertyWithContext(ctx context.Context, v api1.Property) error
	VisitPropertiesWithContext(ctx context.Context, v api.PropertiesFilter) error
	VisitDataSourceSeriesTagWithContext(ctx context.Context, v DataSourceSeriesTag) error
	VisitDataSourceRefNameWithContext(ctx context.Context, v api2.DataSourceRefName) error
	VisitDataSourceWithContext(ctx context.Context, v DataSource) error
	VisitRunNumberWithContext(ctx context.Context, v safelong.SafeLong) error
	VisitRunPrefixWithContext(ctx context.Context, v string) error
	VisitCheckAlertStatesFilterWithContext(ctx context.Context, v CheckAlertStatesFilter) error
	VisitArchivedWithContext(ctx context.Context, v bool) error
	VisitAndWithContext(ctx context.Context, v []SearchQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchQuery) error
	VisitNotWithContext(ctx context.Context, v SearchQuery) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchQueryFromStartTimeInclusive(v UtcTimestamp) SearchQuery {
	return SearchQuery{typ: "startTimeInclusive", startTimeInclusive: &v}
}

func NewSearchQueryFromStartTime(v TimeframeFilter) SearchQuery {
	return SearchQuery{typ: "startTime", startTime: &v}
}

func NewSearchQueryFromEndTimeInclusive(v UtcTimestamp) SearchQuery {
	return SearchQuery{typ: "endTimeInclusive", endTimeInclusive: &v}
}

func NewSearchQueryFromEndTime(v TimeframeFilter) SearchQuery {
	return SearchQuery{typ: "endTime", endTime: &v}
}

func NewSearchQueryFromTimeRange(v TimeRangeFilter) SearchQuery {
	return SearchQuery{typ: "timeRange", timeRange: &v}
}

func NewSearchQueryFromCreatedAt(v TimeframeFilter) SearchQuery {
	return SearchQuery{typ: "createdAt", createdAt: &v}
}

func NewSearchQueryFromExactMatch(v string) SearchQuery {
	return SearchQuery{typ: "exactMatch", exactMatch: &v}
}

func NewSearchQueryFromSearchText(v string) SearchQuery {
	return SearchQuery{typ: "searchText", searchText: &v}
}

func NewSearchQueryFromAsset(v api.AssetRid) SearchQuery {
	return SearchQuery{typ: "asset", asset: &v}
}

func NewSearchQueryFromAssets(v AssetsFilter) SearchQuery {
	return SearchQuery{typ: "assets", assets: &v}
}

func NewSearchQueryFromIsSingleAsset(v bool) SearchQuery {
	return SearchQuery{typ: "isSingleAsset", isSingleAsset: &v}
}

func NewSearchQueryFromLabel(v api1.Label) SearchQuery {
	return SearchQuery{typ: "label", label: &v}
}

func NewSearchQueryFromLabels(v api.LabelsFilter) SearchQuery {
	return SearchQuery{typ: "labels", labels: &v}
}

func NewSearchQueryFromProperty(v api1.Property) SearchQuery {
	return SearchQuery{typ: "property", property: &v}
}

func NewSearchQueryFromProperties(v api.PropertiesFilter) SearchQuery {
	return SearchQuery{typ: "properties", properties: &v}
}

func NewSearchQueryFromDataSourceSeriesTag(v DataSourceSeriesTag) SearchQuery {
	return SearchQuery{typ: "dataSourceSeriesTag", dataSourceSeriesTag: &v}
}

func NewSearchQueryFromDataSourceRefName(v api2.DataSourceRefName) SearchQuery {
	return SearchQuery{typ: "dataSourceRefName", dataSourceRefName: &v}
}

func NewSearchQueryFromDataSource(v DataSource) SearchQuery {
	return SearchQuery{typ: "dataSource", dataSource: &v}
}

func NewSearchQueryFromRunNumber(v safelong.SafeLong) SearchQuery {
	return SearchQuery{typ: "runNumber", runNumber: &v}
}

func NewSearchQueryFromRunPrefix(v string) SearchQuery {
	return SearchQuery{typ: "runPrefix", runPrefix: &v}
}

func NewSearchQueryFromCheckAlertStatesFilter(v CheckAlertStatesFilter) SearchQuery {
	return SearchQuery{typ: "checkAlertStatesFilter", checkAlertStatesFilter: &v}
}

func NewSearchQueryFromArchived(v bool) SearchQuery {
	return SearchQuery{typ: "archived", archived: &v}
}

func NewSearchQueryFromAnd(v []SearchQuery) SearchQuery {
	return SearchQuery{typ: "and", and: &v}
}

func NewSearchQueryFromOr(v []SearchQuery) SearchQuery {
	return SearchQuery{typ: "or", or: &v}
}

func NewSearchQueryFromNot(v SearchQuery) SearchQuery {
	return SearchQuery{typ: "not", not: &v}
}

func NewSearchQueryFromWorkspace(v rids.WorkspaceRid) SearchQuery {
	return SearchQuery{typ: "workspace", workspace: &v}
}

type SortKey struct {
	typ      string
	field    *SortField
	property *SortProperty
}

type sortKeyDeserializer struct {
	Type     string        `json:"type"`
	Field    *SortField    `json:"field"`
	Property *SortProperty `json:"property"`
}

func (u *sortKeyDeserializer) toStruct() SortKey {
	return SortKey{typ: u.Type, field: u.Field, property: u.Property}
}

func (u *SortKey) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "field":
		if u.field == nil {
			return nil, fmt.Errorf("field \"field\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Field SortField `json:"field"`
		}{Type: "field", Field: *u.field}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Property SortProperty `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	}
}

func (u SortKey) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SortKey) UnmarshalJSON(data []byte) error {
	var deser sortKeyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	}
	return nil
}

func (u SortKey) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SortKey) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SortKey) AcceptFuncs(fieldFunc func(SortField) error, propertyFunc func(SortProperty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return fieldFunc(*u.field)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	}
}

func (u *SortKey) FieldNoopSuccess(SortField) error {
	return nil
}

func (u *SortKey) PropertyNoopSuccess(SortProperty) error {
	return nil
}

func (u *SortKey) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SortKey) Accept(v SortKeyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return v.VisitField(*u.field)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	}
}

type SortKeyVisitor interface {
	VisitField(v SortField) error
	VisitProperty(v SortProperty) error
	VisitUnknown(typeName string) error
}

func (u *SortKey) AcceptWithContext(ctx context.Context, v SortKeyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return v.VisitFieldWithContext(ctx, *u.field)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	}
}

type SortKeyVisitorWithContext interface {
	VisitFieldWithContext(ctx context.Context, v SortField) error
	VisitPropertyWithContext(ctx context.Context, v SortProperty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSortKeyFromField(v SortField) SortKey {
	return SortKey{typ: "field", field: &v}
}

func NewSortKeyFromProperty(v SortProperty) SortKey {
	return SortKey{typ: "property", property: &v}
}

type TimeframeFilter struct {
	typ    string
	custom *CustomTimeframeFilter
	preset *PresetTimeframeFilter
}

type timeframeFilterDeserializer struct {
	Type   string                 `json:"type"`
	Custom *CustomTimeframeFilter `json:"custom"`
	Preset *PresetTimeframeFilter `json:"preset"`
}

func (u *timeframeFilterDeserializer) toStruct() TimeframeFilter {
	return TimeframeFilter{typ: u.Type, custom: u.Custom, preset: u.Preset}
}

func (u *TimeframeFilter) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "custom":
		if u.custom == nil {
			return nil, fmt.Errorf("field \"custom\" is required")
		}
		return struct {
			Type   string                `json:"type"`
			Custom CustomTimeframeFilter `json:"custom"`
		}{Type: "custom", Custom: *u.custom}, nil
	case "preset":
		if u.preset == nil {
			return nil, fmt.Errorf("field \"preset\" is required")
		}
		return struct {
			Type   string                `json:"type"`
			Preset PresetTimeframeFilter `json:"preset"`
		}{Type: "preset", Preset: *u.preset}, nil
	}
}

func (u TimeframeFilter) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimeframeFilter) UnmarshalJSON(data []byte) error {
	var deser timeframeFilterDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
	case "preset":
		if u.preset == nil {
			return fmt.Errorf("field \"preset\" is required")
		}
	}
	return nil
}

func (u TimeframeFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimeframeFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimeframeFilter) AcceptFuncs(customFunc func(CustomTimeframeFilter) error, presetFunc func(PresetTimeframeFilter) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	case "preset":
		if u.preset == nil {
			return fmt.Errorf("field \"preset\" is required")
		}
		return presetFunc(*u.preset)
	}
}

func (u *TimeframeFilter) CustomNoopSuccess(CustomTimeframeFilter) error {
	return nil
}

func (u *TimeframeFilter) PresetNoopSuccess(PresetTimeframeFilter) error {
	return nil
}

func (u *TimeframeFilter) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimeframeFilter) Accept(v TimeframeFilterVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(*u.custom)
	case "preset":
		if u.preset == nil {
			return fmt.Errorf("field \"preset\" is required")
		}
		return v.VisitPreset(*u.preset)
	}
}

type TimeframeFilterVisitor interface {
	VisitCustom(v CustomTimeframeFilter) error
	VisitPreset(v PresetTimeframeFilter) error
	VisitUnknown(typeName string) error
}

func (u *TimeframeFilter) AcceptWithContext(ctx context.Context, v TimeframeFilterVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustomWithContext(ctx, *u.custom)
	case "preset":
		if u.preset == nil {
			return fmt.Errorf("field \"preset\" is required")
		}
		return v.VisitPresetWithContext(ctx, *u.preset)
	}
}

type TimeframeFilterVisitorWithContext interface {
	VisitCustomWithContext(ctx context.Context, v CustomTimeframeFilter) error
	VisitPresetWithContext(ctx context.Context, v PresetTimeframeFilter) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimeframeFilterFromCustom(v CustomTimeframeFilter) TimeframeFilter {
	return TimeframeFilter{typ: "custom", custom: &v}
}

func NewTimeframeFilterFromPreset(v PresetTimeframeFilter) TimeframeFilter {
	return TimeframeFilter{typ: "preset", preset: &v}
}
