// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/api"
	"github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
)

type DataSource struct {
	typ        string
	dataset    *rids.DatasetRid
	connection *ConnectionRid
	logSet     *LogSetRid
	video      *rids.VideoRid
}

type dataSourceDeserializer struct {
	Type       string           `json:"type"`
	Dataset    *rids.DatasetRid `json:"dataset"`
	Connection *ConnectionRid   `json:"connection"`
	LogSet     *LogSetRid       `json:"logSet"`
	Video      *rids.VideoRid   `json:"video"`
}

func (u *dataSourceDeserializer) toStruct() DataSource {
	return DataSource{typ: u.Type, dataset: u.Dataset, connection: u.Connection, logSet: u.LogSet, video: u.Video}
}

func (u *DataSource) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "dataset":
		if u.dataset == nil {
			return nil, fmt.Errorf("field \"dataset\" is required")
		}
		return struct {
			Type    string          `json:"type"`
			Dataset rids.DatasetRid `json:"dataset"`
		}{Type: "dataset", Dataset: *u.dataset}, nil
	case "connection":
		if u.connection == nil {
			return nil, fmt.Errorf("field \"connection\" is required")
		}
		return struct {
			Type       string        `json:"type"`
			Connection ConnectionRid `json:"connection"`
		}{Type: "connection", Connection: *u.connection}, nil
	case "logSet":
		if u.logSet == nil {
			return nil, fmt.Errorf("field \"logSet\" is required")
		}
		return struct {
			Type   string    `json:"type"`
			LogSet LogSetRid `json:"logSet"`
		}{Type: "logSet", LogSet: *u.logSet}, nil
	case "video":
		if u.video == nil {
			return nil, fmt.Errorf("field \"video\" is required")
		}
		return struct {
			Type  string        `json:"type"`
			Video rids.VideoRid `json:"video"`
		}{Type: "video", Video: *u.video}, nil
	}
}

func (u DataSource) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DataSource) UnmarshalJSON(data []byte) error {
	var deser dataSourceDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
	case "connection":
		if u.connection == nil {
			return fmt.Errorf("field \"connection\" is required")
		}
	case "logSet":
		if u.logSet == nil {
			return fmt.Errorf("field \"logSet\" is required")
		}
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
	}
	return nil
}

func (u DataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DataSource) AcceptFuncs(datasetFunc func(rids.DatasetRid) error, connectionFunc func(ConnectionRid) error, logSetFunc func(LogSetRid) error, videoFunc func(rids.VideoRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
		return datasetFunc(*u.dataset)
	case "connection":
		if u.connection == nil {
			return fmt.Errorf("field \"connection\" is required")
		}
		return connectionFunc(*u.connection)
	case "logSet":
		if u.logSet == nil {
			return fmt.Errorf("field \"logSet\" is required")
		}
		return logSetFunc(*u.logSet)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	}
}

func (u *DataSource) DatasetNoopSuccess(rids.DatasetRid) error {
	return nil
}

func (u *DataSource) ConnectionNoopSuccess(ConnectionRid) error {
	return nil
}

func (u *DataSource) LogSetNoopSuccess(LogSetRid) error {
	return nil
}

func (u *DataSource) VideoNoopSuccess(rids.VideoRid) error {
	return nil
}

func (u *DataSource) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DataSource) Accept(v DataSourceVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
		return v.VisitDataset(*u.dataset)
	case "connection":
		if u.connection == nil {
			return fmt.Errorf("field \"connection\" is required")
		}
		return v.VisitConnection(*u.connection)
	case "logSet":
		if u.logSet == nil {
			return fmt.Errorf("field \"logSet\" is required")
		}
		return v.VisitLogSet(*u.logSet)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(*u.video)
	}
}

type DataSourceVisitor interface {
	VisitDataset(v rids.DatasetRid) error
	VisitConnection(v ConnectionRid) error
	VisitLogSet(v LogSetRid) error
	VisitVideo(v rids.VideoRid) error
	VisitUnknown(typeName string) error
}

func (u *DataSource) AcceptWithContext(ctx context.Context, v DataSourceVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
		return v.VisitDatasetWithContext(ctx, *u.dataset)
	case "connection":
		if u.connection == nil {
			return fmt.Errorf("field \"connection\" is required")
		}
		return v.VisitConnectionWithContext(ctx, *u.connection)
	case "logSet":
		if u.logSet == nil {
			return fmt.Errorf("field \"logSet\" is required")
		}
		return v.VisitLogSetWithContext(ctx, *u.logSet)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideoWithContext(ctx, *u.video)
	}
}

type DataSourceVisitorWithContext interface {
	VisitDatasetWithContext(ctx context.Context, v rids.DatasetRid) error
	VisitConnectionWithContext(ctx context.Context, v ConnectionRid) error
	VisitLogSetWithContext(ctx context.Context, v LogSetRid) error
	VisitVideoWithContext(ctx context.Context, v rids.VideoRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDataSourceFromDataset(v rids.DatasetRid) DataSource {
	return DataSource{typ: "dataset", dataset: &v}
}

func NewDataSourceFromConnection(v ConnectionRid) DataSource {
	return DataSource{typ: "connection", connection: &v}
}

func NewDataSourceFromLogSet(v LogSetRid) DataSource {
	return DataSource{typ: "logSet", logSet: &v}
}

func NewDataSourceFromVideo(v rids.VideoRid) DataSource {
	return DataSource{typ: "video", video: &v}
}

type SearchQuery struct {
	typ                    string
	startTimeInclusive     *UtcTimestamp
	endTimeInclusive       *UtcTimestamp
	timeRange              *TimeRangeFilter
	exactMatch             *string
	searchText             *string
	asset                  *api.AssetRid
	isSingleAsset          *bool
	label                  *api1.Label
	property               *api1.Property
	dataSourceSeriesTag    *DataSourceSeriesTag
	dataSourceRefName      *api2.DataSourceRefName
	dataSource             *DataSource
	runNumber              *safelong.SafeLong
	runPrefix              *string
	checkAlertStatesFilter *CheckAlertStatesFilter
	and                    *[]SearchQuery
	or                     *[]SearchQuery
	not                    *SearchQuery
	workspace              *rids.WorkspaceRid
}

type searchQueryDeserializer struct {
	Type                   string                  `json:"type"`
	StartTimeInclusive     *UtcTimestamp           `json:"startTimeInclusive"`
	EndTimeInclusive       *UtcTimestamp           `json:"endTimeInclusive"`
	TimeRange              *TimeRangeFilter        `json:"timeRange"`
	ExactMatch             *string                 `json:"exactMatch"`
	SearchText             *string                 `json:"searchText"`
	Asset                  *api.AssetRid           `json:"asset"`
	IsSingleAsset          *bool                   `json:"isSingleAsset"`
	Label                  *api1.Label             `json:"label"`
	Property               *api1.Property          `json:"property"`
	DataSourceSeriesTag    *DataSourceSeriesTag    `json:"dataSourceSeriesTag"`
	DataSourceRefName      *api2.DataSourceRefName `json:"dataSourceRefName"`
	DataSource             *DataSource             `json:"dataSource"`
	RunNumber              *safelong.SafeLong      `json:"runNumber"`
	RunPrefix              *string                 `json:"runPrefix"`
	CheckAlertStatesFilter *CheckAlertStatesFilter `json:"checkAlertStatesFilter"`
	And                    *[]SearchQuery          `json:"and"`
	Or                     *[]SearchQuery          `json:"or"`
	Not                    *SearchQuery            `json:"not"`
	Workspace              *rids.WorkspaceRid      `json:"workspace"`
}

func (u *searchQueryDeserializer) toStruct() SearchQuery {
	return SearchQuery{typ: u.Type, startTimeInclusive: u.StartTimeInclusive, endTimeInclusive: u.EndTimeInclusive, timeRange: u.TimeRange, exactMatch: u.ExactMatch, searchText: u.SearchText, asset: u.Asset, isSingleAsset: u.IsSingleAsset, label: u.Label, property: u.Property, dataSourceSeriesTag: u.DataSourceSeriesTag, dataSourceRefName: u.DataSourceRefName, dataSource: u.DataSource, runNumber: u.RunNumber, runPrefix: u.RunPrefix, checkAlertStatesFilter: u.CheckAlertStatesFilter, and: u.And, or: u.Or, not: u.Not, workspace: u.Workspace}
}

func (u *SearchQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return nil, fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return struct {
			Type               string       `json:"type"`
			StartTimeInclusive UtcTimestamp `json:"startTimeInclusive"`
		}{Type: "startTimeInclusive", StartTimeInclusive: *u.startTimeInclusive}, nil
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return nil, fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return struct {
			Type             string       `json:"type"`
			EndTimeInclusive UtcTimestamp `json:"endTimeInclusive"`
		}{Type: "endTimeInclusive", EndTimeInclusive: *u.endTimeInclusive}, nil
	case "timeRange":
		if u.timeRange == nil {
			return nil, fmt.Errorf("field \"timeRange\" is required")
		}
		return struct {
			Type      string          `json:"type"`
			TimeRange TimeRangeFilter `json:"timeRange"`
		}{Type: "timeRange", TimeRange: *u.timeRange}, nil
	case "exactMatch":
		if u.exactMatch == nil {
			return nil, fmt.Errorf("field \"exactMatch\" is required")
		}
		return struct {
			Type       string `json:"type"`
			ExactMatch string `json:"exactMatch"`
		}{Type: "exactMatch", ExactMatch: *u.exactMatch}, nil
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "asset":
		if u.asset == nil {
			return nil, fmt.Errorf("field \"asset\" is required")
		}
		return struct {
			Type  string       `json:"type"`
			Asset api.AssetRid `json:"asset"`
		}{Type: "asset", Asset: *u.asset}, nil
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return nil, fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return struct {
			Type          string `json:"type"`
			IsSingleAsset bool   `json:"isSingleAsset"`
		}{Type: "isSingleAsset", IsSingleAsset: *u.isSingleAsset}, nil
	case "label":
		if u.label == nil {
			return nil, fmt.Errorf("field \"label\" is required")
		}
		return struct {
			Type  string     `json:"type"`
			Label api1.Label `json:"label"`
		}{Type: "label", Label: *u.label}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string        `json:"type"`
			Property api1.Property `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return nil, fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return struct {
			Type                string              `json:"type"`
			DataSourceSeriesTag DataSourceSeriesTag `json:"dataSourceSeriesTag"`
		}{Type: "dataSourceSeriesTag", DataSourceSeriesTag: *u.dataSourceSeriesTag}, nil
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return nil, fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return struct {
			Type              string                 `json:"type"`
			DataSourceRefName api2.DataSourceRefName `json:"dataSourceRefName"`
		}{Type: "dataSourceRefName", DataSourceRefName: *u.dataSourceRefName}, nil
	case "dataSource":
		if u.dataSource == nil {
			return nil, fmt.Errorf("field \"dataSource\" is required")
		}
		return struct {
			Type       string     `json:"type"`
			DataSource DataSource `json:"dataSource"`
		}{Type: "dataSource", DataSource: *u.dataSource}, nil
	case "runNumber":
		if u.runNumber == nil {
			return nil, fmt.Errorf("field \"runNumber\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			RunNumber safelong.SafeLong `json:"runNumber"`
		}{Type: "runNumber", RunNumber: *u.runNumber}, nil
	case "runPrefix":
		if u.runPrefix == nil {
			return nil, fmt.Errorf("field \"runPrefix\" is required")
		}
		return struct {
			Type      string `json:"type"`
			RunPrefix string `json:"runPrefix"`
		}{Type: "runPrefix", RunPrefix: *u.runPrefix}, nil
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return nil, fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return struct {
			Type                   string                 `json:"type"`
			CheckAlertStatesFilter CheckAlertStatesFilter `json:"checkAlertStatesFilter"`
		}{Type: "checkAlertStatesFilter", CheckAlertStatesFilter: *u.checkAlertStatesFilter}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string        `json:"type"`
			And  []SearchQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Or   []SearchQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string      `json:"type"`
			Not  SearchQuery `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	}
}

func (u SearchQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchQuery) UnmarshalJSON(data []byte) error {
	var deser searchQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return fmt.Errorf("field \"startTimeInclusive\" is required")
		}
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return fmt.Errorf("field \"endTimeInclusive\" is required")
		}
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return fmt.Errorf("field \"isSingleAsset\" is required")
		}
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return fmt.Errorf("field \"dataSourceRefName\" is required")
		}
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
	case "runNumber":
		if u.runNumber == nil {
			return fmt.Errorf("field \"runNumber\" is required")
		}
	case "runPrefix":
		if u.runPrefix == nil {
			return fmt.Errorf("field \"runPrefix\" is required")
		}
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	}
	return nil
}

func (u SearchQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchQuery) AcceptFuncs(startTimeInclusiveFunc func(UtcTimestamp) error, endTimeInclusiveFunc func(UtcTimestamp) error, timeRangeFunc func(TimeRangeFilter) error, exactMatchFunc func(string) error, searchTextFunc func(string) error, assetFunc func(api.AssetRid) error, isSingleAssetFunc func(bool) error, labelFunc func(api1.Label) error, propertyFunc func(api1.Property) error, dataSourceSeriesTagFunc func(DataSourceSeriesTag) error, dataSourceRefNameFunc func(api2.DataSourceRefName) error, dataSourceFunc func(DataSource) error, runNumberFunc func(safelong.SafeLong) error, runPrefixFunc func(string) error, checkAlertStatesFilterFunc func(CheckAlertStatesFilter) error, andFunc func([]SearchQuery) error, orFunc func([]SearchQuery) error, notFunc func(SearchQuery) error, workspaceFunc func(rids.WorkspaceRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return startTimeInclusiveFunc(*u.startTimeInclusive)
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return endTimeInclusiveFunc(*u.endTimeInclusive)
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
		return timeRangeFunc(*u.timeRange)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return exactMatchFunc(*u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return assetFunc(*u.asset)
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return isSingleAssetFunc(*u.isSingleAsset)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return dataSourceSeriesTagFunc(*u.dataSourceSeriesTag)
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return dataSourceRefNameFunc(*u.dataSourceRefName)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return dataSourceFunc(*u.dataSource)
	case "runNumber":
		if u.runNumber == nil {
			return fmt.Errorf("field \"runNumber\" is required")
		}
		return runNumberFunc(*u.runNumber)
	case "runPrefix":
		if u.runPrefix == nil {
			return fmt.Errorf("field \"runPrefix\" is required")
		}
		return runPrefixFunc(*u.runPrefix)
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return checkAlertStatesFilterFunc(*u.checkAlertStatesFilter)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchQuery) StartTimeInclusiveNoopSuccess(UtcTimestamp) error {
	return nil
}

func (u *SearchQuery) EndTimeInclusiveNoopSuccess(UtcTimestamp) error {
	return nil
}

func (u *SearchQuery) TimeRangeNoopSuccess(TimeRangeFilter) error {
	return nil
}

func (u *SearchQuery) ExactMatchNoopSuccess(string) error {
	return nil
}

func (u *SearchQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *SearchQuery) AssetNoopSuccess(api.AssetRid) error {
	return nil
}

func (u *SearchQuery) IsSingleAssetNoopSuccess(bool) error {
	return nil
}

func (u *SearchQuery) LabelNoopSuccess(api1.Label) error {
	return nil
}

func (u *SearchQuery) PropertyNoopSuccess(api1.Property) error {
	return nil
}

func (u *SearchQuery) DataSourceSeriesTagNoopSuccess(DataSourceSeriesTag) error {
	return nil
}

func (u *SearchQuery) DataSourceRefNameNoopSuccess(api2.DataSourceRefName) error {
	return nil
}

func (u *SearchQuery) DataSourceNoopSuccess(DataSource) error {
	return nil
}

func (u *SearchQuery) RunNumberNoopSuccess(safelong.SafeLong) error {
	return nil
}

func (u *SearchQuery) RunPrefixNoopSuccess(string) error {
	return nil
}

func (u *SearchQuery) CheckAlertStatesFilterNoopSuccess(CheckAlertStatesFilter) error {
	return nil
}

func (u *SearchQuery) AndNoopSuccess([]SearchQuery) error {
	return nil
}

func (u *SearchQuery) OrNoopSuccess([]SearchQuery) error {
	return nil
}

func (u *SearchQuery) NotNoopSuccess(SearchQuery) error {
	return nil
}

func (u *SearchQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *SearchQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchQuery) Accept(v SearchQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return v.VisitStartTimeInclusive(*u.startTimeInclusive)
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return v.VisitEndTimeInclusive(*u.endTimeInclusive)
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
		return v.VisitTimeRange(*u.timeRange)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatch(*u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAsset(*u.asset)
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return v.VisitIsSingleAsset(*u.isSingleAsset)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return v.VisitDataSourceSeriesTag(*u.dataSourceSeriesTag)
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return v.VisitDataSourceRefName(*u.dataSourceRefName)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return v.VisitDataSource(*u.dataSource)
	case "runNumber":
		if u.runNumber == nil {
			return fmt.Errorf("field \"runNumber\" is required")
		}
		return v.VisitRunNumber(*u.runNumber)
	case "runPrefix":
		if u.runPrefix == nil {
			return fmt.Errorf("field \"runPrefix\" is required")
		}
		return v.VisitRunPrefix(*u.runPrefix)
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return v.VisitCheckAlertStatesFilter(*u.checkAlertStatesFilter)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	}
}

type SearchQueryVisitor interface {
	VisitStartTimeInclusive(v UtcTimestamp) error
	VisitEndTimeInclusive(v UtcTimestamp) error
	VisitTimeRange(v TimeRangeFilter) error
	VisitExactMatch(v string) error
	VisitSearchText(v string) error
	VisitAsset(v api.AssetRid) error
	VisitIsSingleAsset(v bool) error
	VisitLabel(v api1.Label) error
	VisitProperty(v api1.Property) error
	VisitDataSourceSeriesTag(v DataSourceSeriesTag) error
	VisitDataSourceRefName(v api2.DataSourceRefName) error
	VisitDataSource(v DataSource) error
	VisitRunNumber(v safelong.SafeLong) error
	VisitRunPrefix(v string) error
	VisitCheckAlertStatesFilter(v CheckAlertStatesFilter) error
	VisitAnd(v []SearchQuery) error
	VisitOr(v []SearchQuery) error
	VisitNot(v SearchQuery) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitUnknown(typeName string) error
}

func (u *SearchQuery) AcceptWithContext(ctx context.Context, v SearchQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "startTimeInclusive":
		if u.startTimeInclusive == nil {
			return fmt.Errorf("field \"startTimeInclusive\" is required")
		}
		return v.VisitStartTimeInclusiveWithContext(ctx, *u.startTimeInclusive)
	case "endTimeInclusive":
		if u.endTimeInclusive == nil {
			return fmt.Errorf("field \"endTimeInclusive\" is required")
		}
		return v.VisitEndTimeInclusiveWithContext(ctx, *u.endTimeInclusive)
	case "timeRange":
		if u.timeRange == nil {
			return fmt.Errorf("field \"timeRange\" is required")
		}
		return v.VisitTimeRangeWithContext(ctx, *u.timeRange)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatchWithContext(ctx, *u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "asset":
		if u.asset == nil {
			return fmt.Errorf("field \"asset\" is required")
		}
		return v.VisitAssetWithContext(ctx, *u.asset)
	case "isSingleAsset":
		if u.isSingleAsset == nil {
			return fmt.Errorf("field \"isSingleAsset\" is required")
		}
		return v.VisitIsSingleAssetWithContext(ctx, *u.isSingleAsset)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabelWithContext(ctx, *u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "dataSourceSeriesTag":
		if u.dataSourceSeriesTag == nil {
			return fmt.Errorf("field \"dataSourceSeriesTag\" is required")
		}
		return v.VisitDataSourceSeriesTagWithContext(ctx, *u.dataSourceSeriesTag)
	case "dataSourceRefName":
		if u.dataSourceRefName == nil {
			return fmt.Errorf("field \"dataSourceRefName\" is required")
		}
		return v.VisitDataSourceRefNameWithContext(ctx, *u.dataSourceRefName)
	case "dataSource":
		if u.dataSource == nil {
			return fmt.Errorf("field \"dataSource\" is required")
		}
		return v.VisitDataSourceWithContext(ctx, *u.dataSource)
	case "runNumber":
		if u.runNumber == nil {
			return fmt.Errorf("field \"runNumber\" is required")
		}
		return v.VisitRunNumberWithContext(ctx, *u.runNumber)
	case "runPrefix":
		if u.runPrefix == nil {
			return fmt.Errorf("field \"runPrefix\" is required")
		}
		return v.VisitRunPrefixWithContext(ctx, *u.runPrefix)
	case "checkAlertStatesFilter":
		if u.checkAlertStatesFilter == nil {
			return fmt.Errorf("field \"checkAlertStatesFilter\" is required")
		}
		return v.VisitCheckAlertStatesFilterWithContext(ctx, *u.checkAlertStatesFilter)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	}
}

type SearchQueryVisitorWithContext interface {
	VisitStartTimeInclusiveWithContext(ctx context.Context, v UtcTimestamp) error
	VisitEndTimeInclusiveWithContext(ctx context.Context, v UtcTimestamp) error
	VisitTimeRangeWithContext(ctx context.Context, v TimeRangeFilter) error
	VisitExactMatchWithContext(ctx context.Context, v string) error
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitAssetWithContext(ctx context.Context, v api.AssetRid) error
	VisitIsSingleAssetWithContext(ctx context.Context, v bool) error
	VisitLabelWithContext(ctx context.Context, v api1.Label) error
	VisitPropertyWithContext(ctx context.Context, v api1.Property) error
	VisitDataSourceSeriesTagWithContext(ctx context.Context, v DataSourceSeriesTag) error
	VisitDataSourceRefNameWithContext(ctx context.Context, v api2.DataSourceRefName) error
	VisitDataSourceWithContext(ctx context.Context, v DataSource) error
	VisitRunNumberWithContext(ctx context.Context, v safelong.SafeLong) error
	VisitRunPrefixWithContext(ctx context.Context, v string) error
	VisitCheckAlertStatesFilterWithContext(ctx context.Context, v CheckAlertStatesFilter) error
	VisitAndWithContext(ctx context.Context, v []SearchQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchQuery) error
	VisitNotWithContext(ctx context.Context, v SearchQuery) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchQueryFromStartTimeInclusive(v UtcTimestamp) SearchQuery {
	return SearchQuery{typ: "startTimeInclusive", startTimeInclusive: &v}
}

func NewSearchQueryFromEndTimeInclusive(v UtcTimestamp) SearchQuery {
	return SearchQuery{typ: "endTimeInclusive", endTimeInclusive: &v}
}

func NewSearchQueryFromTimeRange(v TimeRangeFilter) SearchQuery {
	return SearchQuery{typ: "timeRange", timeRange: &v}
}

func NewSearchQueryFromExactMatch(v string) SearchQuery {
	return SearchQuery{typ: "exactMatch", exactMatch: &v}
}

func NewSearchQueryFromSearchText(v string) SearchQuery {
	return SearchQuery{typ: "searchText", searchText: &v}
}

func NewSearchQueryFromAsset(v api.AssetRid) SearchQuery {
	return SearchQuery{typ: "asset", asset: &v}
}

func NewSearchQueryFromIsSingleAsset(v bool) SearchQuery {
	return SearchQuery{typ: "isSingleAsset", isSingleAsset: &v}
}

func NewSearchQueryFromLabel(v api1.Label) SearchQuery {
	return SearchQuery{typ: "label", label: &v}
}

func NewSearchQueryFromProperty(v api1.Property) SearchQuery {
	return SearchQuery{typ: "property", property: &v}
}

func NewSearchQueryFromDataSourceSeriesTag(v DataSourceSeriesTag) SearchQuery {
	return SearchQuery{typ: "dataSourceSeriesTag", dataSourceSeriesTag: &v}
}

func NewSearchQueryFromDataSourceRefName(v api2.DataSourceRefName) SearchQuery {
	return SearchQuery{typ: "dataSourceRefName", dataSourceRefName: &v}
}

func NewSearchQueryFromDataSource(v DataSource) SearchQuery {
	return SearchQuery{typ: "dataSource", dataSource: &v}
}

func NewSearchQueryFromRunNumber(v safelong.SafeLong) SearchQuery {
	return SearchQuery{typ: "runNumber", runNumber: &v}
}

func NewSearchQueryFromRunPrefix(v string) SearchQuery {
	return SearchQuery{typ: "runPrefix", runPrefix: &v}
}

func NewSearchQueryFromCheckAlertStatesFilter(v CheckAlertStatesFilter) SearchQuery {
	return SearchQuery{typ: "checkAlertStatesFilter", checkAlertStatesFilter: &v}
}

func NewSearchQueryFromAnd(v []SearchQuery) SearchQuery {
	return SearchQuery{typ: "and", and: &v}
}

func NewSearchQueryFromOr(v []SearchQuery) SearchQuery {
	return SearchQuery{typ: "or", or: &v}
}

func NewSearchQueryFromNot(v SearchQuery) SearchQuery {
	return SearchQuery{typ: "not", not: &v}
}

func NewSearchQueryFromWorkspace(v rids.WorkspaceRid) SearchQuery {
	return SearchQuery{typ: "workspace", workspace: &v}
}

type SortKey struct {
	typ      string
	field    *SortField
	property *SortProperty
}

type sortKeyDeserializer struct {
	Type     string        `json:"type"`
	Field    *SortField    `json:"field"`
	Property *SortProperty `json:"property"`
}

func (u *sortKeyDeserializer) toStruct() SortKey {
	return SortKey{typ: u.Type, field: u.Field, property: u.Property}
}

func (u *SortKey) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "field":
		if u.field == nil {
			return nil, fmt.Errorf("field \"field\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Field SortField `json:"field"`
		}{Type: "field", Field: *u.field}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Property SortProperty `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	}
}

func (u SortKey) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SortKey) UnmarshalJSON(data []byte) error {
	var deser sortKeyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	}
	return nil
}

func (u SortKey) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SortKey) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SortKey) AcceptFuncs(fieldFunc func(SortField) error, propertyFunc func(SortProperty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return fieldFunc(*u.field)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	}
}

func (u *SortKey) FieldNoopSuccess(SortField) error {
	return nil
}

func (u *SortKey) PropertyNoopSuccess(SortProperty) error {
	return nil
}

func (u *SortKey) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SortKey) Accept(v SortKeyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return v.VisitField(*u.field)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	}
}

type SortKeyVisitor interface {
	VisitField(v SortField) error
	VisitProperty(v SortProperty) error
	VisitUnknown(typeName string) error
}

func (u *SortKey) AcceptWithContext(ctx context.Context, v SortKeyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "field":
		if u.field == nil {
			return fmt.Errorf("field \"field\" is required")
		}
		return v.VisitFieldWithContext(ctx, *u.field)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	}
}

type SortKeyVisitorWithContext interface {
	VisitFieldWithContext(ctx context.Context, v SortField) error
	VisitPropertyWithContext(ctx context.Context, v SortProperty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSortKeyFromField(v SortField) SortKey {
	return SortKey{typ: "field", field: &v}
}

func NewSortKeyFromProperty(v SortProperty) SortKey {
	return SortKey{typ: "property", property: &v}
}
