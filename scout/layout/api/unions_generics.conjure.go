// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"
)

type ChartPanelWithT[T any] ChartPanel

func (u *ChartPanelWithT[T]) Accept(ctx context.Context, v ChartPanelVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *ChartPanelWithT[T]) AcceptFuncs(v1Func func(ChartPanelV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ChartPanelWithT[T]) V1NoopSuccess(ChartPanelV1) (T, error) {
	var result T
	return result, nil
}

func (u *ChartPanelWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ChartPanelVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v ChartPanelV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type EmptyPanelWithT[T any] EmptyPanel

func (u *EmptyPanelWithT[T]) Accept(ctx context.Context, v EmptyPanelVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *EmptyPanelWithT[T]) AcceptFuncs(v1Func func(EmptyPanelV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *EmptyPanelWithT[T]) V1NoopSuccess(EmptyPanelV1) (T, error) {
	var result T
	return result, nil
}

func (u *EmptyPanelWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type EmptyPanelVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v EmptyPanelV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PanelWithT[T any] Panel

func (u *PanelWithT[T]) Accept(ctx context.Context, v PanelVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "viz":
		if u.viz == nil {
			return result, fmt.Errorf("field \"viz\" is required")
		}
		return v.VisitViz(ctx, *u.viz)
	case "chart":
		if u.chart == nil {
			return result, fmt.Errorf("field \"chart\" is required")
		}
		return v.VisitChart(ctx, *u.chart)
	case "empty":
		if u.empty == nil {
			return result, fmt.Errorf("field \"empty\" is required")
		}
		return v.VisitEmpty(ctx, *u.empty)
	case "split":
		if u.split == nil {
			return result, fmt.Errorf("field \"split\" is required")
		}
		return v.VisitSplit(ctx, *u.split)
	case "tabbed":
		if u.tabbed == nil {
			return result, fmt.Errorf("field \"tabbed\" is required")
		}
		return v.VisitTabbed(ctx, *u.tabbed)
	}
}

func (u *PanelWithT[T]) AcceptFuncs(vizFunc func(VizPanel) (T, error), chartFunc func(ChartPanel) (T, error), emptyFunc func(EmptyPanel) (T, error), splitFunc func(SplitPanel) (T, error), tabbedFunc func(TabbedPanel) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "viz":
		if u.viz == nil {
			return result, fmt.Errorf("field \"viz\" is required")
		}
		return vizFunc(*u.viz)
	case "chart":
		if u.chart == nil {
			return result, fmt.Errorf("field \"chart\" is required")
		}
		return chartFunc(*u.chart)
	case "empty":
		if u.empty == nil {
			return result, fmt.Errorf("field \"empty\" is required")
		}
		return emptyFunc(*u.empty)
	case "split":
		if u.split == nil {
			return result, fmt.Errorf("field \"split\" is required")
		}
		return splitFunc(*u.split)
	case "tabbed":
		if u.tabbed == nil {
			return result, fmt.Errorf("field \"tabbed\" is required")
		}
		return tabbedFunc(*u.tabbed)
	}
}

func (u *PanelWithT[T]) VizNoopSuccess(VizPanel) (T, error) {
	var result T
	return result, nil
}

func (u *PanelWithT[T]) ChartNoopSuccess(ChartPanel) (T, error) {
	var result T
	return result, nil
}

func (u *PanelWithT[T]) EmptyNoopSuccess(EmptyPanel) (T, error) {
	var result T
	return result, nil
}

func (u *PanelWithT[T]) SplitNoopSuccess(SplitPanel) (T, error) {
	var result T
	return result, nil
}

func (u *PanelWithT[T]) TabbedNoopSuccess(TabbedPanel) (T, error) {
	var result T
	return result, nil
}

func (u *PanelWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PanelVisitorWithT[T any] interface {
	VisitViz(ctx context.Context, v VizPanel) (T, error)
	VisitChart(ctx context.Context, v ChartPanel) (T, error)
	VisitEmpty(ctx context.Context, v EmptyPanel) (T, error)
	VisitSplit(ctx context.Context, v SplitPanel) (T, error)
	VisitTabbed(ctx context.Context, v TabbedPanel) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SingleTabWithT[T any] SingleTab

func (u *SingleTabWithT[T]) Accept(ctx context.Context, v SingleTabVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *SingleTabWithT[T]) AcceptFuncs(v1Func func(SingleTabV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *SingleTabWithT[T]) V1NoopSuccess(SingleTabV1) (T, error) {
	var result T
	return result, nil
}

func (u *SingleTabWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SingleTabVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v SingleTabV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SplitPanelWithT[T any] SplitPanel

func (u *SplitPanelWithT[T]) Accept(ctx context.Context, v SplitPanelVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *SplitPanelWithT[T]) AcceptFuncs(v1Func func(SplitPanelV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *SplitPanelWithT[T]) V1NoopSuccess(SplitPanelV1) (T, error) {
	var result T
	return result, nil
}

func (u *SplitPanelWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SplitPanelVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v SplitPanelV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TabbedPanelWithT[T any] TabbedPanel

func (u *TabbedPanelWithT[T]) Accept(ctx context.Context, v TabbedPanelVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *TabbedPanelWithT[T]) AcceptFuncs(v1Func func(TabbedPanelV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *TabbedPanelWithT[T]) V1NoopSuccess(TabbedPanelV1) (T, error) {
	var result T
	return result, nil
}

func (u *TabbedPanelWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TabbedPanelVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v TabbedPanelV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VizPanelWithT[T any] VizPanel

func (u *VizPanelWithT[T]) Accept(ctx context.Context, v VizPanelVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *VizPanelWithT[T]) AcceptFuncs(v1Func func(VizPanelV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *VizPanelWithT[T]) V1NoopSuccess(VizPanelV1) (T, error) {
	var result T
	return result, nil
}

func (u *VizPanelWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VizPanelVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v VizPanelV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type WorkbookLayoutWithT[T any] WorkbookLayout

func (u *WorkbookLayoutWithT[T]) Accept(ctx context.Context, v WorkbookLayoutVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *WorkbookLayoutWithT[T]) AcceptFuncs(v1Func func(WorkbookLayoutV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *WorkbookLayoutWithT[T]) V1NoopSuccess(WorkbookLayoutV1) (T, error) {
	var result T
	return result, nil
}

func (u *WorkbookLayoutWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type WorkbookLayoutVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v WorkbookLayoutV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
