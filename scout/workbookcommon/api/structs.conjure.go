// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/scout/api"
	api3 "github.com/nominal-io/nominal-api-go/scout/channelvariables/api"
	api4 "github.com/nominal-io/nominal-api-go/scout/chartdefinition/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/run/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
)

// An offset that can be applied to an asset.
type AssetOffset struct {
	Offset      *Offset                           `json:"offset,omitempty"`
	DataSources *map[api.DataSourceRefName]Offset `json:"dataSources,omitempty"`
}

func (o AssetOffset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AssetOffset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AssetSettings struct {
	Offset           *api1.UserDuration                           `json:"offset,omitempty"`
	DataScopeOffsets *map[api.DataSourceRefName]api1.UserDuration `json:"dataScopeOffsets,omitempty"`
}

func (o AssetSettings) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AssetSettings) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CheckAlertReference struct {
	CheckAlertRid api1.CheckAlertRid `json:"checkAlertRid"`
}

func (o CheckAlertReference) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CheckAlertReference) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EventReference struct {
	// Deprecated: Please use the rid field instead.
	EventUuid *uuid.UUID `json:"eventUuid,omitempty"`
	// The event's unique identifier.
	Rid rids.EventRid `conjure-docs:"The event's unique identifier." json:"rid"`
}

func (o EventReference) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EventReference) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// An offset that is defined relative to a target run.
type RunAlignment struct {
	AlignTo      RunAlignTo  `json:"alignTo"`
	TargetRunRid api2.RunRid `json:"targetRunRid"`
}

func (o RunAlignment) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RunAlignment) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// An offset that can be applied to a run.
type RunOffset struct {
	Offset *Offset                        `json:"offset,omitempty"`
	Assets *map[api1.AssetRid]AssetOffset `json:"assets,omitempty"`
}

func (o RunOffset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RunOffset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RunSettings struct {
	Offset        *api1.UserDuration               `json:"offset,omitempty"`
	AssetSettings *map[api1.AssetRid]AssetSettings `json:"assetSettings,omitempty"`
}

func (o RunSettings) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RunSettings) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A tag input contains tag key and tag value information that can apply
to a channel's compute tree. Applies the tag to both the tag filter
and tag group by fields of the series node in the compute tree.
*/
type Tag struct {
	// The key of the tag for the filter and group by compute arguments.
	Key TagString `conjure-docs:"The key of the tag for the filter and group by compute arguments." json:"key"`
	/*
	   The values of the tag to filter against.
	   An empty list will treat the tag as a wildcard, including all values in the compute
	*/
	Values []TagString `conjure-docs:"The values of the tag to filter against. \nAn empty list will treat the tag as a wildcard, including all values in the compute" json:"values"`
}

func (o Tag) MarshalJSON() ([]byte, error) {
	if o.Values == nil {
		o.Values = make([]TagString, 0)
	}
	type _tmpTag Tag
	return safejson.Marshal(_tmpTag(o))
}

func (o *Tag) UnmarshalJSON(data []byte) error {
	type _tmpTag Tag
	var rawTag _tmpTag
	if err := safejson.Unmarshal(data, &rawTag); err != nil {
		return err
	}
	if rawTag.Values == nil {
		rawTag.Values = make([]TagString, 0)
	}
	*o = Tag(rawTag)
	return nil
}

func (o Tag) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Tag) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A literal string value
type TagStringLiteral struct {
	/*
	   A unique identifier for this string. Cannot be shared across different Tag inputs.
	   Used as the variable id for the StringConstant applied to the tag fields
	   of the channel compute node.
	*/
	Id uuid.UUID `conjure-docs:"A unique identifier for this string. Cannot be shared across different Tag inputs.\nUsed as the variable id for the StringConstant applied to the tag fields \nof the channel compute node." json:"id"`
	// The string value.
	Value string `conjure-docs:"The string value." json:"value"`
}

func (o TagStringLiteral) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TagStringLiteral) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type WorkbookContent struct {
	ChannelVariables api3.WorkbookChannelVariableMap `json:"channelVariables"`
	Inputs           *WorkbookInputs                 `json:"inputs,omitempty"`
	// map of visualizations. Previously termed "charts"
	Charts   api4.WorkbookVizDefinitionMap `conjure-docs:"map of visualizations. Previously termed \"charts\"" json:"charts"`
	Settings *WorkbookSettings             `json:"settings,omitempty"`
}

func (o WorkbookContent) MarshalJSON() ([]byte, error) {
	if o.ChannelVariables == nil {
		o.ChannelVariables = make(map[api3.ChannelVariableName]api3.ChannelVariable, 0)
	}
	if o.Charts == nil {
		o.Charts = make(map[api1.VizId]api4.VizDefinition, 0)
	}
	type _tmpWorkbookContent WorkbookContent
	return safejson.Marshal(_tmpWorkbookContent(o))
}

func (o *WorkbookContent) UnmarshalJSON(data []byte) error {
	type _tmpWorkbookContent WorkbookContent
	var rawWorkbookContent _tmpWorkbookContent
	if err := safejson.Unmarshal(data, &rawWorkbookContent); err != nil {
		return err
	}
	if rawWorkbookContent.ChannelVariables == nil {
		rawWorkbookContent.ChannelVariables = make(map[api3.ChannelVariableName]api3.ChannelVariable, 0)
	}
	if rawWorkbookContent.Charts == nil {
		rawWorkbookContent.Charts = make(map[api1.VizId]api4.VizDefinition, 0)
	}
	*o = WorkbookContent(rawWorkbookContent)
	return nil
}

func (o WorkbookContent) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *WorkbookContent) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A workbook input is a value managed at the workbook level
that can be applied to multiple elements.
*/
type WorkbookInput struct {
	// The unique identifier of the input.
	Id uuid.UUID `conjure-docs:"The unique identifier of the input." json:"id"`
	// The label of the input for display purposes.
	Label *string   `conjure-docs:"The label of the input for display purposes." json:"label,omitempty"`
	Value InputType `json:"value"`
}

func (o WorkbookInput) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *WorkbookInput) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A list of workbook inputs.
type WorkbookInputsV1 struct {
	Inputs []WorkbookInput `json:"inputs"`
}

func (o WorkbookInputsV1) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]WorkbookInput, 0)
	}
	type _tmpWorkbookInputsV1 WorkbookInputsV1
	return safejson.Marshal(_tmpWorkbookInputsV1(o))
}

func (o *WorkbookInputsV1) UnmarshalJSON(data []byte) error {
	type _tmpWorkbookInputsV1 WorkbookInputsV1
	var rawWorkbookInputsV1 _tmpWorkbookInputsV1
	if err := safejson.Unmarshal(data, &rawWorkbookInputsV1); err != nil {
		return err
	}
	if rawWorkbookInputsV1.Inputs == nil {
		rawWorkbookInputsV1.Inputs = make([]WorkbookInput, 0)
	}
	*o = WorkbookInputsV1(rawWorkbookInputsV1)
	return nil
}

func (o WorkbookInputsV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *WorkbookInputsV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type WorkbookOffsetsV1 struct {
	Runs   map[api2.RunRid]RunOffset     `json:"runs"`
	Assets map[api1.AssetRid]AssetOffset `json:"assets"`
}

func (o WorkbookOffsetsV1) MarshalJSON() ([]byte, error) {
	if o.Runs == nil {
		o.Runs = make(map[api2.RunRid]RunOffset, 0)
	}
	if o.Assets == nil {
		o.Assets = make(map[api1.AssetRid]AssetOffset, 0)
	}
	type _tmpWorkbookOffsetsV1 WorkbookOffsetsV1
	return safejson.Marshal(_tmpWorkbookOffsetsV1(o))
}

func (o *WorkbookOffsetsV1) UnmarshalJSON(data []byte) error {
	type _tmpWorkbookOffsetsV1 WorkbookOffsetsV1
	var rawWorkbookOffsetsV1 _tmpWorkbookOffsetsV1
	if err := safejson.Unmarshal(data, &rawWorkbookOffsetsV1); err != nil {
		return err
	}
	if rawWorkbookOffsetsV1.Runs == nil {
		rawWorkbookOffsetsV1.Runs = make(map[api2.RunRid]RunOffset, 0)
	}
	if rawWorkbookOffsetsV1.Assets == nil {
		rawWorkbookOffsetsV1.Assets = make(map[api1.AssetRid]AssetOffset, 0)
	}
	*o = WorkbookOffsetsV1(rawWorkbookOffsetsV1)
	return nil
}

func (o WorkbookOffsetsV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *WorkbookOffsetsV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type WorkbookSettings struct {
	// Settings for assets to be used in the workbook. This should be present for asset workbooks.
	AssetSettings *map[api1.AssetRid]AssetSettings `conjure-docs:"Settings for assets to be used in the workbook. This should be present for asset workbooks." json:"assetSettings,omitempty"`
	// Settings for runs to be used in the workbook. This should be present for run workbooks.
	RunSettings *map[api2.RunRid]RunSettings `conjure-docs:"Settings for runs to be used in the workbook. This should be present for run workbooks." json:"runSettings,omitempty"`
	/*
	   Time range settings when users access a workbook. Time range URL query params will take precedence
	   over persisted the global time range.
	*/
	TimeSettings *WorkbookTimeSettings `conjure-docs:"Time range settings when users access a workbook. Time range URL query params will take precedence\nover persisted the global time range." json:"timeSettings,omitempty"`
	// Time offsets that can be applied to the workbook.
	Offsets *WorkbookOffsets `conjure-docs:"Time offsets that can be applied to the workbook." json:"offsets,omitempty"`
}

func (o WorkbookSettings) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *WorkbookSettings) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Time range configuration for workbooks
type WorkbookTimeSettingsV1 struct {
	// The time range type of the workbook
	TimeRangeType WorkbookTimeRangeType `conjure-docs:"The time range type of the workbook" json:"timeRangeType"`
	// The global time range a workbook falls back to.
	GlobalTimeRange *TimeRange `conjure-docs:"The global time range a workbook falls back to." json:"globalTimeRange,omitempty"`
	/*
	   If true, workbook will default to globalTimeRange for all tabs.
	   If false, will attempt to use tabTime to populate the workbook time range.
	*/
	IsGlobalTime  bool                 `conjure-docs:"If true, workbook will default to globalTimeRange for all tabs.\nIf false, will attempt to use tabTime to populate the workbook time range." json:"isGlobalTime"`
	TabTimeRanges map[string]TimeRange `json:"tabTimeRanges"`
}

func (o WorkbookTimeSettingsV1) MarshalJSON() ([]byte, error) {
	if o.TabTimeRanges == nil {
		o.TabTimeRanges = make(map[string]TimeRange, 0)
	}
	type _tmpWorkbookTimeSettingsV1 WorkbookTimeSettingsV1
	return safejson.Marshal(_tmpWorkbookTimeSettingsV1(o))
}

func (o *WorkbookTimeSettingsV1) UnmarshalJSON(data []byte) error {
	type _tmpWorkbookTimeSettingsV1 WorkbookTimeSettingsV1
	var rawWorkbookTimeSettingsV1 _tmpWorkbookTimeSettingsV1
	if err := safejson.Unmarshal(data, &rawWorkbookTimeSettingsV1); err != nil {
		return err
	}
	if rawWorkbookTimeSettingsV1.TabTimeRanges == nil {
		rawWorkbookTimeSettingsV1.TabTimeRanges = make(map[string]TimeRange, 0)
	}
	*o = WorkbookTimeSettingsV1(rawWorkbookTimeSettingsV1)
	return nil
}

func (o WorkbookTimeSettingsV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *WorkbookTimeSettingsV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
