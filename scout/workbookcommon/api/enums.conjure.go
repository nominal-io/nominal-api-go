// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"strings"
)

// The align to value for a run offset.
type RunAlignTo struct {
	val RunAlignTo_Value
}

type RunAlignTo_Value string

const (
	RunAlignTo_START   RunAlignTo_Value = "START"
	RunAlignTo_END     RunAlignTo_Value = "END"
	RunAlignTo_UNKNOWN RunAlignTo_Value = "UNKNOWN"
)

// RunAlignTo_Values returns all known variants of RunAlignTo.
func RunAlignTo_Values() []RunAlignTo_Value {
	return []RunAlignTo_Value{RunAlignTo_START, RunAlignTo_END}
}

func New_RunAlignTo(value RunAlignTo_Value) RunAlignTo {
	return RunAlignTo{val: value}
}

// IsUnknown returns false for all known variants of RunAlignTo and true otherwise.
func (e RunAlignTo) IsUnknown() bool {
	switch e.val {
	case RunAlignTo_START, RunAlignTo_END:
		return false
	}
	return true
}

func (e RunAlignTo) Value() RunAlignTo_Value {
	if e.IsUnknown() {
		return RunAlignTo_UNKNOWN
	}
	return e.val
}

func (e RunAlignTo) String() string {
	return string(e.val)
}

func (e RunAlignTo) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *RunAlignTo) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_RunAlignTo(RunAlignTo_Value(v))
	case "START":
		*e = New_RunAlignTo(RunAlignTo_START)
	case "END":
		*e = New_RunAlignTo(RunAlignTo_END)
	}
	return nil
}

type WorkbookTimeRangeType struct {
	val WorkbookTimeRangeType_Value
}

type WorkbookTimeRangeType_Value string

const (
	WorkbookTimeRangeType_ABSOLUTE WorkbookTimeRangeType_Value = "ABSOLUTE"
	WorkbookTimeRangeType_RELATIVE WorkbookTimeRangeType_Value = "RELATIVE"
	WorkbookTimeRangeType_UNKNOWN  WorkbookTimeRangeType_Value = "UNKNOWN"
)

// WorkbookTimeRangeType_Values returns all known variants of WorkbookTimeRangeType.
func WorkbookTimeRangeType_Values() []WorkbookTimeRangeType_Value {
	return []WorkbookTimeRangeType_Value{WorkbookTimeRangeType_ABSOLUTE, WorkbookTimeRangeType_RELATIVE}
}

func New_WorkbookTimeRangeType(value WorkbookTimeRangeType_Value) WorkbookTimeRangeType {
	return WorkbookTimeRangeType{val: value}
}

// IsUnknown returns false for all known variants of WorkbookTimeRangeType and true otherwise.
func (e WorkbookTimeRangeType) IsUnknown() bool {
	switch e.val {
	case WorkbookTimeRangeType_ABSOLUTE, WorkbookTimeRangeType_RELATIVE:
		return false
	}
	return true
}

func (e WorkbookTimeRangeType) Value() WorkbookTimeRangeType_Value {
	if e.IsUnknown() {
		return WorkbookTimeRangeType_UNKNOWN
	}
	return e.val
}

func (e WorkbookTimeRangeType) String() string {
	return string(e.val)
}

func (e WorkbookTimeRangeType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *WorkbookTimeRangeType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_WorkbookTimeRangeType(WorkbookTimeRangeType_Value(v))
	case "ABSOLUTE":
		*e = New_WorkbookTimeRangeType(WorkbookTimeRangeType_ABSOLUTE)
	case "RELATIVE":
		*e = New_WorkbookTimeRangeType(WorkbookTimeRangeType_RELATIVE)
	}
	return nil
}
