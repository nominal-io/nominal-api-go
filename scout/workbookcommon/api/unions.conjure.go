// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/scout/comparisonnotebook/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type InputType struct {
	typ string
	tag *Tag
}

type inputTypeDeserializer struct {
	Type string `json:"type"`
	Tag  *Tag   `json:"tag"`
}

func (u *inputTypeDeserializer) toStruct() InputType {
	return InputType{typ: u.Type, tag: u.Tag}
}

func (u *InputType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "tag":
		if u.tag == nil {
			return nil, fmt.Errorf("field \"tag\" is required")
		}
		return struct {
			Type string `json:"type"`
			Tag  Tag    `json:"tag"`
		}{Type: "tag", Tag: *u.tag}, nil
	}
}

func (u InputType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *InputType) UnmarshalJSON(data []byte) error {
	var deser inputTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "tag":
		if u.tag == nil {
			return fmt.Errorf("field \"tag\" is required")
		}
	}
	return nil
}

func (u InputType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *InputType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *InputType) AcceptFuncs(tagFunc func(Tag) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "tag":
		if u.tag == nil {
			return fmt.Errorf("field \"tag\" is required")
		}
		return tagFunc(*u.tag)
	}
}

func (u *InputType) TagNoopSuccess(Tag) error {
	return nil
}

func (u *InputType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *InputType) Accept(v InputTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "tag":
		if u.tag == nil {
			return fmt.Errorf("field \"tag\" is required")
		}
		return v.VisitTag(*u.tag)
	}
}

type InputTypeVisitor interface {
	VisitTag(v Tag) error
	VisitUnknown(typeName string) error
}

func (u *InputType) AcceptWithContext(ctx context.Context, v InputTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "tag":
		if u.tag == nil {
			return fmt.Errorf("field \"tag\" is required")
		}
		return v.VisitTagWithContext(ctx, *u.tag)
	}
}

type InputTypeVisitorWithContext interface {
	VisitTagWithContext(ctx context.Context, v Tag) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewInputTypeFromTag(v Tag) InputType {
	return InputType{typ: "tag", tag: &v}
}

type TagString struct {
	typ     string
	literal *TagStringLiteral
}

type tagStringDeserializer struct {
	Type    string            `json:"type"`
	Literal *TagStringLiteral `json:"literal"`
}

func (u *tagStringDeserializer) toStruct() TagString {
	return TagString{typ: u.Type, literal: u.Literal}
}

func (u *TagString) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string           `json:"type"`
			Literal TagStringLiteral `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	}
}

func (u TagString) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TagString) UnmarshalJSON(data []byte) error {
	var deser tagStringDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	}
	return nil
}

func (u TagString) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TagString) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TagString) AcceptFuncs(literalFunc func(TagStringLiteral) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	}
}

func (u *TagString) LiteralNoopSuccess(TagStringLiteral) error {
	return nil
}

func (u *TagString) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TagString) Accept(v TagStringVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	}
}

type TagStringVisitor interface {
	VisitLiteral(v TagStringLiteral) error
	VisitUnknown(typeName string) error
}

func (u *TagString) AcceptWithContext(ctx context.Context, v TagStringVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	}
}

type TagStringVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v TagStringLiteral) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTagStringFromLiteral(v TagStringLiteral) TagString {
	return TagString{typ: "literal", literal: &v}
}

type UnifiedWorkbookContent struct {
	typ                string
	workbook           *WorkbookContent
	comparisonWorkbook *api.ComparisonWorkbookContent
}

type unifiedWorkbookContentDeserializer struct {
	Type               string                         `json:"type"`
	Workbook           *WorkbookContent               `json:"workbook"`
	ComparisonWorkbook *api.ComparisonWorkbookContent `json:"comparisonWorkbook"`
}

func (u *unifiedWorkbookContentDeserializer) toStruct() UnifiedWorkbookContent {
	return UnifiedWorkbookContent{typ: u.Type, workbook: u.Workbook, comparisonWorkbook: u.ComparisonWorkbook}
}

func (u *UnifiedWorkbookContent) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "workbook":
		if u.workbook == nil {
			return nil, fmt.Errorf("field \"workbook\" is required")
		}
		return struct {
			Type     string          `json:"type"`
			Workbook WorkbookContent `json:"workbook"`
		}{Type: "workbook", Workbook: *u.workbook}, nil
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return nil, fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
		return struct {
			Type               string                        `json:"type"`
			ComparisonWorkbook api.ComparisonWorkbookContent `json:"comparisonWorkbook"`
		}{Type: "comparisonWorkbook", ComparisonWorkbook: *u.comparisonWorkbook}, nil
	}
}

func (u UnifiedWorkbookContent) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UnifiedWorkbookContent) UnmarshalJSON(data []byte) error {
	var deser unifiedWorkbookContentDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
	}
	return nil
}

func (u UnifiedWorkbookContent) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UnifiedWorkbookContent) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UnifiedWorkbookContent) AcceptFuncs(workbookFunc func(WorkbookContent) error, comparisonWorkbookFunc func(api.ComparisonWorkbookContent) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return workbookFunc(*u.workbook)
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
		return comparisonWorkbookFunc(*u.comparisonWorkbook)
	}
}

func (u *UnifiedWorkbookContent) WorkbookNoopSuccess(WorkbookContent) error {
	return nil
}

func (u *UnifiedWorkbookContent) ComparisonWorkbookNoopSuccess(api.ComparisonWorkbookContent) error {
	return nil
}

func (u *UnifiedWorkbookContent) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UnifiedWorkbookContent) Accept(v UnifiedWorkbookContentVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return v.VisitWorkbook(*u.workbook)
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
		return v.VisitComparisonWorkbook(*u.comparisonWorkbook)
	}
}

type UnifiedWorkbookContentVisitor interface {
	VisitWorkbook(v WorkbookContent) error
	VisitComparisonWorkbook(v api.ComparisonWorkbookContent) error
	VisitUnknown(typeName string) error
}

func (u *UnifiedWorkbookContent) AcceptWithContext(ctx context.Context, v UnifiedWorkbookContentVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return v.VisitWorkbookWithContext(ctx, *u.workbook)
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
		return v.VisitComparisonWorkbookWithContext(ctx, *u.comparisonWorkbook)
	}
}

type UnifiedWorkbookContentVisitorWithContext interface {
	VisitWorkbookWithContext(ctx context.Context, v WorkbookContent) error
	VisitComparisonWorkbookWithContext(ctx context.Context, v api.ComparisonWorkbookContent) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnifiedWorkbookContentFromWorkbook(v WorkbookContent) UnifiedWorkbookContent {
	return UnifiedWorkbookContent{typ: "workbook", workbook: &v}
}

func NewUnifiedWorkbookContentFromComparisonWorkbook(v api.ComparisonWorkbookContent) UnifiedWorkbookContent {
	return UnifiedWorkbookContent{typ: "comparisonWorkbook", comparisonWorkbook: &v}
}

type WorkbookInputs struct {
	typ string
	v1  *WorkbookInputsV1
}

type workbookInputsDeserializer struct {
	Type string            `json:"type"`
	V1   *WorkbookInputsV1 `json:"v1"`
}

func (u *workbookInputsDeserializer) toStruct() WorkbookInputs {
	return WorkbookInputs{typ: u.Type, v1: u.V1}
}

func (u *WorkbookInputs) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string           `json:"type"`
			V1   WorkbookInputsV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u WorkbookInputs) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *WorkbookInputs) UnmarshalJSON(data []byte) error {
	var deser workbookInputsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u WorkbookInputs) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *WorkbookInputs) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *WorkbookInputs) AcceptFuncs(v1Func func(WorkbookInputsV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *WorkbookInputs) V1NoopSuccess(WorkbookInputsV1) error {
	return nil
}

func (u *WorkbookInputs) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *WorkbookInputs) Accept(v WorkbookInputsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type WorkbookInputsVisitor interface {
	VisitV1(v WorkbookInputsV1) error
	VisitUnknown(typeName string) error
}

func (u *WorkbookInputs) AcceptWithContext(ctx context.Context, v WorkbookInputsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type WorkbookInputsVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v WorkbookInputsV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewWorkbookInputsFromV1(v WorkbookInputsV1) WorkbookInputs {
	return WorkbookInputs{typ: "v1", v1: &v}
}
