// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	api1 "github.com/nominal-io/nominal-api-go/scout/comparisonnotebook/api"
	"github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type InputType struct {
	typ string
	tag *Tag
}

type inputTypeDeserializer struct {
	Type string `json:"type"`
	Tag  *Tag   `json:"tag"`
}

func (u *inputTypeDeserializer) toStruct() InputType {
	return InputType{typ: u.Type, tag: u.Tag}
}

func (u *InputType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "tag":
		if u.tag == nil {
			return nil, fmt.Errorf("field \"tag\" is required")
		}
		return struct {
			Type string `json:"type"`
			Tag  Tag    `json:"tag"`
		}{Type: "tag", Tag: *u.tag}, nil
	}
}

func (u InputType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *InputType) UnmarshalJSON(data []byte) error {
	var deser inputTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "tag":
		if u.tag == nil {
			return fmt.Errorf("field \"tag\" is required")
		}
	}
	return nil
}

func (u InputType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *InputType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *InputType) AcceptFuncs(tagFunc func(Tag) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "tag":
		if u.tag == nil {
			return fmt.Errorf("field \"tag\" is required")
		}
		return tagFunc(*u.tag)
	}
}

func (u *InputType) TagNoopSuccess(Tag) error {
	return nil
}

func (u *InputType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *InputType) Accept(v InputTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "tag":
		if u.tag == nil {
			return fmt.Errorf("field \"tag\" is required")
		}
		return v.VisitTag(*u.tag)
	}
}

type InputTypeVisitor interface {
	VisitTag(v Tag) error
	VisitUnknown(typeName string) error
}

func (u *InputType) AcceptWithContext(ctx context.Context, v InputTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "tag":
		if u.tag == nil {
			return fmt.Errorf("field \"tag\" is required")
		}
		return v.VisitTagWithContext(ctx, *u.tag)
	}
}

type InputTypeVisitorWithContext interface {
	VisitTagWithContext(ctx context.Context, v Tag) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewInputTypeFromTag(v Tag) InputType {
	return InputType{typ: "tag", tag: &v}
}

type Offset struct {
	typ      string
	custom   *api.UserDuration
	runAlign *RunAlignment
}

type offsetDeserializer struct {
	Type     string            `json:"type"`
	Custom   *api.UserDuration `json:"custom"`
	RunAlign *RunAlignment     `json:"runAlign"`
}

func (u *offsetDeserializer) toStruct() Offset {
	return Offset{typ: u.Type, custom: u.Custom, runAlign: u.RunAlign}
}

func (u *Offset) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "custom":
		if u.custom == nil {
			return nil, fmt.Errorf("field \"custom\" is required")
		}
		return struct {
			Type   string           `json:"type"`
			Custom api.UserDuration `json:"custom"`
		}{Type: "custom", Custom: *u.custom}, nil
	case "runAlign":
		if u.runAlign == nil {
			return nil, fmt.Errorf("field \"runAlign\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			RunAlign RunAlignment `json:"runAlign"`
		}{Type: "runAlign", RunAlign: *u.runAlign}, nil
	}
}

func (u Offset) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Offset) UnmarshalJSON(data []byte) error {
	var deser offsetDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
	case "runAlign":
		if u.runAlign == nil {
			return fmt.Errorf("field \"runAlign\" is required")
		}
	}
	return nil
}

func (u Offset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Offset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Offset) AcceptFuncs(customFunc func(api.UserDuration) error, runAlignFunc func(RunAlignment) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return customFunc(*u.custom)
	case "runAlign":
		if u.runAlign == nil {
			return fmt.Errorf("field \"runAlign\" is required")
		}
		return runAlignFunc(*u.runAlign)
	}
}

func (u *Offset) CustomNoopSuccess(api.UserDuration) error {
	return nil
}

func (u *Offset) RunAlignNoopSuccess(RunAlignment) error {
	return nil
}

func (u *Offset) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Offset) Accept(v OffsetVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustom(*u.custom)
	case "runAlign":
		if u.runAlign == nil {
			return fmt.Errorf("field \"runAlign\" is required")
		}
		return v.VisitRunAlign(*u.runAlign)
	}
}

type OffsetVisitor interface {
	VisitCustom(v api.UserDuration) error
	VisitRunAlign(v RunAlignment) error
	VisitUnknown(typeName string) error
}

func (u *Offset) AcceptWithContext(ctx context.Context, v OffsetVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "custom":
		if u.custom == nil {
			return fmt.Errorf("field \"custom\" is required")
		}
		return v.VisitCustomWithContext(ctx, *u.custom)
	case "runAlign":
		if u.runAlign == nil {
			return fmt.Errorf("field \"runAlign\" is required")
		}
		return v.VisitRunAlignWithContext(ctx, *u.runAlign)
	}
}

type OffsetVisitorWithContext interface {
	VisitCustomWithContext(ctx context.Context, v api.UserDuration) error
	VisitRunAlignWithContext(ctx context.Context, v RunAlignment) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewOffsetFromCustom(v api.UserDuration) Offset {
	return Offset{typ: "custom", custom: &v}
}

func NewOffsetFromRunAlign(v RunAlignment) Offset {
	return Offset{typ: "runAlign", runAlign: &v}
}

type TagString struct {
	typ     string
	literal *TagStringLiteral
}

type tagStringDeserializer struct {
	Type    string            `json:"type"`
	Literal *TagStringLiteral `json:"literal"`
}

func (u *tagStringDeserializer) toStruct() TagString {
	return TagString{typ: u.Type, literal: u.Literal}
}

func (u *TagString) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "literal":
		if u.literal == nil {
			return nil, fmt.Errorf("field \"literal\" is required")
		}
		return struct {
			Type    string           `json:"type"`
			Literal TagStringLiteral `json:"literal"`
		}{Type: "literal", Literal: *u.literal}, nil
	}
}

func (u TagString) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TagString) UnmarshalJSON(data []byte) error {
	var deser tagStringDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
	}
	return nil
}

func (u TagString) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TagString) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TagString) AcceptFuncs(literalFunc func(TagStringLiteral) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	}
}

func (u *TagString) LiteralNoopSuccess(TagStringLiteral) error {
	return nil
}

func (u *TagString) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TagString) Accept(v TagStringVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(*u.literal)
	}
}

type TagStringVisitor interface {
	VisitLiteral(v TagStringLiteral) error
	VisitUnknown(typeName string) error
}

func (u *TagString) AcceptWithContext(ctx context.Context, v TagStringVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteralWithContext(ctx, *u.literal)
	}
}

type TagStringVisitorWithContext interface {
	VisitLiteralWithContext(ctx context.Context, v TagStringLiteral) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTagStringFromLiteral(v TagStringLiteral) TagString {
	return TagString{typ: "literal", literal: &v}
}

type UnifiedWorkbookContent struct {
	typ                string
	workbook           *WorkbookContent
	comparisonWorkbook *api1.ComparisonWorkbookContent
}

type unifiedWorkbookContentDeserializer struct {
	Type               string                          `json:"type"`
	Workbook           *WorkbookContent                `json:"workbook"`
	ComparisonWorkbook *api1.ComparisonWorkbookContent `json:"comparisonWorkbook"`
}

func (u *unifiedWorkbookContentDeserializer) toStruct() UnifiedWorkbookContent {
	return UnifiedWorkbookContent{typ: u.Type, workbook: u.Workbook, comparisonWorkbook: u.ComparisonWorkbook}
}

func (u *UnifiedWorkbookContent) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "workbook":
		if u.workbook == nil {
			return nil, fmt.Errorf("field \"workbook\" is required")
		}
		return struct {
			Type     string          `json:"type"`
			Workbook WorkbookContent `json:"workbook"`
		}{Type: "workbook", Workbook: *u.workbook}, nil
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return nil, fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
		return struct {
			Type               string                         `json:"type"`
			ComparisonWorkbook api1.ComparisonWorkbookContent `json:"comparisonWorkbook"`
		}{Type: "comparisonWorkbook", ComparisonWorkbook: *u.comparisonWorkbook}, nil
	}
}

func (u UnifiedWorkbookContent) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UnifiedWorkbookContent) UnmarshalJSON(data []byte) error {
	var deser unifiedWorkbookContentDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
	}
	return nil
}

func (u UnifiedWorkbookContent) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UnifiedWorkbookContent) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UnifiedWorkbookContent) AcceptFuncs(workbookFunc func(WorkbookContent) error, comparisonWorkbookFunc func(api1.ComparisonWorkbookContent) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return workbookFunc(*u.workbook)
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
		return comparisonWorkbookFunc(*u.comparisonWorkbook)
	}
}

func (u *UnifiedWorkbookContent) WorkbookNoopSuccess(WorkbookContent) error {
	return nil
}

func (u *UnifiedWorkbookContent) ComparisonWorkbookNoopSuccess(api1.ComparisonWorkbookContent) error {
	return nil
}

func (u *UnifiedWorkbookContent) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UnifiedWorkbookContent) Accept(v UnifiedWorkbookContentVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return v.VisitWorkbook(*u.workbook)
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
		return v.VisitComparisonWorkbook(*u.comparisonWorkbook)
	}
}

type UnifiedWorkbookContentVisitor interface {
	VisitWorkbook(v WorkbookContent) error
	VisitComparisonWorkbook(v api1.ComparisonWorkbookContent) error
	VisitUnknown(typeName string) error
}

func (u *UnifiedWorkbookContent) AcceptWithContext(ctx context.Context, v UnifiedWorkbookContentVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "workbook":
		if u.workbook == nil {
			return fmt.Errorf("field \"workbook\" is required")
		}
		return v.VisitWorkbookWithContext(ctx, *u.workbook)
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
		return v.VisitComparisonWorkbookWithContext(ctx, *u.comparisonWorkbook)
	}
}

type UnifiedWorkbookContentVisitorWithContext interface {
	VisitWorkbookWithContext(ctx context.Context, v WorkbookContent) error
	VisitComparisonWorkbookWithContext(ctx context.Context, v api1.ComparisonWorkbookContent) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnifiedWorkbookContentFromWorkbook(v WorkbookContent) UnifiedWorkbookContent {
	return UnifiedWorkbookContent{typ: "workbook", workbook: &v}
}

func NewUnifiedWorkbookContentFromComparisonWorkbook(v api1.ComparisonWorkbookContent) UnifiedWorkbookContent {
	return UnifiedWorkbookContent{typ: "comparisonWorkbook", comparisonWorkbook: &v}
}

type WorkbookInputs struct {
	typ string
	v1  *WorkbookInputsV1
}

type workbookInputsDeserializer struct {
	Type string            `json:"type"`
	V1   *WorkbookInputsV1 `json:"v1"`
}

func (u *workbookInputsDeserializer) toStruct() WorkbookInputs {
	return WorkbookInputs{typ: u.Type, v1: u.V1}
}

func (u *WorkbookInputs) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string           `json:"type"`
			V1   WorkbookInputsV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u WorkbookInputs) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *WorkbookInputs) UnmarshalJSON(data []byte) error {
	var deser workbookInputsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u WorkbookInputs) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *WorkbookInputs) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *WorkbookInputs) AcceptFuncs(v1Func func(WorkbookInputsV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *WorkbookInputs) V1NoopSuccess(WorkbookInputsV1) error {
	return nil
}

func (u *WorkbookInputs) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *WorkbookInputs) Accept(v WorkbookInputsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type WorkbookInputsVisitor interface {
	VisitV1(v WorkbookInputsV1) error
	VisitUnknown(typeName string) error
}

func (u *WorkbookInputs) AcceptWithContext(ctx context.Context, v WorkbookInputsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type WorkbookInputsVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v WorkbookInputsV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewWorkbookInputsFromV1(v WorkbookInputsV1) WorkbookInputs {
	return WorkbookInputs{typ: "v1", v1: &v}
}

type WorkbookOffsets struct {
	typ string
	v1  *WorkbookOffsetsV1
}

type workbookOffsetsDeserializer struct {
	Type string             `json:"type"`
	V1   *WorkbookOffsetsV1 `json:"v1"`
}

func (u *workbookOffsetsDeserializer) toStruct() WorkbookOffsets {
	return WorkbookOffsets{typ: u.Type, v1: u.V1}
}

func (u *WorkbookOffsets) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string            `json:"type"`
			V1   WorkbookOffsetsV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u WorkbookOffsets) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *WorkbookOffsets) UnmarshalJSON(data []byte) error {
	var deser workbookOffsetsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u WorkbookOffsets) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *WorkbookOffsets) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *WorkbookOffsets) AcceptFuncs(v1Func func(WorkbookOffsetsV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *WorkbookOffsets) V1NoopSuccess(WorkbookOffsetsV1) error {
	return nil
}

func (u *WorkbookOffsets) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *WorkbookOffsets) Accept(v WorkbookOffsetsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type WorkbookOffsetsVisitor interface {
	VisitV1(v WorkbookOffsetsV1) error
	VisitUnknown(typeName string) error
}

func (u *WorkbookOffsets) AcceptWithContext(ctx context.Context, v WorkbookOffsetsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type WorkbookOffsetsVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v WorkbookOffsetsV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewWorkbookOffsetsFromV1(v WorkbookOffsetsV1) WorkbookOffsets {
	return WorkbookOffsets{typ: "v1", v1: &v}
}

type WorkbookTimeSettings struct {
	typ string
	v1  *WorkbookTimeSettingsV1
}

type workbookTimeSettingsDeserializer struct {
	Type string                  `json:"type"`
	V1   *WorkbookTimeSettingsV1 `json:"v1"`
}

func (u *workbookTimeSettingsDeserializer) toStruct() WorkbookTimeSettings {
	return WorkbookTimeSettings{typ: u.Type, v1: u.V1}
}

func (u *WorkbookTimeSettings) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string                 `json:"type"`
			V1   WorkbookTimeSettingsV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u WorkbookTimeSettings) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *WorkbookTimeSettings) UnmarshalJSON(data []byte) error {
	var deser workbookTimeSettingsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u WorkbookTimeSettings) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *WorkbookTimeSettings) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *WorkbookTimeSettings) AcceptFuncs(v1Func func(WorkbookTimeSettingsV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *WorkbookTimeSettings) V1NoopSuccess(WorkbookTimeSettingsV1) error {
	return nil
}

func (u *WorkbookTimeSettings) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *WorkbookTimeSettings) Accept(v WorkbookTimeSettingsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type WorkbookTimeSettingsVisitor interface {
	VisitV1(v WorkbookTimeSettingsV1) error
	VisitUnknown(typeName string) error
}

func (u *WorkbookTimeSettings) AcceptWithContext(ctx context.Context, v WorkbookTimeSettingsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type WorkbookTimeSettingsVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v WorkbookTimeSettingsV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewWorkbookTimeSettingsFromV1(v WorkbookTimeSettingsV1) WorkbookTimeSettings {
	return WorkbookTimeSettings{typ: "v1", v1: &v}
}
