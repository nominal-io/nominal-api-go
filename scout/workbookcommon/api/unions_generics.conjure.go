// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/scout/comparisonnotebook/api"
)

type InputTypeWithT[T any] InputType

func (u *InputTypeWithT[T]) Accept(ctx context.Context, v InputTypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "tag":
		if u.tag == nil {
			return result, fmt.Errorf("field \"tag\" is required")
		}
		return v.VisitTag(ctx, *u.tag)
	}
}

func (u *InputTypeWithT[T]) AcceptFuncs(tagFunc func(Tag) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "tag":
		if u.tag == nil {
			return result, fmt.Errorf("field \"tag\" is required")
		}
		return tagFunc(*u.tag)
	}
}

func (u *InputTypeWithT[T]) TagNoopSuccess(Tag) (T, error) {
	var result T
	return result, nil
}

func (u *InputTypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type InputTypeVisitorWithT[T any] interface {
	VisitTag(ctx context.Context, v Tag) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TagStringWithT[T any] TagString

func (u *TagStringWithT[T]) Accept(ctx context.Context, v TagStringVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return v.VisitLiteral(ctx, *u.literal)
	}
}

func (u *TagStringWithT[T]) AcceptFuncs(literalFunc func(TagStringLiteral) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "literal":
		if u.literal == nil {
			return result, fmt.Errorf("field \"literal\" is required")
		}
		return literalFunc(*u.literal)
	}
}

func (u *TagStringWithT[T]) LiteralNoopSuccess(TagStringLiteral) (T, error) {
	var result T
	return result, nil
}

func (u *TagStringWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TagStringVisitorWithT[T any] interface {
	VisitLiteral(ctx context.Context, v TagStringLiteral) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UnifiedWorkbookContentWithT[T any] UnifiedWorkbookContent

func (u *UnifiedWorkbookContentWithT[T]) Accept(ctx context.Context, v UnifiedWorkbookContentVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "workbook":
		if u.workbook == nil {
			return result, fmt.Errorf("field \"workbook\" is required")
		}
		return v.VisitWorkbook(ctx, *u.workbook)
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return result, fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
		return v.VisitComparisonWorkbook(ctx, *u.comparisonWorkbook)
	}
}

func (u *UnifiedWorkbookContentWithT[T]) AcceptFuncs(workbookFunc func(WorkbookContent) (T, error), comparisonWorkbookFunc func(api.ComparisonWorkbookContent) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "workbook":
		if u.workbook == nil {
			return result, fmt.Errorf("field \"workbook\" is required")
		}
		return workbookFunc(*u.workbook)
	case "comparisonWorkbook":
		if u.comparisonWorkbook == nil {
			return result, fmt.Errorf("field \"comparisonWorkbook\" is required")
		}
		return comparisonWorkbookFunc(*u.comparisonWorkbook)
	}
}

func (u *UnifiedWorkbookContentWithT[T]) WorkbookNoopSuccess(WorkbookContent) (T, error) {
	var result T
	return result, nil
}

func (u *UnifiedWorkbookContentWithT[T]) ComparisonWorkbookNoopSuccess(api.ComparisonWorkbookContent) (T, error) {
	var result T
	return result, nil
}

func (u *UnifiedWorkbookContentWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UnifiedWorkbookContentVisitorWithT[T any] interface {
	VisitWorkbook(ctx context.Context, v WorkbookContent) (T, error)
	VisitComparisonWorkbook(ctx context.Context, v api.ComparisonWorkbookContent) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type WorkbookInputsWithT[T any] WorkbookInputs

func (u *WorkbookInputsWithT[T]) Accept(ctx context.Context, v WorkbookInputsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *WorkbookInputsWithT[T]) AcceptFuncs(v1Func func(WorkbookInputsV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *WorkbookInputsWithT[T]) V1NoopSuccess(WorkbookInputsV1) (T, error) {
	var result T
	return result, nil
}

func (u *WorkbookInputsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type WorkbookInputsVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v WorkbookInputsV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
