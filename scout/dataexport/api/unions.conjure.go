// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
)

type ExportChannels struct {
	typ        string
	timeDomain *ExportTimeDomainChannels
}

type exportChannelsDeserializer struct {
	Type       string                    `json:"type"`
	TimeDomain *ExportTimeDomainChannels `json:"timeDomain"`
}

func (u *exportChannelsDeserializer) toStruct() ExportChannels {
	return ExportChannels{typ: u.Type, timeDomain: u.TimeDomain}
}

func (u *ExportChannels) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timeDomain":
		if u.timeDomain == nil {
			return nil, fmt.Errorf("field \"timeDomain\" is required")
		}
		return struct {
			Type       string                   `json:"type"`
			TimeDomain ExportTimeDomainChannels `json:"timeDomain"`
		}{Type: "timeDomain", TimeDomain: *u.timeDomain}, nil
	}
}

func (u ExportChannels) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ExportChannels) UnmarshalJSON(data []byte) error {
	var deser exportChannelsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timeDomain":
		if u.timeDomain == nil {
			return fmt.Errorf("field \"timeDomain\" is required")
		}
	}
	return nil
}

func (u ExportChannels) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ExportChannels) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ExportChannels) AcceptFuncs(timeDomainFunc func(ExportTimeDomainChannels) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timeDomain":
		if u.timeDomain == nil {
			return fmt.Errorf("field \"timeDomain\" is required")
		}
		return timeDomainFunc(*u.timeDomain)
	}
}

func (u *ExportChannels) TimeDomainNoopSuccess(ExportTimeDomainChannels) error {
	return nil
}

func (u *ExportChannels) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ExportChannels) Accept(v ExportChannelsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timeDomain":
		if u.timeDomain == nil {
			return fmt.Errorf("field \"timeDomain\" is required")
		}
		return v.VisitTimeDomain(*u.timeDomain)
	}
}

type ExportChannelsVisitor interface {
	VisitTimeDomain(v ExportTimeDomainChannels) error
	VisitUnknown(typeName string) error
}

func (u *ExportChannels) AcceptWithContext(ctx context.Context, v ExportChannelsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timeDomain":
		if u.timeDomain == nil {
			return fmt.Errorf("field \"timeDomain\" is required")
		}
		return v.VisitTimeDomainWithContext(ctx, *u.timeDomain)
	}
}

type ExportChannelsVisitorWithContext interface {
	VisitTimeDomainWithContext(ctx context.Context, v ExportTimeDomainChannels) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewExportChannelsFromTimeDomain(v ExportTimeDomainChannels) ExportChannels {
	return ExportChannels{typ: "timeDomain", timeDomain: &v}
}

type ExportFormat struct {
	typ     string
	arrow   *Arrow
	csv     *Csv
	matfile *Matfile
}

type exportFormatDeserializer struct {
	Type    string   `json:"type"`
	Arrow   *Arrow   `json:"arrow"`
	Csv     *Csv     `json:"csv"`
	Matfile *Matfile `json:"matfile"`
}

func (u *exportFormatDeserializer) toStruct() ExportFormat {
	return ExportFormat{typ: u.Type, arrow: u.Arrow, csv: u.Csv, matfile: u.Matfile}
}

func (u *ExportFormat) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "arrow":
		if u.arrow == nil {
			return nil, fmt.Errorf("field \"arrow\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Arrow Arrow  `json:"arrow"`
		}{Type: "arrow", Arrow: *u.arrow}, nil
	case "csv":
		if u.csv == nil {
			return nil, fmt.Errorf("field \"csv\" is required")
		}
		return struct {
			Type string `json:"type"`
			Csv  Csv    `json:"csv"`
		}{Type: "csv", Csv: *u.csv}, nil
	case "matfile":
		if u.matfile == nil {
			return nil, fmt.Errorf("field \"matfile\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Matfile Matfile `json:"matfile"`
		}{Type: "matfile", Matfile: *u.matfile}, nil
	}
}

func (u ExportFormat) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ExportFormat) UnmarshalJSON(data []byte) error {
	var deser exportFormatDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "arrow":
		if u.arrow == nil {
			return fmt.Errorf("field \"arrow\" is required")
		}
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
	case "matfile":
		if u.matfile == nil {
			return fmt.Errorf("field \"matfile\" is required")
		}
	}
	return nil
}

func (u ExportFormat) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ExportFormat) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ExportFormat) AcceptFuncs(arrowFunc func(Arrow) error, csvFunc func(Csv) error, matfileFunc func(Matfile) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "arrow":
		if u.arrow == nil {
			return fmt.Errorf("field \"arrow\" is required")
		}
		return arrowFunc(*u.arrow)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return csvFunc(*u.csv)
	case "matfile":
		if u.matfile == nil {
			return fmt.Errorf("field \"matfile\" is required")
		}
		return matfileFunc(*u.matfile)
	}
}

func (u *ExportFormat) ArrowNoopSuccess(Arrow) error {
	return nil
}

func (u *ExportFormat) CsvNoopSuccess(Csv) error {
	return nil
}

func (u *ExportFormat) MatfileNoopSuccess(Matfile) error {
	return nil
}

func (u *ExportFormat) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ExportFormat) Accept(v ExportFormatVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "arrow":
		if u.arrow == nil {
			return fmt.Errorf("field \"arrow\" is required")
		}
		return v.VisitArrow(*u.arrow)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsv(*u.csv)
	case "matfile":
		if u.matfile == nil {
			return fmt.Errorf("field \"matfile\" is required")
		}
		return v.VisitMatfile(*u.matfile)
	}
}

type ExportFormatVisitor interface {
	VisitArrow(v Arrow) error
	VisitCsv(v Csv) error
	VisitMatfile(v Matfile) error
	VisitUnknown(typeName string) error
}

func (u *ExportFormat) AcceptWithContext(ctx context.Context, v ExportFormatVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "arrow":
		if u.arrow == nil {
			return fmt.Errorf("field \"arrow\" is required")
		}
		return v.VisitArrowWithContext(ctx, *u.arrow)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsvWithContext(ctx, *u.csv)
	case "matfile":
		if u.matfile == nil {
			return fmt.Errorf("field \"matfile\" is required")
		}
		return v.VisitMatfileWithContext(ctx, *u.matfile)
	}
}

type ExportFormatVisitorWithContext interface {
	VisitArrowWithContext(ctx context.Context, v Arrow) error
	VisitCsvWithContext(ctx context.Context, v Csv) error
	VisitMatfileWithContext(ctx context.Context, v Matfile) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewExportFormatFromArrow(v Arrow) ExportFormat {
	return ExportFormat{typ: "arrow", arrow: &v}
}

func NewExportFormatFromCsv(v Csv) ExportFormat {
	return ExportFormat{typ: "csv", csv: &v}
}

func NewExportFormatFromMatfile(v Matfile) ExportFormat {
	return ExportFormat{typ: "matfile", matfile: &v}
}

// How to handle timestamps that are not aligned.
type MergeTimestampStrategy struct {
	typ                      string
	none                     *NoneStrategy
	allTimestampsForwardFill *AllTimestampsForwardFillStrategy
}

type mergeTimestampStrategyDeserializer struct {
	Type                     string                            `json:"type"`
	None                     *NoneStrategy                     `json:"none"`
	AllTimestampsForwardFill *AllTimestampsForwardFillStrategy `json:"allTimestampsForwardFill"`
}

func (u *mergeTimestampStrategyDeserializer) toStruct() MergeTimestampStrategy {
	return MergeTimestampStrategy{typ: u.Type, none: u.None, allTimestampsForwardFill: u.AllTimestampsForwardFill}
}

func (u *MergeTimestampStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "none":
		if u.none == nil {
			return nil, fmt.Errorf("field \"none\" is required")
		}
		return struct {
			Type string       `json:"type"`
			None NoneStrategy `json:"none"`
		}{Type: "none", None: *u.none}, nil
	case "allTimestampsForwardFill":
		if u.allTimestampsForwardFill == nil {
			return nil, fmt.Errorf("field \"allTimestampsForwardFill\" is required")
		}
		return struct {
			Type                     string                           `json:"type"`
			AllTimestampsForwardFill AllTimestampsForwardFillStrategy `json:"allTimestampsForwardFill"`
		}{Type: "allTimestampsForwardFill", AllTimestampsForwardFill: *u.allTimestampsForwardFill}, nil
	}
}

func (u MergeTimestampStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *MergeTimestampStrategy) UnmarshalJSON(data []byte) error {
	var deser mergeTimestampStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "none":
		if u.none == nil {
			return fmt.Errorf("field \"none\" is required")
		}
	case "allTimestampsForwardFill":
		if u.allTimestampsForwardFill == nil {
			return fmt.Errorf("field \"allTimestampsForwardFill\" is required")
		}
	}
	return nil
}

func (u MergeTimestampStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *MergeTimestampStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *MergeTimestampStrategy) AcceptFuncs(noneFunc func(NoneStrategy) error, allTimestampsForwardFillFunc func(AllTimestampsForwardFillStrategy) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "none":
		if u.none == nil {
			return fmt.Errorf("field \"none\" is required")
		}
		return noneFunc(*u.none)
	case "allTimestampsForwardFill":
		if u.allTimestampsForwardFill == nil {
			return fmt.Errorf("field \"allTimestampsForwardFill\" is required")
		}
		return allTimestampsForwardFillFunc(*u.allTimestampsForwardFill)
	}
}

func (u *MergeTimestampStrategy) NoneNoopSuccess(NoneStrategy) error {
	return nil
}

func (u *MergeTimestampStrategy) AllTimestampsForwardFillNoopSuccess(AllTimestampsForwardFillStrategy) error {
	return nil
}

func (u *MergeTimestampStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *MergeTimestampStrategy) Accept(v MergeTimestampStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "none":
		if u.none == nil {
			return fmt.Errorf("field \"none\" is required")
		}
		return v.VisitNone(*u.none)
	case "allTimestampsForwardFill":
		if u.allTimestampsForwardFill == nil {
			return fmt.Errorf("field \"allTimestampsForwardFill\" is required")
		}
		return v.VisitAllTimestampsForwardFill(*u.allTimestampsForwardFill)
	}
}

type MergeTimestampStrategyVisitor interface {
	VisitNone(v NoneStrategy) error
	VisitAllTimestampsForwardFill(v AllTimestampsForwardFillStrategy) error
	VisitUnknown(typeName string) error
}

func (u *MergeTimestampStrategy) AcceptWithContext(ctx context.Context, v MergeTimestampStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "none":
		if u.none == nil {
			return fmt.Errorf("field \"none\" is required")
		}
		return v.VisitNoneWithContext(ctx, *u.none)
	case "allTimestampsForwardFill":
		if u.allTimestampsForwardFill == nil {
			return fmt.Errorf("field \"allTimestampsForwardFill\" is required")
		}
		return v.VisitAllTimestampsForwardFillWithContext(ctx, *u.allTimestampsForwardFill)
	}
}

type MergeTimestampStrategyVisitorWithContext interface {
	VisitNoneWithContext(ctx context.Context, v NoneStrategy) error
	VisitAllTimestampsForwardFillWithContext(ctx context.Context, v AllTimestampsForwardFillStrategy) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewMergeTimestampStrategyFromNone(v NoneStrategy) MergeTimestampStrategy {
	return MergeTimestampStrategy{typ: "none", none: &v}
}

func NewMergeTimestampStrategyFromAllTimestampsForwardFill(v AllTimestampsForwardFillStrategy) MergeTimestampStrategy {
	return MergeTimestampStrategy{typ: "allTimestampsForwardFill", allTimestampsForwardFill: &v}
}

/*
The minimum desired step between adjacent timestamps. If multiple values are available for a timestamp,
the mean of the values will be used for numeric types and the mode of the values will be used for enum types.
*/
type ResolutionOption struct {
	typ         string
	nanoseconds *safelong.SafeLong
	buckets     *int
	undecimated *UndecimatedResolution
}

type resolutionOptionDeserializer struct {
	Type        string                 `json:"type"`
	Nanoseconds *safelong.SafeLong     `json:"nanoseconds"`
	Buckets     *int                   `json:"buckets"`
	Undecimated *UndecimatedResolution `json:"undecimated"`
}

func (u *resolutionOptionDeserializer) toStruct() ResolutionOption {
	return ResolutionOption{typ: u.Type, nanoseconds: u.Nanoseconds, buckets: u.Buckets, undecimated: u.Undecimated}
}

func (u *ResolutionOption) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "nanoseconds":
		if u.nanoseconds == nil {
			return nil, fmt.Errorf("field \"nanoseconds\" is required")
		}
		return struct {
			Type        string            `json:"type"`
			Nanoseconds safelong.SafeLong `json:"nanoseconds"`
		}{Type: "nanoseconds", Nanoseconds: *u.nanoseconds}, nil
	case "buckets":
		if u.buckets == nil {
			return nil, fmt.Errorf("field \"buckets\" is required")
		}
		return struct {
			Type    string `json:"type"`
			Buckets int    `json:"buckets"`
		}{Type: "buckets", Buckets: *u.buckets}, nil
	case "undecimated":
		if u.undecimated == nil {
			return nil, fmt.Errorf("field \"undecimated\" is required")
		}
		return struct {
			Type        string                `json:"type"`
			Undecimated UndecimatedResolution `json:"undecimated"`
		}{Type: "undecimated", Undecimated: *u.undecimated}, nil
	}
}

func (u ResolutionOption) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ResolutionOption) UnmarshalJSON(data []byte) error {
	var deser resolutionOptionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "nanoseconds":
		if u.nanoseconds == nil {
			return fmt.Errorf("field \"nanoseconds\" is required")
		}
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
	case "undecimated":
		if u.undecimated == nil {
			return fmt.Errorf("field \"undecimated\" is required")
		}
	}
	return nil
}

func (u ResolutionOption) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ResolutionOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ResolutionOption) AcceptFuncs(nanosecondsFunc func(safelong.SafeLong) error, bucketsFunc func(int) error, undecimatedFunc func(UndecimatedResolution) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "nanoseconds":
		if u.nanoseconds == nil {
			return fmt.Errorf("field \"nanoseconds\" is required")
		}
		return nanosecondsFunc(*u.nanoseconds)
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
		return bucketsFunc(*u.buckets)
	case "undecimated":
		if u.undecimated == nil {
			return fmt.Errorf("field \"undecimated\" is required")
		}
		return undecimatedFunc(*u.undecimated)
	}
}

func (u *ResolutionOption) NanosecondsNoopSuccess(safelong.SafeLong) error {
	return nil
}

func (u *ResolutionOption) BucketsNoopSuccess(int) error {
	return nil
}

func (u *ResolutionOption) UndecimatedNoopSuccess(UndecimatedResolution) error {
	return nil
}

func (u *ResolutionOption) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ResolutionOption) Accept(v ResolutionOptionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "nanoseconds":
		if u.nanoseconds == nil {
			return fmt.Errorf("field \"nanoseconds\" is required")
		}
		return v.VisitNanoseconds(*u.nanoseconds)
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
		return v.VisitBuckets(*u.buckets)
	case "undecimated":
		if u.undecimated == nil {
			return fmt.Errorf("field \"undecimated\" is required")
		}
		return v.VisitUndecimated(*u.undecimated)
	}
}

type ResolutionOptionVisitor interface {
	VisitNanoseconds(v safelong.SafeLong) error
	VisitBuckets(v int) error
	VisitUndecimated(v UndecimatedResolution) error
	VisitUnknown(typeName string) error
}

func (u *ResolutionOption) AcceptWithContext(ctx context.Context, v ResolutionOptionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "nanoseconds":
		if u.nanoseconds == nil {
			return fmt.Errorf("field \"nanoseconds\" is required")
		}
		return v.VisitNanosecondsWithContext(ctx, *u.nanoseconds)
	case "buckets":
		if u.buckets == nil {
			return fmt.Errorf("field \"buckets\" is required")
		}
		return v.VisitBucketsWithContext(ctx, *u.buckets)
	case "undecimated":
		if u.undecimated == nil {
			return fmt.Errorf("field \"undecimated\" is required")
		}
		return v.VisitUndecimatedWithContext(ctx, *u.undecimated)
	}
}

type ResolutionOptionVisitorWithContext interface {
	VisitNanosecondsWithContext(ctx context.Context, v safelong.SafeLong) error
	VisitBucketsWithContext(ctx context.Context, v int) error
	VisitUndecimatedWithContext(ctx context.Context, v UndecimatedResolution) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewResolutionOptionFromNanoseconds(v safelong.SafeLong) ResolutionOption {
	return ResolutionOption{typ: "nanoseconds", nanoseconds: &v}
}

func NewResolutionOptionFromBuckets(v int) ResolutionOption {
	return ResolutionOption{typ: "buckets", buckets: &v}
}

func NewResolutionOptionFromUndecimated(v UndecimatedResolution) ResolutionOption {
	return ResolutionOption{typ: "undecimated", undecimated: &v}
}

type TimestampFormat struct {
	typ      string
	iso8601  *Iso8601TimestampFormat
	relative *RelativeTimestampFormat
}

type timestampFormatDeserializer struct {
	Type     string                   `json:"type"`
	Iso8601  *Iso8601TimestampFormat  `json:"iso8601"`
	Relative *RelativeTimestampFormat `json:"relative"`
}

func (u *timestampFormatDeserializer) toStruct() TimestampFormat {
	return TimestampFormat{typ: u.Type, iso8601: u.Iso8601, relative: u.Relative}
}

func (u *TimestampFormat) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return nil, fmt.Errorf("field \"iso8601\" is required")
		}
		return struct {
			Type    string                 `json:"type"`
			Iso8601 Iso8601TimestampFormat `json:"iso8601"`
		}{Type: "iso8601", Iso8601: *u.iso8601}, nil
	case "relative":
		if u.relative == nil {
			return nil, fmt.Errorf("field \"relative\" is required")
		}
		return struct {
			Type     string                  `json:"type"`
			Relative RelativeTimestampFormat `json:"relative"`
		}{Type: "relative", Relative: *u.relative}, nil
	}
}

func (u TimestampFormat) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimestampFormat) UnmarshalJSON(data []byte) error {
	var deser timestampFormatDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
	}
	return nil
}

func (u TimestampFormat) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimestampFormat) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimestampFormat) AcceptFuncs(iso8601Func func(Iso8601TimestampFormat) error, relativeFunc func(RelativeTimestampFormat) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
		return iso8601Func(*u.iso8601)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return relativeFunc(*u.relative)
	}
}

func (u *TimestampFormat) Iso8601NoopSuccess(Iso8601TimestampFormat) error {
	return nil
}

func (u *TimestampFormat) RelativeNoopSuccess(RelativeTimestampFormat) error {
	return nil
}

func (u *TimestampFormat) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimestampFormat) Accept(v TimestampFormatVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
		return v.VisitIso8601(*u.iso8601)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelative(*u.relative)
	}
}

type TimestampFormatVisitor interface {
	VisitIso8601(v Iso8601TimestampFormat) error
	VisitRelative(v RelativeTimestampFormat) error
	VisitUnknown(typeName string) error
}

func (u *TimestampFormat) AcceptWithContext(ctx context.Context, v TimestampFormatVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
		return v.VisitIso8601WithContext(ctx, *u.iso8601)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelativeWithContext(ctx, *u.relative)
	}
}

type TimestampFormatVisitorWithContext interface {
	VisitIso8601WithContext(ctx context.Context, v Iso8601TimestampFormat) error
	VisitRelativeWithContext(ctx context.Context, v RelativeTimestampFormat) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimestampFormatFromIso8601(v Iso8601TimestampFormat) TimestampFormat {
	return TimestampFormat{typ: "iso8601", iso8601: &v}
}

func NewTimestampFormatFromRelative(v RelativeTimestampFormat) TimestampFormat {
	return TimestampFormat{typ: "relative", relative: &v}
}
