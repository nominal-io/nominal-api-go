// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	api11 "github.com/nominal-io/nominal-api-go/scout/compute/api1"
	"github.com/nominal-io/nominal-api-go/scout/run/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

/*
All timestamps will be kept.
The value of a channel at a timestamp will be its latest
value, within the provided look back period.
*/
type AllTimestampsForwardFillStrategy struct {
	LookBackPeriod api.Duration `json:"lookBackPeriod"`
}

func (o AllTimestampsForwardFillStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AllTimestampsForwardFillStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Export settings for a stream of arrow-compatible data.
type Arrow struct{}

func (o Arrow) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Arrow) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Export settings for a stream of `.csv` data.
type Csv struct{}

func (o Csv) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Csv) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExportDataRequest struct {
	Format      ExportFormat       `json:"format"`
	Compression *CompressionFormat `json:"compression,omitempty"`
	StartTime   api1.Timestamp     `json:"startTime"`
	EndTime     api1.Timestamp     `json:"endTime"`
	Resolution  ResolutionOption   `json:"resolution"`
	Channels    ExportChannels     `json:"channels"`
	Context     api11.Context      `json:"context"`
}

func (o ExportDataRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExportDataRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExportTimeDomainChannels struct {
	OutputTimestampFormat  TimestampFormat        `json:"outputTimestampFormat"`
	MergeTimestampStrategy MergeTimestampStrategy `json:"mergeTimestampStrategy"`
	Channels               []TimeDomainChannel    `json:"channels"`
}

func (o ExportTimeDomainChannels) MarshalJSON() ([]byte, error) {
	if o.Channels == nil {
		o.Channels = make([]TimeDomainChannel, 0)
	}
	type _tmpExportTimeDomainChannels ExportTimeDomainChannels
	return safejson.Marshal(_tmpExportTimeDomainChannels(o))
}

func (o *ExportTimeDomainChannels) UnmarshalJSON(data []byte) error {
	type _tmpExportTimeDomainChannels ExportTimeDomainChannels
	var rawExportTimeDomainChannels _tmpExportTimeDomainChannels
	if err := safejson.Unmarshal(data, &rawExportTimeDomainChannels); err != nil {
		return err
	}
	if rawExportTimeDomainChannels.Channels == nil {
		rawExportTimeDomainChannels.Channels = make([]TimeDomainChannel, 0)
	}
	*o = ExportTimeDomainChannels(rawExportTimeDomainChannels)
	return nil
}

func (o ExportTimeDomainChannels) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExportTimeDomainChannels) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GeneratePresignedLinkResponse struct {
	PresignedUrl PresignedUrl `json:"presignedUrl"`
}

func (o GeneratePresignedLinkResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeneratePresignedLinkResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Iso8601TimestampFormat struct{}

func (o Iso8601TimestampFormat) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Iso8601TimestampFormat) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Export settings for a `.mat` file compatible with matlab.
type Matfile struct{}

func (o Matfile) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Matfile) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Do nothing. The value of a channel will be empty at
timestamps not present in its original time series.
*/
type NoneStrategy struct{}

func (o NoneStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NoneStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PresignedUrl struct {
	Url string `json:"url"`
}

func (o PresignedUrl) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PresignedUrl) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Returns in relative time to the supplied timestamp.
type RelativeTimestampFormat struct {
	RelativeTo api1.Timestamp `json:"relativeTo"`
	TimeUnit   api1.TimeUnit  `json:"timeUnit"`
}

func (o RelativeTimestampFormat) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RelativeTimestampFormat) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimeDomainChannel struct {
	ColumnName  string       `json:"columnName"`
	ComputeNode api11.Series `json:"computeNode"`
}

func (o TimeDomainChannel) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimeDomainChannel) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Full resolution.
type UndecimatedResolution struct{}

func (o UndecimatedResolution) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UndecimatedResolution) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
