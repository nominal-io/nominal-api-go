// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safelong"
)

type ExportChannelsWithT[T any] ExportChannels

func (u *ExportChannelsWithT[T]) Accept(ctx context.Context, v ExportChannelsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "timeDomain":
		if u.timeDomain == nil {
			return result, fmt.Errorf("field \"timeDomain\" is required")
		}
		return v.VisitTimeDomain(ctx, *u.timeDomain)
	}
}

func (u *ExportChannelsWithT[T]) AcceptFuncs(timeDomainFunc func(ExportTimeDomainChannels) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timeDomain":
		if u.timeDomain == nil {
			return result, fmt.Errorf("field \"timeDomain\" is required")
		}
		return timeDomainFunc(*u.timeDomain)
	}
}

func (u *ExportChannelsWithT[T]) TimeDomainNoopSuccess(ExportTimeDomainChannels) (T, error) {
	var result T
	return result, nil
}

func (u *ExportChannelsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ExportChannelsVisitorWithT[T any] interface {
	VisitTimeDomain(ctx context.Context, v ExportTimeDomainChannels) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ExportFormatWithT[T any] ExportFormat

func (u *ExportFormatWithT[T]) Accept(ctx context.Context, v ExportFormatVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "csv":
		if u.csv == nil {
			return result, fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsv(ctx, *u.csv)
	}
}

func (u *ExportFormatWithT[T]) AcceptFuncs(csvFunc func(Csv) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "csv":
		if u.csv == nil {
			return result, fmt.Errorf("field \"csv\" is required")
		}
		return csvFunc(*u.csv)
	}
}

func (u *ExportFormatWithT[T]) CsvNoopSuccess(Csv) (T, error) {
	var result T
	return result, nil
}

func (u *ExportFormatWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ExportFormatVisitorWithT[T any] interface {
	VisitCsv(ctx context.Context, v Csv) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type MergeTimestampStrategyWithT[T any] MergeTimestampStrategy

func (u *MergeTimestampStrategyWithT[T]) Accept(ctx context.Context, v MergeTimestampStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "none":
		if u.none == nil {
			return result, fmt.Errorf("field \"none\" is required")
		}
		return v.VisitNone(ctx, *u.none)
	case "allTimestampsForwardFill":
		if u.allTimestampsForwardFill == nil {
			return result, fmt.Errorf("field \"allTimestampsForwardFill\" is required")
		}
		return v.VisitAllTimestampsForwardFill(ctx, *u.allTimestampsForwardFill)
	}
}

func (u *MergeTimestampStrategyWithT[T]) AcceptFuncs(noneFunc func(NoneStrategy) (T, error), allTimestampsForwardFillFunc func(AllTimestampsForwardFillStrategy) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "none":
		if u.none == nil {
			return result, fmt.Errorf("field \"none\" is required")
		}
		return noneFunc(*u.none)
	case "allTimestampsForwardFill":
		if u.allTimestampsForwardFill == nil {
			return result, fmt.Errorf("field \"allTimestampsForwardFill\" is required")
		}
		return allTimestampsForwardFillFunc(*u.allTimestampsForwardFill)
	}
}

func (u *MergeTimestampStrategyWithT[T]) NoneNoopSuccess(NoneStrategy) (T, error) {
	var result T
	return result, nil
}

func (u *MergeTimestampStrategyWithT[T]) AllTimestampsForwardFillNoopSuccess(AllTimestampsForwardFillStrategy) (T, error) {
	var result T
	return result, nil
}

func (u *MergeTimestampStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type MergeTimestampStrategyVisitorWithT[T any] interface {
	VisitNone(ctx context.Context, v NoneStrategy) (T, error)
	VisitAllTimestampsForwardFill(ctx context.Context, v AllTimestampsForwardFillStrategy) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ResolutionOptionWithT[T any] ResolutionOption

func (u *ResolutionOptionWithT[T]) Accept(ctx context.Context, v ResolutionOptionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "nanoseconds":
		if u.nanoseconds == nil {
			return result, fmt.Errorf("field \"nanoseconds\" is required")
		}
		return v.VisitNanoseconds(ctx, *u.nanoseconds)
	case "buckets":
		if u.buckets == nil {
			return result, fmt.Errorf("field \"buckets\" is required")
		}
		return v.VisitBuckets(ctx, *u.buckets)
	case "undecimated":
		if u.undecimated == nil {
			return result, fmt.Errorf("field \"undecimated\" is required")
		}
		return v.VisitUndecimated(ctx, *u.undecimated)
	}
}

func (u *ResolutionOptionWithT[T]) AcceptFuncs(nanosecondsFunc func(safelong.SafeLong) (T, error), bucketsFunc func(int) (T, error), undecimatedFunc func(UndecimatedResolution) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "nanoseconds":
		if u.nanoseconds == nil {
			return result, fmt.Errorf("field \"nanoseconds\" is required")
		}
		return nanosecondsFunc(*u.nanoseconds)
	case "buckets":
		if u.buckets == nil {
			return result, fmt.Errorf("field \"buckets\" is required")
		}
		return bucketsFunc(*u.buckets)
	case "undecimated":
		if u.undecimated == nil {
			return result, fmt.Errorf("field \"undecimated\" is required")
		}
		return undecimatedFunc(*u.undecimated)
	}
}

func (u *ResolutionOptionWithT[T]) NanosecondsNoopSuccess(safelong.SafeLong) (T, error) {
	var result T
	return result, nil
}

func (u *ResolutionOptionWithT[T]) BucketsNoopSuccess(int) (T, error) {
	var result T
	return result, nil
}

func (u *ResolutionOptionWithT[T]) UndecimatedNoopSuccess(UndecimatedResolution) (T, error) {
	var result T
	return result, nil
}

func (u *ResolutionOptionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ResolutionOptionVisitorWithT[T any] interface {
	VisitNanoseconds(ctx context.Context, v safelong.SafeLong) (T, error)
	VisitBuckets(ctx context.Context, v int) (T, error)
	VisitUndecimated(ctx context.Context, v UndecimatedResolution) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimestampFormatWithT[T any] TimestampFormat

func (u *TimestampFormatWithT[T]) Accept(ctx context.Context, v TimestampFormatVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return result, fmt.Errorf("field \"iso8601\" is required")
		}
		return v.VisitIso8601(ctx, *u.iso8601)
	case "relative":
		if u.relative == nil {
			return result, fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelative(ctx, *u.relative)
	}
}

func (u *TimestampFormatWithT[T]) AcceptFuncs(iso8601Func func(Iso8601TimestampFormat) (T, error), relativeFunc func(RelativeTimestampFormat) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return result, fmt.Errorf("field \"iso8601\" is required")
		}
		return iso8601Func(*u.iso8601)
	case "relative":
		if u.relative == nil {
			return result, fmt.Errorf("field \"relative\" is required")
		}
		return relativeFunc(*u.relative)
	}
}

func (u *TimestampFormatWithT[T]) Iso8601NoopSuccess(Iso8601TimestampFormat) (T, error) {
	var result T
	return result, nil
}

func (u *TimestampFormatWithT[T]) RelativeNoopSuccess(RelativeTimestampFormat) (T, error) {
	var result T
	return result, nil
}

func (u *TimestampFormatWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimestampFormatVisitorWithT[T any] interface {
	VisitIso8601(ctx context.Context, v Iso8601TimestampFormat) (T, error)
	VisitRelative(ctx context.Context, v RelativeTimestampFormat) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
