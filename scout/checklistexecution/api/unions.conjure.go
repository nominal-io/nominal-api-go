// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type CheckStatus struct {
	typ     string
	pass    *Pass
	fail    *Fail
	invalid *Invalid
	skipped *Skipped
}

type checkStatusDeserializer struct {
	Type    string   `json:"type"`
	Pass    *Pass    `json:"pass"`
	Fail    *Fail    `json:"fail"`
	Invalid *Invalid `json:"invalid"`
	Skipped *Skipped `json:"skipped"`
}

func (u *checkStatusDeserializer) toStruct() CheckStatus {
	return CheckStatus{typ: u.Type, pass: u.Pass, fail: u.Fail, invalid: u.Invalid, skipped: u.Skipped}
}

func (u *CheckStatus) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "pass":
		if u.pass == nil {
			return nil, fmt.Errorf("field \"pass\" is required")
		}
		return struct {
			Type string `json:"type"`
			Pass Pass   `json:"pass"`
		}{Type: "pass", Pass: *u.pass}, nil
	case "fail":
		if u.fail == nil {
			return nil, fmt.Errorf("field \"fail\" is required")
		}
		return struct {
			Type string `json:"type"`
			Fail Fail   `json:"fail"`
		}{Type: "fail", Fail: *u.fail}, nil
	case "invalid":
		if u.invalid == nil {
			return nil, fmt.Errorf("field \"invalid\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Invalid Invalid `json:"invalid"`
		}{Type: "invalid", Invalid: *u.invalid}, nil
	case "skipped":
		if u.skipped == nil {
			return nil, fmt.Errorf("field \"skipped\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Skipped Skipped `json:"skipped"`
		}{Type: "skipped", Skipped: *u.skipped}, nil
	}
}

func (u CheckStatus) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CheckStatus) UnmarshalJSON(data []byte) error {
	var deser checkStatusDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "pass":
		if u.pass == nil {
			return fmt.Errorf("field \"pass\" is required")
		}
	case "fail":
		if u.fail == nil {
			return fmt.Errorf("field \"fail\" is required")
		}
	case "invalid":
		if u.invalid == nil {
			return fmt.Errorf("field \"invalid\" is required")
		}
	case "skipped":
		if u.skipped == nil {
			return fmt.Errorf("field \"skipped\" is required")
		}
	}
	return nil
}

func (u CheckStatus) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CheckStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CheckStatus) AcceptFuncs(passFunc func(Pass) error, failFunc func(Fail) error, invalidFunc func(Invalid) error, skippedFunc func(Skipped) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pass":
		if u.pass == nil {
			return fmt.Errorf("field \"pass\" is required")
		}
		return passFunc(*u.pass)
	case "fail":
		if u.fail == nil {
			return fmt.Errorf("field \"fail\" is required")
		}
		return failFunc(*u.fail)
	case "invalid":
		if u.invalid == nil {
			return fmt.Errorf("field \"invalid\" is required")
		}
		return invalidFunc(*u.invalid)
	case "skipped":
		if u.skipped == nil {
			return fmt.Errorf("field \"skipped\" is required")
		}
		return skippedFunc(*u.skipped)
	}
}

func (u *CheckStatus) PassNoopSuccess(Pass) error {
	return nil
}

func (u *CheckStatus) FailNoopSuccess(Fail) error {
	return nil
}

func (u *CheckStatus) InvalidNoopSuccess(Invalid) error {
	return nil
}

func (u *CheckStatus) SkippedNoopSuccess(Skipped) error {
	return nil
}

func (u *CheckStatus) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CheckStatus) Accept(v CheckStatusVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "pass":
		if u.pass == nil {
			return fmt.Errorf("field \"pass\" is required")
		}
		return v.VisitPass(*u.pass)
	case "fail":
		if u.fail == nil {
			return fmt.Errorf("field \"fail\" is required")
		}
		return v.VisitFail(*u.fail)
	case "invalid":
		if u.invalid == nil {
			return fmt.Errorf("field \"invalid\" is required")
		}
		return v.VisitInvalid(*u.invalid)
	case "skipped":
		if u.skipped == nil {
			return fmt.Errorf("field \"skipped\" is required")
		}
		return v.VisitSkipped(*u.skipped)
	}
}

type CheckStatusVisitor interface {
	VisitPass(v Pass) error
	VisitFail(v Fail) error
	VisitInvalid(v Invalid) error
	VisitSkipped(v Skipped) error
	VisitUnknown(typeName string) error
}

func (u *CheckStatus) AcceptWithContext(ctx context.Context, v CheckStatusVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "pass":
		if u.pass == nil {
			return fmt.Errorf("field \"pass\" is required")
		}
		return v.VisitPassWithContext(ctx, *u.pass)
	case "fail":
		if u.fail == nil {
			return fmt.Errorf("field \"fail\" is required")
		}
		return v.VisitFailWithContext(ctx, *u.fail)
	case "invalid":
		if u.invalid == nil {
			return fmt.Errorf("field \"invalid\" is required")
		}
		return v.VisitInvalidWithContext(ctx, *u.invalid)
	case "skipped":
		if u.skipped == nil {
			return fmt.Errorf("field \"skipped\" is required")
		}
		return v.VisitSkippedWithContext(ctx, *u.skipped)
	}
}

type CheckStatusVisitorWithContext interface {
	VisitPassWithContext(ctx context.Context, v Pass) error
	VisitFailWithContext(ctx context.Context, v Fail) error
	VisitInvalidWithContext(ctx context.Context, v Invalid) error
	VisitSkippedWithContext(ctx context.Context, v Skipped) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCheckStatusFromPass(v Pass) CheckStatus {
	return CheckStatus{typ: "pass", pass: &v}
}

func NewCheckStatusFromFail(v Fail) CheckStatus {
	return CheckStatus{typ: "fail", fail: &v}
}

func NewCheckStatusFromInvalid(v Invalid) CheckStatus {
	return CheckStatus{typ: "invalid", invalid: &v}
}

func NewCheckStatusFromSkipped(v Skipped) CheckStatus {
	return CheckStatus{typ: "skipped", skipped: &v}
}

type ChecklistLiveStatus struct {
	typ          string
	running      *StreamingChecklistRunning
	initializing *StreamingChecklistInitializing
	failed       *StreamingChecklistFailed
}

type checklistLiveStatusDeserializer struct {
	Type         string                          `json:"type"`
	Running      *StreamingChecklistRunning      `json:"running"`
	Initializing *StreamingChecklistInitializing `json:"initializing"`
	Failed       *StreamingChecklistFailed       `json:"failed"`
}

func (u *checklistLiveStatusDeserializer) toStruct() ChecklistLiveStatus {
	return ChecklistLiveStatus{typ: u.Type, running: u.Running, initializing: u.Initializing, failed: u.Failed}
}

func (u *ChecklistLiveStatus) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "running":
		if u.running == nil {
			return nil, fmt.Errorf("field \"running\" is required")
		}
		return struct {
			Type    string                    `json:"type"`
			Running StreamingChecklistRunning `json:"running"`
		}{Type: "running", Running: *u.running}, nil
	case "initializing":
		if u.initializing == nil {
			return nil, fmt.Errorf("field \"initializing\" is required")
		}
		return struct {
			Type         string                         `json:"type"`
			Initializing StreamingChecklistInitializing `json:"initializing"`
		}{Type: "initializing", Initializing: *u.initializing}, nil
	case "failed":
		if u.failed == nil {
			return nil, fmt.Errorf("field \"failed\" is required")
		}
		return struct {
			Type   string                   `json:"type"`
			Failed StreamingChecklistFailed `json:"failed"`
		}{Type: "failed", Failed: *u.failed}, nil
	}
}

func (u ChecklistLiveStatus) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ChecklistLiveStatus) UnmarshalJSON(data []byte) error {
	var deser checklistLiveStatusDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "running":
		if u.running == nil {
			return fmt.Errorf("field \"running\" is required")
		}
	case "initializing":
		if u.initializing == nil {
			return fmt.Errorf("field \"initializing\" is required")
		}
	case "failed":
		if u.failed == nil {
			return fmt.Errorf("field \"failed\" is required")
		}
	}
	return nil
}

func (u ChecklistLiveStatus) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ChecklistLiveStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ChecklistLiveStatus) AcceptFuncs(runningFunc func(StreamingChecklistRunning) error, initializingFunc func(StreamingChecklistInitializing) error, failedFunc func(StreamingChecklistFailed) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "running":
		if u.running == nil {
			return fmt.Errorf("field \"running\" is required")
		}
		return runningFunc(*u.running)
	case "initializing":
		if u.initializing == nil {
			return fmt.Errorf("field \"initializing\" is required")
		}
		return initializingFunc(*u.initializing)
	case "failed":
		if u.failed == nil {
			return fmt.Errorf("field \"failed\" is required")
		}
		return failedFunc(*u.failed)
	}
}

func (u *ChecklistLiveStatus) RunningNoopSuccess(StreamingChecklistRunning) error {
	return nil
}

func (u *ChecklistLiveStatus) InitializingNoopSuccess(StreamingChecklistInitializing) error {
	return nil
}

func (u *ChecklistLiveStatus) FailedNoopSuccess(StreamingChecklistFailed) error {
	return nil
}

func (u *ChecklistLiveStatus) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ChecklistLiveStatus) Accept(v ChecklistLiveStatusVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "running":
		if u.running == nil {
			return fmt.Errorf("field \"running\" is required")
		}
		return v.VisitRunning(*u.running)
	case "initializing":
		if u.initializing == nil {
			return fmt.Errorf("field \"initializing\" is required")
		}
		return v.VisitInitializing(*u.initializing)
	case "failed":
		if u.failed == nil {
			return fmt.Errorf("field \"failed\" is required")
		}
		return v.VisitFailed(*u.failed)
	}
}

type ChecklistLiveStatusVisitor interface {
	VisitRunning(v StreamingChecklistRunning) error
	VisitInitializing(v StreamingChecklistInitializing) error
	VisitFailed(v StreamingChecklistFailed) error
	VisitUnknown(typeName string) error
}

func (u *ChecklistLiveStatus) AcceptWithContext(ctx context.Context, v ChecklistLiveStatusVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "running":
		if u.running == nil {
			return fmt.Errorf("field \"running\" is required")
		}
		return v.VisitRunningWithContext(ctx, *u.running)
	case "initializing":
		if u.initializing == nil {
			return fmt.Errorf("field \"initializing\" is required")
		}
		return v.VisitInitializingWithContext(ctx, *u.initializing)
	case "failed":
		if u.failed == nil {
			return fmt.Errorf("field \"failed\" is required")
		}
		return v.VisitFailedWithContext(ctx, *u.failed)
	}
}

type ChecklistLiveStatusVisitorWithContext interface {
	VisitRunningWithContext(ctx context.Context, v StreamingChecklistRunning) error
	VisitInitializingWithContext(ctx context.Context, v StreamingChecklistInitializing) error
	VisitFailedWithContext(ctx context.Context, v StreamingChecklistFailed) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewChecklistLiveStatusFromRunning(v StreamingChecklistRunning) ChecklistLiveStatus {
	return ChecklistLiveStatus{typ: "running", running: &v}
}

func NewChecklistLiveStatusFromInitializing(v StreamingChecklistInitializing) ChecklistLiveStatus {
	return ChecklistLiveStatus{typ: "initializing", initializing: &v}
}

func NewChecklistLiveStatusFromFailed(v StreamingChecklistFailed) ChecklistLiveStatus {
	return ChecklistLiveStatus{typ: "failed", failed: &v}
}

type LastFailure struct {
	typ               string
	notComputed       *NotComputed
	computing         *Computing
	noPreviousFailure *NoPreviousFailure
	failure           *Failure
}

type lastFailureDeserializer struct {
	Type              string             `json:"type"`
	NotComputed       *NotComputed       `json:"notComputed"`
	Computing         *Computing         `json:"computing"`
	NoPreviousFailure *NoPreviousFailure `json:"noPreviousFailure"`
	Failure           *Failure           `json:"failure"`
}

func (u *lastFailureDeserializer) toStruct() LastFailure {
	return LastFailure{typ: u.Type, notComputed: u.NotComputed, computing: u.Computing, noPreviousFailure: u.NoPreviousFailure, failure: u.Failure}
}

func (u *LastFailure) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "notComputed":
		if u.notComputed == nil {
			return nil, fmt.Errorf("field \"notComputed\" is required")
		}
		return struct {
			Type        string      `json:"type"`
			NotComputed NotComputed `json:"notComputed"`
		}{Type: "notComputed", NotComputed: *u.notComputed}, nil
	case "computing":
		if u.computing == nil {
			return nil, fmt.Errorf("field \"computing\" is required")
		}
		return struct {
			Type      string    `json:"type"`
			Computing Computing `json:"computing"`
		}{Type: "computing", Computing: *u.computing}, nil
	case "noPreviousFailure":
		if u.noPreviousFailure == nil {
			return nil, fmt.Errorf("field \"noPreviousFailure\" is required")
		}
		return struct {
			Type              string            `json:"type"`
			NoPreviousFailure NoPreviousFailure `json:"noPreviousFailure"`
		}{Type: "noPreviousFailure", NoPreviousFailure: *u.noPreviousFailure}, nil
	case "failure":
		if u.failure == nil {
			return nil, fmt.Errorf("field \"failure\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			Failure Failure `json:"failure"`
		}{Type: "failure", Failure: *u.failure}, nil
	}
}

func (u LastFailure) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LastFailure) UnmarshalJSON(data []byte) error {
	var deser lastFailureDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "notComputed":
		if u.notComputed == nil {
			return fmt.Errorf("field \"notComputed\" is required")
		}
	case "computing":
		if u.computing == nil {
			return fmt.Errorf("field \"computing\" is required")
		}
	case "noPreviousFailure":
		if u.noPreviousFailure == nil {
			return fmt.Errorf("field \"noPreviousFailure\" is required")
		}
	case "failure":
		if u.failure == nil {
			return fmt.Errorf("field \"failure\" is required")
		}
	}
	return nil
}

func (u LastFailure) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LastFailure) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LastFailure) AcceptFuncs(notComputedFunc func(NotComputed) error, computingFunc func(Computing) error, noPreviousFailureFunc func(NoPreviousFailure) error, failureFunc func(Failure) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "notComputed":
		if u.notComputed == nil {
			return fmt.Errorf("field \"notComputed\" is required")
		}
		return notComputedFunc(*u.notComputed)
	case "computing":
		if u.computing == nil {
			return fmt.Errorf("field \"computing\" is required")
		}
		return computingFunc(*u.computing)
	case "noPreviousFailure":
		if u.noPreviousFailure == nil {
			return fmt.Errorf("field \"noPreviousFailure\" is required")
		}
		return noPreviousFailureFunc(*u.noPreviousFailure)
	case "failure":
		if u.failure == nil {
			return fmt.Errorf("field \"failure\" is required")
		}
		return failureFunc(*u.failure)
	}
}

func (u *LastFailure) NotComputedNoopSuccess(NotComputed) error {
	return nil
}

func (u *LastFailure) ComputingNoopSuccess(Computing) error {
	return nil
}

func (u *LastFailure) NoPreviousFailureNoopSuccess(NoPreviousFailure) error {
	return nil
}

func (u *LastFailure) FailureNoopSuccess(Failure) error {
	return nil
}

func (u *LastFailure) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LastFailure) Accept(v LastFailureVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "notComputed":
		if u.notComputed == nil {
			return fmt.Errorf("field \"notComputed\" is required")
		}
		return v.VisitNotComputed(*u.notComputed)
	case "computing":
		if u.computing == nil {
			return fmt.Errorf("field \"computing\" is required")
		}
		return v.VisitComputing(*u.computing)
	case "noPreviousFailure":
		if u.noPreviousFailure == nil {
			return fmt.Errorf("field \"noPreviousFailure\" is required")
		}
		return v.VisitNoPreviousFailure(*u.noPreviousFailure)
	case "failure":
		if u.failure == nil {
			return fmt.Errorf("field \"failure\" is required")
		}
		return v.VisitFailure(*u.failure)
	}
}

type LastFailureVisitor interface {
	VisitNotComputed(v NotComputed) error
	VisitComputing(v Computing) error
	VisitNoPreviousFailure(v NoPreviousFailure) error
	VisitFailure(v Failure) error
	VisitUnknown(typeName string) error
}

func (u *LastFailure) AcceptWithContext(ctx context.Context, v LastFailureVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "notComputed":
		if u.notComputed == nil {
			return fmt.Errorf("field \"notComputed\" is required")
		}
		return v.VisitNotComputedWithContext(ctx, *u.notComputed)
	case "computing":
		if u.computing == nil {
			return fmt.Errorf("field \"computing\" is required")
		}
		return v.VisitComputingWithContext(ctx, *u.computing)
	case "noPreviousFailure":
		if u.noPreviousFailure == nil {
			return fmt.Errorf("field \"noPreviousFailure\" is required")
		}
		return v.VisitNoPreviousFailureWithContext(ctx, *u.noPreviousFailure)
	case "failure":
		if u.failure == nil {
			return fmt.Errorf("field \"failure\" is required")
		}
		return v.VisitFailureWithContext(ctx, *u.failure)
	}
}

type LastFailureVisitorWithContext interface {
	VisitNotComputedWithContext(ctx context.Context, v NotComputed) error
	VisitComputingWithContext(ctx context.Context, v Computing) error
	VisitNoPreviousFailureWithContext(ctx context.Context, v NoPreviousFailure) error
	VisitFailureWithContext(ctx context.Context, v Failure) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLastFailureFromNotComputed(v NotComputed) LastFailure {
	return LastFailure{typ: "notComputed", notComputed: &v}
}

func NewLastFailureFromComputing(v Computing) LastFailure {
	return LastFailure{typ: "computing", computing: &v}
}

func NewLastFailureFromNoPreviousFailure(v NoPreviousFailure) LastFailure {
	return LastFailure{typ: "noPreviousFailure", noPreviousFailure: &v}
}

func NewLastFailureFromFailure(v Failure) LastFailure {
	return LastFailure{typ: "failure", failure: &v}
}
