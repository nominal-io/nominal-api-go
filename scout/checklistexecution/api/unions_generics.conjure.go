// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"
)

type CheckStatusWithT[T any] CheckStatus

func (u *CheckStatusWithT[T]) Accept(ctx context.Context, v CheckStatusVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "pass":
		if u.pass == nil {
			return result, fmt.Errorf("field \"pass\" is required")
		}
		return v.VisitPass(ctx, *u.pass)
	case "fail":
		if u.fail == nil {
			return result, fmt.Errorf("field \"fail\" is required")
		}
		return v.VisitFail(ctx, *u.fail)
	case "invalid":
		if u.invalid == nil {
			return result, fmt.Errorf("field \"invalid\" is required")
		}
		return v.VisitInvalid(ctx, *u.invalid)
	case "skipped":
		if u.skipped == nil {
			return result, fmt.Errorf("field \"skipped\" is required")
		}
		return v.VisitSkipped(ctx, *u.skipped)
	}
}

func (u *CheckStatusWithT[T]) AcceptFuncs(passFunc func(Pass) (T, error), failFunc func(Fail) (T, error), invalidFunc func(Invalid) (T, error), skippedFunc func(Skipped) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pass":
		if u.pass == nil {
			return result, fmt.Errorf("field \"pass\" is required")
		}
		return passFunc(*u.pass)
	case "fail":
		if u.fail == nil {
			return result, fmt.Errorf("field \"fail\" is required")
		}
		return failFunc(*u.fail)
	case "invalid":
		if u.invalid == nil {
			return result, fmt.Errorf("field \"invalid\" is required")
		}
		return invalidFunc(*u.invalid)
	case "skipped":
		if u.skipped == nil {
			return result, fmt.Errorf("field \"skipped\" is required")
		}
		return skippedFunc(*u.skipped)
	}
}

func (u *CheckStatusWithT[T]) PassNoopSuccess(Pass) (T, error) {
	var result T
	return result, nil
}

func (u *CheckStatusWithT[T]) FailNoopSuccess(Fail) (T, error) {
	var result T
	return result, nil
}

func (u *CheckStatusWithT[T]) InvalidNoopSuccess(Invalid) (T, error) {
	var result T
	return result, nil
}

func (u *CheckStatusWithT[T]) SkippedNoopSuccess(Skipped) (T, error) {
	var result T
	return result, nil
}

func (u *CheckStatusWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CheckStatusVisitorWithT[T any] interface {
	VisitPass(ctx context.Context, v Pass) (T, error)
	VisitFail(ctx context.Context, v Fail) (T, error)
	VisitInvalid(ctx context.Context, v Invalid) (T, error)
	VisitSkipped(ctx context.Context, v Skipped) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ChecklistLiveStatusWithT[T any] ChecklistLiveStatus

func (u *ChecklistLiveStatusWithT[T]) Accept(ctx context.Context, v ChecklistLiveStatusVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "running":
		if u.running == nil {
			return result, fmt.Errorf("field \"running\" is required")
		}
		return v.VisitRunning(ctx, *u.running)
	case "initializing":
		if u.initializing == nil {
			return result, fmt.Errorf("field \"initializing\" is required")
		}
		return v.VisitInitializing(ctx, *u.initializing)
	case "failed":
		if u.failed == nil {
			return result, fmt.Errorf("field \"failed\" is required")
		}
		return v.VisitFailed(ctx, *u.failed)
	}
}

func (u *ChecklistLiveStatusWithT[T]) AcceptFuncs(runningFunc func(StreamingChecklistRunning) (T, error), initializingFunc func(StreamingChecklistInitializing) (T, error), failedFunc func(StreamingChecklistFailed) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "running":
		if u.running == nil {
			return result, fmt.Errorf("field \"running\" is required")
		}
		return runningFunc(*u.running)
	case "initializing":
		if u.initializing == nil {
			return result, fmt.Errorf("field \"initializing\" is required")
		}
		return initializingFunc(*u.initializing)
	case "failed":
		if u.failed == nil {
			return result, fmt.Errorf("field \"failed\" is required")
		}
		return failedFunc(*u.failed)
	}
}

func (u *ChecklistLiveStatusWithT[T]) RunningNoopSuccess(StreamingChecklistRunning) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistLiveStatusWithT[T]) InitializingNoopSuccess(StreamingChecklistInitializing) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistLiveStatusWithT[T]) FailedNoopSuccess(StreamingChecklistFailed) (T, error) {
	var result T
	return result, nil
}

func (u *ChecklistLiveStatusWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ChecklistLiveStatusVisitorWithT[T any] interface {
	VisitRunning(ctx context.Context, v StreamingChecklistRunning) (T, error)
	VisitInitializing(ctx context.Context, v StreamingChecklistInitializing) (T, error)
	VisitFailed(ctx context.Context, v StreamingChecklistFailed) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type LastFailureWithT[T any] LastFailure

func (u *LastFailureWithT[T]) Accept(ctx context.Context, v LastFailureVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "notComputed":
		if u.notComputed == nil {
			return result, fmt.Errorf("field \"notComputed\" is required")
		}
		return v.VisitNotComputed(ctx, *u.notComputed)
	case "computing":
		if u.computing == nil {
			return result, fmt.Errorf("field \"computing\" is required")
		}
		return v.VisitComputing(ctx, *u.computing)
	case "noPreviousFailure":
		if u.noPreviousFailure == nil {
			return result, fmt.Errorf("field \"noPreviousFailure\" is required")
		}
		return v.VisitNoPreviousFailure(ctx, *u.noPreviousFailure)
	case "failure":
		if u.failure == nil {
			return result, fmt.Errorf("field \"failure\" is required")
		}
		return v.VisitFailure(ctx, *u.failure)
	}
}

func (u *LastFailureWithT[T]) AcceptFuncs(notComputedFunc func(NotComputed) (T, error), computingFunc func(Computing) (T, error), noPreviousFailureFunc func(NoPreviousFailure) (T, error), failureFunc func(Failure) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "notComputed":
		if u.notComputed == nil {
			return result, fmt.Errorf("field \"notComputed\" is required")
		}
		return notComputedFunc(*u.notComputed)
	case "computing":
		if u.computing == nil {
			return result, fmt.Errorf("field \"computing\" is required")
		}
		return computingFunc(*u.computing)
	case "noPreviousFailure":
		if u.noPreviousFailure == nil {
			return result, fmt.Errorf("field \"noPreviousFailure\" is required")
		}
		return noPreviousFailureFunc(*u.noPreviousFailure)
	case "failure":
		if u.failure == nil {
			return result, fmt.Errorf("field \"failure\" is required")
		}
		return failureFunc(*u.failure)
	}
}

func (u *LastFailureWithT[T]) NotComputedNoopSuccess(NotComputed) (T, error) {
	var result T
	return result, nil
}

func (u *LastFailureWithT[T]) ComputingNoopSuccess(Computing) (T, error) {
	var result T
	return result, nil
}

func (u *LastFailureWithT[T]) NoPreviousFailureNoopSuccess(NoPreviousFailure) (T, error) {
	var result T
	return result, nil
}

func (u *LastFailureWithT[T]) FailureNoopSuccess(Failure) (T, error) {
	var result T
	return result, nil
}

func (u *LastFailureWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LastFailureVisitorWithT[T any] interface {
	VisitNotComputed(ctx context.Context, v NotComputed) (T, error)
	VisitComputing(ctx context.Context, v Computing) (T, error)
	VisitNoPreviousFailure(ctx context.Context, v NoPreviousFailure) (T, error)
	VisitFailure(ctx context.Context, v Failure) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
