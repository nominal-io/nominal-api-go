// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api/internal/conjureerrors"
	api1 "github.com/nominal-io/nominal-api/scout/rids/api"
	"github.com/nominal-io/nominal-api/scout/run/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type checkNotAvailableInStreamingContext struct {
	CheckName string `json:"checkName"`
}

func (o checkNotAvailableInStreamingContext) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *checkNotAvailableInStreamingContext) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCheckNotAvailableInStreamingContext returns new instance of CheckNotAvailableInStreamingContext error.
func NewCheckNotAvailableInStreamingContext(checkNameArg string) *CheckNotAvailableInStreamingContext {
	return &CheckNotAvailableInStreamingContext{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), checkNotAvailableInStreamingContext: checkNotAvailableInStreamingContext{CheckName: checkNameArg}}
}

// WrapWithCheckNotAvailableInStreamingContext returns new instance of CheckNotAvailableInStreamingContext error wrapping an existing error.
func WrapWithCheckNotAvailableInStreamingContext(err error, checkNameArg string) *CheckNotAvailableInStreamingContext {
	return &CheckNotAvailableInStreamingContext{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, checkNotAvailableInStreamingContext: checkNotAvailableInStreamingContext{CheckName: checkNameArg}}
}

// CheckNotAvailableInStreamingContext is an error type.
type CheckNotAvailableInStreamingContext struct {
	errorInstanceID uuid.UUID
	checkNotAvailableInStreamingContext
	cause error
	stack werror.StackTrace
}

// IsCheckNotAvailableInStreamingContext returns true if err is an instance of CheckNotAvailableInStreamingContext.
func IsCheckNotAvailableInStreamingContext(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CheckNotAvailableInStreamingContext)
	return ok
}

func (e *CheckNotAvailableInStreamingContext) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT ChecklistExecution:CheckNotAvailableInStreamingContext (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CheckNotAvailableInStreamingContext) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CheckNotAvailableInStreamingContext) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CheckNotAvailableInStreamingContext) Message() string {
	return "INVALID_ARGUMENT ChecklistExecution:CheckNotAvailableInStreamingContext"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CheckNotAvailableInStreamingContext) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CheckNotAvailableInStreamingContext) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CheckNotAvailableInStreamingContext) Name() string {
	return "ChecklistExecution:CheckNotAvailableInStreamingContext"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CheckNotAvailableInStreamingContext) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CheckNotAvailableInStreamingContext) Parameters() map[string]interface{} {
	return map[string]interface{}{"checkName": e.CheckName}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CheckNotAvailableInStreamingContext) safeParams() map[string]interface{} {
	return map[string]interface{}{"checkName": e.CheckName, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CheckNotAvailableInStreamingContext) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CheckNotAvailableInStreamingContext) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CheckNotAvailableInStreamingContext) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CheckNotAvailableInStreamingContext) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.checkNotAvailableInStreamingContext)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "ChecklistExecution:CheckNotAvailableInStreamingContext", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CheckNotAvailableInStreamingContext) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters checkNotAvailableInStreamingContext
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.checkNotAvailableInStreamingContext = parameters
	return nil
}

type checklistAlreadyRunning struct{}

func (o checklistAlreadyRunning) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *checklistAlreadyRunning) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewChecklistAlreadyRunning returns new instance of ChecklistAlreadyRunning error.
func NewChecklistAlreadyRunning() *ChecklistAlreadyRunning {
	return &ChecklistAlreadyRunning{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), checklistAlreadyRunning: checklistAlreadyRunning{}}
}

// WrapWithChecklistAlreadyRunning returns new instance of ChecklistAlreadyRunning error wrapping an existing error.
func WrapWithChecklistAlreadyRunning(err error) *ChecklistAlreadyRunning {
	return &ChecklistAlreadyRunning{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, checklistAlreadyRunning: checklistAlreadyRunning{}}
}

// ChecklistAlreadyRunning is an error type.
type ChecklistAlreadyRunning struct {
	errorInstanceID uuid.UUID
	checklistAlreadyRunning
	cause error
	stack werror.StackTrace
}

// IsChecklistAlreadyRunning returns true if err is an instance of ChecklistAlreadyRunning.
func IsChecklistAlreadyRunning(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ChecklistAlreadyRunning)
	return ok
}

func (e *ChecklistAlreadyRunning) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT ChecklistExecution:ChecklistAlreadyRunning (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ChecklistAlreadyRunning) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ChecklistAlreadyRunning) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ChecklistAlreadyRunning) Message() string {
	return "INVALID_ARGUMENT ChecklistExecution:ChecklistAlreadyRunning"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ChecklistAlreadyRunning) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ChecklistAlreadyRunning) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ChecklistAlreadyRunning) Name() string {
	return "ChecklistExecution:ChecklistAlreadyRunning"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ChecklistAlreadyRunning) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ChecklistAlreadyRunning) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ChecklistAlreadyRunning) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecklistAlreadyRunning) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ChecklistAlreadyRunning) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ChecklistAlreadyRunning) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ChecklistAlreadyRunning) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.checklistAlreadyRunning)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "ChecklistExecution:ChecklistAlreadyRunning", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ChecklistAlreadyRunning) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters checklistAlreadyRunning
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.checklistAlreadyRunning = parameters
	return nil
}

type connectionNotAvailableForStreaming struct {
	Connection api.ConnectionRid `json:"connection"`
}

func (o connectionNotAvailableForStreaming) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *connectionNotAvailableForStreaming) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConnectionNotAvailableForStreaming returns new instance of ConnectionNotAvailableForStreaming error.
func NewConnectionNotAvailableForStreaming(connectionArg api.ConnectionRid) *ConnectionNotAvailableForStreaming {
	return &ConnectionNotAvailableForStreaming{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), connectionNotAvailableForStreaming: connectionNotAvailableForStreaming{Connection: connectionArg}}
}

// WrapWithConnectionNotAvailableForStreaming returns new instance of ConnectionNotAvailableForStreaming error wrapping an existing error.
func WrapWithConnectionNotAvailableForStreaming(err error, connectionArg api.ConnectionRid) *ConnectionNotAvailableForStreaming {
	return &ConnectionNotAvailableForStreaming{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, connectionNotAvailableForStreaming: connectionNotAvailableForStreaming{Connection: connectionArg}}
}

// ConnectionNotAvailableForStreaming is an error type.
type ConnectionNotAvailableForStreaming struct {
	errorInstanceID uuid.UUID
	connectionNotAvailableForStreaming
	cause error
	stack werror.StackTrace
}

// IsConnectionNotAvailableForStreaming returns true if err is an instance of ConnectionNotAvailableForStreaming.
func IsConnectionNotAvailableForStreaming(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConnectionNotAvailableForStreaming)
	return ok
}

func (e *ConnectionNotAvailableForStreaming) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT ChecklistExecution:ConnectionNotAvailableForStreaming (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConnectionNotAvailableForStreaming) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConnectionNotAvailableForStreaming) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConnectionNotAvailableForStreaming) Message() string {
	return "INVALID_ARGUMENT ChecklistExecution:ConnectionNotAvailableForStreaming"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConnectionNotAvailableForStreaming) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConnectionNotAvailableForStreaming) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ConnectionNotAvailableForStreaming) Name() string {
	return "ChecklistExecution:ConnectionNotAvailableForStreaming"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConnectionNotAvailableForStreaming) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConnectionNotAvailableForStreaming) Parameters() map[string]interface{} {
	return map[string]interface{}{"connection": e.Connection}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConnectionNotAvailableForStreaming) safeParams() map[string]interface{} {
	return map[string]interface{}{"connection": e.Connection, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConnectionNotAvailableForStreaming) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConnectionNotAvailableForStreaming) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConnectionNotAvailableForStreaming) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConnectionNotAvailableForStreaming) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.connectionNotAvailableForStreaming)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "ChecklistExecution:ConnectionNotAvailableForStreaming", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConnectionNotAvailableForStreaming) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters connectionNotAvailableForStreaming
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.connectionNotAvailableForStreaming = parameters
	return nil
}

type streamingChecklistNotFound struct {
	ChecklistRid api1.ChecklistRid `json:"checklistRid"`
}

func (o streamingChecklistNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *streamingChecklistNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewStreamingChecklistNotFound returns new instance of StreamingChecklistNotFound error.
func NewStreamingChecklistNotFound(checklistRidArg api1.ChecklistRid) *StreamingChecklistNotFound {
	return &StreamingChecklistNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), streamingChecklistNotFound: streamingChecklistNotFound{ChecklistRid: checklistRidArg}}
}

// WrapWithStreamingChecklistNotFound returns new instance of StreamingChecklistNotFound error wrapping an existing error.
func WrapWithStreamingChecklistNotFound(err error, checklistRidArg api1.ChecklistRid) *StreamingChecklistNotFound {
	return &StreamingChecklistNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, streamingChecklistNotFound: streamingChecklistNotFound{ChecklistRid: checklistRidArg}}
}

// StreamingChecklistNotFound is an error type.
type StreamingChecklistNotFound struct {
	errorInstanceID uuid.UUID
	streamingChecklistNotFound
	cause error
	stack werror.StackTrace
}

// IsStreamingChecklistNotFound returns true if err is an instance of StreamingChecklistNotFound.
func IsStreamingChecklistNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*StreamingChecklistNotFound)
	return ok
}

func (e *StreamingChecklistNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND ChecklistExecution:StreamingChecklistNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *StreamingChecklistNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *StreamingChecklistNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *StreamingChecklistNotFound) Message() string {
	return "NOT_FOUND ChecklistExecution:StreamingChecklistNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *StreamingChecklistNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *StreamingChecklistNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *StreamingChecklistNotFound) Name() string {
	return "ChecklistExecution:StreamingChecklistNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *StreamingChecklistNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *StreamingChecklistNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"checklistRid": e.ChecklistRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *StreamingChecklistNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"checklistRid": e.ChecklistRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *StreamingChecklistNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *StreamingChecklistNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *StreamingChecklistNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e StreamingChecklistNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.streamingChecklistNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "ChecklistExecution:StreamingChecklistNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *StreamingChecklistNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters streamingChecklistNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.streamingChecklistNotFound = parameters
	return nil
}

type streamingChecklistNotFoundForAsset struct {
	ChecklistRid api1.ChecklistRid `json:"checklistRid"`
	AssetRid     api1.AssetRid     `json:"assetRid"`
}

func (o streamingChecklistNotFoundForAsset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *streamingChecklistNotFoundForAsset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewStreamingChecklistNotFoundForAsset returns new instance of StreamingChecklistNotFoundForAsset error.
func NewStreamingChecklistNotFoundForAsset(checklistRidArg api1.ChecklistRid, assetRidArg api1.AssetRid) *StreamingChecklistNotFoundForAsset {
	return &StreamingChecklistNotFoundForAsset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), streamingChecklistNotFoundForAsset: streamingChecklistNotFoundForAsset{ChecklistRid: checklistRidArg, AssetRid: assetRidArg}}
}

// WrapWithStreamingChecklistNotFoundForAsset returns new instance of StreamingChecklistNotFoundForAsset error wrapping an existing error.
func WrapWithStreamingChecklistNotFoundForAsset(err error, checklistRidArg api1.ChecklistRid, assetRidArg api1.AssetRid) *StreamingChecklistNotFoundForAsset {
	return &StreamingChecklistNotFoundForAsset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, streamingChecklistNotFoundForAsset: streamingChecklistNotFoundForAsset{ChecklistRid: checklistRidArg, AssetRid: assetRidArg}}
}

// StreamingChecklistNotFoundForAsset is an error type.
type StreamingChecklistNotFoundForAsset struct {
	errorInstanceID uuid.UUID
	streamingChecklistNotFoundForAsset
	cause error
	stack werror.StackTrace
}

// IsStreamingChecklistNotFoundForAsset returns true if err is an instance of StreamingChecklistNotFoundForAsset.
func IsStreamingChecklistNotFoundForAsset(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*StreamingChecklistNotFoundForAsset)
	return ok
}

func (e *StreamingChecklistNotFoundForAsset) Error() string {
	return fmt.Sprintf("NOT_FOUND ChecklistExecution:StreamingChecklistNotFoundForAsset (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *StreamingChecklistNotFoundForAsset) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *StreamingChecklistNotFoundForAsset) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *StreamingChecklistNotFoundForAsset) Message() string {
	return "NOT_FOUND ChecklistExecution:StreamingChecklistNotFoundForAsset"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *StreamingChecklistNotFoundForAsset) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *StreamingChecklistNotFoundForAsset) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *StreamingChecklistNotFoundForAsset) Name() string {
	return "ChecklistExecution:StreamingChecklistNotFoundForAsset"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *StreamingChecklistNotFoundForAsset) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *StreamingChecklistNotFoundForAsset) Parameters() map[string]interface{} {
	return map[string]interface{}{"checklistRid": e.ChecklistRid, "assetRid": e.AssetRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *StreamingChecklistNotFoundForAsset) safeParams() map[string]interface{} {
	return map[string]interface{}{"checklistRid": e.ChecklistRid, "assetRid": e.AssetRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *StreamingChecklistNotFoundForAsset) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *StreamingChecklistNotFoundForAsset) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *StreamingChecklistNotFoundForAsset) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e StreamingChecklistNotFoundForAsset) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.streamingChecklistNotFoundForAsset)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "ChecklistExecution:StreamingChecklistNotFoundForAsset", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *StreamingChecklistNotFoundForAsset) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters streamingChecklistNotFoundForAsset
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.streamingChecklistNotFoundForAsset = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("ChecklistExecution:CheckNotAvailableInStreamingContext", reflect.TypeOf(CheckNotAvailableInStreamingContext{}))
	conjureerrors.RegisterErrorType("ChecklistExecution:ChecklistAlreadyRunning", reflect.TypeOf(ChecklistAlreadyRunning{}))
	conjureerrors.RegisterErrorType("ChecklistExecution:ConnectionNotAvailableForStreaming", reflect.TypeOf(ConnectionNotAvailableForStreaming{}))
	conjureerrors.RegisterErrorType("ChecklistExecution:StreamingChecklistNotFound", reflect.TypeOf(StreamingChecklistNotFound{}))
	conjureerrors.RegisterErrorType("ChecklistExecution:StreamingChecklistNotFoundForAsset", reflect.TypeOf(StreamingChecklistNotFoundForAsset{}))
}
