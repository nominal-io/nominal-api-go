// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"
	"net/url"

	"github.com/nominal-io/nominal-api/internal/conjureerrors"
	"github.com/nominal-io/nominal-api/scout/rids/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	werror "github.com/palantir/witchcraft-go-error"
)

// The Checklist Execution Service checks the status of checklist executions.
type ChecklistExecutionServiceClient interface {
	// For each request, get the latest status for each check in a streaming checklist against the given asset.
	ChecklistLiveStatus(ctx context.Context, authHeader bearertoken.Token, requestArg BatchChecklistLiveStatusRequest) (BatchChecklistLiveStatusResponse, error)
	/*
	   Triggers a checklist to run continuously against assets.
	   If the checklist is already running for the given asset, replace the existing configuration with the one specified by the request.
	*/
	ExecuteStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, requestArg ExecuteChecklistForAssetsRequest) error
	// Lists all running streaming checklists.
	ListStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, requestArg ListStreamingChecklistRequest) (ListStreamingChecklistResponse, error)
	// Retrieves all streaming checklists for a given asset.
	ListStreamingChecklistForAsset(ctx context.Context, authHeader bearertoken.Token, requestArg ListStreamingChecklistForAssetRequest) (ListStreamingChecklistForAssetResponse, error)
	// Retrieves the set of assets and their execution configurations for a streaming checklist specified by the checklistRid.
	GetStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid) (StreamingChecklistInfo, error)
	/*
	   Retrieves the set of assets and their execution configurations for all streaming checklists specified by the request.
	   If a streaming checklist is not found, it will not be included in the response.
	*/
	BatchGetStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, requestArg BatchGetStreamingChecklistRequest) (BatchGetStreamingChecklistResponse, error)
	// Stops the execution of a streaming checklist on all assets.
	StopStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid) error
	// Stops the execution of a streaming checklist for a given set of assets.
	StopStreamingChecklistForAssets(ctx context.Context, authHeader bearertoken.Token, requestArg StopStreamingChecklistForAssetsRequest) error
	// Reloads the state of the streaming checklist for the given checklistRid.
	ReloadStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid) error
	// Validates that the channels referenced by the checklist can be resolved against the data sources.
	ValidateChecklistResolution(ctx context.Context, authHeader bearertoken.Token, requestArg BatchValidateChecklistResolutionRequest) (BatchValidateChecklistResolutionResponse, error)
}

type checklistExecutionServiceClient struct {
	client httpclient.Client
}

func NewChecklistExecutionServiceClient(client httpclient.Client) ChecklistExecutionServiceClient {
	return &checklistExecutionServiceClient{client: client}
}

func (c *checklistExecutionServiceClient) ChecklistLiveStatus(ctx context.Context, authHeader bearertoken.Token, requestArg BatchChecklistLiveStatusRequest) (BatchChecklistLiveStatusResponse, error) {
	var defaultReturnVal BatchChecklistLiveStatusResponse
	var returnVal *BatchChecklistLiveStatusResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ChecklistLiveStatus"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/checklist-execution/checklist-live-status"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "checklistLiveStatus failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "checklistLiveStatus response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistExecutionServiceClient) ExecuteStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, requestArg ExecuteChecklistForAssetsRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ExecuteStreamingChecklist"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/checklist-execution/execute-streaming-checklist"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "executeStreamingChecklist failed")
	}
	return nil
}

func (c *checklistExecutionServiceClient) ListStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, requestArg ListStreamingChecklistRequest) (ListStreamingChecklistResponse, error) {
	var defaultReturnVal ListStreamingChecklistResponse
	var returnVal *ListStreamingChecklistResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ListStreamingChecklist"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/checklist-execution/list-streaming-checklists"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "listStreamingChecklist failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "listStreamingChecklist response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistExecutionServiceClient) ListStreamingChecklistForAsset(ctx context.Context, authHeader bearertoken.Token, requestArg ListStreamingChecklistForAssetRequest) (ListStreamingChecklistForAssetResponse, error) {
	var defaultReturnVal ListStreamingChecklistForAssetResponse
	var returnVal *ListStreamingChecklistForAssetResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ListStreamingChecklistForAsset"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/checklist-execution/list-streaming-checklists-for-asset"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "listStreamingChecklistForAsset failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "listStreamingChecklistForAsset response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistExecutionServiceClient) GetStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid) (StreamingChecklistInfo, error) {
	var defaultReturnVal StreamingChecklistInfo
	var returnVal *StreamingChecklistInfo
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetStreamingChecklist"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/checklist-execution/get-streaming-checklist/%s", url.PathEscape(fmt.Sprint(checklistRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getStreamingChecklist failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getStreamingChecklist response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistExecutionServiceClient) BatchGetStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, requestArg BatchGetStreamingChecklistRequest) (BatchGetStreamingChecklistResponse, error) {
	var defaultReturnVal BatchGetStreamingChecklistResponse
	var returnVal *BatchGetStreamingChecklistResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGetStreamingChecklist"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/checklist-execution/get-streaming-checklists"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "batchGetStreamingChecklist failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "batchGetStreamingChecklist response cannot be nil")
	}
	return *returnVal, nil
}

func (c *checklistExecutionServiceClient) StopStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("StopStreamingChecklist"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("DELETE"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/checklist-execution/stop-streaming-checklist/%s", url.PathEscape(fmt.Sprint(checklistRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "stopStreamingChecklist failed")
	}
	return nil
}

func (c *checklistExecutionServiceClient) StopStreamingChecklistForAssets(ctx context.Context, authHeader bearertoken.Token, requestArg StopStreamingChecklistForAssetsRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("StopStreamingChecklistForAssets"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/checklist-execution/stop-streaming-checklist-for-assets"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "stopStreamingChecklistForAssets failed")
	}
	return nil
}

func (c *checklistExecutionServiceClient) ReloadStreamingChecklist(ctx context.Context, authHeader bearertoken.Token, checklistRidArg api.ChecklistRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ReloadStreamingChecklist"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/checklist-execution/reload-streaming-checklist/%s", url.PathEscape(fmt.Sprint(checklistRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "reloadStreamingChecklist failed")
	}
	return nil
}

func (c *checklistExecutionServiceClient) ValidateChecklistResolution(ctx context.Context, authHeader bearertoken.Token, requestArg BatchValidateChecklistResolutionRequest) (BatchValidateChecklistResolutionResponse, error) {
	var defaultReturnVal BatchValidateChecklistResolutionResponse
	var returnVal *BatchValidateChecklistResolutionResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ValidateChecklistResolution"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/checklist-execution/validate-checklist-resolution"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "validateChecklistResolution failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "validateChecklistResolution response cannot be nil")
	}
	return *returnVal, nil
}

// The Checklist Execution Service checks the status of checklist executions.
type ChecklistExecutionServiceClientWithAuth interface {
	// For each request, get the latest status for each check in a streaming checklist against the given asset.
	ChecklistLiveStatus(ctx context.Context, requestArg BatchChecklistLiveStatusRequest) (BatchChecklistLiveStatusResponse, error)
	/*
	   Triggers a checklist to run continuously against assets.
	   If the checklist is already running for the given asset, replace the existing configuration with the one specified by the request.
	*/
	ExecuteStreamingChecklist(ctx context.Context, requestArg ExecuteChecklistForAssetsRequest) error
	// Lists all running streaming checklists.
	ListStreamingChecklist(ctx context.Context, requestArg ListStreamingChecklistRequest) (ListStreamingChecklistResponse, error)
	// Retrieves all streaming checklists for a given asset.
	ListStreamingChecklistForAsset(ctx context.Context, requestArg ListStreamingChecklistForAssetRequest) (ListStreamingChecklistForAssetResponse, error)
	// Retrieves the set of assets and their execution configurations for a streaming checklist specified by the checklistRid.
	GetStreamingChecklist(ctx context.Context, checklistRidArg api.ChecklistRid) (StreamingChecklistInfo, error)
	/*
	   Retrieves the set of assets and their execution configurations for all streaming checklists specified by the request.
	   If a streaming checklist is not found, it will not be included in the response.
	*/
	BatchGetStreamingChecklist(ctx context.Context, requestArg BatchGetStreamingChecklistRequest) (BatchGetStreamingChecklistResponse, error)
	// Stops the execution of a streaming checklist on all assets.
	StopStreamingChecklist(ctx context.Context, checklistRidArg api.ChecklistRid) error
	// Stops the execution of a streaming checklist for a given set of assets.
	StopStreamingChecklistForAssets(ctx context.Context, requestArg StopStreamingChecklistForAssetsRequest) error
	// Reloads the state of the streaming checklist for the given checklistRid.
	ReloadStreamingChecklist(ctx context.Context, checklistRidArg api.ChecklistRid) error
	// Validates that the channels referenced by the checklist can be resolved against the data sources.
	ValidateChecklistResolution(ctx context.Context, requestArg BatchValidateChecklistResolutionRequest) (BatchValidateChecklistResolutionResponse, error)
}

func NewChecklistExecutionServiceClientWithAuth(client ChecklistExecutionServiceClient, authHeader bearertoken.Token) ChecklistExecutionServiceClientWithAuth {
	return &checklistExecutionServiceClientWithAuth{client: client, authHeader: authHeader}
}

type checklistExecutionServiceClientWithAuth struct {
	client     ChecklistExecutionServiceClient
	authHeader bearertoken.Token
}

func (c *checklistExecutionServiceClientWithAuth) ChecklistLiveStatus(ctx context.Context, requestArg BatchChecklistLiveStatusRequest) (BatchChecklistLiveStatusResponse, error) {
	return c.client.ChecklistLiveStatus(ctx, c.authHeader, requestArg)
}

func (c *checklistExecutionServiceClientWithAuth) ExecuteStreamingChecklist(ctx context.Context, requestArg ExecuteChecklistForAssetsRequest) error {
	return c.client.ExecuteStreamingChecklist(ctx, c.authHeader, requestArg)
}

func (c *checklistExecutionServiceClientWithAuth) ListStreamingChecklist(ctx context.Context, requestArg ListStreamingChecklistRequest) (ListStreamingChecklistResponse, error) {
	return c.client.ListStreamingChecklist(ctx, c.authHeader, requestArg)
}

func (c *checklistExecutionServiceClientWithAuth) ListStreamingChecklistForAsset(ctx context.Context, requestArg ListStreamingChecklistForAssetRequest) (ListStreamingChecklistForAssetResponse, error) {
	return c.client.ListStreamingChecklistForAsset(ctx, c.authHeader, requestArg)
}

func (c *checklistExecutionServiceClientWithAuth) GetStreamingChecklist(ctx context.Context, checklistRidArg api.ChecklistRid) (StreamingChecklistInfo, error) {
	return c.client.GetStreamingChecklist(ctx, c.authHeader, checklistRidArg)
}

func (c *checklistExecutionServiceClientWithAuth) BatchGetStreamingChecklist(ctx context.Context, requestArg BatchGetStreamingChecklistRequest) (BatchGetStreamingChecklistResponse, error) {
	return c.client.BatchGetStreamingChecklist(ctx, c.authHeader, requestArg)
}

func (c *checklistExecutionServiceClientWithAuth) StopStreamingChecklist(ctx context.Context, checklistRidArg api.ChecklistRid) error {
	return c.client.StopStreamingChecklist(ctx, c.authHeader, checklistRidArg)
}

func (c *checklistExecutionServiceClientWithAuth) StopStreamingChecklistForAssets(ctx context.Context, requestArg StopStreamingChecklistForAssetsRequest) error {
	return c.client.StopStreamingChecklistForAssets(ctx, c.authHeader, requestArg)
}

func (c *checklistExecutionServiceClientWithAuth) ReloadStreamingChecklist(ctx context.Context, checklistRidArg api.ChecklistRid) error {
	return c.client.ReloadStreamingChecklist(ctx, c.authHeader, checklistRidArg)
}

func (c *checklistExecutionServiceClientWithAuth) ValidateChecklistResolution(ctx context.Context, requestArg BatchValidateChecklistResolutionRequest) (BatchValidateChecklistResolutionResponse, error) {
	return c.client.ValidateChecklistResolution(ctx, c.authHeader, requestArg)
}

func NewChecklistExecutionServiceClientWithTokenProvider(client ChecklistExecutionServiceClient, tokenProvider httpclient.TokenProvider) ChecklistExecutionServiceClientWithAuth {
	return &checklistExecutionServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type checklistExecutionServiceClientWithTokenProvider struct {
	client        ChecklistExecutionServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *checklistExecutionServiceClientWithTokenProvider) ChecklistLiveStatus(ctx context.Context, requestArg BatchChecklistLiveStatusRequest) (BatchChecklistLiveStatusResponse, error) {
	var defaultReturnVal BatchChecklistLiveStatusResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ChecklistLiveStatus(ctx, bearertoken.Token(token), requestArg)
}

func (c *checklistExecutionServiceClientWithTokenProvider) ExecuteStreamingChecklist(ctx context.Context, requestArg ExecuteChecklistForAssetsRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.ExecuteStreamingChecklist(ctx, bearertoken.Token(token), requestArg)
}

func (c *checklistExecutionServiceClientWithTokenProvider) ListStreamingChecklist(ctx context.Context, requestArg ListStreamingChecklistRequest) (ListStreamingChecklistResponse, error) {
	var defaultReturnVal ListStreamingChecklistResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ListStreamingChecklist(ctx, bearertoken.Token(token), requestArg)
}

func (c *checklistExecutionServiceClientWithTokenProvider) ListStreamingChecklistForAsset(ctx context.Context, requestArg ListStreamingChecklistForAssetRequest) (ListStreamingChecklistForAssetResponse, error) {
	var defaultReturnVal ListStreamingChecklistForAssetResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ListStreamingChecklistForAsset(ctx, bearertoken.Token(token), requestArg)
}

func (c *checklistExecutionServiceClientWithTokenProvider) GetStreamingChecklist(ctx context.Context, checklistRidArg api.ChecklistRid) (StreamingChecklistInfo, error) {
	var defaultReturnVal StreamingChecklistInfo
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetStreamingChecklist(ctx, bearertoken.Token(token), checklistRidArg)
}

func (c *checklistExecutionServiceClientWithTokenProvider) BatchGetStreamingChecklist(ctx context.Context, requestArg BatchGetStreamingChecklistRequest) (BatchGetStreamingChecklistResponse, error) {
	var defaultReturnVal BatchGetStreamingChecklistResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGetStreamingChecklist(ctx, bearertoken.Token(token), requestArg)
}

func (c *checklistExecutionServiceClientWithTokenProvider) StopStreamingChecklist(ctx context.Context, checklistRidArg api.ChecklistRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.StopStreamingChecklist(ctx, bearertoken.Token(token), checklistRidArg)
}

func (c *checklistExecutionServiceClientWithTokenProvider) StopStreamingChecklistForAssets(ctx context.Context, requestArg StopStreamingChecklistForAssetsRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.StopStreamingChecklistForAssets(ctx, bearertoken.Token(token), requestArg)
}

func (c *checklistExecutionServiceClientWithTokenProvider) ReloadStreamingChecklist(ctx context.Context, checklistRidArg api.ChecklistRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.ReloadStreamingChecklist(ctx, bearertoken.Token(token), checklistRidArg)
}

func (c *checklistExecutionServiceClientWithTokenProvider) ValidateChecklistResolution(ctx context.Context, requestArg BatchValidateChecklistResolutionRequest) (BatchValidateChecklistResolutionResponse, error) {
	var defaultReturnVal BatchValidateChecklistResolutionResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ValidateChecklistResolution(ctx, bearertoken.Token(token), requestArg)
}
