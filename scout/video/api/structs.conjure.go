// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type Bounds struct {
	Start api.Timestamp `json:"start"`
	End   api.Timestamp `json:"end"`
}

func (o Bounds) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Bounds) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateSegment struct {
	DataHandle api.Handle `json:"dataHandle"`
	// The average frame rate (FPS) of the segment calculated as total frames / duration in seconds.
	FrameRate           float64           `conjure-docs:"The average frame rate (FPS) of the segment calculated as total frames / duration in seconds." json:"frameRate"`
	DurationSeconds     float64           `json:"durationSeconds"`
	Timestamps          SegmentTimestamps `json:"timestamps"`
	SegmentEndTimestamp api.Timestamp     `json:"segmentEndTimestamp"`
}

func (o CreateSegment) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateSegment) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateSegmentsRequest struct {
	Requests []CreateSegment `json:"requests"`
}

func (o CreateSegmentsRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]CreateSegment, 0)
	}
	type _tmpCreateSegmentsRequest CreateSegmentsRequest
	return safejson.Marshal(_tmpCreateSegmentsRequest(o))
}

func (o *CreateSegmentsRequest) UnmarshalJSON(data []byte) error {
	type _tmpCreateSegmentsRequest CreateSegmentsRequest
	var rawCreateSegmentsRequest _tmpCreateSegmentsRequest
	if err := safejson.Unmarshal(data, &rawCreateSegmentsRequest); err != nil {
		return err
	}
	if rawCreateSegmentsRequest.Requests == nil {
		rawCreateSegmentsRequest.Requests = make([]CreateSegment, 0)
	}
	*o = CreateSegmentsRequest(rawCreateSegmentsRequest)
	return nil
}

func (o CreateSegmentsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateSegmentsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateSegmentsResponse struct {
	Segments []Segment `json:"segments"`
}

func (o CreateSegmentsResponse) MarshalJSON() ([]byte, error) {
	if o.Segments == nil {
		o.Segments = make([]Segment, 0)
	}
	type _tmpCreateSegmentsResponse CreateSegmentsResponse
	return safejson.Marshal(_tmpCreateSegmentsResponse(o))
}

func (o *CreateSegmentsResponse) UnmarshalJSON(data []byte) error {
	type _tmpCreateSegmentsResponse CreateSegmentsResponse
	var rawCreateSegmentsResponse _tmpCreateSegmentsResponse
	if err := safejson.Unmarshal(data, &rawCreateSegmentsResponse); err != nil {
		return err
	}
	if rawCreateSegmentsResponse.Segments == nil {
		rawCreateSegmentsResponse.Segments = make([]Segment, 0)
	}
	*o = CreateSegmentsResponse(rawCreateSegmentsResponse)
	return nil
}

func (o CreateSegmentsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateSegmentsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Request to create and persist a video file
type CreateVideoFileRequest struct {
	Title          string                  `json:"title"`
	Description    *string                 `json:"description,omitempty"`
	OriginMetadata VideoFileOriginMetadata `json:"originMetadata"`
	VideoRid       rids.VideoRid           `json:"videoRid"`
}

func (o CreateVideoFileRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateVideoFileRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateVideoRequest struct {
	Title       string                                 `json:"title"`
	Description *string                                `json:"description,omitempty"`
	Labels      []api.Label                            `json:"labels"`
	Properties  map[api.PropertyName]api.PropertyValue `json:"properties"`
	// Deprecated: deprecated in favor of per-file VideoFileOriginMetadata. Will be removed after April 15th.
	OriginMetadata *VideoOriginMetadata `json:"originMetadata,omitempty"`
	/*
	   The workspace in which to create the video. If not provided, the video will be created in
	   the default workspace for the user's organization, if the default workspace for the
	   organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the video. If not provided, the video will be created in\nthe default workspace for the user's organization, if the default workspace for the\norganization is configured." json:"workspace,omitempty"`
	/*
	   The markings to apply to the created video.
	   If not provided, the video will be visible to all users in the same workspace.
	*/
	MarkingRids []api1.MarkingRid `conjure-docs:"The markings to apply to the created video.\nIf not provided, the video will be visible to all users in the same workspace." json:"markingRids"`
}

func (o CreateVideoRequest) MarshalJSON() ([]byte, error) {
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if o.MarkingRids == nil {
		o.MarkingRids = make([]api1.MarkingRid, 0)
	}
	type _tmpCreateVideoRequest CreateVideoRequest
	return safejson.Marshal(_tmpCreateVideoRequest(o))
}

func (o *CreateVideoRequest) UnmarshalJSON(data []byte) error {
	type _tmpCreateVideoRequest CreateVideoRequest
	var rawCreateVideoRequest _tmpCreateVideoRequest
	if err := safejson.Unmarshal(data, &rawCreateVideoRequest); err != nil {
		return err
	}
	if rawCreateVideoRequest.Labels == nil {
		rawCreateVideoRequest.Labels = make([]api.Label, 0)
	}
	if rawCreateVideoRequest.Properties == nil {
		rawCreateVideoRequest.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if rawCreateVideoRequest.MarkingRids == nil {
		rawCreateVideoRequest.MarkingRids = make([]api1.MarkingRid, 0)
	}
	*o = CreateVideoRequest(rawCreateVideoRequest)
	return nil
}

func (o CreateVideoRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateVideoRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnrichedVideoIngestStatus struct {
	Status           VideoIngestStatus                           `json:"status"`
	FileIngestStatus map[rids.VideoFileRid]VideoFileIngestStatus `json:"fileIngestStatus"`
	NextPageToken    *api.Token                                  `json:"nextPageToken,omitempty"`
}

func (o EnrichedVideoIngestStatus) MarshalJSON() ([]byte, error) {
	if o.FileIngestStatus == nil {
		o.FileIngestStatus = make(map[rids.VideoFileRid]VideoFileIngestStatus, 0)
	}
	type _tmpEnrichedVideoIngestStatus EnrichedVideoIngestStatus
	return safejson.Marshal(_tmpEnrichedVideoIngestStatus(o))
}

func (o *EnrichedVideoIngestStatus) UnmarshalJSON(data []byte) error {
	type _tmpEnrichedVideoIngestStatus EnrichedVideoIngestStatus
	var rawEnrichedVideoIngestStatus _tmpEnrichedVideoIngestStatus
	if err := safejson.Unmarshal(data, &rawEnrichedVideoIngestStatus); err != nil {
		return err
	}
	if rawEnrichedVideoIngestStatus.FileIngestStatus == nil {
		rawEnrichedVideoIngestStatus.FileIngestStatus = make(map[rids.VideoFileRid]VideoFileIngestStatus, 0)
	}
	*o = EnrichedVideoIngestStatus(rawEnrichedVideoIngestStatus)
	return nil
}

func (o EnrichedVideoIngestStatus) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnrichedVideoIngestStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ErrorIngestStatus struct {
	Errors []IngestError `json:"errors"`
}

func (o ErrorIngestStatus) MarshalJSON() ([]byte, error) {
	if o.Errors == nil {
		o.Errors = make([]IngestError, 0)
	}
	type _tmpErrorIngestStatus ErrorIngestStatus
	return safejson.Marshal(_tmpErrorIngestStatus(o))
}

func (o *ErrorIngestStatus) UnmarshalJSON(data []byte) error {
	type _tmpErrorIngestStatus ErrorIngestStatus
	var rawErrorIngestStatus _tmpErrorIngestStatus
	if err := safejson.Unmarshal(data, &rawErrorIngestStatus); err != nil {
		return err
	}
	if rawErrorIngestStatus.Errors == nil {
		rawErrorIngestStatus.Errors = make([]IngestError, 0)
	}
	*o = ErrorIngestStatus(rawErrorIngestStatus)
	return nil
}

func (o ErrorIngestStatus) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ErrorIngestStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FileSummary struct {
	FileRid rids.VideoFileRid `json:"fileRid"`
	Bounds  Bounds            `json:"bounds"`
}

func (o FileSummary) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FileSummary) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetEnrichedVideoIngestStatusRequest struct {
	VideoRid rids.VideoRid `json:"videoRid"`
	Token    *api.Token    `json:"token,omitempty"`
}

func (o GetEnrichedVideoIngestStatusRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetEnrichedVideoIngestStatusRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetFileSummariesRequest struct {
	Bounds *Bounds `json:"bounds,omitempty"`
}

func (o GetFileSummariesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetFileSummariesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetFileSummariesResponse struct {
	FileSummaries []FileSummary `json:"fileSummaries"`
}

func (o GetFileSummariesResponse) MarshalJSON() ([]byte, error) {
	if o.FileSummaries == nil {
		o.FileSummaries = make([]FileSummary, 0)
	}
	type _tmpGetFileSummariesResponse GetFileSummariesResponse
	return safejson.Marshal(_tmpGetFileSummariesResponse(o))
}

func (o *GetFileSummariesResponse) UnmarshalJSON(data []byte) error {
	type _tmpGetFileSummariesResponse GetFileSummariesResponse
	var rawGetFileSummariesResponse _tmpGetFileSummariesResponse
	if err := safejson.Unmarshal(data, &rawGetFileSummariesResponse); err != nil {
		return err
	}
	if rawGetFileSummariesResponse.FileSummaries == nil {
		rawGetFileSummariesResponse.FileSummaries = make([]FileSummary, 0)
	}
	*o = GetFileSummariesResponse(rawGetFileSummariesResponse)
	return nil
}

func (o GetFileSummariesResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetFileSummariesResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetIngestStatusResponse struct {
	IngestStatus VideoFileIngestStatus `json:"ingestStatus"`
}

func (o GetIngestStatusResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetIngestStatusResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetPlaylistInBoundsRequest struct {
	Bounds *Bounds `json:"bounds,omitempty"`
}

func (o GetPlaylistInBoundsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetPlaylistInBoundsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetSegmentByTimestampRequest struct {
	Timestamp api.Timestamp `json:"timestamp"`
	/*
	   The start of the view range used to dynamically calculate media timestamps. The first segment with an
	   overlap with the time bounds will have its minimum media timestamp set to 0, with every subsequent
	   segment building media time cumulatively from that offset. This will determine the starting media
	   timestamp of the returned segment. The view range should be the same as the one requested to get the
	   playlist and segment summaries.
	*/
	ViewRangeStart *api.Timestamp `conjure-docs:"The start of the view range used to dynamically calculate media timestamps. The first segment with an \noverlap with the time bounds will have its minimum media timestamp set to 0, with every subsequent\nsegment building media time cumulatively from that offset. This will determine the starting media\ntimestamp of the returned segment. The view range should be the same as the one requested to get the\nplaylist and segment summaries." json:"viewRangeStart,omitempty"`
}

func (o GetSegmentByTimestampRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetSegmentByTimestampRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetSegmentSummariesInBoundsRequest struct {
	Bounds *Bounds `json:"bounds,omitempty"`
}

func (o GetSegmentSummariesInBoundsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetSegmentSummariesInBoundsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetVideosRequest struct {
	VideoRids []rids.VideoRid `json:"videoRids"`
}

func (o GetVideosRequest) MarshalJSON() ([]byte, error) {
	if o.VideoRids == nil {
		o.VideoRids = make([]rids.VideoRid, 0)
	}
	type _tmpGetVideosRequest GetVideosRequest
	return safejson.Marshal(_tmpGetVideosRequest(o))
}

func (o *GetVideosRequest) UnmarshalJSON(data []byte) error {
	type _tmpGetVideosRequest GetVideosRequest
	var rawGetVideosRequest _tmpGetVideosRequest
	if err := safejson.Unmarshal(data, &rawGetVideosRequest); err != nil {
		return err
	}
	if rawGetVideosRequest.VideoRids == nil {
		rawGetVideosRequest.VideoRids = make([]rids.VideoRid, 0)
	}
	*o = GetVideosRequest(rawGetVideosRequest)
	return nil
}

func (o GetVideosRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetVideosRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetVideosResponse struct {
	Responses []Video `json:"responses"`
}

func (o GetVideosResponse) MarshalJSON() ([]byte, error) {
	if o.Responses == nil {
		o.Responses = make([]Video, 0)
	}
	type _tmpGetVideosResponse GetVideosResponse
	return safejson.Marshal(_tmpGetVideosResponse(o))
}

func (o *GetVideosResponse) UnmarshalJSON(data []byte) error {
	type _tmpGetVideosResponse GetVideosResponse
	var rawGetVideosResponse _tmpGetVideosResponse
	if err := safejson.Unmarshal(data, &rawGetVideosResponse); err != nil {
		return err
	}
	if rawGetVideosResponse.Responses == nil {
		rawGetVideosResponse.Responses = make([]Video, 0)
	}
	*o = GetVideosResponse(rawGetVideosResponse)
	return nil
}

func (o GetVideosResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetVideosResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestError struct {
	ErrorType ErrorType `json:"errorType"`
	Message   string    `json:"message"`
}

func (o IngestError) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestError) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ListFilesInVideoRequest struct {
	VideoRid rids.VideoRid `json:"videoRid"`
	Token    *api.Token    `json:"token,omitempty"`
}

func (o ListFilesInVideoRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ListFilesInVideoRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ListFilesInVideoResponse struct {
	Files         []VideoFile `json:"files"`
	NextPageToken *api.Token  `json:"nextPageToken,omitempty"`
}

func (o ListFilesInVideoResponse) MarshalJSON() ([]byte, error) {
	if o.Files == nil {
		o.Files = make([]VideoFile, 0)
	}
	type _tmpListFilesInVideoResponse ListFilesInVideoResponse
	return safejson.Marshal(_tmpListFilesInVideoResponse(o))
}

func (o *ListFilesInVideoResponse) UnmarshalJSON(data []byte) error {
	type _tmpListFilesInVideoResponse ListFilesInVideoResponse
	var rawListFilesInVideoResponse _tmpListFilesInVideoResponse
	if err := safejson.Unmarshal(data, &rawListFilesInVideoResponse); err != nil {
		return err
	}
	if rawListFilesInVideoResponse.Files == nil {
		rawListFilesInVideoResponse.Files = make([]VideoFile, 0)
	}
	*o = ListFilesInVideoResponse(rawListFilesInVideoResponse)
	return nil
}

func (o ListFilesInVideoResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ListFilesInVideoResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Timestamps are derived from the mcap file containing the video frames.
type McapTimestampManifest struct {
	McapChannelLocator api.McapChannelLocator `json:"mcapChannelLocator"`
}

func (o McapTimestampManifest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *McapTimestampManifest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
these values will not be updated after ingest time, to allow for resetting. The updated values are stored
implicitly through the segment timestamps.
*/
type NoTimestampManifest struct {
	// Specifies the original starting timestamp of the video.
	StartingTimestamp api.Timestamp `conjure-docs:"Specifies the original starting timestamp of the video." json:"startingTimestamp"`
	// A field that specifies that the frame rate of the video does not match the frame rate of the camera | i.e. a slowed down or sped up video. Can specify either the camera frame rate or the absolute end time.
	ScaleParameter *ScaleParameter `conjure-docs:"A field that specifies that the frame rate of the video does not match the frame rate of the camera | i.e. a slowed down or sped up video. Can specify either the camera frame rate or the absolute end time." json:"scaleParameter,omitempty"`
}

func (o NoTimestampManifest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NoTimestampManifest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchVideosRequest struct {
	Query SearchVideosQuery `json:"query"`
	// Defaults to 100. Will throw if larger than 1_000.
	PageSize    *int        `conjure-docs:"Defaults to 100. Will throw if larger than 1_000." json:"pageSize,omitempty"`
	Token       *api.Token  `json:"token,omitempty"`
	SortOptions SortOptions `json:"sortOptions"`
	// Default search status is NOT_ARCHIVED if none are provided. Allows for including archived videos in search.
	ArchivedStatuses *[]api.ArchivedStatus `conjure-docs:"Default search status is NOT_ARCHIVED if none are provided. Allows for including archived videos in search." json:"archivedStatuses,omitempty"`
}

func (o SearchVideosRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchVideosRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchVideosResponse struct {
	Results       []Video    `json:"results"`
	NextPageToken *api.Token `json:"nextPageToken,omitempty"`
}

func (o SearchVideosResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]Video, 0)
	}
	type _tmpSearchVideosResponse SearchVideosResponse
	return safejson.Marshal(_tmpSearchVideosResponse(o))
}

func (o *SearchVideosResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchVideosResponse SearchVideosResponse
	var rawSearchVideosResponse _tmpSearchVideosResponse
	if err := safejson.Unmarshal(data, &rawSearchVideosResponse); err != nil {
		return err
	}
	if rawSearchVideosResponse.Results == nil {
		rawSearchVideosResponse.Results = make([]Video, 0)
	}
	*o = SearchVideosResponse(rawSearchVideosResponse)
	return nil
}

func (o SearchVideosResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchVideosResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Segment struct {
	Rid        rids.SegmentRid `json:"rid"`
	VideoRid   rids.VideoRid   `json:"videoRid"`
	DataHandle api.Handle      `json:"dataHandle"`
	// The average frame rate (FPS) of the segment calculated as total frames / duration in seconds.
	FrameRate float64 `conjure-docs:"The average frame rate (FPS) of the segment calculated as total frames / duration in seconds." json:"frameRate"`
	// The duration of a segment in media time.
	DurationSeconds float64 `conjure-docs:"The duration of a segment in media time." json:"durationSeconds"`
	/*
	   for videos with frame-level timestamps, we provide mappings, otherwise we just include a single list
	   of timestamps.
	*/
	Timestamps SegmentTimestamps `conjure-docs:"for videos with frame-level timestamps, we provide mappings, otherwise we just include a single list\nof timestamps." json:"timestamps"`
}

func (o Segment) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Segment) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Bounding timestamps for the frames within a segment. For non-frame-mapped videos, the min and max media
timestamps will be empty.
*/
type SegmentSummary struct {
	MinAbsoluteTimestamp api.Timestamp `json:"minAbsoluteTimestamp"`
	MaxAbsoluteTimestamp api.Timestamp `json:"maxAbsoluteTimestamp"`
	MinMediaTimestamp    float64       `json:"minMediaTimestamp"`
	MaxMediaTimestamp    float64       `json:"maxMediaTimestamp"`
}

func (o SegmentSummary) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SegmentSummary) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SortOptions struct {
	IsDescending bool      `json:"isDescending"`
	Field        SortField `json:"field"`
}

func (o SortOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SortOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SuccessIngestStatus struct{}

func (o SuccessIngestStatus) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SuccessIngestStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
contains 2 equal-length lists, which contain the video media time and user-provided absolute time
for the frame at each index. Enables frame-mapping on the front-end.
*/
type TimestampMappings struct {
	MediaTimestamps    []float64       `json:"mediaTimestamps"`
	AbsoluteTimestamps []api.Timestamp `json:"absoluteTimestamps"`
}

func (o TimestampMappings) MarshalJSON() ([]byte, error) {
	if o.MediaTimestamps == nil {
		o.MediaTimestamps = make([]float64, 0)
	}
	if o.AbsoluteTimestamps == nil {
		o.AbsoluteTimestamps = make([]api.Timestamp, 0)
	}
	type _tmpTimestampMappings TimestampMappings
	return safejson.Marshal(_tmpTimestampMappings(o))
}

func (o *TimestampMappings) UnmarshalJSON(data []byte) error {
	type _tmpTimestampMappings TimestampMappings
	var rawTimestampMappings _tmpTimestampMappings
	if err := safejson.Unmarshal(data, &rawTimestampMappings); err != nil {
		return err
	}
	if rawTimestampMappings.MediaTimestamps == nil {
		rawTimestampMappings.MediaTimestamps = make([]float64, 0)
	}
	if rawTimestampMappings.AbsoluteTimestamps == nil {
		rawTimestampMappings.AbsoluteTimestamps = make([]api.Timestamp, 0)
	}
	*o = TimestampMappings(rawTimestampMappings)
	return nil
}

func (o TimestampMappings) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimestampMappings) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateIngestStatusRequest struct {
	Video        rids.VideoRid         `json:"video"`
	IngestStatus VideoFileIngestStatus `json:"ingestStatus"`
}

func (o UpdateIngestStatusRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateIngestStatusRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Request to update metadata for a given video file.
type UpdateVideoFileRequest struct {
	Title             *string         `json:"title,omitempty"`
	Description       *string         `json:"description,omitempty"`
	StartingTimestamp *api.Timestamp  `json:"startingTimestamp,omitempty"`
	ScaleParameter    *ScaleParameter `json:"scaleParameter,omitempty"`
}

func (o UpdateVideoFileRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateVideoFileRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateVideoMetadataRequest struct {
	Title             *string                                 `json:"title,omitempty"`
	Description       *string                                 `json:"description,omitempty"`
	Labels            *[]api.Label                            `json:"labels,omitempty"`
	Properties        *map[api.PropertyName]api.PropertyValue `json:"properties,omitempty"`
	StartingTimestamp *api.Timestamp                          `json:"startingTimestamp,omitempty"`
	/*
	   Deprecated: deprecated in favor of updating scaleParameter per-file. Will fail if set on a video with multiple files.
	   Will be removed after April 15th.
	*/
	ScaleParameter *ScaleParameter `json:"scaleParameter,omitempty"`
}

func (o UpdateVideoMetadataRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateVideoMetadataRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Video struct {
	Rid         rids.VideoRid                          `json:"rid"`
	Title       string                                 `json:"title"`
	Description *string                                `json:"description,omitempty"`
	Labels      []api.Label                            `json:"labels"`
	Properties  map[api.PropertyName]api.PropertyValue `json:"properties"`
	CreatedBy   rid.ResourceIdentifier                 `json:"createdBy"`
	CreatedAt   datetime.DateTime                      `json:"createdAt"`
	// Deprecated: deprecated in favor of per-file VideoFileOriginMetadata. Will be removed after April 15th.
	OriginMetadata      *VideoOriginMetadata      `json:"originMetadata,omitempty"`
	AllSegmentsMetadata *VideoAllSegmentsMetadata `json:"allSegmentsMetadata,omitempty"`
}

func (o Video) MarshalJSON() ([]byte, error) {
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	type _tmpVideo Video
	return safejson.Marshal(_tmpVideo(o))
}

func (o *Video) UnmarshalJSON(data []byte) error {
	type _tmpVideo Video
	var rawVideo _tmpVideo
	if err := safejson.Unmarshal(data, &rawVideo); err != nil {
		return err
	}
	if rawVideo.Labels == nil {
		rawVideo.Labels = make([]api.Label, 0)
	}
	if rawVideo.Properties == nil {
		rawVideo.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	*o = Video(rawVideo)
	return nil
}

func (o Video) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Video) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type VideoAllSegmentsMetadata struct {
	Rid         rids.VideoRid `json:"rid"`
	NumFrames   int           `json:"numFrames"`
	NumSegments int           `json:"numSegments"`
	// deprecated, in favor of per-file VideoFileSegmentsMetadata scaleFactor. Will be removed after April 15th.
	ScaleFactor          *float64      `conjure-docs:"deprecated, in favor of per-file VideoFileSegmentsMetadata scaleFactor. Will be removed after April 15th." json:"scaleFactor,omitempty"`
	MinAbsoluteTimestamp api.Timestamp `json:"minAbsoluteTimestamp"`
	// the timestamp corresponding to absolute starting timestamp plus absolute duration of the video.
	MaxAbsoluteTimestamp api.Timestamp `conjure-docs:"the timestamp corresponding to absolute starting timestamp plus absolute duration of the video." json:"maxAbsoluteTimestamp"`
	MediaDurationSeconds float64       `json:"mediaDurationSeconds"`
	// The average media frame rate (FPS) of the video calculated as total frames / duration in seconds.
	MediaFrameRate float64 `conjure-docs:"The average media frame rate (FPS) of the video calculated as total frames / duration in seconds." json:"mediaFrameRate"`
	// deprecated. Will be removed after April 15th.
	MinTimestamp *api.Timestamp `conjure-docs:"deprecated. Will be removed after April 15th." json:"minTimestamp,omitempty"`
	// deprecated. Will be removed after April 15th.
	MaxTimestamp *api.Timestamp `conjure-docs:"deprecated. Will be removed after April 15th." json:"maxTimestamp,omitempty"`
	// deprecated. Will be removed after April 15th.
	DurationSeconds *float64 `conjure-docs:"deprecated. Will be removed after April 15th." json:"durationSeconds,omitempty"`
	// deprecated. Will be removed after April 15th.
	FrameRate *float64 `conjure-docs:"deprecated. Will be removed after April 15th." json:"frameRate,omitempty"`
}

func (o VideoAllSegmentsMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VideoAllSegmentsMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Representation of a single user-provided video file.
type VideoFile struct {
	Rid             rids.VideoFileRid          `json:"rid"`
	VideoRid        rids.VideoRid              `json:"videoRid"`
	Title           string                     `json:"title"`
	Description     *string                    `json:"description,omitempty"`
	CreatedBy       rid.ResourceIdentifier     `json:"createdBy"`
	CreatedAt       datetime.DateTime          `json:"createdAt"`
	OriginMetadata  VideoFileOriginMetadata    `json:"originMetadata"`
	SegmentMetadata *VideoFileSegmentsMetadata `json:"segmentMetadata,omitempty"`
}

func (o VideoFile) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VideoFile) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Metadata about the origin of the video file. This includes the original source of the video file and
additional timestamp metadata used to time-sync the video file.
*/
type VideoFileOriginMetadata struct {
	Source            api.Handle                 `json:"source"`
	TimestampManifest VideoFileTimestampManifest `json:"timestampManifest"`
}

func (o VideoFileOriginMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VideoFileOriginMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// High-level metadata about the segments comprising a video file post-segmentation.
type VideoFileSegmentsMetadata struct {
	Rid                  rids.VideoFileRid `json:"rid"`
	NumFrames            int               `json:"numFrames"`
	NumSegments          int               `json:"numSegments"`
	ScaleFactor          float64           `json:"scaleFactor"`
	MinAbsoluteTimestamp api.Timestamp     `json:"minAbsoluteTimestamp"`
	MaxAbsoluteTimestamp api.Timestamp     `json:"maxAbsoluteTimestamp"`
	MediaDurationSeconds float64           `json:"mediaDurationSeconds"`
	MediaFrameRate       float64           `json:"mediaFrameRate"`
}

func (o VideoFileSegmentsMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VideoFileSegmentsMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type VideoOriginMetadata struct {
	// Deprecated: deprecated in favor of per-file VideoFileOriginMetadata. Will be removed after April 15th.
	VideoSources []api.Handle `json:"videoSources"`
	// Deprecated: deprecated in favor of per-file VideoFileOriginMetadata. Will be removed after April 15th.
	TimestampManifest VideoTimestampManifest `json:"timestampManifest"`
}

func (o VideoOriginMetadata) MarshalJSON() ([]byte, error) {
	if o.VideoSources == nil {
		o.VideoSources = make([]api.Handle, 0)
	}
	type _tmpVideoOriginMetadata VideoOriginMetadata
	return safejson.Marshal(_tmpVideoOriginMetadata(o))
}

func (o *VideoOriginMetadata) UnmarshalJSON(data []byte) error {
	type _tmpVideoOriginMetadata VideoOriginMetadata
	var rawVideoOriginMetadata _tmpVideoOriginMetadata
	if err := safejson.Unmarshal(data, &rawVideoOriginMetadata); err != nil {
		return err
	}
	if rawVideoOriginMetadata.VideoSources == nil {
		rawVideoOriginMetadata.VideoSources = make([]api.Handle, 0)
	}
	*o = VideoOriginMetadata(rawVideoOriginMetadata)
	return nil
}

func (o VideoOriginMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VideoOriginMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
