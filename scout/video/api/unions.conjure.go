// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/io/nominal/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type DetailedIngestStatus struct {
	typ        string
	success    *SuccessIngestStatus
	error      *ErrorIngestStatus
	inProgress *float64
}

type detailedIngestStatusDeserializer struct {
	Type       string               `json:"type"`
	Success    *SuccessIngestStatus `json:"success"`
	Error      *ErrorIngestStatus   `json:"error"`
	InProgress *float64             `json:"inProgress"`
}

func (u *detailedIngestStatusDeserializer) toStruct() DetailedIngestStatus {
	return DetailedIngestStatus{typ: u.Type, success: u.Success, error: u.Error, inProgress: u.InProgress}
}

func (u *DetailedIngestStatus) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "success":
		if u.success == nil {
			return nil, fmt.Errorf("field \"success\" is required")
		}
		return struct {
			Type    string              `json:"type"`
			Success SuccessIngestStatus `json:"success"`
		}{Type: "success", Success: *u.success}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string            `json:"type"`
			Error ErrorIngestStatus `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	case "inProgress":
		if u.inProgress == nil {
			return nil, fmt.Errorf("field \"inProgress\" is required")
		}
		return struct {
			Type       string  `json:"type"`
			InProgress float64 `json:"inProgress"`
		}{Type: "inProgress", InProgress: *u.inProgress}, nil
	}
}

func (u DetailedIngestStatus) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DetailedIngestStatus) UnmarshalJSON(data []byte) error {
	var deser detailedIngestStatusDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
	}
	return nil
}

func (u DetailedIngestStatus) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DetailedIngestStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DetailedIngestStatus) AcceptFuncs(successFunc func(SuccessIngestStatus) error, errorFunc func(ErrorIngestStatus) error, inProgressFunc func(float64) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return inProgressFunc(*u.inProgress)
	}
}

func (u *DetailedIngestStatus) SuccessNoopSuccess(SuccessIngestStatus) error {
	return nil
}

func (u *DetailedIngestStatus) ErrorNoopSuccess(ErrorIngestStatus) error {
	return nil
}

func (u *DetailedIngestStatus) InProgressNoopSuccess(float64) error {
	return nil
}

func (u *DetailedIngestStatus) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DetailedIngestStatus) Accept(v DetailedIngestStatusVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgress(*u.inProgress)
	}
}

type DetailedIngestStatusVisitor interface {
	VisitSuccess(v SuccessIngestStatus) error
	VisitError(v ErrorIngestStatus) error
	VisitInProgress(v float64) error
	VisitUnknown(typeName string) error
}

func (u *DetailedIngestStatus) AcceptWithContext(ctx context.Context, v DetailedIngestStatusVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccessWithContext(ctx, *u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgressWithContext(ctx, *u.inProgress)
	}
}

type DetailedIngestStatusVisitorWithContext interface {
	VisitSuccessWithContext(ctx context.Context, v SuccessIngestStatus) error
	VisitErrorWithContext(ctx context.Context, v ErrorIngestStatus) error
	VisitInProgressWithContext(ctx context.Context, v float64) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDetailedIngestStatusFromSuccess(v SuccessIngestStatus) DetailedIngestStatus {
	return DetailedIngestStatus{typ: "success", success: &v}
}

func NewDetailedIngestStatusFromError(v ErrorIngestStatus) DetailedIngestStatus {
	return DetailedIngestStatus{typ: "error", error: &v}
}

func NewDetailedIngestStatusFromInProgress(v float64) DetailedIngestStatus {
	return DetailedIngestStatus{typ: "inProgress", inProgress: &v}
}

type ScaleParameter struct {
	typ             string
	trueFrameRate   *float64
	endingTimestamp *api.Timestamp
	scaleFactor     *float64
}

type scaleParameterDeserializer struct {
	Type            string         `json:"type"`
	TrueFrameRate   *float64       `json:"trueFrameRate"`
	EndingTimestamp *api.Timestamp `json:"endingTimestamp"`
	ScaleFactor     *float64       `json:"scaleFactor"`
}

func (u *scaleParameterDeserializer) toStruct() ScaleParameter {
	return ScaleParameter{typ: u.Type, trueFrameRate: u.TrueFrameRate, endingTimestamp: u.EndingTimestamp, scaleFactor: u.ScaleFactor}
}

func (u *ScaleParameter) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return nil, fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return struct {
			Type          string  `json:"type"`
			TrueFrameRate float64 `json:"trueFrameRate"`
		}{Type: "trueFrameRate", TrueFrameRate: *u.trueFrameRate}, nil
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return nil, fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return struct {
			Type            string        `json:"type"`
			EndingTimestamp api.Timestamp `json:"endingTimestamp"`
		}{Type: "endingTimestamp", EndingTimestamp: *u.endingTimestamp}, nil
	case "scaleFactor":
		if u.scaleFactor == nil {
			return nil, fmt.Errorf("field \"scaleFactor\" is required")
		}
		return struct {
			Type        string  `json:"type"`
			ScaleFactor float64 `json:"scaleFactor"`
		}{Type: "scaleFactor", ScaleFactor: *u.scaleFactor}, nil
	}
}

func (u ScaleParameter) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ScaleParameter) UnmarshalJSON(data []byte) error {
	var deser scaleParameterDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return fmt.Errorf("field \"trueFrameRate\" is required")
		}
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return fmt.Errorf("field \"endingTimestamp\" is required")
		}
	case "scaleFactor":
		if u.scaleFactor == nil {
			return fmt.Errorf("field \"scaleFactor\" is required")
		}
	}
	return nil
}

func (u ScaleParameter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ScaleParameter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ScaleParameter) AcceptFuncs(trueFrameRateFunc func(float64) error, endingTimestampFunc func(api.Timestamp) error, scaleFactorFunc func(float64) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return trueFrameRateFunc(*u.trueFrameRate)
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return endingTimestampFunc(*u.endingTimestamp)
	case "scaleFactor":
		if u.scaleFactor == nil {
			return fmt.Errorf("field \"scaleFactor\" is required")
		}
		return scaleFactorFunc(*u.scaleFactor)
	}
}

func (u *ScaleParameter) TrueFrameRateNoopSuccess(float64) error {
	return nil
}

func (u *ScaleParameter) EndingTimestampNoopSuccess(api.Timestamp) error {
	return nil
}

func (u *ScaleParameter) ScaleFactorNoopSuccess(float64) error {
	return nil
}

func (u *ScaleParameter) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ScaleParameter) Accept(v ScaleParameterVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return v.VisitTrueFrameRate(*u.trueFrameRate)
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return v.VisitEndingTimestamp(*u.endingTimestamp)
	case "scaleFactor":
		if u.scaleFactor == nil {
			return fmt.Errorf("field \"scaleFactor\" is required")
		}
		return v.VisitScaleFactor(*u.scaleFactor)
	}
}

type ScaleParameterVisitor interface {
	VisitTrueFrameRate(v float64) error
	VisitEndingTimestamp(v api.Timestamp) error
	VisitScaleFactor(v float64) error
	VisitUnknown(typeName string) error
}

func (u *ScaleParameter) AcceptWithContext(ctx context.Context, v ScaleParameterVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return v.VisitTrueFrameRateWithContext(ctx, *u.trueFrameRate)
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return v.VisitEndingTimestampWithContext(ctx, *u.endingTimestamp)
	case "scaleFactor":
		if u.scaleFactor == nil {
			return fmt.Errorf("field \"scaleFactor\" is required")
		}
		return v.VisitScaleFactorWithContext(ctx, *u.scaleFactor)
	}
}

type ScaleParameterVisitorWithContext interface {
	VisitTrueFrameRateWithContext(ctx context.Context, v float64) error
	VisitEndingTimestampWithContext(ctx context.Context, v api.Timestamp) error
	VisitScaleFactorWithContext(ctx context.Context, v float64) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewScaleParameterFromTrueFrameRate(v float64) ScaleParameter {
	return ScaleParameter{typ: "trueFrameRate", trueFrameRate: &v}
}

func NewScaleParameterFromEndingTimestamp(v api.Timestamp) ScaleParameter {
	return ScaleParameter{typ: "endingTimestamp", endingTimestamp: &v}
}

func NewScaleParameterFromScaleFactor(v float64) ScaleParameter {
	return ScaleParameter{typ: "scaleFactor", scaleFactor: &v}
}

type SearchVideosQuery struct {
	typ          string
	searchText   *string
	label        *api.Label
	property     *api.Property
	and          *[]SearchVideosQuery
	or           *[]SearchVideosQuery
	ingestStatus *api.IngestStatus
	workspace    *rids.WorkspaceRid
}

type searchVideosQueryDeserializer struct {
	Type         string               `json:"type"`
	SearchText   *string              `json:"searchText"`
	Label        *api.Label           `json:"label"`
	Property     *api.Property        `json:"property"`
	And          *[]SearchVideosQuery `json:"and"`
	Or           *[]SearchVideosQuery `json:"or"`
	IngestStatus *api.IngestStatus    `json:"ingestStatus"`
	Workspace    *rids.WorkspaceRid   `json:"workspace"`
}

func (u *searchVideosQueryDeserializer) toStruct() SearchVideosQuery {
	return SearchVideosQuery{typ: u.Type, searchText: u.SearchText, label: u.Label, property: u.Property, and: u.And, or: u.Or, ingestStatus: u.IngestStatus, workspace: u.Workspace}
}

func (u *SearchVideosQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "label":
		if u.label == nil {
			return nil, fmt.Errorf("field \"label\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Label api.Label `json:"label"`
		}{Type: "label", Label: *u.label}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Property api.Property `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string              `json:"type"`
			And  []SearchVideosQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string              `json:"type"`
			Or   []SearchVideosQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "ingestStatus":
		if u.ingestStatus == nil {
			return nil, fmt.Errorf("field \"ingestStatus\" is required")
		}
		return struct {
			Type         string           `json:"type"`
			IngestStatus api.IngestStatus `json:"ingestStatus"`
		}{Type: "ingestStatus", IngestStatus: *u.ingestStatus}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	}
}

func (u SearchVideosQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchVideosQuery) UnmarshalJSON(data []byte) error {
	var deser searchVideosQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "ingestStatus":
		if u.ingestStatus == nil {
			return fmt.Errorf("field \"ingestStatus\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	}
	return nil
}

func (u SearchVideosQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchVideosQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchVideosQuery) AcceptFuncs(searchTextFunc func(string) error, labelFunc func(api.Label) error, propertyFunc func(api.Property) error, andFunc func([]SearchVideosQuery) error, orFunc func([]SearchVideosQuery) error, ingestStatusFunc func(api.IngestStatus) error, workspaceFunc func(rids.WorkspaceRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "ingestStatus":
		if u.ingestStatus == nil {
			return fmt.Errorf("field \"ingestStatus\" is required")
		}
		return ingestStatusFunc(*u.ingestStatus)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchVideosQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *SearchVideosQuery) LabelNoopSuccess(api.Label) error {
	return nil
}

func (u *SearchVideosQuery) PropertyNoopSuccess(api.Property) error {
	return nil
}

func (u *SearchVideosQuery) AndNoopSuccess([]SearchVideosQuery) error {
	return nil
}

func (u *SearchVideosQuery) OrNoopSuccess([]SearchVideosQuery) error {
	return nil
}

func (u *SearchVideosQuery) IngestStatusNoopSuccess(api.IngestStatus) error {
	return nil
}

func (u *SearchVideosQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *SearchVideosQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchVideosQuery) Accept(v SearchVideosQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "ingestStatus":
		if u.ingestStatus == nil {
			return fmt.Errorf("field \"ingestStatus\" is required")
		}
		return v.VisitIngestStatus(*u.ingestStatus)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	}
}

type SearchVideosQueryVisitor interface {
	VisitSearchText(v string) error
	VisitLabel(v api.Label) error
	VisitProperty(v api.Property) error
	VisitAnd(v []SearchVideosQuery) error
	VisitOr(v []SearchVideosQuery) error
	VisitIngestStatus(v api.IngestStatus) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitUnknown(typeName string) error
}

func (u *SearchVideosQuery) AcceptWithContext(ctx context.Context, v SearchVideosQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabelWithContext(ctx, *u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "ingestStatus":
		if u.ingestStatus == nil {
			return fmt.Errorf("field \"ingestStatus\" is required")
		}
		return v.VisitIngestStatusWithContext(ctx, *u.ingestStatus)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	}
}

type SearchVideosQueryVisitorWithContext interface {
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitLabelWithContext(ctx context.Context, v api.Label) error
	VisitPropertyWithContext(ctx context.Context, v api.Property) error
	VisitAndWithContext(ctx context.Context, v []SearchVideosQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchVideosQuery) error
	VisitIngestStatusWithContext(ctx context.Context, v api.IngestStatus) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchVideosQueryFromSearchText(v string) SearchVideosQuery {
	return SearchVideosQuery{typ: "searchText", searchText: &v}
}

func NewSearchVideosQueryFromLabel(v api.Label) SearchVideosQuery {
	return SearchVideosQuery{typ: "label", label: &v}
}

func NewSearchVideosQueryFromProperty(v api.Property) SearchVideosQuery {
	return SearchVideosQuery{typ: "property", property: &v}
}

func NewSearchVideosQueryFromAnd(v []SearchVideosQuery) SearchVideosQuery {
	return SearchVideosQuery{typ: "and", and: &v}
}

func NewSearchVideosQueryFromOr(v []SearchVideosQuery) SearchVideosQuery {
	return SearchVideosQuery{typ: "or", or: &v}
}

func NewSearchVideosQueryFromIngestStatus(v api.IngestStatus) SearchVideosQuery {
	return SearchVideosQuery{typ: "ingestStatus", ingestStatus: &v}
}

func NewSearchVideosQueryFromWorkspace(v rids.WorkspaceRid) SearchVideosQuery {
	return SearchVideosQuery{typ: "workspace", workspace: &v}
}

/*
A video segment will either contain timestamps or timestamp mappings depending on whether it is intended to
be frame-mapped. Without a frame-timestamp mapping manifest file, a list of absolute timestamps will be
automatically assigned to each segment based on media timestamps.. Otherwise, media timestamps will be
extracted and mapped to those in the provided manifest.
*/
type SegmentTimestamps struct {
	typ               string
	timestampMappings *TimestampMappings
}

type segmentTimestampsDeserializer struct {
	Type              string             `json:"type"`
	TimestampMappings *TimestampMappings `json:"timestampMappings"`
}

func (u *segmentTimestampsDeserializer) toStruct() SegmentTimestamps {
	return SegmentTimestamps{typ: u.Type, timestampMappings: u.TimestampMappings}
}

func (u *SegmentTimestamps) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timestampMappings":
		if u.timestampMappings == nil {
			return nil, fmt.Errorf("field \"timestampMappings\" is required")
		}
		return struct {
			Type              string            `json:"type"`
			TimestampMappings TimestampMappings `json:"timestampMappings"`
		}{Type: "timestampMappings", TimestampMappings: *u.timestampMappings}, nil
	}
}

func (u SegmentTimestamps) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SegmentTimestamps) UnmarshalJSON(data []byte) error {
	var deser segmentTimestampsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timestampMappings":
		if u.timestampMappings == nil {
			return fmt.Errorf("field \"timestampMappings\" is required")
		}
	}
	return nil
}

func (u SegmentTimestamps) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SegmentTimestamps) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SegmentTimestamps) AcceptFuncs(timestampMappingsFunc func(TimestampMappings) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timestampMappings":
		if u.timestampMappings == nil {
			return fmt.Errorf("field \"timestampMappings\" is required")
		}
		return timestampMappingsFunc(*u.timestampMappings)
	}
}

func (u *SegmentTimestamps) TimestampMappingsNoopSuccess(TimestampMappings) error {
	return nil
}

func (u *SegmentTimestamps) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SegmentTimestamps) Accept(v SegmentTimestampsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timestampMappings":
		if u.timestampMappings == nil {
			return fmt.Errorf("field \"timestampMappings\" is required")
		}
		return v.VisitTimestampMappings(*u.timestampMappings)
	}
}

type SegmentTimestampsVisitor interface {
	VisitTimestampMappings(v TimestampMappings) error
	VisitUnknown(typeName string) error
}

func (u *SegmentTimestamps) AcceptWithContext(ctx context.Context, v SegmentTimestampsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timestampMappings":
		if u.timestampMappings == nil {
			return fmt.Errorf("field \"timestampMappings\" is required")
		}
		return v.VisitTimestampMappingsWithContext(ctx, *u.timestampMappings)
	}
}

type SegmentTimestampsVisitorWithContext interface {
	VisitTimestampMappingsWithContext(ctx context.Context, v TimestampMappings) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSegmentTimestampsFromTimestampMappings(v TimestampMappings) SegmentTimestamps {
	return SegmentTimestamps{typ: "timestampMappings", timestampMappings: &v}
}

type UpdateIngestStatus struct {
	typ        string
	success    *SuccessIngestStatus
	error      *ErrorIngestStatus
	inProgress *api.Empty
}

type updateIngestStatusDeserializer struct {
	Type       string               `json:"type"`
	Success    *SuccessIngestStatus `json:"success"`
	Error      *ErrorIngestStatus   `json:"error"`
	InProgress *api.Empty           `json:"inProgress"`
}

func (u *updateIngestStatusDeserializer) toStruct() UpdateIngestStatus {
	return UpdateIngestStatus{typ: u.Type, success: u.Success, error: u.Error, inProgress: u.InProgress}
}

func (u *UpdateIngestStatus) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "success":
		if u.success == nil {
			return nil, fmt.Errorf("field \"success\" is required")
		}
		return struct {
			Type    string              `json:"type"`
			Success SuccessIngestStatus `json:"success"`
		}{Type: "success", Success: *u.success}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string            `json:"type"`
			Error ErrorIngestStatus `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	case "inProgress":
		if u.inProgress == nil {
			return nil, fmt.Errorf("field \"inProgress\" is required")
		}
		return struct {
			Type       string    `json:"type"`
			InProgress api.Empty `json:"inProgress"`
		}{Type: "inProgress", InProgress: *u.inProgress}, nil
	}
}

func (u UpdateIngestStatus) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UpdateIngestStatus) UnmarshalJSON(data []byte) error {
	var deser updateIngestStatusDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
	}
	return nil
}

func (u UpdateIngestStatus) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UpdateIngestStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UpdateIngestStatus) AcceptFuncs(successFunc func(SuccessIngestStatus) error, errorFunc func(ErrorIngestStatus) error, inProgressFunc func(api.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return inProgressFunc(*u.inProgress)
	}
}

func (u *UpdateIngestStatus) SuccessNoopSuccess(SuccessIngestStatus) error {
	return nil
}

func (u *UpdateIngestStatus) ErrorNoopSuccess(ErrorIngestStatus) error {
	return nil
}

func (u *UpdateIngestStatus) InProgressNoopSuccess(api.Empty) error {
	return nil
}

func (u *UpdateIngestStatus) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UpdateIngestStatus) Accept(v UpdateIngestStatusVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgress(*u.inProgress)
	}
}

type UpdateIngestStatusVisitor interface {
	VisitSuccess(v SuccessIngestStatus) error
	VisitError(v ErrorIngestStatus) error
	VisitInProgress(v api.Empty) error
	VisitUnknown(typeName string) error
}

func (u *UpdateIngestStatus) AcceptWithContext(ctx context.Context, v UpdateIngestStatusVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccessWithContext(ctx, *u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgressWithContext(ctx, *u.inProgress)
	}
}

type UpdateIngestStatusVisitorWithContext interface {
	VisitSuccessWithContext(ctx context.Context, v SuccessIngestStatus) error
	VisitErrorWithContext(ctx context.Context, v ErrorIngestStatus) error
	VisitInProgressWithContext(ctx context.Context, v api.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUpdateIngestStatusFromSuccess(v SuccessIngestStatus) UpdateIngestStatus {
	return UpdateIngestStatus{typ: "success", success: &v}
}

func NewUpdateIngestStatusFromError(v ErrorIngestStatus) UpdateIngestStatus {
	return UpdateIngestStatus{typ: "error", error: &v}
}

func NewUpdateIngestStatusFromInProgress(v api.Empty) UpdateIngestStatus {
	return UpdateIngestStatus{typ: "inProgress", inProgress: &v}
}

type VideoFileIngestStatus struct {
	typ        string
	success    *SuccessIngestStatus
	error      *IngestError
	inProgress *api.Empty
}

type videoFileIngestStatusDeserializer struct {
	Type       string               `json:"type"`
	Success    *SuccessIngestStatus `json:"success"`
	Error      *IngestError         `json:"error"`
	InProgress *api.Empty           `json:"inProgress"`
}

func (u *videoFileIngestStatusDeserializer) toStruct() VideoFileIngestStatus {
	return VideoFileIngestStatus{typ: u.Type, success: u.Success, error: u.Error, inProgress: u.InProgress}
}

func (u *VideoFileIngestStatus) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "success":
		if u.success == nil {
			return nil, fmt.Errorf("field \"success\" is required")
		}
		return struct {
			Type    string              `json:"type"`
			Success SuccessIngestStatus `json:"success"`
		}{Type: "success", Success: *u.success}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Error IngestError `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	case "inProgress":
		if u.inProgress == nil {
			return nil, fmt.Errorf("field \"inProgress\" is required")
		}
		return struct {
			Type       string    `json:"type"`
			InProgress api.Empty `json:"inProgress"`
		}{Type: "inProgress", InProgress: *u.inProgress}, nil
	}
}

func (u VideoFileIngestStatus) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VideoFileIngestStatus) UnmarshalJSON(data []byte) error {
	var deser videoFileIngestStatusDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
	}
	return nil
}

func (u VideoFileIngestStatus) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VideoFileIngestStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VideoFileIngestStatus) AcceptFuncs(successFunc func(SuccessIngestStatus) error, errorFunc func(IngestError) error, inProgressFunc func(api.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return inProgressFunc(*u.inProgress)
	}
}

func (u *VideoFileIngestStatus) SuccessNoopSuccess(SuccessIngestStatus) error {
	return nil
}

func (u *VideoFileIngestStatus) ErrorNoopSuccess(IngestError) error {
	return nil
}

func (u *VideoFileIngestStatus) InProgressNoopSuccess(api.Empty) error {
	return nil
}

func (u *VideoFileIngestStatus) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VideoFileIngestStatus) Accept(v VideoFileIngestStatusVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgress(*u.inProgress)
	}
}

type VideoFileIngestStatusVisitor interface {
	VisitSuccess(v SuccessIngestStatus) error
	VisitError(v IngestError) error
	VisitInProgress(v api.Empty) error
	VisitUnknown(typeName string) error
}

func (u *VideoFileIngestStatus) AcceptWithContext(ctx context.Context, v VideoFileIngestStatusVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccessWithContext(ctx, *u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgressWithContext(ctx, *u.inProgress)
	}
}

type VideoFileIngestStatusVisitorWithContext interface {
	VisitSuccessWithContext(ctx context.Context, v SuccessIngestStatus) error
	VisitErrorWithContext(ctx context.Context, v IngestError) error
	VisitInProgressWithContext(ctx context.Context, v api.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVideoFileIngestStatusFromSuccess(v SuccessIngestStatus) VideoFileIngestStatus {
	return VideoFileIngestStatus{typ: "success", success: &v}
}

func NewVideoFileIngestStatusFromError(v IngestError) VideoFileIngestStatus {
	return VideoFileIngestStatus{typ: "error", error: &v}
}

func NewVideoFileIngestStatusFromInProgress(v api.Empty) VideoFileIngestStatus {
	return VideoFileIngestStatus{typ: "inProgress", inProgress: &v}
}

/*
A video fileâ€™s timestamp manifest specifies how to determine absolute timestamps for each frame. In an MCAP
file, this data is embedded within the source file. Alternatively, the manifest may be provided as an external
sidecar file. If no manifest is available, the timestamps are calculated by applying a starting offset to the
presentation timestamp of each frame.
*/
type VideoFileTimestampManifest struct {
	typ        string
	mcap       *McapTimestampManifest
	s3path     *api.S3Path
	noManifest *NoTimestampManifest
}

type videoFileTimestampManifestDeserializer struct {
	Type       string                 `json:"type"`
	Mcap       *McapTimestampManifest `json:"mcap"`
	S3path     *api.S3Path            `json:"s3path"`
	NoManifest *NoTimestampManifest   `json:"noManifest"`
}

func (u *videoFileTimestampManifestDeserializer) toStruct() VideoFileTimestampManifest {
	return VideoFileTimestampManifest{typ: u.Type, mcap: u.Mcap, s3path: u.S3path, noManifest: u.NoManifest}
}

func (u *VideoFileTimestampManifest) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "mcap":
		if u.mcap == nil {
			return nil, fmt.Errorf("field \"mcap\" is required")
		}
		return struct {
			Type string                `json:"type"`
			Mcap McapTimestampManifest `json:"mcap"`
		}{Type: "mcap", Mcap: *u.mcap}, nil
	case "s3path":
		if u.s3path == nil {
			return nil, fmt.Errorf("field \"s3path\" is required")
		}
		return struct {
			Type   string     `json:"type"`
			S3path api.S3Path `json:"s3path"`
		}{Type: "s3path", S3path: *u.s3path}, nil
	case "noManifest":
		if u.noManifest == nil {
			return nil, fmt.Errorf("field \"noManifest\" is required")
		}
		return struct {
			Type       string              `json:"type"`
			NoManifest NoTimestampManifest `json:"noManifest"`
		}{Type: "noManifest", NoManifest: *u.noManifest}, nil
	}
}

func (u VideoFileTimestampManifest) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VideoFileTimestampManifest) UnmarshalJSON(data []byte) error {
	var deser videoFileTimestampManifestDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "mcap":
		if u.mcap == nil {
			return fmt.Errorf("field \"mcap\" is required")
		}
	case "s3path":
		if u.s3path == nil {
			return fmt.Errorf("field \"s3path\" is required")
		}
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
	}
	return nil
}

func (u VideoFileTimestampManifest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VideoFileTimestampManifest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VideoFileTimestampManifest) AcceptFuncs(mcapFunc func(McapTimestampManifest) error, s3pathFunc func(api.S3Path) error, noManifestFunc func(NoTimestampManifest) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "mcap":
		if u.mcap == nil {
			return fmt.Errorf("field \"mcap\" is required")
		}
		return mcapFunc(*u.mcap)
	case "s3path":
		if u.s3path == nil {
			return fmt.Errorf("field \"s3path\" is required")
		}
		return s3pathFunc(*u.s3path)
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
		return noManifestFunc(*u.noManifest)
	}
}

func (u *VideoFileTimestampManifest) McapNoopSuccess(McapTimestampManifest) error {
	return nil
}

func (u *VideoFileTimestampManifest) S3pathNoopSuccess(api.S3Path) error {
	return nil
}

func (u *VideoFileTimestampManifest) NoManifestNoopSuccess(NoTimestampManifest) error {
	return nil
}

func (u *VideoFileTimestampManifest) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VideoFileTimestampManifest) Accept(v VideoFileTimestampManifestVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "mcap":
		if u.mcap == nil {
			return fmt.Errorf("field \"mcap\" is required")
		}
		return v.VisitMcap(*u.mcap)
	case "s3path":
		if u.s3path == nil {
			return fmt.Errorf("field \"s3path\" is required")
		}
		return v.VisitS3path(*u.s3path)
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
		return v.VisitNoManifest(*u.noManifest)
	}
}

type VideoFileTimestampManifestVisitor interface {
	VisitMcap(v McapTimestampManifest) error
	VisitS3path(v api.S3Path) error
	VisitNoManifest(v NoTimestampManifest) error
	VisitUnknown(typeName string) error
}

func (u *VideoFileTimestampManifest) AcceptWithContext(ctx context.Context, v VideoFileTimestampManifestVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "mcap":
		if u.mcap == nil {
			return fmt.Errorf("field \"mcap\" is required")
		}
		return v.VisitMcapWithContext(ctx, *u.mcap)
	case "s3path":
		if u.s3path == nil {
			return fmt.Errorf("field \"s3path\" is required")
		}
		return v.VisitS3pathWithContext(ctx, *u.s3path)
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
		return v.VisitNoManifestWithContext(ctx, *u.noManifest)
	}
}

type VideoFileTimestampManifestVisitorWithContext interface {
	VisitMcapWithContext(ctx context.Context, v McapTimestampManifest) error
	VisitS3pathWithContext(ctx context.Context, v api.S3Path) error
	VisitNoManifestWithContext(ctx context.Context, v NoTimestampManifest) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVideoFileTimestampManifestFromMcap(v McapTimestampManifest) VideoFileTimestampManifest {
	return VideoFileTimestampManifest{typ: "mcap", mcap: &v}
}

func NewVideoFileTimestampManifestFromS3path(v api.S3Path) VideoFileTimestampManifest {
	return VideoFileTimestampManifest{typ: "s3path", s3path: &v}
}

func NewVideoFileTimestampManifestFromNoManifest(v NoTimestampManifest) VideoFileTimestampManifest {
	return VideoFileTimestampManifest{typ: "noManifest", noManifest: &v}
}

type VideoIngestStatus struct {
	typ        string
	ready      *api.Empty
	inProgress *api.Empty
	error      *api.Empty
}

type videoIngestStatusDeserializer struct {
	Type       string     `json:"type"`
	Ready      *api.Empty `json:"ready"`
	InProgress *api.Empty `json:"inProgress"`
	Error      *api.Empty `json:"error"`
}

func (u *videoIngestStatusDeserializer) toStruct() VideoIngestStatus {
	return VideoIngestStatus{typ: u.Type, ready: u.Ready, inProgress: u.InProgress, error: u.Error}
}

func (u *VideoIngestStatus) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "ready":
		if u.ready == nil {
			return nil, fmt.Errorf("field \"ready\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Ready api.Empty `json:"ready"`
		}{Type: "ready", Ready: *u.ready}, nil
	case "inProgress":
		if u.inProgress == nil {
			return nil, fmt.Errorf("field \"inProgress\" is required")
		}
		return struct {
			Type       string    `json:"type"`
			InProgress api.Empty `json:"inProgress"`
		}{Type: "inProgress", InProgress: *u.inProgress}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Error api.Empty `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	}
}

func (u VideoIngestStatus) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VideoIngestStatus) UnmarshalJSON(data []byte) error {
	var deser videoIngestStatusDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "ready":
		if u.ready == nil {
			return fmt.Errorf("field \"ready\" is required")
		}
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	}
	return nil
}

func (u VideoIngestStatus) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VideoIngestStatus) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VideoIngestStatus) AcceptFuncs(readyFunc func(api.Empty) error, inProgressFunc func(api.Empty) error, errorFunc func(api.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ready":
		if u.ready == nil {
			return fmt.Errorf("field \"ready\" is required")
		}
		return readyFunc(*u.ready)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return inProgressFunc(*u.inProgress)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *VideoIngestStatus) ReadyNoopSuccess(api.Empty) error {
	return nil
}

func (u *VideoIngestStatus) InProgressNoopSuccess(api.Empty) error {
	return nil
}

func (u *VideoIngestStatus) ErrorNoopSuccess(api.Empty) error {
	return nil
}

func (u *VideoIngestStatus) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VideoIngestStatus) Accept(v VideoIngestStatusVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "ready":
		if u.ready == nil {
			return fmt.Errorf("field \"ready\" is required")
		}
		return v.VisitReady(*u.ready)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgress(*u.inProgress)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	}
}

type VideoIngestStatusVisitor interface {
	VisitReady(v api.Empty) error
	VisitInProgress(v api.Empty) error
	VisitError(v api.Empty) error
	VisitUnknown(typeName string) error
}

func (u *VideoIngestStatus) AcceptWithContext(ctx context.Context, v VideoIngestStatusVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "ready":
		if u.ready == nil {
			return fmt.Errorf("field \"ready\" is required")
		}
		return v.VisitReadyWithContext(ctx, *u.ready)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgressWithContext(ctx, *u.inProgress)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	}
}

type VideoIngestStatusVisitorWithContext interface {
	VisitReadyWithContext(ctx context.Context, v api.Empty) error
	VisitInProgressWithContext(ctx context.Context, v api.Empty) error
	VisitErrorWithContext(ctx context.Context, v api.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVideoIngestStatusFromReady(v api.Empty) VideoIngestStatus {
	return VideoIngestStatus{typ: "ready", ready: &v}
}

func NewVideoIngestStatusFromInProgress(v api.Empty) VideoIngestStatus {
	return VideoIngestStatus{typ: "inProgress", inProgress: &v}
}

func NewVideoIngestStatusFromError(v api.Empty) VideoIngestStatus {
	return VideoIngestStatus{typ: "error", error: &v}
}

type VideoTimestampManifest struct {
	typ        string
	mcap       *McapTimestampManifest
	s3paths    *[]api.S3Path
	noManifest *NoTimestampManifest
}

type videoTimestampManifestDeserializer struct {
	Type       string                 `json:"type"`
	Mcap       *McapTimestampManifest `json:"mcap"`
	S3paths    *[]api.S3Path          `json:"s3paths"`
	NoManifest *NoTimestampManifest   `json:"noManifest"`
}

func (u *videoTimestampManifestDeserializer) toStruct() VideoTimestampManifest {
	return VideoTimestampManifest{typ: u.Type, mcap: u.Mcap, s3paths: u.S3paths, noManifest: u.NoManifest}
}

func (u *VideoTimestampManifest) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "mcap":
		if u.mcap == nil {
			return nil, fmt.Errorf("field \"mcap\" is required")
		}
		return struct {
			Type string                `json:"type"`
			Mcap McapTimestampManifest `json:"mcap"`
		}{Type: "mcap", Mcap: *u.mcap}, nil
	case "s3paths":
		if u.s3paths == nil {
			return nil, fmt.Errorf("field \"s3paths\" is required")
		}
		return struct {
			Type    string       `json:"type"`
			S3paths []api.S3Path `json:"s3paths"`
		}{Type: "s3paths", S3paths: *u.s3paths}, nil
	case "noManifest":
		if u.noManifest == nil {
			return nil, fmt.Errorf("field \"noManifest\" is required")
		}
		return struct {
			Type       string              `json:"type"`
			NoManifest NoTimestampManifest `json:"noManifest"`
		}{Type: "noManifest", NoManifest: *u.noManifest}, nil
	}
}

func (u VideoTimestampManifest) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VideoTimestampManifest) UnmarshalJSON(data []byte) error {
	var deser videoTimestampManifestDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "mcap":
		if u.mcap == nil {
			return fmt.Errorf("field \"mcap\" is required")
		}
	case "s3paths":
		if u.s3paths == nil {
			return fmt.Errorf("field \"s3paths\" is required")
		}
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
	}
	return nil
}

func (u VideoTimestampManifest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VideoTimestampManifest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VideoTimestampManifest) AcceptFuncs(mcapFunc func(McapTimestampManifest) error, s3pathsFunc func([]api.S3Path) error, noManifestFunc func(NoTimestampManifest) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "mcap":
		if u.mcap == nil {
			return fmt.Errorf("field \"mcap\" is required")
		}
		return mcapFunc(*u.mcap)
	case "s3paths":
		if u.s3paths == nil {
			return fmt.Errorf("field \"s3paths\" is required")
		}
		return s3pathsFunc(*u.s3paths)
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
		return noManifestFunc(*u.noManifest)
	}
}

func (u *VideoTimestampManifest) McapNoopSuccess(McapTimestampManifest) error {
	return nil
}

func (u *VideoTimestampManifest) S3pathsNoopSuccess([]api.S3Path) error {
	return nil
}

func (u *VideoTimestampManifest) NoManifestNoopSuccess(NoTimestampManifest) error {
	return nil
}

func (u *VideoTimestampManifest) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VideoTimestampManifest) Accept(v VideoTimestampManifestVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "mcap":
		if u.mcap == nil {
			return fmt.Errorf("field \"mcap\" is required")
		}
		return v.VisitMcap(*u.mcap)
	case "s3paths":
		if u.s3paths == nil {
			return fmt.Errorf("field \"s3paths\" is required")
		}
		return v.VisitS3paths(*u.s3paths)
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
		return v.VisitNoManifest(*u.noManifest)
	}
}

type VideoTimestampManifestVisitor interface {
	VisitMcap(v McapTimestampManifest) error
	VisitS3paths(v []api.S3Path) error
	VisitNoManifest(v NoTimestampManifest) error
	VisitUnknown(typeName string) error
}

func (u *VideoTimestampManifest) AcceptWithContext(ctx context.Context, v VideoTimestampManifestVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "mcap":
		if u.mcap == nil {
			return fmt.Errorf("field \"mcap\" is required")
		}
		return v.VisitMcapWithContext(ctx, *u.mcap)
	case "s3paths":
		if u.s3paths == nil {
			return fmt.Errorf("field \"s3paths\" is required")
		}
		return v.VisitS3pathsWithContext(ctx, *u.s3paths)
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
		return v.VisitNoManifestWithContext(ctx, *u.noManifest)
	}
}

type VideoTimestampManifestVisitorWithContext interface {
	VisitMcapWithContext(ctx context.Context, v McapTimestampManifest) error
	VisitS3pathsWithContext(ctx context.Context, v []api.S3Path) error
	VisitNoManifestWithContext(ctx context.Context, v NoTimestampManifest) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVideoTimestampManifestFromMcap(v McapTimestampManifest) VideoTimestampManifest {
	return VideoTimestampManifest{typ: "mcap", mcap: &v}
}

func NewVideoTimestampManifestFromS3paths(v []api.S3Path) VideoTimestampManifest {
	return VideoTimestampManifest{typ: "s3paths", s3paths: &v}
}

func NewVideoTimestampManifestFromNoManifest(v NoTimestampManifest) VideoTimestampManifest {
	return VideoTimestampManifest{typ: "noManifest", noManifest: &v}
}
