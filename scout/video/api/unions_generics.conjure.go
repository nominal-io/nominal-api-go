// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/io/nominal/api"
)

type DetailedIngestStatusWithT[T any] DetailedIngestStatus

func (u *DetailedIngestStatusWithT[T]) Accept(ctx context.Context, v DetailedIngestStatusVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(ctx, *u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(ctx, *u.error)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgress(ctx, *u.inProgress)
	}
}

func (u *DetailedIngestStatusWithT[T]) AcceptFuncs(successFunc func(SuccessIngestStatus) (T, error), errorFunc func(ErrorIngestStatus) (T, error), inProgressFunc func(float64) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return inProgressFunc(*u.inProgress)
	}
}

func (u *DetailedIngestStatusWithT[T]) SuccessNoopSuccess(SuccessIngestStatus) (T, error) {
	var result T
	return result, nil
}

func (u *DetailedIngestStatusWithT[T]) ErrorNoopSuccess(ErrorIngestStatus) (T, error) {
	var result T
	return result, nil
}

func (u *DetailedIngestStatusWithT[T]) InProgressNoopSuccess(float64) (T, error) {
	var result T
	return result, nil
}

func (u *DetailedIngestStatusWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DetailedIngestStatusVisitorWithT[T any] interface {
	VisitSuccess(ctx context.Context, v SuccessIngestStatus) (T, error)
	VisitError(ctx context.Context, v ErrorIngestStatus) (T, error)
	VisitInProgress(ctx context.Context, v float64) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ScaleParameterWithT[T any] ScaleParameter

func (u *ScaleParameterWithT[T]) Accept(ctx context.Context, v ScaleParameterVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return result, fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return v.VisitTrueFrameRate(ctx, *u.trueFrameRate)
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return result, fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return v.VisitEndingTimestamp(ctx, *u.endingTimestamp)
	case "scaleFactor":
		if u.scaleFactor == nil {
			return result, fmt.Errorf("field \"scaleFactor\" is required")
		}
		return v.VisitScaleFactor(ctx, *u.scaleFactor)
	}
}

func (u *ScaleParameterWithT[T]) AcceptFuncs(trueFrameRateFunc func(float64) (T, error), endingTimestampFunc func(api.Timestamp) (T, error), scaleFactorFunc func(float64) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return result, fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return trueFrameRateFunc(*u.trueFrameRate)
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return result, fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return endingTimestampFunc(*u.endingTimestamp)
	case "scaleFactor":
		if u.scaleFactor == nil {
			return result, fmt.Errorf("field \"scaleFactor\" is required")
		}
		return scaleFactorFunc(*u.scaleFactor)
	}
}

func (u *ScaleParameterWithT[T]) TrueFrameRateNoopSuccess(float64) (T, error) {
	var result T
	return result, nil
}

func (u *ScaleParameterWithT[T]) EndingTimestampNoopSuccess(api.Timestamp) (T, error) {
	var result T
	return result, nil
}

func (u *ScaleParameterWithT[T]) ScaleFactorNoopSuccess(float64) (T, error) {
	var result T
	return result, nil
}

func (u *ScaleParameterWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ScaleParameterVisitorWithT[T any] interface {
	VisitTrueFrameRate(ctx context.Context, v float64) (T, error)
	VisitEndingTimestamp(ctx context.Context, v api.Timestamp) (T, error)
	VisitScaleFactor(ctx context.Context, v float64) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SearchVideosQueryWithT[T any] SearchVideosQuery

func (u *SearchVideosQueryWithT[T]) Accept(ctx context.Context, v SearchVideosQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(ctx, *u.searchText)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(ctx, *u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "ingestStatus":
		if u.ingestStatus == nil {
			return result, fmt.Errorf("field \"ingestStatus\" is required")
		}
		return v.VisitIngestStatus(ctx, *u.ingestStatus)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	}
}

func (u *SearchVideosQueryWithT[T]) AcceptFuncs(searchTextFunc func(string) (T, error), labelFunc func(api.Label) (T, error), propertyFunc func(api.Property) (T, error), andFunc func([]SearchVideosQuery) (T, error), orFunc func([]SearchVideosQuery) (T, error), ingestStatusFunc func(api.IngestStatus) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "ingestStatus":
		if u.ingestStatus == nil {
			return result, fmt.Errorf("field \"ingestStatus\" is required")
		}
		return ingestStatusFunc(*u.ingestStatus)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchVideosQueryWithT[T]) SearchTextNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchVideosQueryWithT[T]) LabelNoopSuccess(api.Label) (T, error) {
	var result T
	return result, nil
}

func (u *SearchVideosQueryWithT[T]) PropertyNoopSuccess(api.Property) (T, error) {
	var result T
	return result, nil
}

func (u *SearchVideosQueryWithT[T]) AndNoopSuccess([]SearchVideosQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchVideosQueryWithT[T]) OrNoopSuccess([]SearchVideosQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchVideosQueryWithT[T]) IngestStatusNoopSuccess(api.IngestStatus) (T, error) {
	var result T
	return result, nil
}

func (u *SearchVideosQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchVideosQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchVideosQueryVisitorWithT[T any] interface {
	VisitSearchText(ctx context.Context, v string) (T, error)
	VisitLabel(ctx context.Context, v api.Label) (T, error)
	VisitProperty(ctx context.Context, v api.Property) (T, error)
	VisitAnd(ctx context.Context, v []SearchVideosQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchVideosQuery) (T, error)
	VisitIngestStatus(ctx context.Context, v api.IngestStatus) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SegmentTimestampsWithT[T any] SegmentTimestamps

func (u *SegmentTimestampsWithT[T]) Accept(ctx context.Context, v SegmentTimestampsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "timestampMappings":
		if u.timestampMappings == nil {
			return result, fmt.Errorf("field \"timestampMappings\" is required")
		}
		return v.VisitTimestampMappings(ctx, *u.timestampMappings)
	}
}

func (u *SegmentTimestampsWithT[T]) AcceptFuncs(timestampMappingsFunc func(TimestampMappings) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timestampMappings":
		if u.timestampMappings == nil {
			return result, fmt.Errorf("field \"timestampMappings\" is required")
		}
		return timestampMappingsFunc(*u.timestampMappings)
	}
}

func (u *SegmentTimestampsWithT[T]) TimestampMappingsNoopSuccess(TimestampMappings) (T, error) {
	var result T
	return result, nil
}

func (u *SegmentTimestampsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SegmentTimestampsVisitorWithT[T any] interface {
	VisitTimestampMappings(ctx context.Context, v TimestampMappings) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UpdateIngestStatusWithT[T any] UpdateIngestStatus

func (u *UpdateIngestStatusWithT[T]) Accept(ctx context.Context, v UpdateIngestStatusVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(ctx, *u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(ctx, *u.error)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgress(ctx, *u.inProgress)
	}
}

func (u *UpdateIngestStatusWithT[T]) AcceptFuncs(successFunc func(SuccessIngestStatus) (T, error), errorFunc func(ErrorIngestStatus) (T, error), inProgressFunc func(api.Empty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return inProgressFunc(*u.inProgress)
	}
}

func (u *UpdateIngestStatusWithT[T]) SuccessNoopSuccess(SuccessIngestStatus) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateIngestStatusWithT[T]) ErrorNoopSuccess(ErrorIngestStatus) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateIngestStatusWithT[T]) InProgressNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateIngestStatusWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UpdateIngestStatusVisitorWithT[T any] interface {
	VisitSuccess(ctx context.Context, v SuccessIngestStatus) (T, error)
	VisitError(ctx context.Context, v ErrorIngestStatus) (T, error)
	VisitInProgress(ctx context.Context, v api.Empty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VideoFileIngestStatusWithT[T any] VideoFileIngestStatus

func (u *VideoFileIngestStatusWithT[T]) Accept(ctx context.Context, v VideoFileIngestStatusVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(ctx, *u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(ctx, *u.error)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgress(ctx, *u.inProgress)
	}
}

func (u *VideoFileIngestStatusWithT[T]) AcceptFuncs(successFunc func(SuccessIngestStatus) (T, error), errorFunc func(IngestError) (T, error), inProgressFunc func(api.Empty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return inProgressFunc(*u.inProgress)
	}
}

func (u *VideoFileIngestStatusWithT[T]) SuccessNoopSuccess(SuccessIngestStatus) (T, error) {
	var result T
	return result, nil
}

func (u *VideoFileIngestStatusWithT[T]) ErrorNoopSuccess(IngestError) (T, error) {
	var result T
	return result, nil
}

func (u *VideoFileIngestStatusWithT[T]) InProgressNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *VideoFileIngestStatusWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VideoFileIngestStatusVisitorWithT[T any] interface {
	VisitSuccess(ctx context.Context, v SuccessIngestStatus) (T, error)
	VisitError(ctx context.Context, v IngestError) (T, error)
	VisitInProgress(ctx context.Context, v api.Empty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VideoFileTimestampManifestWithT[T any] VideoFileTimestampManifest

func (u *VideoFileTimestampManifestWithT[T]) Accept(ctx context.Context, v VideoFileTimestampManifestVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "mcap":
		if u.mcap == nil {
			return result, fmt.Errorf("field \"mcap\" is required")
		}
		return v.VisitMcap(ctx, *u.mcap)
	case "s3path":
		if u.s3path == nil {
			return result, fmt.Errorf("field \"s3path\" is required")
		}
		return v.VisitS3path(ctx, *u.s3path)
	case "noManifest":
		if u.noManifest == nil {
			return result, fmt.Errorf("field \"noManifest\" is required")
		}
		return v.VisitNoManifest(ctx, *u.noManifest)
	}
}

func (u *VideoFileTimestampManifestWithT[T]) AcceptFuncs(mcapFunc func(McapTimestampManifest) (T, error), s3pathFunc func(api.S3Path) (T, error), noManifestFunc func(NoTimestampManifest) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "mcap":
		if u.mcap == nil {
			return result, fmt.Errorf("field \"mcap\" is required")
		}
		return mcapFunc(*u.mcap)
	case "s3path":
		if u.s3path == nil {
			return result, fmt.Errorf("field \"s3path\" is required")
		}
		return s3pathFunc(*u.s3path)
	case "noManifest":
		if u.noManifest == nil {
			return result, fmt.Errorf("field \"noManifest\" is required")
		}
		return noManifestFunc(*u.noManifest)
	}
}

func (u *VideoFileTimestampManifestWithT[T]) McapNoopSuccess(McapTimestampManifest) (T, error) {
	var result T
	return result, nil
}

func (u *VideoFileTimestampManifestWithT[T]) S3pathNoopSuccess(api.S3Path) (T, error) {
	var result T
	return result, nil
}

func (u *VideoFileTimestampManifestWithT[T]) NoManifestNoopSuccess(NoTimestampManifest) (T, error) {
	var result T
	return result, nil
}

func (u *VideoFileTimestampManifestWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VideoFileTimestampManifestVisitorWithT[T any] interface {
	VisitMcap(ctx context.Context, v McapTimestampManifest) (T, error)
	VisitS3path(ctx context.Context, v api.S3Path) (T, error)
	VisitNoManifest(ctx context.Context, v NoTimestampManifest) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VideoIngestStatusWithT[T any] VideoIngestStatus

func (u *VideoIngestStatusWithT[T]) Accept(ctx context.Context, v VideoIngestStatusVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "ready":
		if u.ready == nil {
			return result, fmt.Errorf("field \"ready\" is required")
		}
		return v.VisitReady(ctx, *u.ready)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgress(ctx, *u.inProgress)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(ctx, *u.error)
	}
}

func (u *VideoIngestStatusWithT[T]) AcceptFuncs(readyFunc func(api.Empty) (T, error), inProgressFunc func(api.Empty) (T, error), errorFunc func(api.Empty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ready":
		if u.ready == nil {
			return result, fmt.Errorf("field \"ready\" is required")
		}
		return readyFunc(*u.ready)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return inProgressFunc(*u.inProgress)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *VideoIngestStatusWithT[T]) ReadyNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *VideoIngestStatusWithT[T]) InProgressNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *VideoIngestStatusWithT[T]) ErrorNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *VideoIngestStatusWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VideoIngestStatusVisitorWithT[T any] interface {
	VisitReady(ctx context.Context, v api.Empty) (T, error)
	VisitInProgress(ctx context.Context, v api.Empty) (T, error)
	VisitError(ctx context.Context, v api.Empty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VideoTimestampManifestWithT[T any] VideoTimestampManifest

func (u *VideoTimestampManifestWithT[T]) Accept(ctx context.Context, v VideoTimestampManifestVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "mcap":
		if u.mcap == nil {
			return result, fmt.Errorf("field \"mcap\" is required")
		}
		return v.VisitMcap(ctx, *u.mcap)
	case "s3paths":
		if u.s3paths == nil {
			return result, fmt.Errorf("field \"s3paths\" is required")
		}
		return v.VisitS3paths(ctx, *u.s3paths)
	case "noManifest":
		if u.noManifest == nil {
			return result, fmt.Errorf("field \"noManifest\" is required")
		}
		return v.VisitNoManifest(ctx, *u.noManifest)
	}
}

func (u *VideoTimestampManifestWithT[T]) AcceptFuncs(mcapFunc func(McapTimestampManifest) (T, error), s3pathsFunc func([]api.S3Path) (T, error), noManifestFunc func(NoTimestampManifest) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "mcap":
		if u.mcap == nil {
			return result, fmt.Errorf("field \"mcap\" is required")
		}
		return mcapFunc(*u.mcap)
	case "s3paths":
		if u.s3paths == nil {
			return result, fmt.Errorf("field \"s3paths\" is required")
		}
		return s3pathsFunc(*u.s3paths)
	case "noManifest":
		if u.noManifest == nil {
			return result, fmt.Errorf("field \"noManifest\" is required")
		}
		return noManifestFunc(*u.noManifest)
	}
}

func (u *VideoTimestampManifestWithT[T]) McapNoopSuccess(McapTimestampManifest) (T, error) {
	var result T
	return result, nil
}

func (u *VideoTimestampManifestWithT[T]) S3pathsNoopSuccess([]api.S3Path) (T, error) {
	var result T
	return result, nil
}

func (u *VideoTimestampManifestWithT[T]) NoManifestNoopSuccess(NoTimestampManifest) (T, error) {
	var result T
	return result, nil
}

func (u *VideoTimestampManifestWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VideoTimestampManifestVisitorWithT[T any] interface {
	VisitMcap(ctx context.Context, v McapTimestampManifest) (T, error)
	VisitS3paths(ctx context.Context, v []api.S3Path) (T, error)
	VisitNoManifest(ctx context.Context, v NoTimestampManifest) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
