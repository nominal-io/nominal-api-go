// Code generated by conjure-go. DO NOT EDIT.

package video

import (
	"context"
	"fmt"
	"io"
	"net/url"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	api1 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/nominal-io/nominal-api-go/scout/video/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

// The video service manages individual video files and their metadata.
type VideoFileServiceClient interface {
	// Create and persist a video file entity with the given metadata
	Create(ctx context.Context, authHeader bearertoken.Token, requestArg api.CreateVideoFileRequest) (api.VideoFile, error)
	// Returns video file metadata associated with a video file RID.
	Get(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) (api.VideoFile, error)
	// Returns all video files and their metadata associated with the given RIDs
	BatchGet(ctx context.Context, authHeader bearertoken.Token, videoFileRidsArg []rids.VideoFileRid) ([]api.VideoFile, error)
	// Deprecated: Returns all video files and their metadata associated with the given video RID.
	ListFilesInVideo(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) ([]api.VideoFile, error)
	// Returns a paginated list of all video files and their metadata associated with the given video RID.
	ListFilesInVideoPaginated(ctx context.Context, authHeader bearertoken.Token, videoRidArg api.ListFilesInVideoRequest) (api.ListFilesInVideoResponse, error)
	// Updates the metadata for a video file associated with the given RID.
	Update(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid, requestArg api.UpdateVideoFileRequest) (api.VideoFile, error)
	/*
	   Permanently deletes a video file and all associated segments from the database.
	   This operation cannot be undone.
	*/
	Delete(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) error
	/*
	   Deprecated: Archives a video file, which excludes it from search and hides it from being visible
	   in the UI, but does not permanently delete it. Archived video files can be unarchived.
	   This endpoints is deprecated and will be removed on February 1st, 2026. Use delete endpoint instead for permanent removal.
	*/
	Archive(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) error
	// Deprecated: Unarchive a previously archived video file, exposing it to the UI and search. Unarchiving functionality will be removed on February 1st, 2026.
	Unarchive(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) error
	// Get the latest ingest status for a given video file by RID.
	GetIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) (api.GetIngestStatusResponse, error)
	// Get the latest ingest status for a set of given video files by RID.
	BatchGetIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoFileRidsArg []rids.VideoFileRid) (map[rids.VideoFileRid]api.VideoFileIngestStatus, error)
	// Update the latest ingest status for a given video file by RID.
	UpdateIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid, requestArg api.UpdateIngestStatusRequest) error
	/*
	   Returns the min and max absolute and media timestamps for each segment in a video file.
	   To be used during frame-timestamp mapping when playing back videos.
	*/
	GetSegmentSummaries(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) ([]api.SegmentSummary, error)
	/*
	   Generate an HLS playlist for a video file with the given RID to enable playback.
	   The HLS playlist will contain links to all of the video segments in the video in sequential order.
	*/
	GetPlaylist(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) (io.ReadCloser, error)
}

type videoFileServiceClient struct {
	client httpclient.Client
}

func NewVideoFileServiceClient(client httpclient.Client) VideoFileServiceClient {
	return &videoFileServiceClient{client: client}
}

func (c *videoFileServiceClient) Create(ctx context.Context, authHeader bearertoken.Token, requestArg api.CreateVideoFileRequest) (api.VideoFile, error) {
	var defaultReturnVal api.VideoFile
	var returnVal *api.VideoFile
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Create"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "create failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "create response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoFileServiceClient) Get(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) (api.VideoFile, error) {
	var defaultReturnVal api.VideoFile
	var returnVal *api.VideoFile
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Get"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files/%s", url.PathEscape(fmt.Sprint(videoFileRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "get failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "get response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoFileServiceClient) BatchGet(ctx context.Context, authHeader bearertoken.Token, videoFileRidsArg []rids.VideoFileRid) ([]api.VideoFile, error) {
	var returnVal []api.VideoFile
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGet"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files/batchGet"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(videoFileRidsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGet failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGet response cannot be nil")
	}
	return returnVal, nil
}

func (c *videoFileServiceClient) ListFilesInVideo(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) ([]api.VideoFile, error) {
	var returnVal []api.VideoFile
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ListFilesInVideo"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files/list-files-in-video"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(videoRidArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "listFilesInVideo failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "listFilesInVideo response cannot be nil")
	}
	return returnVal, nil
}

func (c *videoFileServiceClient) ListFilesInVideoPaginated(ctx context.Context, authHeader bearertoken.Token, videoRidArg api.ListFilesInVideoRequest) (api.ListFilesInVideoResponse, error) {
	var defaultReturnVal api.ListFilesInVideoResponse
	var returnVal *api.ListFilesInVideoResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ListFilesInVideoPaginated"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files/list-files-in-video-paginated"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(videoRidArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "listFilesInVideoPaginated failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "listFilesInVideoPaginated response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoFileServiceClient) Update(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid, requestArg api.UpdateVideoFileRequest) (api.VideoFile, error) {
	var defaultReturnVal api.VideoFile
	var returnVal *api.VideoFile
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Update"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files/%s", url.PathEscape(fmt.Sprint(videoFileRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "update failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "update response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoFileServiceClient) Delete(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Delete"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("DELETE"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files/%s", url.PathEscape(fmt.Sprint(videoFileRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "delete failed")
	}
	return nil
}

func (c *videoFileServiceClient) Archive(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Archive"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files/%s/archive", url.PathEscape(fmt.Sprint(videoFileRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "archive failed")
	}
	return nil
}

func (c *videoFileServiceClient) Unarchive(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Unarchive"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files/%s/unarchive", url.PathEscape(fmt.Sprint(videoFileRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "unarchive failed")
	}
	return nil
}

func (c *videoFileServiceClient) GetIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) (api.GetIngestStatusResponse, error) {
	var defaultReturnVal api.GetIngestStatusResponse
	var returnVal *api.GetIngestStatusResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetIngestStatus"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files/%s/ingest-status", url.PathEscape(fmt.Sprint(videoFileRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getIngestStatus failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getIngestStatus response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoFileServiceClient) BatchGetIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoFileRidsArg []rids.VideoFileRid) (map[rids.VideoFileRid]api.VideoFileIngestStatus, error) {
	var returnVal map[rids.VideoFileRid]api.VideoFileIngestStatus
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGetIngestStatus"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/videos/batch-get-ingest-status"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(videoFileRidsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGetIngestStatus failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGetIngestStatus response cannot be nil")
	}
	return returnVal, nil
}

func (c *videoFileServiceClient) UpdateIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid, requestArg api.UpdateIngestStatusRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateIngestStatus"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/videos/%s/ingest-status", url.PathEscape(fmt.Sprint(videoFileRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "updateIngestStatus failed")
	}
	return nil
}

func (c *videoFileServiceClient) GetSegmentSummaries(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) ([]api.SegmentSummary, error) {
	var returnVal []api.SegmentSummary
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetSegmentSummaries"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files/%s/segment-summaries", url.PathEscape(fmt.Sprint(videoFileRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getSegmentSummaries failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getSegmentSummaries response cannot be nil")
	}
	return returnVal, nil
}

func (c *videoFileServiceClient) GetPlaylist(ctx context.Context, authHeader bearertoken.Token, videoFileRidArg rids.VideoFileRid) (io.ReadCloser, error) {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetPlaylist"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video-files/v1/video-files/%s/playlist", url.PathEscape(fmt.Sprint(videoFileRidArg))))
	requestParams = append(requestParams, httpclient.WithRawResponseBody())
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	resp, err := c.client.Do(ctx, requestParams...)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getPlaylist failed")
	}
	return resp.Body, nil
}

// The video service manages individual video files and their metadata.
type VideoFileServiceClientWithAuth interface {
	// Create and persist a video file entity with the given metadata
	Create(ctx context.Context, requestArg api.CreateVideoFileRequest) (api.VideoFile, error)
	// Returns video file metadata associated with a video file RID.
	Get(ctx context.Context, videoFileRidArg rids.VideoFileRid) (api.VideoFile, error)
	// Returns all video files and their metadata associated with the given RIDs
	BatchGet(ctx context.Context, videoFileRidsArg []rids.VideoFileRid) ([]api.VideoFile, error)
	// Deprecated: Returns all video files and their metadata associated with the given video RID.
	ListFilesInVideo(ctx context.Context, videoRidArg rids.VideoRid) ([]api.VideoFile, error)
	// Returns a paginated list of all video files and their metadata associated with the given video RID.
	ListFilesInVideoPaginated(ctx context.Context, videoRidArg api.ListFilesInVideoRequest) (api.ListFilesInVideoResponse, error)
	// Updates the metadata for a video file associated with the given RID.
	Update(ctx context.Context, videoFileRidArg rids.VideoFileRid, requestArg api.UpdateVideoFileRequest) (api.VideoFile, error)
	/*
	   Permanently deletes a video file and all associated segments from the database.
	   This operation cannot be undone.
	*/
	Delete(ctx context.Context, videoFileRidArg rids.VideoFileRid) error
	/*
	   Deprecated: Archives a video file, which excludes it from search and hides it from being visible
	   in the UI, but does not permanently delete it. Archived video files can be unarchived.
	   This endpoints is deprecated and will be removed on February 1st, 2026. Use delete endpoint instead for permanent removal.
	*/
	Archive(ctx context.Context, videoFileRidArg rids.VideoFileRid) error
	// Deprecated: Unarchive a previously archived video file, exposing it to the UI and search. Unarchiving functionality will be removed on February 1st, 2026.
	Unarchive(ctx context.Context, videoFileRidArg rids.VideoFileRid) error
	// Get the latest ingest status for a given video file by RID.
	GetIngestStatus(ctx context.Context, videoFileRidArg rids.VideoFileRid) (api.GetIngestStatusResponse, error)
	// Get the latest ingest status for a set of given video files by RID.
	BatchGetIngestStatus(ctx context.Context, videoFileRidsArg []rids.VideoFileRid) (map[rids.VideoFileRid]api.VideoFileIngestStatus, error)
	// Update the latest ingest status for a given video file by RID.
	UpdateIngestStatus(ctx context.Context, videoFileRidArg rids.VideoFileRid, requestArg api.UpdateIngestStatusRequest) error
	/*
	   Returns the min and max absolute and media timestamps for each segment in a video file.
	   To be used during frame-timestamp mapping when playing back videos.
	*/
	GetSegmentSummaries(ctx context.Context, videoFileRidArg rids.VideoFileRid) ([]api.SegmentSummary, error)
	/*
	   Generate an HLS playlist for a video file with the given RID to enable playback.
	   The HLS playlist will contain links to all of the video segments in the video in sequential order.
	*/
	GetPlaylist(ctx context.Context, videoFileRidArg rids.VideoFileRid) (io.ReadCloser, error)
}

func NewVideoFileServiceClientWithAuth(client VideoFileServiceClient, authHeader bearertoken.Token) VideoFileServiceClientWithAuth {
	return &videoFileServiceClientWithAuth{client: client, authHeader: authHeader}
}

type videoFileServiceClientWithAuth struct {
	client     VideoFileServiceClient
	authHeader bearertoken.Token
}

func (c *videoFileServiceClientWithAuth) Create(ctx context.Context, requestArg api.CreateVideoFileRequest) (api.VideoFile, error) {
	return c.client.Create(ctx, c.authHeader, requestArg)
}

func (c *videoFileServiceClientWithAuth) Get(ctx context.Context, videoFileRidArg rids.VideoFileRid) (api.VideoFile, error) {
	return c.client.Get(ctx, c.authHeader, videoFileRidArg)
}

func (c *videoFileServiceClientWithAuth) BatchGet(ctx context.Context, videoFileRidsArg []rids.VideoFileRid) ([]api.VideoFile, error) {
	return c.client.BatchGet(ctx, c.authHeader, videoFileRidsArg)
}

func (c *videoFileServiceClientWithAuth) ListFilesInVideo(ctx context.Context, videoRidArg rids.VideoRid) ([]api.VideoFile, error) {
	return c.client.ListFilesInVideo(ctx, c.authHeader, videoRidArg)
}

func (c *videoFileServiceClientWithAuth) ListFilesInVideoPaginated(ctx context.Context, videoRidArg api.ListFilesInVideoRequest) (api.ListFilesInVideoResponse, error) {
	return c.client.ListFilesInVideoPaginated(ctx, c.authHeader, videoRidArg)
}

func (c *videoFileServiceClientWithAuth) Update(ctx context.Context, videoFileRidArg rids.VideoFileRid, requestArg api.UpdateVideoFileRequest) (api.VideoFile, error) {
	return c.client.Update(ctx, c.authHeader, videoFileRidArg, requestArg)
}

func (c *videoFileServiceClientWithAuth) Delete(ctx context.Context, videoFileRidArg rids.VideoFileRid) error {
	return c.client.Delete(ctx, c.authHeader, videoFileRidArg)
}

func (c *videoFileServiceClientWithAuth) Archive(ctx context.Context, videoFileRidArg rids.VideoFileRid) error {
	return c.client.Archive(ctx, c.authHeader, videoFileRidArg)
}

func (c *videoFileServiceClientWithAuth) Unarchive(ctx context.Context, videoFileRidArg rids.VideoFileRid) error {
	return c.client.Unarchive(ctx, c.authHeader, videoFileRidArg)
}

func (c *videoFileServiceClientWithAuth) GetIngestStatus(ctx context.Context, videoFileRidArg rids.VideoFileRid) (api.GetIngestStatusResponse, error) {
	return c.client.GetIngestStatus(ctx, c.authHeader, videoFileRidArg)
}

func (c *videoFileServiceClientWithAuth) BatchGetIngestStatus(ctx context.Context, videoFileRidsArg []rids.VideoFileRid) (map[rids.VideoFileRid]api.VideoFileIngestStatus, error) {
	return c.client.BatchGetIngestStatus(ctx, c.authHeader, videoFileRidsArg)
}

func (c *videoFileServiceClientWithAuth) UpdateIngestStatus(ctx context.Context, videoFileRidArg rids.VideoFileRid, requestArg api.UpdateIngestStatusRequest) error {
	return c.client.UpdateIngestStatus(ctx, c.authHeader, videoFileRidArg, requestArg)
}

func (c *videoFileServiceClientWithAuth) GetSegmentSummaries(ctx context.Context, videoFileRidArg rids.VideoFileRid) ([]api.SegmentSummary, error) {
	return c.client.GetSegmentSummaries(ctx, c.authHeader, videoFileRidArg)
}

func (c *videoFileServiceClientWithAuth) GetPlaylist(ctx context.Context, videoFileRidArg rids.VideoFileRid) (io.ReadCloser, error) {
	return c.client.GetPlaylist(ctx, c.authHeader, videoFileRidArg)
}

func NewVideoFileServiceClientWithTokenProvider(client VideoFileServiceClient, tokenProvider httpclient.TokenProvider) VideoFileServiceClientWithAuth {
	return &videoFileServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type videoFileServiceClientWithTokenProvider struct {
	client        VideoFileServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *videoFileServiceClientWithTokenProvider) Create(ctx context.Context, requestArg api.CreateVideoFileRequest) (api.VideoFile, error) {
	var defaultReturnVal api.VideoFile
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Create(ctx, bearertoken.Token(token), requestArg)
}

func (c *videoFileServiceClientWithTokenProvider) Get(ctx context.Context, videoFileRidArg rids.VideoFileRid) (api.VideoFile, error) {
	var defaultReturnVal api.VideoFile
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Get(ctx, bearertoken.Token(token), videoFileRidArg)
}

func (c *videoFileServiceClientWithTokenProvider) BatchGet(ctx context.Context, videoFileRidsArg []rids.VideoFileRid) ([]api.VideoFile, error) {
	var defaultReturnVal []api.VideoFile
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGet(ctx, bearertoken.Token(token), videoFileRidsArg)
}

func (c *videoFileServiceClientWithTokenProvider) ListFilesInVideo(ctx context.Context, videoRidArg rids.VideoRid) ([]api.VideoFile, error) {
	var defaultReturnVal []api.VideoFile
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ListFilesInVideo(ctx, bearertoken.Token(token), videoRidArg)
}

func (c *videoFileServiceClientWithTokenProvider) ListFilesInVideoPaginated(ctx context.Context, videoRidArg api.ListFilesInVideoRequest) (api.ListFilesInVideoResponse, error) {
	var defaultReturnVal api.ListFilesInVideoResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ListFilesInVideoPaginated(ctx, bearertoken.Token(token), videoRidArg)
}

func (c *videoFileServiceClientWithTokenProvider) Update(ctx context.Context, videoFileRidArg rids.VideoFileRid, requestArg api.UpdateVideoFileRequest) (api.VideoFile, error) {
	var defaultReturnVal api.VideoFile
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Update(ctx, bearertoken.Token(token), videoFileRidArg, requestArg)
}

func (c *videoFileServiceClientWithTokenProvider) Delete(ctx context.Context, videoFileRidArg rids.VideoFileRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Delete(ctx, bearertoken.Token(token), videoFileRidArg)
}

func (c *videoFileServiceClientWithTokenProvider) Archive(ctx context.Context, videoFileRidArg rids.VideoFileRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Archive(ctx, bearertoken.Token(token), videoFileRidArg)
}

func (c *videoFileServiceClientWithTokenProvider) Unarchive(ctx context.Context, videoFileRidArg rids.VideoFileRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Unarchive(ctx, bearertoken.Token(token), videoFileRidArg)
}

func (c *videoFileServiceClientWithTokenProvider) GetIngestStatus(ctx context.Context, videoFileRidArg rids.VideoFileRid) (api.GetIngestStatusResponse, error) {
	var defaultReturnVal api.GetIngestStatusResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetIngestStatus(ctx, bearertoken.Token(token), videoFileRidArg)
}

func (c *videoFileServiceClientWithTokenProvider) BatchGetIngestStatus(ctx context.Context, videoFileRidsArg []rids.VideoFileRid) (map[rids.VideoFileRid]api.VideoFileIngestStatus, error) {
	var defaultReturnVal map[rids.VideoFileRid]api.VideoFileIngestStatus
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGetIngestStatus(ctx, bearertoken.Token(token), videoFileRidsArg)
}

func (c *videoFileServiceClientWithTokenProvider) UpdateIngestStatus(ctx context.Context, videoFileRidArg rids.VideoFileRid, requestArg api.UpdateIngestStatusRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.UpdateIngestStatus(ctx, bearertoken.Token(token), videoFileRidArg, requestArg)
}

func (c *videoFileServiceClientWithTokenProvider) GetSegmentSummaries(ctx context.Context, videoFileRidArg rids.VideoFileRid) ([]api.SegmentSummary, error) {
	var defaultReturnVal []api.SegmentSummary
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetSegmentSummaries(ctx, bearertoken.Token(token), videoFileRidArg)
}

func (c *videoFileServiceClientWithTokenProvider) GetPlaylist(ctx context.Context, videoFileRidArg rids.VideoFileRid) (io.ReadCloser, error) {
	var defaultReturnVal io.ReadCloser
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetPlaylist(ctx, bearertoken.Token(token), videoFileRidArg)
}

/*
Upon ingestion, every video is split into smaller segments. The Video Segment Service manages operations on videos
at the segment-level.
*/
type VideoSegmentServiceClient interface {
	// Deprecated: Replaced by createVideoFileSegments. Will be removed after April 15th.
	CreateSegments(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.CreateSegmentsRequest) error
	CreateVideoFileSegments(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, videoFileRidArg rids.VideoFileRid, requestArg api.CreateSegmentsRequest) (api.CreateSegmentsResponse, error)
	// Creates segments for a video stream. Similar to createVideoFileSegments but for streaming video.
	CreateVideoStreamSegments(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, streamUuidArg uuid.UUID, requestArg api.CreateSegmentsRequest) (api.CreateSegmentsResponse, error)
	// Creates segments for a dataset file video. Used for channel-based video ingestion.
	CreateDatasetFileSegments(ctx context.Context, authHeader bearertoken.Token, requestArg api.CreateDatasetFileSegmentsRequest) (api.CreateSegmentsResponse, error)
	// Returns metadata for the segment within a video containing the requested absolute timestamp.
	GetSegmentByTimestamp(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.GetSegmentByTimestampRequest) (*api.Segment, error)
}

type videoSegmentServiceClient struct {
	client httpclient.Client
}

func NewVideoSegmentServiceClient(client httpclient.Client) VideoSegmentServiceClient {
	return &videoSegmentServiceClient{client: client}
}

func (c *videoSegmentServiceClient) CreateSegments(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.CreateSegmentsRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateSegments"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/create-segments", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "createSegments failed")
	}
	return nil
}

func (c *videoSegmentServiceClient) CreateVideoFileSegments(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, videoFileRidArg rids.VideoFileRid, requestArg api.CreateSegmentsRequest) (api.CreateSegmentsResponse, error) {
	var defaultReturnVal api.CreateSegmentsResponse
	var returnVal *api.CreateSegmentsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateVideoFileSegments"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/%s/create-segments", url.PathEscape(fmt.Sprint(videoRidArg)), url.PathEscape(fmt.Sprint(videoFileRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createVideoFileSegments failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createVideoFileSegments response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoSegmentServiceClient) CreateVideoStreamSegments(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, streamUuidArg uuid.UUID, requestArg api.CreateSegmentsRequest) (api.CreateSegmentsResponse, error) {
	var defaultReturnVal api.CreateSegmentsResponse
	var returnVal *api.CreateSegmentsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateVideoStreamSegments"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/streams/%s/create-segments", url.PathEscape(fmt.Sprint(videoRidArg)), url.PathEscape(fmt.Sprint(streamUuidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createVideoStreamSegments failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createVideoStreamSegments response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoSegmentServiceClient) CreateDatasetFileSegments(ctx context.Context, authHeader bearertoken.Token, requestArg api.CreateDatasetFileSegmentsRequest) (api.CreateSegmentsResponse, error) {
	var defaultReturnVal api.CreateSegmentsResponse
	var returnVal *api.CreateSegmentsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateDatasetFileSegments"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/dataset-files/create-segments"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createDatasetFileSegments failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createDatasetFileSegments response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoSegmentServiceClient) GetSegmentByTimestamp(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.GetSegmentByTimestampRequest) (*api.Segment, error) {
	var returnVal *api.Segment
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetSegmentByTimestamp"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/get-segment-by-timestamp", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getSegmentByTimestamp failed")
	}
	return returnVal, nil
}

/*
Upon ingestion, every video is split into smaller segments. The Video Segment Service manages operations on videos
at the segment-level.
*/
type VideoSegmentServiceClientWithAuth interface {
	// Deprecated: Replaced by createVideoFileSegments. Will be removed after April 15th.
	CreateSegments(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.CreateSegmentsRequest) error
	CreateVideoFileSegments(ctx context.Context, videoRidArg rids.VideoRid, videoFileRidArg rids.VideoFileRid, requestArg api.CreateSegmentsRequest) (api.CreateSegmentsResponse, error)
	// Creates segments for a video stream. Similar to createVideoFileSegments but for streaming video.
	CreateVideoStreamSegments(ctx context.Context, videoRidArg rids.VideoRid, streamUuidArg uuid.UUID, requestArg api.CreateSegmentsRequest) (api.CreateSegmentsResponse, error)
	// Creates segments for a dataset file video. Used for channel-based video ingestion.
	CreateDatasetFileSegments(ctx context.Context, requestArg api.CreateDatasetFileSegmentsRequest) (api.CreateSegmentsResponse, error)
	// Returns metadata for the segment within a video containing the requested absolute timestamp.
	GetSegmentByTimestamp(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetSegmentByTimestampRequest) (*api.Segment, error)
}

func NewVideoSegmentServiceClientWithAuth(client VideoSegmentServiceClient, authHeader bearertoken.Token) VideoSegmentServiceClientWithAuth {
	return &videoSegmentServiceClientWithAuth{client: client, authHeader: authHeader}
}

type videoSegmentServiceClientWithAuth struct {
	client     VideoSegmentServiceClient
	authHeader bearertoken.Token
}

func (c *videoSegmentServiceClientWithAuth) CreateSegments(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.CreateSegmentsRequest) error {
	return c.client.CreateSegments(ctx, c.authHeader, videoRidArg, requestArg)
}

func (c *videoSegmentServiceClientWithAuth) CreateVideoFileSegments(ctx context.Context, videoRidArg rids.VideoRid, videoFileRidArg rids.VideoFileRid, requestArg api.CreateSegmentsRequest) (api.CreateSegmentsResponse, error) {
	return c.client.CreateVideoFileSegments(ctx, c.authHeader, videoRidArg, videoFileRidArg, requestArg)
}

func (c *videoSegmentServiceClientWithAuth) CreateVideoStreamSegments(ctx context.Context, videoRidArg rids.VideoRid, streamUuidArg uuid.UUID, requestArg api.CreateSegmentsRequest) (api.CreateSegmentsResponse, error) {
	return c.client.CreateVideoStreamSegments(ctx, c.authHeader, videoRidArg, streamUuidArg, requestArg)
}

func (c *videoSegmentServiceClientWithAuth) CreateDatasetFileSegments(ctx context.Context, requestArg api.CreateDatasetFileSegmentsRequest) (api.CreateSegmentsResponse, error) {
	return c.client.CreateDatasetFileSegments(ctx, c.authHeader, requestArg)
}

func (c *videoSegmentServiceClientWithAuth) GetSegmentByTimestamp(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetSegmentByTimestampRequest) (*api.Segment, error) {
	return c.client.GetSegmentByTimestamp(ctx, c.authHeader, videoRidArg, requestArg)
}

func NewVideoSegmentServiceClientWithTokenProvider(client VideoSegmentServiceClient, tokenProvider httpclient.TokenProvider) VideoSegmentServiceClientWithAuth {
	return &videoSegmentServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type videoSegmentServiceClientWithTokenProvider struct {
	client        VideoSegmentServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *videoSegmentServiceClientWithTokenProvider) CreateSegments(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.CreateSegmentsRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.CreateSegments(ctx, bearertoken.Token(token), videoRidArg, requestArg)
}

func (c *videoSegmentServiceClientWithTokenProvider) CreateVideoFileSegments(ctx context.Context, videoRidArg rids.VideoRid, videoFileRidArg rids.VideoFileRid, requestArg api.CreateSegmentsRequest) (api.CreateSegmentsResponse, error) {
	var defaultReturnVal api.CreateSegmentsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateVideoFileSegments(ctx, bearertoken.Token(token), videoRidArg, videoFileRidArg, requestArg)
}

func (c *videoSegmentServiceClientWithTokenProvider) CreateVideoStreamSegments(ctx context.Context, videoRidArg rids.VideoRid, streamUuidArg uuid.UUID, requestArg api.CreateSegmentsRequest) (api.CreateSegmentsResponse, error) {
	var defaultReturnVal api.CreateSegmentsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateVideoStreamSegments(ctx, bearertoken.Token(token), videoRidArg, streamUuidArg, requestArg)
}

func (c *videoSegmentServiceClientWithTokenProvider) CreateDatasetFileSegments(ctx context.Context, requestArg api.CreateDatasetFileSegmentsRequest) (api.CreateSegmentsResponse, error) {
	var defaultReturnVal api.CreateSegmentsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateDatasetFileSegments(ctx, bearertoken.Token(token), requestArg)
}

func (c *videoSegmentServiceClientWithTokenProvider) GetSegmentByTimestamp(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetSegmentByTimestampRequest) (*api.Segment, error) {
	var defaultReturnVal *api.Segment
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetSegmentByTimestamp(ctx, bearertoken.Token(token), videoRidArg, requestArg)
}

// The video service manages videos and video metadata.
type VideoServiceClient interface {
	// Returns video metadata associated with a video rid.
	Get(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) (api.Video, error)
	// Returns video metadata about each video given a set of video rids.
	BatchGet(ctx context.Context, authHeader bearertoken.Token, requestArg api.GetVideosRequest) (api.GetVideosResponse, error)
	// Returns metadata about videos that match a given query.
	Search(ctx context.Context, authHeader bearertoken.Token, requestArg api.SearchVideosRequest) (api.SearchVideosResponse, error)
	// Creates and persists a video entity with the given metadata.
	Create(ctx context.Context, authHeader bearertoken.Token, requestArg api.CreateVideoRequest) (api.Video, error)
	// Updates the metadata for a video associated with the given video rid.
	UpdateMetadata(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.UpdateVideoMetadataRequest) (api.Video, error)
	// Deprecated: Replaced by per-file updateIngestStatus. Will be removed after April 15th.
	UpdateIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.UpdateIngestStatus) error
	GetIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) (api.DetailedIngestStatus, error)
	BatchGetIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoRidsArg []rids.VideoRid) (map[rids.VideoRid]api.DetailedIngestStatus, error)
	GetEnrichedIngestStatus(ctx context.Context, authHeader bearertoken.Token, requestArg api.GetEnrichedVideoIngestStatusRequest) (*api.EnrichedVideoIngestStatus, error)
	/*
	   Archives a video, which excludes it from search and hides it from being publicly visible, but does not
	   permanently delete it. Archived videos can be unarchived.
	*/
	Archive(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) error
	// Unarchives a previously archived video.
	Unarchive(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) error
	/*
	   Generates an HLS playlist for a video within optional time bounds.
	   Uses GET with query parameters for HLS.js compatibility.
	   The HLS playlist will contain links to all of the segments in the video that overlap with the given bounds,
	   or all segments if no bounds are provided.

	   Note: The start and end parameters must either both be provided or both be omitted.
	   Providing only one will result in a MissingTimestampBoundPair error.
	*/
	GetPlaylist(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, startArg *string, endArg *string) (io.ReadCloser, error)
	/*
	   Returns the min and max absolute and media timestamps for each segment in a video. To be used during
	   frame-timestamp mapping.

	   Deprecated: Replaced by getSegmentSummariesInBounds. Will be removed after April 15th.
	*/
	GetSegmentSummaries(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) ([]api.SegmentSummary, error)
	/*
	   Generates an HLS playlist for a video with the given video rid to enable playback within an optional set of
	   bounds. The HLS playlist will contain links to all of the segments in the video that overlap with the given
	   bounds.
	   playlist will be limited to the given bounds.

	   Deprecated: Use getPlaylist (GET) for HLS.js compatibility.
	*/
	GetPlaylistInBounds(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.GetPlaylistInBoundsRequest) (io.ReadCloser, error)
	/*
	   Generates an HLS playlist for a video channel series (identified by channel + tags) within an optional set of
	   bounds then generates a playlist for all matching video segments.

	   Deprecated: Use getPlaylistForChannel (GET) for HLS.js compatibility.
	*/
	GetPlaylistInBoundsForChannel(ctx context.Context, authHeader bearertoken.Token, requestArg api.GetPlaylistInBoundsForChannelRequest) (io.ReadCloser, error)
	/*
	   Generates an HLS playlist for a video channel series within time bounds.
	   Specify either dataSourceRid OR (assetRid + dataScopeName) to identify the channel source.

	   Note: Both start and end parameters are required and must be provided together.
	*/
	GetPlaylistForChannel(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg *rids.DataSourceRid, assetRidArg *api1.AssetRid, dataScopeNameArg *string, channelArg string, tagsArg *string, startArg string, endArg string) (io.ReadCloser, error)
	/*
	   Returns the min and max absolute and media timestamps for each segment in a video that overlap with an
	   optional set of bounds.
	*/
	GetSegmentSummariesInBounds(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.GetSegmentSummariesInBoundsRequest) ([]api.SegmentSummary, error)
	/*
	   Returns the min and max absolute and media timestamps for each segment matching a video channel series
	   (identified by channel + tags) within the specified bounds.
	*/
	GetSegmentSummariesInBoundsForChannel(ctx context.Context, authHeader bearertoken.Token, requestArg api.GetSegmentSummariesInBoundsForChannelRequest) ([]api.SegmentSummary, error)
	/*
	   Returns the min and max absolute timestamps from non-archived video files associated with a given video that
	   overlap with an optional set of bounds. The files on the edges of the bounds will be truncated to segments
	   that are inside or overlap with the bounds.
	*/
	GetFileSummaries(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.GetFileSummariesRequest) (api.GetFileSummariesResponse, error)
	/*
	   Generates a stream ID scoped to a video and returns a WHIP URL with a MediaMTX JWT and ICE servers.
	   Enforces write permission on the video.
	*/
	GenerateWhipStream(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) (api.GenerateWhipStreamResponse, error)
	/*
	   Returns WHEP URL, ICE servers, and token for playing back the active stream.
	   Returns empty if there is no active stream.
	   Enforces read permission on the video.
	*/
	GenerateWhepStream(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) (*api.GenerateWhepStreamResponse, error)
	/*
	   MediaMTX segment upload endpoint. Receives video segments from MediaMTX hooks.
	   Validates JWT and logs session. Future: create video segments from uploaded files.
	*/
	UploadSegmentFromMediaMtx(ctx context.Context, authHeader bearertoken.Token, streamPathArg string, filePathArg string, durationArg string, contentLengthArg safelong.SafeLong, bodyArg httpclient.RequestBody) error
}

type videoServiceClient struct {
	client httpclient.Client
}

func NewVideoServiceClient(client httpclient.Client) VideoServiceClient {
	return &videoServiceClient{client: client}
}

func (c *videoServiceClient) Get(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) (api.Video, error) {
	var defaultReturnVal api.Video
	var returnVal *api.Video
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Get"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "get failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "get response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoServiceClient) BatchGet(ctx context.Context, authHeader bearertoken.Token, requestArg api.GetVideosRequest) (api.GetVideosResponse, error) {
	var defaultReturnVal api.GetVideosResponse
	var returnVal *api.GetVideosResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGet"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/batchGet"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "batchGet failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "batchGet response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoServiceClient) Search(ctx context.Context, authHeader bearertoken.Token, requestArg api.SearchVideosRequest) (api.SearchVideosResponse, error) {
	var defaultReturnVal api.SearchVideosResponse
	var returnVal *api.SearchVideosResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Search"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/search"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "search failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "search response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoServiceClient) Create(ctx context.Context, authHeader bearertoken.Token, requestArg api.CreateVideoRequest) (api.Video, error) {
	var defaultReturnVal api.Video
	var returnVal *api.Video
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Create"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "create failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "create response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoServiceClient) UpdateMetadata(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.UpdateVideoMetadataRequest) (api.Video, error) {
	var defaultReturnVal api.Video
	var returnVal *api.Video
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateMetadata"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateMetadata failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateMetadata response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoServiceClient) UpdateIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.UpdateIngestStatus) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateIngestStatus"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/ingest-status", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "updateIngestStatus failed")
	}
	return nil
}

func (c *videoServiceClient) GetIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) (api.DetailedIngestStatus, error) {
	var defaultReturnVal api.DetailedIngestStatus
	var returnVal *api.DetailedIngestStatus
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetIngestStatus"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/ingest-status", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getIngestStatus failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getIngestStatus response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoServiceClient) BatchGetIngestStatus(ctx context.Context, authHeader bearertoken.Token, videoRidsArg []rids.VideoRid) (map[rids.VideoRid]api.DetailedIngestStatus, error) {
	var returnVal map[rids.VideoRid]api.DetailedIngestStatus
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGetIngestStatus"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/batch-get-ingest-status"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(videoRidsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGetIngestStatus failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGetIngestStatus response cannot be nil")
	}
	return returnVal, nil
}

func (c *videoServiceClient) GetEnrichedIngestStatus(ctx context.Context, authHeader bearertoken.Token, requestArg api.GetEnrichedVideoIngestStatusRequest) (*api.EnrichedVideoIngestStatus, error) {
	var returnVal *api.EnrichedVideoIngestStatus
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetEnrichedIngestStatus"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/enriched-ingest-status"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getEnrichedIngestStatus failed")
	}
	return returnVal, nil
}

func (c *videoServiceClient) Archive(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Archive"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/archive", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "archive failed")
	}
	return nil
}

func (c *videoServiceClient) Unarchive(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Unarchive"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/unarchive", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "unarchive failed")
	}
	return nil
}

func (c *videoServiceClient) GetPlaylist(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, startArg *string, endArg *string) (io.ReadCloser, error) {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetPlaylist"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/playlist", url.PathEscape(fmt.Sprint(videoRidArg))))
	queryParams := make(url.Values)
	if startArg != nil {
		queryParams.Set("start", fmt.Sprint(*startArg))
	}
	if endArg != nil {
		queryParams.Set("end", fmt.Sprint(*endArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithRawResponseBody())
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	resp, err := c.client.Do(ctx, requestParams...)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getPlaylist failed")
	}
	return resp.Body, nil
}

func (c *videoServiceClient) GetSegmentSummaries(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) ([]api.SegmentSummary, error) {
	var returnVal []api.SegmentSummary
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetSegmentSummaries"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/segment-summaries", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getSegmentSummaries failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getSegmentSummaries response cannot be nil")
	}
	return returnVal, nil
}

func (c *videoServiceClient) GetPlaylistInBounds(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.GetPlaylistInBoundsRequest) (io.ReadCloser, error) {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetPlaylistInBounds"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/playlist-in-bounds", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRawResponseBody())
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	resp, err := c.client.Do(ctx, requestParams...)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getPlaylistInBounds failed")
	}
	return resp.Body, nil
}

func (c *videoServiceClient) GetPlaylistInBoundsForChannel(ctx context.Context, authHeader bearertoken.Token, requestArg api.GetPlaylistInBoundsForChannelRequest) (io.ReadCloser, error) {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetPlaylistInBoundsForChannel"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/channel/playlist-in-bounds"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRawResponseBody())
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	resp, err := c.client.Do(ctx, requestParams...)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getPlaylistInBoundsForChannel failed")
	}
	return resp.Body, nil
}

func (c *videoServiceClient) GetPlaylistForChannel(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg *rids.DataSourceRid, assetRidArg *api1.AssetRid, dataScopeNameArg *string, channelArg string, tagsArg *string, startArg string, endArg string) (io.ReadCloser, error) {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetPlaylistForChannel"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/channel/playlist"))
	queryParams := make(url.Values)
	if dataSourceRidArg != nil {
		queryParams.Set("dataSourceRid", fmt.Sprint(*dataSourceRidArg))
	}
	if assetRidArg != nil {
		queryParams.Set("assetRid", fmt.Sprint(*assetRidArg))
	}
	if dataScopeNameArg != nil {
		queryParams.Set("dataScopeName", fmt.Sprint(*dataScopeNameArg))
	}
	queryParams.Set("channel", fmt.Sprint(channelArg))
	if tagsArg != nil {
		queryParams.Set("tags", fmt.Sprint(*tagsArg))
	}
	queryParams.Set("start", fmt.Sprint(startArg))
	queryParams.Set("end", fmt.Sprint(endArg))
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithRawResponseBody())
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	resp, err := c.client.Do(ctx, requestParams...)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getPlaylistForChannel failed")
	}
	return resp.Body, nil
}

func (c *videoServiceClient) GetSegmentSummariesInBounds(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.GetSegmentSummariesInBoundsRequest) ([]api.SegmentSummary, error) {
	var returnVal []api.SegmentSummary
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetSegmentSummariesInBounds"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/segment-summaries-in-bounds", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getSegmentSummariesInBounds failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getSegmentSummariesInBounds response cannot be nil")
	}
	return returnVal, nil
}

func (c *videoServiceClient) GetSegmentSummariesInBoundsForChannel(ctx context.Context, authHeader bearertoken.Token, requestArg api.GetSegmentSummariesInBoundsForChannelRequest) ([]api.SegmentSummary, error) {
	var returnVal []api.SegmentSummary
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetSegmentSummariesInBoundsForChannel"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/channel/segment-summaries-in-bounds"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getSegmentSummariesInBoundsForChannel failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getSegmentSummariesInBoundsForChannel response cannot be nil")
	}
	return returnVal, nil
}

func (c *videoServiceClient) GetFileSummaries(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid, requestArg api.GetFileSummariesRequest) (api.GetFileSummariesResponse, error) {
	var defaultReturnVal api.GetFileSummariesResponse
	var returnVal *api.GetFileSummariesResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetFileSummaries"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/get-ranges-with-existing-segment-data", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getFileSummaries failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getFileSummaries response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoServiceClient) GenerateWhipStream(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) (api.GenerateWhipStreamResponse, error) {
	var defaultReturnVal api.GenerateWhipStreamResponse
	var returnVal *api.GenerateWhipStreamResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GenerateWhipStream"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/streaming/whip", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "generateWhipStream failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "generateWhipStream response cannot be nil")
	}
	return *returnVal, nil
}

func (c *videoServiceClient) GenerateWhepStream(ctx context.Context, authHeader bearertoken.Token, videoRidArg rids.VideoRid) (*api.GenerateWhepStreamResponse, error) {
	var returnVal *api.GenerateWhepStreamResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GenerateWhepStream"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/videos/%s/streaming/whep", url.PathEscape(fmt.Sprint(videoRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "generateWhepStream failed")
	}
	return returnVal, nil
}

func (c *videoServiceClient) UploadSegmentFromMediaMtx(ctx context.Context, authHeader bearertoken.Token, streamPathArg string, filePathArg string, durationArg string, contentLengthArg safelong.SafeLong, bodyArg httpclient.RequestBody) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UploadSegmentFromMediaMtx"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/video/v1/segment/upload"))
	requestParams = append(requestParams, httpclient.WithBinaryRequestBody(bodyArg))
	requestParams = append(requestParams, httpclient.WithHeader("Content-Length", fmt.Sprint(contentLengthArg)))
	queryParams := make(url.Values)
	queryParams.Set("streamPath", fmt.Sprint(streamPathArg))
	queryParams.Set("filePath", fmt.Sprint(filePathArg))
	queryParams.Set("duration", fmt.Sprint(durationArg))
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "uploadSegmentFromMediaMtx failed")
	}
	return nil
}

// The video service manages videos and video metadata.
type VideoServiceClientWithAuth interface {
	// Returns video metadata associated with a video rid.
	Get(ctx context.Context, videoRidArg rids.VideoRid) (api.Video, error)
	// Returns video metadata about each video given a set of video rids.
	BatchGet(ctx context.Context, requestArg api.GetVideosRequest) (api.GetVideosResponse, error)
	// Returns metadata about videos that match a given query.
	Search(ctx context.Context, requestArg api.SearchVideosRequest) (api.SearchVideosResponse, error)
	// Creates and persists a video entity with the given metadata.
	Create(ctx context.Context, requestArg api.CreateVideoRequest) (api.Video, error)
	// Updates the metadata for a video associated with the given video rid.
	UpdateMetadata(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.UpdateVideoMetadataRequest) (api.Video, error)
	// Deprecated: Replaced by per-file updateIngestStatus. Will be removed after April 15th.
	UpdateIngestStatus(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.UpdateIngestStatus) error
	GetIngestStatus(ctx context.Context, videoRidArg rids.VideoRid) (api.DetailedIngestStatus, error)
	BatchGetIngestStatus(ctx context.Context, videoRidsArg []rids.VideoRid) (map[rids.VideoRid]api.DetailedIngestStatus, error)
	GetEnrichedIngestStatus(ctx context.Context, requestArg api.GetEnrichedVideoIngestStatusRequest) (*api.EnrichedVideoIngestStatus, error)
	/*
	   Archives a video, which excludes it from search and hides it from being publicly visible, but does not
	   permanently delete it. Archived videos can be unarchived.
	*/
	Archive(ctx context.Context, videoRidArg rids.VideoRid) error
	// Unarchives a previously archived video.
	Unarchive(ctx context.Context, videoRidArg rids.VideoRid) error
	/*
	   Generates an HLS playlist for a video within optional time bounds.
	   Uses GET with query parameters for HLS.js compatibility.
	   The HLS playlist will contain links to all of the segments in the video that overlap with the given bounds,
	   or all segments if no bounds are provided.

	   Note: The start and end parameters must either both be provided or both be omitted.
	   Providing only one will result in a MissingTimestampBoundPair error.
	*/
	GetPlaylist(ctx context.Context, videoRidArg rids.VideoRid, startArg *string, endArg *string) (io.ReadCloser, error)
	/*
	   Returns the min and max absolute and media timestamps for each segment in a video. To be used during
	   frame-timestamp mapping.

	   Deprecated: Replaced by getSegmentSummariesInBounds. Will be removed after April 15th.
	*/
	GetSegmentSummaries(ctx context.Context, videoRidArg rids.VideoRid) ([]api.SegmentSummary, error)
	/*
	   Generates an HLS playlist for a video with the given video rid to enable playback within an optional set of
	   bounds. The HLS playlist will contain links to all of the segments in the video that overlap with the given
	   bounds.
	   playlist will be limited to the given bounds.

	   Deprecated: Use getPlaylist (GET) for HLS.js compatibility.
	*/
	GetPlaylistInBounds(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetPlaylistInBoundsRequest) (io.ReadCloser, error)
	/*
	   Generates an HLS playlist for a video channel series (identified by channel + tags) within an optional set of
	   bounds then generates a playlist for all matching video segments.

	   Deprecated: Use getPlaylistForChannel (GET) for HLS.js compatibility.
	*/
	GetPlaylistInBoundsForChannel(ctx context.Context, requestArg api.GetPlaylistInBoundsForChannelRequest) (io.ReadCloser, error)
	/*
	   Generates an HLS playlist for a video channel series within time bounds.
	   Specify either dataSourceRid OR (assetRid + dataScopeName) to identify the channel source.

	   Note: Both start and end parameters are required and must be provided together.
	*/
	GetPlaylistForChannel(ctx context.Context, dataSourceRidArg *rids.DataSourceRid, assetRidArg *api1.AssetRid, dataScopeNameArg *string, channelArg string, tagsArg *string, startArg string, endArg string) (io.ReadCloser, error)
	/*
	   Returns the min and max absolute and media timestamps for each segment in a video that overlap with an
	   optional set of bounds.
	*/
	GetSegmentSummariesInBounds(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetSegmentSummariesInBoundsRequest) ([]api.SegmentSummary, error)
	/*
	   Returns the min and max absolute and media timestamps for each segment matching a video channel series
	   (identified by channel + tags) within the specified bounds.
	*/
	GetSegmentSummariesInBoundsForChannel(ctx context.Context, requestArg api.GetSegmentSummariesInBoundsForChannelRequest) ([]api.SegmentSummary, error)
	/*
	   Returns the min and max absolute timestamps from non-archived video files associated with a given video that
	   overlap with an optional set of bounds. The files on the edges of the bounds will be truncated to segments
	   that are inside or overlap with the bounds.
	*/
	GetFileSummaries(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetFileSummariesRequest) (api.GetFileSummariesResponse, error)
	/*
	   Generates a stream ID scoped to a video and returns a WHIP URL with a MediaMTX JWT and ICE servers.
	   Enforces write permission on the video.
	*/
	GenerateWhipStream(ctx context.Context, videoRidArg rids.VideoRid) (api.GenerateWhipStreamResponse, error)
	/*
	   Returns WHEP URL, ICE servers, and token for playing back the active stream.
	   Returns empty if there is no active stream.
	   Enforces read permission on the video.
	*/
	GenerateWhepStream(ctx context.Context, videoRidArg rids.VideoRid) (*api.GenerateWhepStreamResponse, error)
	/*
	   MediaMTX segment upload endpoint. Receives video segments from MediaMTX hooks.
	   Validates JWT and logs session. Future: create video segments from uploaded files.
	*/
	UploadSegmentFromMediaMtx(ctx context.Context, streamPathArg string, filePathArg string, durationArg string, contentLengthArg safelong.SafeLong, bodyArg httpclient.RequestBody) error
}

func NewVideoServiceClientWithAuth(client VideoServiceClient, authHeader bearertoken.Token) VideoServiceClientWithAuth {
	return &videoServiceClientWithAuth{client: client, authHeader: authHeader}
}

type videoServiceClientWithAuth struct {
	client     VideoServiceClient
	authHeader bearertoken.Token
}

func (c *videoServiceClientWithAuth) Get(ctx context.Context, videoRidArg rids.VideoRid) (api.Video, error) {
	return c.client.Get(ctx, c.authHeader, videoRidArg)
}

func (c *videoServiceClientWithAuth) BatchGet(ctx context.Context, requestArg api.GetVideosRequest) (api.GetVideosResponse, error) {
	return c.client.BatchGet(ctx, c.authHeader, requestArg)
}

func (c *videoServiceClientWithAuth) Search(ctx context.Context, requestArg api.SearchVideosRequest) (api.SearchVideosResponse, error) {
	return c.client.Search(ctx, c.authHeader, requestArg)
}

func (c *videoServiceClientWithAuth) Create(ctx context.Context, requestArg api.CreateVideoRequest) (api.Video, error) {
	return c.client.Create(ctx, c.authHeader, requestArg)
}

func (c *videoServiceClientWithAuth) UpdateMetadata(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.UpdateVideoMetadataRequest) (api.Video, error) {
	return c.client.UpdateMetadata(ctx, c.authHeader, videoRidArg, requestArg)
}

func (c *videoServiceClientWithAuth) UpdateIngestStatus(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.UpdateIngestStatus) error {
	return c.client.UpdateIngestStatus(ctx, c.authHeader, videoRidArg, requestArg)
}

func (c *videoServiceClientWithAuth) GetIngestStatus(ctx context.Context, videoRidArg rids.VideoRid) (api.DetailedIngestStatus, error) {
	return c.client.GetIngestStatus(ctx, c.authHeader, videoRidArg)
}

func (c *videoServiceClientWithAuth) BatchGetIngestStatus(ctx context.Context, videoRidsArg []rids.VideoRid) (map[rids.VideoRid]api.DetailedIngestStatus, error) {
	return c.client.BatchGetIngestStatus(ctx, c.authHeader, videoRidsArg)
}

func (c *videoServiceClientWithAuth) GetEnrichedIngestStatus(ctx context.Context, requestArg api.GetEnrichedVideoIngestStatusRequest) (*api.EnrichedVideoIngestStatus, error) {
	return c.client.GetEnrichedIngestStatus(ctx, c.authHeader, requestArg)
}

func (c *videoServiceClientWithAuth) Archive(ctx context.Context, videoRidArg rids.VideoRid) error {
	return c.client.Archive(ctx, c.authHeader, videoRidArg)
}

func (c *videoServiceClientWithAuth) Unarchive(ctx context.Context, videoRidArg rids.VideoRid) error {
	return c.client.Unarchive(ctx, c.authHeader, videoRidArg)
}

func (c *videoServiceClientWithAuth) GetPlaylist(ctx context.Context, videoRidArg rids.VideoRid, startArg *string, endArg *string) (io.ReadCloser, error) {
	return c.client.GetPlaylist(ctx, c.authHeader, videoRidArg, startArg, endArg)
}

func (c *videoServiceClientWithAuth) GetSegmentSummaries(ctx context.Context, videoRidArg rids.VideoRid) ([]api.SegmentSummary, error) {
	return c.client.GetSegmentSummaries(ctx, c.authHeader, videoRidArg)
}

func (c *videoServiceClientWithAuth) GetPlaylistInBounds(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetPlaylistInBoundsRequest) (io.ReadCloser, error) {
	return c.client.GetPlaylistInBounds(ctx, c.authHeader, videoRidArg, requestArg)
}

func (c *videoServiceClientWithAuth) GetPlaylistInBoundsForChannel(ctx context.Context, requestArg api.GetPlaylistInBoundsForChannelRequest) (io.ReadCloser, error) {
	return c.client.GetPlaylistInBoundsForChannel(ctx, c.authHeader, requestArg)
}

func (c *videoServiceClientWithAuth) GetPlaylistForChannel(ctx context.Context, dataSourceRidArg *rids.DataSourceRid, assetRidArg *api1.AssetRid, dataScopeNameArg *string, channelArg string, tagsArg *string, startArg string, endArg string) (io.ReadCloser, error) {
	return c.client.GetPlaylistForChannel(ctx, c.authHeader, dataSourceRidArg, assetRidArg, dataScopeNameArg, channelArg, tagsArg, startArg, endArg)
}

func (c *videoServiceClientWithAuth) GetSegmentSummariesInBounds(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetSegmentSummariesInBoundsRequest) ([]api.SegmentSummary, error) {
	return c.client.GetSegmentSummariesInBounds(ctx, c.authHeader, videoRidArg, requestArg)
}

func (c *videoServiceClientWithAuth) GetSegmentSummariesInBoundsForChannel(ctx context.Context, requestArg api.GetSegmentSummariesInBoundsForChannelRequest) ([]api.SegmentSummary, error) {
	return c.client.GetSegmentSummariesInBoundsForChannel(ctx, c.authHeader, requestArg)
}

func (c *videoServiceClientWithAuth) GetFileSummaries(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetFileSummariesRequest) (api.GetFileSummariesResponse, error) {
	return c.client.GetFileSummaries(ctx, c.authHeader, videoRidArg, requestArg)
}

func (c *videoServiceClientWithAuth) GenerateWhipStream(ctx context.Context, videoRidArg rids.VideoRid) (api.GenerateWhipStreamResponse, error) {
	return c.client.GenerateWhipStream(ctx, c.authHeader, videoRidArg)
}

func (c *videoServiceClientWithAuth) GenerateWhepStream(ctx context.Context, videoRidArg rids.VideoRid) (*api.GenerateWhepStreamResponse, error) {
	return c.client.GenerateWhepStream(ctx, c.authHeader, videoRidArg)
}

func (c *videoServiceClientWithAuth) UploadSegmentFromMediaMtx(ctx context.Context, streamPathArg string, filePathArg string, durationArg string, contentLengthArg safelong.SafeLong, bodyArg httpclient.RequestBody) error {
	return c.client.UploadSegmentFromMediaMtx(ctx, c.authHeader, streamPathArg, filePathArg, durationArg, contentLengthArg, bodyArg)
}

func NewVideoServiceClientWithTokenProvider(client VideoServiceClient, tokenProvider httpclient.TokenProvider) VideoServiceClientWithAuth {
	return &videoServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type videoServiceClientWithTokenProvider struct {
	client        VideoServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *videoServiceClientWithTokenProvider) Get(ctx context.Context, videoRidArg rids.VideoRid) (api.Video, error) {
	var defaultReturnVal api.Video
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Get(ctx, bearertoken.Token(token), videoRidArg)
}

func (c *videoServiceClientWithTokenProvider) BatchGet(ctx context.Context, requestArg api.GetVideosRequest) (api.GetVideosResponse, error) {
	var defaultReturnVal api.GetVideosResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGet(ctx, bearertoken.Token(token), requestArg)
}

func (c *videoServiceClientWithTokenProvider) Search(ctx context.Context, requestArg api.SearchVideosRequest) (api.SearchVideosResponse, error) {
	var defaultReturnVal api.SearchVideosResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Search(ctx, bearertoken.Token(token), requestArg)
}

func (c *videoServiceClientWithTokenProvider) Create(ctx context.Context, requestArg api.CreateVideoRequest) (api.Video, error) {
	var defaultReturnVal api.Video
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Create(ctx, bearertoken.Token(token), requestArg)
}

func (c *videoServiceClientWithTokenProvider) UpdateMetadata(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.UpdateVideoMetadataRequest) (api.Video, error) {
	var defaultReturnVal api.Video
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateMetadata(ctx, bearertoken.Token(token), videoRidArg, requestArg)
}

func (c *videoServiceClientWithTokenProvider) UpdateIngestStatus(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.UpdateIngestStatus) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.UpdateIngestStatus(ctx, bearertoken.Token(token), videoRidArg, requestArg)
}

func (c *videoServiceClientWithTokenProvider) GetIngestStatus(ctx context.Context, videoRidArg rids.VideoRid) (api.DetailedIngestStatus, error) {
	var defaultReturnVal api.DetailedIngestStatus
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetIngestStatus(ctx, bearertoken.Token(token), videoRidArg)
}

func (c *videoServiceClientWithTokenProvider) BatchGetIngestStatus(ctx context.Context, videoRidsArg []rids.VideoRid) (map[rids.VideoRid]api.DetailedIngestStatus, error) {
	var defaultReturnVal map[rids.VideoRid]api.DetailedIngestStatus
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGetIngestStatus(ctx, bearertoken.Token(token), videoRidsArg)
}

func (c *videoServiceClientWithTokenProvider) GetEnrichedIngestStatus(ctx context.Context, requestArg api.GetEnrichedVideoIngestStatusRequest) (*api.EnrichedVideoIngestStatus, error) {
	var defaultReturnVal *api.EnrichedVideoIngestStatus
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetEnrichedIngestStatus(ctx, bearertoken.Token(token), requestArg)
}

func (c *videoServiceClientWithTokenProvider) Archive(ctx context.Context, videoRidArg rids.VideoRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Archive(ctx, bearertoken.Token(token), videoRidArg)
}

func (c *videoServiceClientWithTokenProvider) Unarchive(ctx context.Context, videoRidArg rids.VideoRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Unarchive(ctx, bearertoken.Token(token), videoRidArg)
}

func (c *videoServiceClientWithTokenProvider) GetPlaylist(ctx context.Context, videoRidArg rids.VideoRid, startArg *string, endArg *string) (io.ReadCloser, error) {
	var defaultReturnVal io.ReadCloser
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetPlaylist(ctx, bearertoken.Token(token), videoRidArg, startArg, endArg)
}

func (c *videoServiceClientWithTokenProvider) GetSegmentSummaries(ctx context.Context, videoRidArg rids.VideoRid) ([]api.SegmentSummary, error) {
	var defaultReturnVal []api.SegmentSummary
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetSegmentSummaries(ctx, bearertoken.Token(token), videoRidArg)
}

func (c *videoServiceClientWithTokenProvider) GetPlaylistInBounds(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetPlaylistInBoundsRequest) (io.ReadCloser, error) {
	var defaultReturnVal io.ReadCloser
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetPlaylistInBounds(ctx, bearertoken.Token(token), videoRidArg, requestArg)
}

func (c *videoServiceClientWithTokenProvider) GetPlaylistInBoundsForChannel(ctx context.Context, requestArg api.GetPlaylistInBoundsForChannelRequest) (io.ReadCloser, error) {
	var defaultReturnVal io.ReadCloser
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetPlaylistInBoundsForChannel(ctx, bearertoken.Token(token), requestArg)
}

func (c *videoServiceClientWithTokenProvider) GetPlaylistForChannel(ctx context.Context, dataSourceRidArg *rids.DataSourceRid, assetRidArg *api1.AssetRid, dataScopeNameArg *string, channelArg string, tagsArg *string, startArg string, endArg string) (io.ReadCloser, error) {
	var defaultReturnVal io.ReadCloser
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetPlaylistForChannel(ctx, bearertoken.Token(token), dataSourceRidArg, assetRidArg, dataScopeNameArg, channelArg, tagsArg, startArg, endArg)
}

func (c *videoServiceClientWithTokenProvider) GetSegmentSummariesInBounds(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetSegmentSummariesInBoundsRequest) ([]api.SegmentSummary, error) {
	var defaultReturnVal []api.SegmentSummary
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetSegmentSummariesInBounds(ctx, bearertoken.Token(token), videoRidArg, requestArg)
}

func (c *videoServiceClientWithTokenProvider) GetSegmentSummariesInBoundsForChannel(ctx context.Context, requestArg api.GetSegmentSummariesInBoundsForChannelRequest) ([]api.SegmentSummary, error) {
	var defaultReturnVal []api.SegmentSummary
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetSegmentSummariesInBoundsForChannel(ctx, bearertoken.Token(token), requestArg)
}

func (c *videoServiceClientWithTokenProvider) GetFileSummaries(ctx context.Context, videoRidArg rids.VideoRid, requestArg api.GetFileSummariesRequest) (api.GetFileSummariesResponse, error) {
	var defaultReturnVal api.GetFileSummariesResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetFileSummaries(ctx, bearertoken.Token(token), videoRidArg, requestArg)
}

func (c *videoServiceClientWithTokenProvider) GenerateWhipStream(ctx context.Context, videoRidArg rids.VideoRid) (api.GenerateWhipStreamResponse, error) {
	var defaultReturnVal api.GenerateWhipStreamResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GenerateWhipStream(ctx, bearertoken.Token(token), videoRidArg)
}

func (c *videoServiceClientWithTokenProvider) GenerateWhepStream(ctx context.Context, videoRidArg rids.VideoRid) (*api.GenerateWhepStreamResponse, error) {
	var defaultReturnVal *api.GenerateWhepStreamResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GenerateWhepStream(ctx, bearertoken.Token(token), videoRidArg)
}

func (c *videoServiceClientWithTokenProvider) UploadSegmentFromMediaMtx(ctx context.Context, streamPathArg string, filePathArg string, durationArg string, contentLengthArg safelong.SafeLong, bodyArg httpclient.RequestBody) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.UploadSegmentFromMediaMtx(ctx, bearertoken.Token(token), streamPathArg, filePathArg, durationArg, contentLengthArg, bodyArg)
}
