// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	api1 "github.com/nominal-io/nominal-api/scout/api"
	"github.com/nominal-io/nominal-api/scout/compute/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type ComputeSpec struct {
	typ string
	v1  *ComputeSpecV1
}

type computeSpecDeserializer struct {
	Type string         `json:"type"`
	V1   *ComputeSpecV1 `json:"v1"`
}

func (u *computeSpecDeserializer) toStruct() ComputeSpec {
	return ComputeSpec{typ: u.Type, v1: u.V1}
}

func (u *ComputeSpec) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "v1":
		if u.v1 == nil {
			return nil, fmt.Errorf("field \"v1\" is required")
		}
		return struct {
			Type string        `json:"type"`
			V1   ComputeSpecV1 `json:"v1"`
		}{Type: "v1", V1: *u.v1}, nil
	}
}

func (u ComputeSpec) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputeSpec) UnmarshalJSON(data []byte) error {
	var deser computeSpecDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
	}
	return nil
}

func (u ComputeSpec) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputeSpec) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputeSpec) AcceptFuncs(v1Func func(ComputeSpecV1) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ComputeSpec) V1NoopSuccess(ComputeSpecV1) error {
	return nil
}

func (u *ComputeSpec) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputeSpec) Accept(v ComputeSpecVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(*u.v1)
	}
}

type ComputeSpecVisitor interface {
	VisitV1(v ComputeSpecV1) error
	VisitUnknown(typeName string) error
}

func (u *ComputeSpec) AcceptWithContext(ctx context.Context, v ComputeSpecVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1WithContext(ctx, *u.v1)
	}
}

type ComputeSpecVisitorWithContext interface {
	VisitV1WithContext(ctx context.Context, v ComputeSpecV1) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputeSpecFromV1(v ComputeSpecV1) ComputeSpec {
	return ComputeSpec{typ: "v1", v1: &v}
}

type VariableLocator struct {
	typ      string
	variable *api.VariableName
	series   *api1.ChannelLocator
}

type variableLocatorDeserializer struct {
	Type     string               `json:"type"`
	Variable *api.VariableName    `json:"variable"`
	Series   *api1.ChannelLocator `json:"series"`
}

func (u *variableLocatorDeserializer) toStruct() VariableLocator {
	return VariableLocator{typ: u.Type, variable: u.Variable, series: u.Series}
}

func (u *VariableLocator) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "variable":
		if u.variable == nil {
			return nil, fmt.Errorf("field \"variable\" is required")
		}
		return struct {
			Type     string           `json:"type"`
			Variable api.VariableName `json:"variable"`
		}{Type: "variable", Variable: *u.variable}, nil
	case "series":
		if u.series == nil {
			return nil, fmt.Errorf("field \"series\" is required")
		}
		return struct {
			Type   string              `json:"type"`
			Series api1.ChannelLocator `json:"series"`
		}{Type: "series", Series: *u.series}, nil
	}
}

func (u VariableLocator) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VariableLocator) UnmarshalJSON(data []byte) error {
	var deser variableLocatorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
	}
	return nil
}

func (u VariableLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VariableLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VariableLocator) AcceptFuncs(variableFunc func(api.VariableName) error, seriesFunc func(api1.ChannelLocator) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	}
}

func (u *VariableLocator) VariableNoopSuccess(api.VariableName) error {
	return nil
}

func (u *VariableLocator) SeriesNoopSuccess(api1.ChannelLocator) error {
	return nil
}

func (u *VariableLocator) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VariableLocator) Accept(v VariableLocatorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(*u.variable)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(*u.series)
	}
}

type VariableLocatorVisitor interface {
	VisitVariable(v api.VariableName) error
	VisitSeries(v api1.ChannelLocator) error
	VisitUnknown(typeName string) error
}

func (u *VariableLocator) AcceptWithContext(ctx context.Context, v VariableLocatorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "variable":
		if u.variable == nil {
			return fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariableWithContext(ctx, *u.variable)
	case "series":
		if u.series == nil {
			return fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeriesWithContext(ctx, *u.series)
	}
}

type VariableLocatorVisitorWithContext interface {
	VisitVariableWithContext(ctx context.Context, v api.VariableName) error
	VisitSeriesWithContext(ctx context.Context, v api1.ChannelLocator) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVariableLocatorFromVariable(v api.VariableName) VariableLocator {
	return VariableLocator{typ: "variable", variable: &v}
}

func NewVariableLocatorFromSeries(v api1.ChannelLocator) VariableLocator {
	return VariableLocator{typ: "series", series: &v}
}
