// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	api1 "github.com/nominal-io/nominal-api-go/scout/api"
	"github.com/nominal-io/nominal-api-go/scout/compute/api"
)

type ComputeSpecWithT[T any] ComputeSpec

func (u *ComputeSpecWithT[T]) Accept(ctx context.Context, v ComputeSpecVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *ComputeSpecWithT[T]) AcceptFuncs(v1Func func(ComputeSpecV1) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *ComputeSpecWithT[T]) V1NoopSuccess(ComputeSpecV1) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeSpecWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComputeSpecVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v ComputeSpecV1) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VariableLocatorWithT[T any] VariableLocator

func (u *VariableLocatorWithT[T]) Accept(ctx context.Context, v VariableLocatorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return v.VisitVariable(ctx, *u.variable)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return v.VisitSeries(ctx, *u.series)
	}
}

func (u *VariableLocatorWithT[T]) AcceptFuncs(variableFunc func(api.VariableName) (T, error), seriesFunc func(api1.ChannelLocator) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "variable":
		if u.variable == nil {
			return result, fmt.Errorf("field \"variable\" is required")
		}
		return variableFunc(*u.variable)
	case "series":
		if u.series == nil {
			return result, fmt.Errorf("field \"series\" is required")
		}
		return seriesFunc(*u.series)
	}
}

func (u *VariableLocatorWithT[T]) VariableNoopSuccess(api.VariableName) (T, error) {
	var result T
	return result, nil
}

func (u *VariableLocatorWithT[T]) SeriesNoopSuccess(api1.ChannelLocator) (T, error) {
	var result T
	return result, nil
}

func (u *VariableLocatorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VariableLocatorVisitorWithT[T any] interface {
	VisitVariable(ctx context.Context, v api.VariableName) (T, error)
	VisitSeries(ctx context.Context, v api1.ChannelLocator) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
