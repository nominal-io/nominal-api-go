// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	api1 "github.com/nominal-io/nominal-api/scout/rids/api"
	"github.com/nominal-io/nominal-api/scout/run/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type AutomaticCheckEvaluationAction struct {
	typ                  string
	executionFinished    *AutomaticCheckExecutionFinished
	executionFailedToRun *AutomaticCheckExecutionFailedToRun
	executionRetriggered *ExecutionRetriggered
	executionStarted     *AutomaticCheckExecutionStarted
}

type automaticCheckEvaluationActionDeserializer struct {
	Type                 string                              `json:"type"`
	ExecutionFinished    *AutomaticCheckExecutionFinished    `json:"executionFinished"`
	ExecutionFailedToRun *AutomaticCheckExecutionFailedToRun `json:"executionFailedToRun"`
	ExecutionRetriggered *ExecutionRetriggered               `json:"executionRetriggered"`
	ExecutionStarted     *AutomaticCheckExecutionStarted     `json:"executionStarted"`
}

func (u *automaticCheckEvaluationActionDeserializer) toStruct() AutomaticCheckEvaluationAction {
	return AutomaticCheckEvaluationAction{typ: u.Type, executionFinished: u.ExecutionFinished, executionFailedToRun: u.ExecutionFailedToRun, executionRetriggered: u.ExecutionRetriggered, executionStarted: u.ExecutionStarted}
}

func (u *AutomaticCheckEvaluationAction) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "executionFinished":
		if u.executionFinished == nil {
			return nil, fmt.Errorf("field \"executionFinished\" is required")
		}
		return struct {
			Type              string                          `json:"type"`
			ExecutionFinished AutomaticCheckExecutionFinished `json:"executionFinished"`
		}{Type: "executionFinished", ExecutionFinished: *u.executionFinished}, nil
	case "executionFailedToRun":
		if u.executionFailedToRun == nil {
			return nil, fmt.Errorf("field \"executionFailedToRun\" is required")
		}
		return struct {
			Type                 string                             `json:"type"`
			ExecutionFailedToRun AutomaticCheckExecutionFailedToRun `json:"executionFailedToRun"`
		}{Type: "executionFailedToRun", ExecutionFailedToRun: *u.executionFailedToRun}, nil
	case "executionRetriggered":
		if u.executionRetriggered == nil {
			return nil, fmt.Errorf("field \"executionRetriggered\" is required")
		}
		return struct {
			Type                 string               `json:"type"`
			ExecutionRetriggered ExecutionRetriggered `json:"executionRetriggered"`
		}{Type: "executionRetriggered", ExecutionRetriggered: *u.executionRetriggered}, nil
	case "executionStarted":
		if u.executionStarted == nil {
			return nil, fmt.Errorf("field \"executionStarted\" is required")
		}
		return struct {
			Type             string                         `json:"type"`
			ExecutionStarted AutomaticCheckExecutionStarted `json:"executionStarted"`
		}{Type: "executionStarted", ExecutionStarted: *u.executionStarted}, nil
	}
}

func (u AutomaticCheckEvaluationAction) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *AutomaticCheckEvaluationAction) UnmarshalJSON(data []byte) error {
	var deser automaticCheckEvaluationActionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "executionFinished":
		if u.executionFinished == nil {
			return fmt.Errorf("field \"executionFinished\" is required")
		}
	case "executionFailedToRun":
		if u.executionFailedToRun == nil {
			return fmt.Errorf("field \"executionFailedToRun\" is required")
		}
	case "executionRetriggered":
		if u.executionRetriggered == nil {
			return fmt.Errorf("field \"executionRetriggered\" is required")
		}
	case "executionStarted":
		if u.executionStarted == nil {
			return fmt.Errorf("field \"executionStarted\" is required")
		}
	}
	return nil
}

func (u AutomaticCheckEvaluationAction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *AutomaticCheckEvaluationAction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *AutomaticCheckEvaluationAction) AcceptFuncs(executionFinishedFunc func(AutomaticCheckExecutionFinished) error, executionFailedToRunFunc func(AutomaticCheckExecutionFailedToRun) error, executionRetriggeredFunc func(ExecutionRetriggered) error, executionStartedFunc func(AutomaticCheckExecutionStarted) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "executionFinished":
		if u.executionFinished == nil {
			return fmt.Errorf("field \"executionFinished\" is required")
		}
		return executionFinishedFunc(*u.executionFinished)
	case "executionFailedToRun":
		if u.executionFailedToRun == nil {
			return fmt.Errorf("field \"executionFailedToRun\" is required")
		}
		return executionFailedToRunFunc(*u.executionFailedToRun)
	case "executionRetriggered":
		if u.executionRetriggered == nil {
			return fmt.Errorf("field \"executionRetriggered\" is required")
		}
		return executionRetriggeredFunc(*u.executionRetriggered)
	case "executionStarted":
		if u.executionStarted == nil {
			return fmt.Errorf("field \"executionStarted\" is required")
		}
		return executionStartedFunc(*u.executionStarted)
	}
}

func (u *AutomaticCheckEvaluationAction) ExecutionFinishedNoopSuccess(AutomaticCheckExecutionFinished) error {
	return nil
}

func (u *AutomaticCheckEvaluationAction) ExecutionFailedToRunNoopSuccess(AutomaticCheckExecutionFailedToRun) error {
	return nil
}

func (u *AutomaticCheckEvaluationAction) ExecutionRetriggeredNoopSuccess(ExecutionRetriggered) error {
	return nil
}

func (u *AutomaticCheckEvaluationAction) ExecutionStartedNoopSuccess(AutomaticCheckExecutionStarted) error {
	return nil
}

func (u *AutomaticCheckEvaluationAction) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *AutomaticCheckEvaluationAction) Accept(v AutomaticCheckEvaluationActionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "executionFinished":
		if u.executionFinished == nil {
			return fmt.Errorf("field \"executionFinished\" is required")
		}
		return v.VisitExecutionFinished(*u.executionFinished)
	case "executionFailedToRun":
		if u.executionFailedToRun == nil {
			return fmt.Errorf("field \"executionFailedToRun\" is required")
		}
		return v.VisitExecutionFailedToRun(*u.executionFailedToRun)
	case "executionRetriggered":
		if u.executionRetriggered == nil {
			return fmt.Errorf("field \"executionRetriggered\" is required")
		}
		return v.VisitExecutionRetriggered(*u.executionRetriggered)
	case "executionStarted":
		if u.executionStarted == nil {
			return fmt.Errorf("field \"executionStarted\" is required")
		}
		return v.VisitExecutionStarted(*u.executionStarted)
	}
}

type AutomaticCheckEvaluationActionVisitor interface {
	VisitExecutionFinished(v AutomaticCheckExecutionFinished) error
	VisitExecutionFailedToRun(v AutomaticCheckExecutionFailedToRun) error
	VisitExecutionRetriggered(v ExecutionRetriggered) error
	VisitExecutionStarted(v AutomaticCheckExecutionStarted) error
	VisitUnknown(typeName string) error
}

func (u *AutomaticCheckEvaluationAction) AcceptWithContext(ctx context.Context, v AutomaticCheckEvaluationActionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "executionFinished":
		if u.executionFinished == nil {
			return fmt.Errorf("field \"executionFinished\" is required")
		}
		return v.VisitExecutionFinishedWithContext(ctx, *u.executionFinished)
	case "executionFailedToRun":
		if u.executionFailedToRun == nil {
			return fmt.Errorf("field \"executionFailedToRun\" is required")
		}
		return v.VisitExecutionFailedToRunWithContext(ctx, *u.executionFailedToRun)
	case "executionRetriggered":
		if u.executionRetriggered == nil {
			return fmt.Errorf("field \"executionRetriggered\" is required")
		}
		return v.VisitExecutionRetriggeredWithContext(ctx, *u.executionRetriggered)
	case "executionStarted":
		if u.executionStarted == nil {
			return fmt.Errorf("field \"executionStarted\" is required")
		}
		return v.VisitExecutionStartedWithContext(ctx, *u.executionStarted)
	}
}

type AutomaticCheckEvaluationActionVisitorWithContext interface {
	VisitExecutionFinishedWithContext(ctx context.Context, v AutomaticCheckExecutionFinished) error
	VisitExecutionFailedToRunWithContext(ctx context.Context, v AutomaticCheckExecutionFailedToRun) error
	VisitExecutionRetriggeredWithContext(ctx context.Context, v ExecutionRetriggered) error
	VisitExecutionStartedWithContext(ctx context.Context, v AutomaticCheckExecutionStarted) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAutomaticCheckEvaluationActionFromExecutionFinished(v AutomaticCheckExecutionFinished) AutomaticCheckEvaluationAction {
	return AutomaticCheckEvaluationAction{typ: "executionFinished", executionFinished: &v}
}

func NewAutomaticCheckEvaluationActionFromExecutionFailedToRun(v AutomaticCheckExecutionFailedToRun) AutomaticCheckEvaluationAction {
	return AutomaticCheckEvaluationAction{typ: "executionFailedToRun", executionFailedToRun: &v}
}

func NewAutomaticCheckEvaluationActionFromExecutionRetriggered(v ExecutionRetriggered) AutomaticCheckEvaluationAction {
	return AutomaticCheckEvaluationAction{typ: "executionRetriggered", executionRetriggered: &v}
}

func NewAutomaticCheckEvaluationActionFromExecutionStarted(v AutomaticCheckExecutionStarted) AutomaticCheckEvaluationAction {
	return AutomaticCheckEvaluationAction{typ: "executionStarted", executionStarted: &v}
}

type AutomaticCheckEvaluationReviewAction struct {
	typ                    string
	closeWithIgnore        *CloseWithIgnoreAlert
	closeWithFurtherAction *CloseWithFurtherAction
	reopen                 *Reopen
	reassign               *Reassign
	updateNotes            *UpdateNotes
}

type automaticCheckEvaluationReviewActionDeserializer struct {
	Type                   string                  `json:"type"`
	CloseWithIgnore        *CloseWithIgnoreAlert   `json:"closeWithIgnore"`
	CloseWithFurtherAction *CloseWithFurtherAction `json:"closeWithFurtherAction"`
	Reopen                 *Reopen                 `json:"reopen"`
	Reassign               *Reassign               `json:"reassign"`
	UpdateNotes            *UpdateNotes            `json:"updateNotes"`
}

func (u *automaticCheckEvaluationReviewActionDeserializer) toStruct() AutomaticCheckEvaluationReviewAction {
	return AutomaticCheckEvaluationReviewAction{typ: u.Type, closeWithIgnore: u.CloseWithIgnore, closeWithFurtherAction: u.CloseWithFurtherAction, reopen: u.Reopen, reassign: u.Reassign, updateNotes: u.UpdateNotes}
}

func (u *AutomaticCheckEvaluationReviewAction) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return nil, fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return struct {
			Type            string               `json:"type"`
			CloseWithIgnore CloseWithIgnoreAlert `json:"closeWithIgnore"`
		}{Type: "closeWithIgnore", CloseWithIgnore: *u.closeWithIgnore}, nil
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return nil, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return struct {
			Type                   string                 `json:"type"`
			CloseWithFurtherAction CloseWithFurtherAction `json:"closeWithFurtherAction"`
		}{Type: "closeWithFurtherAction", CloseWithFurtherAction: *u.closeWithFurtherAction}, nil
	case "reopen":
		if u.reopen == nil {
			return nil, fmt.Errorf("field \"reopen\" is required")
		}
		return struct {
			Type   string `json:"type"`
			Reopen Reopen `json:"reopen"`
		}{Type: "reopen", Reopen: *u.reopen}, nil
	case "reassign":
		if u.reassign == nil {
			return nil, fmt.Errorf("field \"reassign\" is required")
		}
		return struct {
			Type     string   `json:"type"`
			Reassign Reassign `json:"reassign"`
		}{Type: "reassign", Reassign: *u.reassign}, nil
	case "updateNotes":
		if u.updateNotes == nil {
			return nil, fmt.Errorf("field \"updateNotes\" is required")
		}
		return struct {
			Type        string      `json:"type"`
			UpdateNotes UpdateNotes `json:"updateNotes"`
		}{Type: "updateNotes", UpdateNotes: *u.updateNotes}, nil
	}
}

func (u AutomaticCheckEvaluationReviewAction) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *AutomaticCheckEvaluationReviewAction) UnmarshalJSON(data []byte) error {
	var deser automaticCheckEvaluationReviewActionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
	}
	return nil
}

func (u AutomaticCheckEvaluationReviewAction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *AutomaticCheckEvaluationReviewAction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *AutomaticCheckEvaluationReviewAction) AcceptFuncs(closeWithIgnoreFunc func(CloseWithIgnoreAlert) error, closeWithFurtherActionFunc func(CloseWithFurtherAction) error, reopenFunc func(Reopen) error, reassignFunc func(Reassign) error, updateNotesFunc func(UpdateNotes) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return closeWithIgnoreFunc(*u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return closeWithFurtherActionFunc(*u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
		return reopenFunc(*u.reopen)
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
		return reassignFunc(*u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
		return updateNotesFunc(*u.updateNotes)
	}
}

func (u *AutomaticCheckEvaluationReviewAction) CloseWithIgnoreNoopSuccess(CloseWithIgnoreAlert) error {
	return nil
}

func (u *AutomaticCheckEvaluationReviewAction) CloseWithFurtherActionNoopSuccess(CloseWithFurtherAction) error {
	return nil
}

func (u *AutomaticCheckEvaluationReviewAction) ReopenNoopSuccess(Reopen) error {
	return nil
}

func (u *AutomaticCheckEvaluationReviewAction) ReassignNoopSuccess(Reassign) error {
	return nil
}

func (u *AutomaticCheckEvaluationReviewAction) UpdateNotesNoopSuccess(UpdateNotes) error {
	return nil
}

func (u *AutomaticCheckEvaluationReviewAction) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *AutomaticCheckEvaluationReviewAction) Accept(v AutomaticCheckEvaluationReviewActionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return v.VisitCloseWithIgnore(*u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherAction(*u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
		return v.VisitReopen(*u.reopen)
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
		return v.VisitReassign(*u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
		return v.VisitUpdateNotes(*u.updateNotes)
	}
}

type AutomaticCheckEvaluationReviewActionVisitor interface {
	VisitCloseWithIgnore(v CloseWithIgnoreAlert) error
	VisitCloseWithFurtherAction(v CloseWithFurtherAction) error
	VisitReopen(v Reopen) error
	VisitReassign(v Reassign) error
	VisitUpdateNotes(v UpdateNotes) error
	VisitUnknown(typeName string) error
}

func (u *AutomaticCheckEvaluationReviewAction) AcceptWithContext(ctx context.Context, v AutomaticCheckEvaluationReviewActionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return v.VisitCloseWithIgnoreWithContext(ctx, *u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherActionWithContext(ctx, *u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
		return v.VisitReopenWithContext(ctx, *u.reopen)
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
		return v.VisitReassignWithContext(ctx, *u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
		return v.VisitUpdateNotesWithContext(ctx, *u.updateNotes)
	}
}

type AutomaticCheckEvaluationReviewActionVisitorWithContext interface {
	VisitCloseWithIgnoreWithContext(ctx context.Context, v CloseWithIgnoreAlert) error
	VisitCloseWithFurtherActionWithContext(ctx context.Context, v CloseWithFurtherAction) error
	VisitReopenWithContext(ctx context.Context, v Reopen) error
	VisitReassignWithContext(ctx context.Context, v Reassign) error
	VisitUpdateNotesWithContext(ctx context.Context, v UpdateNotes) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAutomaticCheckEvaluationReviewActionFromCloseWithIgnore(v CloseWithIgnoreAlert) AutomaticCheckEvaluationReviewAction {
	return AutomaticCheckEvaluationReviewAction{typ: "closeWithIgnore", closeWithIgnore: &v}
}

func NewAutomaticCheckEvaluationReviewActionFromCloseWithFurtherAction(v CloseWithFurtherAction) AutomaticCheckEvaluationReviewAction {
	return AutomaticCheckEvaluationReviewAction{typ: "closeWithFurtherAction", closeWithFurtherAction: &v}
}

func NewAutomaticCheckEvaluationReviewActionFromReopen(v Reopen) AutomaticCheckEvaluationReviewAction {
	return AutomaticCheckEvaluationReviewAction{typ: "reopen", reopen: &v}
}

func NewAutomaticCheckEvaluationReviewActionFromReassign(v Reassign) AutomaticCheckEvaluationReviewAction {
	return AutomaticCheckEvaluationReviewAction{typ: "reassign", reassign: &v}
}

func NewAutomaticCheckEvaluationReviewActionFromUpdateNotes(v UpdateNotes) AutomaticCheckEvaluationReviewAction {
	return AutomaticCheckEvaluationReviewAction{typ: "updateNotes", updateNotes: &v}
}

type AutomaticCheckEvaluationState struct {
	typ              string
	pendingExecution *PendingExecutionState
	failedToExecute  *FailedToExecuteState
	passing          *PassingExecutionState
	generatedAlerts  *GeneratedAlertsState
	tooManyAlerts    *TooManyAlertsState
	executing        *ExecutingState
}

type automaticCheckEvaluationStateDeserializer struct {
	Type             string                 `json:"type"`
	PendingExecution *PendingExecutionState `json:"pendingExecution"`
	FailedToExecute  *FailedToExecuteState  `json:"failedToExecute"`
	Passing          *PassingExecutionState `json:"passing"`
	GeneratedAlerts  *GeneratedAlertsState  `json:"generatedAlerts"`
	TooManyAlerts    *TooManyAlertsState    `json:"tooManyAlerts"`
	Executing        *ExecutingState        `json:"executing"`
}

func (u *automaticCheckEvaluationStateDeserializer) toStruct() AutomaticCheckEvaluationState {
	return AutomaticCheckEvaluationState{typ: u.Type, pendingExecution: u.PendingExecution, failedToExecute: u.FailedToExecute, passing: u.Passing, generatedAlerts: u.GeneratedAlerts, tooManyAlerts: u.TooManyAlerts, executing: u.Executing}
}

func (u *AutomaticCheckEvaluationState) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "pendingExecution":
		if u.pendingExecution == nil {
			return nil, fmt.Errorf("field \"pendingExecution\" is required")
		}
		return struct {
			Type             string                `json:"type"`
			PendingExecution PendingExecutionState `json:"pendingExecution"`
		}{Type: "pendingExecution", PendingExecution: *u.pendingExecution}, nil
	case "failedToExecute":
		if u.failedToExecute == nil {
			return nil, fmt.Errorf("field \"failedToExecute\" is required")
		}
		return struct {
			Type            string               `json:"type"`
			FailedToExecute FailedToExecuteState `json:"failedToExecute"`
		}{Type: "failedToExecute", FailedToExecute: *u.failedToExecute}, nil
	case "passing":
		if u.passing == nil {
			return nil, fmt.Errorf("field \"passing\" is required")
		}
		return struct {
			Type    string                `json:"type"`
			Passing PassingExecutionState `json:"passing"`
		}{Type: "passing", Passing: *u.passing}, nil
	case "generatedAlerts":
		if u.generatedAlerts == nil {
			return nil, fmt.Errorf("field \"generatedAlerts\" is required")
		}
		return struct {
			Type            string               `json:"type"`
			GeneratedAlerts GeneratedAlertsState `json:"generatedAlerts"`
		}{Type: "generatedAlerts", GeneratedAlerts: *u.generatedAlerts}, nil
	case "tooManyAlerts":
		if u.tooManyAlerts == nil {
			return nil, fmt.Errorf("field \"tooManyAlerts\" is required")
		}
		return struct {
			Type          string             `json:"type"`
			TooManyAlerts TooManyAlertsState `json:"tooManyAlerts"`
		}{Type: "tooManyAlerts", TooManyAlerts: *u.tooManyAlerts}, nil
	case "executing":
		if u.executing == nil {
			return nil, fmt.Errorf("field \"executing\" is required")
		}
		return struct {
			Type      string         `json:"type"`
			Executing ExecutingState `json:"executing"`
		}{Type: "executing", Executing: *u.executing}, nil
	}
}

func (u AutomaticCheckEvaluationState) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *AutomaticCheckEvaluationState) UnmarshalJSON(data []byte) error {
	var deser automaticCheckEvaluationStateDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "pendingExecution":
		if u.pendingExecution == nil {
			return fmt.Errorf("field \"pendingExecution\" is required")
		}
	case "failedToExecute":
		if u.failedToExecute == nil {
			return fmt.Errorf("field \"failedToExecute\" is required")
		}
	case "passing":
		if u.passing == nil {
			return fmt.Errorf("field \"passing\" is required")
		}
	case "generatedAlerts":
		if u.generatedAlerts == nil {
			return fmt.Errorf("field \"generatedAlerts\" is required")
		}
	case "tooManyAlerts":
		if u.tooManyAlerts == nil {
			return fmt.Errorf("field \"tooManyAlerts\" is required")
		}
	case "executing":
		if u.executing == nil {
			return fmt.Errorf("field \"executing\" is required")
		}
	}
	return nil
}

func (u AutomaticCheckEvaluationState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *AutomaticCheckEvaluationState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *AutomaticCheckEvaluationState) AcceptFuncs(pendingExecutionFunc func(PendingExecutionState) error, failedToExecuteFunc func(FailedToExecuteState) error, passingFunc func(PassingExecutionState) error, generatedAlertsFunc func(GeneratedAlertsState) error, tooManyAlertsFunc func(TooManyAlertsState) error, executingFunc func(ExecutingState) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pendingExecution":
		if u.pendingExecution == nil {
			return fmt.Errorf("field \"pendingExecution\" is required")
		}
		return pendingExecutionFunc(*u.pendingExecution)
	case "failedToExecute":
		if u.failedToExecute == nil {
			return fmt.Errorf("field \"failedToExecute\" is required")
		}
		return failedToExecuteFunc(*u.failedToExecute)
	case "passing":
		if u.passing == nil {
			return fmt.Errorf("field \"passing\" is required")
		}
		return passingFunc(*u.passing)
	case "generatedAlerts":
		if u.generatedAlerts == nil {
			return fmt.Errorf("field \"generatedAlerts\" is required")
		}
		return generatedAlertsFunc(*u.generatedAlerts)
	case "tooManyAlerts":
		if u.tooManyAlerts == nil {
			return fmt.Errorf("field \"tooManyAlerts\" is required")
		}
		return tooManyAlertsFunc(*u.tooManyAlerts)
	case "executing":
		if u.executing == nil {
			return fmt.Errorf("field \"executing\" is required")
		}
		return executingFunc(*u.executing)
	}
}

func (u *AutomaticCheckEvaluationState) PendingExecutionNoopSuccess(PendingExecutionState) error {
	return nil
}

func (u *AutomaticCheckEvaluationState) FailedToExecuteNoopSuccess(FailedToExecuteState) error {
	return nil
}

func (u *AutomaticCheckEvaluationState) PassingNoopSuccess(PassingExecutionState) error {
	return nil
}

func (u *AutomaticCheckEvaluationState) GeneratedAlertsNoopSuccess(GeneratedAlertsState) error {
	return nil
}

func (u *AutomaticCheckEvaluationState) TooManyAlertsNoopSuccess(TooManyAlertsState) error {
	return nil
}

func (u *AutomaticCheckEvaluationState) ExecutingNoopSuccess(ExecutingState) error {
	return nil
}

func (u *AutomaticCheckEvaluationState) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *AutomaticCheckEvaluationState) Accept(v AutomaticCheckEvaluationStateVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "pendingExecution":
		if u.pendingExecution == nil {
			return fmt.Errorf("field \"pendingExecution\" is required")
		}
		return v.VisitPendingExecution(*u.pendingExecution)
	case "failedToExecute":
		if u.failedToExecute == nil {
			return fmt.Errorf("field \"failedToExecute\" is required")
		}
		return v.VisitFailedToExecute(*u.failedToExecute)
	case "passing":
		if u.passing == nil {
			return fmt.Errorf("field \"passing\" is required")
		}
		return v.VisitPassing(*u.passing)
	case "generatedAlerts":
		if u.generatedAlerts == nil {
			return fmt.Errorf("field \"generatedAlerts\" is required")
		}
		return v.VisitGeneratedAlerts(*u.generatedAlerts)
	case "tooManyAlerts":
		if u.tooManyAlerts == nil {
			return fmt.Errorf("field \"tooManyAlerts\" is required")
		}
		return v.VisitTooManyAlerts(*u.tooManyAlerts)
	case "executing":
		if u.executing == nil {
			return fmt.Errorf("field \"executing\" is required")
		}
		return v.VisitExecuting(*u.executing)
	}
}

type AutomaticCheckEvaluationStateVisitor interface {
	VisitPendingExecution(v PendingExecutionState) error
	VisitFailedToExecute(v FailedToExecuteState) error
	VisitPassing(v PassingExecutionState) error
	VisitGeneratedAlerts(v GeneratedAlertsState) error
	VisitTooManyAlerts(v TooManyAlertsState) error
	VisitExecuting(v ExecutingState) error
	VisitUnknown(typeName string) error
}

func (u *AutomaticCheckEvaluationState) AcceptWithContext(ctx context.Context, v AutomaticCheckEvaluationStateVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "pendingExecution":
		if u.pendingExecution == nil {
			return fmt.Errorf("field \"pendingExecution\" is required")
		}
		return v.VisitPendingExecutionWithContext(ctx, *u.pendingExecution)
	case "failedToExecute":
		if u.failedToExecute == nil {
			return fmt.Errorf("field \"failedToExecute\" is required")
		}
		return v.VisitFailedToExecuteWithContext(ctx, *u.failedToExecute)
	case "passing":
		if u.passing == nil {
			return fmt.Errorf("field \"passing\" is required")
		}
		return v.VisitPassingWithContext(ctx, *u.passing)
	case "generatedAlerts":
		if u.generatedAlerts == nil {
			return fmt.Errorf("field \"generatedAlerts\" is required")
		}
		return v.VisitGeneratedAlertsWithContext(ctx, *u.generatedAlerts)
	case "tooManyAlerts":
		if u.tooManyAlerts == nil {
			return fmt.Errorf("field \"tooManyAlerts\" is required")
		}
		return v.VisitTooManyAlertsWithContext(ctx, *u.tooManyAlerts)
	case "executing":
		if u.executing == nil {
			return fmt.Errorf("field \"executing\" is required")
		}
		return v.VisitExecutingWithContext(ctx, *u.executing)
	}
}

type AutomaticCheckEvaluationStateVisitorWithContext interface {
	VisitPendingExecutionWithContext(ctx context.Context, v PendingExecutionState) error
	VisitFailedToExecuteWithContext(ctx context.Context, v FailedToExecuteState) error
	VisitPassingWithContext(ctx context.Context, v PassingExecutionState) error
	VisitGeneratedAlertsWithContext(ctx context.Context, v GeneratedAlertsState) error
	VisitTooManyAlertsWithContext(ctx context.Context, v TooManyAlertsState) error
	VisitExecutingWithContext(ctx context.Context, v ExecutingState) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAutomaticCheckEvaluationStateFromPendingExecution(v PendingExecutionState) AutomaticCheckEvaluationState {
	return AutomaticCheckEvaluationState{typ: "pendingExecution", pendingExecution: &v}
}

func NewAutomaticCheckEvaluationStateFromFailedToExecute(v FailedToExecuteState) AutomaticCheckEvaluationState {
	return AutomaticCheckEvaluationState{typ: "failedToExecute", failedToExecute: &v}
}

func NewAutomaticCheckEvaluationStateFromPassing(v PassingExecutionState) AutomaticCheckEvaluationState {
	return AutomaticCheckEvaluationState{typ: "passing", passing: &v}
}

func NewAutomaticCheckEvaluationStateFromGeneratedAlerts(v GeneratedAlertsState) AutomaticCheckEvaluationState {
	return AutomaticCheckEvaluationState{typ: "generatedAlerts", generatedAlerts: &v}
}

func NewAutomaticCheckEvaluationStateFromTooManyAlerts(v TooManyAlertsState) AutomaticCheckEvaluationState {
	return AutomaticCheckEvaluationState{typ: "tooManyAlerts", tooManyAlerts: &v}
}

func NewAutomaticCheckEvaluationStateFromExecuting(v ExecutingState) AutomaticCheckEvaluationState {
	return AutomaticCheckEvaluationState{typ: "executing", executing: &v}
}

type CheckAlertAction struct {
	typ                    string
	closeWithIgnore        *CloseWithIgnoreAlert
	closeWithFurtherAction *CloseWithFurtherAction
	reopen                 *Reopen
	reassign               *Reassign
	updateNotes            *UpdateNotes
	linkNotebook           *LinkNotebook
	unlinkNotebook         *UnlinkNotebook
	archiveDataReview      *ArchiveDataReview
	unarchiveDataReview    *UnarchiveDataReview
}

type checkAlertActionDeserializer struct {
	Type                   string                  `json:"type"`
	CloseWithIgnore        *CloseWithIgnoreAlert   `json:"closeWithIgnore"`
	CloseWithFurtherAction *CloseWithFurtherAction `json:"closeWithFurtherAction"`
	Reopen                 *Reopen                 `json:"reopen"`
	Reassign               *Reassign               `json:"reassign"`
	UpdateNotes            *UpdateNotes            `json:"updateNotes"`
	LinkNotebook           *LinkNotebook           `json:"linkNotebook"`
	UnlinkNotebook         *UnlinkNotebook         `json:"unlinkNotebook"`
	ArchiveDataReview      *ArchiveDataReview      `json:"archiveDataReview"`
	UnarchiveDataReview    *UnarchiveDataReview    `json:"unarchiveDataReview"`
}

func (u *checkAlertActionDeserializer) toStruct() CheckAlertAction {
	return CheckAlertAction{typ: u.Type, closeWithIgnore: u.CloseWithIgnore, closeWithFurtherAction: u.CloseWithFurtherAction, reopen: u.Reopen, reassign: u.Reassign, updateNotes: u.UpdateNotes, linkNotebook: u.LinkNotebook, unlinkNotebook: u.UnlinkNotebook, archiveDataReview: u.ArchiveDataReview, unarchiveDataReview: u.UnarchiveDataReview}
}

func (u *CheckAlertAction) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return nil, fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return struct {
			Type            string               `json:"type"`
			CloseWithIgnore CloseWithIgnoreAlert `json:"closeWithIgnore"`
		}{Type: "closeWithIgnore", CloseWithIgnore: *u.closeWithIgnore}, nil
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return nil, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return struct {
			Type                   string                 `json:"type"`
			CloseWithFurtherAction CloseWithFurtherAction `json:"closeWithFurtherAction"`
		}{Type: "closeWithFurtherAction", CloseWithFurtherAction: *u.closeWithFurtherAction}, nil
	case "reopen":
		if u.reopen == nil {
			return nil, fmt.Errorf("field \"reopen\" is required")
		}
		return struct {
			Type   string `json:"type"`
			Reopen Reopen `json:"reopen"`
		}{Type: "reopen", Reopen: *u.reopen}, nil
	case "reassign":
		if u.reassign == nil {
			return nil, fmt.Errorf("field \"reassign\" is required")
		}
		return struct {
			Type     string   `json:"type"`
			Reassign Reassign `json:"reassign"`
		}{Type: "reassign", Reassign: *u.reassign}, nil
	case "updateNotes":
		if u.updateNotes == nil {
			return nil, fmt.Errorf("field \"updateNotes\" is required")
		}
		return struct {
			Type        string      `json:"type"`
			UpdateNotes UpdateNotes `json:"updateNotes"`
		}{Type: "updateNotes", UpdateNotes: *u.updateNotes}, nil
	case "linkNotebook":
		if u.linkNotebook == nil {
			return nil, fmt.Errorf("field \"linkNotebook\" is required")
		}
		return struct {
			Type         string       `json:"type"`
			LinkNotebook LinkNotebook `json:"linkNotebook"`
		}{Type: "linkNotebook", LinkNotebook: *u.linkNotebook}, nil
	case "unlinkNotebook":
		if u.unlinkNotebook == nil {
			return nil, fmt.Errorf("field \"unlinkNotebook\" is required")
		}
		return struct {
			Type           string         `json:"type"`
			UnlinkNotebook UnlinkNotebook `json:"unlinkNotebook"`
		}{Type: "unlinkNotebook", UnlinkNotebook: *u.unlinkNotebook}, nil
	case "archiveDataReview":
		if u.archiveDataReview == nil {
			return nil, fmt.Errorf("field \"archiveDataReview\" is required")
		}
		return struct {
			Type              string            `json:"type"`
			ArchiveDataReview ArchiveDataReview `json:"archiveDataReview"`
		}{Type: "archiveDataReview", ArchiveDataReview: *u.archiveDataReview}, nil
	case "unarchiveDataReview":
		if u.unarchiveDataReview == nil {
			return nil, fmt.Errorf("field \"unarchiveDataReview\" is required")
		}
		return struct {
			Type                string              `json:"type"`
			UnarchiveDataReview UnarchiveDataReview `json:"unarchiveDataReview"`
		}{Type: "unarchiveDataReview", UnarchiveDataReview: *u.unarchiveDataReview}, nil
	}
}

func (u CheckAlertAction) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CheckAlertAction) UnmarshalJSON(data []byte) error {
	var deser checkAlertActionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
	case "linkNotebook":
		if u.linkNotebook == nil {
			return fmt.Errorf("field \"linkNotebook\" is required")
		}
	case "unlinkNotebook":
		if u.unlinkNotebook == nil {
			return fmt.Errorf("field \"unlinkNotebook\" is required")
		}
	case "archiveDataReview":
		if u.archiveDataReview == nil {
			return fmt.Errorf("field \"archiveDataReview\" is required")
		}
	case "unarchiveDataReview":
		if u.unarchiveDataReview == nil {
			return fmt.Errorf("field \"unarchiveDataReview\" is required")
		}
	}
	return nil
}

func (u CheckAlertAction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CheckAlertAction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CheckAlertAction) AcceptFuncs(closeWithIgnoreFunc func(CloseWithIgnoreAlert) error, closeWithFurtherActionFunc func(CloseWithFurtherAction) error, reopenFunc func(Reopen) error, reassignFunc func(Reassign) error, updateNotesFunc func(UpdateNotes) error, linkNotebookFunc func(LinkNotebook) error, unlinkNotebookFunc func(UnlinkNotebook) error, archiveDataReviewFunc func(ArchiveDataReview) error, unarchiveDataReviewFunc func(UnarchiveDataReview) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return closeWithIgnoreFunc(*u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return closeWithFurtherActionFunc(*u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
		return reopenFunc(*u.reopen)
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
		return reassignFunc(*u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
		return updateNotesFunc(*u.updateNotes)
	case "linkNotebook":
		if u.linkNotebook == nil {
			return fmt.Errorf("field \"linkNotebook\" is required")
		}
		return linkNotebookFunc(*u.linkNotebook)
	case "unlinkNotebook":
		if u.unlinkNotebook == nil {
			return fmt.Errorf("field \"unlinkNotebook\" is required")
		}
		return unlinkNotebookFunc(*u.unlinkNotebook)
	case "archiveDataReview":
		if u.archiveDataReview == nil {
			return fmt.Errorf("field \"archiveDataReview\" is required")
		}
		return archiveDataReviewFunc(*u.archiveDataReview)
	case "unarchiveDataReview":
		if u.unarchiveDataReview == nil {
			return fmt.Errorf("field \"unarchiveDataReview\" is required")
		}
		return unarchiveDataReviewFunc(*u.unarchiveDataReview)
	}
}

func (u *CheckAlertAction) CloseWithIgnoreNoopSuccess(CloseWithIgnoreAlert) error {
	return nil
}

func (u *CheckAlertAction) CloseWithFurtherActionNoopSuccess(CloseWithFurtherAction) error {
	return nil
}

func (u *CheckAlertAction) ReopenNoopSuccess(Reopen) error {
	return nil
}

func (u *CheckAlertAction) ReassignNoopSuccess(Reassign) error {
	return nil
}

func (u *CheckAlertAction) UpdateNotesNoopSuccess(UpdateNotes) error {
	return nil
}

func (u *CheckAlertAction) LinkNotebookNoopSuccess(LinkNotebook) error {
	return nil
}

func (u *CheckAlertAction) UnlinkNotebookNoopSuccess(UnlinkNotebook) error {
	return nil
}

func (u *CheckAlertAction) ArchiveDataReviewNoopSuccess(ArchiveDataReview) error {
	return nil
}

func (u *CheckAlertAction) UnarchiveDataReviewNoopSuccess(UnarchiveDataReview) error {
	return nil
}

func (u *CheckAlertAction) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CheckAlertAction) Accept(v CheckAlertActionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return v.VisitCloseWithIgnore(*u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherAction(*u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
		return v.VisitReopen(*u.reopen)
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
		return v.VisitReassign(*u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
		return v.VisitUpdateNotes(*u.updateNotes)
	case "linkNotebook":
		if u.linkNotebook == nil {
			return fmt.Errorf("field \"linkNotebook\" is required")
		}
		return v.VisitLinkNotebook(*u.linkNotebook)
	case "unlinkNotebook":
		if u.unlinkNotebook == nil {
			return fmt.Errorf("field \"unlinkNotebook\" is required")
		}
		return v.VisitUnlinkNotebook(*u.unlinkNotebook)
	case "archiveDataReview":
		if u.archiveDataReview == nil {
			return fmt.Errorf("field \"archiveDataReview\" is required")
		}
		return v.VisitArchiveDataReview(*u.archiveDataReview)
	case "unarchiveDataReview":
		if u.unarchiveDataReview == nil {
			return fmt.Errorf("field \"unarchiveDataReview\" is required")
		}
		return v.VisitUnarchiveDataReview(*u.unarchiveDataReview)
	}
}

type CheckAlertActionVisitor interface {
	VisitCloseWithIgnore(v CloseWithIgnoreAlert) error
	VisitCloseWithFurtherAction(v CloseWithFurtherAction) error
	VisitReopen(v Reopen) error
	VisitReassign(v Reassign) error
	VisitUpdateNotes(v UpdateNotes) error
	VisitLinkNotebook(v LinkNotebook) error
	VisitUnlinkNotebook(v UnlinkNotebook) error
	VisitArchiveDataReview(v ArchiveDataReview) error
	VisitUnarchiveDataReview(v UnarchiveDataReview) error
	VisitUnknown(typeName string) error
}

func (u *CheckAlertAction) AcceptWithContext(ctx context.Context, v CheckAlertActionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return v.VisitCloseWithIgnoreWithContext(ctx, *u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherActionWithContext(ctx, *u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
		return v.VisitReopenWithContext(ctx, *u.reopen)
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
		return v.VisitReassignWithContext(ctx, *u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
		return v.VisitUpdateNotesWithContext(ctx, *u.updateNotes)
	case "linkNotebook":
		if u.linkNotebook == nil {
			return fmt.Errorf("field \"linkNotebook\" is required")
		}
		return v.VisitLinkNotebookWithContext(ctx, *u.linkNotebook)
	case "unlinkNotebook":
		if u.unlinkNotebook == nil {
			return fmt.Errorf("field \"unlinkNotebook\" is required")
		}
		return v.VisitUnlinkNotebookWithContext(ctx, *u.unlinkNotebook)
	case "archiveDataReview":
		if u.archiveDataReview == nil {
			return fmt.Errorf("field \"archiveDataReview\" is required")
		}
		return v.VisitArchiveDataReviewWithContext(ctx, *u.archiveDataReview)
	case "unarchiveDataReview":
		if u.unarchiveDataReview == nil {
			return fmt.Errorf("field \"unarchiveDataReview\" is required")
		}
		return v.VisitUnarchiveDataReviewWithContext(ctx, *u.unarchiveDataReview)
	}
}

type CheckAlertActionVisitorWithContext interface {
	VisitCloseWithIgnoreWithContext(ctx context.Context, v CloseWithIgnoreAlert) error
	VisitCloseWithFurtherActionWithContext(ctx context.Context, v CloseWithFurtherAction) error
	VisitReopenWithContext(ctx context.Context, v Reopen) error
	VisitReassignWithContext(ctx context.Context, v Reassign) error
	VisitUpdateNotesWithContext(ctx context.Context, v UpdateNotes) error
	VisitLinkNotebookWithContext(ctx context.Context, v LinkNotebook) error
	VisitUnlinkNotebookWithContext(ctx context.Context, v UnlinkNotebook) error
	VisitArchiveDataReviewWithContext(ctx context.Context, v ArchiveDataReview) error
	VisitUnarchiveDataReviewWithContext(ctx context.Context, v UnarchiveDataReview) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCheckAlertActionFromCloseWithIgnore(v CloseWithIgnoreAlert) CheckAlertAction {
	return CheckAlertAction{typ: "closeWithIgnore", closeWithIgnore: &v}
}

func NewCheckAlertActionFromCloseWithFurtherAction(v CloseWithFurtherAction) CheckAlertAction {
	return CheckAlertAction{typ: "closeWithFurtherAction", closeWithFurtherAction: &v}
}

func NewCheckAlertActionFromReopen(v Reopen) CheckAlertAction {
	return CheckAlertAction{typ: "reopen", reopen: &v}
}

func NewCheckAlertActionFromReassign(v Reassign) CheckAlertAction {
	return CheckAlertAction{typ: "reassign", reassign: &v}
}

func NewCheckAlertActionFromUpdateNotes(v UpdateNotes) CheckAlertAction {
	return CheckAlertAction{typ: "updateNotes", updateNotes: &v}
}

func NewCheckAlertActionFromLinkNotebook(v LinkNotebook) CheckAlertAction {
	return CheckAlertAction{typ: "linkNotebook", linkNotebook: &v}
}

func NewCheckAlertActionFromUnlinkNotebook(v UnlinkNotebook) CheckAlertAction {
	return CheckAlertAction{typ: "unlinkNotebook", unlinkNotebook: &v}
}

func NewCheckAlertActionFromArchiveDataReview(v ArchiveDataReview) CheckAlertAction {
	return CheckAlertAction{typ: "archiveDataReview", archiveDataReview: &v}
}

func NewCheckAlertActionFromUnarchiveDataReview(v UnarchiveDataReview) CheckAlertAction {
	return CheckAlertAction{typ: "unarchiveDataReview", unarchiveDataReview: &v}
}

type CheckAlertsHistogramBuckets struct {
	typ       string
	unstacked *CheckAlertsUnstackedHistogram
	priority  *CheckAlertsPriorityHistogram
	status    *CheckAlertsStatusHistogram
}

type checkAlertsHistogramBucketsDeserializer struct {
	Type      string                         `json:"type"`
	Unstacked *CheckAlertsUnstackedHistogram `json:"unstacked"`
	Priority  *CheckAlertsPriorityHistogram  `json:"priority"`
	Status    *CheckAlertsStatusHistogram    `json:"status"`
}

func (u *checkAlertsHistogramBucketsDeserializer) toStruct() CheckAlertsHistogramBuckets {
	return CheckAlertsHistogramBuckets{typ: u.Type, unstacked: u.Unstacked, priority: u.Priority, status: u.Status}
}

func (u *CheckAlertsHistogramBuckets) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "unstacked":
		if u.unstacked == nil {
			return nil, fmt.Errorf("field \"unstacked\" is required")
		}
		return struct {
			Type      string                        `json:"type"`
			Unstacked CheckAlertsUnstackedHistogram `json:"unstacked"`
		}{Type: "unstacked", Unstacked: *u.unstacked}, nil
	case "priority":
		if u.priority == nil {
			return nil, fmt.Errorf("field \"priority\" is required")
		}
		return struct {
			Type     string                       `json:"type"`
			Priority CheckAlertsPriorityHistogram `json:"priority"`
		}{Type: "priority", Priority: *u.priority}, nil
	case "status":
		if u.status == nil {
			return nil, fmt.Errorf("field \"status\" is required")
		}
		return struct {
			Type   string                     `json:"type"`
			Status CheckAlertsStatusHistogram `json:"status"`
		}{Type: "status", Status: *u.status}, nil
	}
}

func (u CheckAlertsHistogramBuckets) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CheckAlertsHistogramBuckets) UnmarshalJSON(data []byte) error {
	var deser checkAlertsHistogramBucketsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "unstacked":
		if u.unstacked == nil {
			return fmt.Errorf("field \"unstacked\" is required")
		}
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
	case "status":
		if u.status == nil {
			return fmt.Errorf("field \"status\" is required")
		}
	}
	return nil
}

func (u CheckAlertsHistogramBuckets) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CheckAlertsHistogramBuckets) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CheckAlertsHistogramBuckets) AcceptFuncs(unstackedFunc func(CheckAlertsUnstackedHistogram) error, priorityFunc func(CheckAlertsPriorityHistogram) error, statusFunc func(CheckAlertsStatusHistogram) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "unstacked":
		if u.unstacked == nil {
			return fmt.Errorf("field \"unstacked\" is required")
		}
		return unstackedFunc(*u.unstacked)
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
		return priorityFunc(*u.priority)
	case "status":
		if u.status == nil {
			return fmt.Errorf("field \"status\" is required")
		}
		return statusFunc(*u.status)
	}
}

func (u *CheckAlertsHistogramBuckets) UnstackedNoopSuccess(CheckAlertsUnstackedHistogram) error {
	return nil
}

func (u *CheckAlertsHistogramBuckets) PriorityNoopSuccess(CheckAlertsPriorityHistogram) error {
	return nil
}

func (u *CheckAlertsHistogramBuckets) StatusNoopSuccess(CheckAlertsStatusHistogram) error {
	return nil
}

func (u *CheckAlertsHistogramBuckets) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CheckAlertsHistogramBuckets) Accept(v CheckAlertsHistogramBucketsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "unstacked":
		if u.unstacked == nil {
			return fmt.Errorf("field \"unstacked\" is required")
		}
		return v.VisitUnstacked(*u.unstacked)
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
		return v.VisitPriority(*u.priority)
	case "status":
		if u.status == nil {
			return fmt.Errorf("field \"status\" is required")
		}
		return v.VisitStatus(*u.status)
	}
}

type CheckAlertsHistogramBucketsVisitor interface {
	VisitUnstacked(v CheckAlertsUnstackedHistogram) error
	VisitPriority(v CheckAlertsPriorityHistogram) error
	VisitStatus(v CheckAlertsStatusHistogram) error
	VisitUnknown(typeName string) error
}

func (u *CheckAlertsHistogramBuckets) AcceptWithContext(ctx context.Context, v CheckAlertsHistogramBucketsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "unstacked":
		if u.unstacked == nil {
			return fmt.Errorf("field \"unstacked\" is required")
		}
		return v.VisitUnstackedWithContext(ctx, *u.unstacked)
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
		return v.VisitPriorityWithContext(ctx, *u.priority)
	case "status":
		if u.status == nil {
			return fmt.Errorf("field \"status\" is required")
		}
		return v.VisitStatusWithContext(ctx, *u.status)
	}
}

type CheckAlertsHistogramBucketsVisitorWithContext interface {
	VisitUnstackedWithContext(ctx context.Context, v CheckAlertsUnstackedHistogram) error
	VisitPriorityWithContext(ctx context.Context, v CheckAlertsPriorityHistogram) error
	VisitStatusWithContext(ctx context.Context, v CheckAlertsStatusHistogram) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCheckAlertsHistogramBucketsFromUnstacked(v CheckAlertsUnstackedHistogram) CheckAlertsHistogramBuckets {
	return CheckAlertsHistogramBuckets{typ: "unstacked", unstacked: &v}
}

func NewCheckAlertsHistogramBucketsFromPriority(v CheckAlertsPriorityHistogram) CheckAlertsHistogramBuckets {
	return CheckAlertsHistogramBuckets{typ: "priority", priority: &v}
}

func NewCheckAlertsHistogramBucketsFromStatus(v CheckAlertsStatusHistogram) CheckAlertsHistogramBuckets {
	return CheckAlertsHistogramBuckets{typ: "status", status: &v}
}

type CheckEvaluation struct {
	typ            string
	automaticCheck *AutomaticCheckEvaluation
	manualCheck    *ManualCheckEvaluation
}

type checkEvaluationDeserializer struct {
	Type           string                    `json:"type"`
	AutomaticCheck *AutomaticCheckEvaluation `json:"automaticCheck"`
	ManualCheck    *ManualCheckEvaluation    `json:"manualCheck"`
}

func (u *checkEvaluationDeserializer) toStruct() CheckEvaluation {
	return CheckEvaluation{typ: u.Type, automaticCheck: u.AutomaticCheck, manualCheck: u.ManualCheck}
}

func (u *CheckEvaluation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "automaticCheck":
		if u.automaticCheck == nil {
			return nil, fmt.Errorf("field \"automaticCheck\" is required")
		}
		return struct {
			Type           string                   `json:"type"`
			AutomaticCheck AutomaticCheckEvaluation `json:"automaticCheck"`
		}{Type: "automaticCheck", AutomaticCheck: *u.automaticCheck}, nil
	case "manualCheck":
		if u.manualCheck == nil {
			return nil, fmt.Errorf("field \"manualCheck\" is required")
		}
		return struct {
			Type        string                `json:"type"`
			ManualCheck ManualCheckEvaluation `json:"manualCheck"`
		}{Type: "manualCheck", ManualCheck: *u.manualCheck}, nil
	}
}

func (u CheckEvaluation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CheckEvaluation) UnmarshalJSON(data []byte) error {
	var deser checkEvaluationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "automaticCheck":
		if u.automaticCheck == nil {
			return fmt.Errorf("field \"automaticCheck\" is required")
		}
	case "manualCheck":
		if u.manualCheck == nil {
			return fmt.Errorf("field \"manualCheck\" is required")
		}
	}
	return nil
}

func (u CheckEvaluation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CheckEvaluation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CheckEvaluation) AcceptFuncs(automaticCheckFunc func(AutomaticCheckEvaluation) error, manualCheckFunc func(ManualCheckEvaluation) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "automaticCheck":
		if u.automaticCheck == nil {
			return fmt.Errorf("field \"automaticCheck\" is required")
		}
		return automaticCheckFunc(*u.automaticCheck)
	case "manualCheck":
		if u.manualCheck == nil {
			return fmt.Errorf("field \"manualCheck\" is required")
		}
		return manualCheckFunc(*u.manualCheck)
	}
}

func (u *CheckEvaluation) AutomaticCheckNoopSuccess(AutomaticCheckEvaluation) error {
	return nil
}

func (u *CheckEvaluation) ManualCheckNoopSuccess(ManualCheckEvaluation) error {
	return nil
}

func (u *CheckEvaluation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CheckEvaluation) Accept(v CheckEvaluationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "automaticCheck":
		if u.automaticCheck == nil {
			return fmt.Errorf("field \"automaticCheck\" is required")
		}
		return v.VisitAutomaticCheck(*u.automaticCheck)
	case "manualCheck":
		if u.manualCheck == nil {
			return fmt.Errorf("field \"manualCheck\" is required")
		}
		return v.VisitManualCheck(*u.manualCheck)
	}
}

type CheckEvaluationVisitor interface {
	VisitAutomaticCheck(v AutomaticCheckEvaluation) error
	VisitManualCheck(v ManualCheckEvaluation) error
	VisitUnknown(typeName string) error
}

func (u *CheckEvaluation) AcceptWithContext(ctx context.Context, v CheckEvaluationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "automaticCheck":
		if u.automaticCheck == nil {
			return fmt.Errorf("field \"automaticCheck\" is required")
		}
		return v.VisitAutomaticCheckWithContext(ctx, *u.automaticCheck)
	case "manualCheck":
		if u.manualCheck == nil {
			return fmt.Errorf("field \"manualCheck\" is required")
		}
		return v.VisitManualCheckWithContext(ctx, *u.manualCheck)
	}
}

type CheckEvaluationVisitorWithContext interface {
	VisitAutomaticCheckWithContext(ctx context.Context, v AutomaticCheckEvaluation) error
	VisitManualCheckWithContext(ctx context.Context, v ManualCheckEvaluation) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCheckEvaluationFromAutomaticCheck(v AutomaticCheckEvaluation) CheckEvaluation {
	return CheckEvaluation{typ: "automaticCheck", automaticCheck: &v}
}

func NewCheckEvaluationFromManualCheck(v ManualCheckEvaluation) CheckEvaluation {
	return CheckEvaluation{typ: "manualCheck", manualCheck: &v}
}

type CloseAction struct {
	typ                    string
	closeWithIgnore        *CloseWithIgnoreAlert
	closeWithFurtherAction *CloseWithFurtherAction
}

type closeActionDeserializer struct {
	Type                   string                  `json:"type"`
	CloseWithIgnore        *CloseWithIgnoreAlert   `json:"closeWithIgnore"`
	CloseWithFurtherAction *CloseWithFurtherAction `json:"closeWithFurtherAction"`
}

func (u *closeActionDeserializer) toStruct() CloseAction {
	return CloseAction{typ: u.Type, closeWithIgnore: u.CloseWithIgnore, closeWithFurtherAction: u.CloseWithFurtherAction}
}

func (u *CloseAction) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return nil, fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return struct {
			Type            string               `json:"type"`
			CloseWithIgnore CloseWithIgnoreAlert `json:"closeWithIgnore"`
		}{Type: "closeWithIgnore", CloseWithIgnore: *u.closeWithIgnore}, nil
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return nil, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return struct {
			Type                   string                 `json:"type"`
			CloseWithFurtherAction CloseWithFurtherAction `json:"closeWithFurtherAction"`
		}{Type: "closeWithFurtherAction", CloseWithFurtherAction: *u.closeWithFurtherAction}, nil
	}
}

func (u CloseAction) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CloseAction) UnmarshalJSON(data []byte) error {
	var deser closeActionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
	}
	return nil
}

func (u CloseAction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CloseAction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CloseAction) AcceptFuncs(closeWithIgnoreFunc func(CloseWithIgnoreAlert) error, closeWithFurtherActionFunc func(CloseWithFurtherAction) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return closeWithIgnoreFunc(*u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return closeWithFurtherActionFunc(*u.closeWithFurtherAction)
	}
}

func (u *CloseAction) CloseWithIgnoreNoopSuccess(CloseWithIgnoreAlert) error {
	return nil
}

func (u *CloseAction) CloseWithFurtherActionNoopSuccess(CloseWithFurtherAction) error {
	return nil
}

func (u *CloseAction) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CloseAction) Accept(v CloseActionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return v.VisitCloseWithIgnore(*u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherAction(*u.closeWithFurtherAction)
	}
}

type CloseActionVisitor interface {
	VisitCloseWithIgnore(v CloseWithIgnoreAlert) error
	VisitCloseWithFurtherAction(v CloseWithFurtherAction) error
	VisitUnknown(typeName string) error
}

func (u *CloseAction) AcceptWithContext(ctx context.Context, v CloseActionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return v.VisitCloseWithIgnoreWithContext(ctx, *u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherActionWithContext(ctx, *u.closeWithFurtherAction)
	}
}

type CloseActionVisitorWithContext interface {
	VisitCloseWithIgnoreWithContext(ctx context.Context, v CloseWithIgnoreAlert) error
	VisitCloseWithFurtherActionWithContext(ctx context.Context, v CloseWithFurtherAction) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCloseActionFromCloseWithIgnore(v CloseWithIgnoreAlert) CloseAction {
	return CloseAction{typ: "closeWithIgnore", closeWithIgnore: &v}
}

func NewCloseActionFromCloseWithFurtherAction(v CloseWithFurtherAction) CloseAction {
	return CloseAction{typ: "closeWithFurtherAction", closeWithFurtherAction: &v}
}

type CloseStrategy struct {
	typ                                       string
	closeAllLinkedAlerts                      *CloseAllLinkedAlerts
	closeAndDetachFromNotebook                *CloseAndDetachFromNotebook
	closeAndDuplicatePreviouslyLinkedNotebook *CloseAndDuplicatePreviouslyLinkedNotebook
}

type closeStrategyDeserializer struct {
	Type                                      string                                     `json:"type"`
	CloseAllLinkedAlerts                      *CloseAllLinkedAlerts                      `json:"closeAllLinkedAlerts"`
	CloseAndDetachFromNotebook                *CloseAndDetachFromNotebook                `json:"closeAndDetachFromNotebook"`
	CloseAndDuplicatePreviouslyLinkedNotebook *CloseAndDuplicatePreviouslyLinkedNotebook `json:"closeAndDuplicatePreviouslyLinkedNotebook"`
}

func (u *closeStrategyDeserializer) toStruct() CloseStrategy {
	return CloseStrategy{typ: u.Type, closeAllLinkedAlerts: u.CloseAllLinkedAlerts, closeAndDetachFromNotebook: u.CloseAndDetachFromNotebook, closeAndDuplicatePreviouslyLinkedNotebook: u.CloseAndDuplicatePreviouslyLinkedNotebook}
}

func (u *CloseStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "closeAllLinkedAlerts":
		if u.closeAllLinkedAlerts == nil {
			return nil, fmt.Errorf("field \"closeAllLinkedAlerts\" is required")
		}
		return struct {
			Type                 string               `json:"type"`
			CloseAllLinkedAlerts CloseAllLinkedAlerts `json:"closeAllLinkedAlerts"`
		}{Type: "closeAllLinkedAlerts", CloseAllLinkedAlerts: *u.closeAllLinkedAlerts}, nil
	case "closeAndDetachFromNotebook":
		if u.closeAndDetachFromNotebook == nil {
			return nil, fmt.Errorf("field \"closeAndDetachFromNotebook\" is required")
		}
		return struct {
			Type                       string                     `json:"type"`
			CloseAndDetachFromNotebook CloseAndDetachFromNotebook `json:"closeAndDetachFromNotebook"`
		}{Type: "closeAndDetachFromNotebook", CloseAndDetachFromNotebook: *u.closeAndDetachFromNotebook}, nil
	case "closeAndDuplicatePreviouslyLinkedNotebook":
		if u.closeAndDuplicatePreviouslyLinkedNotebook == nil {
			return nil, fmt.Errorf("field \"closeAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return struct {
			Type                                      string                                    `json:"type"`
			CloseAndDuplicatePreviouslyLinkedNotebook CloseAndDuplicatePreviouslyLinkedNotebook `json:"closeAndDuplicatePreviouslyLinkedNotebook"`
		}{Type: "closeAndDuplicatePreviouslyLinkedNotebook", CloseAndDuplicatePreviouslyLinkedNotebook: *u.closeAndDuplicatePreviouslyLinkedNotebook}, nil
	}
}

func (u CloseStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *CloseStrategy) UnmarshalJSON(data []byte) error {
	var deser closeStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "closeAllLinkedAlerts":
		if u.closeAllLinkedAlerts == nil {
			return fmt.Errorf("field \"closeAllLinkedAlerts\" is required")
		}
	case "closeAndDetachFromNotebook":
		if u.closeAndDetachFromNotebook == nil {
			return fmt.Errorf("field \"closeAndDetachFromNotebook\" is required")
		}
	case "closeAndDuplicatePreviouslyLinkedNotebook":
		if u.closeAndDuplicatePreviouslyLinkedNotebook == nil {
			return fmt.Errorf("field \"closeAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
	}
	return nil
}

func (u CloseStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *CloseStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *CloseStrategy) AcceptFuncs(closeAllLinkedAlertsFunc func(CloseAllLinkedAlerts) error, closeAndDetachFromNotebookFunc func(CloseAndDetachFromNotebook) error, closeAndDuplicatePreviouslyLinkedNotebookFunc func(CloseAndDuplicatePreviouslyLinkedNotebook) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "closeAllLinkedAlerts":
		if u.closeAllLinkedAlerts == nil {
			return fmt.Errorf("field \"closeAllLinkedAlerts\" is required")
		}
		return closeAllLinkedAlertsFunc(*u.closeAllLinkedAlerts)
	case "closeAndDetachFromNotebook":
		if u.closeAndDetachFromNotebook == nil {
			return fmt.Errorf("field \"closeAndDetachFromNotebook\" is required")
		}
		return closeAndDetachFromNotebookFunc(*u.closeAndDetachFromNotebook)
	case "closeAndDuplicatePreviouslyLinkedNotebook":
		if u.closeAndDuplicatePreviouslyLinkedNotebook == nil {
			return fmt.Errorf("field \"closeAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return closeAndDuplicatePreviouslyLinkedNotebookFunc(*u.closeAndDuplicatePreviouslyLinkedNotebook)
	}
}

func (u *CloseStrategy) CloseAllLinkedAlertsNoopSuccess(CloseAllLinkedAlerts) error {
	return nil
}

func (u *CloseStrategy) CloseAndDetachFromNotebookNoopSuccess(CloseAndDetachFromNotebook) error {
	return nil
}

func (u *CloseStrategy) CloseAndDuplicatePreviouslyLinkedNotebookNoopSuccess(CloseAndDuplicatePreviouslyLinkedNotebook) error {
	return nil
}

func (u *CloseStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *CloseStrategy) Accept(v CloseStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "closeAllLinkedAlerts":
		if u.closeAllLinkedAlerts == nil {
			return fmt.Errorf("field \"closeAllLinkedAlerts\" is required")
		}
		return v.VisitCloseAllLinkedAlerts(*u.closeAllLinkedAlerts)
	case "closeAndDetachFromNotebook":
		if u.closeAndDetachFromNotebook == nil {
			return fmt.Errorf("field \"closeAndDetachFromNotebook\" is required")
		}
		return v.VisitCloseAndDetachFromNotebook(*u.closeAndDetachFromNotebook)
	case "closeAndDuplicatePreviouslyLinkedNotebook":
		if u.closeAndDuplicatePreviouslyLinkedNotebook == nil {
			return fmt.Errorf("field \"closeAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return v.VisitCloseAndDuplicatePreviouslyLinkedNotebook(*u.closeAndDuplicatePreviouslyLinkedNotebook)
	}
}

type CloseStrategyVisitor interface {
	VisitCloseAllLinkedAlerts(v CloseAllLinkedAlerts) error
	VisitCloseAndDetachFromNotebook(v CloseAndDetachFromNotebook) error
	VisitCloseAndDuplicatePreviouslyLinkedNotebook(v CloseAndDuplicatePreviouslyLinkedNotebook) error
	VisitUnknown(typeName string) error
}

func (u *CloseStrategy) AcceptWithContext(ctx context.Context, v CloseStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "closeAllLinkedAlerts":
		if u.closeAllLinkedAlerts == nil {
			return fmt.Errorf("field \"closeAllLinkedAlerts\" is required")
		}
		return v.VisitCloseAllLinkedAlertsWithContext(ctx, *u.closeAllLinkedAlerts)
	case "closeAndDetachFromNotebook":
		if u.closeAndDetachFromNotebook == nil {
			return fmt.Errorf("field \"closeAndDetachFromNotebook\" is required")
		}
		return v.VisitCloseAndDetachFromNotebookWithContext(ctx, *u.closeAndDetachFromNotebook)
	case "closeAndDuplicatePreviouslyLinkedNotebook":
		if u.closeAndDuplicatePreviouslyLinkedNotebook == nil {
			return fmt.Errorf("field \"closeAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return v.VisitCloseAndDuplicatePreviouslyLinkedNotebookWithContext(ctx, *u.closeAndDuplicatePreviouslyLinkedNotebook)
	}
}

type CloseStrategyVisitorWithContext interface {
	VisitCloseAllLinkedAlertsWithContext(ctx context.Context, v CloseAllLinkedAlerts) error
	VisitCloseAndDetachFromNotebookWithContext(ctx context.Context, v CloseAndDetachFromNotebook) error
	VisitCloseAndDuplicatePreviouslyLinkedNotebookWithContext(ctx context.Context, v CloseAndDuplicatePreviouslyLinkedNotebook) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewCloseStrategyFromCloseAllLinkedAlerts(v CloseAllLinkedAlerts) CloseStrategy {
	return CloseStrategy{typ: "closeAllLinkedAlerts", closeAllLinkedAlerts: &v}
}

func NewCloseStrategyFromCloseAndDetachFromNotebook(v CloseAndDetachFromNotebook) CloseStrategy {
	return CloseStrategy{typ: "closeAndDetachFromNotebook", closeAndDetachFromNotebook: &v}
}

func NewCloseStrategyFromCloseAndDuplicatePreviouslyLinkedNotebook(v CloseAndDuplicatePreviouslyLinkedNotebook) CloseStrategy {
	return CloseStrategy{typ: "closeAndDuplicatePreviouslyLinkedNotebook", closeAndDuplicatePreviouslyLinkedNotebook: &v}
}

type DataReviewCheckMetricsScope struct {
	typ           string
	runRid        *api.RunRid
	assetRid      *api1.AssetRid
	dataReviewRid *api1.DataReviewRid
}

type dataReviewCheckMetricsScopeDeserializer struct {
	Type          string              `json:"type"`
	RunRid        *api.RunRid         `json:"runRid"`
	AssetRid      *api1.AssetRid      `json:"assetRid"`
	DataReviewRid *api1.DataReviewRid `json:"dataReviewRid"`
}

func (u *dataReviewCheckMetricsScopeDeserializer) toStruct() DataReviewCheckMetricsScope {
	return DataReviewCheckMetricsScope{typ: u.Type, runRid: u.RunRid, assetRid: u.AssetRid, dataReviewRid: u.DataReviewRid}
}

func (u *DataReviewCheckMetricsScope) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "runRid":
		if u.runRid == nil {
			return nil, fmt.Errorf("field \"runRid\" is required")
		}
		return struct {
			Type   string     `json:"type"`
			RunRid api.RunRid `json:"runRid"`
		}{Type: "runRid", RunRid: *u.runRid}, nil
	case "assetRid":
		if u.assetRid == nil {
			return nil, fmt.Errorf("field \"assetRid\" is required")
		}
		return struct {
			Type     string        `json:"type"`
			AssetRid api1.AssetRid `json:"assetRid"`
		}{Type: "assetRid", AssetRid: *u.assetRid}, nil
	case "dataReviewRid":
		if u.dataReviewRid == nil {
			return nil, fmt.Errorf("field \"dataReviewRid\" is required")
		}
		return struct {
			Type          string             `json:"type"`
			DataReviewRid api1.DataReviewRid `json:"dataReviewRid"`
		}{Type: "dataReviewRid", DataReviewRid: *u.dataReviewRid}, nil
	}
}

func (u DataReviewCheckMetricsScope) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DataReviewCheckMetricsScope) UnmarshalJSON(data []byte) error {
	var deser dataReviewCheckMetricsScopeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "runRid":
		if u.runRid == nil {
			return fmt.Errorf("field \"runRid\" is required")
		}
	case "assetRid":
		if u.assetRid == nil {
			return fmt.Errorf("field \"assetRid\" is required")
		}
	case "dataReviewRid":
		if u.dataReviewRid == nil {
			return fmt.Errorf("field \"dataReviewRid\" is required")
		}
	}
	return nil
}

func (u DataReviewCheckMetricsScope) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DataReviewCheckMetricsScope) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DataReviewCheckMetricsScope) AcceptFuncs(runRidFunc func(api.RunRid) error, assetRidFunc func(api1.AssetRid) error, dataReviewRidFunc func(api1.DataReviewRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "runRid":
		if u.runRid == nil {
			return fmt.Errorf("field \"runRid\" is required")
		}
		return runRidFunc(*u.runRid)
	case "assetRid":
		if u.assetRid == nil {
			return fmt.Errorf("field \"assetRid\" is required")
		}
		return assetRidFunc(*u.assetRid)
	case "dataReviewRid":
		if u.dataReviewRid == nil {
			return fmt.Errorf("field \"dataReviewRid\" is required")
		}
		return dataReviewRidFunc(*u.dataReviewRid)
	}
}

func (u *DataReviewCheckMetricsScope) RunRidNoopSuccess(api.RunRid) error {
	return nil
}

func (u *DataReviewCheckMetricsScope) AssetRidNoopSuccess(api1.AssetRid) error {
	return nil
}

func (u *DataReviewCheckMetricsScope) DataReviewRidNoopSuccess(api1.DataReviewRid) error {
	return nil
}

func (u *DataReviewCheckMetricsScope) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DataReviewCheckMetricsScope) Accept(v DataReviewCheckMetricsScopeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "runRid":
		if u.runRid == nil {
			return fmt.Errorf("field \"runRid\" is required")
		}
		return v.VisitRunRid(*u.runRid)
	case "assetRid":
		if u.assetRid == nil {
			return fmt.Errorf("field \"assetRid\" is required")
		}
		return v.VisitAssetRid(*u.assetRid)
	case "dataReviewRid":
		if u.dataReviewRid == nil {
			return fmt.Errorf("field \"dataReviewRid\" is required")
		}
		return v.VisitDataReviewRid(*u.dataReviewRid)
	}
}

type DataReviewCheckMetricsScopeVisitor interface {
	VisitRunRid(v api.RunRid) error
	VisitAssetRid(v api1.AssetRid) error
	VisitDataReviewRid(v api1.DataReviewRid) error
	VisitUnknown(typeName string) error
}

func (u *DataReviewCheckMetricsScope) AcceptWithContext(ctx context.Context, v DataReviewCheckMetricsScopeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "runRid":
		if u.runRid == nil {
			return fmt.Errorf("field \"runRid\" is required")
		}
		return v.VisitRunRidWithContext(ctx, *u.runRid)
	case "assetRid":
		if u.assetRid == nil {
			return fmt.Errorf("field \"assetRid\" is required")
		}
		return v.VisitAssetRidWithContext(ctx, *u.assetRid)
	case "dataReviewRid":
		if u.dataReviewRid == nil {
			return fmt.Errorf("field \"dataReviewRid\" is required")
		}
		return v.VisitDataReviewRidWithContext(ctx, *u.dataReviewRid)
	}
}

type DataReviewCheckMetricsScopeVisitorWithContext interface {
	VisitRunRidWithContext(ctx context.Context, v api.RunRid) error
	VisitAssetRidWithContext(ctx context.Context, v api1.AssetRid) error
	VisitDataReviewRidWithContext(ctx context.Context, v api1.DataReviewRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDataReviewCheckMetricsScopeFromRunRid(v api.RunRid) DataReviewCheckMetricsScope {
	return DataReviewCheckMetricsScope{typ: "runRid", runRid: &v}
}

func NewDataReviewCheckMetricsScopeFromAssetRid(v api1.AssetRid) DataReviewCheckMetricsScope {
	return DataReviewCheckMetricsScope{typ: "assetRid", assetRid: &v}
}

func NewDataReviewCheckMetricsScopeFromDataReviewRid(v api1.DataReviewRid) DataReviewCheckMetricsScope {
	return DataReviewCheckMetricsScope{typ: "dataReviewRid", dataReviewRid: &v}
}

type HistogramDistributionVariable struct {
	typ       string
	startTime *HistogramStartTimeVariable
}

type histogramDistributionVariableDeserializer struct {
	Type      string                      `json:"type"`
	StartTime *HistogramStartTimeVariable `json:"startTime"`
}

func (u *histogramDistributionVariableDeserializer) toStruct() HistogramDistributionVariable {
	return HistogramDistributionVariable{typ: u.Type, startTime: u.StartTime}
}

func (u *HistogramDistributionVariable) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "startTime":
		if u.startTime == nil {
			return nil, fmt.Errorf("field \"startTime\" is required")
		}
		return struct {
			Type      string                     `json:"type"`
			StartTime HistogramStartTimeVariable `json:"startTime"`
		}{Type: "startTime", StartTime: *u.startTime}, nil
	}
}

func (u HistogramDistributionVariable) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *HistogramDistributionVariable) UnmarshalJSON(data []byte) error {
	var deser histogramDistributionVariableDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "startTime":
		if u.startTime == nil {
			return fmt.Errorf("field \"startTime\" is required")
		}
	}
	return nil
}

func (u HistogramDistributionVariable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *HistogramDistributionVariable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *HistogramDistributionVariable) AcceptFuncs(startTimeFunc func(HistogramStartTimeVariable) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "startTime":
		if u.startTime == nil {
			return fmt.Errorf("field \"startTime\" is required")
		}
		return startTimeFunc(*u.startTime)
	}
}

func (u *HistogramDistributionVariable) StartTimeNoopSuccess(HistogramStartTimeVariable) error {
	return nil
}

func (u *HistogramDistributionVariable) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *HistogramDistributionVariable) Accept(v HistogramDistributionVariableVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "startTime":
		if u.startTime == nil {
			return fmt.Errorf("field \"startTime\" is required")
		}
		return v.VisitStartTime(*u.startTime)
	}
}

type HistogramDistributionVariableVisitor interface {
	VisitStartTime(v HistogramStartTimeVariable) error
	VisitUnknown(typeName string) error
}

func (u *HistogramDistributionVariable) AcceptWithContext(ctx context.Context, v HistogramDistributionVariableVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "startTime":
		if u.startTime == nil {
			return fmt.Errorf("field \"startTime\" is required")
		}
		return v.VisitStartTimeWithContext(ctx, *u.startTime)
	}
}

type HistogramDistributionVariableVisitorWithContext interface {
	VisitStartTimeWithContext(ctx context.Context, v HistogramStartTimeVariable) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewHistogramDistributionVariableFromStartTime(v HistogramStartTimeVariable) HistogramDistributionVariable {
	return HistogramDistributionVariable{typ: "startTime", startTime: &v}
}

type HistogramSubGroupVariable struct {
	typ      string
	priority *HistogramPriorityVariable
	status   *HistogramStatusVariable
}

type histogramSubGroupVariableDeserializer struct {
	Type     string                     `json:"type"`
	Priority *HistogramPriorityVariable `json:"priority"`
	Status   *HistogramStatusVariable   `json:"status"`
}

func (u *histogramSubGroupVariableDeserializer) toStruct() HistogramSubGroupVariable {
	return HistogramSubGroupVariable{typ: u.Type, priority: u.Priority, status: u.Status}
}

func (u *HistogramSubGroupVariable) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "priority":
		if u.priority == nil {
			return nil, fmt.Errorf("field \"priority\" is required")
		}
		return struct {
			Type     string                    `json:"type"`
			Priority HistogramPriorityVariable `json:"priority"`
		}{Type: "priority", Priority: *u.priority}, nil
	case "status":
		if u.status == nil {
			return nil, fmt.Errorf("field \"status\" is required")
		}
		return struct {
			Type   string                  `json:"type"`
			Status HistogramStatusVariable `json:"status"`
		}{Type: "status", Status: *u.status}, nil
	}
}

func (u HistogramSubGroupVariable) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *HistogramSubGroupVariable) UnmarshalJSON(data []byte) error {
	var deser histogramSubGroupVariableDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
	case "status":
		if u.status == nil {
			return fmt.Errorf("field \"status\" is required")
		}
	}
	return nil
}

func (u HistogramSubGroupVariable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *HistogramSubGroupVariable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *HistogramSubGroupVariable) AcceptFuncs(priorityFunc func(HistogramPriorityVariable) error, statusFunc func(HistogramStatusVariable) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
		return priorityFunc(*u.priority)
	case "status":
		if u.status == nil {
			return fmt.Errorf("field \"status\" is required")
		}
		return statusFunc(*u.status)
	}
}

func (u *HistogramSubGroupVariable) PriorityNoopSuccess(HistogramPriorityVariable) error {
	return nil
}

func (u *HistogramSubGroupVariable) StatusNoopSuccess(HistogramStatusVariable) error {
	return nil
}

func (u *HistogramSubGroupVariable) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *HistogramSubGroupVariable) Accept(v HistogramSubGroupVariableVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
		return v.VisitPriority(*u.priority)
	case "status":
		if u.status == nil {
			return fmt.Errorf("field \"status\" is required")
		}
		return v.VisitStatus(*u.status)
	}
}

type HistogramSubGroupVariableVisitor interface {
	VisitPriority(v HistogramPriorityVariable) error
	VisitStatus(v HistogramStatusVariable) error
	VisitUnknown(typeName string) error
}

func (u *HistogramSubGroupVariable) AcceptWithContext(ctx context.Context, v HistogramSubGroupVariableVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "priority":
		if u.priority == nil {
			return fmt.Errorf("field \"priority\" is required")
		}
		return v.VisitPriorityWithContext(ctx, *u.priority)
	case "status":
		if u.status == nil {
			return fmt.Errorf("field \"status\" is required")
		}
		return v.VisitStatusWithContext(ctx, *u.status)
	}
}

type HistogramSubGroupVariableVisitorWithContext interface {
	VisitPriorityWithContext(ctx context.Context, v HistogramPriorityVariable) error
	VisitStatusWithContext(ctx context.Context, v HistogramStatusVariable) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewHistogramSubGroupVariableFromPriority(v HistogramPriorityVariable) HistogramSubGroupVariable {
	return HistogramSubGroupVariable{typ: "priority", priority: &v}
}

func NewHistogramSubGroupVariableFromStatus(v HistogramStatusVariable) HistogramSubGroupVariable {
	return HistogramSubGroupVariable{typ: "status", status: &v}
}

type LinkNotebookStrategy struct {
	typ                           string
	duplicateAndLinkToNewNotebook *DuplicateAndLinkNotebook
	closeAndLink                  *CloseAndLinkToNotebook
	reopenAndLink                 *ReopenAndLinkToNotebook
}

type linkNotebookStrategyDeserializer struct {
	Type                          string                    `json:"type"`
	DuplicateAndLinkToNewNotebook *DuplicateAndLinkNotebook `json:"duplicateAndLinkToNewNotebook"`
	CloseAndLink                  *CloseAndLinkToNotebook   `json:"closeAndLink"`
	ReopenAndLink                 *ReopenAndLinkToNotebook  `json:"reopenAndLink"`
}

func (u *linkNotebookStrategyDeserializer) toStruct() LinkNotebookStrategy {
	return LinkNotebookStrategy{typ: u.Type, duplicateAndLinkToNewNotebook: u.DuplicateAndLinkToNewNotebook, closeAndLink: u.CloseAndLink, reopenAndLink: u.ReopenAndLink}
}

func (u *LinkNotebookStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "duplicateAndLinkToNewNotebook":
		if u.duplicateAndLinkToNewNotebook == nil {
			return nil, fmt.Errorf("field \"duplicateAndLinkToNewNotebook\" is required")
		}
		return struct {
			Type                          string                   `json:"type"`
			DuplicateAndLinkToNewNotebook DuplicateAndLinkNotebook `json:"duplicateAndLinkToNewNotebook"`
		}{Type: "duplicateAndLinkToNewNotebook", DuplicateAndLinkToNewNotebook: *u.duplicateAndLinkToNewNotebook}, nil
	case "closeAndLink":
		if u.closeAndLink == nil {
			return nil, fmt.Errorf("field \"closeAndLink\" is required")
		}
		return struct {
			Type         string                 `json:"type"`
			CloseAndLink CloseAndLinkToNotebook `json:"closeAndLink"`
		}{Type: "closeAndLink", CloseAndLink: *u.closeAndLink}, nil
	case "reopenAndLink":
		if u.reopenAndLink == nil {
			return nil, fmt.Errorf("field \"reopenAndLink\" is required")
		}
		return struct {
			Type          string                  `json:"type"`
			ReopenAndLink ReopenAndLinkToNotebook `json:"reopenAndLink"`
		}{Type: "reopenAndLink", ReopenAndLink: *u.reopenAndLink}, nil
	}
}

func (u LinkNotebookStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LinkNotebookStrategy) UnmarshalJSON(data []byte) error {
	var deser linkNotebookStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "duplicateAndLinkToNewNotebook":
		if u.duplicateAndLinkToNewNotebook == nil {
			return fmt.Errorf("field \"duplicateAndLinkToNewNotebook\" is required")
		}
	case "closeAndLink":
		if u.closeAndLink == nil {
			return fmt.Errorf("field \"closeAndLink\" is required")
		}
	case "reopenAndLink":
		if u.reopenAndLink == nil {
			return fmt.Errorf("field \"reopenAndLink\" is required")
		}
	}
	return nil
}

func (u LinkNotebookStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LinkNotebookStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LinkNotebookStrategy) AcceptFuncs(duplicateAndLinkToNewNotebookFunc func(DuplicateAndLinkNotebook) error, closeAndLinkFunc func(CloseAndLinkToNotebook) error, reopenAndLinkFunc func(ReopenAndLinkToNotebook) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "duplicateAndLinkToNewNotebook":
		if u.duplicateAndLinkToNewNotebook == nil {
			return fmt.Errorf("field \"duplicateAndLinkToNewNotebook\" is required")
		}
		return duplicateAndLinkToNewNotebookFunc(*u.duplicateAndLinkToNewNotebook)
	case "closeAndLink":
		if u.closeAndLink == nil {
			return fmt.Errorf("field \"closeAndLink\" is required")
		}
		return closeAndLinkFunc(*u.closeAndLink)
	case "reopenAndLink":
		if u.reopenAndLink == nil {
			return fmt.Errorf("field \"reopenAndLink\" is required")
		}
		return reopenAndLinkFunc(*u.reopenAndLink)
	}
}

func (u *LinkNotebookStrategy) DuplicateAndLinkToNewNotebookNoopSuccess(DuplicateAndLinkNotebook) error {
	return nil
}

func (u *LinkNotebookStrategy) CloseAndLinkNoopSuccess(CloseAndLinkToNotebook) error {
	return nil
}

func (u *LinkNotebookStrategy) ReopenAndLinkNoopSuccess(ReopenAndLinkToNotebook) error {
	return nil
}

func (u *LinkNotebookStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LinkNotebookStrategy) Accept(v LinkNotebookStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "duplicateAndLinkToNewNotebook":
		if u.duplicateAndLinkToNewNotebook == nil {
			return fmt.Errorf("field \"duplicateAndLinkToNewNotebook\" is required")
		}
		return v.VisitDuplicateAndLinkToNewNotebook(*u.duplicateAndLinkToNewNotebook)
	case "closeAndLink":
		if u.closeAndLink == nil {
			return fmt.Errorf("field \"closeAndLink\" is required")
		}
		return v.VisitCloseAndLink(*u.closeAndLink)
	case "reopenAndLink":
		if u.reopenAndLink == nil {
			return fmt.Errorf("field \"reopenAndLink\" is required")
		}
		return v.VisitReopenAndLink(*u.reopenAndLink)
	}
}

type LinkNotebookStrategyVisitor interface {
	VisitDuplicateAndLinkToNewNotebook(v DuplicateAndLinkNotebook) error
	VisitCloseAndLink(v CloseAndLinkToNotebook) error
	VisitReopenAndLink(v ReopenAndLinkToNotebook) error
	VisitUnknown(typeName string) error
}

func (u *LinkNotebookStrategy) AcceptWithContext(ctx context.Context, v LinkNotebookStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "duplicateAndLinkToNewNotebook":
		if u.duplicateAndLinkToNewNotebook == nil {
			return fmt.Errorf("field \"duplicateAndLinkToNewNotebook\" is required")
		}
		return v.VisitDuplicateAndLinkToNewNotebookWithContext(ctx, *u.duplicateAndLinkToNewNotebook)
	case "closeAndLink":
		if u.closeAndLink == nil {
			return fmt.Errorf("field \"closeAndLink\" is required")
		}
		return v.VisitCloseAndLinkWithContext(ctx, *u.closeAndLink)
	case "reopenAndLink":
		if u.reopenAndLink == nil {
			return fmt.Errorf("field \"reopenAndLink\" is required")
		}
		return v.VisitReopenAndLinkWithContext(ctx, *u.reopenAndLink)
	}
}

type LinkNotebookStrategyVisitorWithContext interface {
	VisitDuplicateAndLinkToNewNotebookWithContext(ctx context.Context, v DuplicateAndLinkNotebook) error
	VisitCloseAndLinkWithContext(ctx context.Context, v CloseAndLinkToNotebook) error
	VisitReopenAndLinkWithContext(ctx context.Context, v ReopenAndLinkToNotebook) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLinkNotebookStrategyFromDuplicateAndLinkToNewNotebook(v DuplicateAndLinkNotebook) LinkNotebookStrategy {
	return LinkNotebookStrategy{typ: "duplicateAndLinkToNewNotebook", duplicateAndLinkToNewNotebook: &v}
}

func NewLinkNotebookStrategyFromCloseAndLink(v CloseAndLinkToNotebook) LinkNotebookStrategy {
	return LinkNotebookStrategy{typ: "closeAndLink", closeAndLink: &v}
}

func NewLinkNotebookStrategyFromReopenAndLink(v ReopenAndLinkToNotebook) LinkNotebookStrategy {
	return LinkNotebookStrategy{typ: "reopenAndLink", reopenAndLink: &v}
}

type ManualCheckAlertAction struct {
	typ                    string
	pass                   *Pass
	closeWithFurtherAction *CloseWithFurtherAction
	reopen                 *Reopen
	reassign               *Reassign
	updateNotes            *UpdateNotes
	linkNotebook           *LinkNotebook
}

type manualCheckAlertActionDeserializer struct {
	Type                   string                  `json:"type"`
	Pass                   *Pass                   `json:"pass"`
	CloseWithFurtherAction *CloseWithFurtherAction `json:"closeWithFurtherAction"`
	Reopen                 *Reopen                 `json:"reopen"`
	Reassign               *Reassign               `json:"reassign"`
	UpdateNotes            *UpdateNotes            `json:"updateNotes"`
	LinkNotebook           *LinkNotebook           `json:"linkNotebook"`
}

func (u *manualCheckAlertActionDeserializer) toStruct() ManualCheckAlertAction {
	return ManualCheckAlertAction{typ: u.Type, pass: u.Pass, closeWithFurtherAction: u.CloseWithFurtherAction, reopen: u.Reopen, reassign: u.Reassign, updateNotes: u.UpdateNotes, linkNotebook: u.LinkNotebook}
}

func (u *ManualCheckAlertAction) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "pass":
		if u.pass == nil {
			return nil, fmt.Errorf("field \"pass\" is required")
		}
		return struct {
			Type string `json:"type"`
			Pass Pass   `json:"pass"`
		}{Type: "pass", Pass: *u.pass}, nil
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return nil, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return struct {
			Type                   string                 `json:"type"`
			CloseWithFurtherAction CloseWithFurtherAction `json:"closeWithFurtherAction"`
		}{Type: "closeWithFurtherAction", CloseWithFurtherAction: *u.closeWithFurtherAction}, nil
	case "reopen":
		if u.reopen == nil {
			return nil, fmt.Errorf("field \"reopen\" is required")
		}
		return struct {
			Type   string `json:"type"`
			Reopen Reopen `json:"reopen"`
		}{Type: "reopen", Reopen: *u.reopen}, nil
	case "reassign":
		if u.reassign == nil {
			return nil, fmt.Errorf("field \"reassign\" is required")
		}
		return struct {
			Type     string   `json:"type"`
			Reassign Reassign `json:"reassign"`
		}{Type: "reassign", Reassign: *u.reassign}, nil
	case "updateNotes":
		if u.updateNotes == nil {
			return nil, fmt.Errorf("field \"updateNotes\" is required")
		}
		return struct {
			Type        string      `json:"type"`
			UpdateNotes UpdateNotes `json:"updateNotes"`
		}{Type: "updateNotes", UpdateNotes: *u.updateNotes}, nil
	case "linkNotebook":
		if u.linkNotebook == nil {
			return nil, fmt.Errorf("field \"linkNotebook\" is required")
		}
		return struct {
			Type         string       `json:"type"`
			LinkNotebook LinkNotebook `json:"linkNotebook"`
		}{Type: "linkNotebook", LinkNotebook: *u.linkNotebook}, nil
	}
}

func (u ManualCheckAlertAction) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ManualCheckAlertAction) UnmarshalJSON(data []byte) error {
	var deser manualCheckAlertActionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "pass":
		if u.pass == nil {
			return fmt.Errorf("field \"pass\" is required")
		}
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
	case "linkNotebook":
		if u.linkNotebook == nil {
			return fmt.Errorf("field \"linkNotebook\" is required")
		}
	}
	return nil
}

func (u ManualCheckAlertAction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ManualCheckAlertAction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ManualCheckAlertAction) AcceptFuncs(passFunc func(Pass) error, closeWithFurtherActionFunc func(CloseWithFurtherAction) error, reopenFunc func(Reopen) error, reassignFunc func(Reassign) error, updateNotesFunc func(UpdateNotes) error, linkNotebookFunc func(LinkNotebook) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pass":
		if u.pass == nil {
			return fmt.Errorf("field \"pass\" is required")
		}
		return passFunc(*u.pass)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return closeWithFurtherActionFunc(*u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
		return reopenFunc(*u.reopen)
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
		return reassignFunc(*u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
		return updateNotesFunc(*u.updateNotes)
	case "linkNotebook":
		if u.linkNotebook == nil {
			return fmt.Errorf("field \"linkNotebook\" is required")
		}
		return linkNotebookFunc(*u.linkNotebook)
	}
}

func (u *ManualCheckAlertAction) PassNoopSuccess(Pass) error {
	return nil
}

func (u *ManualCheckAlertAction) CloseWithFurtherActionNoopSuccess(CloseWithFurtherAction) error {
	return nil
}

func (u *ManualCheckAlertAction) ReopenNoopSuccess(Reopen) error {
	return nil
}

func (u *ManualCheckAlertAction) ReassignNoopSuccess(Reassign) error {
	return nil
}

func (u *ManualCheckAlertAction) UpdateNotesNoopSuccess(UpdateNotes) error {
	return nil
}

func (u *ManualCheckAlertAction) LinkNotebookNoopSuccess(LinkNotebook) error {
	return nil
}

func (u *ManualCheckAlertAction) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ManualCheckAlertAction) Accept(v ManualCheckAlertActionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "pass":
		if u.pass == nil {
			return fmt.Errorf("field \"pass\" is required")
		}
		return v.VisitPass(*u.pass)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherAction(*u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
		return v.VisitReopen(*u.reopen)
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
		return v.VisitReassign(*u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
		return v.VisitUpdateNotes(*u.updateNotes)
	case "linkNotebook":
		if u.linkNotebook == nil {
			return fmt.Errorf("field \"linkNotebook\" is required")
		}
		return v.VisitLinkNotebook(*u.linkNotebook)
	}
}

type ManualCheckAlertActionVisitor interface {
	VisitPass(v Pass) error
	VisitCloseWithFurtherAction(v CloseWithFurtherAction) error
	VisitReopen(v Reopen) error
	VisitReassign(v Reassign) error
	VisitUpdateNotes(v UpdateNotes) error
	VisitLinkNotebook(v LinkNotebook) error
	VisitUnknown(typeName string) error
}

func (u *ManualCheckAlertAction) AcceptWithContext(ctx context.Context, v ManualCheckAlertActionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "pass":
		if u.pass == nil {
			return fmt.Errorf("field \"pass\" is required")
		}
		return v.VisitPassWithContext(ctx, *u.pass)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherActionWithContext(ctx, *u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return fmt.Errorf("field \"reopen\" is required")
		}
		return v.VisitReopenWithContext(ctx, *u.reopen)
	case "reassign":
		if u.reassign == nil {
			return fmt.Errorf("field \"reassign\" is required")
		}
		return v.VisitReassignWithContext(ctx, *u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return fmt.Errorf("field \"updateNotes\" is required")
		}
		return v.VisitUpdateNotesWithContext(ctx, *u.updateNotes)
	case "linkNotebook":
		if u.linkNotebook == nil {
			return fmt.Errorf("field \"linkNotebook\" is required")
		}
		return v.VisitLinkNotebookWithContext(ctx, *u.linkNotebook)
	}
}

type ManualCheckAlertActionVisitorWithContext interface {
	VisitPassWithContext(ctx context.Context, v Pass) error
	VisitCloseWithFurtherActionWithContext(ctx context.Context, v CloseWithFurtherAction) error
	VisitReopenWithContext(ctx context.Context, v Reopen) error
	VisitReassignWithContext(ctx context.Context, v Reassign) error
	VisitUpdateNotesWithContext(ctx context.Context, v UpdateNotes) error
	VisitLinkNotebookWithContext(ctx context.Context, v LinkNotebook) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewManualCheckAlertActionFromPass(v Pass) ManualCheckAlertAction {
	return ManualCheckAlertAction{typ: "pass", pass: &v}
}

func NewManualCheckAlertActionFromCloseWithFurtherAction(v CloseWithFurtherAction) ManualCheckAlertAction {
	return ManualCheckAlertAction{typ: "closeWithFurtherAction", closeWithFurtherAction: &v}
}

func NewManualCheckAlertActionFromReopen(v Reopen) ManualCheckAlertAction {
	return ManualCheckAlertAction{typ: "reopen", reopen: &v}
}

func NewManualCheckAlertActionFromReassign(v Reassign) ManualCheckAlertAction {
	return ManualCheckAlertAction{typ: "reassign", reassign: &v}
}

func NewManualCheckAlertActionFromUpdateNotes(v UpdateNotes) ManualCheckAlertAction {
	return ManualCheckAlertAction{typ: "updateNotes", updateNotes: &v}
}

func NewManualCheckAlertActionFromLinkNotebook(v LinkNotebook) ManualCheckAlertAction {
	return ManualCheckAlertAction{typ: "linkNotebook", linkNotebook: &v}
}

type ManualCheckEvaluationState struct {
	typ                     string
	pendingReview           *PendingReviewState
	closedWithFurtherAction *ClosedWithFurtherActionState
	passing                 *PassState
}

type manualCheckEvaluationStateDeserializer struct {
	Type                    string                        `json:"type"`
	PendingReview           *PendingReviewState           `json:"pendingReview"`
	ClosedWithFurtherAction *ClosedWithFurtherActionState `json:"closedWithFurtherAction"`
	Passing                 *PassState                    `json:"passing"`
}

func (u *manualCheckEvaluationStateDeserializer) toStruct() ManualCheckEvaluationState {
	return ManualCheckEvaluationState{typ: u.Type, pendingReview: u.PendingReview, closedWithFurtherAction: u.ClosedWithFurtherAction, passing: u.Passing}
}

func (u *ManualCheckEvaluationState) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return nil, fmt.Errorf("field \"pendingReview\" is required")
		}
		return struct {
			Type          string             `json:"type"`
			PendingReview PendingReviewState `json:"pendingReview"`
		}{Type: "pendingReview", PendingReview: *u.pendingReview}, nil
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return nil, fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return struct {
			Type                    string                       `json:"type"`
			ClosedWithFurtherAction ClosedWithFurtherActionState `json:"closedWithFurtherAction"`
		}{Type: "closedWithFurtherAction", ClosedWithFurtherAction: *u.closedWithFurtherAction}, nil
	case "passing":
		if u.passing == nil {
			return nil, fmt.Errorf("field \"passing\" is required")
		}
		return struct {
			Type    string    `json:"type"`
			Passing PassState `json:"passing"`
		}{Type: "passing", Passing: *u.passing}, nil
	}
}

func (u ManualCheckEvaluationState) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ManualCheckEvaluationState) UnmarshalJSON(data []byte) error {
	var deser manualCheckEvaluationStateDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "pendingReview":
		if u.pendingReview == nil {
			return fmt.Errorf("field \"pendingReview\" is required")
		}
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
	case "passing":
		if u.passing == nil {
			return fmt.Errorf("field \"passing\" is required")
		}
	}
	return nil
}

func (u ManualCheckEvaluationState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ManualCheckEvaluationState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ManualCheckEvaluationState) AcceptFuncs(pendingReviewFunc func(PendingReviewState) error, closedWithFurtherActionFunc func(ClosedWithFurtherActionState) error, passingFunc func(PassState) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return fmt.Errorf("field \"pendingReview\" is required")
		}
		return pendingReviewFunc(*u.pendingReview)
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return closedWithFurtherActionFunc(*u.closedWithFurtherAction)
	case "passing":
		if u.passing == nil {
			return fmt.Errorf("field \"passing\" is required")
		}
		return passingFunc(*u.passing)
	}
}

func (u *ManualCheckEvaluationState) PendingReviewNoopSuccess(PendingReviewState) error {
	return nil
}

func (u *ManualCheckEvaluationState) ClosedWithFurtherActionNoopSuccess(ClosedWithFurtherActionState) error {
	return nil
}

func (u *ManualCheckEvaluationState) PassingNoopSuccess(PassState) error {
	return nil
}

func (u *ManualCheckEvaluationState) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ManualCheckEvaluationState) Accept(v ManualCheckEvaluationStateVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return fmt.Errorf("field \"pendingReview\" is required")
		}
		return v.VisitPendingReview(*u.pendingReview)
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return v.VisitClosedWithFurtherAction(*u.closedWithFurtherAction)
	case "passing":
		if u.passing == nil {
			return fmt.Errorf("field \"passing\" is required")
		}
		return v.VisitPassing(*u.passing)
	}
}

type ManualCheckEvaluationStateVisitor interface {
	VisitPendingReview(v PendingReviewState) error
	VisitClosedWithFurtherAction(v ClosedWithFurtherActionState) error
	VisitPassing(v PassState) error
	VisitUnknown(typeName string) error
}

func (u *ManualCheckEvaluationState) AcceptWithContext(ctx context.Context, v ManualCheckEvaluationStateVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return fmt.Errorf("field \"pendingReview\" is required")
		}
		return v.VisitPendingReviewWithContext(ctx, *u.pendingReview)
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return v.VisitClosedWithFurtherActionWithContext(ctx, *u.closedWithFurtherAction)
	case "passing":
		if u.passing == nil {
			return fmt.Errorf("field \"passing\" is required")
		}
		return v.VisitPassingWithContext(ctx, *u.passing)
	}
}

type ManualCheckEvaluationStateVisitorWithContext interface {
	VisitPendingReviewWithContext(ctx context.Context, v PendingReviewState) error
	VisitClosedWithFurtherActionWithContext(ctx context.Context, v ClosedWithFurtherActionState) error
	VisitPassingWithContext(ctx context.Context, v PassState) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewManualCheckEvaluationStateFromPendingReview(v PendingReviewState) ManualCheckEvaluationState {
	return ManualCheckEvaluationState{typ: "pendingReview", pendingReview: &v}
}

func NewManualCheckEvaluationStateFromClosedWithFurtherAction(v ClosedWithFurtherActionState) ManualCheckEvaluationState {
	return ManualCheckEvaluationState{typ: "closedWithFurtherAction", closedWithFurtherAction: &v}
}

func NewManualCheckEvaluationStateFromPassing(v PassState) ManualCheckEvaluationState {
	return ManualCheckEvaluationState{typ: "passing", passing: &v}
}

type ReopenStrategy struct {
	typ                                        string
	reopenAllLinkedAlerts                      *ReopenAllLinkedAlerts
	reopenAndDetachFromNotebook                *ReopenAndDetachFromNotebook
	reopenAndDuplicatePreviouslyLinkedNotebook *ReopenAndDuplicatePreviouslyLinkedNotebook
}

type reopenStrategyDeserializer struct {
	Type                                       string                                      `json:"type"`
	ReopenAllLinkedAlerts                      *ReopenAllLinkedAlerts                      `json:"reopenAllLinkedAlerts"`
	ReopenAndDetachFromNotebook                *ReopenAndDetachFromNotebook                `json:"reopenAndDetachFromNotebook"`
	ReopenAndDuplicatePreviouslyLinkedNotebook *ReopenAndDuplicatePreviouslyLinkedNotebook `json:"reopenAndDuplicatePreviouslyLinkedNotebook"`
}

func (u *reopenStrategyDeserializer) toStruct() ReopenStrategy {
	return ReopenStrategy{typ: u.Type, reopenAllLinkedAlerts: u.ReopenAllLinkedAlerts, reopenAndDetachFromNotebook: u.ReopenAndDetachFromNotebook, reopenAndDuplicatePreviouslyLinkedNotebook: u.ReopenAndDuplicatePreviouslyLinkedNotebook}
}

func (u *ReopenStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "reopenAllLinkedAlerts":
		if u.reopenAllLinkedAlerts == nil {
			return nil, fmt.Errorf("field \"reopenAllLinkedAlerts\" is required")
		}
		return struct {
			Type                  string                `json:"type"`
			ReopenAllLinkedAlerts ReopenAllLinkedAlerts `json:"reopenAllLinkedAlerts"`
		}{Type: "reopenAllLinkedAlerts", ReopenAllLinkedAlerts: *u.reopenAllLinkedAlerts}, nil
	case "reopenAndDetachFromNotebook":
		if u.reopenAndDetachFromNotebook == nil {
			return nil, fmt.Errorf("field \"reopenAndDetachFromNotebook\" is required")
		}
		return struct {
			Type                        string                      `json:"type"`
			ReopenAndDetachFromNotebook ReopenAndDetachFromNotebook `json:"reopenAndDetachFromNotebook"`
		}{Type: "reopenAndDetachFromNotebook", ReopenAndDetachFromNotebook: *u.reopenAndDetachFromNotebook}, nil
	case "reopenAndDuplicatePreviouslyLinkedNotebook":
		if u.reopenAndDuplicatePreviouslyLinkedNotebook == nil {
			return nil, fmt.Errorf("field \"reopenAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return struct {
			Type                                       string                                     `json:"type"`
			ReopenAndDuplicatePreviouslyLinkedNotebook ReopenAndDuplicatePreviouslyLinkedNotebook `json:"reopenAndDuplicatePreviouslyLinkedNotebook"`
		}{Type: "reopenAndDuplicatePreviouslyLinkedNotebook", ReopenAndDuplicatePreviouslyLinkedNotebook: *u.reopenAndDuplicatePreviouslyLinkedNotebook}, nil
	}
}

func (u ReopenStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ReopenStrategy) UnmarshalJSON(data []byte) error {
	var deser reopenStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "reopenAllLinkedAlerts":
		if u.reopenAllLinkedAlerts == nil {
			return fmt.Errorf("field \"reopenAllLinkedAlerts\" is required")
		}
	case "reopenAndDetachFromNotebook":
		if u.reopenAndDetachFromNotebook == nil {
			return fmt.Errorf("field \"reopenAndDetachFromNotebook\" is required")
		}
	case "reopenAndDuplicatePreviouslyLinkedNotebook":
		if u.reopenAndDuplicatePreviouslyLinkedNotebook == nil {
			return fmt.Errorf("field \"reopenAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
	}
	return nil
}

func (u ReopenStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ReopenStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ReopenStrategy) AcceptFuncs(reopenAllLinkedAlertsFunc func(ReopenAllLinkedAlerts) error, reopenAndDetachFromNotebookFunc func(ReopenAndDetachFromNotebook) error, reopenAndDuplicatePreviouslyLinkedNotebookFunc func(ReopenAndDuplicatePreviouslyLinkedNotebook) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "reopenAllLinkedAlerts":
		if u.reopenAllLinkedAlerts == nil {
			return fmt.Errorf("field \"reopenAllLinkedAlerts\" is required")
		}
		return reopenAllLinkedAlertsFunc(*u.reopenAllLinkedAlerts)
	case "reopenAndDetachFromNotebook":
		if u.reopenAndDetachFromNotebook == nil {
			return fmt.Errorf("field \"reopenAndDetachFromNotebook\" is required")
		}
		return reopenAndDetachFromNotebookFunc(*u.reopenAndDetachFromNotebook)
	case "reopenAndDuplicatePreviouslyLinkedNotebook":
		if u.reopenAndDuplicatePreviouslyLinkedNotebook == nil {
			return fmt.Errorf("field \"reopenAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return reopenAndDuplicatePreviouslyLinkedNotebookFunc(*u.reopenAndDuplicatePreviouslyLinkedNotebook)
	}
}

func (u *ReopenStrategy) ReopenAllLinkedAlertsNoopSuccess(ReopenAllLinkedAlerts) error {
	return nil
}

func (u *ReopenStrategy) ReopenAndDetachFromNotebookNoopSuccess(ReopenAndDetachFromNotebook) error {
	return nil
}

func (u *ReopenStrategy) ReopenAndDuplicatePreviouslyLinkedNotebookNoopSuccess(ReopenAndDuplicatePreviouslyLinkedNotebook) error {
	return nil
}

func (u *ReopenStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ReopenStrategy) Accept(v ReopenStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "reopenAllLinkedAlerts":
		if u.reopenAllLinkedAlerts == nil {
			return fmt.Errorf("field \"reopenAllLinkedAlerts\" is required")
		}
		return v.VisitReopenAllLinkedAlerts(*u.reopenAllLinkedAlerts)
	case "reopenAndDetachFromNotebook":
		if u.reopenAndDetachFromNotebook == nil {
			return fmt.Errorf("field \"reopenAndDetachFromNotebook\" is required")
		}
		return v.VisitReopenAndDetachFromNotebook(*u.reopenAndDetachFromNotebook)
	case "reopenAndDuplicatePreviouslyLinkedNotebook":
		if u.reopenAndDuplicatePreviouslyLinkedNotebook == nil {
			return fmt.Errorf("field \"reopenAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return v.VisitReopenAndDuplicatePreviouslyLinkedNotebook(*u.reopenAndDuplicatePreviouslyLinkedNotebook)
	}
}

type ReopenStrategyVisitor interface {
	VisitReopenAllLinkedAlerts(v ReopenAllLinkedAlerts) error
	VisitReopenAndDetachFromNotebook(v ReopenAndDetachFromNotebook) error
	VisitReopenAndDuplicatePreviouslyLinkedNotebook(v ReopenAndDuplicatePreviouslyLinkedNotebook) error
	VisitUnknown(typeName string) error
}

func (u *ReopenStrategy) AcceptWithContext(ctx context.Context, v ReopenStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "reopenAllLinkedAlerts":
		if u.reopenAllLinkedAlerts == nil {
			return fmt.Errorf("field \"reopenAllLinkedAlerts\" is required")
		}
		return v.VisitReopenAllLinkedAlertsWithContext(ctx, *u.reopenAllLinkedAlerts)
	case "reopenAndDetachFromNotebook":
		if u.reopenAndDetachFromNotebook == nil {
			return fmt.Errorf("field \"reopenAndDetachFromNotebook\" is required")
		}
		return v.VisitReopenAndDetachFromNotebookWithContext(ctx, *u.reopenAndDetachFromNotebook)
	case "reopenAndDuplicatePreviouslyLinkedNotebook":
		if u.reopenAndDuplicatePreviouslyLinkedNotebook == nil {
			return fmt.Errorf("field \"reopenAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return v.VisitReopenAndDuplicatePreviouslyLinkedNotebookWithContext(ctx, *u.reopenAndDuplicatePreviouslyLinkedNotebook)
	}
}

type ReopenStrategyVisitorWithContext interface {
	VisitReopenAllLinkedAlertsWithContext(ctx context.Context, v ReopenAllLinkedAlerts) error
	VisitReopenAndDetachFromNotebookWithContext(ctx context.Context, v ReopenAndDetachFromNotebook) error
	VisitReopenAndDuplicatePreviouslyLinkedNotebookWithContext(ctx context.Context, v ReopenAndDuplicatePreviouslyLinkedNotebook) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewReopenStrategyFromReopenAllLinkedAlerts(v ReopenAllLinkedAlerts) ReopenStrategy {
	return ReopenStrategy{typ: "reopenAllLinkedAlerts", reopenAllLinkedAlerts: &v}
}

func NewReopenStrategyFromReopenAndDetachFromNotebook(v ReopenAndDetachFromNotebook) ReopenStrategy {
	return ReopenStrategy{typ: "reopenAndDetachFromNotebook", reopenAndDetachFromNotebook: &v}
}

func NewReopenStrategyFromReopenAndDuplicatePreviouslyLinkedNotebook(v ReopenAndDuplicatePreviouslyLinkedNotebook) ReopenStrategy {
	return ReopenStrategy{typ: "reopenAndDuplicatePreviouslyLinkedNotebook", reopenAndDuplicatePreviouslyLinkedNotebook: &v}
}
