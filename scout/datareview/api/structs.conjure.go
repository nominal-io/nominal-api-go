// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	api3 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	api4 "github.com/nominal-io/nominal-api-go/scout/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/checks/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/integrations/api"
	"github.com/nominal-io/nominal-api-go/scout/rids/api"
	api5 "github.com/nominal-io/nominal-api-go/scout/run/api"
	api6 "github.com/nominal-io/nominal-api-go/scout/versioning/api"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

/*
Archive the data review which created this check alert. Only performable via the archive data review endpoint;
not supported by Perform Check Alert Action.
*/
type ArchiveDataReview struct{}

func (o ArchiveDataReview) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ArchiveDataReview) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AutomaticCheckEvaluation struct {
	Rid      rids.AutomaticCheckEvaluationRid `json:"rid"`
	CheckRid api.CheckRid                     `json:"checkRid"`
	/*
	   Checks can define a single range computation which can evaluate over multiple implementations of a context.
	   The check implementation index will correspond to the implementation index of the check condition.
	*/
	CheckImplementationIndex *int                          `conjure-docs:"Checks can define a single range computation which can evaluate over multiple implementations of a context.\nThe check implementation index will correspond to the implementation index of the check condition." json:"checkImplementationIndex,omitempty"`
	DataReviewRid            api.DataReviewRid             `json:"dataReviewRid"`
	State                    AutomaticCheckEvaluationState `json:"state"`
}

func (o AutomaticCheckEvaluation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AutomaticCheckEvaluation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AutomaticCheckEvaluationActionLog struct {
	Entries []AutomaticCheckEvaluationActionLogEntry `json:"entries"`
}

func (o AutomaticCheckEvaluationActionLog) MarshalJSON() ([]byte, error) {
	if o.Entries == nil {
		o.Entries = make([]AutomaticCheckEvaluationActionLogEntry, 0)
	}
	type _tmpAutomaticCheckEvaluationActionLog AutomaticCheckEvaluationActionLog
	return safejson.Marshal(_tmpAutomaticCheckEvaluationActionLog(o))
}

func (o *AutomaticCheckEvaluationActionLog) UnmarshalJSON(data []byte) error {
	type _tmpAutomaticCheckEvaluationActionLog AutomaticCheckEvaluationActionLog
	var rawAutomaticCheckEvaluationActionLog _tmpAutomaticCheckEvaluationActionLog
	if err := safejson.Unmarshal(data, &rawAutomaticCheckEvaluationActionLog); err != nil {
		return err
	}
	if rawAutomaticCheckEvaluationActionLog.Entries == nil {
		rawAutomaticCheckEvaluationActionLog.Entries = make([]AutomaticCheckEvaluationActionLogEntry, 0)
	}
	*o = AutomaticCheckEvaluationActionLog(rawAutomaticCheckEvaluationActionLog)
	return nil
}

func (o AutomaticCheckEvaluationActionLog) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AutomaticCheckEvaluationActionLog) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AutomaticCheckEvaluationActionLogEntry struct {
	Action    AutomaticCheckEvaluationAction `json:"action"`
	Timestamp datetime.DateTime              `json:"timestamp"`
}

func (o AutomaticCheckEvaluationActionLogEntry) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AutomaticCheckEvaluationActionLogEntry) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AutomaticCheckEvaluationReviewActionLog struct {
	Entries []AutomaticCheckEvaluationReviewActionLogEntry `json:"entries"`
}

func (o AutomaticCheckEvaluationReviewActionLog) MarshalJSON() ([]byte, error) {
	if o.Entries == nil {
		o.Entries = make([]AutomaticCheckEvaluationReviewActionLogEntry, 0)
	}
	type _tmpAutomaticCheckEvaluationReviewActionLog AutomaticCheckEvaluationReviewActionLog
	return safejson.Marshal(_tmpAutomaticCheckEvaluationReviewActionLog(o))
}

func (o *AutomaticCheckEvaluationReviewActionLog) UnmarshalJSON(data []byte) error {
	type _tmpAutomaticCheckEvaluationReviewActionLog AutomaticCheckEvaluationReviewActionLog
	var rawAutomaticCheckEvaluationReviewActionLog _tmpAutomaticCheckEvaluationReviewActionLog
	if err := safejson.Unmarshal(data, &rawAutomaticCheckEvaluationReviewActionLog); err != nil {
		return err
	}
	if rawAutomaticCheckEvaluationReviewActionLog.Entries == nil {
		rawAutomaticCheckEvaluationReviewActionLog.Entries = make([]AutomaticCheckEvaluationReviewActionLogEntry, 0)
	}
	*o = AutomaticCheckEvaluationReviewActionLog(rawAutomaticCheckEvaluationReviewActionLog)
	return nil
}

func (o AutomaticCheckEvaluationReviewActionLog) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AutomaticCheckEvaluationReviewActionLog) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AutomaticCheckEvaluationReviewActionLogEntry struct {
	PerformedBy api.UserRid                          `json:"performedBy"`
	Action      AutomaticCheckEvaluationReviewAction `json:"action"`
	Timestamp   datetime.DateTime                    `json:"timestamp"`
}

func (o AutomaticCheckEvaluationReviewActionLogEntry) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AutomaticCheckEvaluationReviewActionLogEntry) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AutomaticCheckExecutionFailedToRun struct {
	JobRid api1.JobRid `json:"jobRid"`
}

func (o AutomaticCheckExecutionFailedToRun) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AutomaticCheckExecutionFailedToRun) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AutomaticCheckExecutionFinished struct {
	JobRid api1.JobRid `json:"jobRid"`
	Status Status      `json:"status"`
}

func (o AutomaticCheckExecutionFinished) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AutomaticCheckExecutionFinished) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type AutomaticCheckExecutionStarted struct {
	JobRid api1.JobRid `json:"jobRid"`
}

func (o AutomaticCheckExecutionStarted) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AutomaticCheckExecutionStarted) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchAutomaticCheckEvaluationActionRequest struct {
	CheckEvaluationAction AutomaticCheckEvaluationReviewAction `json:"checkEvaluationAction"`
	CheckEvaluationRids   []rids.AutomaticCheckEvaluationRid   `json:"checkEvaluationRids"`
}

func (o BatchAutomaticCheckEvaluationActionRequest) MarshalJSON() ([]byte, error) {
	if o.CheckEvaluationRids == nil {
		o.CheckEvaluationRids = make([]rids.AutomaticCheckEvaluationRid, 0)
	}
	type _tmpBatchAutomaticCheckEvaluationActionRequest BatchAutomaticCheckEvaluationActionRequest
	return safejson.Marshal(_tmpBatchAutomaticCheckEvaluationActionRequest(o))
}

func (o *BatchAutomaticCheckEvaluationActionRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchAutomaticCheckEvaluationActionRequest BatchAutomaticCheckEvaluationActionRequest
	var rawBatchAutomaticCheckEvaluationActionRequest _tmpBatchAutomaticCheckEvaluationActionRequest
	if err := safejson.Unmarshal(data, &rawBatchAutomaticCheckEvaluationActionRequest); err != nil {
		return err
	}
	if rawBatchAutomaticCheckEvaluationActionRequest.CheckEvaluationRids == nil {
		rawBatchAutomaticCheckEvaluationActionRequest.CheckEvaluationRids = make([]rids.AutomaticCheckEvaluationRid, 0)
	}
	*o = BatchAutomaticCheckEvaluationActionRequest(rawBatchAutomaticCheckEvaluationActionRequest)
	return nil
}

func (o BatchAutomaticCheckEvaluationActionRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchAutomaticCheckEvaluationActionRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchAutomaticCheckEvaluationActionResponse struct {
	CheckEvaluations []AutomaticCheckEvaluation `json:"checkEvaluations"`
}

func (o BatchAutomaticCheckEvaluationActionResponse) MarshalJSON() ([]byte, error) {
	if o.CheckEvaluations == nil {
		o.CheckEvaluations = make([]AutomaticCheckEvaluation, 0)
	}
	type _tmpBatchAutomaticCheckEvaluationActionResponse BatchAutomaticCheckEvaluationActionResponse
	return safejson.Marshal(_tmpBatchAutomaticCheckEvaluationActionResponse(o))
}

func (o *BatchAutomaticCheckEvaluationActionResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchAutomaticCheckEvaluationActionResponse BatchAutomaticCheckEvaluationActionResponse
	var rawBatchAutomaticCheckEvaluationActionResponse _tmpBatchAutomaticCheckEvaluationActionResponse
	if err := safejson.Unmarshal(data, &rawBatchAutomaticCheckEvaluationActionResponse); err != nil {
		return err
	}
	if rawBatchAutomaticCheckEvaluationActionResponse.CheckEvaluations == nil {
		rawBatchAutomaticCheckEvaluationActionResponse.CheckEvaluations = make([]AutomaticCheckEvaluation, 0)
	}
	*o = BatchAutomaticCheckEvaluationActionResponse(rawBatchAutomaticCheckEvaluationActionResponse)
	return nil
}

func (o BatchAutomaticCheckEvaluationActionResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchAutomaticCheckEvaluationActionResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchCheckAlertActionRequest struct {
	CheckAlertAction CheckAlertAction    `json:"checkAlertAction"`
	CheckAlertRids   []api.CheckAlertRid `json:"checkAlertRids"`
}

func (o BatchCheckAlertActionRequest) MarshalJSON() ([]byte, error) {
	if o.CheckAlertRids == nil {
		o.CheckAlertRids = make([]api.CheckAlertRid, 0)
	}
	type _tmpBatchCheckAlertActionRequest BatchCheckAlertActionRequest
	return safejson.Marshal(_tmpBatchCheckAlertActionRequest(o))
}

func (o *BatchCheckAlertActionRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchCheckAlertActionRequest BatchCheckAlertActionRequest
	var rawBatchCheckAlertActionRequest _tmpBatchCheckAlertActionRequest
	if err := safejson.Unmarshal(data, &rawBatchCheckAlertActionRequest); err != nil {
		return err
	}
	if rawBatchCheckAlertActionRequest.CheckAlertRids == nil {
		rawBatchCheckAlertActionRequest.CheckAlertRids = make([]api.CheckAlertRid, 0)
	}
	*o = BatchCheckAlertActionRequest(rawBatchCheckAlertActionRequest)
	return nil
}

func (o BatchCheckAlertActionRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchCheckAlertActionRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchCheckAlertActionResponse struct {
	CheckAlerts []CheckAlert `json:"checkAlerts"`
}

func (o BatchCheckAlertActionResponse) MarshalJSON() ([]byte, error) {
	if o.CheckAlerts == nil {
		o.CheckAlerts = make([]CheckAlert, 0)
	}
	type _tmpBatchCheckAlertActionResponse BatchCheckAlertActionResponse
	return safejson.Marshal(_tmpBatchCheckAlertActionResponse(o))
}

func (o *BatchCheckAlertActionResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchCheckAlertActionResponse BatchCheckAlertActionResponse
	var rawBatchCheckAlertActionResponse _tmpBatchCheckAlertActionResponse
	if err := safejson.Unmarshal(data, &rawBatchCheckAlertActionResponse); err != nil {
		return err
	}
	if rawBatchCheckAlertActionResponse.CheckAlerts == nil {
		rawBatchCheckAlertActionResponse.CheckAlerts = make([]CheckAlert, 0)
	}
	*o = BatchCheckAlertActionResponse(rawBatchCheckAlertActionResponse)
	return nil
}

func (o BatchCheckAlertActionResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchCheckAlertActionResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchInitiateDataReviewRequest struct {
	Requests []CreateDataReviewRequest `json:"requests"`
	// If provided, checklist violations will be sent to the specified integrations.
	NotificationConfigurations []api2.NotificationConfiguration `conjure-docs:"If provided, checklist violations will be sent to the specified integrations." json:"notificationConfigurations"`
}

func (o BatchInitiateDataReviewRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]CreateDataReviewRequest, 0)
	}
	if o.NotificationConfigurations == nil {
		o.NotificationConfigurations = make([]api2.NotificationConfiguration, 0)
	}
	type _tmpBatchInitiateDataReviewRequest BatchInitiateDataReviewRequest
	return safejson.Marshal(_tmpBatchInitiateDataReviewRequest(o))
}

func (o *BatchInitiateDataReviewRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchInitiateDataReviewRequest BatchInitiateDataReviewRequest
	var rawBatchInitiateDataReviewRequest _tmpBatchInitiateDataReviewRequest
	if err := safejson.Unmarshal(data, &rawBatchInitiateDataReviewRequest); err != nil {
		return err
	}
	if rawBatchInitiateDataReviewRequest.Requests == nil {
		rawBatchInitiateDataReviewRequest.Requests = make([]CreateDataReviewRequest, 0)
	}
	if rawBatchInitiateDataReviewRequest.NotificationConfigurations == nil {
		rawBatchInitiateDataReviewRequest.NotificationConfigurations = make([]api2.NotificationConfiguration, 0)
	}
	*o = BatchInitiateDataReviewRequest(rawBatchInitiateDataReviewRequest)
	return nil
}

func (o BatchInitiateDataReviewRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchInitiateDataReviewRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Responses are returned in the same order as the requests.
type BatchInitiateDataReviewResponse struct {
	Rids []api.DataReviewRid `json:"rids"`
}

func (o BatchInitiateDataReviewResponse) MarshalJSON() ([]byte, error) {
	if o.Rids == nil {
		o.Rids = make([]api.DataReviewRid, 0)
	}
	type _tmpBatchInitiateDataReviewResponse BatchInitiateDataReviewResponse
	return safejson.Marshal(_tmpBatchInitiateDataReviewResponse(o))
}

func (o *BatchInitiateDataReviewResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchInitiateDataReviewResponse BatchInitiateDataReviewResponse
	var rawBatchInitiateDataReviewResponse _tmpBatchInitiateDataReviewResponse
	if err := safejson.Unmarshal(data, &rawBatchInitiateDataReviewResponse); err != nil {
		return err
	}
	if rawBatchInitiateDataReviewResponse.Rids == nil {
		rawBatchInitiateDataReviewResponse.Rids = make([]api.DataReviewRid, 0)
	}
	*o = BatchInitiateDataReviewResponse(rawBatchInitiateDataReviewResponse)
	return nil
}

func (o BatchInitiateDataReviewResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchInitiateDataReviewResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchManualCheckEvaluationActionRequest struct {
	CheckAlertAction    ManualCheckAlertAction     `json:"checkAlertAction"`
	CheckEvaluationRids []ManualCheckEvaluationRid `json:"checkEvaluationRids"`
}

func (o BatchManualCheckEvaluationActionRequest) MarshalJSON() ([]byte, error) {
	if o.CheckEvaluationRids == nil {
		o.CheckEvaluationRids = make([]ManualCheckEvaluationRid, 0)
	}
	type _tmpBatchManualCheckEvaluationActionRequest BatchManualCheckEvaluationActionRequest
	return safejson.Marshal(_tmpBatchManualCheckEvaluationActionRequest(o))
}

func (o *BatchManualCheckEvaluationActionRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchManualCheckEvaluationActionRequest BatchManualCheckEvaluationActionRequest
	var rawBatchManualCheckEvaluationActionRequest _tmpBatchManualCheckEvaluationActionRequest
	if err := safejson.Unmarshal(data, &rawBatchManualCheckEvaluationActionRequest); err != nil {
		return err
	}
	if rawBatchManualCheckEvaluationActionRequest.CheckEvaluationRids == nil {
		rawBatchManualCheckEvaluationActionRequest.CheckEvaluationRids = make([]ManualCheckEvaluationRid, 0)
	}
	*o = BatchManualCheckEvaluationActionRequest(rawBatchManualCheckEvaluationActionRequest)
	return nil
}

func (o BatchManualCheckEvaluationActionRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchManualCheckEvaluationActionRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CheckAlert struct {
	Rid                           api.CheckAlertRid                `json:"rid"`
	CheckRid                      api.CheckRid                     `json:"checkRid"`
	ImplementationIndex           *int                             `json:"implementationIndex,omitempty"`
	DataReviewRid                 api.DataReviewRid                `json:"dataReviewRid"`
	CheckEvaluationRid            rids.AutomaticCheckEvaluationRid `json:"checkEvaluationRid"`
	Name                          string                           `json:"name"`
	AutogeneratedCheckTitle       *string                          `json:"autogeneratedCheckTitle,omitempty"`
	AutogeneratedCheckDescription *string                          `json:"autogeneratedCheckDescription,omitempty"`
	AssigneeRids                  []api.UserRid                    `json:"assigneeRids"`
	Start                         api3.Timestamp                   `json:"start"`
	End                           *api3.Timestamp                  `json:"end,omitempty"`
	State                         api.CheckAlertState              `json:"state"`
	Priority                      api4.Priority                    `json:"priority"`
	// Deprecated: charts are no longer versioned resources.
	Chart    *api.VersionedVizId `json:"chart,omitempty"`
	Notes    *string             `json:"notes,omitempty"`
	Notebook *api.NotebookRid    `json:"notebook,omitempty"`
}

func (o CheckAlert) MarshalJSON() ([]byte, error) {
	if o.AssigneeRids == nil {
		o.AssigneeRids = make([]api.UserRid, 0)
	}
	type _tmpCheckAlert CheckAlert
	return safejson.Marshal(_tmpCheckAlert(o))
}

func (o *CheckAlert) UnmarshalJSON(data []byte) error {
	type _tmpCheckAlert CheckAlert
	var rawCheckAlert _tmpCheckAlert
	if err := safejson.Unmarshal(data, &rawCheckAlert); err != nil {
		return err
	}
	if rawCheckAlert.AssigneeRids == nil {
		rawCheckAlert.AssigneeRids = make([]api.UserRid, 0)
	}
	*o = CheckAlert(rawCheckAlert)
	return nil
}

func (o CheckAlert) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CheckAlert) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CheckAlertActionLog struct {
	Entries []CheckAlertActionLogEntry `json:"entries"`
}

func (o CheckAlertActionLog) MarshalJSON() ([]byte, error) {
	if o.Entries == nil {
		o.Entries = make([]CheckAlertActionLogEntry, 0)
	}
	type _tmpCheckAlertActionLog CheckAlertActionLog
	return safejson.Marshal(_tmpCheckAlertActionLog(o))
}

func (o *CheckAlertActionLog) UnmarshalJSON(data []byte) error {
	type _tmpCheckAlertActionLog CheckAlertActionLog
	var rawCheckAlertActionLog _tmpCheckAlertActionLog
	if err := safejson.Unmarshal(data, &rawCheckAlertActionLog); err != nil {
		return err
	}
	if rawCheckAlertActionLog.Entries == nil {
		rawCheckAlertActionLog.Entries = make([]CheckAlertActionLogEntry, 0)
	}
	*o = CheckAlertActionLog(rawCheckAlertActionLog)
	return nil
}

func (o CheckAlertActionLog) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CheckAlertActionLog) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CheckAlertActionLogEntry struct {
	PerformedBy api.UserRid       `json:"performedBy"`
	Action      CheckAlertAction  `json:"action"`
	Timestamp   datetime.DateTime `json:"timestamp"`
}

func (o CheckAlertActionLogEntry) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CheckAlertActionLogEntry) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CheckAlertsHistogramRequest struct {
	// Defaults to 100. Throws if larger than 1_000.
	NumBins *int `conjure-docs:"Defaults to 100. Throws if larger than 1_000." json:"numBins,omitempty"`
	// Matches on check name
	SearchText *string `conjure-docs:"Matches on check name" json:"searchText,omitempty"`
	// Represents the data points on the x-axis of a histogram.
	DistributionVariable HistogramDistributionVariable `conjure-docs:"Represents the data points on the x-axis of a histogram." json:"distributionVariable"`
	// The variable that divides the data into distinct groups for comparison within the histogram.
	SubGroupVariable *HistogramSubGroupVariable `conjure-docs:"The variable that divides the data into distinct groups for comparison within the histogram." json:"subGroupVariable,omitempty"`
	// Filters to start times after this time, inclusive.
	StartTimeAfter api3.Timestamp `conjure-docs:"Filters to start times after this time, inclusive." json:"startTimeAfter"`
	// Filters to start times before this time, exclusive.
	StartTimeBefore     api3.Timestamp             `conjure-docs:"Filters to start times before this time, exclusive." json:"startTimeBefore"`
	Status              *[]CheckAlertStatus        `json:"status,omitempty"`
	CheckRids           *[]api.CheckRid            `json:"checkRids,omitempty"`
	DataReviewRids      *[]api.DataReviewRid       `json:"dataReviewRids,omitempty"`
	AssigneeRids        *[]api.UserRid             `json:"assigneeRids,omitempty"`
	Priorities          *[]api4.Priority           `json:"priorities,omitempty"`
	RunRids             []api5.RunRid              `json:"runRids"`
	AssetRids           []api.AssetRid             `json:"assetRids"`
	PinnedChecklistRefs *[]api1.PinnedChecklistRef `json:"pinnedChecklistRefs,omitempty"`
	// Deprecated: charts are no longer versioned resources.
	ChartRids    *[]api.VersionedVizId `json:"chartRids,omitempty"`
	NotebookRids *[]api.NotebookRid    `json:"notebookRids,omitempty"`
	/*
	   To be deprecated. Use archivedStatuses instead. If not present, will not show archived data reviews
	   in search results.
	*/
	ShowArchived *bool `conjure-docs:"To be deprecated. Use archivedStatuses instead. If not present, will not show archived data reviews \nin search results." json:"showArchived,omitempty"`
	/*
	   Filters search on check alerts based on the archived statuses provided.
	   Default is NOT_ARCHIVED only if none are provided.
	*/
	ArchivedStatuses *[]api3.ArchivedStatus `conjure-docs:"Filters search on check alerts based on the archived statuses provided. \nDefault is NOT_ARCHIVED only if none are provided." json:"archivedStatuses,omitempty"`
}

func (o CheckAlertsHistogramRequest) MarshalJSON() ([]byte, error) {
	if o.RunRids == nil {
		o.RunRids = make([]api5.RunRid, 0)
	}
	if o.AssetRids == nil {
		o.AssetRids = make([]api.AssetRid, 0)
	}
	type _tmpCheckAlertsHistogramRequest CheckAlertsHistogramRequest
	return safejson.Marshal(_tmpCheckAlertsHistogramRequest(o))
}

func (o *CheckAlertsHistogramRequest) UnmarshalJSON(data []byte) error {
	type _tmpCheckAlertsHistogramRequest CheckAlertsHistogramRequest
	var rawCheckAlertsHistogramRequest _tmpCheckAlertsHistogramRequest
	if err := safejson.Unmarshal(data, &rawCheckAlertsHistogramRequest); err != nil {
		return err
	}
	if rawCheckAlertsHistogramRequest.RunRids == nil {
		rawCheckAlertsHistogramRequest.RunRids = make([]api5.RunRid, 0)
	}
	if rawCheckAlertsHistogramRequest.AssetRids == nil {
		rawCheckAlertsHistogramRequest.AssetRids = make([]api.AssetRid, 0)
	}
	*o = CheckAlertsHistogramRequest(rawCheckAlertsHistogramRequest)
	return nil
}

func (o CheckAlertsHistogramRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CheckAlertsHistogramRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CheckAlertsHistogramResponse struct {
	Buckets CheckAlertsHistogramBuckets `json:"buckets"`
}

func (o CheckAlertsHistogramResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CheckAlertsHistogramResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CheckAlertsPriorityHistogram struct {
	Buckets []HistogramPriorityBucket `json:"buckets"`
}

func (o CheckAlertsPriorityHistogram) MarshalJSON() ([]byte, error) {
	if o.Buckets == nil {
		o.Buckets = make([]HistogramPriorityBucket, 0)
	}
	type _tmpCheckAlertsPriorityHistogram CheckAlertsPriorityHistogram
	return safejson.Marshal(_tmpCheckAlertsPriorityHistogram(o))
}

func (o *CheckAlertsPriorityHistogram) UnmarshalJSON(data []byte) error {
	type _tmpCheckAlertsPriorityHistogram CheckAlertsPriorityHistogram
	var rawCheckAlertsPriorityHistogram _tmpCheckAlertsPriorityHistogram
	if err := safejson.Unmarshal(data, &rawCheckAlertsPriorityHistogram); err != nil {
		return err
	}
	if rawCheckAlertsPriorityHistogram.Buckets == nil {
		rawCheckAlertsPriorityHistogram.Buckets = make([]HistogramPriorityBucket, 0)
	}
	*o = CheckAlertsPriorityHistogram(rawCheckAlertsPriorityHistogram)
	return nil
}

func (o CheckAlertsPriorityHistogram) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CheckAlertsPriorityHistogram) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CheckAlertsStatusHistogram struct {
	Buckets []HistogramStatusBucket `json:"buckets"`
}

func (o CheckAlertsStatusHistogram) MarshalJSON() ([]byte, error) {
	if o.Buckets == nil {
		o.Buckets = make([]HistogramStatusBucket, 0)
	}
	type _tmpCheckAlertsStatusHistogram CheckAlertsStatusHistogram
	return safejson.Marshal(_tmpCheckAlertsStatusHistogram(o))
}

func (o *CheckAlertsStatusHistogram) UnmarshalJSON(data []byte) error {
	type _tmpCheckAlertsStatusHistogram CheckAlertsStatusHistogram
	var rawCheckAlertsStatusHistogram _tmpCheckAlertsStatusHistogram
	if err := safejson.Unmarshal(data, &rawCheckAlertsStatusHistogram); err != nil {
		return err
	}
	if rawCheckAlertsStatusHistogram.Buckets == nil {
		rawCheckAlertsStatusHistogram.Buckets = make([]HistogramStatusBucket, 0)
	}
	*o = CheckAlertsStatusHistogram(rawCheckAlertsStatusHistogram)
	return nil
}

func (o CheckAlertsStatusHistogram) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CheckAlertsStatusHistogram) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CheckAlertsUnstackedHistogram struct {
	Buckets []HistogramBucket `json:"buckets"`
}

func (o CheckAlertsUnstackedHistogram) MarshalJSON() ([]byte, error) {
	if o.Buckets == nil {
		o.Buckets = make([]HistogramBucket, 0)
	}
	type _tmpCheckAlertsUnstackedHistogram CheckAlertsUnstackedHistogram
	return safejson.Marshal(_tmpCheckAlertsUnstackedHistogram(o))
}

func (o *CheckAlertsUnstackedHistogram) UnmarshalJSON(data []byte) error {
	type _tmpCheckAlertsUnstackedHistogram CheckAlertsUnstackedHistogram
	var rawCheckAlertsUnstackedHistogram _tmpCheckAlertsUnstackedHistogram
	if err := safejson.Unmarshal(data, &rawCheckAlertsUnstackedHistogram); err != nil {
		return err
	}
	if rawCheckAlertsUnstackedHistogram.Buckets == nil {
		rawCheckAlertsUnstackedHistogram.Buckets = make([]HistogramBucket, 0)
	}
	*o = CheckAlertsUnstackedHistogram(rawCheckAlertsUnstackedHistogram)
	return nil
}

func (o CheckAlertsUnstackedHistogram) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CheckAlertsUnstackedHistogram) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChecklistEvaluation struct {
	Checklist     api1.PinnedChecklistRef `json:"checklist"`
	DataReviewRid api.DataReviewRid       `json:"dataReviewRid"`
	Checks        []CheckEvaluation       `json:"checks"`
}

func (o ChecklistEvaluation) MarshalJSON() ([]byte, error) {
	if o.Checks == nil {
		o.Checks = make([]CheckEvaluation, 0)
	}
	type _tmpChecklistEvaluation ChecklistEvaluation
	return safejson.Marshal(_tmpChecklistEvaluation(o))
}

func (o *ChecklistEvaluation) UnmarshalJSON(data []byte) error {
	type _tmpChecklistEvaluation ChecklistEvaluation
	var rawChecklistEvaluation _tmpChecklistEvaluation
	if err := safejson.Unmarshal(data, &rawChecklistEvaluation); err != nil {
		return err
	}
	if rawChecklistEvaluation.Checks == nil {
		rawChecklistEvaluation.Checks = make([]CheckEvaluation, 0)
	}
	*o = ChecklistEvaluation(rawChecklistEvaluation)
	return nil
}

func (o ChecklistEvaluation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChecklistEvaluation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Close all alerts associated with the same notebook with the same comment.
type CloseAllLinkedAlerts struct{}

func (o CloseAllLinkedAlerts) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CloseAllLinkedAlerts) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Close the alert and detach it from the notebook. If the alert is linked to the same notebook as other
alerts, those alerts will maintain the reference to the notebook and the notebook will remain unlocked.
*/
type CloseAndDetachFromNotebook struct{}

func (o CloseAndDetachFromNotebook) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CloseAndDetachFromNotebook) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Close the alert and detach it from the notebook. If the alert is linked to the same notebook as other
alerts, the notebook will be duplicated and the alert will be linked to the new notebook. The new notebook
will be locked.
*/
type CloseAndDuplicatePreviouslyLinkedNotebook struct{}

func (o CloseAndDuplicatePreviouslyLinkedNotebook) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CloseAndDuplicatePreviouslyLinkedNotebook) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Close the alert and link to notebook. Throws if the associated notebook has open alerts.
type CloseAndLinkToNotebook struct {
	CloseAction CloseAction `json:"closeAction"`
}

func (o CloseAndLinkToNotebook) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CloseAndLinkToNotebook) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Close the alert with further action. If the alert is linked to the same notebook as other alerts, the other
alerts will also be closed with further action. This will also lock the associated notebook.
*/
type CloseWithFurtherAction struct {
	Comment string `json:"comment"`
	/*
	   Defines the strategy for reopening the alert and any alerts linked via an associated notebook. If not
	   provided, the alert will be closed naively and throw if it leaves a linked notebook in an invalid state.
	*/
	Strategy *CloseStrategy `conjure-docs:"Defines the strategy for reopening the alert and any alerts linked via an associated notebook. If not \nprovided, the alert will be closed naively and throw if it leaves a linked notebook in an invalid state." json:"strategy,omitempty"`
}

func (o CloseWithFurtherAction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CloseWithFurtherAction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Close the alert with ignore. If the alert is linked to the same notebook as other alerts, the other
alerts will also be closed with ignore. This will also lock the associated notebook.
*/
type CloseWithIgnoreAlert struct {
	Comment string `json:"comment"`
	/*
	   Defines the strategy for closing the alert and any alerts linked via an associated notebook. If not
	   provided, the default strategy is closeAllLinkedAlerts.
	*/
	Strategy *CloseStrategy `conjure-docs:"Defines the strategy for closing the alert and any alerts linked via an associated notebook. If not \nprovided, the default strategy is closeAllLinkedAlerts." json:"strategy,omitempty"`
}

func (o CloseWithIgnoreAlert) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CloseWithIgnoreAlert) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ClosedWithFurtherActionState struct {
	Comment  string      `json:"comment"`
	ClosedBy api.UserRid `json:"closedBy"`
}

func (o ClosedWithFurtherActionState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ClosedWithFurtherActionState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
If commit not is provided, the latest commit on main will be used.
Asset RID is required only for multi-asset runs.
*/
type CreateDataReviewRequest struct {
	RunRid api5.RunRid `json:"runRid"`
	// Selects asset to execute data review on. Required for multi-asset runs.
	AssetRid     *api.AssetRid    `conjure-docs:"Selects asset to execute data review on. Required for multi-asset runs." json:"assetRid,omitempty"`
	ChecklistRid api.ChecklistRid `json:"checklistRid"`
	Commit       *api6.CommitId   `json:"commit,omitempty"`
}

func (o CreateDataReviewRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateDataReviewRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataReview struct {
	Rid       api.DataReviewRid `json:"rid"`
	RunRid    api5.RunRid       `json:"runRid"`
	AssetRid  api.AssetRid      `json:"assetRid"`
	CreatedAt datetime.DateTime `json:"createdAt"`
	CreatedBy api.UserRid       `json:"createdBy"`
	// Deprecated: This field is deprecated and will be removed in a future version.
	Checklist        *ChecklistEvaluation       `json:"checklist,omitempty"`
	ChecklistRef     api1.PinnedChecklistRef    `json:"checklistRef"`
	CheckEvaluations []AutomaticCheckEvaluation `json:"checkEvaluations"`
	Archived         bool                       `json:"archived"`
}

func (o DataReview) MarshalJSON() ([]byte, error) {
	if o.CheckEvaluations == nil {
		o.CheckEvaluations = make([]AutomaticCheckEvaluation, 0)
	}
	type _tmpDataReview DataReview
	return safejson.Marshal(_tmpDataReview(o))
}

func (o *DataReview) UnmarshalJSON(data []byte) error {
	type _tmpDataReview DataReview
	var rawDataReview _tmpDataReview
	if err := safejson.Unmarshal(data, &rawDataReview); err != nil {
		return err
	}
	if rawDataReview.CheckEvaluations == nil {
		rawDataReview.CheckEvaluations = make([]AutomaticCheckEvaluation, 0)
	}
	*o = DataReview(rawDataReview)
	return nil
}

func (o DataReview) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataReview) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataReviewPage struct {
	DataReviews   []DataReview `json:"dataReviews"`
	NextPageToken *api3.Token  `json:"nextPageToken,omitempty"`
}

func (o DataReviewPage) MarshalJSON() ([]byte, error) {
	if o.DataReviews == nil {
		o.DataReviews = make([]DataReview, 0)
	}
	type _tmpDataReviewPage DataReviewPage
	return safejson.Marshal(_tmpDataReviewPage(o))
}

func (o *DataReviewPage) UnmarshalJSON(data []byte) error {
	type _tmpDataReviewPage DataReviewPage
	var rawDataReviewPage _tmpDataReviewPage
	if err := safejson.Unmarshal(data, &rawDataReviewPage); err != nil {
		return err
	}
	if rawDataReviewPage.DataReviews == nil {
		rawDataReviewPage.DataReviews = make([]DataReview, 0)
	}
	*o = DataReviewPage(rawDataReviewPage)
	return nil
}

func (o DataReviewPage) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataReviewPage) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Duplicate the notebook and link the alert to it.
type DuplicateAndLinkNotebook struct{}

func (o DuplicateAndLinkNotebook) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DuplicateAndLinkNotebook) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExecutingState struct {
	JobRid api1.JobRid `json:"jobRid"`
}

func (o ExecutingState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExecutingState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExecutionRetriggered struct {
	JobRid api1.JobRid `json:"jobRid"`
}

func (o ExecutionRetriggered) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExecutionRetriggered) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FailedToExecuteState struct {
	JobRid       api1.JobRid          `json:"jobRid"`
	ReviewState  *api.CheckAlertState `json:"reviewState,omitempty"`
	ReviewNotes  *string              `json:"reviewNotes,omitempty"`
	AssigneeRids []api.UserRid        `json:"assigneeRids"`
}

func (o FailedToExecuteState) MarshalJSON() ([]byte, error) {
	if o.AssigneeRids == nil {
		o.AssigneeRids = make([]api.UserRid, 0)
	}
	type _tmpFailedToExecuteState FailedToExecuteState
	return safejson.Marshal(_tmpFailedToExecuteState(o))
}

func (o *FailedToExecuteState) UnmarshalJSON(data []byte) error {
	type _tmpFailedToExecuteState FailedToExecuteState
	var rawFailedToExecuteState _tmpFailedToExecuteState
	if err := safejson.Unmarshal(data, &rawFailedToExecuteState); err != nil {
		return err
	}
	if rawFailedToExecuteState.AssigneeRids == nil {
		rawFailedToExecuteState.AssigneeRids = make([]api.UserRid, 0)
	}
	*o = FailedToExecuteState(rawFailedToExecuteState)
	return nil
}

func (o FailedToExecuteState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FailedToExecuteState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
If both sets are empty, an empty page is returned.
If one set is empty, that field is not considered for filtering (like a wildcard).
If commitId is omitted from a ChecklistRef, it will match all commits.
*/
type FindDataReviewsRequest struct {
	RunRids   []api5.RunRid  `json:"runRids"`
	AssetRids []api.AssetRid `json:"assetRids"`
	/*
	   If true, results are filtered to data reviews w/ both run and asset in the requested runs/assets.
	   Defaults to false, where assets are converted to runs and all data reviews under the linked runs
	   (including data reviews on other assets sharing the parent run) will be returned.
	   It is recommended to set this to true and pass in asset RIDs for multi-asset runs.
	   Toggling this option has no effect if no asset RIDs are supplied.
	*/
	FilterByBothRunsAndAssets *bool               `conjure-docs:"If true, results are filtered to data reviews w/ both run and asset in the requested runs/assets.\nDefaults to false, where assets are converted to runs and all data reviews under the linked runs\n(including data reviews on other assets sharing the parent run) will be returned.\nIt is recommended to set this to true and pass in asset RIDs for multi-asset runs.\nToggling this option has no effect if no asset RIDs are supplied." json:"filterByBothRunsAndAssets,omitempty"`
	ChecklistRefs             []api1.ChecklistRef `json:"checklistRefs"`
	NextPageToken             *api3.Token         `json:"nextPageToken,omitempty"`
	// Defaults to 1000. Will throw if larger than 1000.
	PageSize *int `conjure-docs:"Defaults to 1000. Will throw if larger than 1000." json:"pageSize,omitempty"`
	/*
	   To be deprecated. Use archivedStatuses instead. Allows for inclusion of archived data reviews
	   in search results alongside non-archived ones. Defaults to false if not specified.
	*/
	ShowArchived *bool `conjure-docs:"To be deprecated. Use archivedStatuses instead. Allows for inclusion of archived data reviews \nin search results alongside non-archived ones. Defaults to false if not specified." json:"showArchived,omitempty"`
	/*
	   Filters search on data reviews based on the archived statuses provided.
	   Default is NOT_ARCHIVED only if none are provided.
	*/
	ArchivedStatuses *[]api3.ArchivedStatus `conjure-docs:"Filters search on data reviews based on the archived statuses provided. \nDefault is NOT_ARCHIVED only if none are provided." json:"archivedStatuses,omitempty"`
}

func (o FindDataReviewsRequest) MarshalJSON() ([]byte, error) {
	if o.RunRids == nil {
		o.RunRids = make([]api5.RunRid, 0)
	}
	if o.AssetRids == nil {
		o.AssetRids = make([]api.AssetRid, 0)
	}
	if o.ChecklistRefs == nil {
		o.ChecklistRefs = make([]api1.ChecklistRef, 0)
	}
	type _tmpFindDataReviewsRequest FindDataReviewsRequest
	return safejson.Marshal(_tmpFindDataReviewsRequest(o))
}

func (o *FindDataReviewsRequest) UnmarshalJSON(data []byte) error {
	type _tmpFindDataReviewsRequest FindDataReviewsRequest
	var rawFindDataReviewsRequest _tmpFindDataReviewsRequest
	if err := safejson.Unmarshal(data, &rawFindDataReviewsRequest); err != nil {
		return err
	}
	if rawFindDataReviewsRequest.RunRids == nil {
		rawFindDataReviewsRequest.RunRids = make([]api5.RunRid, 0)
	}
	if rawFindDataReviewsRequest.AssetRids == nil {
		rawFindDataReviewsRequest.AssetRids = make([]api.AssetRid, 0)
	}
	if rawFindDataReviewsRequest.ChecklistRefs == nil {
		rawFindDataReviewsRequest.ChecklistRefs = make([]api1.ChecklistRef, 0)
	}
	*o = FindDataReviewsRequest(rawFindDataReviewsRequest)
	return nil
}

func (o FindDataReviewsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FindDataReviewsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GeneratedAlertsState struct {
	/*
	   Deprecated: This field is deprecated and will be removed in a future version.
	   Use eventRids instead.
	*/
	Rids      *[]api.CheckAlertRid `json:"rids,omitempty"`
	EventRids []rids.EventRid      `json:"eventRids"`
}

func (o GeneratedAlertsState) MarshalJSON() ([]byte, error) {
	if o.EventRids == nil {
		o.EventRids = make([]rids.EventRid, 0)
	}
	type _tmpGeneratedAlertsState GeneratedAlertsState
	return safejson.Marshal(_tmpGeneratedAlertsState(o))
}

func (o *GeneratedAlertsState) UnmarshalJSON(data []byte) error {
	type _tmpGeneratedAlertsState GeneratedAlertsState
	var rawGeneratedAlertsState _tmpGeneratedAlertsState
	if err := safejson.Unmarshal(data, &rawGeneratedAlertsState); err != nil {
		return err
	}
	if rawGeneratedAlertsState.EventRids == nil {
		rawGeneratedAlertsState.EventRids = make([]rids.EventRid, 0)
	}
	*o = GeneratedAlertsState(rawGeneratedAlertsState)
	return nil
}

func (o GeneratedAlertsState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GeneratedAlertsState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetDataReviewCheckMetricsRequest struct {
	Scope DataReviewCheckMetricsScope `json:"scope"`
}

func (o GetDataReviewCheckMetricsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetDataReviewCheckMetricsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetDataReviewCheckMetricsResponse struct {
	ChecksPendingExecution                       int `json:"checksPendingExecution"`
	ChecksExecuting                              int `json:"checksExecuting"`
	ChecksPassed                                 int `json:"checksPassed"`
	ChecksWithEventsPendingReview                int `json:"checksWithEventsPendingReview"`
	ChecksWithEventsClosedWithIgnore             int `json:"checksWithEventsClosedWithIgnore"`
	ChecksWithEventsClosedWithFurtherAction      int `json:"checksWithEventsClosedWithFurtherAction"`
	ChecksWithEvents                             int `json:"checksWithEvents"`
	ChecksWithTooManyEvents                      int `json:"checksWithTooManyEvents"`
	ChecksFailedToExecutePendingReview           int `json:"checksFailedToExecutePendingReview"`
	ChecksFailedToExecuteClosedWithIgnore        int `json:"checksFailedToExecuteClosedWithIgnore"`
	ChecksFailedToExecuteClosedWithFurtherAction int `json:"checksFailedToExecuteClosedWithFurtherAction"`
	ChecksFailedToExecute                        int `json:"checksFailedToExecute"`
	ChecksExecuted                               int `json:"checksExecuted"`
	ChecksTotal                                  int `json:"checksTotal"`
	EventsPendingReview                          int `json:"eventsPendingReview"`
	EventsClosedWithIgnore                       int `json:"eventsClosedWithIgnore"`
	EventsClosedWithFurtherAction                int `json:"eventsClosedWithFurtherAction"`
	EventsTotal                                  int `json:"eventsTotal"`
}

func (o GetDataReviewCheckMetricsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetDataReviewCheckMetricsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HistogramBucket struct {
	StartInclusive api3.Timestamp `json:"startInclusive"`
	EndExclusive   api3.Timestamp `json:"endExclusive"`
	Count          int            `json:"count"`
}

func (o HistogramBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HistogramEndTimeVariable struct{}

func (o HistogramEndTimeVariable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramEndTimeVariable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HistogramPriorityBucket struct {
	StartInclusive api3.Timestamp        `json:"startInclusive"`
	EndExclusive   api3.Timestamp        `json:"endExclusive"`
	Counts         map[api4.Priority]int `json:"counts"`
}

func (o HistogramPriorityBucket) MarshalJSON() ([]byte, error) {
	if o.Counts == nil {
		o.Counts = make(map[api4.Priority]int, 0)
	}
	type _tmpHistogramPriorityBucket HistogramPriorityBucket
	return safejson.Marshal(_tmpHistogramPriorityBucket(o))
}

func (o *HistogramPriorityBucket) UnmarshalJSON(data []byte) error {
	type _tmpHistogramPriorityBucket HistogramPriorityBucket
	var rawHistogramPriorityBucket _tmpHistogramPriorityBucket
	if err := safejson.Unmarshal(data, &rawHistogramPriorityBucket); err != nil {
		return err
	}
	if rawHistogramPriorityBucket.Counts == nil {
		rawHistogramPriorityBucket.Counts = make(map[api4.Priority]int, 0)
	}
	*o = HistogramPriorityBucket(rawHistogramPriorityBucket)
	return nil
}

func (o HistogramPriorityBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramPriorityBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HistogramPriorityVariable struct{}

func (o HistogramPriorityVariable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramPriorityVariable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HistogramStartTimeVariable struct{}

func (o HistogramStartTimeVariable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramStartTimeVariable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HistogramStatusBucket struct {
	StartInclusive api3.Timestamp           `json:"startInclusive"`
	EndExclusive   api3.Timestamp           `json:"endExclusive"`
	Counts         map[CheckAlertStatus]int `json:"counts"`
}

func (o HistogramStatusBucket) MarshalJSON() ([]byte, error) {
	if o.Counts == nil {
		o.Counts = make(map[CheckAlertStatus]int, 0)
	}
	type _tmpHistogramStatusBucket HistogramStatusBucket
	return safejson.Marshal(_tmpHistogramStatusBucket(o))
}

func (o *HistogramStatusBucket) UnmarshalJSON(data []byte) error {
	type _tmpHistogramStatusBucket HistogramStatusBucket
	var rawHistogramStatusBucket _tmpHistogramStatusBucket
	if err := safejson.Unmarshal(data, &rawHistogramStatusBucket); err != nil {
		return err
	}
	if rawHistogramStatusBucket.Counts == nil {
		rawHistogramStatusBucket.Counts = make(map[CheckAlertStatus]int, 0)
	}
	*o = HistogramStatusBucket(rawHistogramStatusBucket)
	return nil
}

func (o HistogramStatusBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramStatusBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type HistogramStatusVariable struct{}

func (o HistogramStatusVariable) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *HistogramStatusVariable) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LinkNotebook struct {
	Rid api.NotebookRid `json:"rid"`
	/*
	   Defines the strategy for reconciling the alert with any linked alerts via the associated notebook. If not
	   provided, the alert will be linked naively and throw if it leaves a linked notebook in an invalid state.
	*/
	Strategy *LinkNotebookStrategy `conjure-docs:"Defines the strategy for reconciling the alert with any linked alerts via the associated notebook. If not\nprovided, the alert will be linked naively and throw if it leaves a linked notebook in an invalid state." json:"strategy,omitempty"`
}

func (o LinkNotebook) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LinkNotebook) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ManualCheckEvaluation struct {
	Rid           ManualCheckEvaluationRid   `json:"rid"`
	CheckRid      api.CheckRid               `json:"checkRid"`
	DataReviewRid api.DataReviewRid          `json:"dataReviewRid"`
	State         ManualCheckEvaluationState `json:"state"`
	AssigneeRids  []api.UserRid              `json:"assigneeRids"`
	// Deprecated: charts are no longer versioned resources.
	Chart    *api.VersionedVizId `json:"chart,omitempty"`
	Notes    *string             `json:"notes,omitempty"`
	Notebook *api.NotebookRid    `json:"notebook,omitempty"`
}

func (o ManualCheckEvaluation) MarshalJSON() ([]byte, error) {
	if o.AssigneeRids == nil {
		o.AssigneeRids = make([]api.UserRid, 0)
	}
	type _tmpManualCheckEvaluation ManualCheckEvaluation
	return safejson.Marshal(_tmpManualCheckEvaluation(o))
}

func (o *ManualCheckEvaluation) UnmarshalJSON(data []byte) error {
	type _tmpManualCheckEvaluation ManualCheckEvaluation
	var rawManualCheckEvaluation _tmpManualCheckEvaluation
	if err := safejson.Unmarshal(data, &rawManualCheckEvaluation); err != nil {
		return err
	}
	if rawManualCheckEvaluation.AssigneeRids == nil {
		rawManualCheckEvaluation.AssigneeRids = make([]api.UserRid, 0)
	}
	*o = ManualCheckEvaluation(rawManualCheckEvaluation)
	return nil
}

func (o ManualCheckEvaluation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ManualCheckEvaluation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ManualCheckEvaluationActionLog struct {
	Entries []ManualCheckEvaluationActionLogEntry `json:"entries"`
}

func (o ManualCheckEvaluationActionLog) MarshalJSON() ([]byte, error) {
	if o.Entries == nil {
		o.Entries = make([]ManualCheckEvaluationActionLogEntry, 0)
	}
	type _tmpManualCheckEvaluationActionLog ManualCheckEvaluationActionLog
	return safejson.Marshal(_tmpManualCheckEvaluationActionLog(o))
}

func (o *ManualCheckEvaluationActionLog) UnmarshalJSON(data []byte) error {
	type _tmpManualCheckEvaluationActionLog ManualCheckEvaluationActionLog
	var rawManualCheckEvaluationActionLog _tmpManualCheckEvaluationActionLog
	if err := safejson.Unmarshal(data, &rawManualCheckEvaluationActionLog); err != nil {
		return err
	}
	if rawManualCheckEvaluationActionLog.Entries == nil {
		rawManualCheckEvaluationActionLog.Entries = make([]ManualCheckEvaluationActionLogEntry, 0)
	}
	*o = ManualCheckEvaluationActionLog(rawManualCheckEvaluationActionLog)
	return nil
}

func (o ManualCheckEvaluationActionLog) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ManualCheckEvaluationActionLog) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ManualCheckEvaluationActionLogEntry struct {
	PerformedBy api.UserRid            `json:"performedBy"`
	Action      ManualCheckAlertAction `json:"action"`
	Timestamp   datetime.DateTime      `json:"timestamp"`
}

func (o ManualCheckEvaluationActionLogEntry) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ManualCheckEvaluationActionLogEntry) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Pass struct {
	Comment string `json:"comment"`
}

func (o Pass) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Pass) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PassState struct {
	Comment  string      `json:"comment"`
	ClosedBy api.UserRid `json:"closedBy"`
}

func (o PassState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PassState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PassingExecutionState struct{}

func (o PassingExecutionState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PassingExecutionState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PendingExecutionState struct {
	JobRid api1.JobRid `json:"jobRid"`
}

func (o PendingExecutionState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PendingExecutionState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PendingReviewState struct{}

func (o PendingReviewState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PendingReviewState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Reassign struct {
	AssigneeRids []api.UserRid `json:"assigneeRids"`
}

func (o Reassign) MarshalJSON() ([]byte, error) {
	if o.AssigneeRids == nil {
		o.AssigneeRids = make([]api.UserRid, 0)
	}
	type _tmpReassign Reassign
	return safejson.Marshal(_tmpReassign(o))
}

func (o *Reassign) UnmarshalJSON(data []byte) error {
	type _tmpReassign Reassign
	var rawReassign _tmpReassign
	if err := safejson.Unmarshal(data, &rawReassign); err != nil {
		return err
	}
	if rawReassign.AssigneeRids == nil {
		rawReassign.AssigneeRids = make([]api.UserRid, 0)
	}
	*o = Reassign(rawReassign)
	return nil
}

func (o Reassign) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Reassign) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Reopen struct {
	Comment string `json:"comment"`
	/*
	   Defines the strategy for reopening the alert and any alerts linked via an associated notebook. If not
	   provided, the default strategy is reopenAllLinkedAlerts.
	*/
	Strategy *ReopenStrategy `conjure-docs:"Defines the strategy for reopening the alert and any alerts linked via an associated notebook. If not \nprovided, the default strategy is reopenAllLinkedAlerts." json:"strategy,omitempty"`
}

func (o Reopen) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Reopen) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Reopen all alerts associated with the same notebook and unlock the notebook.
type ReopenAllLinkedAlerts struct{}

func (o ReopenAllLinkedAlerts) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ReopenAllLinkedAlerts) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Reopen the alert and detach it from the notebook. If the alert is linked to the same notebook as other
alerts, those alerts will maintain the reference to the notebook and the notebook will remain locked.
*/
type ReopenAndDetachFromNotebook struct{}

func (o ReopenAndDetachFromNotebook) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ReopenAndDetachFromNotebook) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Reopen the alert and detach it from the notebook. If the alert is linked to the same notebook as other
alerts, the notebook will be duplicated and the alert will be linked to the new notebook. The new notebook
will be unlocked.
*/
type ReopenAndDuplicatePreviouslyLinkedNotebook struct{}

func (o ReopenAndDuplicatePreviouslyLinkedNotebook) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ReopenAndDuplicatePreviouslyLinkedNotebook) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Reopen the alert and link to notebook. Throws if the associated notebook has closed alerts.
type ReopenAndLinkToNotebook struct {
	Comment string `json:"comment"`
}

func (o ReopenAndLinkToNotebook) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ReopenAndLinkToNotebook) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RerunFailedAutomaticChecksRequest struct {
	DataReviewRid api.DataReviewRid `json:"dataReviewRid"`
}

func (o RerunFailedAutomaticChecksRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RerunFailedAutomaticChecksRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchCheckAlertsRequest struct {
	NextPageToken *api3.Token `json:"nextPageToken,omitempty"`
	// Defaults to 100. Will throw if larger than 1_000.
	PageSize *int `conjure-docs:"Defaults to 100. Will throw if larger than 1_000." json:"pageSize,omitempty"`
	// If not present, will sort by start time in descending order.
	SortBy *SearchCheckAlertsSortOptions `conjure-docs:"If not present, will sort by start time in descending order." json:"sortBy,omitempty"`
	// Matches on check name
	SearchText *string `conjure-docs:"Matches on check name" json:"searchText,omitempty"`
	// Filters to start times after this time, inclusive.
	After *api3.Timestamp `conjure-docs:"Filters to start times after this time, inclusive." json:"after,omitempty"`
	// Filters to start times before this time, exclusive.
	Before              *api3.Timestamp            `conjure-docs:"Filters to start times before this time, exclusive." json:"before,omitempty"`
	Status              *[]CheckAlertStatus        `json:"status,omitempty"`
	CheckRids           *[]api.CheckRid            `json:"checkRids,omitempty"`
	DataReviewRids      *[]api.DataReviewRid       `json:"dataReviewRids,omitempty"`
	AssigneeRids        *[]api.UserRid             `json:"assigneeRids,omitempty"`
	Priorities          *[]api4.Priority           `json:"priorities,omitempty"`
	RunRids             []api5.RunRid              `json:"runRids"`
	AssetRids           []api.AssetRid             `json:"assetRids"`
	PinnedChecklistRefs *[]api1.PinnedChecklistRef `json:"pinnedChecklistRefs,omitempty"`
	// Deprecated: charts are no longer versioned resources.
	ChartRids    *[]api.VersionedVizId `json:"chartRids,omitempty"`
	NotebookRids *[]api.NotebookRid    `json:"notebookRids,omitempty"`
	/*
	   To be deprecated. Use archivedStatuses instead. If true, includes archived check alerts in the search
	   results. If not present or false, will not show archived data reviews in search results
	*/
	ShowArchived *bool `conjure-docs:"To be deprecated. Use archivedStatuses instead. If true, includes archived check alerts in the search \nresults. If not present or false, will not show archived data reviews in search results" json:"showArchived,omitempty"`
	/*
	   Filters search on check alerts based on the archived statuses provided.
	   Default is NOT_ARCHIVED only if none are provided.
	*/
	ArchivedStatuses *[]api3.ArchivedStatus `conjure-docs:"Filters search on check alerts based on the archived statuses provided.\nDefault is NOT_ARCHIVED only if none are provided." json:"archivedStatuses,omitempty"`
}

func (o SearchCheckAlertsRequest) MarshalJSON() ([]byte, error) {
	if o.RunRids == nil {
		o.RunRids = make([]api5.RunRid, 0)
	}
	if o.AssetRids == nil {
		o.AssetRids = make([]api.AssetRid, 0)
	}
	type _tmpSearchCheckAlertsRequest SearchCheckAlertsRequest
	return safejson.Marshal(_tmpSearchCheckAlertsRequest(o))
}

func (o *SearchCheckAlertsRequest) UnmarshalJSON(data []byte) error {
	type _tmpSearchCheckAlertsRequest SearchCheckAlertsRequest
	var rawSearchCheckAlertsRequest _tmpSearchCheckAlertsRequest
	if err := safejson.Unmarshal(data, &rawSearchCheckAlertsRequest); err != nil {
		return err
	}
	if rawSearchCheckAlertsRequest.RunRids == nil {
		rawSearchCheckAlertsRequest.RunRids = make([]api5.RunRid, 0)
	}
	if rawSearchCheckAlertsRequest.AssetRids == nil {
		rawSearchCheckAlertsRequest.AssetRids = make([]api.AssetRid, 0)
	}
	*o = SearchCheckAlertsRequest(rawSearchCheckAlertsRequest)
	return nil
}

func (o SearchCheckAlertsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchCheckAlertsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchCheckAlertsResponse struct {
	NextPageToken *api3.Token  `json:"nextPageToken,omitempty"`
	CheckAlerts   []CheckAlert `json:"checkAlerts"`
}

func (o SearchCheckAlertsResponse) MarshalJSON() ([]byte, error) {
	if o.CheckAlerts == nil {
		o.CheckAlerts = make([]CheckAlert, 0)
	}
	type _tmpSearchCheckAlertsResponse SearchCheckAlertsResponse
	return safejson.Marshal(_tmpSearchCheckAlertsResponse(o))
}

func (o *SearchCheckAlertsResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchCheckAlertsResponse SearchCheckAlertsResponse
	var rawSearchCheckAlertsResponse _tmpSearchCheckAlertsResponse
	if err := safejson.Unmarshal(data, &rawSearchCheckAlertsResponse); err != nil {
		return err
	}
	if rawSearchCheckAlertsResponse.CheckAlerts == nil {
		rawSearchCheckAlertsResponse.CheckAlerts = make([]CheckAlert, 0)
	}
	*o = SearchCheckAlertsResponse(rawSearchCheckAlertsResponse)
	return nil
}

func (o SearchCheckAlertsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchCheckAlertsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchCheckAlertsSortOptions struct {
	IsDescending bool                       `json:"isDescending"`
	Field        SearchCheckAlertsSortField `json:"field"`
}

func (o SearchCheckAlertsSortOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchCheckAlertsSortOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// The number of generated alerts is greater than the maximum. The check is likely misconfigured.
type TooManyAlertsState struct{}

func (o TooManyAlertsState) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TooManyAlertsState) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Unarchive the data review which created this check alert. Only performable via the unarchive data review
endpoint; not supported by Perform Check Alert Action.
*/
type UnarchiveDataReview struct{}

func (o UnarchiveDataReview) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnarchiveDataReview) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UnlinkNotebook struct{}

func (o UnlinkNotebook) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UnlinkNotebook) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateNotes struct {
	Notes string `json:"notes"`
}

func (o UpdateNotes) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateNotes) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
