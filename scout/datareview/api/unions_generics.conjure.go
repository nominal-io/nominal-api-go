// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	api1 "github.com/nominal-io/nominal-api/scout/rids/api"
	"github.com/nominal-io/nominal-api/scout/run/api"
)

type AutomaticCheckEvaluationActionWithT[T any] AutomaticCheckEvaluationAction

func (u *AutomaticCheckEvaluationActionWithT[T]) Accept(ctx context.Context, v AutomaticCheckEvaluationActionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "executionFinished":
		if u.executionFinished == nil {
			return result, fmt.Errorf("field \"executionFinished\" is required")
		}
		return v.VisitExecutionFinished(ctx, *u.executionFinished)
	case "executionFailedToRun":
		if u.executionFailedToRun == nil {
			return result, fmt.Errorf("field \"executionFailedToRun\" is required")
		}
		return v.VisitExecutionFailedToRun(ctx, *u.executionFailedToRun)
	case "executionRetriggered":
		if u.executionRetriggered == nil {
			return result, fmt.Errorf("field \"executionRetriggered\" is required")
		}
		return v.VisitExecutionRetriggered(ctx, *u.executionRetriggered)
	case "executionStarted":
		if u.executionStarted == nil {
			return result, fmt.Errorf("field \"executionStarted\" is required")
		}
		return v.VisitExecutionStarted(ctx, *u.executionStarted)
	}
}

func (u *AutomaticCheckEvaluationActionWithT[T]) AcceptFuncs(executionFinishedFunc func(AutomaticCheckExecutionFinished) (T, error), executionFailedToRunFunc func(AutomaticCheckExecutionFailedToRun) (T, error), executionRetriggeredFunc func(ExecutionRetriggered) (T, error), executionStartedFunc func(AutomaticCheckExecutionStarted) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "executionFinished":
		if u.executionFinished == nil {
			return result, fmt.Errorf("field \"executionFinished\" is required")
		}
		return executionFinishedFunc(*u.executionFinished)
	case "executionFailedToRun":
		if u.executionFailedToRun == nil {
			return result, fmt.Errorf("field \"executionFailedToRun\" is required")
		}
		return executionFailedToRunFunc(*u.executionFailedToRun)
	case "executionRetriggered":
		if u.executionRetriggered == nil {
			return result, fmt.Errorf("field \"executionRetriggered\" is required")
		}
		return executionRetriggeredFunc(*u.executionRetriggered)
	case "executionStarted":
		if u.executionStarted == nil {
			return result, fmt.Errorf("field \"executionStarted\" is required")
		}
		return executionStartedFunc(*u.executionStarted)
	}
}

func (u *AutomaticCheckEvaluationActionWithT[T]) ExecutionFinishedNoopSuccess(AutomaticCheckExecutionFinished) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationActionWithT[T]) ExecutionFailedToRunNoopSuccess(AutomaticCheckExecutionFailedToRun) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationActionWithT[T]) ExecutionRetriggeredNoopSuccess(ExecutionRetriggered) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationActionWithT[T]) ExecutionStartedNoopSuccess(AutomaticCheckExecutionStarted) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationActionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type AutomaticCheckEvaluationActionVisitorWithT[T any] interface {
	VisitExecutionFinished(ctx context.Context, v AutomaticCheckExecutionFinished) (T, error)
	VisitExecutionFailedToRun(ctx context.Context, v AutomaticCheckExecutionFailedToRun) (T, error)
	VisitExecutionRetriggered(ctx context.Context, v ExecutionRetriggered) (T, error)
	VisitExecutionStarted(ctx context.Context, v AutomaticCheckExecutionStarted) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type AutomaticCheckEvaluationReviewActionWithT[T any] AutomaticCheckEvaluationReviewAction

func (u *AutomaticCheckEvaluationReviewActionWithT[T]) Accept(ctx context.Context, v AutomaticCheckEvaluationReviewActionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return result, fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return v.VisitCloseWithIgnore(ctx, *u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherAction(ctx, *u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return result, fmt.Errorf("field \"reopen\" is required")
		}
		return v.VisitReopen(ctx, *u.reopen)
	case "reassign":
		if u.reassign == nil {
			return result, fmt.Errorf("field \"reassign\" is required")
		}
		return v.VisitReassign(ctx, *u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return result, fmt.Errorf("field \"updateNotes\" is required")
		}
		return v.VisitUpdateNotes(ctx, *u.updateNotes)
	}
}

func (u *AutomaticCheckEvaluationReviewActionWithT[T]) AcceptFuncs(closeWithIgnoreFunc func(CloseWithIgnoreAlert) (T, error), closeWithFurtherActionFunc func(CloseWithFurtherAction) (T, error), reopenFunc func(Reopen) (T, error), reassignFunc func(Reassign) (T, error), updateNotesFunc func(UpdateNotes) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return result, fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return closeWithIgnoreFunc(*u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return closeWithFurtherActionFunc(*u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return result, fmt.Errorf("field \"reopen\" is required")
		}
		return reopenFunc(*u.reopen)
	case "reassign":
		if u.reassign == nil {
			return result, fmt.Errorf("field \"reassign\" is required")
		}
		return reassignFunc(*u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return result, fmt.Errorf("field \"updateNotes\" is required")
		}
		return updateNotesFunc(*u.updateNotes)
	}
}

func (u *AutomaticCheckEvaluationReviewActionWithT[T]) CloseWithIgnoreNoopSuccess(CloseWithIgnoreAlert) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationReviewActionWithT[T]) CloseWithFurtherActionNoopSuccess(CloseWithFurtherAction) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationReviewActionWithT[T]) ReopenNoopSuccess(Reopen) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationReviewActionWithT[T]) ReassignNoopSuccess(Reassign) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationReviewActionWithT[T]) UpdateNotesNoopSuccess(UpdateNotes) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationReviewActionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type AutomaticCheckEvaluationReviewActionVisitorWithT[T any] interface {
	VisitCloseWithIgnore(ctx context.Context, v CloseWithIgnoreAlert) (T, error)
	VisitCloseWithFurtherAction(ctx context.Context, v CloseWithFurtherAction) (T, error)
	VisitReopen(ctx context.Context, v Reopen) (T, error)
	VisitReassign(ctx context.Context, v Reassign) (T, error)
	VisitUpdateNotes(ctx context.Context, v UpdateNotes) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type AutomaticCheckEvaluationStateWithT[T any] AutomaticCheckEvaluationState

func (u *AutomaticCheckEvaluationStateWithT[T]) Accept(ctx context.Context, v AutomaticCheckEvaluationStateVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "pendingExecution":
		if u.pendingExecution == nil {
			return result, fmt.Errorf("field \"pendingExecution\" is required")
		}
		return v.VisitPendingExecution(ctx, *u.pendingExecution)
	case "failedToExecute":
		if u.failedToExecute == nil {
			return result, fmt.Errorf("field \"failedToExecute\" is required")
		}
		return v.VisitFailedToExecute(ctx, *u.failedToExecute)
	case "passing":
		if u.passing == nil {
			return result, fmt.Errorf("field \"passing\" is required")
		}
		return v.VisitPassing(ctx, *u.passing)
	case "generatedAlerts":
		if u.generatedAlerts == nil {
			return result, fmt.Errorf("field \"generatedAlerts\" is required")
		}
		return v.VisitGeneratedAlerts(ctx, *u.generatedAlerts)
	case "tooManyAlerts":
		if u.tooManyAlerts == nil {
			return result, fmt.Errorf("field \"tooManyAlerts\" is required")
		}
		return v.VisitTooManyAlerts(ctx, *u.tooManyAlerts)
	case "executing":
		if u.executing == nil {
			return result, fmt.Errorf("field \"executing\" is required")
		}
		return v.VisitExecuting(ctx, *u.executing)
	}
}

func (u *AutomaticCheckEvaluationStateWithT[T]) AcceptFuncs(pendingExecutionFunc func(PendingExecutionState) (T, error), failedToExecuteFunc func(FailedToExecuteState) (T, error), passingFunc func(PassingExecutionState) (T, error), generatedAlertsFunc func(GeneratedAlertsState) (T, error), tooManyAlertsFunc func(TooManyAlertsState) (T, error), executingFunc func(ExecutingState) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pendingExecution":
		if u.pendingExecution == nil {
			return result, fmt.Errorf("field \"pendingExecution\" is required")
		}
		return pendingExecutionFunc(*u.pendingExecution)
	case "failedToExecute":
		if u.failedToExecute == nil {
			return result, fmt.Errorf("field \"failedToExecute\" is required")
		}
		return failedToExecuteFunc(*u.failedToExecute)
	case "passing":
		if u.passing == nil {
			return result, fmt.Errorf("field \"passing\" is required")
		}
		return passingFunc(*u.passing)
	case "generatedAlerts":
		if u.generatedAlerts == nil {
			return result, fmt.Errorf("field \"generatedAlerts\" is required")
		}
		return generatedAlertsFunc(*u.generatedAlerts)
	case "tooManyAlerts":
		if u.tooManyAlerts == nil {
			return result, fmt.Errorf("field \"tooManyAlerts\" is required")
		}
		return tooManyAlertsFunc(*u.tooManyAlerts)
	case "executing":
		if u.executing == nil {
			return result, fmt.Errorf("field \"executing\" is required")
		}
		return executingFunc(*u.executing)
	}
}

func (u *AutomaticCheckEvaluationStateWithT[T]) PendingExecutionNoopSuccess(PendingExecutionState) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationStateWithT[T]) FailedToExecuteNoopSuccess(FailedToExecuteState) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationStateWithT[T]) PassingNoopSuccess(PassingExecutionState) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationStateWithT[T]) GeneratedAlertsNoopSuccess(GeneratedAlertsState) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationStateWithT[T]) TooManyAlertsNoopSuccess(TooManyAlertsState) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationStateWithT[T]) ExecutingNoopSuccess(ExecutingState) (T, error) {
	var result T
	return result, nil
}

func (u *AutomaticCheckEvaluationStateWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type AutomaticCheckEvaluationStateVisitorWithT[T any] interface {
	VisitPendingExecution(ctx context.Context, v PendingExecutionState) (T, error)
	VisitFailedToExecute(ctx context.Context, v FailedToExecuteState) (T, error)
	VisitPassing(ctx context.Context, v PassingExecutionState) (T, error)
	VisitGeneratedAlerts(ctx context.Context, v GeneratedAlertsState) (T, error)
	VisitTooManyAlerts(ctx context.Context, v TooManyAlertsState) (T, error)
	VisitExecuting(ctx context.Context, v ExecutingState) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CheckAlertActionWithT[T any] CheckAlertAction

func (u *CheckAlertActionWithT[T]) Accept(ctx context.Context, v CheckAlertActionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return result, fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return v.VisitCloseWithIgnore(ctx, *u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherAction(ctx, *u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return result, fmt.Errorf("field \"reopen\" is required")
		}
		return v.VisitReopen(ctx, *u.reopen)
	case "reassign":
		if u.reassign == nil {
			return result, fmt.Errorf("field \"reassign\" is required")
		}
		return v.VisitReassign(ctx, *u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return result, fmt.Errorf("field \"updateNotes\" is required")
		}
		return v.VisitUpdateNotes(ctx, *u.updateNotes)
	case "linkNotebook":
		if u.linkNotebook == nil {
			return result, fmt.Errorf("field \"linkNotebook\" is required")
		}
		return v.VisitLinkNotebook(ctx, *u.linkNotebook)
	case "unlinkNotebook":
		if u.unlinkNotebook == nil {
			return result, fmt.Errorf("field \"unlinkNotebook\" is required")
		}
		return v.VisitUnlinkNotebook(ctx, *u.unlinkNotebook)
	case "archiveDataReview":
		if u.archiveDataReview == nil {
			return result, fmt.Errorf("field \"archiveDataReview\" is required")
		}
		return v.VisitArchiveDataReview(ctx, *u.archiveDataReview)
	case "unarchiveDataReview":
		if u.unarchiveDataReview == nil {
			return result, fmt.Errorf("field \"unarchiveDataReview\" is required")
		}
		return v.VisitUnarchiveDataReview(ctx, *u.unarchiveDataReview)
	}
}

func (u *CheckAlertActionWithT[T]) AcceptFuncs(closeWithIgnoreFunc func(CloseWithIgnoreAlert) (T, error), closeWithFurtherActionFunc func(CloseWithFurtherAction) (T, error), reopenFunc func(Reopen) (T, error), reassignFunc func(Reassign) (T, error), updateNotesFunc func(UpdateNotes) (T, error), linkNotebookFunc func(LinkNotebook) (T, error), unlinkNotebookFunc func(UnlinkNotebook) (T, error), archiveDataReviewFunc func(ArchiveDataReview) (T, error), unarchiveDataReviewFunc func(UnarchiveDataReview) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return result, fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return closeWithIgnoreFunc(*u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return closeWithFurtherActionFunc(*u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return result, fmt.Errorf("field \"reopen\" is required")
		}
		return reopenFunc(*u.reopen)
	case "reassign":
		if u.reassign == nil {
			return result, fmt.Errorf("field \"reassign\" is required")
		}
		return reassignFunc(*u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return result, fmt.Errorf("field \"updateNotes\" is required")
		}
		return updateNotesFunc(*u.updateNotes)
	case "linkNotebook":
		if u.linkNotebook == nil {
			return result, fmt.Errorf("field \"linkNotebook\" is required")
		}
		return linkNotebookFunc(*u.linkNotebook)
	case "unlinkNotebook":
		if u.unlinkNotebook == nil {
			return result, fmt.Errorf("field \"unlinkNotebook\" is required")
		}
		return unlinkNotebookFunc(*u.unlinkNotebook)
	case "archiveDataReview":
		if u.archiveDataReview == nil {
			return result, fmt.Errorf("field \"archiveDataReview\" is required")
		}
		return archiveDataReviewFunc(*u.archiveDataReview)
	case "unarchiveDataReview":
		if u.unarchiveDataReview == nil {
			return result, fmt.Errorf("field \"unarchiveDataReview\" is required")
		}
		return unarchiveDataReviewFunc(*u.unarchiveDataReview)
	}
}

func (u *CheckAlertActionWithT[T]) CloseWithIgnoreNoopSuccess(CloseWithIgnoreAlert) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertActionWithT[T]) CloseWithFurtherActionNoopSuccess(CloseWithFurtherAction) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertActionWithT[T]) ReopenNoopSuccess(Reopen) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertActionWithT[T]) ReassignNoopSuccess(Reassign) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertActionWithT[T]) UpdateNotesNoopSuccess(UpdateNotes) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertActionWithT[T]) LinkNotebookNoopSuccess(LinkNotebook) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertActionWithT[T]) UnlinkNotebookNoopSuccess(UnlinkNotebook) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertActionWithT[T]) ArchiveDataReviewNoopSuccess(ArchiveDataReview) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertActionWithT[T]) UnarchiveDataReviewNoopSuccess(UnarchiveDataReview) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertActionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CheckAlertActionVisitorWithT[T any] interface {
	VisitCloseWithIgnore(ctx context.Context, v CloseWithIgnoreAlert) (T, error)
	VisitCloseWithFurtherAction(ctx context.Context, v CloseWithFurtherAction) (T, error)
	VisitReopen(ctx context.Context, v Reopen) (T, error)
	VisitReassign(ctx context.Context, v Reassign) (T, error)
	VisitUpdateNotes(ctx context.Context, v UpdateNotes) (T, error)
	VisitLinkNotebook(ctx context.Context, v LinkNotebook) (T, error)
	VisitUnlinkNotebook(ctx context.Context, v UnlinkNotebook) (T, error)
	VisitArchiveDataReview(ctx context.Context, v ArchiveDataReview) (T, error)
	VisitUnarchiveDataReview(ctx context.Context, v UnarchiveDataReview) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CheckAlertsHistogramBucketsWithT[T any] CheckAlertsHistogramBuckets

func (u *CheckAlertsHistogramBucketsWithT[T]) Accept(ctx context.Context, v CheckAlertsHistogramBucketsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "unstacked":
		if u.unstacked == nil {
			return result, fmt.Errorf("field \"unstacked\" is required")
		}
		return v.VisitUnstacked(ctx, *u.unstacked)
	case "priority":
		if u.priority == nil {
			return result, fmt.Errorf("field \"priority\" is required")
		}
		return v.VisitPriority(ctx, *u.priority)
	case "status":
		if u.status == nil {
			return result, fmt.Errorf("field \"status\" is required")
		}
		return v.VisitStatus(ctx, *u.status)
	}
}

func (u *CheckAlertsHistogramBucketsWithT[T]) AcceptFuncs(unstackedFunc func(CheckAlertsUnstackedHistogram) (T, error), priorityFunc func(CheckAlertsPriorityHistogram) (T, error), statusFunc func(CheckAlertsStatusHistogram) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "unstacked":
		if u.unstacked == nil {
			return result, fmt.Errorf("field \"unstacked\" is required")
		}
		return unstackedFunc(*u.unstacked)
	case "priority":
		if u.priority == nil {
			return result, fmt.Errorf("field \"priority\" is required")
		}
		return priorityFunc(*u.priority)
	case "status":
		if u.status == nil {
			return result, fmt.Errorf("field \"status\" is required")
		}
		return statusFunc(*u.status)
	}
}

func (u *CheckAlertsHistogramBucketsWithT[T]) UnstackedNoopSuccess(CheckAlertsUnstackedHistogram) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertsHistogramBucketsWithT[T]) PriorityNoopSuccess(CheckAlertsPriorityHistogram) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertsHistogramBucketsWithT[T]) StatusNoopSuccess(CheckAlertsStatusHistogram) (T, error) {
	var result T
	return result, nil
}

func (u *CheckAlertsHistogramBucketsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CheckAlertsHistogramBucketsVisitorWithT[T any] interface {
	VisitUnstacked(ctx context.Context, v CheckAlertsUnstackedHistogram) (T, error)
	VisitPriority(ctx context.Context, v CheckAlertsPriorityHistogram) (T, error)
	VisitStatus(ctx context.Context, v CheckAlertsStatusHistogram) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CheckEvaluationWithT[T any] CheckEvaluation

func (u *CheckEvaluationWithT[T]) Accept(ctx context.Context, v CheckEvaluationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "automaticCheck":
		if u.automaticCheck == nil {
			return result, fmt.Errorf("field \"automaticCheck\" is required")
		}
		return v.VisitAutomaticCheck(ctx, *u.automaticCheck)
	case "manualCheck":
		if u.manualCheck == nil {
			return result, fmt.Errorf("field \"manualCheck\" is required")
		}
		return v.VisitManualCheck(ctx, *u.manualCheck)
	}
}

func (u *CheckEvaluationWithT[T]) AcceptFuncs(automaticCheckFunc func(AutomaticCheckEvaluation) (T, error), manualCheckFunc func(ManualCheckEvaluation) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "automaticCheck":
		if u.automaticCheck == nil {
			return result, fmt.Errorf("field \"automaticCheck\" is required")
		}
		return automaticCheckFunc(*u.automaticCheck)
	case "manualCheck":
		if u.manualCheck == nil {
			return result, fmt.Errorf("field \"manualCheck\" is required")
		}
		return manualCheckFunc(*u.manualCheck)
	}
}

func (u *CheckEvaluationWithT[T]) AutomaticCheckNoopSuccess(AutomaticCheckEvaluation) (T, error) {
	var result T
	return result, nil
}

func (u *CheckEvaluationWithT[T]) ManualCheckNoopSuccess(ManualCheckEvaluation) (T, error) {
	var result T
	return result, nil
}

func (u *CheckEvaluationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CheckEvaluationVisitorWithT[T any] interface {
	VisitAutomaticCheck(ctx context.Context, v AutomaticCheckEvaluation) (T, error)
	VisitManualCheck(ctx context.Context, v ManualCheckEvaluation) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CloseActionWithT[T any] CloseAction

func (u *CloseActionWithT[T]) Accept(ctx context.Context, v CloseActionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return result, fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return v.VisitCloseWithIgnore(ctx, *u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherAction(ctx, *u.closeWithFurtherAction)
	}
}

func (u *CloseActionWithT[T]) AcceptFuncs(closeWithIgnoreFunc func(CloseWithIgnoreAlert) (T, error), closeWithFurtherActionFunc func(CloseWithFurtherAction) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "closeWithIgnore":
		if u.closeWithIgnore == nil {
			return result, fmt.Errorf("field \"closeWithIgnore\" is required")
		}
		return closeWithIgnoreFunc(*u.closeWithIgnore)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return closeWithFurtherActionFunc(*u.closeWithFurtherAction)
	}
}

func (u *CloseActionWithT[T]) CloseWithIgnoreNoopSuccess(CloseWithIgnoreAlert) (T, error) {
	var result T
	return result, nil
}

func (u *CloseActionWithT[T]) CloseWithFurtherActionNoopSuccess(CloseWithFurtherAction) (T, error) {
	var result T
	return result, nil
}

func (u *CloseActionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CloseActionVisitorWithT[T any] interface {
	VisitCloseWithIgnore(ctx context.Context, v CloseWithIgnoreAlert) (T, error)
	VisitCloseWithFurtherAction(ctx context.Context, v CloseWithFurtherAction) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type CloseStrategyWithT[T any] CloseStrategy

func (u *CloseStrategyWithT[T]) Accept(ctx context.Context, v CloseStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "closeAllLinkedAlerts":
		if u.closeAllLinkedAlerts == nil {
			return result, fmt.Errorf("field \"closeAllLinkedAlerts\" is required")
		}
		return v.VisitCloseAllLinkedAlerts(ctx, *u.closeAllLinkedAlerts)
	case "closeAndDetachFromNotebook":
		if u.closeAndDetachFromNotebook == nil {
			return result, fmt.Errorf("field \"closeAndDetachFromNotebook\" is required")
		}
		return v.VisitCloseAndDetachFromNotebook(ctx, *u.closeAndDetachFromNotebook)
	case "closeAndDuplicatePreviouslyLinkedNotebook":
		if u.closeAndDuplicatePreviouslyLinkedNotebook == nil {
			return result, fmt.Errorf("field \"closeAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return v.VisitCloseAndDuplicatePreviouslyLinkedNotebook(ctx, *u.closeAndDuplicatePreviouslyLinkedNotebook)
	}
}

func (u *CloseStrategyWithT[T]) AcceptFuncs(closeAllLinkedAlertsFunc func(CloseAllLinkedAlerts) (T, error), closeAndDetachFromNotebookFunc func(CloseAndDetachFromNotebook) (T, error), closeAndDuplicatePreviouslyLinkedNotebookFunc func(CloseAndDuplicatePreviouslyLinkedNotebook) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "closeAllLinkedAlerts":
		if u.closeAllLinkedAlerts == nil {
			return result, fmt.Errorf("field \"closeAllLinkedAlerts\" is required")
		}
		return closeAllLinkedAlertsFunc(*u.closeAllLinkedAlerts)
	case "closeAndDetachFromNotebook":
		if u.closeAndDetachFromNotebook == nil {
			return result, fmt.Errorf("field \"closeAndDetachFromNotebook\" is required")
		}
		return closeAndDetachFromNotebookFunc(*u.closeAndDetachFromNotebook)
	case "closeAndDuplicatePreviouslyLinkedNotebook":
		if u.closeAndDuplicatePreviouslyLinkedNotebook == nil {
			return result, fmt.Errorf("field \"closeAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return closeAndDuplicatePreviouslyLinkedNotebookFunc(*u.closeAndDuplicatePreviouslyLinkedNotebook)
	}
}

func (u *CloseStrategyWithT[T]) CloseAllLinkedAlertsNoopSuccess(CloseAllLinkedAlerts) (T, error) {
	var result T
	return result, nil
}

func (u *CloseStrategyWithT[T]) CloseAndDetachFromNotebookNoopSuccess(CloseAndDetachFromNotebook) (T, error) {
	var result T
	return result, nil
}

func (u *CloseStrategyWithT[T]) CloseAndDuplicatePreviouslyLinkedNotebookNoopSuccess(CloseAndDuplicatePreviouslyLinkedNotebook) (T, error) {
	var result T
	return result, nil
}

func (u *CloseStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type CloseStrategyVisitorWithT[T any] interface {
	VisitCloseAllLinkedAlerts(ctx context.Context, v CloseAllLinkedAlerts) (T, error)
	VisitCloseAndDetachFromNotebook(ctx context.Context, v CloseAndDetachFromNotebook) (T, error)
	VisitCloseAndDuplicatePreviouslyLinkedNotebook(ctx context.Context, v CloseAndDuplicatePreviouslyLinkedNotebook) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type DataReviewCheckMetricsScopeWithT[T any] DataReviewCheckMetricsScope

func (u *DataReviewCheckMetricsScopeWithT[T]) Accept(ctx context.Context, v DataReviewCheckMetricsScopeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "runRid":
		if u.runRid == nil {
			return result, fmt.Errorf("field \"runRid\" is required")
		}
		return v.VisitRunRid(ctx, *u.runRid)
	case "assetRid":
		if u.assetRid == nil {
			return result, fmt.Errorf("field \"assetRid\" is required")
		}
		return v.VisitAssetRid(ctx, *u.assetRid)
	case "dataReviewRid":
		if u.dataReviewRid == nil {
			return result, fmt.Errorf("field \"dataReviewRid\" is required")
		}
		return v.VisitDataReviewRid(ctx, *u.dataReviewRid)
	}
}

func (u *DataReviewCheckMetricsScopeWithT[T]) AcceptFuncs(runRidFunc func(api.RunRid) (T, error), assetRidFunc func(api1.AssetRid) (T, error), dataReviewRidFunc func(api1.DataReviewRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "runRid":
		if u.runRid == nil {
			return result, fmt.Errorf("field \"runRid\" is required")
		}
		return runRidFunc(*u.runRid)
	case "assetRid":
		if u.assetRid == nil {
			return result, fmt.Errorf("field \"assetRid\" is required")
		}
		return assetRidFunc(*u.assetRid)
	case "dataReviewRid":
		if u.dataReviewRid == nil {
			return result, fmt.Errorf("field \"dataReviewRid\" is required")
		}
		return dataReviewRidFunc(*u.dataReviewRid)
	}
}

func (u *DataReviewCheckMetricsScopeWithT[T]) RunRidNoopSuccess(api.RunRid) (T, error) {
	var result T
	return result, nil
}

func (u *DataReviewCheckMetricsScopeWithT[T]) AssetRidNoopSuccess(api1.AssetRid) (T, error) {
	var result T
	return result, nil
}

func (u *DataReviewCheckMetricsScopeWithT[T]) DataReviewRidNoopSuccess(api1.DataReviewRid) (T, error) {
	var result T
	return result, nil
}

func (u *DataReviewCheckMetricsScopeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DataReviewCheckMetricsScopeVisitorWithT[T any] interface {
	VisitRunRid(ctx context.Context, v api.RunRid) (T, error)
	VisitAssetRid(ctx context.Context, v api1.AssetRid) (T, error)
	VisitDataReviewRid(ctx context.Context, v api1.DataReviewRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type HistogramDistributionVariableWithT[T any] HistogramDistributionVariable

func (u *HistogramDistributionVariableWithT[T]) Accept(ctx context.Context, v HistogramDistributionVariableVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "startTime":
		if u.startTime == nil {
			return result, fmt.Errorf("field \"startTime\" is required")
		}
		return v.VisitStartTime(ctx, *u.startTime)
	}
}

func (u *HistogramDistributionVariableWithT[T]) AcceptFuncs(startTimeFunc func(HistogramStartTimeVariable) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "startTime":
		if u.startTime == nil {
			return result, fmt.Errorf("field \"startTime\" is required")
		}
		return startTimeFunc(*u.startTime)
	}
}

func (u *HistogramDistributionVariableWithT[T]) StartTimeNoopSuccess(HistogramStartTimeVariable) (T, error) {
	var result T
	return result, nil
}

func (u *HistogramDistributionVariableWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type HistogramDistributionVariableVisitorWithT[T any] interface {
	VisitStartTime(ctx context.Context, v HistogramStartTimeVariable) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type HistogramSubGroupVariableWithT[T any] HistogramSubGroupVariable

func (u *HistogramSubGroupVariableWithT[T]) Accept(ctx context.Context, v HistogramSubGroupVariableVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "priority":
		if u.priority == nil {
			return result, fmt.Errorf("field \"priority\" is required")
		}
		return v.VisitPriority(ctx, *u.priority)
	case "status":
		if u.status == nil {
			return result, fmt.Errorf("field \"status\" is required")
		}
		return v.VisitStatus(ctx, *u.status)
	}
}

func (u *HistogramSubGroupVariableWithT[T]) AcceptFuncs(priorityFunc func(HistogramPriorityVariable) (T, error), statusFunc func(HistogramStatusVariable) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "priority":
		if u.priority == nil {
			return result, fmt.Errorf("field \"priority\" is required")
		}
		return priorityFunc(*u.priority)
	case "status":
		if u.status == nil {
			return result, fmt.Errorf("field \"status\" is required")
		}
		return statusFunc(*u.status)
	}
}

func (u *HistogramSubGroupVariableWithT[T]) PriorityNoopSuccess(HistogramPriorityVariable) (T, error) {
	var result T
	return result, nil
}

func (u *HistogramSubGroupVariableWithT[T]) StatusNoopSuccess(HistogramStatusVariable) (T, error) {
	var result T
	return result, nil
}

func (u *HistogramSubGroupVariableWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type HistogramSubGroupVariableVisitorWithT[T any] interface {
	VisitPriority(ctx context.Context, v HistogramPriorityVariable) (T, error)
	VisitStatus(ctx context.Context, v HistogramStatusVariable) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type LinkNotebookStrategyWithT[T any] LinkNotebookStrategy

func (u *LinkNotebookStrategyWithT[T]) Accept(ctx context.Context, v LinkNotebookStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "duplicateAndLinkToNewNotebook":
		if u.duplicateAndLinkToNewNotebook == nil {
			return result, fmt.Errorf("field \"duplicateAndLinkToNewNotebook\" is required")
		}
		return v.VisitDuplicateAndLinkToNewNotebook(ctx, *u.duplicateAndLinkToNewNotebook)
	case "closeAndLink":
		if u.closeAndLink == nil {
			return result, fmt.Errorf("field \"closeAndLink\" is required")
		}
		return v.VisitCloseAndLink(ctx, *u.closeAndLink)
	case "reopenAndLink":
		if u.reopenAndLink == nil {
			return result, fmt.Errorf("field \"reopenAndLink\" is required")
		}
		return v.VisitReopenAndLink(ctx, *u.reopenAndLink)
	}
}

func (u *LinkNotebookStrategyWithT[T]) AcceptFuncs(duplicateAndLinkToNewNotebookFunc func(DuplicateAndLinkNotebook) (T, error), closeAndLinkFunc func(CloseAndLinkToNotebook) (T, error), reopenAndLinkFunc func(ReopenAndLinkToNotebook) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "duplicateAndLinkToNewNotebook":
		if u.duplicateAndLinkToNewNotebook == nil {
			return result, fmt.Errorf("field \"duplicateAndLinkToNewNotebook\" is required")
		}
		return duplicateAndLinkToNewNotebookFunc(*u.duplicateAndLinkToNewNotebook)
	case "closeAndLink":
		if u.closeAndLink == nil {
			return result, fmt.Errorf("field \"closeAndLink\" is required")
		}
		return closeAndLinkFunc(*u.closeAndLink)
	case "reopenAndLink":
		if u.reopenAndLink == nil {
			return result, fmt.Errorf("field \"reopenAndLink\" is required")
		}
		return reopenAndLinkFunc(*u.reopenAndLink)
	}
}

func (u *LinkNotebookStrategyWithT[T]) DuplicateAndLinkToNewNotebookNoopSuccess(DuplicateAndLinkNotebook) (T, error) {
	var result T
	return result, nil
}

func (u *LinkNotebookStrategyWithT[T]) CloseAndLinkNoopSuccess(CloseAndLinkToNotebook) (T, error) {
	var result T
	return result, nil
}

func (u *LinkNotebookStrategyWithT[T]) ReopenAndLinkNoopSuccess(ReopenAndLinkToNotebook) (T, error) {
	var result T
	return result, nil
}

func (u *LinkNotebookStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LinkNotebookStrategyVisitorWithT[T any] interface {
	VisitDuplicateAndLinkToNewNotebook(ctx context.Context, v DuplicateAndLinkNotebook) (T, error)
	VisitCloseAndLink(ctx context.Context, v CloseAndLinkToNotebook) (T, error)
	VisitReopenAndLink(ctx context.Context, v ReopenAndLinkToNotebook) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ManualCheckAlertActionWithT[T any] ManualCheckAlertAction

func (u *ManualCheckAlertActionWithT[T]) Accept(ctx context.Context, v ManualCheckAlertActionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "pass":
		if u.pass == nil {
			return result, fmt.Errorf("field \"pass\" is required")
		}
		return v.VisitPass(ctx, *u.pass)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return v.VisitCloseWithFurtherAction(ctx, *u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return result, fmt.Errorf("field \"reopen\" is required")
		}
		return v.VisitReopen(ctx, *u.reopen)
	case "reassign":
		if u.reassign == nil {
			return result, fmt.Errorf("field \"reassign\" is required")
		}
		return v.VisitReassign(ctx, *u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return result, fmt.Errorf("field \"updateNotes\" is required")
		}
		return v.VisitUpdateNotes(ctx, *u.updateNotes)
	case "linkNotebook":
		if u.linkNotebook == nil {
			return result, fmt.Errorf("field \"linkNotebook\" is required")
		}
		return v.VisitLinkNotebook(ctx, *u.linkNotebook)
	}
}

func (u *ManualCheckAlertActionWithT[T]) AcceptFuncs(passFunc func(Pass) (T, error), closeWithFurtherActionFunc func(CloseWithFurtherAction) (T, error), reopenFunc func(Reopen) (T, error), reassignFunc func(Reassign) (T, error), updateNotesFunc func(UpdateNotes) (T, error), linkNotebookFunc func(LinkNotebook) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pass":
		if u.pass == nil {
			return result, fmt.Errorf("field \"pass\" is required")
		}
		return passFunc(*u.pass)
	case "closeWithFurtherAction":
		if u.closeWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closeWithFurtherAction\" is required")
		}
		return closeWithFurtherActionFunc(*u.closeWithFurtherAction)
	case "reopen":
		if u.reopen == nil {
			return result, fmt.Errorf("field \"reopen\" is required")
		}
		return reopenFunc(*u.reopen)
	case "reassign":
		if u.reassign == nil {
			return result, fmt.Errorf("field \"reassign\" is required")
		}
		return reassignFunc(*u.reassign)
	case "updateNotes":
		if u.updateNotes == nil {
			return result, fmt.Errorf("field \"updateNotes\" is required")
		}
		return updateNotesFunc(*u.updateNotes)
	case "linkNotebook":
		if u.linkNotebook == nil {
			return result, fmt.Errorf("field \"linkNotebook\" is required")
		}
		return linkNotebookFunc(*u.linkNotebook)
	}
}

func (u *ManualCheckAlertActionWithT[T]) PassNoopSuccess(Pass) (T, error) {
	var result T
	return result, nil
}

func (u *ManualCheckAlertActionWithT[T]) CloseWithFurtherActionNoopSuccess(CloseWithFurtherAction) (T, error) {
	var result T
	return result, nil
}

func (u *ManualCheckAlertActionWithT[T]) ReopenNoopSuccess(Reopen) (T, error) {
	var result T
	return result, nil
}

func (u *ManualCheckAlertActionWithT[T]) ReassignNoopSuccess(Reassign) (T, error) {
	var result T
	return result, nil
}

func (u *ManualCheckAlertActionWithT[T]) UpdateNotesNoopSuccess(UpdateNotes) (T, error) {
	var result T
	return result, nil
}

func (u *ManualCheckAlertActionWithT[T]) LinkNotebookNoopSuccess(LinkNotebook) (T, error) {
	var result T
	return result, nil
}

func (u *ManualCheckAlertActionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ManualCheckAlertActionVisitorWithT[T any] interface {
	VisitPass(ctx context.Context, v Pass) (T, error)
	VisitCloseWithFurtherAction(ctx context.Context, v CloseWithFurtherAction) (T, error)
	VisitReopen(ctx context.Context, v Reopen) (T, error)
	VisitReassign(ctx context.Context, v Reassign) (T, error)
	VisitUpdateNotes(ctx context.Context, v UpdateNotes) (T, error)
	VisitLinkNotebook(ctx context.Context, v LinkNotebook) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ManualCheckEvaluationStateWithT[T any] ManualCheckEvaluationState

func (u *ManualCheckEvaluationStateWithT[T]) Accept(ctx context.Context, v ManualCheckEvaluationStateVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return result, fmt.Errorf("field \"pendingReview\" is required")
		}
		return v.VisitPendingReview(ctx, *u.pendingReview)
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return v.VisitClosedWithFurtherAction(ctx, *u.closedWithFurtherAction)
	case "passing":
		if u.passing == nil {
			return result, fmt.Errorf("field \"passing\" is required")
		}
		return v.VisitPassing(ctx, *u.passing)
	}
}

func (u *ManualCheckEvaluationStateWithT[T]) AcceptFuncs(pendingReviewFunc func(PendingReviewState) (T, error), closedWithFurtherActionFunc func(ClosedWithFurtherActionState) (T, error), passingFunc func(PassState) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pendingReview":
		if u.pendingReview == nil {
			return result, fmt.Errorf("field \"pendingReview\" is required")
		}
		return pendingReviewFunc(*u.pendingReview)
	case "closedWithFurtherAction":
		if u.closedWithFurtherAction == nil {
			return result, fmt.Errorf("field \"closedWithFurtherAction\" is required")
		}
		return closedWithFurtherActionFunc(*u.closedWithFurtherAction)
	case "passing":
		if u.passing == nil {
			return result, fmt.Errorf("field \"passing\" is required")
		}
		return passingFunc(*u.passing)
	}
}

func (u *ManualCheckEvaluationStateWithT[T]) PendingReviewNoopSuccess(PendingReviewState) (T, error) {
	var result T
	return result, nil
}

func (u *ManualCheckEvaluationStateWithT[T]) ClosedWithFurtherActionNoopSuccess(ClosedWithFurtherActionState) (T, error) {
	var result T
	return result, nil
}

func (u *ManualCheckEvaluationStateWithT[T]) PassingNoopSuccess(PassState) (T, error) {
	var result T
	return result, nil
}

func (u *ManualCheckEvaluationStateWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ManualCheckEvaluationStateVisitorWithT[T any] interface {
	VisitPendingReview(ctx context.Context, v PendingReviewState) (T, error)
	VisitClosedWithFurtherAction(ctx context.Context, v ClosedWithFurtherActionState) (T, error)
	VisitPassing(ctx context.Context, v PassState) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ReopenStrategyWithT[T any] ReopenStrategy

func (u *ReopenStrategyWithT[T]) Accept(ctx context.Context, v ReopenStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "reopenAllLinkedAlerts":
		if u.reopenAllLinkedAlerts == nil {
			return result, fmt.Errorf("field \"reopenAllLinkedAlerts\" is required")
		}
		return v.VisitReopenAllLinkedAlerts(ctx, *u.reopenAllLinkedAlerts)
	case "reopenAndDetachFromNotebook":
		if u.reopenAndDetachFromNotebook == nil {
			return result, fmt.Errorf("field \"reopenAndDetachFromNotebook\" is required")
		}
		return v.VisitReopenAndDetachFromNotebook(ctx, *u.reopenAndDetachFromNotebook)
	case "reopenAndDuplicatePreviouslyLinkedNotebook":
		if u.reopenAndDuplicatePreviouslyLinkedNotebook == nil {
			return result, fmt.Errorf("field \"reopenAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return v.VisitReopenAndDuplicatePreviouslyLinkedNotebook(ctx, *u.reopenAndDuplicatePreviouslyLinkedNotebook)
	}
}

func (u *ReopenStrategyWithT[T]) AcceptFuncs(reopenAllLinkedAlertsFunc func(ReopenAllLinkedAlerts) (T, error), reopenAndDetachFromNotebookFunc func(ReopenAndDetachFromNotebook) (T, error), reopenAndDuplicatePreviouslyLinkedNotebookFunc func(ReopenAndDuplicatePreviouslyLinkedNotebook) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "reopenAllLinkedAlerts":
		if u.reopenAllLinkedAlerts == nil {
			return result, fmt.Errorf("field \"reopenAllLinkedAlerts\" is required")
		}
		return reopenAllLinkedAlertsFunc(*u.reopenAllLinkedAlerts)
	case "reopenAndDetachFromNotebook":
		if u.reopenAndDetachFromNotebook == nil {
			return result, fmt.Errorf("field \"reopenAndDetachFromNotebook\" is required")
		}
		return reopenAndDetachFromNotebookFunc(*u.reopenAndDetachFromNotebook)
	case "reopenAndDuplicatePreviouslyLinkedNotebook":
		if u.reopenAndDuplicatePreviouslyLinkedNotebook == nil {
			return result, fmt.Errorf("field \"reopenAndDuplicatePreviouslyLinkedNotebook\" is required")
		}
		return reopenAndDuplicatePreviouslyLinkedNotebookFunc(*u.reopenAndDuplicatePreviouslyLinkedNotebook)
	}
}

func (u *ReopenStrategyWithT[T]) ReopenAllLinkedAlertsNoopSuccess(ReopenAllLinkedAlerts) (T, error) {
	var result T
	return result, nil
}

func (u *ReopenStrategyWithT[T]) ReopenAndDetachFromNotebookNoopSuccess(ReopenAndDetachFromNotebook) (T, error) {
	var result T
	return result, nil
}

func (u *ReopenStrategyWithT[T]) ReopenAndDuplicatePreviouslyLinkedNotebookNoopSuccess(ReopenAndDuplicatePreviouslyLinkedNotebook) (T, error) {
	var result T
	return result, nil
}

func (u *ReopenStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ReopenStrategyVisitorWithT[T any] interface {
	VisitReopenAllLinkedAlerts(ctx context.Context, v ReopenAllLinkedAlerts) (T, error)
	VisitReopenAndDetachFromNotebook(ctx context.Context, v ReopenAndDetachFromNotebook) (T, error)
	VisitReopenAndDuplicatePreviouslyLinkedNotebook(ctx context.Context, v ReopenAndDuplicatePreviouslyLinkedNotebook) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
