// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	werror "github.com/palantir/witchcraft-go-error"
)

// Internal service responsible for handling creation of new users.
type InternalUserCreationServiceClient interface {
	/*
	   Ensures that the user corresponding to the auth header provided exists in the database.
	   Will do nothing if the user already exists.
	*/
	EnsureDatabaseUserExists(ctx context.Context, authHeader bearertoken.Token) error
}

type internalUserCreationServiceClient struct {
	client httpclient.Client
}

func NewInternalUserCreationServiceClient(client httpclient.Client) InternalUserCreationServiceClient {
	return &internalUserCreationServiceClient{client: client}
}

func (c *internalUserCreationServiceClient) EnsureDatabaseUserExists(ctx context.Context, authHeader bearertoken.Token) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("EnsureDatabaseUserExists"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/user-creation/v1/database"))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "ensureDatabaseUserExists failed")
	}
	return nil
}

// Internal service responsible for handling creation of new users.
type InternalUserCreationServiceClientWithAuth interface {
	/*
	   Ensures that the user corresponding to the auth header provided exists in the database.
	   Will do nothing if the user already exists.
	*/
	EnsureDatabaseUserExists(ctx context.Context) error
}

func NewInternalUserCreationServiceClientWithAuth(client InternalUserCreationServiceClient, authHeader bearertoken.Token) InternalUserCreationServiceClientWithAuth {
	return &internalUserCreationServiceClientWithAuth{client: client, authHeader: authHeader}
}

type internalUserCreationServiceClientWithAuth struct {
	client     InternalUserCreationServiceClient
	authHeader bearertoken.Token
}

func (c *internalUserCreationServiceClientWithAuth) EnsureDatabaseUserExists(ctx context.Context) error {
	return c.client.EnsureDatabaseUserExists(ctx, c.authHeader)
}

func NewInternalUserCreationServiceClientWithTokenProvider(client InternalUserCreationServiceClient, tokenProvider httpclient.TokenProvider) InternalUserCreationServiceClientWithAuth {
	return &internalUserCreationServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type internalUserCreationServiceClientWithTokenProvider struct {
	client        InternalUserCreationServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *internalUserCreationServiceClientWithTokenProvider) EnsureDatabaseUserExists(ctx context.Context) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.EnsureDatabaseUserExists(ctx, bearertoken.Token(token))
}
