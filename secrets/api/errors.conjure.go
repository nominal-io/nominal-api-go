// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type secretNotFound struct {
	SecretRid SecretRid `json:"secretRid"`
}

func (o secretNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *secretNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSecretNotFound returns new instance of SecretNotFound error.
func NewSecretNotFound(secretRidArg SecretRid) *SecretNotFound {
	return &SecretNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), secretNotFound: secretNotFound{SecretRid: secretRidArg}}
}

// WrapWithSecretNotFound returns new instance of SecretNotFound error wrapping an existing error.
func WrapWithSecretNotFound(err error, secretRidArg SecretRid) *SecretNotFound {
	return &SecretNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, secretNotFound: secretNotFound{SecretRid: secretRidArg}}
}

// SecretNotFound is an error type.
type SecretNotFound struct {
	errorInstanceID uuid.UUID
	secretNotFound
	cause error
	stack werror.StackTrace
}

// IsSecretNotFound returns true if err is an instance of SecretNotFound.
func IsSecretNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SecretNotFound)
	return ok
}

func (e *SecretNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Secrets:SecretNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SecretNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SecretNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SecretNotFound) Message() string {
	return "NOT_FOUND Secrets:SecretNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SecretNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SecretNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *SecretNotFound) Name() string {
	return "Secrets:SecretNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SecretNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SecretNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"secretRid": e.SecretRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SecretNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"secretRid": e.SecretRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SecretNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SecretNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SecretNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SecretNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.secretNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Secrets:SecretNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SecretNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters secretNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.secretNotFound = parameters
	return nil
}

type secretsNotFound struct {
	SecretRids []SecretRid `json:"secretRids"`
}

func (o secretsNotFound) MarshalJSON() ([]byte, error) {
	if o.SecretRids == nil {
		o.SecretRids = make([]SecretRid, 0)
	}
	type _tmpsecretsNotFound secretsNotFound
	return safejson.Marshal(_tmpsecretsNotFound(o))
}

func (o *secretsNotFound) UnmarshalJSON(data []byte) error {
	type _tmpsecretsNotFound secretsNotFound
	var rawsecretsNotFound _tmpsecretsNotFound
	if err := safejson.Unmarshal(data, &rawsecretsNotFound); err != nil {
		return err
	}
	if rawsecretsNotFound.SecretRids == nil {
		rawsecretsNotFound.SecretRids = make([]SecretRid, 0)
	}
	*o = secretsNotFound(rawsecretsNotFound)
	return nil
}

func (o secretsNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *secretsNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSecretsNotFound returns new instance of SecretsNotFound error.
func NewSecretsNotFound(secretRidsArg []SecretRid) *SecretsNotFound {
	return &SecretsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), secretsNotFound: secretsNotFound{SecretRids: secretRidsArg}}
}

// WrapWithSecretsNotFound returns new instance of SecretsNotFound error wrapping an existing error.
func WrapWithSecretsNotFound(err error, secretRidsArg []SecretRid) *SecretsNotFound {
	return &SecretsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, secretsNotFound: secretsNotFound{SecretRids: secretRidsArg}}
}

// SecretsNotFound is an error type.
type SecretsNotFound struct {
	errorInstanceID uuid.UUID
	secretsNotFound
	cause error
	stack werror.StackTrace
}

// IsSecretsNotFound returns true if err is an instance of SecretsNotFound.
func IsSecretsNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SecretsNotFound)
	return ok
}

func (e *SecretsNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Secrets:SecretsNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SecretsNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SecretsNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SecretsNotFound) Message() string {
	return "NOT_FOUND Secrets:SecretsNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SecretsNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SecretsNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *SecretsNotFound) Name() string {
	return "Secrets:SecretsNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SecretsNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SecretsNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"secretRids": e.SecretRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SecretsNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"secretRids": e.SecretRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SecretsNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SecretsNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SecretsNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SecretsNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.secretsNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Secrets:SecretsNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SecretsNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters secretsNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.secretsNotFound = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Secrets:SecretNotFound", reflect.TypeOf(SecretNotFound{}))
	conjureerrors.RegisterErrorType("Secrets:SecretsNotFound", reflect.TypeOf(SecretsNotFound{}))
}
