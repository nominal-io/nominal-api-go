// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type SearchUsersQuery struct {
	typ        string
	and        *[]SearchUsersQuery
	or         *[]SearchUsersQuery
	exactMatch *string
	searchText *string
}

type searchUsersQueryDeserializer struct {
	Type       string              `json:"type"`
	And        *[]SearchUsersQuery `json:"and"`
	Or         *[]SearchUsersQuery `json:"or"`
	ExactMatch *string             `json:"exactMatch"`
	SearchText *string             `json:"searchText"`
}

func (u *searchUsersQueryDeserializer) toStruct() SearchUsersQuery {
	return SearchUsersQuery{typ: u.Type, and: u.And, or: u.Or, exactMatch: u.ExactMatch, searchText: u.SearchText}
}

func (u *SearchUsersQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string             `json:"type"`
			And  []SearchUsersQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string             `json:"type"`
			Or   []SearchUsersQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "exactMatch":
		if u.exactMatch == nil {
			return nil, fmt.Errorf("field \"exactMatch\" is required")
		}
		return struct {
			Type       string `json:"type"`
			ExactMatch string `json:"exactMatch"`
		}{Type: "exactMatch", ExactMatch: *u.exactMatch}, nil
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	}
}

func (u SearchUsersQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchUsersQuery) UnmarshalJSON(data []byte) error {
	var deser searchUsersQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	}
	return nil
}

func (u SearchUsersQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchUsersQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchUsersQuery) AcceptFuncs(andFunc func([]SearchUsersQuery) error, orFunc func([]SearchUsersQuery) error, exactMatchFunc func(string) error, searchTextFunc func(string) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return exactMatchFunc(*u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	}
}

func (u *SearchUsersQuery) AndNoopSuccess([]SearchUsersQuery) error {
	return nil
}

func (u *SearchUsersQuery) OrNoopSuccess([]SearchUsersQuery) error {
	return nil
}

func (u *SearchUsersQuery) ExactMatchNoopSuccess(string) error {
	return nil
}

func (u *SearchUsersQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *SearchUsersQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchUsersQuery) Accept(v SearchUsersQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatch(*u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	}
}

type SearchUsersQueryVisitor interface {
	VisitAnd(v []SearchUsersQuery) error
	VisitOr(v []SearchUsersQuery) error
	VisitExactMatch(v string) error
	VisitSearchText(v string) error
	VisitUnknown(typeName string) error
}

func (u *SearchUsersQuery) AcceptWithContext(ctx context.Context, v SearchUsersQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "exactMatch":
		if u.exactMatch == nil {
			return fmt.Errorf("field \"exactMatch\" is required")
		}
		return v.VisitExactMatchWithContext(ctx, *u.exactMatch)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	}
}

type SearchUsersQueryVisitorWithContext interface {
	VisitAndWithContext(ctx context.Context, v []SearchUsersQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchUsersQuery) error
	VisitExactMatchWithContext(ctx context.Context, v string) error
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchUsersQueryFromAnd(v []SearchUsersQuery) SearchUsersQuery {
	return SearchUsersQuery{typ: "and", and: &v}
}

func NewSearchUsersQueryFromOr(v []SearchUsersQuery) SearchUsersQuery {
	return SearchUsersQuery{typ: "or", or: &v}
}

func NewSearchUsersQueryFromExactMatch(v string) SearchUsersQuery {
	return SearchUsersQuery{typ: "exactMatch", exactMatch: &v}
}

func NewSearchUsersQueryFromSearchText(v string) SearchUsersQuery {
	return SearchUsersQuery{typ: "searchText", searchText: &v}
}
