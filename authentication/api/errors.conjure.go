// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type multipleUsersForSameEmail struct {
	Email string `json:"email"`
}

func (o multipleUsersForSameEmail) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *multipleUsersForSameEmail) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMultipleUsersForSameEmail returns new instance of MultipleUsersForSameEmail error.
func NewMultipleUsersForSameEmail(emailArg string) *MultipleUsersForSameEmail {
	return &MultipleUsersForSameEmail{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), multipleUsersForSameEmail: multipleUsersForSameEmail{Email: emailArg}}
}

// WrapWithMultipleUsersForSameEmail returns new instance of MultipleUsersForSameEmail error wrapping an existing error.
func WrapWithMultipleUsersForSameEmail(err error, emailArg string) *MultipleUsersForSameEmail {
	return &MultipleUsersForSameEmail{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, multipleUsersForSameEmail: multipleUsersForSameEmail{Email: emailArg}}
}

// MultipleUsersForSameEmail is an error type.
type MultipleUsersForSameEmail struct {
	errorInstanceID uuid.UUID
	multipleUsersForSameEmail
	cause error
	stack werror.StackTrace
}

// IsMultipleUsersForSameEmail returns true if err is an instance of MultipleUsersForSameEmail.
func IsMultipleUsersForSameEmail(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MultipleUsersForSameEmail)
	return ok
}

func (e *MultipleUsersForSameEmail) Error() string {
	return fmt.Sprintf("FAILED_PRECONDITION Authentication:MultipleUsersForSameEmail (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MultipleUsersForSameEmail) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MultipleUsersForSameEmail) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MultipleUsersForSameEmail) Message() string {
	return "FAILED_PRECONDITION Authentication:MultipleUsersForSameEmail"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MultipleUsersForSameEmail) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MultipleUsersForSameEmail) Code() errors.ErrorCode {
	return errors.FailedPrecondition
}

// Name returns an error name identifying error type.
func (e *MultipleUsersForSameEmail) Name() string {
	return "Authentication:MultipleUsersForSameEmail"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MultipleUsersForSameEmail) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MultipleUsersForSameEmail) Parameters() map[string]interface{} {
	return map[string]interface{}{"email": e.Email}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MultipleUsersForSameEmail) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MultipleUsersForSameEmail) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MultipleUsersForSameEmail) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"email": e.Email}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MultipleUsersForSameEmail) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MultipleUsersForSameEmail) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.multipleUsersForSameEmail)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.FailedPrecondition, ErrorName: "Authentication:MultipleUsersForSameEmail", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MultipleUsersForSameEmail) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters multipleUsersForSameEmail
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.multipleUsersForSameEmail = parameters
	return nil
}

type notAuthorized struct{}

func (o notAuthorized) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *notAuthorized) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNotAuthorized returns new instance of NotAuthorized error.
func NewNotAuthorized() *NotAuthorized {
	return &NotAuthorized{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), notAuthorized: notAuthorized{}}
}

// WrapWithNotAuthorized returns new instance of NotAuthorized error wrapping an existing error.
func WrapWithNotAuthorized(err error) *NotAuthorized {
	return &NotAuthorized{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, notAuthorized: notAuthorized{}}
}

// NotAuthorized is an error type.
type NotAuthorized struct {
	errorInstanceID uuid.UUID
	notAuthorized
	cause error
	stack werror.StackTrace
}

// IsNotAuthorized returns true if err is an instance of NotAuthorized.
func IsNotAuthorized(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NotAuthorized)
	return ok
}

func (e *NotAuthorized) Error() string {
	return fmt.Sprintf("PERMISSION_DENIED Authentication:NotAuthorized (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NotAuthorized) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NotAuthorized) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NotAuthorized) Message() string {
	return "PERMISSION_DENIED Authentication:NotAuthorized"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NotAuthorized) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NotAuthorized) Code() errors.ErrorCode {
	return errors.PermissionDenied
}

// Name returns an error name identifying error type.
func (e *NotAuthorized) Name() string {
	return "Authentication:NotAuthorized"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NotAuthorized) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NotAuthorized) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NotAuthorized) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NotAuthorized) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NotAuthorized) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NotAuthorized) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NotAuthorized) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.notAuthorized)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.PermissionDenied, ErrorName: "Authentication:NotAuthorized", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NotAuthorized) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters notAuthorized
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.notAuthorized = parameters
	return nil
}

type orgNotFound struct{}

func (o orgNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *orgNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewOrgNotFound returns new instance of OrgNotFound error.
func NewOrgNotFound() *OrgNotFound {
	return &OrgNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), orgNotFound: orgNotFound{}}
}

// WrapWithOrgNotFound returns new instance of OrgNotFound error wrapping an existing error.
func WrapWithOrgNotFound(err error) *OrgNotFound {
	return &OrgNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, orgNotFound: orgNotFound{}}
}

// OrgNotFound is an error type.
type OrgNotFound struct {
	errorInstanceID uuid.UUID
	orgNotFound
	cause error
	stack werror.StackTrace
}

// IsOrgNotFound returns true if err is an instance of OrgNotFound.
func IsOrgNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*OrgNotFound)
	return ok
}

func (e *OrgNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Authentication:OrgNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *OrgNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *OrgNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *OrgNotFound) Message() string {
	return "NOT_FOUND Authentication:OrgNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *OrgNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *OrgNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *OrgNotFound) Name() string {
	return "Authentication:OrgNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *OrgNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *OrgNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *OrgNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *OrgNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *OrgNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *OrgNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e OrgNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.orgNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Authentication:OrgNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *OrgNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters orgNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.orgNotFound = parameters
	return nil
}

type searchUsersLimitExceeded struct {
	RequestedLimit int `json:"requestedLimit"`
	AllowedLimit   int `json:"allowedLimit"`
}

func (o searchUsersLimitExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *searchUsersLimitExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewSearchUsersLimitExceeded returns new instance of SearchUsersLimitExceeded error.
func NewSearchUsersLimitExceeded(requestedLimitArg int, allowedLimitArg int) *SearchUsersLimitExceeded {
	return &SearchUsersLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), searchUsersLimitExceeded: searchUsersLimitExceeded{RequestedLimit: requestedLimitArg, AllowedLimit: allowedLimitArg}}
}

// WrapWithSearchUsersLimitExceeded returns new instance of SearchUsersLimitExceeded error wrapping an existing error.
func WrapWithSearchUsersLimitExceeded(err error, requestedLimitArg int, allowedLimitArg int) *SearchUsersLimitExceeded {
	return &SearchUsersLimitExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, searchUsersLimitExceeded: searchUsersLimitExceeded{RequestedLimit: requestedLimitArg, AllowedLimit: allowedLimitArg}}
}

// SearchUsersLimitExceeded is an error type.
type SearchUsersLimitExceeded struct {
	errorInstanceID uuid.UUID
	searchUsersLimitExceeded
	cause error
	stack werror.StackTrace
}

// IsSearchUsersLimitExceeded returns true if err is an instance of SearchUsersLimitExceeded.
func IsSearchUsersLimitExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*SearchUsersLimitExceeded)
	return ok
}

func (e *SearchUsersLimitExceeded) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Authentication:SearchUsersLimitExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *SearchUsersLimitExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *SearchUsersLimitExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *SearchUsersLimitExceeded) Message() string {
	return "INVALID_ARGUMENT Authentication:SearchUsersLimitExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *SearchUsersLimitExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *SearchUsersLimitExceeded) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *SearchUsersLimitExceeded) Name() string {
	return "Authentication:SearchUsersLimitExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *SearchUsersLimitExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *SearchUsersLimitExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{"requestedLimit": e.RequestedLimit, "allowedLimit": e.AllowedLimit}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *SearchUsersLimitExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"requestedLimit": e.RequestedLimit, "allowedLimit": e.AllowedLimit, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *SearchUsersLimitExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *SearchUsersLimitExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *SearchUsersLimitExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e SearchUsersLimitExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.searchUsersLimitExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Authentication:SearchUsersLimitExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *SearchUsersLimitExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters searchUsersLimitExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.searchUsersLimitExceeded = parameters
	return nil
}

type userNotFound struct{}

func (o userNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *userNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUserNotFound returns new instance of UserNotFound error.
func NewUserNotFound() *UserNotFound {
	return &UserNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), userNotFound: userNotFound{}}
}

// WrapWithUserNotFound returns new instance of UserNotFound error wrapping an existing error.
func WrapWithUserNotFound(err error) *UserNotFound {
	return &UserNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, userNotFound: userNotFound{}}
}

// UserNotFound is an error type.
type UserNotFound struct {
	errorInstanceID uuid.UUID
	userNotFound
	cause error
	stack werror.StackTrace
}

// IsUserNotFound returns true if err is an instance of UserNotFound.
func IsUserNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*UserNotFound)
	return ok
}

func (e *UserNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Authentication:UserNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *UserNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *UserNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *UserNotFound) Message() string {
	return "NOT_FOUND Authentication:UserNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *UserNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *UserNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *UserNotFound) Name() string {
	return "Authentication:UserNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *UserNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *UserNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *UserNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *UserNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *UserNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *UserNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e UserNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.userNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Authentication:UserNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *UserNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters userNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.userNotFound = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Authentication:MultipleUsersForSameEmail", reflect.TypeOf(MultipleUsersForSameEmail{}))
	conjureerrors.RegisterErrorType("Authentication:NotAuthorized", reflect.TypeOf(NotAuthorized{}))
	conjureerrors.RegisterErrorType("Authentication:OrgNotFound", reflect.TypeOf(OrgNotFound{}))
	conjureerrors.RegisterErrorType("Authentication:SearchUsersLimitExceeded", reflect.TypeOf(SearchUsersLimitExceeded{}))
	conjureerrors.RegisterErrorType("Authentication:UserNotFound", reflect.TypeOf(UserNotFound{}))
}
