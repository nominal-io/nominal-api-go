// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/compute/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/run/api"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

/*
An append result won't cover the full `StreamingComputeNodeRequest#windowWidth` but rather just a smaller
window. The end of the window that the append covers is guaranteed to be later than previously sent results.
The start, however, can and most likely will overlap with previous results. That allows us to support
out-of-order points. The client will have to merge this new `AppendResult` with previous results.
Example of time windows that might be covered by results for a subscription:
We send a full result for window [0s, 120s] followed by an append result for [116s, 121s] and another
append result for [117s, 122s].
*/
type AppendResult struct {
	// The start of the time range that the append result covers
	Start api.Timestamp `conjure-docs:"The start of the time range that the append result covers" json:"start"`
	// The end of the time range that the append result covers
	End    api.Timestamp             `conjure-docs:"The end of the time range that the append result covers" json:"end"`
	Result ComputeNodeAppendResponse `json:"result"`
}

func (o AppendResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AppendResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FullResult struct {
	Result api1.ComputeNodeResponse `json:"result"`
}

func (o FullResult) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FullResult) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GroupedComputeNodeAppendResponse struct {
	Grouping api1.Grouping             `json:"grouping"`
	Response ComputeNodeAppendResponse `json:"response"`
}

func (o GroupedComputeNodeAppendResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GroupedComputeNodeAppendResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Contains a `GroupedComputeNodeAppendResponse` for each applicable grouping along with metadata describing the
grouping. All the contained `GroupedComputeNodeAppendResponse`s are guaranteed to be of the same type.
*/
type GroupedComputeNodeAppendResponses struct {
	Responses []GroupedComputeNodeAppendResponse `json:"responses"`
}

func (o GroupedComputeNodeAppendResponses) MarshalJSON() ([]byte, error) {
	if o.Responses == nil {
		o.Responses = make([]GroupedComputeNodeAppendResponse, 0)
	}
	type _tmpGroupedComputeNodeAppendResponses GroupedComputeNodeAppendResponses
	return safejson.Marshal(_tmpGroupedComputeNodeAppendResponses(o))
}

func (o *GroupedComputeNodeAppendResponses) UnmarshalJSON(data []byte) error {
	type _tmpGroupedComputeNodeAppendResponses GroupedComputeNodeAppendResponses
	var rawGroupedComputeNodeAppendResponses _tmpGroupedComputeNodeAppendResponses
	if err := safejson.Unmarshal(data, &rawGroupedComputeNodeAppendResponses); err != nil {
		return err
	}
	if rawGroupedComputeNodeAppendResponses.Responses == nil {
		rawGroupedComputeNodeAppendResponses.Responses = make([]GroupedComputeNodeAppendResponse, 0)
	}
	*o = GroupedComputeNodeAppendResponses(rawGroupedComputeNodeAppendResponses)
	return nil
}

func (o GroupedComputeNodeAppendResponses) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GroupedComputeNodeAppendResponses) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IsEnabledResponse struct{}

func (o IsEnabledResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IsEnabledResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A ping can be sent by both client and server to keep the connection open and check that it is still working.
The receiving end should send back a pong immediately.
We also include the times that pings and pongs are sent so that we can track latency and/or discover clock
drift between server and client.
*/
type Ping struct {
	SentAt datetime.DateTime `json:"sentAt"`
}

func (o Ping) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Ping) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Pong struct {
	PingOriginallySentAt datetime.DateTime `json:"pingOriginallySentAt"`
	SentAt               datetime.DateTime `json:"sentAt"`
}

func (o Pong) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Pong) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Indicates that the websocket will shut down in the near future. Until it is, SubscriptionUpdates will
still be sent to the client. Clients that want to avoid downtime or latency spikes should initiate a new
websocket and recreate all their subscriptions there but still keep this websocket open until the new
websockets starts sending SubscriptionUpdates.
Note: The initial updates that the new websocket sends might be somewhat stale because of server and
connection pools warm up. The client might want to wait with fully switching to the new subscription until
the updates aren't very stale anymore.
*/
type ShutdownNotice struct{}

func (o ShutdownNotice) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ShutdownNotice) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
A templatized version of `ComputeNodeRequest` where the end of the range will track the current time and
the start of the range tracks `windowWidth` time ago.
*/
type StreamingComputeNodeRequest struct {
	Node        api1.ComputableNode `json:"node"`
	WindowWidth api2.Duration       `json:"windowWidth"`
	Context     api1.Context        `json:"context"`
}

func (o StreamingComputeNodeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StreamingComputeNodeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type StreamingComputeNodeSubscription struct {
	ComputeRequest      StreamingComputeNodeRequest `json:"computeRequest"`
	SubscriptionOptions SubscriptionOptions         `json:"subscriptionOptions"`
}

func (o StreamingComputeNodeSubscription) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *StreamingComputeNodeSubscription) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
This will be sent if there is an error while creating a subscription. This means that the subscription was
never created and the client will have to re-try creating it if warranted.
This can also be sent after a subscription was first successfully started and sent result. In that case it
means that the subscription encountered an unrecoverable error at runtime and will be stopped.
*/
type SubscriptionCreationError struct {
	// A serialized version of the error. Should match the errors defined below.
	SerializableError api.SerializableError `conjure-docs:"A serialized version of the error. Should match the errors defined below." json:"serializableError"`
}

func (o SubscriptionCreationError) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SubscriptionCreationError) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SubscriptionCreationMessage struct {
	SubscriptionId SubscriptionId       `json:"subscriptionId"`
	Creation       SubscriptionCreation `json:"creation"`
}

func (o SubscriptionCreationMessage) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SubscriptionCreationMessage) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Will be returned once a subscriptions has been successfully created.
type SubscriptionCreationSuccess struct {
	UnitResult api1.ComputeUnitResult `json:"unitResult"`
}

func (o SubscriptionCreationSuccess) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SubscriptionCreationSuccess) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SubscriptionOptions struct {
	// The minimum delay between `SubscriptionUpdate`s sent for this subscription.
	MinDelay Milliseconds `conjure-docs:"The minimum delay between \"SubscriptionUpdate\"s sent for this subscription." json:"minDelay"`
	/*
	   Can be set to `false` by the client to indicate that it doesn't support appends for this subscription
	   and always wants to receive full results. Defaults to `false` if not set.
	   The expectation is that clients should implement support for appends for any of the results covered in
	   `ComputeNodeAppendResponse` and set this to `true` as quickly as possible. However, in order to support
	   adding new sub-types to `ComputeNodeAppendResponse` without breaking clients that haven't upgraded yet
	   and haven't yet added support for them, we default this to `false` and make clients opt-in as soon as they
	   implement support.
	*/
	AllowAppends *bool `conjure-docs:"Can be set to \"false\" by the client to indicate that it doesn't support appends for this subscription\nand always wants to receive full results. Defaults to \"false\" if not set.\nThe expectation is that clients should implement support for appends for any of the results covered in\n\"ComputeNodeAppendResponse\" and set this to \"true\" as quickly as possible. However, in order to support \nadding new sub-types to \"ComputeNodeAppendResponse\" without breaking clients that haven't upgraded yet \nand haven't yet added support for them, we default this to \"false\" and make clients opt-in as soon as they\nimplement support." json:"allowAppends,omitempty"`
}

func (o SubscriptionOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SubscriptionOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
This will be sent if there is an error while updating a subscription. Note: This won't automatically cancel
the subscription. The client will have to call `ClientMessage::unsubscribe` to do that if warranted.
*/
type SubscriptionUpdateError struct {
	// A serialized version of the error. Should match the errors defined below.
	SerializableError api.SerializableError `conjure-docs:"A serialized version of the error. Should match the errors defined below." json:"serializableError"`
}

func (o SubscriptionUpdateError) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SubscriptionUpdateError) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SubscriptionUpdateMessage struct {
	SubscriptionId SubscriptionId     `json:"subscriptionId"`
	Update         SubscriptionUpdate `json:"update"`
}

func (o SubscriptionUpdateMessage) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SubscriptionUpdateMessage) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
