// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	werror "github.com/palantir/witchcraft-go-error"
)

// Exposes a simple endpoints for checking whether or not persistent compute is enabled.
type PersistentComputeServiceClient interface {
	// Simple "ping" like endpoint to see if the service is enabled (and available).
	IsEnabled(ctx context.Context, authHeader bearertoken.Token) (IsEnabledResponse, error)
}

type persistentComputeServiceClient struct {
	client httpclient.Client
}

func NewPersistentComputeServiceClient(client httpclient.Client) PersistentComputeServiceClient {
	return &persistentComputeServiceClient{client: client}
}

func (c *persistentComputeServiceClient) IsEnabled(ctx context.Context, authHeader bearertoken.Token) (IsEnabledResponse, error) {
	var defaultReturnVal IsEnabledResponse
	var returnVal *IsEnabledResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("IsEnabled"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/persistent-compute/enabled"))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "isEnabled failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "isEnabled response cannot be nil")
	}
	return *returnVal, nil
}

// Exposes a simple endpoints for checking whether or not persistent compute is enabled.
type PersistentComputeServiceClientWithAuth interface {
	// Simple "ping" like endpoint to see if the service is enabled (and available).
	IsEnabled(ctx context.Context) (IsEnabledResponse, error)
}

func NewPersistentComputeServiceClientWithAuth(client PersistentComputeServiceClient, authHeader bearertoken.Token) PersistentComputeServiceClientWithAuth {
	return &persistentComputeServiceClientWithAuth{client: client, authHeader: authHeader}
}

type persistentComputeServiceClientWithAuth struct {
	client     PersistentComputeServiceClient
	authHeader bearertoken.Token
}

func (c *persistentComputeServiceClientWithAuth) IsEnabled(ctx context.Context) (IsEnabledResponse, error) {
	return c.client.IsEnabled(ctx, c.authHeader)
}

func NewPersistentComputeServiceClientWithTokenProvider(client PersistentComputeServiceClient, tokenProvider httpclient.TokenProvider) PersistentComputeServiceClientWithAuth {
	return &persistentComputeServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type persistentComputeServiceClientWithTokenProvider struct {
	client        PersistentComputeServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *persistentComputeServiceClientWithTokenProvider) IsEnabled(ctx context.Context) (IsEnabledResponse, error) {
	var defaultReturnVal IsEnabledResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.IsEnabled(ctx, bearertoken.Token(token))
}
