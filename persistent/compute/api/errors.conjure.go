// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type invalidClientMessage struct{}

func (o invalidClientMessage) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidClientMessage) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidClientMessage returns new instance of InvalidClientMessage error.
func NewInvalidClientMessage() *InvalidClientMessage {
	return &InvalidClientMessage{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidClientMessage: invalidClientMessage{}}
}

// WrapWithInvalidClientMessage returns new instance of InvalidClientMessage error wrapping an existing error.
func WrapWithInvalidClientMessage(err error) *InvalidClientMessage {
	return &InvalidClientMessage{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidClientMessage: invalidClientMessage{}}
}

// InvalidClientMessage is an error type.
// Could not parse client message.
type InvalidClientMessage struct {
	errorInstanceID uuid.UUID
	invalidClientMessage
	cause error
	stack werror.StackTrace
}

// IsInvalidClientMessage returns true if err is an instance of InvalidClientMessage.
func IsInvalidClientMessage(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidClientMessage)
	return ok
}

func (e *InvalidClientMessage) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT PersistentCompute:InvalidClientMessage (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidClientMessage) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidClientMessage) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidClientMessage) Message() string {
	return "INVALID_ARGUMENT PersistentCompute:InvalidClientMessage"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidClientMessage) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidClientMessage) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidClientMessage) Name() string {
	return "PersistentCompute:InvalidClientMessage"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidClientMessage) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidClientMessage) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidClientMessage) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidClientMessage) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidClientMessage) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidClientMessage) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidClientMessage) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidClientMessage)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "PersistentCompute:InvalidClientMessage", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidClientMessage) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidClientMessage
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidClientMessage = parameters
	return nil
}

type invalidComputation struct {
	InvalidTypes []InvalidComputationType `json:"invalidTypes"`
}

func (o invalidComputation) MarshalJSON() ([]byte, error) {
	if o.InvalidTypes == nil {
		o.InvalidTypes = make([]InvalidComputationType, 0)
	}
	type _tmpinvalidComputation invalidComputation
	return safejson.Marshal(_tmpinvalidComputation(o))
}

func (o *invalidComputation) UnmarshalJSON(data []byte) error {
	type _tmpinvalidComputation invalidComputation
	var rawinvalidComputation _tmpinvalidComputation
	if err := safejson.Unmarshal(data, &rawinvalidComputation); err != nil {
		return err
	}
	if rawinvalidComputation.InvalidTypes == nil {
		rawinvalidComputation.InvalidTypes = make([]InvalidComputationType, 0)
	}
	*o = invalidComputation(rawinvalidComputation)
	return nil
}

func (o invalidComputation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidComputation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidComputation returns new instance of InvalidComputation error.
func NewInvalidComputation(invalidTypesArg []InvalidComputationType) *InvalidComputation {
	return &InvalidComputation{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidComputation: invalidComputation{InvalidTypes: invalidTypesArg}}
}

// WrapWithInvalidComputation returns new instance of InvalidComputation error wrapping an existing error.
func WrapWithInvalidComputation(err error, invalidTypesArg []InvalidComputationType) *InvalidComputation {
	return &InvalidComputation{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidComputation: invalidComputation{InvalidTypes: invalidTypesArg}}
}

// InvalidComputation is an error type.
type InvalidComputation struct {
	errorInstanceID uuid.UUID
	invalidComputation
	cause error
	stack werror.StackTrace
}

// IsInvalidComputation returns true if err is an instance of InvalidComputation.
func IsInvalidComputation(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidComputation)
	return ok
}

func (e *InvalidComputation) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT PersistentCompute:InvalidComputation (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidComputation) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidComputation) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidComputation) Message() string {
	return "INVALID_ARGUMENT PersistentCompute:InvalidComputation"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidComputation) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidComputation) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidComputation) Name() string {
	return "PersistentCompute:InvalidComputation"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidComputation) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidComputation) Parameters() map[string]interface{} {
	return map[string]interface{}{"invalidTypes": e.InvalidTypes}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidComputation) safeParams() map[string]interface{} {
	return map[string]interface{}{"invalidTypes": e.InvalidTypes, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidComputation) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidComputation) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidComputation) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidComputation) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidComputation)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "PersistentCompute:InvalidComputation", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidComputation) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidComputation
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidComputation = parameters
	return nil
}

type nonNominalStorageLocator struct{}

func (o nonNominalStorageLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *nonNominalStorageLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNonNominalStorageLocator returns new instance of NonNominalStorageLocator error.
func NewNonNominalStorageLocator() *NonNominalStorageLocator {
	return &NonNominalStorageLocator{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), nonNominalStorageLocator: nonNominalStorageLocator{}}
}

// WrapWithNonNominalStorageLocator returns new instance of NonNominalStorageLocator error wrapping an existing error.
func WrapWithNonNominalStorageLocator(err error) *NonNominalStorageLocator {
	return &NonNominalStorageLocator{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, nonNominalStorageLocator: nonNominalStorageLocator{}}
}

// NonNominalStorageLocator is an error type.
type NonNominalStorageLocator struct {
	errorInstanceID uuid.UUID
	nonNominalStorageLocator
	cause error
	stack werror.StackTrace
}

// IsNonNominalStorageLocator returns true if err is an instance of NonNominalStorageLocator.
func IsNonNominalStorageLocator(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NonNominalStorageLocator)
	return ok
}

func (e *NonNominalStorageLocator) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT PersistentCompute:NonNominalStorageLocator (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NonNominalStorageLocator) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NonNominalStorageLocator) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NonNominalStorageLocator) Message() string {
	return "INVALID_ARGUMENT PersistentCompute:NonNominalStorageLocator"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NonNominalStorageLocator) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NonNominalStorageLocator) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *NonNominalStorageLocator) Name() string {
	return "PersistentCompute:NonNominalStorageLocator"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NonNominalStorageLocator) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NonNominalStorageLocator) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NonNominalStorageLocator) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NonNominalStorageLocator) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NonNominalStorageLocator) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NonNominalStorageLocator) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NonNominalStorageLocator) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.nonNominalStorageLocator)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "PersistentCompute:NonNominalStorageLocator", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NonNominalStorageLocator) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters nonNominalStorageLocator
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.nonNominalStorageLocator = parameters
	return nil
}

type permissionDenied struct {
	Rids []rid.ResourceIdentifier `json:"rids"`
}

func (o permissionDenied) MarshalJSON() ([]byte, error) {
	if o.Rids == nil {
		o.Rids = make([]rid.ResourceIdentifier, 0)
	}
	type _tmppermissionDenied permissionDenied
	return safejson.Marshal(_tmppermissionDenied(o))
}

func (o *permissionDenied) UnmarshalJSON(data []byte) error {
	type _tmppermissionDenied permissionDenied
	var rawpermissionDenied _tmppermissionDenied
	if err := safejson.Unmarshal(data, &rawpermissionDenied); err != nil {
		return err
	}
	if rawpermissionDenied.Rids == nil {
		rawpermissionDenied.Rids = make([]rid.ResourceIdentifier, 0)
	}
	*o = permissionDenied(rawpermissionDenied)
	return nil
}

func (o permissionDenied) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *permissionDenied) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewPermissionDenied returns new instance of PermissionDenied error.
func NewPermissionDenied(ridsArg []rid.ResourceIdentifier) *PermissionDenied {
	return &PermissionDenied{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), permissionDenied: permissionDenied{Rids: ridsArg}}
}

// WrapWithPermissionDenied returns new instance of PermissionDenied error wrapping an existing error.
func WrapWithPermissionDenied(err error, ridsArg []rid.ResourceIdentifier) *PermissionDenied {
	return &PermissionDenied{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, permissionDenied: permissionDenied{Rids: ridsArg}}
}

// PermissionDenied is an error type.
type PermissionDenied struct {
	errorInstanceID uuid.UUID
	permissionDenied
	cause error
	stack werror.StackTrace
}

// IsPermissionDenied returns true if err is an instance of PermissionDenied.
func IsPermissionDenied(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*PermissionDenied)
	return ok
}

func (e *PermissionDenied) Error() string {
	return fmt.Sprintf("PERMISSION_DENIED PersistentCompute:PermissionDenied (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *PermissionDenied) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *PermissionDenied) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *PermissionDenied) Message() string {
	return "PERMISSION_DENIED PersistentCompute:PermissionDenied"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *PermissionDenied) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *PermissionDenied) Code() errors.ErrorCode {
	return errors.PermissionDenied
}

// Name returns an error name identifying error type.
func (e *PermissionDenied) Name() string {
	return "PersistentCompute:PermissionDenied"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *PermissionDenied) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *PermissionDenied) Parameters() map[string]interface{} {
	return map[string]interface{}{"rids": e.Rids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *PermissionDenied) safeParams() map[string]interface{} {
	return map[string]interface{}{"rids": e.Rids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *PermissionDenied) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *PermissionDenied) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *PermissionDenied) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e PermissionDenied) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.permissionDenied)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.PermissionDenied, ErrorName: "PersistentCompute:PermissionDenied", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *PermissionDenied) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters permissionDenied
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.permissionDenied = parameters
	return nil
}

type pollingOnlyComputation struct {
	PollingOnlyTypes []PollingOnlyComputationType `json:"pollingOnlyTypes"`
}

func (o pollingOnlyComputation) MarshalJSON() ([]byte, error) {
	if o.PollingOnlyTypes == nil {
		o.PollingOnlyTypes = make([]PollingOnlyComputationType, 0)
	}
	type _tmppollingOnlyComputation pollingOnlyComputation
	return safejson.Marshal(_tmppollingOnlyComputation(o))
}

func (o *pollingOnlyComputation) UnmarshalJSON(data []byte) error {
	type _tmppollingOnlyComputation pollingOnlyComputation
	var rawpollingOnlyComputation _tmppollingOnlyComputation
	if err := safejson.Unmarshal(data, &rawpollingOnlyComputation); err != nil {
		return err
	}
	if rawpollingOnlyComputation.PollingOnlyTypes == nil {
		rawpollingOnlyComputation.PollingOnlyTypes = make([]PollingOnlyComputationType, 0)
	}
	*o = pollingOnlyComputation(rawpollingOnlyComputation)
	return nil
}

func (o pollingOnlyComputation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *pollingOnlyComputation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewPollingOnlyComputation returns new instance of PollingOnlyComputation error.
func NewPollingOnlyComputation(pollingOnlyTypesArg []PollingOnlyComputationType) *PollingOnlyComputation {
	return &PollingOnlyComputation{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), pollingOnlyComputation: pollingOnlyComputation{PollingOnlyTypes: pollingOnlyTypesArg}}
}

// WrapWithPollingOnlyComputation returns new instance of PollingOnlyComputation error wrapping an existing error.
func WrapWithPollingOnlyComputation(err error, pollingOnlyTypesArg []PollingOnlyComputationType) *PollingOnlyComputation {
	return &PollingOnlyComputation{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, pollingOnlyComputation: pollingOnlyComputation{PollingOnlyTypes: pollingOnlyTypesArg}}
}

// PollingOnlyComputation is an error type.
/*
The requested compute contains nodes that support streaming but only via polling (not WebSocket).
The frontend should use polling mode (HTTP requests) instead of WebSocket streaming for this query.
*/
type PollingOnlyComputation struct {
	errorInstanceID uuid.UUID
	pollingOnlyComputation
	cause error
	stack werror.StackTrace
}

// IsPollingOnlyComputation returns true if err is an instance of PollingOnlyComputation.
func IsPollingOnlyComputation(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*PollingOnlyComputation)
	return ok
}

func (e *PollingOnlyComputation) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT PersistentCompute:PollingOnlyComputation (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *PollingOnlyComputation) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *PollingOnlyComputation) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *PollingOnlyComputation) Message() string {
	return "INVALID_ARGUMENT PersistentCompute:PollingOnlyComputation"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *PollingOnlyComputation) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *PollingOnlyComputation) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *PollingOnlyComputation) Name() string {
	return "PersistentCompute:PollingOnlyComputation"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *PollingOnlyComputation) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *PollingOnlyComputation) Parameters() map[string]interface{} {
	return map[string]interface{}{"pollingOnlyTypes": e.PollingOnlyTypes}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *PollingOnlyComputation) safeParams() map[string]interface{} {
	return map[string]interface{}{"pollingOnlyTypes": e.PollingOnlyTypes, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *PollingOnlyComputation) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *PollingOnlyComputation) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *PollingOnlyComputation) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e PollingOnlyComputation) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.pollingOnlyComputation)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "PersistentCompute:PollingOnlyComputation", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *PollingOnlyComputation) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters pollingOnlyComputation
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.pollingOnlyComputation = parameters
	return nil
}

type tooManyPoints struct {
	Limit          safelong.SafeLong  `json:"limit"`
	TotalNumSeries *safelong.SafeLong `json:"totalNumSeries,omitempty"`
}

func (o tooManyPoints) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyPoints) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyPoints returns new instance of TooManyPoints error.
func NewTooManyPoints(limitArg safelong.SafeLong, totalNumSeriesArg *safelong.SafeLong) *TooManyPoints {
	return &TooManyPoints{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyPoints: tooManyPoints{Limit: limitArg, TotalNumSeries: totalNumSeriesArg}}
}

// WrapWithTooManyPoints returns new instance of TooManyPoints error wrapping an existing error.
func WrapWithTooManyPoints(err error, limitArg safelong.SafeLong, totalNumSeriesArg *safelong.SafeLong) *TooManyPoints {
	return &TooManyPoints{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyPoints: tooManyPoints{Limit: limitArg, TotalNumSeries: totalNumSeriesArg}}
}

// TooManyPoints is an error type.
// The subscription is operating on too many points.
type TooManyPoints struct {
	errorInstanceID uuid.UUID
	tooManyPoints
	cause error
	stack werror.StackTrace
}

// IsTooManyPoints returns true if err is an instance of TooManyPoints.
func IsTooManyPoints(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyPoints)
	return ok
}

func (e *TooManyPoints) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT PersistentCompute:TooManyPoints (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyPoints) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyPoints) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyPoints) Message() string {
	return "INVALID_ARGUMENT PersistentCompute:TooManyPoints"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyPoints) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyPoints) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyPoints) Name() string {
	return "PersistentCompute:TooManyPoints"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyPoints) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyPoints) Parameters() map[string]interface{} {
	return map[string]interface{}{"limit": e.Limit, "totalNumSeries": e.TotalNumSeries}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyPoints) safeParams() map[string]interface{} {
	return map[string]interface{}{"limit": e.Limit, "totalNumSeries": e.TotalNumSeries, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyPoints) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyPoints) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyPoints) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyPoints) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyPoints)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "PersistentCompute:TooManyPoints", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyPoints) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyPoints
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyPoints = parameters
	return nil
}

type tooManyPointsForSingleSeries struct {
	Limit             safelong.SafeLong `json:"limit"`
	RequestStartBound *string           `json:"requestStartBound,omitempty"`
}

func (o tooManyPointsForSingleSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyPointsForSingleSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyPointsForSingleSeries returns new instance of TooManyPointsForSingleSeries error.
func NewTooManyPointsForSingleSeries(limitArg safelong.SafeLong, requestStartBoundArg *string) *TooManyPointsForSingleSeries {
	return &TooManyPointsForSingleSeries{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyPointsForSingleSeries: tooManyPointsForSingleSeries{Limit: limitArg, RequestStartBound: requestStartBoundArg}}
}

// WrapWithTooManyPointsForSingleSeries returns new instance of TooManyPointsForSingleSeries error wrapping an existing error.
func WrapWithTooManyPointsForSingleSeries(err error, limitArg safelong.SafeLong, requestStartBoundArg *string) *TooManyPointsForSingleSeries {
	return &TooManyPointsForSingleSeries{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyPointsForSingleSeries: tooManyPointsForSingleSeries{Limit: limitArg, RequestStartBound: requestStartBoundArg}}
}

// TooManyPointsForSingleSeries is an error type.
// The subscription is operating on a series that has too many points.
type TooManyPointsForSingleSeries struct {
	errorInstanceID uuid.UUID
	tooManyPointsForSingleSeries
	cause error
	stack werror.StackTrace
}

// IsTooManyPointsForSingleSeries returns true if err is an instance of TooManyPointsForSingleSeries.
func IsTooManyPointsForSingleSeries(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyPointsForSingleSeries)
	return ok
}

func (e *TooManyPointsForSingleSeries) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT PersistentCompute:TooManyPointsForSingleSeries (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyPointsForSingleSeries) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyPointsForSingleSeries) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyPointsForSingleSeries) Message() string {
	return "INVALID_ARGUMENT PersistentCompute:TooManyPointsForSingleSeries"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyPointsForSingleSeries) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyPointsForSingleSeries) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyPointsForSingleSeries) Name() string {
	return "PersistentCompute:TooManyPointsForSingleSeries"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyPointsForSingleSeries) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyPointsForSingleSeries) Parameters() map[string]interface{} {
	return map[string]interface{}{"limit": e.Limit, "requestStartBound": e.RequestStartBound}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyPointsForSingleSeries) safeParams() map[string]interface{} {
	return map[string]interface{}{"limit": e.Limit, "requestStartBound": e.RequestStartBound, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyPointsForSingleSeries) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyPointsForSingleSeries) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyPointsForSingleSeries) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyPointsForSingleSeries) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyPointsForSingleSeries)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "PersistentCompute:TooManyPointsForSingleSeries", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyPointsForSingleSeries) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyPointsForSingleSeries
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyPointsForSingleSeries = parameters
	return nil
}

type unavailableResultConfiguration struct {
	Reason UnavailableResultConfigurationReason `json:"reason"`
}

func (o unavailableResultConfiguration) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *unavailableResultConfiguration) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUnavailableResultConfiguration returns new instance of UnavailableResultConfiguration error.
func NewUnavailableResultConfiguration(reasonArg UnavailableResultConfigurationReason) *UnavailableResultConfiguration {
	return &UnavailableResultConfiguration{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), unavailableResultConfiguration: unavailableResultConfiguration{Reason: reasonArg}}
}

// WrapWithUnavailableResultConfiguration returns new instance of UnavailableResultConfiguration error wrapping an existing error.
func WrapWithUnavailableResultConfiguration(err error, reasonArg UnavailableResultConfigurationReason) *UnavailableResultConfiguration {
	return &UnavailableResultConfiguration{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, unavailableResultConfiguration: unavailableResultConfiguration{Reason: reasonArg}}
}

// UnavailableResultConfiguration is an error type.
// ResultConfiguration is incompatible with the requested compute.
type UnavailableResultConfiguration struct {
	errorInstanceID uuid.UUID
	unavailableResultConfiguration
	cause error
	stack werror.StackTrace
}

// IsUnavailableResultConfiguration returns true if err is an instance of UnavailableResultConfiguration.
func IsUnavailableResultConfiguration(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*UnavailableResultConfiguration)
	return ok
}

func (e *UnavailableResultConfiguration) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT PersistentCompute:UnavailableResultConfiguration (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *UnavailableResultConfiguration) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *UnavailableResultConfiguration) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *UnavailableResultConfiguration) Message() string {
	return "INVALID_ARGUMENT PersistentCompute:UnavailableResultConfiguration"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *UnavailableResultConfiguration) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *UnavailableResultConfiguration) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *UnavailableResultConfiguration) Name() string {
	return "PersistentCompute:UnavailableResultConfiguration"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *UnavailableResultConfiguration) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *UnavailableResultConfiguration) Parameters() map[string]interface{} {
	return map[string]interface{}{"reason": e.Reason}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *UnavailableResultConfiguration) safeParams() map[string]interface{} {
	return map[string]interface{}{"reason": e.Reason, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnavailableResultConfiguration) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *UnavailableResultConfiguration) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnavailableResultConfiguration) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e UnavailableResultConfiguration) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.unavailableResultConfiguration)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "PersistentCompute:UnavailableResultConfiguration", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *UnavailableResultConfiguration) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters unavailableResultConfiguration
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.unavailableResultConfiguration = parameters
	return nil
}

type unsupportedGranularity struct{}

func (o unsupportedGranularity) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *unsupportedGranularity) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUnsupportedGranularity returns new instance of UnsupportedGranularity error.
func NewUnsupportedGranularity() *UnsupportedGranularity {
	return &UnsupportedGranularity{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), unsupportedGranularity: unsupportedGranularity{}}
}

// WrapWithUnsupportedGranularity returns new instance of UnsupportedGranularity error wrapping an existing error.
func WrapWithUnsupportedGranularity(err error) *UnsupportedGranularity {
	return &UnsupportedGranularity{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, unsupportedGranularity: unsupportedGranularity{}}
}

// UnsupportedGranularity is an error type.
type UnsupportedGranularity struct {
	errorInstanceID uuid.UUID
	unsupportedGranularity
	cause error
	stack werror.StackTrace
}

// IsUnsupportedGranularity returns true if err is an instance of UnsupportedGranularity.
func IsUnsupportedGranularity(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*UnsupportedGranularity)
	return ok
}

func (e *UnsupportedGranularity) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT PersistentCompute:UnsupportedGranularity (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *UnsupportedGranularity) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *UnsupportedGranularity) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *UnsupportedGranularity) Message() string {
	return "INVALID_ARGUMENT PersistentCompute:UnsupportedGranularity"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *UnsupportedGranularity) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *UnsupportedGranularity) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *UnsupportedGranularity) Name() string {
	return "PersistentCompute:UnsupportedGranularity"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *UnsupportedGranularity) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *UnsupportedGranularity) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *UnsupportedGranularity) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnsupportedGranularity) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *UnsupportedGranularity) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnsupportedGranularity) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e UnsupportedGranularity) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.unsupportedGranularity)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "PersistentCompute:UnsupportedGranularity", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *UnsupportedGranularity) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters unsupportedGranularity
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.unsupportedGranularity = parameters
	return nil
}

type windowNegative struct {
	Window safelong.SafeLong `json:"window"`
}

func (o windowNegative) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *windowNegative) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewWindowNegative returns new instance of WindowNegative error.
func NewWindowNegative(windowArg safelong.SafeLong) *WindowNegative {
	return &WindowNegative{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), windowNegative: windowNegative{Window: windowArg}}
}

// WrapWithWindowNegative returns new instance of WindowNegative error wrapping an existing error.
func WrapWithWindowNegative(err error, windowArg safelong.SafeLong) *WindowNegative {
	return &WindowNegative{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, windowNegative: windowNegative{Window: windowArg}}
}

// WindowNegative is an error type.
type WindowNegative struct {
	errorInstanceID uuid.UUID
	windowNegative
	cause error
	stack werror.StackTrace
}

// IsWindowNegative returns true if err is an instance of WindowNegative.
func IsWindowNegative(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*WindowNegative)
	return ok
}

func (e *WindowNegative) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT PersistentCompute:WindowNegative (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *WindowNegative) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *WindowNegative) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *WindowNegative) Message() string {
	return "INVALID_ARGUMENT PersistentCompute:WindowNegative"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *WindowNegative) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *WindowNegative) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *WindowNegative) Name() string {
	return "PersistentCompute:WindowNegative"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *WindowNegative) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *WindowNegative) Parameters() map[string]interface{} {
	return map[string]interface{}{"window": e.Window}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *WindowNegative) safeParams() map[string]interface{} {
	return map[string]interface{}{"window": e.Window, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *WindowNegative) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *WindowNegative) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *WindowNegative) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e WindowNegative) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.windowNegative)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "PersistentCompute:WindowNegative", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *WindowNegative) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters windowNegative
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.windowNegative = parameters
	return nil
}

type windowTooLarge struct{}

func (o windowTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *windowTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewWindowTooLarge returns new instance of WindowTooLarge error.
func NewWindowTooLarge() *WindowTooLarge {
	return &WindowTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), windowTooLarge: windowTooLarge{}}
}

// WrapWithWindowTooLarge returns new instance of WindowTooLarge error wrapping an existing error.
func WrapWithWindowTooLarge(err error) *WindowTooLarge {
	return &WindowTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, windowTooLarge: windowTooLarge{}}
}

// WindowTooLarge is an error type.
type WindowTooLarge struct {
	errorInstanceID uuid.UUID
	windowTooLarge
	cause error
	stack werror.StackTrace
}

// IsWindowTooLarge returns true if err is an instance of WindowTooLarge.
func IsWindowTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*WindowTooLarge)
	return ok
}

func (e *WindowTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT PersistentCompute:WindowTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *WindowTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *WindowTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *WindowTooLarge) Message() string {
	return "INVALID_ARGUMENT PersistentCompute:WindowTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *WindowTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *WindowTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *WindowTooLarge) Name() string {
	return "PersistentCompute:WindowTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *WindowTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *WindowTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *WindowTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *WindowTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *WindowTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *WindowTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e WindowTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.windowTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "PersistentCompute:WindowTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *WindowTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters windowTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.windowTooLarge = parameters
	return nil
}

type windowWithLookBackTooLarge struct{}

func (o windowWithLookBackTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *windowWithLookBackTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewWindowWithLookBackTooLarge returns new instance of WindowWithLookBackTooLarge error.
func NewWindowWithLookBackTooLarge() *WindowWithLookBackTooLarge {
	return &WindowWithLookBackTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), windowWithLookBackTooLarge: windowWithLookBackTooLarge{}}
}

// WrapWithWindowWithLookBackTooLarge returns new instance of WindowWithLookBackTooLarge error wrapping an existing error.
func WrapWithWindowWithLookBackTooLarge(err error) *WindowWithLookBackTooLarge {
	return &WindowWithLookBackTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, windowWithLookBackTooLarge: windowWithLookBackTooLarge{}}
}

// WindowWithLookBackTooLarge is an error type.
type WindowWithLookBackTooLarge struct {
	errorInstanceID uuid.UUID
	windowWithLookBackTooLarge
	cause error
	stack werror.StackTrace
}

// IsWindowWithLookBackTooLarge returns true if err is an instance of WindowWithLookBackTooLarge.
func IsWindowWithLookBackTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*WindowWithLookBackTooLarge)
	return ok
}

func (e *WindowWithLookBackTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT PersistentCompute:WindowWithLookBackTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *WindowWithLookBackTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *WindowWithLookBackTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *WindowWithLookBackTooLarge) Message() string {
	return "INVALID_ARGUMENT PersistentCompute:WindowWithLookBackTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *WindowWithLookBackTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *WindowWithLookBackTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *WindowWithLookBackTooLarge) Name() string {
	return "PersistentCompute:WindowWithLookBackTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *WindowWithLookBackTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *WindowWithLookBackTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *WindowWithLookBackTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *WindowWithLookBackTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *WindowWithLookBackTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *WindowWithLookBackTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e WindowWithLookBackTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.windowWithLookBackTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "PersistentCompute:WindowWithLookBackTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *WindowWithLookBackTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters windowWithLookBackTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.windowWithLookBackTooLarge = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("PersistentCompute:InvalidClientMessage", reflect.TypeOf(InvalidClientMessage{}))
	conjureerrors.RegisterErrorType("PersistentCompute:InvalidComputation", reflect.TypeOf(InvalidComputation{}))
	conjureerrors.RegisterErrorType("PersistentCompute:NonNominalStorageLocator", reflect.TypeOf(NonNominalStorageLocator{}))
	conjureerrors.RegisterErrorType("PersistentCompute:PermissionDenied", reflect.TypeOf(PermissionDenied{}))
	conjureerrors.RegisterErrorType("PersistentCompute:PollingOnlyComputation", reflect.TypeOf(PollingOnlyComputation{}))
	conjureerrors.RegisterErrorType("PersistentCompute:TooManyPoints", reflect.TypeOf(TooManyPoints{}))
	conjureerrors.RegisterErrorType("PersistentCompute:TooManyPointsForSingleSeries", reflect.TypeOf(TooManyPointsForSingleSeries{}))
	conjureerrors.RegisterErrorType("PersistentCompute:UnavailableResultConfiguration", reflect.TypeOf(UnavailableResultConfiguration{}))
	conjureerrors.RegisterErrorType("PersistentCompute:UnsupportedGranularity", reflect.TypeOf(UnsupportedGranularity{}))
	conjureerrors.RegisterErrorType("PersistentCompute:WindowNegative", reflect.TypeOf(WindowNegative{}))
	conjureerrors.RegisterErrorType("PersistentCompute:WindowTooLarge", reflect.TypeOf(WindowTooLarge{}))
	conjureerrors.RegisterErrorType("PersistentCompute:WindowWithLookBackTooLarge", reflect.TypeOf(WindowWithLookBackTooLarge{}))
}
