// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/scout/compute/api"
)

type ClientMessageWithT[T any] ClientMessage

func (u *ClientMessageWithT[T]) Accept(ctx context.Context, v ClientMessageVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "subscribe":
		if u.subscribe == nil {
			return result, fmt.Errorf("field \"subscribe\" is required")
		}
		return v.VisitSubscribe(ctx, *u.subscribe)
	case "unsubscribe":
		if u.unsubscribe == nil {
			return result, fmt.Errorf("field \"unsubscribe\" is required")
		}
		return v.VisitUnsubscribe(ctx, *u.unsubscribe)
	case "ping":
		if u.ping == nil {
			return result, fmt.Errorf("field \"ping\" is required")
		}
		return v.VisitPing(ctx, *u.ping)
	case "pong":
		if u.pong == nil {
			return result, fmt.Errorf("field \"pong\" is required")
		}
		return v.VisitPong(ctx, *u.pong)
	}
}

func (u *ClientMessageWithT[T]) AcceptFuncs(subscribeFunc func(map[SubscriptionId]StreamingComputeNodeSubscription) (T, error), unsubscribeFunc func([]SubscriptionId) (T, error), pingFunc func(Ping) (T, error), pongFunc func(Pong) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "subscribe":
		if u.subscribe == nil {
			return result, fmt.Errorf("field \"subscribe\" is required")
		}
		return subscribeFunc(*u.subscribe)
	case "unsubscribe":
		if u.unsubscribe == nil {
			return result, fmt.Errorf("field \"unsubscribe\" is required")
		}
		return unsubscribeFunc(*u.unsubscribe)
	case "ping":
		if u.ping == nil {
			return result, fmt.Errorf("field \"ping\" is required")
		}
		return pingFunc(*u.ping)
	case "pong":
		if u.pong == nil {
			return result, fmt.Errorf("field \"pong\" is required")
		}
		return pongFunc(*u.pong)
	}
}

func (u *ClientMessageWithT[T]) SubscribeNoopSuccess(map[SubscriptionId]StreamingComputeNodeSubscription) (T, error) {
	var result T
	return result, nil
}

func (u *ClientMessageWithT[T]) UnsubscribeNoopSuccess([]SubscriptionId) (T, error) {
	var result T
	return result, nil
}

func (u *ClientMessageWithT[T]) PingNoopSuccess(Ping) (T, error) {
	var result T
	return result, nil
}

func (u *ClientMessageWithT[T]) PongNoopSuccess(Pong) (T, error) {
	var result T
	return result, nil
}

func (u *ClientMessageWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ClientMessageVisitorWithT[T any] interface {
	VisitSubscribe(ctx context.Context, v map[SubscriptionId]StreamingComputeNodeSubscription) (T, error)
	VisitUnsubscribe(ctx context.Context, v []SubscriptionId) (T, error)
	VisitPing(ctx context.Context, v Ping) (T, error)
	VisitPong(ctx context.Context, v Pong) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ComputeNodeAppendResponseWithT[T any] ComputeNodeAppendResponse

func (u *ComputeNodeAppendResponseWithT[T]) Accept(ctx context.Context, v ComputeNodeAppendResponseVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(ctx, *u.range_)
	case "enumPoint":
		var enumPoint *api.EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return v.VisitEnumPoint(ctx, enumPoint)
	case "numericPoint":
		var numericPoint *api.NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return v.VisitNumericPoint(ctx, numericPoint)
	case "singlePoint":
		var singlePoint *api.SinglePoint
		if u.singlePoint != nil {
			singlePoint = *u.singlePoint
		}
		return v.VisitSinglePoint(ctx, singlePoint)
	case "logPoint":
		var logPoint *api.LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return v.VisitLogPoint(ctx, logPoint)
	case "rangeValue":
		var rangeValue *api.Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return v.VisitRangeValue(ctx, rangeValue)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return result, fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumeric(ctx, *u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return result, fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnum(ctx, *u.bucketedEnum)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return result, fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return v.VisitArrowNumeric(ctx, *u.arrowNumeric)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return result, fmt.Errorf("field \"arrowEnum\" is required")
		}
		return v.VisitArrowEnum(ctx, *u.arrowEnum)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return result, fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return v.VisitArrowBucketedNumeric(ctx, *u.arrowBucketedNumeric)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return result, fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return v.VisitArrowBucketedEnum(ctx, *u.arrowBucketedEnum)
	case "grouped":
		if u.grouped == nil {
			return result, fmt.Errorf("field \"grouped\" is required")
		}
		return v.VisitGrouped(ctx, *u.grouped)
	}
}

func (u *ComputeNodeAppendResponseWithT[T]) AcceptFuncs(range_Func func([]api.Range) (T, error), enumPointFunc func(*api.EnumPoint) (T, error), numericPointFunc func(*api.NumericPoint) (T, error), singlePointFunc func(*api.SinglePoint) (T, error), logPointFunc func(*api.LogPoint) (T, error), rangeValueFunc func(*api.Range) (T, error), numericFunc func(api.NumericPlot) (T, error), enumFunc func(api.EnumPlot) (T, error), bucketedNumericFunc func(api.BucketedNumericPlot) (T, error), bucketedEnumFunc func(api.BucketedEnumPlot) (T, error), arrowNumericFunc func(api.ArrowNumericPlot) (T, error), arrowEnumFunc func(api.ArrowEnumPlot) (T, error), arrowBucketedNumericFunc func(api.ArrowBucketedNumericPlot) (T, error), arrowBucketedEnumFunc func(api.ArrowBucketedEnumPlot) (T, error), groupedFunc func(GroupedComputeNodeAppendResponses) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "range":
		if u.range_ == nil {
			return result, fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "enumPoint":
		var enumPoint *api.EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return enumPointFunc(enumPoint)
	case "numericPoint":
		var numericPoint *api.NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return numericPointFunc(numericPoint)
	case "singlePoint":
		var singlePoint *api.SinglePoint
		if u.singlePoint != nil {
			singlePoint = *u.singlePoint
		}
		return singlePointFunc(singlePoint)
	case "logPoint":
		var logPoint *api.LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return logPointFunc(logPoint)
	case "rangeValue":
		var rangeValue *api.Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return rangeValueFunc(rangeValue)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return result, fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return bucketedNumericFunc(*u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return result, fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return bucketedEnumFunc(*u.bucketedEnum)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return result, fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return arrowNumericFunc(*u.arrowNumeric)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return result, fmt.Errorf("field \"arrowEnum\" is required")
		}
		return arrowEnumFunc(*u.arrowEnum)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return result, fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return arrowBucketedNumericFunc(*u.arrowBucketedNumeric)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return result, fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return arrowBucketedEnumFunc(*u.arrowBucketedEnum)
	case "grouped":
		if u.grouped == nil {
			return result, fmt.Errorf("field \"grouped\" is required")
		}
		return groupedFunc(*u.grouped)
	}
}

func (u *ComputeNodeAppendResponseWithT[T]) RangeNoopSuccess([]api.Range) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) EnumPointNoopSuccess(*api.EnumPoint) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) NumericPointNoopSuccess(*api.NumericPoint) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) SinglePointNoopSuccess(*api.SinglePoint) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) LogPointNoopSuccess(*api.LogPoint) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) RangeValueNoopSuccess(*api.Range) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) NumericNoopSuccess(api.NumericPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) EnumNoopSuccess(api.EnumPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) BucketedNumericNoopSuccess(api.BucketedNumericPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) BucketedEnumNoopSuccess(api.BucketedEnumPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) ArrowNumericNoopSuccess(api.ArrowNumericPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) ArrowEnumNoopSuccess(api.ArrowEnumPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) ArrowBucketedNumericNoopSuccess(api.ArrowBucketedNumericPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) ArrowBucketedEnumNoopSuccess(api.ArrowBucketedEnumPlot) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) GroupedNoopSuccess(GroupedComputeNodeAppendResponses) (T, error) {
	var result T
	return result, nil
}

func (u *ComputeNodeAppendResponseWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ComputeNodeAppendResponseVisitorWithT[T any] interface {
	VisitRange(ctx context.Context, v []api.Range) (T, error)
	VisitEnumPoint(ctx context.Context, v *api.EnumPoint) (T, error)
	VisitNumericPoint(ctx context.Context, v *api.NumericPoint) (T, error)
	VisitSinglePoint(ctx context.Context, v *api.SinglePoint) (T, error)
	VisitLogPoint(ctx context.Context, v *api.LogPoint) (T, error)
	VisitRangeValue(ctx context.Context, v *api.Range) (T, error)
	VisitNumeric(ctx context.Context, v api.NumericPlot) (T, error)
	VisitEnum(ctx context.Context, v api.EnumPlot) (T, error)
	VisitBucketedNumeric(ctx context.Context, v api.BucketedNumericPlot) (T, error)
	VisitBucketedEnum(ctx context.Context, v api.BucketedEnumPlot) (T, error)
	VisitArrowNumeric(ctx context.Context, v api.ArrowNumericPlot) (T, error)
	VisitArrowEnum(ctx context.Context, v api.ArrowEnumPlot) (T, error)
	VisitArrowBucketedNumeric(ctx context.Context, v api.ArrowBucketedNumericPlot) (T, error)
	VisitArrowBucketedEnum(ctx context.Context, v api.ArrowBucketedEnumPlot) (T, error)
	VisitGrouped(ctx context.Context, v GroupedComputeNodeAppendResponses) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type HealthMessageWithT[T any] HealthMessage

func (u *HealthMessageWithT[T]) Accept(ctx context.Context, v HealthMessageVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "ping":
		if u.ping == nil {
			return result, fmt.Errorf("field \"ping\" is required")
		}
		return v.VisitPing(ctx, *u.ping)
	case "pong":
		if u.pong == nil {
			return result, fmt.Errorf("field \"pong\" is required")
		}
		return v.VisitPong(ctx, *u.pong)
	case "shutdownNotice":
		if u.shutdownNotice == nil {
			return result, fmt.Errorf("field \"shutdownNotice\" is required")
		}
		return v.VisitShutdownNotice(ctx, *u.shutdownNotice)
	case "clientMessageError":
		if u.clientMessageError == nil {
			return result, fmt.Errorf("field \"clientMessageError\" is required")
		}
		return v.VisitClientMessageError(ctx, *u.clientMessageError)
	}
}

func (u *HealthMessageWithT[T]) AcceptFuncs(pingFunc func(Ping) (T, error), pongFunc func(Pong) (T, error), shutdownNoticeFunc func(ShutdownNotice) (T, error), clientMessageErrorFunc func(ClientMessageError) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ping":
		if u.ping == nil {
			return result, fmt.Errorf("field \"ping\" is required")
		}
		return pingFunc(*u.ping)
	case "pong":
		if u.pong == nil {
			return result, fmt.Errorf("field \"pong\" is required")
		}
		return pongFunc(*u.pong)
	case "shutdownNotice":
		if u.shutdownNotice == nil {
			return result, fmt.Errorf("field \"shutdownNotice\" is required")
		}
		return shutdownNoticeFunc(*u.shutdownNotice)
	case "clientMessageError":
		if u.clientMessageError == nil {
			return result, fmt.Errorf("field \"clientMessageError\" is required")
		}
		return clientMessageErrorFunc(*u.clientMessageError)
	}
}

func (u *HealthMessageWithT[T]) PingNoopSuccess(Ping) (T, error) {
	var result T
	return result, nil
}

func (u *HealthMessageWithT[T]) PongNoopSuccess(Pong) (T, error) {
	var result T
	return result, nil
}

func (u *HealthMessageWithT[T]) ShutdownNoticeNoopSuccess(ShutdownNotice) (T, error) {
	var result T
	return result, nil
}

func (u *HealthMessageWithT[T]) ClientMessageErrorNoopSuccess(ClientMessageError) (T, error) {
	var result T
	return result, nil
}

func (u *HealthMessageWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type HealthMessageVisitorWithT[T any] interface {
	VisitPing(ctx context.Context, v Ping) (T, error)
	VisitPong(ctx context.Context, v Pong) (T, error)
	VisitShutdownNotice(ctx context.Context, v ShutdownNotice) (T, error)
	VisitClientMessageError(ctx context.Context, v ClientMessageError) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ResultConfigurationWithT[T any] ResultConfiguration

func (u *ResultConfigurationWithT[T]) Accept(ctx context.Context, v ResultConfigurationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "appendOnly":
		if u.appendOnly == nil {
			return result, fmt.Errorf("field \"appendOnly\" is required")
		}
		return v.VisitAppendOnly(ctx, *u.appendOnly)
	}
}

func (u *ResultConfigurationWithT[T]) AcceptFuncs(appendOnlyFunc func(AppendOnlyConfig) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "appendOnly":
		if u.appendOnly == nil {
			return result, fmt.Errorf("field \"appendOnly\" is required")
		}
		return appendOnlyFunc(*u.appendOnly)
	}
}

func (u *ResultConfigurationWithT[T]) AppendOnlyNoopSuccess(AppendOnlyConfig) (T, error) {
	var result T
	return result, nil
}

func (u *ResultConfigurationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ResultConfigurationVisitorWithT[T any] interface {
	VisitAppendOnly(ctx context.Context, v AppendOnlyConfig) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ServerMessageWithT[T any] ServerMessage

func (u *ServerMessageWithT[T]) Accept(ctx context.Context, v ServerMessageVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "subscriptionUpdate":
		if u.subscriptionUpdate == nil {
			return result, fmt.Errorf("field \"subscriptionUpdate\" is required")
		}
		return v.VisitSubscriptionUpdate(ctx, *u.subscriptionUpdate)
	case "subscriptionCreation":
		if u.subscriptionCreation == nil {
			return result, fmt.Errorf("field \"subscriptionCreation\" is required")
		}
		return v.VisitSubscriptionCreation(ctx, *u.subscriptionCreation)
	case "health":
		if u.health == nil {
			return result, fmt.Errorf("field \"health\" is required")
		}
		return v.VisitHealth(ctx, *u.health)
	}
}

func (u *ServerMessageWithT[T]) AcceptFuncs(subscriptionUpdateFunc func(SubscriptionUpdateMessage) (T, error), subscriptionCreationFunc func(SubscriptionCreationMessage) (T, error), healthFunc func(HealthMessage) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "subscriptionUpdate":
		if u.subscriptionUpdate == nil {
			return result, fmt.Errorf("field \"subscriptionUpdate\" is required")
		}
		return subscriptionUpdateFunc(*u.subscriptionUpdate)
	case "subscriptionCreation":
		if u.subscriptionCreation == nil {
			return result, fmt.Errorf("field \"subscriptionCreation\" is required")
		}
		return subscriptionCreationFunc(*u.subscriptionCreation)
	case "health":
		if u.health == nil {
			return result, fmt.Errorf("field \"health\" is required")
		}
		return healthFunc(*u.health)
	}
}

func (u *ServerMessageWithT[T]) SubscriptionUpdateNoopSuccess(SubscriptionUpdateMessage) (T, error) {
	var result T
	return result, nil
}

func (u *ServerMessageWithT[T]) SubscriptionCreationNoopSuccess(SubscriptionCreationMessage) (T, error) {
	var result T
	return result, nil
}

func (u *ServerMessageWithT[T]) HealthNoopSuccess(HealthMessage) (T, error) {
	var result T
	return result, nil
}

func (u *ServerMessageWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ServerMessageVisitorWithT[T any] interface {
	VisitSubscriptionUpdate(ctx context.Context, v SubscriptionUpdateMessage) (T, error)
	VisitSubscriptionCreation(ctx context.Context, v SubscriptionCreationMessage) (T, error)
	VisitHealth(ctx context.Context, v HealthMessage) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SubscriptionCreationWithT[T any] SubscriptionCreation

func (u *SubscriptionCreationWithT[T]) Accept(ctx context.Context, v SubscriptionCreationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(ctx, *u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(ctx, *u.error)
	}
}

func (u *SubscriptionCreationWithT[T]) AcceptFuncs(successFunc func(SubscriptionCreationSuccess) (T, error), errorFunc func(SubscriptionCreationError) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *SubscriptionCreationWithT[T]) SuccessNoopSuccess(SubscriptionCreationSuccess) (T, error) {
	var result T
	return result, nil
}

func (u *SubscriptionCreationWithT[T]) ErrorNoopSuccess(SubscriptionCreationError) (T, error) {
	var result T
	return result, nil
}

func (u *SubscriptionCreationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SubscriptionCreationVisitorWithT[T any] interface {
	VisitSuccess(ctx context.Context, v SubscriptionCreationSuccess) (T, error)
	VisitError(ctx context.Context, v SubscriptionCreationError) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SubscriptionUpdateWithT[T any] SubscriptionUpdate

func (u *SubscriptionUpdateWithT[T]) Accept(ctx context.Context, v SubscriptionUpdateVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "full":
		if u.full == nil {
			return result, fmt.Errorf("field \"full\" is required")
		}
		return v.VisitFull(ctx, *u.full)
	case "append":
		if u.append == nil {
			return result, fmt.Errorf("field \"append\" is required")
		}
		return v.VisitAppend(ctx, *u.append)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(ctx, *u.error)
	}
}

func (u *SubscriptionUpdateWithT[T]) AcceptFuncs(fullFunc func(FullResult) (T, error), appendFunc func(AppendResult) (T, error), errorFunc func(SubscriptionUpdateError) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "full":
		if u.full == nil {
			return result, fmt.Errorf("field \"full\" is required")
		}
		return fullFunc(*u.full)
	case "append":
		if u.append == nil {
			return result, fmt.Errorf("field \"append\" is required")
		}
		return appendFunc(*u.append)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *SubscriptionUpdateWithT[T]) FullNoopSuccess(FullResult) (T, error) {
	var result T
	return result, nil
}

func (u *SubscriptionUpdateWithT[T]) AppendNoopSuccess(AppendResult) (T, error) {
	var result T
	return result, nil
}

func (u *SubscriptionUpdateWithT[T]) ErrorNoopSuccess(SubscriptionUpdateError) (T, error) {
	var result T
	return result, nil
}

func (u *SubscriptionUpdateWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SubscriptionUpdateVisitorWithT[T any] interface {
	VisitFull(ctx context.Context, v FullResult) (T, error)
	VisitAppend(ctx context.Context, v AppendResult) (T, error)
	VisitError(ctx context.Context, v SubscriptionUpdateError) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
