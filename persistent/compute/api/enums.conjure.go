// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"strings"
)

/*
Compute types that are completely incompatible with streaming.
If any of these are present, the subscription cannot be created.
*/
type InvalidComputationType struct {
	val InvalidComputationType_Value
}

type InvalidComputationType_Value string

const (
	InvalidComputationType_POINT_PERSISTENCE   InvalidComputationType_Value = "POINT_PERSISTENCE"
	InvalidComputationType_CUMULATIVE_SUM      InvalidComputationType_Value = "CUMULATIVE_SUM"
	InvalidComputationType_INTEGRAL            InvalidComputationType_Value = "INTEGRAL"
	InvalidComputationType_STALENESS_DETECTION InvalidComputationType_Value = "STALENESS_DETECTION"
	InvalidComputationType_TIME_RANGE_FILTER   InvalidComputationType_Value = "TIME_RANGE_FILTER"
	InvalidComputationType_LITERAL_RANGES      InvalidComputationType_Value = "LITERAL_RANGES"
	InvalidComputationType_UNKNOWN             InvalidComputationType_Value = "UNKNOWN"
)

// InvalidComputationType_Values returns all known variants of InvalidComputationType.
func InvalidComputationType_Values() []InvalidComputationType_Value {
	return []InvalidComputationType_Value{InvalidComputationType_POINT_PERSISTENCE, InvalidComputationType_CUMULATIVE_SUM, InvalidComputationType_INTEGRAL, InvalidComputationType_STALENESS_DETECTION, InvalidComputationType_TIME_RANGE_FILTER, InvalidComputationType_LITERAL_RANGES}
}

func New_InvalidComputationType(value InvalidComputationType_Value) InvalidComputationType {
	return InvalidComputationType{val: value}
}

// IsUnknown returns false for all known variants of InvalidComputationType and true otherwise.
func (e InvalidComputationType) IsUnknown() bool {
	switch e.val {
	case InvalidComputationType_POINT_PERSISTENCE, InvalidComputationType_CUMULATIVE_SUM, InvalidComputationType_INTEGRAL, InvalidComputationType_STALENESS_DETECTION, InvalidComputationType_TIME_RANGE_FILTER, InvalidComputationType_LITERAL_RANGES:
		return false
	}
	return true
}

func (e InvalidComputationType) Value() InvalidComputationType_Value {
	if e.IsUnknown() {
		return InvalidComputationType_UNKNOWN
	}
	return e.val
}

func (e InvalidComputationType) String() string {
	return string(e.val)
}

func (e InvalidComputationType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *InvalidComputationType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_InvalidComputationType(InvalidComputationType_Value(v))
	case "POINT_PERSISTENCE":
		*e = New_InvalidComputationType(InvalidComputationType_POINT_PERSISTENCE)
	case "CUMULATIVE_SUM":
		*e = New_InvalidComputationType(InvalidComputationType_CUMULATIVE_SUM)
	case "INTEGRAL":
		*e = New_InvalidComputationType(InvalidComputationType_INTEGRAL)
	case "STALENESS_DETECTION":
		*e = New_InvalidComputationType(InvalidComputationType_STALENESS_DETECTION)
	case "TIME_RANGE_FILTER":
		*e = New_InvalidComputationType(InvalidComputationType_TIME_RANGE_FILTER)
	case "LITERAL_RANGES":
		*e = New_InvalidComputationType(InvalidComputationType_LITERAL_RANGES)
	}
	return nil
}

/*
Compute types that support streaming but only via polling (not real-time appends).
Subscriptions with these types will be created successfully, but the frontend should
use polling mode instead of expecting append updates.
*/
type PollingOnlyComputationType struct {
	val PollingOnlyComputationType_Value
}

type PollingOnlyComputationType_Value string

const (
	PollingOnlyComputationType_FREQUENCY_DOMAIN                PollingOnlyComputationType_Value = "FREQUENCY_DOMAIN"
	PollingOnlyComputationType_PAGE_SUMMARIZATION_STRATEGY     PollingOnlyComputationType_Value = "PAGE_SUMMARIZATION_STRATEGY"
	PollingOnlyComputationType_TRUNCATE_SUMMARIZATION_STRATEGY PollingOnlyComputationType_Value = "TRUNCATE_SUMMARIZATION_STRATEGY"
	PollingOnlyComputationType_LOG_SERIES                      PollingOnlyComputationType_Value = "LOG_SERIES"
	PollingOnlyComputationType_CURVE_FITTING                   PollingOnlyComputationType_Value = "CURVE_FITTING"
	PollingOnlyComputationType_ARRAY                           PollingOnlyComputationType_Value = "ARRAY"
	PollingOnlyComputationType_STRUCT                          PollingOnlyComputationType_Value = "STRUCT"
	PollingOnlyComputationType_UNKNOWN                         PollingOnlyComputationType_Value = "UNKNOWN"
)

// PollingOnlyComputationType_Values returns all known variants of PollingOnlyComputationType.
func PollingOnlyComputationType_Values() []PollingOnlyComputationType_Value {
	return []PollingOnlyComputationType_Value{PollingOnlyComputationType_FREQUENCY_DOMAIN, PollingOnlyComputationType_PAGE_SUMMARIZATION_STRATEGY, PollingOnlyComputationType_TRUNCATE_SUMMARIZATION_STRATEGY, PollingOnlyComputationType_LOG_SERIES, PollingOnlyComputationType_CURVE_FITTING, PollingOnlyComputationType_ARRAY, PollingOnlyComputationType_STRUCT}
}

func New_PollingOnlyComputationType(value PollingOnlyComputationType_Value) PollingOnlyComputationType {
	return PollingOnlyComputationType{val: value}
}

// IsUnknown returns false for all known variants of PollingOnlyComputationType and true otherwise.
func (e PollingOnlyComputationType) IsUnknown() bool {
	switch e.val {
	case PollingOnlyComputationType_FREQUENCY_DOMAIN, PollingOnlyComputationType_PAGE_SUMMARIZATION_STRATEGY, PollingOnlyComputationType_TRUNCATE_SUMMARIZATION_STRATEGY, PollingOnlyComputationType_LOG_SERIES, PollingOnlyComputationType_CURVE_FITTING, PollingOnlyComputationType_ARRAY, PollingOnlyComputationType_STRUCT:
		return false
	}
	return true
}

func (e PollingOnlyComputationType) Value() PollingOnlyComputationType_Value {
	if e.IsUnknown() {
		return PollingOnlyComputationType_UNKNOWN
	}
	return e.val
}

func (e PollingOnlyComputationType) String() string {
	return string(e.val)
}

func (e PollingOnlyComputationType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *PollingOnlyComputationType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_PollingOnlyComputationType(PollingOnlyComputationType_Value(v))
	case "FREQUENCY_DOMAIN":
		*e = New_PollingOnlyComputationType(PollingOnlyComputationType_FREQUENCY_DOMAIN)
	case "PAGE_SUMMARIZATION_STRATEGY":
		*e = New_PollingOnlyComputationType(PollingOnlyComputationType_PAGE_SUMMARIZATION_STRATEGY)
	case "TRUNCATE_SUMMARIZATION_STRATEGY":
		*e = New_PollingOnlyComputationType(PollingOnlyComputationType_TRUNCATE_SUMMARIZATION_STRATEGY)
	case "LOG_SERIES":
		*e = New_PollingOnlyComputationType(PollingOnlyComputationType_LOG_SERIES)
	case "CURVE_FITTING":
		*e = New_PollingOnlyComputationType(PollingOnlyComputationType_CURVE_FITTING)
	case "ARRAY":
		*e = New_PollingOnlyComputationType(PollingOnlyComputationType_ARRAY)
	case "STRUCT":
		*e = New_PollingOnlyComputationType(PollingOnlyComputationType_STRUCT)
	}
	return nil
}

type UnavailableResultConfigurationReason struct {
	val UnavailableResultConfigurationReason_Value
}

type UnavailableResultConfigurationReason_Value string

const (
	UnavailableResultConfigurationReason_APPENDS_NOT_SUPPORTED_FOR_COMPUTE       UnavailableResultConfigurationReason_Value = "APPENDS_NOT_SUPPORTED_FOR_COMPUTE"
	UnavailableResultConfigurationReason_TOO_MANY_POINTS_FOR_UNDECIMATED_APPENDS UnavailableResultConfigurationReason_Value = "TOO_MANY_POINTS_FOR_UNDECIMATED_APPENDS"
	UnavailableResultConfigurationReason_UNKNOWN                                 UnavailableResultConfigurationReason_Value = "UNKNOWN"
)

// UnavailableResultConfigurationReason_Values returns all known variants of UnavailableResultConfigurationReason.
func UnavailableResultConfigurationReason_Values() []UnavailableResultConfigurationReason_Value {
	return []UnavailableResultConfigurationReason_Value{UnavailableResultConfigurationReason_APPENDS_NOT_SUPPORTED_FOR_COMPUTE, UnavailableResultConfigurationReason_TOO_MANY_POINTS_FOR_UNDECIMATED_APPENDS}
}

func New_UnavailableResultConfigurationReason(value UnavailableResultConfigurationReason_Value) UnavailableResultConfigurationReason {
	return UnavailableResultConfigurationReason{val: value}
}

// IsUnknown returns false for all known variants of UnavailableResultConfigurationReason and true otherwise.
func (e UnavailableResultConfigurationReason) IsUnknown() bool {
	switch e.val {
	case UnavailableResultConfigurationReason_APPENDS_NOT_SUPPORTED_FOR_COMPUTE, UnavailableResultConfigurationReason_TOO_MANY_POINTS_FOR_UNDECIMATED_APPENDS:
		return false
	}
	return true
}

func (e UnavailableResultConfigurationReason) Value() UnavailableResultConfigurationReason_Value {
	if e.IsUnknown() {
		return UnavailableResultConfigurationReason_UNKNOWN
	}
	return e.val
}

func (e UnavailableResultConfigurationReason) String() string {
	return string(e.val)
}

func (e UnavailableResultConfigurationReason) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *UnavailableResultConfigurationReason) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_UnavailableResultConfigurationReason(UnavailableResultConfigurationReason_Value(v))
	case "APPENDS_NOT_SUPPORTED_FOR_COMPUTE":
		*e = New_UnavailableResultConfigurationReason(UnavailableResultConfigurationReason_APPENDS_NOT_SUPPORTED_FOR_COMPUTE)
	case "TOO_MANY_POINTS_FOR_UNDECIMATED_APPENDS":
		*e = New_UnavailableResultConfigurationReason(UnavailableResultConfigurationReason_TOO_MANY_POINTS_FOR_UNDECIMATED_APPENDS)
	}
	return nil
}
