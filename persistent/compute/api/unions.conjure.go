// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/scout/compute/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type ClientMessage struct {
	typ         string
	subscribe   *map[SubscriptionId]StreamingComputeNodeSubscription
	unsubscribe *[]SubscriptionId
	ping        *Ping
	pong        *Pong
}

type clientMessageDeserializer struct {
	Type        string                                               `json:"type"`
	Subscribe   *map[SubscriptionId]StreamingComputeNodeSubscription `json:"subscribe"`
	Unsubscribe *[]SubscriptionId                                    `json:"unsubscribe"`
	Ping        *Ping                                                `json:"ping"`
	Pong        *Pong                                                `json:"pong"`
}

func (u *clientMessageDeserializer) toStruct() ClientMessage {
	return ClientMessage{typ: u.Type, subscribe: u.Subscribe, unsubscribe: u.Unsubscribe, ping: u.Ping, pong: u.Pong}
}

func (u *ClientMessage) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "subscribe":
		if u.subscribe == nil {
			return nil, fmt.Errorf("field \"subscribe\" is required")
		}
		return struct {
			Type      string                                              `json:"type"`
			Subscribe map[SubscriptionId]StreamingComputeNodeSubscription `json:"subscribe"`
		}{Type: "subscribe", Subscribe: *u.subscribe}, nil
	case "unsubscribe":
		if u.unsubscribe == nil {
			return nil, fmt.Errorf("field \"unsubscribe\" is required")
		}
		return struct {
			Type        string           `json:"type"`
			Unsubscribe []SubscriptionId `json:"unsubscribe"`
		}{Type: "unsubscribe", Unsubscribe: *u.unsubscribe}, nil
	case "ping":
		if u.ping == nil {
			return nil, fmt.Errorf("field \"ping\" is required")
		}
		return struct {
			Type string `json:"type"`
			Ping Ping   `json:"ping"`
		}{Type: "ping", Ping: *u.ping}, nil
	case "pong":
		if u.pong == nil {
			return nil, fmt.Errorf("field \"pong\" is required")
		}
		return struct {
			Type string `json:"type"`
			Pong Pong   `json:"pong"`
		}{Type: "pong", Pong: *u.pong}, nil
	}
}

func (u ClientMessage) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ClientMessage) UnmarshalJSON(data []byte) error {
	var deser clientMessageDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "subscribe":
		if u.subscribe == nil {
			return fmt.Errorf("field \"subscribe\" is required")
		}
	case "unsubscribe":
		if u.unsubscribe == nil {
			return fmt.Errorf("field \"unsubscribe\" is required")
		}
	case "ping":
		if u.ping == nil {
			return fmt.Errorf("field \"ping\" is required")
		}
	case "pong":
		if u.pong == nil {
			return fmt.Errorf("field \"pong\" is required")
		}
	}
	return nil
}

func (u ClientMessage) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ClientMessage) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ClientMessage) AcceptFuncs(subscribeFunc func(map[SubscriptionId]StreamingComputeNodeSubscription) error, unsubscribeFunc func([]SubscriptionId) error, pingFunc func(Ping) error, pongFunc func(Pong) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "subscribe":
		if u.subscribe == nil {
			return fmt.Errorf("field \"subscribe\" is required")
		}
		return subscribeFunc(*u.subscribe)
	case "unsubscribe":
		if u.unsubscribe == nil {
			return fmt.Errorf("field \"unsubscribe\" is required")
		}
		return unsubscribeFunc(*u.unsubscribe)
	case "ping":
		if u.ping == nil {
			return fmt.Errorf("field \"ping\" is required")
		}
		return pingFunc(*u.ping)
	case "pong":
		if u.pong == nil {
			return fmt.Errorf("field \"pong\" is required")
		}
		return pongFunc(*u.pong)
	}
}

func (u *ClientMessage) SubscribeNoopSuccess(map[SubscriptionId]StreamingComputeNodeSubscription) error {
	return nil
}

func (u *ClientMessage) UnsubscribeNoopSuccess([]SubscriptionId) error {
	return nil
}

func (u *ClientMessage) PingNoopSuccess(Ping) error {
	return nil
}

func (u *ClientMessage) PongNoopSuccess(Pong) error {
	return nil
}

func (u *ClientMessage) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ClientMessage) Accept(v ClientMessageVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "subscribe":
		if u.subscribe == nil {
			return fmt.Errorf("field \"subscribe\" is required")
		}
		return v.VisitSubscribe(*u.subscribe)
	case "unsubscribe":
		if u.unsubscribe == nil {
			return fmt.Errorf("field \"unsubscribe\" is required")
		}
		return v.VisitUnsubscribe(*u.unsubscribe)
	case "ping":
		if u.ping == nil {
			return fmt.Errorf("field \"ping\" is required")
		}
		return v.VisitPing(*u.ping)
	case "pong":
		if u.pong == nil {
			return fmt.Errorf("field \"pong\" is required")
		}
		return v.VisitPong(*u.pong)
	}
}

type ClientMessageVisitor interface {
	VisitSubscribe(v map[SubscriptionId]StreamingComputeNodeSubscription) error
	VisitUnsubscribe(v []SubscriptionId) error
	VisitPing(v Ping) error
	VisitPong(v Pong) error
	VisitUnknown(typeName string) error
}

func (u *ClientMessage) AcceptWithContext(ctx context.Context, v ClientMessageVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "subscribe":
		if u.subscribe == nil {
			return fmt.Errorf("field \"subscribe\" is required")
		}
		return v.VisitSubscribeWithContext(ctx, *u.subscribe)
	case "unsubscribe":
		if u.unsubscribe == nil {
			return fmt.Errorf("field \"unsubscribe\" is required")
		}
		return v.VisitUnsubscribeWithContext(ctx, *u.unsubscribe)
	case "ping":
		if u.ping == nil {
			return fmt.Errorf("field \"ping\" is required")
		}
		return v.VisitPingWithContext(ctx, *u.ping)
	case "pong":
		if u.pong == nil {
			return fmt.Errorf("field \"pong\" is required")
		}
		return v.VisitPongWithContext(ctx, *u.pong)
	}
}

type ClientMessageVisitorWithContext interface {
	VisitSubscribeWithContext(ctx context.Context, v map[SubscriptionId]StreamingComputeNodeSubscription) error
	VisitUnsubscribeWithContext(ctx context.Context, v []SubscriptionId) error
	VisitPingWithContext(ctx context.Context, v Ping) error
	VisitPongWithContext(ctx context.Context, v Pong) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewClientMessageFromSubscribe(v map[SubscriptionId]StreamingComputeNodeSubscription) ClientMessage {
	return ClientMessage{typ: "subscribe", subscribe: &v}
}

func NewClientMessageFromUnsubscribe(v []SubscriptionId) ClientMessage {
	return ClientMessage{typ: "unsubscribe", unsubscribe: &v}
}

func NewClientMessageFromPing(v Ping) ClientMessage {
	return ClientMessage{typ: "ping", ping: &v}
}

func NewClientMessageFromPong(v Pong) ClientMessage {
	return ClientMessage{typ: "pong", pong: &v}
}

/*
These cover the subset of the union type in `ComputeNodeResponse` for which we support append results.
Append results will have the same subtype as the previous full result for the same `SubscriptionId`.
If the subtype were to change (e.g., we start doing bucketing because data frequency increased) we will send
a new full result with that new type. The results will also have the same units as the previous `FullResult`.
Notably, we currently don't support appends for bucketed results as merging buckets is not trivial, especially
when accounting for out-of-order points.
*/
type ComputeNodeAppendResponse struct {
	typ                  string
	range_               *[]api.Range
	enumPoint            **api.EnumPoint
	numericPoint         **api.NumericPoint
	logPoint             **api.LogPoint
	rangeValue           **api.Range
	numeric              *api.NumericPlot
	enum                 *api.EnumPlot
	bucketedNumeric      *api.BucketedNumericPlot
	bucketedEnum         *api.BucketedEnumPlot
	arrowNumeric         *api.ArrowNumericPlot
	arrowEnum            *api.ArrowEnumPlot
	arrowBucketedNumeric *api.ArrowBucketedNumericPlot
	arrowBucketedEnum    *api.ArrowBucketedEnumPlot
	grouped              *GroupedComputeNodeAppendResponses
}

type computeNodeAppendResponseDeserializer struct {
	Type                 string                             `json:"type"`
	Range                *[]api.Range                       `json:"range"`
	EnumPoint            **api.EnumPoint                    `json:"enumPoint"`
	NumericPoint         **api.NumericPoint                 `json:"numericPoint"`
	LogPoint             **api.LogPoint                     `json:"logPoint"`
	RangeValue           **api.Range                        `json:"rangeValue"`
	Numeric              *api.NumericPlot                   `json:"numeric"`
	Enum                 *api.EnumPlot                      `json:"enum"`
	BucketedNumeric      *api.BucketedNumericPlot           `json:"bucketedNumeric"`
	BucketedEnum         *api.BucketedEnumPlot              `json:"bucketedEnum"`
	ArrowNumeric         *api.ArrowNumericPlot              `json:"arrowNumeric"`
	ArrowEnum            *api.ArrowEnumPlot                 `json:"arrowEnum"`
	ArrowBucketedNumeric *api.ArrowBucketedNumericPlot      `json:"arrowBucketedNumeric"`
	ArrowBucketedEnum    *api.ArrowBucketedEnumPlot         `json:"arrowBucketedEnum"`
	Grouped              *GroupedComputeNodeAppendResponses `json:"grouped"`
}

func (u *computeNodeAppendResponseDeserializer) toStruct() ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: u.Type, range_: u.Range, enumPoint: u.EnumPoint, numericPoint: u.NumericPoint, logPoint: u.LogPoint, rangeValue: u.RangeValue, numeric: u.Numeric, enum: u.Enum, bucketedNumeric: u.BucketedNumeric, bucketedEnum: u.BucketedEnum, arrowNumeric: u.ArrowNumeric, arrowEnum: u.ArrowEnum, arrowBucketedNumeric: u.ArrowBucketedNumeric, arrowBucketedEnum: u.ArrowBucketedEnum, grouped: u.Grouped}
}

func (u *ComputeNodeAppendResponse) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "range":
		if u.range_ == nil {
			return nil, fmt.Errorf("field \"range\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Range []api.Range `json:"range"`
		}{Type: "range", Range: *u.range_}, nil
	case "enumPoint":
		var enumPoint *api.EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return struct {
			Type      string         `json:"type"`
			EnumPoint *api.EnumPoint `json:"enumPoint"`
		}{Type: "enumPoint", EnumPoint: enumPoint}, nil
	case "numericPoint":
		var numericPoint *api.NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return struct {
			Type         string            `json:"type"`
			NumericPoint *api.NumericPoint `json:"numericPoint"`
		}{Type: "numericPoint", NumericPoint: numericPoint}, nil
	case "logPoint":
		var logPoint *api.LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return struct {
			Type     string        `json:"type"`
			LogPoint *api.LogPoint `json:"logPoint"`
		}{Type: "logPoint", LogPoint: logPoint}, nil
	case "rangeValue":
		var rangeValue *api.Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return struct {
			Type       string     `json:"type"`
			RangeValue *api.Range `json:"rangeValue"`
		}{Type: "rangeValue", RangeValue: rangeValue}, nil
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string          `json:"type"`
			Numeric api.NumericPlot `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string       `json:"type"`
			Enum api.EnumPlot `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return nil, fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return struct {
			Type            string                  `json:"type"`
			BucketedNumeric api.BucketedNumericPlot `json:"bucketedNumeric"`
		}{Type: "bucketedNumeric", BucketedNumeric: *u.bucketedNumeric}, nil
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return nil, fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return struct {
			Type         string               `json:"type"`
			BucketedEnum api.BucketedEnumPlot `json:"bucketedEnum"`
		}{Type: "bucketedEnum", BucketedEnum: *u.bucketedEnum}, nil
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return nil, fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return struct {
			Type         string               `json:"type"`
			ArrowNumeric api.ArrowNumericPlot `json:"arrowNumeric"`
		}{Type: "arrowNumeric", ArrowNumeric: *u.arrowNumeric}, nil
	case "arrowEnum":
		if u.arrowEnum == nil {
			return nil, fmt.Errorf("field \"arrowEnum\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			ArrowEnum api.ArrowEnumPlot `json:"arrowEnum"`
		}{Type: "arrowEnum", ArrowEnum: *u.arrowEnum}, nil
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return nil, fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return struct {
			Type                 string                       `json:"type"`
			ArrowBucketedNumeric api.ArrowBucketedNumericPlot `json:"arrowBucketedNumeric"`
		}{Type: "arrowBucketedNumeric", ArrowBucketedNumeric: *u.arrowBucketedNumeric}, nil
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return nil, fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return struct {
			Type              string                    `json:"type"`
			ArrowBucketedEnum api.ArrowBucketedEnumPlot `json:"arrowBucketedEnum"`
		}{Type: "arrowBucketedEnum", ArrowBucketedEnum: *u.arrowBucketedEnum}, nil
	case "grouped":
		if u.grouped == nil {
			return nil, fmt.Errorf("field \"grouped\" is required")
		}
		return struct {
			Type    string                            `json:"type"`
			Grouped GroupedComputeNodeAppendResponses `json:"grouped"`
		}{Type: "grouped", Grouped: *u.grouped}, nil
	}
}

func (u ComputeNodeAppendResponse) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ComputeNodeAppendResponse) UnmarshalJSON(data []byte) error {
	var deser computeNodeAppendResponseDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
	case "enumPoint":
	case "numericPoint":
	case "logPoint":
	case "rangeValue":
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
	}
	return nil
}

func (u ComputeNodeAppendResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ComputeNodeAppendResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ComputeNodeAppendResponse) AcceptFuncs(range_Func func([]api.Range) error, enumPointFunc func(*api.EnumPoint) error, numericPointFunc func(*api.NumericPoint) error, logPointFunc func(*api.LogPoint) error, rangeValueFunc func(*api.Range) error, numericFunc func(api.NumericPlot) error, enumFunc func(api.EnumPlot) error, bucketedNumericFunc func(api.BucketedNumericPlot) error, bucketedEnumFunc func(api.BucketedEnumPlot) error, arrowNumericFunc func(api.ArrowNumericPlot) error, arrowEnumFunc func(api.ArrowEnumPlot) error, arrowBucketedNumericFunc func(api.ArrowBucketedNumericPlot) error, arrowBucketedEnumFunc func(api.ArrowBucketedEnumPlot) error, groupedFunc func(GroupedComputeNodeAppendResponses) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return range_Func(*u.range_)
	case "enumPoint":
		var enumPoint *api.EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return enumPointFunc(enumPoint)
	case "numericPoint":
		var numericPoint *api.NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return numericPointFunc(numericPoint)
	case "logPoint":
		var logPoint *api.LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return logPointFunc(logPoint)
	case "rangeValue":
		var rangeValue *api.Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return rangeValueFunc(rangeValue)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return bucketedNumericFunc(*u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return bucketedEnumFunc(*u.bucketedEnum)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return arrowNumericFunc(*u.arrowNumeric)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
		return arrowEnumFunc(*u.arrowEnum)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return arrowBucketedNumericFunc(*u.arrowBucketedNumeric)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return arrowBucketedEnumFunc(*u.arrowBucketedEnum)
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
		return groupedFunc(*u.grouped)
	}
}

func (u *ComputeNodeAppendResponse) RangeNoopSuccess([]api.Range) error {
	return nil
}

func (u *ComputeNodeAppendResponse) EnumPointNoopSuccess(*api.EnumPoint) error {
	return nil
}

func (u *ComputeNodeAppendResponse) NumericPointNoopSuccess(*api.NumericPoint) error {
	return nil
}

func (u *ComputeNodeAppendResponse) LogPointNoopSuccess(*api.LogPoint) error {
	return nil
}

func (u *ComputeNodeAppendResponse) RangeValueNoopSuccess(*api.Range) error {
	return nil
}

func (u *ComputeNodeAppendResponse) NumericNoopSuccess(api.NumericPlot) error {
	return nil
}

func (u *ComputeNodeAppendResponse) EnumNoopSuccess(api.EnumPlot) error {
	return nil
}

func (u *ComputeNodeAppendResponse) BucketedNumericNoopSuccess(api.BucketedNumericPlot) error {
	return nil
}

func (u *ComputeNodeAppendResponse) BucketedEnumNoopSuccess(api.BucketedEnumPlot) error {
	return nil
}

func (u *ComputeNodeAppendResponse) ArrowNumericNoopSuccess(api.ArrowNumericPlot) error {
	return nil
}

func (u *ComputeNodeAppendResponse) ArrowEnumNoopSuccess(api.ArrowEnumPlot) error {
	return nil
}

func (u *ComputeNodeAppendResponse) ArrowBucketedNumericNoopSuccess(api.ArrowBucketedNumericPlot) error {
	return nil
}

func (u *ComputeNodeAppendResponse) ArrowBucketedEnumNoopSuccess(api.ArrowBucketedEnumPlot) error {
	return nil
}

func (u *ComputeNodeAppendResponse) GroupedNoopSuccess(GroupedComputeNodeAppendResponses) error {
	return nil
}

func (u *ComputeNodeAppendResponse) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ComputeNodeAppendResponse) Accept(v ComputeNodeAppendResponseVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRange(*u.range_)
	case "enumPoint":
		var enumPoint *api.EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return v.VisitEnumPoint(enumPoint)
	case "numericPoint":
		var numericPoint *api.NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return v.VisitNumericPoint(numericPoint)
	case "logPoint":
		var logPoint *api.LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return v.VisitLogPoint(logPoint)
	case "rangeValue":
		var rangeValue *api.Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return v.VisitRangeValue(rangeValue)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumeric(*u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnum(*u.bucketedEnum)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return v.VisitArrowNumeric(*u.arrowNumeric)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
		return v.VisitArrowEnum(*u.arrowEnum)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return v.VisitArrowBucketedNumeric(*u.arrowBucketedNumeric)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return v.VisitArrowBucketedEnum(*u.arrowBucketedEnum)
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
		return v.VisitGrouped(*u.grouped)
	}
}

type ComputeNodeAppendResponseVisitor interface {
	VisitRange(v []api.Range) error
	VisitEnumPoint(v *api.EnumPoint) error
	VisitNumericPoint(v *api.NumericPoint) error
	VisitLogPoint(v *api.LogPoint) error
	VisitRangeValue(v *api.Range) error
	VisitNumeric(v api.NumericPlot) error
	VisitEnum(v api.EnumPlot) error
	VisitBucketedNumeric(v api.BucketedNumericPlot) error
	VisitBucketedEnum(v api.BucketedEnumPlot) error
	VisitArrowNumeric(v api.ArrowNumericPlot) error
	VisitArrowEnum(v api.ArrowEnumPlot) error
	VisitArrowBucketedNumeric(v api.ArrowBucketedNumericPlot) error
	VisitArrowBucketedEnum(v api.ArrowBucketedEnumPlot) error
	VisitGrouped(v GroupedComputeNodeAppendResponses) error
	VisitUnknown(typeName string) error
}

func (u *ComputeNodeAppendResponse) AcceptWithContext(ctx context.Context, v ComputeNodeAppendResponseVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "range":
		if u.range_ == nil {
			return fmt.Errorf("field \"range\" is required")
		}
		return v.VisitRangeWithContext(ctx, *u.range_)
	case "enumPoint":
		var enumPoint *api.EnumPoint
		if u.enumPoint != nil {
			enumPoint = *u.enumPoint
		}
		return v.VisitEnumPointWithContext(ctx, enumPoint)
	case "numericPoint":
		var numericPoint *api.NumericPoint
		if u.numericPoint != nil {
			numericPoint = *u.numericPoint
		}
		return v.VisitNumericPointWithContext(ctx, numericPoint)
	case "logPoint":
		var logPoint *api.LogPoint
		if u.logPoint != nil {
			logPoint = *u.logPoint
		}
		return v.VisitLogPointWithContext(ctx, logPoint)
	case "rangeValue":
		var rangeValue *api.Range
		if u.rangeValue != nil {
			rangeValue = *u.rangeValue
		}
		return v.VisitRangeValueWithContext(ctx, rangeValue)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "bucketedNumeric":
		if u.bucketedNumeric == nil {
			return fmt.Errorf("field \"bucketedNumeric\" is required")
		}
		return v.VisitBucketedNumericWithContext(ctx, *u.bucketedNumeric)
	case "bucketedEnum":
		if u.bucketedEnum == nil {
			return fmt.Errorf("field \"bucketedEnum\" is required")
		}
		return v.VisitBucketedEnumWithContext(ctx, *u.bucketedEnum)
	case "arrowNumeric":
		if u.arrowNumeric == nil {
			return fmt.Errorf("field \"arrowNumeric\" is required")
		}
		return v.VisitArrowNumericWithContext(ctx, *u.arrowNumeric)
	case "arrowEnum":
		if u.arrowEnum == nil {
			return fmt.Errorf("field \"arrowEnum\" is required")
		}
		return v.VisitArrowEnumWithContext(ctx, *u.arrowEnum)
	case "arrowBucketedNumeric":
		if u.arrowBucketedNumeric == nil {
			return fmt.Errorf("field \"arrowBucketedNumeric\" is required")
		}
		return v.VisitArrowBucketedNumericWithContext(ctx, *u.arrowBucketedNumeric)
	case "arrowBucketedEnum":
		if u.arrowBucketedEnum == nil {
			return fmt.Errorf("field \"arrowBucketedEnum\" is required")
		}
		return v.VisitArrowBucketedEnumWithContext(ctx, *u.arrowBucketedEnum)
	case "grouped":
		if u.grouped == nil {
			return fmt.Errorf("field \"grouped\" is required")
		}
		return v.VisitGroupedWithContext(ctx, *u.grouped)
	}
}

type ComputeNodeAppendResponseVisitorWithContext interface {
	VisitRangeWithContext(ctx context.Context, v []api.Range) error
	VisitEnumPointWithContext(ctx context.Context, v *api.EnumPoint) error
	VisitNumericPointWithContext(ctx context.Context, v *api.NumericPoint) error
	VisitLogPointWithContext(ctx context.Context, v *api.LogPoint) error
	VisitRangeValueWithContext(ctx context.Context, v *api.Range) error
	VisitNumericWithContext(ctx context.Context, v api.NumericPlot) error
	VisitEnumWithContext(ctx context.Context, v api.EnumPlot) error
	VisitBucketedNumericWithContext(ctx context.Context, v api.BucketedNumericPlot) error
	VisitBucketedEnumWithContext(ctx context.Context, v api.BucketedEnumPlot) error
	VisitArrowNumericWithContext(ctx context.Context, v api.ArrowNumericPlot) error
	VisitArrowEnumWithContext(ctx context.Context, v api.ArrowEnumPlot) error
	VisitArrowBucketedNumericWithContext(ctx context.Context, v api.ArrowBucketedNumericPlot) error
	VisitArrowBucketedEnumWithContext(ctx context.Context, v api.ArrowBucketedEnumPlot) error
	VisitGroupedWithContext(ctx context.Context, v GroupedComputeNodeAppendResponses) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewComputeNodeAppendResponseFromRange(v []api.Range) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "range", range_: &v}
}

func NewComputeNodeAppendResponseFromEnumPoint(v *api.EnumPoint) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "enumPoint", enumPoint: &v}
}

func NewComputeNodeAppendResponseFromNumericPoint(v *api.NumericPoint) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "numericPoint", numericPoint: &v}
}

func NewComputeNodeAppendResponseFromLogPoint(v *api.LogPoint) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "logPoint", logPoint: &v}
}

func NewComputeNodeAppendResponseFromRangeValue(v *api.Range) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "rangeValue", rangeValue: &v}
}

func NewComputeNodeAppendResponseFromNumeric(v api.NumericPlot) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "numeric", numeric: &v}
}

func NewComputeNodeAppendResponseFromEnum(v api.EnumPlot) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "enum", enum: &v}
}

func NewComputeNodeAppendResponseFromBucketedNumeric(v api.BucketedNumericPlot) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "bucketedNumeric", bucketedNumeric: &v}
}

func NewComputeNodeAppendResponseFromBucketedEnum(v api.BucketedEnumPlot) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "bucketedEnum", bucketedEnum: &v}
}

func NewComputeNodeAppendResponseFromArrowNumeric(v api.ArrowNumericPlot) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "arrowNumeric", arrowNumeric: &v}
}

func NewComputeNodeAppendResponseFromArrowEnum(v api.ArrowEnumPlot) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "arrowEnum", arrowEnum: &v}
}

func NewComputeNodeAppendResponseFromArrowBucketedNumeric(v api.ArrowBucketedNumericPlot) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "arrowBucketedNumeric", arrowBucketedNumeric: &v}
}

func NewComputeNodeAppendResponseFromArrowBucketedEnum(v api.ArrowBucketedEnumPlot) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "arrowBucketedEnum", arrowBucketedEnum: &v}
}

func NewComputeNodeAppendResponseFromGrouped(v GroupedComputeNodeAppendResponses) ComputeNodeAppendResponse {
	return ComputeNodeAppendResponse{typ: "grouped", grouped: &v}
}

type HealthMessage struct {
	typ            string
	ping           *Ping
	pong           *Pong
	shutdownNotice *ShutdownNotice
}

type healthMessageDeserializer struct {
	Type           string          `json:"type"`
	Ping           *Ping           `json:"ping"`
	Pong           *Pong           `json:"pong"`
	ShutdownNotice *ShutdownNotice `json:"shutdownNotice"`
}

func (u *healthMessageDeserializer) toStruct() HealthMessage {
	return HealthMessage{typ: u.Type, ping: u.Ping, pong: u.Pong, shutdownNotice: u.ShutdownNotice}
}

func (u *HealthMessage) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "ping":
		if u.ping == nil {
			return nil, fmt.Errorf("field \"ping\" is required")
		}
		return struct {
			Type string `json:"type"`
			Ping Ping   `json:"ping"`
		}{Type: "ping", Ping: *u.ping}, nil
	case "pong":
		if u.pong == nil {
			return nil, fmt.Errorf("field \"pong\" is required")
		}
		return struct {
			Type string `json:"type"`
			Pong Pong   `json:"pong"`
		}{Type: "pong", Pong: *u.pong}, nil
	case "shutdownNotice":
		if u.shutdownNotice == nil {
			return nil, fmt.Errorf("field \"shutdownNotice\" is required")
		}
		return struct {
			Type           string         `json:"type"`
			ShutdownNotice ShutdownNotice `json:"shutdownNotice"`
		}{Type: "shutdownNotice", ShutdownNotice: *u.shutdownNotice}, nil
	}
}

func (u HealthMessage) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *HealthMessage) UnmarshalJSON(data []byte) error {
	var deser healthMessageDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "ping":
		if u.ping == nil {
			return fmt.Errorf("field \"ping\" is required")
		}
	case "pong":
		if u.pong == nil {
			return fmt.Errorf("field \"pong\" is required")
		}
	case "shutdownNotice":
		if u.shutdownNotice == nil {
			return fmt.Errorf("field \"shutdownNotice\" is required")
		}
	}
	return nil
}

func (u HealthMessage) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *HealthMessage) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *HealthMessage) AcceptFuncs(pingFunc func(Ping) error, pongFunc func(Pong) error, shutdownNoticeFunc func(ShutdownNotice) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ping":
		if u.ping == nil {
			return fmt.Errorf("field \"ping\" is required")
		}
		return pingFunc(*u.ping)
	case "pong":
		if u.pong == nil {
			return fmt.Errorf("field \"pong\" is required")
		}
		return pongFunc(*u.pong)
	case "shutdownNotice":
		if u.shutdownNotice == nil {
			return fmt.Errorf("field \"shutdownNotice\" is required")
		}
		return shutdownNoticeFunc(*u.shutdownNotice)
	}
}

func (u *HealthMessage) PingNoopSuccess(Ping) error {
	return nil
}

func (u *HealthMessage) PongNoopSuccess(Pong) error {
	return nil
}

func (u *HealthMessage) ShutdownNoticeNoopSuccess(ShutdownNotice) error {
	return nil
}

func (u *HealthMessage) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *HealthMessage) Accept(v HealthMessageVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "ping":
		if u.ping == nil {
			return fmt.Errorf("field \"ping\" is required")
		}
		return v.VisitPing(*u.ping)
	case "pong":
		if u.pong == nil {
			return fmt.Errorf("field \"pong\" is required")
		}
		return v.VisitPong(*u.pong)
	case "shutdownNotice":
		if u.shutdownNotice == nil {
			return fmt.Errorf("field \"shutdownNotice\" is required")
		}
		return v.VisitShutdownNotice(*u.shutdownNotice)
	}
}

type HealthMessageVisitor interface {
	VisitPing(v Ping) error
	VisitPong(v Pong) error
	VisitShutdownNotice(v ShutdownNotice) error
	VisitUnknown(typeName string) error
}

func (u *HealthMessage) AcceptWithContext(ctx context.Context, v HealthMessageVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "ping":
		if u.ping == nil {
			return fmt.Errorf("field \"ping\" is required")
		}
		return v.VisitPingWithContext(ctx, *u.ping)
	case "pong":
		if u.pong == nil {
			return fmt.Errorf("field \"pong\" is required")
		}
		return v.VisitPongWithContext(ctx, *u.pong)
	case "shutdownNotice":
		if u.shutdownNotice == nil {
			return fmt.Errorf("field \"shutdownNotice\" is required")
		}
		return v.VisitShutdownNoticeWithContext(ctx, *u.shutdownNotice)
	}
}

type HealthMessageVisitorWithContext interface {
	VisitPingWithContext(ctx context.Context, v Ping) error
	VisitPongWithContext(ctx context.Context, v Pong) error
	VisitShutdownNoticeWithContext(ctx context.Context, v ShutdownNotice) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewHealthMessageFromPing(v Ping) HealthMessage {
	return HealthMessage{typ: "ping", ping: &v}
}

func NewHealthMessageFromPong(v Pong) HealthMessage {
	return HealthMessage{typ: "pong", pong: &v}
}

func NewHealthMessageFromShutdownNotice(v ShutdownNotice) HealthMessage {
	return HealthMessage{typ: "shutdownNotice", shutdownNotice: &v}
}

type ServerMessage struct {
	typ                  string
	subscriptionUpdate   *SubscriptionUpdateMessage
	subscriptionCreation *SubscriptionCreationMessage
	health               *HealthMessage
}

type serverMessageDeserializer struct {
	Type                 string                       `json:"type"`
	SubscriptionUpdate   *SubscriptionUpdateMessage   `json:"subscriptionUpdate"`
	SubscriptionCreation *SubscriptionCreationMessage `json:"subscriptionCreation"`
	Health               *HealthMessage               `json:"health"`
}

func (u *serverMessageDeserializer) toStruct() ServerMessage {
	return ServerMessage{typ: u.Type, subscriptionUpdate: u.SubscriptionUpdate, subscriptionCreation: u.SubscriptionCreation, health: u.Health}
}

func (u *ServerMessage) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "subscriptionUpdate":
		if u.subscriptionUpdate == nil {
			return nil, fmt.Errorf("field \"subscriptionUpdate\" is required")
		}
		return struct {
			Type               string                    `json:"type"`
			SubscriptionUpdate SubscriptionUpdateMessage `json:"subscriptionUpdate"`
		}{Type: "subscriptionUpdate", SubscriptionUpdate: *u.subscriptionUpdate}, nil
	case "subscriptionCreation":
		if u.subscriptionCreation == nil {
			return nil, fmt.Errorf("field \"subscriptionCreation\" is required")
		}
		return struct {
			Type                 string                      `json:"type"`
			SubscriptionCreation SubscriptionCreationMessage `json:"subscriptionCreation"`
		}{Type: "subscriptionCreation", SubscriptionCreation: *u.subscriptionCreation}, nil
	case "health":
		if u.health == nil {
			return nil, fmt.Errorf("field \"health\" is required")
		}
		return struct {
			Type   string        `json:"type"`
			Health HealthMessage `json:"health"`
		}{Type: "health", Health: *u.health}, nil
	}
}

func (u ServerMessage) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ServerMessage) UnmarshalJSON(data []byte) error {
	var deser serverMessageDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "subscriptionUpdate":
		if u.subscriptionUpdate == nil {
			return fmt.Errorf("field \"subscriptionUpdate\" is required")
		}
	case "subscriptionCreation":
		if u.subscriptionCreation == nil {
			return fmt.Errorf("field \"subscriptionCreation\" is required")
		}
	case "health":
		if u.health == nil {
			return fmt.Errorf("field \"health\" is required")
		}
	}
	return nil
}

func (u ServerMessage) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ServerMessage) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ServerMessage) AcceptFuncs(subscriptionUpdateFunc func(SubscriptionUpdateMessage) error, subscriptionCreationFunc func(SubscriptionCreationMessage) error, healthFunc func(HealthMessage) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "subscriptionUpdate":
		if u.subscriptionUpdate == nil {
			return fmt.Errorf("field \"subscriptionUpdate\" is required")
		}
		return subscriptionUpdateFunc(*u.subscriptionUpdate)
	case "subscriptionCreation":
		if u.subscriptionCreation == nil {
			return fmt.Errorf("field \"subscriptionCreation\" is required")
		}
		return subscriptionCreationFunc(*u.subscriptionCreation)
	case "health":
		if u.health == nil {
			return fmt.Errorf("field \"health\" is required")
		}
		return healthFunc(*u.health)
	}
}

func (u *ServerMessage) SubscriptionUpdateNoopSuccess(SubscriptionUpdateMessage) error {
	return nil
}

func (u *ServerMessage) SubscriptionCreationNoopSuccess(SubscriptionCreationMessage) error {
	return nil
}

func (u *ServerMessage) HealthNoopSuccess(HealthMessage) error {
	return nil
}

func (u *ServerMessage) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ServerMessage) Accept(v ServerMessageVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "subscriptionUpdate":
		if u.subscriptionUpdate == nil {
			return fmt.Errorf("field \"subscriptionUpdate\" is required")
		}
		return v.VisitSubscriptionUpdate(*u.subscriptionUpdate)
	case "subscriptionCreation":
		if u.subscriptionCreation == nil {
			return fmt.Errorf("field \"subscriptionCreation\" is required")
		}
		return v.VisitSubscriptionCreation(*u.subscriptionCreation)
	case "health":
		if u.health == nil {
			return fmt.Errorf("field \"health\" is required")
		}
		return v.VisitHealth(*u.health)
	}
}

type ServerMessageVisitor interface {
	VisitSubscriptionUpdate(v SubscriptionUpdateMessage) error
	VisitSubscriptionCreation(v SubscriptionCreationMessage) error
	VisitHealth(v HealthMessage) error
	VisitUnknown(typeName string) error
}

func (u *ServerMessage) AcceptWithContext(ctx context.Context, v ServerMessageVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "subscriptionUpdate":
		if u.subscriptionUpdate == nil {
			return fmt.Errorf("field \"subscriptionUpdate\" is required")
		}
		return v.VisitSubscriptionUpdateWithContext(ctx, *u.subscriptionUpdate)
	case "subscriptionCreation":
		if u.subscriptionCreation == nil {
			return fmt.Errorf("field \"subscriptionCreation\" is required")
		}
		return v.VisitSubscriptionCreationWithContext(ctx, *u.subscriptionCreation)
	case "health":
		if u.health == nil {
			return fmt.Errorf("field \"health\" is required")
		}
		return v.VisitHealthWithContext(ctx, *u.health)
	}
}

type ServerMessageVisitorWithContext interface {
	VisitSubscriptionUpdateWithContext(ctx context.Context, v SubscriptionUpdateMessage) error
	VisitSubscriptionCreationWithContext(ctx context.Context, v SubscriptionCreationMessage) error
	VisitHealthWithContext(ctx context.Context, v HealthMessage) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewServerMessageFromSubscriptionUpdate(v SubscriptionUpdateMessage) ServerMessage {
	return ServerMessage{typ: "subscriptionUpdate", subscriptionUpdate: &v}
}

func NewServerMessageFromSubscriptionCreation(v SubscriptionCreationMessage) ServerMessage {
	return ServerMessage{typ: "subscriptionCreation", subscriptionCreation: &v}
}

func NewServerMessageFromHealth(v HealthMessage) ServerMessage {
	return ServerMessage{typ: "health", health: &v}
}

type SubscriptionCreation struct {
	typ     string
	success *SubscriptionCreationSuccess
	error   *SubscriptionCreationError
}

type subscriptionCreationDeserializer struct {
	Type    string                       `json:"type"`
	Success *SubscriptionCreationSuccess `json:"success"`
	Error   *SubscriptionCreationError   `json:"error"`
}

func (u *subscriptionCreationDeserializer) toStruct() SubscriptionCreation {
	return SubscriptionCreation{typ: u.Type, success: u.Success, error: u.Error}
}

func (u *SubscriptionCreation) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "success":
		if u.success == nil {
			return nil, fmt.Errorf("field \"success\" is required")
		}
		return struct {
			Type    string                      `json:"type"`
			Success SubscriptionCreationSuccess `json:"success"`
		}{Type: "success", Success: *u.success}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string                    `json:"type"`
			Error SubscriptionCreationError `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	}
}

func (u SubscriptionCreation) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SubscriptionCreation) UnmarshalJSON(data []byte) error {
	var deser subscriptionCreationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	}
	return nil
}

func (u SubscriptionCreation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SubscriptionCreation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SubscriptionCreation) AcceptFuncs(successFunc func(SubscriptionCreationSuccess) error, errorFunc func(SubscriptionCreationError) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *SubscriptionCreation) SuccessNoopSuccess(SubscriptionCreationSuccess) error {
	return nil
}

func (u *SubscriptionCreation) ErrorNoopSuccess(SubscriptionCreationError) error {
	return nil
}

func (u *SubscriptionCreation) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SubscriptionCreation) Accept(v SubscriptionCreationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	}
}

type SubscriptionCreationVisitor interface {
	VisitSuccess(v SubscriptionCreationSuccess) error
	VisitError(v SubscriptionCreationError) error
	VisitUnknown(typeName string) error
}

func (u *SubscriptionCreation) AcceptWithContext(ctx context.Context, v SubscriptionCreationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccessWithContext(ctx, *u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	}
}

type SubscriptionCreationVisitorWithContext interface {
	VisitSuccessWithContext(ctx context.Context, v SubscriptionCreationSuccess) error
	VisitErrorWithContext(ctx context.Context, v SubscriptionCreationError) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSubscriptionCreationFromSuccess(v SubscriptionCreationSuccess) SubscriptionCreation {
	return SubscriptionCreation{typ: "success", success: &v}
}

func NewSubscriptionCreationFromError(v SubscriptionCreationError) SubscriptionCreation {
	return SubscriptionCreation{typ: "error", error: &v}
}

type SubscriptionUpdate struct {
	typ    string
	full   *FullResult
	append *AppendResult
	error  *SubscriptionUpdateError
}

type subscriptionUpdateDeserializer struct {
	Type   string                   `json:"type"`
	Full   *FullResult              `json:"full"`
	Append *AppendResult            `json:"append"`
	Error  *SubscriptionUpdateError `json:"error"`
}

func (u *subscriptionUpdateDeserializer) toStruct() SubscriptionUpdate {
	return SubscriptionUpdate{typ: u.Type, full: u.Full, append: u.Append, error: u.Error}
}

func (u *SubscriptionUpdate) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "full":
		if u.full == nil {
			return nil, fmt.Errorf("field \"full\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Full FullResult `json:"full"`
		}{Type: "full", Full: *u.full}, nil
	case "append":
		if u.append == nil {
			return nil, fmt.Errorf("field \"append\" is required")
		}
		return struct {
			Type   string       `json:"type"`
			Append AppendResult `json:"append"`
		}{Type: "append", Append: *u.append}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string                  `json:"type"`
			Error SubscriptionUpdateError `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	}
}

func (u SubscriptionUpdate) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SubscriptionUpdate) UnmarshalJSON(data []byte) error {
	var deser subscriptionUpdateDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "full":
		if u.full == nil {
			return fmt.Errorf("field \"full\" is required")
		}
	case "append":
		if u.append == nil {
			return fmt.Errorf("field \"append\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	}
	return nil
}

func (u SubscriptionUpdate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SubscriptionUpdate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SubscriptionUpdate) AcceptFuncs(fullFunc func(FullResult) error, appendFunc func(AppendResult) error, errorFunc func(SubscriptionUpdateError) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "full":
		if u.full == nil {
			return fmt.Errorf("field \"full\" is required")
		}
		return fullFunc(*u.full)
	case "append":
		if u.append == nil {
			return fmt.Errorf("field \"append\" is required")
		}
		return appendFunc(*u.append)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *SubscriptionUpdate) FullNoopSuccess(FullResult) error {
	return nil
}

func (u *SubscriptionUpdate) AppendNoopSuccess(AppendResult) error {
	return nil
}

func (u *SubscriptionUpdate) ErrorNoopSuccess(SubscriptionUpdateError) error {
	return nil
}

func (u *SubscriptionUpdate) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SubscriptionUpdate) Accept(v SubscriptionUpdateVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "full":
		if u.full == nil {
			return fmt.Errorf("field \"full\" is required")
		}
		return v.VisitFull(*u.full)
	case "append":
		if u.append == nil {
			return fmt.Errorf("field \"append\" is required")
		}
		return v.VisitAppend(*u.append)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	}
}

type SubscriptionUpdateVisitor interface {
	VisitFull(v FullResult) error
	VisitAppend(v AppendResult) error
	VisitError(v SubscriptionUpdateError) error
	VisitUnknown(typeName string) error
}

func (u *SubscriptionUpdate) AcceptWithContext(ctx context.Context, v SubscriptionUpdateVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "full":
		if u.full == nil {
			return fmt.Errorf("field \"full\" is required")
		}
		return v.VisitFullWithContext(ctx, *u.full)
	case "append":
		if u.append == nil {
			return fmt.Errorf("field \"append\" is required")
		}
		return v.VisitAppendWithContext(ctx, *u.append)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	}
}

type SubscriptionUpdateVisitorWithContext interface {
	VisitFullWithContext(ctx context.Context, v FullResult) error
	VisitAppendWithContext(ctx context.Context, v AppendResult) error
	VisitErrorWithContext(ctx context.Context, v SubscriptionUpdateError) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSubscriptionUpdateFromFull(v FullResult) SubscriptionUpdate {
	return SubscriptionUpdate{typ: "full", full: &v}
}

func NewSubscriptionUpdateFromAppend(v AppendResult) SubscriptionUpdate {
	return SubscriptionUpdate{typ: "append", append: &v}
}

func NewSubscriptionUpdateFromError(v SubscriptionUpdateError) SubscriptionUpdate {
	return SubscriptionUpdate{typ: "error", error: &v}
}
