// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type attachmentNotFound struct {
	AttachmentRid rids.AttachmentRid `json:"attachmentRid"`
}

func (o attachmentNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *attachmentNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewAttachmentNotFound returns new instance of AttachmentNotFound error.
func NewAttachmentNotFound(attachmentRidArg rids.AttachmentRid) *AttachmentNotFound {
	return &AttachmentNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), attachmentNotFound: attachmentNotFound{AttachmentRid: attachmentRidArg}}
}

// WrapWithAttachmentNotFound returns new instance of AttachmentNotFound error wrapping an existing error.
func WrapWithAttachmentNotFound(err error, attachmentRidArg rids.AttachmentRid) *AttachmentNotFound {
	return &AttachmentNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, attachmentNotFound: attachmentNotFound{AttachmentRid: attachmentRidArg}}
}

// AttachmentNotFound is an error type.
type AttachmentNotFound struct {
	errorInstanceID uuid.UUID
	attachmentNotFound
	cause error
	stack werror.StackTrace
}

// IsAttachmentNotFound returns true if err is an instance of AttachmentNotFound.
func IsAttachmentNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*AttachmentNotFound)
	return ok
}

func (e *AttachmentNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Attachment:AttachmentNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *AttachmentNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *AttachmentNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *AttachmentNotFound) Message() string {
	return "NOT_FOUND Attachment:AttachmentNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *AttachmentNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *AttachmentNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *AttachmentNotFound) Name() string {
	return "Attachment:AttachmentNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *AttachmentNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *AttachmentNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"attachmentRid": e.AttachmentRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *AttachmentNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"attachmentRid": e.AttachmentRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *AttachmentNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *AttachmentNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *AttachmentNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e AttachmentNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.attachmentNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Attachment:AttachmentNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *AttachmentNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters attachmentNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.attachmentNotFound = parameters
	return nil
}

type attachmentsNotFound struct {
	AttachmentRids []rids.AttachmentRid `json:"attachmentRids"`
}

func (o attachmentsNotFound) MarshalJSON() ([]byte, error) {
	if o.AttachmentRids == nil {
		o.AttachmentRids = make([]rids.AttachmentRid, 0)
	}
	type _tmpattachmentsNotFound attachmentsNotFound
	return safejson.Marshal(_tmpattachmentsNotFound(o))
}

func (o *attachmentsNotFound) UnmarshalJSON(data []byte) error {
	type _tmpattachmentsNotFound attachmentsNotFound
	var rawattachmentsNotFound _tmpattachmentsNotFound
	if err := safejson.Unmarshal(data, &rawattachmentsNotFound); err != nil {
		return err
	}
	if rawattachmentsNotFound.AttachmentRids == nil {
		rawattachmentsNotFound.AttachmentRids = make([]rids.AttachmentRid, 0)
	}
	*o = attachmentsNotFound(rawattachmentsNotFound)
	return nil
}

func (o attachmentsNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *attachmentsNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewAttachmentsNotFound returns new instance of AttachmentsNotFound error.
func NewAttachmentsNotFound(attachmentRidsArg []rids.AttachmentRid) *AttachmentsNotFound {
	return &AttachmentsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), attachmentsNotFound: attachmentsNotFound{AttachmentRids: attachmentRidsArg}}
}

// WrapWithAttachmentsNotFound returns new instance of AttachmentsNotFound error wrapping an existing error.
func WrapWithAttachmentsNotFound(err error, attachmentRidsArg []rids.AttachmentRid) *AttachmentsNotFound {
	return &AttachmentsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, attachmentsNotFound: attachmentsNotFound{AttachmentRids: attachmentRidsArg}}
}

// AttachmentsNotFound is an error type.
type AttachmentsNotFound struct {
	errorInstanceID uuid.UUID
	attachmentsNotFound
	cause error
	stack werror.StackTrace
}

// IsAttachmentsNotFound returns true if err is an instance of AttachmentsNotFound.
func IsAttachmentsNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*AttachmentsNotFound)
	return ok
}

func (e *AttachmentsNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Attachment:AttachmentsNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *AttachmentsNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *AttachmentsNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *AttachmentsNotFound) Message() string {
	return "NOT_FOUND Attachment:AttachmentsNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *AttachmentsNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *AttachmentsNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *AttachmentsNotFound) Name() string {
	return "Attachment:AttachmentsNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *AttachmentsNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *AttachmentsNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"attachmentRids": e.AttachmentRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *AttachmentsNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"attachmentRids": e.AttachmentRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *AttachmentsNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *AttachmentsNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *AttachmentsNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e AttachmentsNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.attachmentsNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Attachment:AttachmentsNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *AttachmentsNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters attachmentsNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.attachmentsNotFound = parameters
	return nil
}

type invalidS3Path struct {
	S3Path api.S3Path `json:"s3Path"`
}

func (o invalidS3Path) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidS3Path) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidS3Path returns new instance of InvalidS3Path error.
func NewInvalidS3Path(s3PathArg api.S3Path) *InvalidS3Path {
	return &InvalidS3Path{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidS3Path: invalidS3Path{S3Path: s3PathArg}}
}

// WrapWithInvalidS3Path returns new instance of InvalidS3Path error wrapping an existing error.
func WrapWithInvalidS3Path(err error, s3PathArg api.S3Path) *InvalidS3Path {
	return &InvalidS3Path{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidS3Path: invalidS3Path{S3Path: s3PathArg}}
}

// InvalidS3Path is an error type.
type InvalidS3Path struct {
	errorInstanceID uuid.UUID
	invalidS3Path
	cause error
	stack werror.StackTrace
}

// IsInvalidS3Path returns true if err is an instance of InvalidS3Path.
func IsInvalidS3Path(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidS3Path)
	return ok
}

func (e *InvalidS3Path) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Attachment:InvalidS3Path (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidS3Path) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidS3Path) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidS3Path) Message() string {
	return "INVALID_ARGUMENT Attachment:InvalidS3Path"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidS3Path) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidS3Path) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidS3Path) Name() string {
	return "Attachment:InvalidS3Path"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidS3Path) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidS3Path) Parameters() map[string]interface{} {
	return map[string]interface{}{"s3Path": e.S3Path}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidS3Path) safeParams() map[string]interface{} {
	return map[string]interface{}{"s3Path": e.S3Path, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidS3Path) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidS3Path) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidS3Path) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidS3Path) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidS3Path)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Attachment:InvalidS3Path", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidS3Path) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidS3Path
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidS3Path = parameters
	return nil
}

type s3FileNotFound struct {
	S3Path api.S3Path `json:"s3Path"`
}

func (o s3FileNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *s3FileNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewS3FileNotFound returns new instance of S3FileNotFound error.
func NewS3FileNotFound(s3PathArg api.S3Path) *S3FileNotFound {
	return &S3FileNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), s3FileNotFound: s3FileNotFound{S3Path: s3PathArg}}
}

// WrapWithS3FileNotFound returns new instance of S3FileNotFound error wrapping an existing error.
func WrapWithS3FileNotFound(err error, s3PathArg api.S3Path) *S3FileNotFound {
	return &S3FileNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, s3FileNotFound: s3FileNotFound{S3Path: s3PathArg}}
}

// S3FileNotFound is an error type.
type S3FileNotFound struct {
	errorInstanceID uuid.UUID
	s3FileNotFound
	cause error
	stack werror.StackTrace
}

// IsS3FileNotFound returns true if err is an instance of S3FileNotFound.
func IsS3FileNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*S3FileNotFound)
	return ok
}

func (e *S3FileNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Attachment:S3FileNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *S3FileNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *S3FileNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *S3FileNotFound) Message() string {
	return "NOT_FOUND Attachment:S3FileNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *S3FileNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *S3FileNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *S3FileNotFound) Name() string {
	return "Attachment:S3FileNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *S3FileNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *S3FileNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"s3Path": e.S3Path}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *S3FileNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"s3Path": e.S3Path, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *S3FileNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *S3FileNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *S3FileNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e S3FileNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.s3FileNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Attachment:S3FileNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *S3FileNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters s3FileNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.s3FileNotFound = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Attachment:AttachmentNotFound", reflect.TypeOf(AttachmentNotFound{}))
	conjureerrors.RegisterErrorType("Attachment:AttachmentsNotFound", reflect.TypeOf(AttachmentsNotFound{}))
	conjureerrors.RegisterErrorType("Attachment:InvalidS3Path", reflect.TypeOf(InvalidS3Path{}))
	conjureerrors.RegisterErrorType("Attachment:S3FileNotFound", reflect.TypeOf(S3FileNotFound{}))
}
