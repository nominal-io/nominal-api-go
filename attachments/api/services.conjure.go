// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"
	"io"
	"net/url"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	werror "github.com/palantir/witchcraft-go-error"
)

// The attachment service provides functionality for creating, updating, and archiving attachments uploaded to S3.
type AttachmentServiceClient interface {
	// Create a new attachment. Assumes the file is already uploaded to S3 through the upload service.
	Create(ctx context.Context, authHeader bearertoken.Token, requestArg CreateAttachmentRequest) (Attachment, error)
	// Get an attachment by its RID.
	Get(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid) (Attachment, error)
	// Get a set of attachments by their RIDs.
	GetBatch(ctx context.Context, authHeader bearertoken.Token, requestArg GetAttachmentsRequest) (GetAttachmentsResponse, error)
	// Get the binary content of an attachment.
	GetContent(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid) (io.ReadCloser, error)
	// Get a pre-signed URI to download an attachment. The link expires in 1 minute.
	GetUri(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid) (AttachmentUri, error)
	// Update an attachment. Only the fields that are set in the request will be updated.
	Update(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid, requestArg UpdateAttachmentRequest) (Attachment, error)
	// Archive an attachment.
	Archive(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid) error
	// Unarchive an attachment.
	Unarchive(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid) error
}

type attachmentServiceClient struct {
	client httpclient.Client
}

func NewAttachmentServiceClient(client httpclient.Client) AttachmentServiceClient {
	return &attachmentServiceClient{client: client}
}

func (c *attachmentServiceClient) Create(ctx context.Context, authHeader bearertoken.Token, requestArg CreateAttachmentRequest) (Attachment, error) {
	var defaultReturnVal Attachment
	var returnVal *Attachment
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Create"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/attachments/v1/attachments"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "create failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "create response cannot be nil")
	}
	return *returnVal, nil
}

func (c *attachmentServiceClient) Get(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid) (Attachment, error) {
	var defaultReturnVal Attachment
	var returnVal *Attachment
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Get"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/attachments/v1/attachments/%s", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "get failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "get response cannot be nil")
	}
	return *returnVal, nil
}

func (c *attachmentServiceClient) GetBatch(ctx context.Context, authHeader bearertoken.Token, requestArg GetAttachmentsRequest) (GetAttachmentsResponse, error) {
	var defaultReturnVal GetAttachmentsResponse
	var returnVal *GetAttachmentsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetBatch"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/attachments/v1/attachments/batch"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getBatch failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getBatch response cannot be nil")
	}
	return *returnVal, nil
}

func (c *attachmentServiceClient) GetContent(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid) (io.ReadCloser, error) {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetContent"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/attachments/v1/attachments/%s/content", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithRawResponseBody())
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	resp, err := c.client.Do(ctx, requestParams...)
	if err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getContent failed")
	}
	return resp.Body, nil
}

func (c *attachmentServiceClient) GetUri(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid) (AttachmentUri, error) {
	var defaultReturnVal AttachmentUri
	var returnVal *AttachmentUri
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetUri"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/attachments/v1/attachments/%s/uri", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getUri failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getUri response cannot be nil")
	}
	return *returnVal, nil
}

func (c *attachmentServiceClient) Update(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid, requestArg UpdateAttachmentRequest) (Attachment, error) {
	var defaultReturnVal Attachment
	var returnVal *Attachment
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Update"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/attachments/v1/attachments/%s", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "update failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "update response cannot be nil")
	}
	return *returnVal, nil
}

func (c *attachmentServiceClient) Archive(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Archive"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/attachments/v1/attachments/%s/archive", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "archive failed")
	}
	return nil
}

func (c *attachmentServiceClient) Unarchive(ctx context.Context, authHeader bearertoken.Token, ridArg rids.AttachmentRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Unarchive"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/attachments/v1/attachments/%s/unarchive", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "unarchive failed")
	}
	return nil
}

// The attachment service provides functionality for creating, updating, and archiving attachments uploaded to S3.
type AttachmentServiceClientWithAuth interface {
	// Create a new attachment. Assumes the file is already uploaded to S3 through the upload service.
	Create(ctx context.Context, requestArg CreateAttachmentRequest) (Attachment, error)
	// Get an attachment by its RID.
	Get(ctx context.Context, ridArg rids.AttachmentRid) (Attachment, error)
	// Get a set of attachments by their RIDs.
	GetBatch(ctx context.Context, requestArg GetAttachmentsRequest) (GetAttachmentsResponse, error)
	// Get the binary content of an attachment.
	GetContent(ctx context.Context, ridArg rids.AttachmentRid) (io.ReadCloser, error)
	// Get a pre-signed URI to download an attachment. The link expires in 1 minute.
	GetUri(ctx context.Context, ridArg rids.AttachmentRid) (AttachmentUri, error)
	// Update an attachment. Only the fields that are set in the request will be updated.
	Update(ctx context.Context, ridArg rids.AttachmentRid, requestArg UpdateAttachmentRequest) (Attachment, error)
	// Archive an attachment.
	Archive(ctx context.Context, ridArg rids.AttachmentRid) error
	// Unarchive an attachment.
	Unarchive(ctx context.Context, ridArg rids.AttachmentRid) error
}

func NewAttachmentServiceClientWithAuth(client AttachmentServiceClient, authHeader bearertoken.Token) AttachmentServiceClientWithAuth {
	return &attachmentServiceClientWithAuth{client: client, authHeader: authHeader}
}

type attachmentServiceClientWithAuth struct {
	client     AttachmentServiceClient
	authHeader bearertoken.Token
}

func (c *attachmentServiceClientWithAuth) Create(ctx context.Context, requestArg CreateAttachmentRequest) (Attachment, error) {
	return c.client.Create(ctx, c.authHeader, requestArg)
}

func (c *attachmentServiceClientWithAuth) Get(ctx context.Context, ridArg rids.AttachmentRid) (Attachment, error) {
	return c.client.Get(ctx, c.authHeader, ridArg)
}

func (c *attachmentServiceClientWithAuth) GetBatch(ctx context.Context, requestArg GetAttachmentsRequest) (GetAttachmentsResponse, error) {
	return c.client.GetBatch(ctx, c.authHeader, requestArg)
}

func (c *attachmentServiceClientWithAuth) GetContent(ctx context.Context, ridArg rids.AttachmentRid) (io.ReadCloser, error) {
	return c.client.GetContent(ctx, c.authHeader, ridArg)
}

func (c *attachmentServiceClientWithAuth) GetUri(ctx context.Context, ridArg rids.AttachmentRid) (AttachmentUri, error) {
	return c.client.GetUri(ctx, c.authHeader, ridArg)
}

func (c *attachmentServiceClientWithAuth) Update(ctx context.Context, ridArg rids.AttachmentRid, requestArg UpdateAttachmentRequest) (Attachment, error) {
	return c.client.Update(ctx, c.authHeader, ridArg, requestArg)
}

func (c *attachmentServiceClientWithAuth) Archive(ctx context.Context, ridArg rids.AttachmentRid) error {
	return c.client.Archive(ctx, c.authHeader, ridArg)
}

func (c *attachmentServiceClientWithAuth) Unarchive(ctx context.Context, ridArg rids.AttachmentRid) error {
	return c.client.Unarchive(ctx, c.authHeader, ridArg)
}

func NewAttachmentServiceClientWithTokenProvider(client AttachmentServiceClient, tokenProvider httpclient.TokenProvider) AttachmentServiceClientWithAuth {
	return &attachmentServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type attachmentServiceClientWithTokenProvider struct {
	client        AttachmentServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *attachmentServiceClientWithTokenProvider) Create(ctx context.Context, requestArg CreateAttachmentRequest) (Attachment, error) {
	var defaultReturnVal Attachment
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Create(ctx, bearertoken.Token(token), requestArg)
}

func (c *attachmentServiceClientWithTokenProvider) Get(ctx context.Context, ridArg rids.AttachmentRid) (Attachment, error) {
	var defaultReturnVal Attachment
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Get(ctx, bearertoken.Token(token), ridArg)
}

func (c *attachmentServiceClientWithTokenProvider) GetBatch(ctx context.Context, requestArg GetAttachmentsRequest) (GetAttachmentsResponse, error) {
	var defaultReturnVal GetAttachmentsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetBatch(ctx, bearertoken.Token(token), requestArg)
}

func (c *attachmentServiceClientWithTokenProvider) GetContent(ctx context.Context, ridArg rids.AttachmentRid) (io.ReadCloser, error) {
	var defaultReturnVal io.ReadCloser
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetContent(ctx, bearertoken.Token(token), ridArg)
}

func (c *attachmentServiceClientWithTokenProvider) GetUri(ctx context.Context, ridArg rids.AttachmentRid) (AttachmentUri, error) {
	var defaultReturnVal AttachmentUri
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetUri(ctx, bearertoken.Token(token), ridArg)
}

func (c *attachmentServiceClientWithTokenProvider) Update(ctx context.Context, ridArg rids.AttachmentRid, requestArg UpdateAttachmentRequest) (Attachment, error) {
	var defaultReturnVal Attachment
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Update(ctx, bearertoken.Token(token), ridArg, requestArg)
}

func (c *attachmentServiceClientWithTokenProvider) Archive(ctx context.Context, ridArg rids.AttachmentRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Archive(ctx, bearertoken.Token(token), ridArg)
}

func (c *attachmentServiceClientWithTokenProvider) Unarchive(ctx context.Context, ridArg rids.AttachmentRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Unarchive(ctx, bearertoken.Token(token), ridArg)
}
