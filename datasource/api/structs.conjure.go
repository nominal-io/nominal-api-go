// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/run/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type BatchGetChannelPrefixTreeRequest struct {
	DataSourceRids []rids.DataSourceRid `json:"dataSourceRids"`
	/*
	   When dataScopeFilters are specified, the set of data sources must match the set of data sources in
	   DataScopeFilters#tags
	*/
	DataScopeFilters *DataScopeFilters `conjure-docs:"When dataScopeFilters are specified, the set of data sources must match the set of data sources in\nDataScopeFilters#tags" json:"dataScopeFilters,omitempty"`
}

func (o BatchGetChannelPrefixTreeRequest) MarshalJSON() ([]byte, error) {
	if o.DataSourceRids == nil {
		o.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	type _tmpBatchGetChannelPrefixTreeRequest BatchGetChannelPrefixTreeRequest
	return safejson.Marshal(_tmpBatchGetChannelPrefixTreeRequest(o))
}

func (o *BatchGetChannelPrefixTreeRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchGetChannelPrefixTreeRequest BatchGetChannelPrefixTreeRequest
	var rawBatchGetChannelPrefixTreeRequest _tmpBatchGetChannelPrefixTreeRequest
	if err := safejson.Unmarshal(data, &rawBatchGetChannelPrefixTreeRequest); err != nil {
		return err
	}
	if rawBatchGetChannelPrefixTreeRequest.DataSourceRids == nil {
		rawBatchGetChannelPrefixTreeRequest.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	*o = BatchGetChannelPrefixTreeRequest(rawBatchGetChannelPrefixTreeRequest)
	return nil
}

func (o BatchGetChannelPrefixTreeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchGetChannelPrefixTreeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// If the tree for a data source has not been indexed, it will be omitted from the map.
type BatchGetChannelPrefixTreeResponse struct {
	ChannelPrefixTrees map[rids.DataSourceRid]ChannelPrefixTree `json:"channelPrefixTrees"`
}

func (o BatchGetChannelPrefixTreeResponse) MarshalJSON() ([]byte, error) {
	if o.ChannelPrefixTrees == nil {
		o.ChannelPrefixTrees = make(map[rids.DataSourceRid]ChannelPrefixTree, 0)
	}
	type _tmpBatchGetChannelPrefixTreeResponse BatchGetChannelPrefixTreeResponse
	return safejson.Marshal(_tmpBatchGetChannelPrefixTreeResponse(o))
}

func (o *BatchGetChannelPrefixTreeResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchGetChannelPrefixTreeResponse BatchGetChannelPrefixTreeResponse
	var rawBatchGetChannelPrefixTreeResponse _tmpBatchGetChannelPrefixTreeResponse
	if err := safejson.Unmarshal(data, &rawBatchGetChannelPrefixTreeResponse); err != nil {
		return err
	}
	if rawBatchGetChannelPrefixTreeResponse.ChannelPrefixTrees == nil {
		rawBatchGetChannelPrefixTreeResponse.ChannelPrefixTrees = make(map[rids.DataSourceRid]ChannelPrefixTree, 0)
	}
	*o = BatchGetChannelPrefixTreeResponse(rawBatchGetChannelPrefixTreeResponse)
	return nil
}

func (o BatchGetChannelPrefixTreeResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchGetChannelPrefixTreeResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchGetDataScopeBoundsRequest struct {
	Requests []GetDataScopeBoundsRequest `json:"requests"`
}

func (o BatchGetDataScopeBoundsRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]GetDataScopeBoundsRequest, 0)
	}
	type _tmpBatchGetDataScopeBoundsRequest BatchGetDataScopeBoundsRequest
	return safejson.Marshal(_tmpBatchGetDataScopeBoundsRequest(o))
}

func (o *BatchGetDataScopeBoundsRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchGetDataScopeBoundsRequest BatchGetDataScopeBoundsRequest
	var rawBatchGetDataScopeBoundsRequest _tmpBatchGetDataScopeBoundsRequest
	if err := safejson.Unmarshal(data, &rawBatchGetDataScopeBoundsRequest); err != nil {
		return err
	}
	if rawBatchGetDataScopeBoundsRequest.Requests == nil {
		rawBatchGetDataScopeBoundsRequest.Requests = make([]GetDataScopeBoundsRequest, 0)
	}
	*o = BatchGetDataScopeBoundsRequest(rawBatchGetDataScopeBoundsRequest)
	return nil
}

func (o BatchGetDataScopeBoundsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchGetDataScopeBoundsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchGetDataScopeBoundsResponse struct {
	Responses []GetDataScopeBoundsResponse `json:"responses"`
}

func (o BatchGetDataScopeBoundsResponse) MarshalJSON() ([]byte, error) {
	if o.Responses == nil {
		o.Responses = make([]GetDataScopeBoundsResponse, 0)
	}
	type _tmpBatchGetDataScopeBoundsResponse BatchGetDataScopeBoundsResponse
	return safejson.Marshal(_tmpBatchGetDataScopeBoundsResponse(o))
}

func (o *BatchGetDataScopeBoundsResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchGetDataScopeBoundsResponse BatchGetDataScopeBoundsResponse
	var rawBatchGetDataScopeBoundsResponse _tmpBatchGetDataScopeBoundsResponse
	if err := safejson.Unmarshal(data, &rawBatchGetDataScopeBoundsResponse); err != nil {
		return err
	}
	if rawBatchGetDataScopeBoundsResponse.Responses == nil {
		rawBatchGetDataScopeBoundsResponse.Responses = make([]GetDataScopeBoundsResponse, 0)
	}
	*o = BatchGetDataScopeBoundsResponse(rawBatchGetDataScopeBoundsResponse)
	return nil
}

func (o BatchGetDataScopeBoundsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchGetDataScopeBoundsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelMetadata struct {
	Name        api.Channel                         `json:"name"`
	DataSource  rids.DataSourceRid                  `json:"dataSource"`
	Unit        *api1.Unit                          `json:"unit,omitempty"`
	Description *string                             `json:"description,omitempty"`
	DataType    *api.SeriesDataType                 `json:"dataType,omitempty"`
	SeriesRid   SeriesMetadataRidOrLogicalSeriesRid `json:"seriesRid"`
}

func (o ChannelMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelPrefixTree struct {
	Roots     []ChannelPrefixTreeNode `json:"roots"`
	Delimiter string                  `json:"delimiter"`
}

func (o ChannelPrefixTree) MarshalJSON() ([]byte, error) {
	if o.Roots == nil {
		o.Roots = make([]ChannelPrefixTreeNode, 0)
	}
	type _tmpChannelPrefixTree ChannelPrefixTree
	return safejson.Marshal(_tmpChannelPrefixTree(o))
}

func (o *ChannelPrefixTree) UnmarshalJSON(data []byte) error {
	type _tmpChannelPrefixTree ChannelPrefixTree
	var rawChannelPrefixTree _tmpChannelPrefixTree
	if err := safejson.Unmarshal(data, &rawChannelPrefixTree); err != nil {
		return err
	}
	if rawChannelPrefixTree.Roots == nil {
		rawChannelPrefixTree.Roots = make([]ChannelPrefixTreeNode, 0)
	}
	*o = ChannelPrefixTree(rawChannelPrefixTree)
	return nil
}

func (o ChannelPrefixTree) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelPrefixTree) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelPrefixTreeNode struct {
	// Should be combined with the ancestor parts and the delimiter to form the full prefix.
	Part     string                  `conjure-docs:"Should be combined with the ancestor parts and the delimiter to form the full prefix." json:"part"`
	Children []ChannelPrefixTreeNode `json:"children"`
}

func (o ChannelPrefixTreeNode) MarshalJSON() ([]byte, error) {
	if o.Children == nil {
		o.Children = make([]ChannelPrefixTreeNode, 0)
	}
	type _tmpChannelPrefixTreeNode ChannelPrefixTreeNode
	return safejson.Marshal(_tmpChannelPrefixTreeNode(o))
}

func (o *ChannelPrefixTreeNode) UnmarshalJSON(data []byte) error {
	type _tmpChannelPrefixTreeNode ChannelPrefixTreeNode
	var rawChannelPrefixTreeNode _tmpChannelPrefixTreeNode
	if err := safejson.Unmarshal(data, &rawChannelPrefixTreeNode); err != nil {
		return err
	}
	if rawChannelPrefixTreeNode.Children == nil {
		rawChannelPrefixTreeNode.Children = make([]ChannelPrefixTreeNode, 0)
	}
	*o = ChannelPrefixTreeNode(rawChannelPrefixTreeNode)
	return nil
}

func (o ChannelPrefixTreeNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelPrefixTreeNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelWithAvailableTags struct {
	DataSourceRid rids.DataSourceRid `json:"dataSourceRid"`
	Channel       api.Channel        `json:"channel"`
	/*
	   A set of tag keys and their values given the initial set of filters. The initial tag filters
	   will be included in the map with their corresponding values.
	*/
	AvailableTags map[api.TagName][]api.TagValue `conjure-docs:"A set of tag keys and their values given the initial set of filters. The initial tag filters\nwill be included in the map with their corresponding values." json:"availableTags"`
}

func (o ChannelWithAvailableTags) MarshalJSON() ([]byte, error) {
	if o.AvailableTags == nil {
		o.AvailableTags = make(map[api.TagName][]api.TagValue, 0)
	}
	type _tmpChannelWithAvailableTags ChannelWithAvailableTags
	return safejson.Marshal(_tmpChannelWithAvailableTags(o))
}

func (o *ChannelWithAvailableTags) UnmarshalJSON(data []byte) error {
	type _tmpChannelWithAvailableTags ChannelWithAvailableTags
	var rawChannelWithAvailableTags _tmpChannelWithAvailableTags
	if err := safejson.Unmarshal(data, &rawChannelWithAvailableTags); err != nil {
		return err
	}
	if rawChannelWithAvailableTags.AvailableTags == nil {
		rawChannelWithAvailableTags.AvailableTags = make(map[api.TagName][]api.TagValue, 0)
	}
	*o = ChannelWithAvailableTags(rawChannelWithAvailableTags)
	return nil
}

func (o ChannelWithAvailableTags) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelWithAvailableTags) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelWithTagFilters struct {
	DataSourceRid rids.DataSourceRid           `json:"dataSourceRid"`
	Channel       api.Channel                  `json:"channel"`
	TagFilters    map[api.TagName]api.TagValue `json:"tagFilters"`
}

func (o ChannelWithTagFilters) MarshalJSON() ([]byte, error) {
	if o.TagFilters == nil {
		o.TagFilters = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpChannelWithTagFilters ChannelWithTagFilters
	return safejson.Marshal(_tmpChannelWithTagFilters(o))
}

func (o *ChannelWithTagFilters) UnmarshalJSON(data []byte) error {
	type _tmpChannelWithTagFilters ChannelWithTagFilters
	var rawChannelWithTagFilters _tmpChannelWithTagFilters
	if err := safejson.Unmarshal(data, &rawChannelWithTagFilters); err != nil {
		return err
	}
	if rawChannelWithTagFilters.TagFilters == nil {
		rawChannelWithTagFilters.TagFilters = make(map[api.TagName]api.TagValue, 0)
	}
	*o = ChannelWithTagFilters(rawChannelWithTagFilters)
	return nil
}

func (o ChannelWithTagFilters) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelWithTagFilters) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataScopeFilters struct {
	/*
	   For each data source specified as a key, search will only return channels containing a superset of the
	   tags specified for that given datasource.
	*/
	Tags map[rids.DataSourceRid]map[api.TagName]api.TagValue `conjure-docs:"For each data source specified as a key, search will only return channels containing a superset of the \ntags specified for that given datasource." json:"tags"`
	// Will only return channels that have had new data after the specified time.
	MinDataUpdatedTime api1.UtcTimestamp `conjure-docs:"Will only return channels that have had new data after the specified time." json:"minDataUpdatedTime"`
	// Will only return channels that have data before the specified time.
	MaxDataStartTime api1.UtcTimestamp `conjure-docs:"Will only return channels that have data before the specified time." json:"maxDataStartTime"`
}

func (o DataScopeFilters) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make(map[rids.DataSourceRid]map[api.TagName]api.TagValue, 0)
	}
	type _tmpDataScopeFilters DataScopeFilters
	return safejson.Marshal(_tmpDataScopeFilters(o))
}

func (o *DataScopeFilters) UnmarshalJSON(data []byte) error {
	type _tmpDataScopeFilters DataScopeFilters
	var rawDataScopeFilters _tmpDataScopeFilters
	if err := safejson.Unmarshal(data, &rawDataScopeFilters); err != nil {
		return err
	}
	if rawDataScopeFilters.Tags == nil {
		rawDataScopeFilters.Tags = make(map[rids.DataSourceRid]map[api.TagName]api.TagValue, 0)
	}
	*o = DataScopeFilters(rawDataScopeFilters)
	return nil
}

func (o DataScopeFilters) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataScopeFilters) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataSourcePrefixNode struct {
	// Should be combined with the ancestor parts and the delimiter to form the full prefix.
	Part       string             `conjure-docs:"Should be combined with the ancestor parts and the delimiter to form the full prefix." json:"part"`
	DataSource rids.DataSourceRid `json:"dataSource"`
}

func (o DataSourcePrefixNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataSourcePrefixNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetAvailableTagKeysRequest struct {
	Filters       TagSearchFilters `json:"filters"`
	NextPageToken *api.TagName     `json:"nextPageToken,omitempty"`
	PageSize      *int             `json:"pageSize,omitempty"`
}

func (o GetAvailableTagKeysRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetAvailableTagKeysRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetAvailableTagKeysResponse struct {
	Results       []api.TagName `json:"results"`
	NextPageToken *api.TagName  `json:"nextPageToken,omitempty"`
}

func (o GetAvailableTagKeysResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]api.TagName, 0)
	}
	type _tmpGetAvailableTagKeysResponse GetAvailableTagKeysResponse
	return safejson.Marshal(_tmpGetAvailableTagKeysResponse(o))
}

func (o *GetAvailableTagKeysResponse) UnmarshalJSON(data []byte) error {
	type _tmpGetAvailableTagKeysResponse GetAvailableTagKeysResponse
	var rawGetAvailableTagKeysResponse _tmpGetAvailableTagKeysResponse
	if err := safejson.Unmarshal(data, &rawGetAvailableTagKeysResponse); err != nil {
		return err
	}
	if rawGetAvailableTagKeysResponse.Results == nil {
		rawGetAvailableTagKeysResponse.Results = make([]api.TagName, 0)
	}
	*o = GetAvailableTagKeysResponse(rawGetAvailableTagKeysResponse)
	return nil
}

func (o GetAvailableTagKeysResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetAvailableTagKeysResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetAvailableTagValuesRequest struct {
	Filters       TagSearchFilters `json:"filters"`
	TagName       api.TagName      `json:"tagName"`
	NextPageToken *api.TagValue    `json:"nextPageToken,omitempty"`
	// Defaults to 1000. Will throw if larger than 10000.
	PageSize *int `conjure-docs:"Defaults to 1000. Will throw if larger than 10000." json:"pageSize,omitempty"`
}

func (o GetAvailableTagValuesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetAvailableTagValuesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetAvailableTagValuesResponse struct {
	Results       []api.TagValue `json:"results"`
	NextPageToken *api.TagValue  `json:"nextPageToken,omitempty"`
}

func (o GetAvailableTagValuesResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]api.TagValue, 0)
	}
	type _tmpGetAvailableTagValuesResponse GetAvailableTagValuesResponse
	return safejson.Marshal(_tmpGetAvailableTagValuesResponse(o))
}

func (o *GetAvailableTagValuesResponse) UnmarshalJSON(data []byte) error {
	type _tmpGetAvailableTagValuesResponse GetAvailableTagValuesResponse
	var rawGetAvailableTagValuesResponse _tmpGetAvailableTagValuesResponse
	if err := safejson.Unmarshal(data, &rawGetAvailableTagValuesResponse); err != nil {
		return err
	}
	if rawGetAvailableTagValuesResponse.Results == nil {
		rawGetAvailableTagValuesResponse.Results = make([]api.TagValue, 0)
	}
	*o = GetAvailableTagValuesResponse(rawGetAvailableTagValuesResponse)
	return nil
}

func (o GetAvailableTagValuesResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetAvailableTagValuesResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetAvailableTagsForChannelRequest struct {
	ChannelWithTagFilters ChannelWithTagFilters `json:"channelWithTagFilters"`
	StartTime             api1.UtcTimestamp     `json:"startTime"`
	EndTime               api1.UtcTimestamp     `json:"endTime"`
}

func (o GetAvailableTagsForChannelRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetAvailableTagsForChannelRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetAvailableTagsForChannelResponse struct {
	AvailableTags ChannelWithAvailableTags `json:"availableTags"`
}

func (o GetAvailableTagsForChannelResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetAvailableTagsForChannelResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetDataScopeBoundsRequest struct {
	DataSourceRid rids.DataSourceRid           `json:"dataSourceRid"`
	Tags          map[api.TagName]api.TagValue `json:"tags"`
}

func (o GetDataScopeBoundsRequest) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpGetDataScopeBoundsRequest GetDataScopeBoundsRequest
	return safejson.Marshal(_tmpGetDataScopeBoundsRequest(o))
}

func (o *GetDataScopeBoundsRequest) UnmarshalJSON(data []byte) error {
	type _tmpGetDataScopeBoundsRequest GetDataScopeBoundsRequest
	var rawGetDataScopeBoundsRequest _tmpGetDataScopeBoundsRequest
	if err := safejson.Unmarshal(data, &rawGetDataScopeBoundsRequest); err != nil {
		return err
	}
	if rawGetDataScopeBoundsRequest.Tags == nil {
		rawGetDataScopeBoundsRequest.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	*o = GetDataScopeBoundsRequest(rawGetDataScopeBoundsRequest)
	return nil
}

func (o GetDataScopeBoundsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetDataScopeBoundsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetDataScopeBoundsResponse struct {
	/*
	   If missing, the end bound is not known definitively. This can happen if the
	   data scope corresponds to an external database or its data was not updated in the last month.
	*/
	EndTime *api.Timestamp `conjure-docs:"If missing, the end bound is not known definitively. This can happen if the\ndata scope corresponds to an external database or its data was not updated in the last month." json:"endTime,omitempty"`
}

func (o GetDataScopeBoundsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetDataScopeBoundsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetTagValuesForDataSourceRequest struct {
	// If empty, returns all available tag keys.
	TagKeys *[]api.TagName `conjure-docs:"If empty, returns all available tag keys." json:"tagKeys,omitempty"`
	/*
	   For Nominal data sources, a time range can be provided to filter tag values to those present within the
	   months spanned by the range. If left empty, this defaults to the last month. For external data sources,
	   the range must not be specified, as all tag values are returned.
	*/
	Range *api.Range `conjure-docs:"For Nominal data sources, a time range can be provided to filter tag values to those present within the \nmonths spanned by the range. If left empty, this defaults to the last month. For external data sources, \nthe range must not be specified, as all tag values are returned." json:"range,omitempty"`
}

func (o GetTagValuesForDataSourceRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetTagValuesForDataSourceRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IndexChannelPrefixTreeRequest struct {
	DataSourceRid rids.DataSourceRid `json:"dataSourceRid"`
	Delimiter     string             `json:"delimiter"`
}

func (o IndexChannelPrefixTreeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IndexChannelPrefixTreeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchChannelsRequest struct {
	FuzzySearchText string `json:"fuzzySearchText"`
	// Deprecated: Use `searchHierarchical` instead. Will be ignored.
	Prefix *string `json:"prefix,omitempty"`
	// Will return only channels that contain all strings specified as exact matches (case insensitive).
	ExactMatch  []string             `conjure-docs:"Will return only channels that contain all strings specified as exact matches (case insensitive)." json:"exactMatch"`
	DataSources []rids.DataSourceRid `json:"dataSources"`
	// Deprecated: Will be ignored.
	PreviouslySelectedChannels *map[rids.DataSourceRid][]api.Channel `json:"previouslySelectedChannels,omitempty"`
	NextPageToken              *api.Token                            `json:"nextPageToken,omitempty"`
	// Defaults to 1000. Will throw if larger than 1000.
	PageSize *int `conjure-docs:"Defaults to 1000. Will throw if larger than 1000." json:"pageSize,omitempty"`
}

func (o SearchChannelsRequest) MarshalJSON() ([]byte, error) {
	if o.ExactMatch == nil {
		o.ExactMatch = make([]string, 0)
	}
	if o.DataSources == nil {
		o.DataSources = make([]rids.DataSourceRid, 0)
	}
	type _tmpSearchChannelsRequest SearchChannelsRequest
	return safejson.Marshal(_tmpSearchChannelsRequest(o))
}

func (o *SearchChannelsRequest) UnmarshalJSON(data []byte) error {
	type _tmpSearchChannelsRequest SearchChannelsRequest
	var rawSearchChannelsRequest _tmpSearchChannelsRequest
	if err := safejson.Unmarshal(data, &rawSearchChannelsRequest); err != nil {
		return err
	}
	if rawSearchChannelsRequest.ExactMatch == nil {
		rawSearchChannelsRequest.ExactMatch = make([]string, 0)
	}
	if rawSearchChannelsRequest.DataSources == nil {
		rawSearchChannelsRequest.DataSources = make([]rids.DataSourceRid, 0)
	}
	*o = SearchChannelsRequest(rawSearchChannelsRequest)
	return nil
}

func (o SearchChannelsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchChannelsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchChannelsResponse struct {
	Results       []ChannelMetadata `json:"results"`
	NextPageToken *api.Token        `json:"nextPageToken,omitempty"`
}

func (o SearchChannelsResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ChannelMetadata, 0)
	}
	type _tmpSearchChannelsResponse SearchChannelsResponse
	return safejson.Marshal(_tmpSearchChannelsResponse(o))
}

func (o *SearchChannelsResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchChannelsResponse SearchChannelsResponse
	var rawSearchChannelsResponse _tmpSearchChannelsResponse
	if err := safejson.Unmarshal(data, &rawSearchChannelsResponse); err != nil {
		return err
	}
	if rawSearchChannelsResponse.Results == nil {
		rawSearchChannelsResponse.Results = make([]ChannelMetadata, 0)
	}
	*o = SearchChannelsResponse(rawSearchChannelsResponse)
	return nil
}

func (o SearchChannelsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchChannelsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchFilteredChannelsRequest struct {
	// All of the strings in the set must appear exactly as substrings within the channel name.
	Substrings *[]string `conjure-docs:"All of the strings in the set must appear exactly as substrings within the channel name." json:"substrings,omitempty"`
	/*
	   All of the characters in the string will appear in the same order (not necessarily adjacently)
	   within the channel name. Only supports one subsequence to match at this time.
	*/
	Subsequences *[]string            `conjure-docs:"All of the characters in the string will appear in the same order (not necessarily adjacently)\nwithin the channel name. Only supports one subsequence to match at this time." json:"subsequences,omitempty"`
	DataSources  []rids.DataSourceRid `json:"dataSources"`
	// Defaults to 200. Will throw if larger than 200.
	ResultSize *int `conjure-docs:"Defaults to 200. Will throw if larger than 200." json:"resultSize,omitempty"`
	/*
	   For each data source specified as a key, search will only return channels containing a superset of the
	   tags specified for that given datasource. If a data source is present in the dataSources field but not
	   in this map, or if a data source points to an empty map of tags, it will be searched without tag filters.
	*/
	Tags map[rids.DataSourceRid]map[api.TagName]api.TagValue `conjure-docs:"For each data source specified as a key, search will only return channels containing a superset of the \ntags specified for that given datasource. If a data source is present in the dataSources field but not\nin this map, or if a data source points to an empty map of tags, it will be searched without tag filters." json:"tags"`
	// If specified, search will only return channels that have had new data after the specified time.
	MinDataUpdatedTime *api1.UtcTimestamp `conjure-docs:"If specified, search will only return channels that have had new data after the specified time." json:"minDataUpdatedTime,omitempty"`
	// If specified, search will only return channels that have data before the specified time.
	MaxDataStartTime *api1.UtcTimestamp `conjure-docs:"If specified, search will only return channels that have data before the specified time." json:"maxDataStartTime,omitempty"`
	// Deprecated: Will be ignored.
	PreviouslySelectedChannels *map[rids.DataSourceRid][]api.Channel `json:"previouslySelectedChannels,omitempty"`
	// Deprecated: Try subsequence search instead.
	FuzzySearchText *string `json:"fuzzySearchText,omitempty"`
	/*
	   Will return only channels that contain all strings specified as exact matches (case insensitive).

	   Deprecated: Try substring search instead.
	*/
	ExactMatch *[]string `conjure-docs:"Will return only channels that contain all strings specified as exact matches (case insensitive)." json:"exactMatch,omitempty"`
}

func (o SearchFilteredChannelsRequest) MarshalJSON() ([]byte, error) {
	if o.DataSources == nil {
		o.DataSources = make([]rids.DataSourceRid, 0)
	}
	if o.Tags == nil {
		o.Tags = make(map[rids.DataSourceRid]map[api.TagName]api.TagValue, 0)
	}
	type _tmpSearchFilteredChannelsRequest SearchFilteredChannelsRequest
	return safejson.Marshal(_tmpSearchFilteredChannelsRequest(o))
}

func (o *SearchFilteredChannelsRequest) UnmarshalJSON(data []byte) error {
	type _tmpSearchFilteredChannelsRequest SearchFilteredChannelsRequest
	var rawSearchFilteredChannelsRequest _tmpSearchFilteredChannelsRequest
	if err := safejson.Unmarshal(data, &rawSearchFilteredChannelsRequest); err != nil {
		return err
	}
	if rawSearchFilteredChannelsRequest.DataSources == nil {
		rawSearchFilteredChannelsRequest.DataSources = make([]rids.DataSourceRid, 0)
	}
	if rawSearchFilteredChannelsRequest.Tags == nil {
		rawSearchFilteredChannelsRequest.Tags = make(map[rids.DataSourceRid]map[api.TagName]api.TagValue, 0)
	}
	*o = SearchFilteredChannelsRequest(rawSearchFilteredChannelsRequest)
	return nil
}

func (o SearchFilteredChannelsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchFilteredChannelsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchFilteredChannelsResponse struct {
	Results []ChannelMetadata `json:"results"`
}

func (o SearchFilteredChannelsResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ChannelMetadata, 0)
	}
	type _tmpSearchFilteredChannelsResponse SearchFilteredChannelsResponse
	return safejson.Marshal(_tmpSearchFilteredChannelsResponse(o))
}

func (o *SearchFilteredChannelsResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchFilteredChannelsResponse SearchFilteredChannelsResponse
	var rawSearchFilteredChannelsResponse _tmpSearchFilteredChannelsResponse
	if err := safejson.Unmarshal(data, &rawSearchFilteredChannelsResponse); err != nil {
		return err
	}
	if rawSearchFilteredChannelsResponse.Results == nil {
		rawSearchFilteredChannelsResponse.Results = make([]ChannelMetadata, 0)
	}
	*o = SearchFilteredChannelsResponse(rawSearchFilteredChannelsResponse)
	return nil
}

func (o SearchFilteredChannelsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchFilteredChannelsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchHierarchicalChannelsRequest struct {
	// The parent (represented as a list of parts) to search under. If empty, will return all top-level channels.
	Parent      []string             `conjure-docs:"The parent (represented as a list of parts) to search under. If empty, will return all top-level channels." json:"parent"`
	DataSources []rids.DataSourceRid `json:"dataSources"`
	/*
	   When dataScopeFilters are specified, the set of data sources must match the set of data sources in
	   DataScopeFilters#tags
	*/
	DataScopeFilters *DataScopeFilters `conjure-docs:"When dataScopeFilters are specified, the set of data sources must match the set of data sources in\nDataScopeFilters#tags" json:"dataScopeFilters,omitempty"`
}

func (o SearchHierarchicalChannelsRequest) MarshalJSON() ([]byte, error) {
	if o.Parent == nil {
		o.Parent = make([]string, 0)
	}
	if o.DataSources == nil {
		o.DataSources = make([]rids.DataSourceRid, 0)
	}
	type _tmpSearchHierarchicalChannelsRequest SearchHierarchicalChannelsRequest
	return safejson.Marshal(_tmpSearchHierarchicalChannelsRequest(o))
}

func (o *SearchHierarchicalChannelsRequest) UnmarshalJSON(data []byte) error {
	type _tmpSearchHierarchicalChannelsRequest SearchHierarchicalChannelsRequest
	var rawSearchHierarchicalChannelsRequest _tmpSearchHierarchicalChannelsRequest
	if err := safejson.Unmarshal(data, &rawSearchHierarchicalChannelsRequest); err != nil {
		return err
	}
	if rawSearchHierarchicalChannelsRequest.Parent == nil {
		rawSearchHierarchicalChannelsRequest.Parent = make([]string, 0)
	}
	if rawSearchHierarchicalChannelsRequest.DataSources == nil {
		rawSearchHierarchicalChannelsRequest.DataSources = make([]rids.DataSourceRid, 0)
	}
	*o = SearchHierarchicalChannelsRequest(rawSearchHierarchicalChannelsRequest)
	return nil
}

func (o SearchHierarchicalChannelsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchHierarchicalChannelsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchHierarchicalChannelsResponse struct {
	Results []ChannelOrPrefix `json:"results"`
}

func (o SearchHierarchicalChannelsResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ChannelOrPrefix, 0)
	}
	type _tmpSearchHierarchicalChannelsResponse SearchHierarchicalChannelsResponse
	return safejson.Marshal(_tmpSearchHierarchicalChannelsResponse(o))
}

func (o *SearchHierarchicalChannelsResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchHierarchicalChannelsResponse SearchHierarchicalChannelsResponse
	var rawSearchHierarchicalChannelsResponse _tmpSearchHierarchicalChannelsResponse
	if err := safejson.Unmarshal(data, &rawSearchHierarchicalChannelsResponse); err != nil {
		return err
	}
	if rawSearchHierarchicalChannelsResponse.Results == nil {
		rawSearchHierarchicalChannelsResponse.Results = make([]ChannelOrPrefix, 0)
	}
	*o = SearchHierarchicalChannelsResponse(rawSearchHierarchicalChannelsResponse)
	return nil
}

func (o SearchHierarchicalChannelsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchHierarchicalChannelsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Filters to use when searching for available tag names and values in paged endpoints.
All filters are optional.
*/
type TagSearchFilters struct {
	// Optional, defaults to all channels in datasource.
	Channel *api.Channel `conjure-docs:"Optional, defaults to all channels in datasource." json:"channel,omitempty"`
	// Optional, defaults to no tag filter.
	TagFilters map[api.TagName]api.TagValue `conjure-docs:"Optional, defaults to no tag filter." json:"tagFilters"`
	// Optional, defaults to no range filter.
	Range *api.Range `conjure-docs:"Optional, defaults to no range filter." json:"range,omitempty"`
}

func (o TagSearchFilters) MarshalJSON() ([]byte, error) {
	if o.TagFilters == nil {
		o.TagFilters = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpTagSearchFilters TagSearchFilters
	return safejson.Marshal(_tmpTagSearchFilters(o))
}

func (o *TagSearchFilters) UnmarshalJSON(data []byte) error {
	type _tmpTagSearchFilters TagSearchFilters
	var rawTagSearchFilters _tmpTagSearchFilters
	if err := safejson.Unmarshal(data, &rawTagSearchFilters); err != nil {
		return err
	}
	if rawTagSearchFilters.TagFilters == nil {
		rawTagSearchFilters.TagFilters = make(map[api.TagName]api.TagValue, 0)
	}
	*o = TagSearchFilters(rawTagSearchFilters)
	return nil
}

func (o TagSearchFilters) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TagSearchFilters) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
