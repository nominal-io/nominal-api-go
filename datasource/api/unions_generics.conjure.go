// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/io/nominal/api"
)

type ChannelOrPrefixWithT[T any] ChannelOrPrefix

func (u *ChannelOrPrefixWithT[T]) Accept(ctx context.Context, v ChannelOrPrefixVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return v.VisitChannel(ctx, *u.channel)
	case "prefix":
		if u.prefix == nil {
			return result, fmt.Errorf("field \"prefix\" is required")
		}
		return v.VisitPrefix(ctx, *u.prefix)
	}
}

func (u *ChannelOrPrefixWithT[T]) AcceptFuncs(channelFunc func(ChannelMetadata) (T, error), prefixFunc func(DataSourcePrefixNode) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "channel":
		if u.channel == nil {
			return result, fmt.Errorf("field \"channel\" is required")
		}
		return channelFunc(*u.channel)
	case "prefix":
		if u.prefix == nil {
			return result, fmt.Errorf("field \"prefix\" is required")
		}
		return prefixFunc(*u.prefix)
	}
}

func (u *ChannelOrPrefixWithT[T]) ChannelNoopSuccess(ChannelMetadata) (T, error) {
	var result T
	return result, nil
}

func (u *ChannelOrPrefixWithT[T]) PrefixNoopSuccess(DataSourcePrefixNode) (T, error) {
	var result T
	return result, nil
}

func (u *ChannelOrPrefixWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ChannelOrPrefixVisitorWithT[T any] interface {
	VisitChannel(ctx context.Context, v ChannelMetadata) (T, error)
	VisitPrefix(ctx context.Context, v DataSourcePrefixNode) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SeriesMetadataRidOrLogicalSeriesRidWithT[T any] SeriesMetadataRidOrLogicalSeriesRid

func (u *SeriesMetadataRidOrLogicalSeriesRidWithT[T]) Accept(ctx context.Context, v SeriesMetadataRidOrLogicalSeriesRidVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "seriesArchetype":
		if u.seriesArchetype == nil {
			return result, fmt.Errorf("field \"seriesArchetype\" is required")
		}
		return v.VisitSeriesArchetype(ctx, *u.seriesArchetype)
	case "logicalSeries":
		if u.logicalSeries == nil {
			return result, fmt.Errorf("field \"logicalSeries\" is required")
		}
		return v.VisitLogicalSeries(ctx, *u.logicalSeries)
	}
}

func (u *SeriesMetadataRidOrLogicalSeriesRidWithT[T]) AcceptFuncs(seriesArchetypeFunc func(api.SeriesMetadataRid) (T, error), logicalSeriesFunc func(api.LogicalSeriesRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "seriesArchetype":
		if u.seriesArchetype == nil {
			return result, fmt.Errorf("field \"seriesArchetype\" is required")
		}
		return seriesArchetypeFunc(*u.seriesArchetype)
	case "logicalSeries":
		if u.logicalSeries == nil {
			return result, fmt.Errorf("field \"logicalSeries\" is required")
		}
		return logicalSeriesFunc(*u.logicalSeries)
	}
}

func (u *SeriesMetadataRidOrLogicalSeriesRidWithT[T]) SeriesArchetypeNoopSuccess(api.SeriesMetadataRid) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesMetadataRidOrLogicalSeriesRidWithT[T]) LogicalSeriesNoopSuccess(api.LogicalSeriesRid) (T, error) {
	var result T
	return result, nil
}

func (u *SeriesMetadataRidOrLogicalSeriesRidWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SeriesMetadataRidOrLogicalSeriesRidVisitorWithT[T any] interface {
	VisitSeriesArchetype(ctx context.Context, v api.SeriesMetadataRid) (T, error)
	VisitLogicalSeries(ctx context.Context, v api.LogicalSeriesRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
