// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type cannotGetTagsForNonSeriesDataSource struct {
	DataSourceRid rids.DataSourceRid `json:"dataSourceRid"`
}

func (o cannotGetTagsForNonSeriesDataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *cannotGetTagsForNonSeriesDataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCannotGetTagsForNonSeriesDataSource returns new instance of CannotGetTagsForNonSeriesDataSource error.
func NewCannotGetTagsForNonSeriesDataSource(dataSourceRidArg rids.DataSourceRid) *CannotGetTagsForNonSeriesDataSource {
	return &CannotGetTagsForNonSeriesDataSource{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cannotGetTagsForNonSeriesDataSource: cannotGetTagsForNonSeriesDataSource{DataSourceRid: dataSourceRidArg}}
}

// WrapWithCannotGetTagsForNonSeriesDataSource returns new instance of CannotGetTagsForNonSeriesDataSource error wrapping an existing error.
func WrapWithCannotGetTagsForNonSeriesDataSource(err error, dataSourceRidArg rids.DataSourceRid) *CannotGetTagsForNonSeriesDataSource {
	return &CannotGetTagsForNonSeriesDataSource{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, cannotGetTagsForNonSeriesDataSource: cannotGetTagsForNonSeriesDataSource{DataSourceRid: dataSourceRidArg}}
}

// CannotGetTagsForNonSeriesDataSource is an error type.
type CannotGetTagsForNonSeriesDataSource struct {
	errorInstanceID uuid.UUID
	cannotGetTagsForNonSeriesDataSource
	cause error
	stack werror.StackTrace
}

// IsCannotGetTagsForNonSeriesDataSource returns true if err is an instance of CannotGetTagsForNonSeriesDataSource.
func IsCannotGetTagsForNonSeriesDataSource(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CannotGetTagsForNonSeriesDataSource)
	return ok
}

func (e *CannotGetTagsForNonSeriesDataSource) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT DataSource:CannotGetTagsForNonSeriesDataSource (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CannotGetTagsForNonSeriesDataSource) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CannotGetTagsForNonSeriesDataSource) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CannotGetTagsForNonSeriesDataSource) Message() string {
	return "INVALID_ARGUMENT DataSource:CannotGetTagsForNonSeriesDataSource"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CannotGetTagsForNonSeriesDataSource) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CannotGetTagsForNonSeriesDataSource) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CannotGetTagsForNonSeriesDataSource) Name() string {
	return "DataSource:CannotGetTagsForNonSeriesDataSource"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CannotGetTagsForNonSeriesDataSource) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CannotGetTagsForNonSeriesDataSource) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CannotGetTagsForNonSeriesDataSource) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotGetTagsForNonSeriesDataSource) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CannotGetTagsForNonSeriesDataSource) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CannotGetTagsForNonSeriesDataSource) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CannotGetTagsForNonSeriesDataSource) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.cannotGetTagsForNonSeriesDataSource)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "DataSource:CannotGetTagsForNonSeriesDataSource", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CannotGetTagsForNonSeriesDataSource) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters cannotGetTagsForNonSeriesDataSource
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.cannotGetTagsForNonSeriesDataSource = parameters
	return nil
}

type dataSourceNotFound struct {
	DataSourceRid rids.DataSourceRid `json:"dataSourceRid"`
}

func (o dataSourceNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *dataSourceNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDataSourceNotFound returns new instance of DataSourceNotFound error.
func NewDataSourceNotFound(dataSourceRidArg rids.DataSourceRid) *DataSourceNotFound {
	return &DataSourceNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), dataSourceNotFound: dataSourceNotFound{DataSourceRid: dataSourceRidArg}}
}

// WrapWithDataSourceNotFound returns new instance of DataSourceNotFound error wrapping an existing error.
func WrapWithDataSourceNotFound(err error, dataSourceRidArg rids.DataSourceRid) *DataSourceNotFound {
	return &DataSourceNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, dataSourceNotFound: dataSourceNotFound{DataSourceRid: dataSourceRidArg}}
}

// DataSourceNotFound is an error type.
type DataSourceNotFound struct {
	errorInstanceID uuid.UUID
	dataSourceNotFound
	cause error
	stack werror.StackTrace
}

// IsDataSourceNotFound returns true if err is an instance of DataSourceNotFound.
func IsDataSourceNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DataSourceNotFound)
	return ok
}

func (e *DataSourceNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND DataSource:DataSourceNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DataSourceNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DataSourceNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DataSourceNotFound) Message() string {
	return "NOT_FOUND DataSource:DataSourceNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DataSourceNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DataSourceNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *DataSourceNotFound) Name() string {
	return "DataSource:DataSourceNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DataSourceNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DataSourceNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DataSourceNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DataSourceNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DataSourceNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DataSourceNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DataSourceNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.dataSourceNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "DataSource:DataSourceNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DataSourceNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters dataSourceNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.dataSourceNotFound = parameters
	return nil
}

type dataSourcesNotFound struct {
	DataSourceRids []rids.DataSourceRid `json:"dataSourceRids"`
}

func (o dataSourcesNotFound) MarshalJSON() ([]byte, error) {
	if o.DataSourceRids == nil {
		o.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	type _tmpdataSourcesNotFound dataSourcesNotFound
	return safejson.Marshal(_tmpdataSourcesNotFound(o))
}

func (o *dataSourcesNotFound) UnmarshalJSON(data []byte) error {
	type _tmpdataSourcesNotFound dataSourcesNotFound
	var rawdataSourcesNotFound _tmpdataSourcesNotFound
	if err := safejson.Unmarshal(data, &rawdataSourcesNotFound); err != nil {
		return err
	}
	if rawdataSourcesNotFound.DataSourceRids == nil {
		rawdataSourcesNotFound.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	*o = dataSourcesNotFound(rawdataSourcesNotFound)
	return nil
}

func (o dataSourcesNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *dataSourcesNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDataSourcesNotFound returns new instance of DataSourcesNotFound error.
func NewDataSourcesNotFound(dataSourceRidsArg []rids.DataSourceRid) *DataSourcesNotFound {
	return &DataSourcesNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), dataSourcesNotFound: dataSourcesNotFound{DataSourceRids: dataSourceRidsArg}}
}

// WrapWithDataSourcesNotFound returns new instance of DataSourcesNotFound error wrapping an existing error.
func WrapWithDataSourcesNotFound(err error, dataSourceRidsArg []rids.DataSourceRid) *DataSourcesNotFound {
	return &DataSourcesNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, dataSourcesNotFound: dataSourcesNotFound{DataSourceRids: dataSourceRidsArg}}
}

// DataSourcesNotFound is an error type.
type DataSourcesNotFound struct {
	errorInstanceID uuid.UUID
	dataSourcesNotFound
	cause error
	stack werror.StackTrace
}

// IsDataSourcesNotFound returns true if err is an instance of DataSourcesNotFound.
func IsDataSourcesNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DataSourcesNotFound)
	return ok
}

func (e *DataSourcesNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND DataSource:DataSourcesNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DataSourcesNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DataSourcesNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DataSourcesNotFound) Message() string {
	return "NOT_FOUND DataSource:DataSourcesNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DataSourcesNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DataSourcesNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *DataSourcesNotFound) Name() string {
	return "DataSource:DataSourcesNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DataSourcesNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DataSourcesNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DataSourcesNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DataSourcesNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DataSourcesNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DataSourcesNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DataSourcesNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.dataSourcesNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "DataSource:DataSourcesNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DataSourcesNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters dataSourcesNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.dataSourcesNotFound = parameters
	return nil
}

type failedToGetTagsForDataSource struct {
	DataSourceRid rids.DataSourceRid `json:"dataSourceRid"`
	Message       string             `json:"message"`
}

func (o failedToGetTagsForDataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *failedToGetTagsForDataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewFailedToGetTagsForDataSource returns new instance of FailedToGetTagsForDataSource error.
func NewFailedToGetTagsForDataSource(dataSourceRidArg rids.DataSourceRid, messageArg string) *FailedToGetTagsForDataSource {
	return &FailedToGetTagsForDataSource{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), failedToGetTagsForDataSource: failedToGetTagsForDataSource{DataSourceRid: dataSourceRidArg, Message: messageArg}}
}

// WrapWithFailedToGetTagsForDataSource returns new instance of FailedToGetTagsForDataSource error wrapping an existing error.
func WrapWithFailedToGetTagsForDataSource(err error, dataSourceRidArg rids.DataSourceRid, messageArg string) *FailedToGetTagsForDataSource {
	return &FailedToGetTagsForDataSource{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, failedToGetTagsForDataSource: failedToGetTagsForDataSource{DataSourceRid: dataSourceRidArg, Message: messageArg}}
}

// FailedToGetTagsForDataSource is an error type.
// Attempted to get tags for an external data source with a specified time range.
type FailedToGetTagsForDataSource struct {
	errorInstanceID uuid.UUID
	failedToGetTagsForDataSource
	cause error
	stack werror.StackTrace
}

// IsFailedToGetTagsForDataSource returns true if err is an instance of FailedToGetTagsForDataSource.
func IsFailedToGetTagsForDataSource(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*FailedToGetTagsForDataSource)
	return ok
}

func (e *FailedToGetTagsForDataSource) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT DataSource:FailedToGetTagsForDataSource (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *FailedToGetTagsForDataSource) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *FailedToGetTagsForDataSource) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *FailedToGetTagsForDataSource) Message() string {
	return "INVALID_ARGUMENT DataSource:FailedToGetTagsForDataSource"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *FailedToGetTagsForDataSource) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *FailedToGetTagsForDataSource) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *FailedToGetTagsForDataSource) Name() string {
	return "DataSource:FailedToGetTagsForDataSource"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *FailedToGetTagsForDataSource) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *FailedToGetTagsForDataSource) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid, "message": e.Message}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *FailedToGetTagsForDataSource) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid, "message": e.Message, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *FailedToGetTagsForDataSource) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *FailedToGetTagsForDataSource) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *FailedToGetTagsForDataSource) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e FailedToGetTagsForDataSource) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.failedToGetTagsForDataSource)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "DataSource:FailedToGetTagsForDataSource", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *FailedToGetTagsForDataSource) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters failedToGetTagsForDataSource
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.failedToGetTagsForDataSource = parameters
	return nil
}

type missingTagFilters struct {
	DataSourceRid rids.DataSourceRid `json:"dataSourceRid"`
}

func (o missingTagFilters) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *missingTagFilters) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMissingTagFilters returns new instance of MissingTagFilters error.
func NewMissingTagFilters(dataSourceRidArg rids.DataSourceRid) *MissingTagFilters {
	return &MissingTagFilters{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), missingTagFilters: missingTagFilters{DataSourceRid: dataSourceRidArg}}
}

// WrapWithMissingTagFilters returns new instance of MissingTagFilters error wrapping an existing error.
func WrapWithMissingTagFilters(err error, dataSourceRidArg rids.DataSourceRid) *MissingTagFilters {
	return &MissingTagFilters{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, missingTagFilters: missingTagFilters{DataSourceRid: dataSourceRidArg}}
}

// MissingTagFilters is an error type.
type MissingTagFilters struct {
	errorInstanceID uuid.UUID
	missingTagFilters
	cause error
	stack werror.StackTrace
}

// IsMissingTagFilters returns true if err is an instance of MissingTagFilters.
func IsMissingTagFilters(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MissingTagFilters)
	return ok
}

func (e *MissingTagFilters) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT DataSource:MissingTagFilters (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MissingTagFilters) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MissingTagFilters) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MissingTagFilters) Message() string {
	return "INVALID_ARGUMENT DataSource:MissingTagFilters"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MissingTagFilters) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MissingTagFilters) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MissingTagFilters) Name() string {
	return "DataSource:MissingTagFilters"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MissingTagFilters) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MissingTagFilters) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MissingTagFilters) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingTagFilters) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MissingTagFilters) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingTagFilters) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MissingTagFilters) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.missingTagFilters)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "DataSource:MissingTagFilters", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MissingTagFilters) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters missingTagFilters
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.missingTagFilters = parameters
	return nil
}

type noPrefixTreeForDataSources struct {
	DataSourceRids []rids.DataSourceRid `json:"dataSourceRids"`
}

func (o noPrefixTreeForDataSources) MarshalJSON() ([]byte, error) {
	if o.DataSourceRids == nil {
		o.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	type _tmpnoPrefixTreeForDataSources noPrefixTreeForDataSources
	return safejson.Marshal(_tmpnoPrefixTreeForDataSources(o))
}

func (o *noPrefixTreeForDataSources) UnmarshalJSON(data []byte) error {
	type _tmpnoPrefixTreeForDataSources noPrefixTreeForDataSources
	var rawnoPrefixTreeForDataSources _tmpnoPrefixTreeForDataSources
	if err := safejson.Unmarshal(data, &rawnoPrefixTreeForDataSources); err != nil {
		return err
	}
	if rawnoPrefixTreeForDataSources.DataSourceRids == nil {
		rawnoPrefixTreeForDataSources.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	*o = noPrefixTreeForDataSources(rawnoPrefixTreeForDataSources)
	return nil
}

func (o noPrefixTreeForDataSources) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *noPrefixTreeForDataSources) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNoPrefixTreeForDataSources returns new instance of NoPrefixTreeForDataSources error.
func NewNoPrefixTreeForDataSources(dataSourceRidsArg []rids.DataSourceRid) *NoPrefixTreeForDataSources {
	return &NoPrefixTreeForDataSources{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), noPrefixTreeForDataSources: noPrefixTreeForDataSources{DataSourceRids: dataSourceRidsArg}}
}

// WrapWithNoPrefixTreeForDataSources returns new instance of NoPrefixTreeForDataSources error wrapping an existing error.
func WrapWithNoPrefixTreeForDataSources(err error, dataSourceRidsArg []rids.DataSourceRid) *NoPrefixTreeForDataSources {
	return &NoPrefixTreeForDataSources{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, noPrefixTreeForDataSources: noPrefixTreeForDataSources{DataSourceRids: dataSourceRidsArg}}
}

// NoPrefixTreeForDataSources is an error type.
type NoPrefixTreeForDataSources struct {
	errorInstanceID uuid.UUID
	noPrefixTreeForDataSources
	cause error
	stack werror.StackTrace
}

// IsNoPrefixTreeForDataSources returns true if err is an instance of NoPrefixTreeForDataSources.
func IsNoPrefixTreeForDataSources(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NoPrefixTreeForDataSources)
	return ok
}

func (e *NoPrefixTreeForDataSources) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT DataSource:NoPrefixTreeForDataSources (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NoPrefixTreeForDataSources) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NoPrefixTreeForDataSources) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NoPrefixTreeForDataSources) Message() string {
	return "INVALID_ARGUMENT DataSource:NoPrefixTreeForDataSources"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NoPrefixTreeForDataSources) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NoPrefixTreeForDataSources) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *NoPrefixTreeForDataSources) Name() string {
	return "DataSource:NoPrefixTreeForDataSources"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NoPrefixTreeForDataSources) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NoPrefixTreeForDataSources) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NoPrefixTreeForDataSources) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NoPrefixTreeForDataSources) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NoPrefixTreeForDataSources) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NoPrefixTreeForDataSources) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NoPrefixTreeForDataSources) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.noPrefixTreeForDataSources)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "DataSource:NoPrefixTreeForDataSources", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NoPrefixTreeForDataSources) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters noPrefixTreeForDataSources
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.noPrefixTreeForDataSources = parameters
	return nil
}

type prefixTreeTooLarge struct {
	NumNodes int `json:"numNodes"`
	MaxNodes int `json:"maxNodes"`
}

func (o prefixTreeTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *prefixTreeTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewPrefixTreeTooLarge returns new instance of PrefixTreeTooLarge error.
func NewPrefixTreeTooLarge(numNodesArg int, maxNodesArg int) *PrefixTreeTooLarge {
	return &PrefixTreeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), prefixTreeTooLarge: prefixTreeTooLarge{NumNodes: numNodesArg, MaxNodes: maxNodesArg}}
}

// WrapWithPrefixTreeTooLarge returns new instance of PrefixTreeTooLarge error wrapping an existing error.
func WrapWithPrefixTreeTooLarge(err error, numNodesArg int, maxNodesArg int) *PrefixTreeTooLarge {
	return &PrefixTreeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, prefixTreeTooLarge: prefixTreeTooLarge{NumNodes: numNodesArg, MaxNodes: maxNodesArg}}
}

// PrefixTreeTooLarge is an error type.
type PrefixTreeTooLarge struct {
	errorInstanceID uuid.UUID
	prefixTreeTooLarge
	cause error
	stack werror.StackTrace
}

// IsPrefixTreeTooLarge returns true if err is an instance of PrefixTreeTooLarge.
func IsPrefixTreeTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*PrefixTreeTooLarge)
	return ok
}

func (e *PrefixTreeTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT DataSource:PrefixTreeTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *PrefixTreeTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *PrefixTreeTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *PrefixTreeTooLarge) Message() string {
	return "INVALID_ARGUMENT DataSource:PrefixTreeTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *PrefixTreeTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *PrefixTreeTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *PrefixTreeTooLarge) Name() string {
	return "DataSource:PrefixTreeTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *PrefixTreeTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *PrefixTreeTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{"numNodes": e.NumNodes, "maxNodes": e.MaxNodes}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *PrefixTreeTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"numNodes": e.NumNodes, "maxNodes": e.MaxNodes, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *PrefixTreeTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *PrefixTreeTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *PrefixTreeTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e PrefixTreeTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.prefixTreeTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "DataSource:PrefixTreeTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *PrefixTreeTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters prefixTreeTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.prefixTreeTooLarge = parameters
	return nil
}

type requestedPageOffsetTooLarge struct {
	Offset int `json:"offset"`
}

func (o requestedPageOffsetTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *requestedPageOffsetTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewRequestedPageOffsetTooLarge returns new instance of RequestedPageOffsetTooLarge error.
func NewRequestedPageOffsetTooLarge(offsetArg int) *RequestedPageOffsetTooLarge {
	return &RequestedPageOffsetTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), requestedPageOffsetTooLarge: requestedPageOffsetTooLarge{Offset: offsetArg}}
}

// WrapWithRequestedPageOffsetTooLarge returns new instance of RequestedPageOffsetTooLarge error wrapping an existing error.
func WrapWithRequestedPageOffsetTooLarge(err error, offsetArg int) *RequestedPageOffsetTooLarge {
	return &RequestedPageOffsetTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, requestedPageOffsetTooLarge: requestedPageOffsetTooLarge{Offset: offsetArg}}
}

// RequestedPageOffsetTooLarge is an error type.
type RequestedPageOffsetTooLarge struct {
	errorInstanceID uuid.UUID
	requestedPageOffsetTooLarge
	cause error
	stack werror.StackTrace
}

// IsRequestedPageOffsetTooLarge returns true if err is an instance of RequestedPageOffsetTooLarge.
func IsRequestedPageOffsetTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*RequestedPageOffsetTooLarge)
	return ok
}

func (e *RequestedPageOffsetTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT DataSource:RequestedPageOffsetTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *RequestedPageOffsetTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *RequestedPageOffsetTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *RequestedPageOffsetTooLarge) Message() string {
	return "INVALID_ARGUMENT DataSource:RequestedPageOffsetTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *RequestedPageOffsetTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *RequestedPageOffsetTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *RequestedPageOffsetTooLarge) Name() string {
	return "DataSource:RequestedPageOffsetTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *RequestedPageOffsetTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *RequestedPageOffsetTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{"offset": e.Offset}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *RequestedPageOffsetTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"offset": e.Offset, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *RequestedPageOffsetTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *RequestedPageOffsetTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *RequestedPageOffsetTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e RequestedPageOffsetTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.requestedPageOffsetTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "DataSource:RequestedPageOffsetTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *RequestedPageOffsetTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters requestedPageOffsetTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.requestedPageOffsetTooLarge = parameters
	return nil
}

type requestedPageSizeTooLarge struct {
	MaxPageSize int `json:"maxPageSize"`
}

func (o requestedPageSizeTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *requestedPageSizeTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewRequestedPageSizeTooLarge returns new instance of RequestedPageSizeTooLarge error.
func NewRequestedPageSizeTooLarge(maxPageSizeArg int) *RequestedPageSizeTooLarge {
	return &RequestedPageSizeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), requestedPageSizeTooLarge: requestedPageSizeTooLarge{MaxPageSize: maxPageSizeArg}}
}

// WrapWithRequestedPageSizeTooLarge returns new instance of RequestedPageSizeTooLarge error wrapping an existing error.
func WrapWithRequestedPageSizeTooLarge(err error, maxPageSizeArg int) *RequestedPageSizeTooLarge {
	return &RequestedPageSizeTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, requestedPageSizeTooLarge: requestedPageSizeTooLarge{MaxPageSize: maxPageSizeArg}}
}

// RequestedPageSizeTooLarge is an error type.
type RequestedPageSizeTooLarge struct {
	errorInstanceID uuid.UUID
	requestedPageSizeTooLarge
	cause error
	stack werror.StackTrace
}

// IsRequestedPageSizeTooLarge returns true if err is an instance of RequestedPageSizeTooLarge.
func IsRequestedPageSizeTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*RequestedPageSizeTooLarge)
	return ok
}

func (e *RequestedPageSizeTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT DataSource:RequestedPageSizeTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *RequestedPageSizeTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *RequestedPageSizeTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *RequestedPageSizeTooLarge) Message() string {
	return "INVALID_ARGUMENT DataSource:RequestedPageSizeTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *RequestedPageSizeTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *RequestedPageSizeTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *RequestedPageSizeTooLarge) Name() string {
	return "DataSource:RequestedPageSizeTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *RequestedPageSizeTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *RequestedPageSizeTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{"maxPageSize": e.MaxPageSize}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *RequestedPageSizeTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"maxPageSize": e.MaxPageSize, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *RequestedPageSizeTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *RequestedPageSizeTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *RequestedPageSizeTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e RequestedPageSizeTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.requestedPageSizeTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "DataSource:RequestedPageSizeTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *RequestedPageSizeTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters requestedPageSizeTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.requestedPageSizeTooLarge = parameters
	return nil
}

type tooManyTagKeysRequested struct {
	MaxTagKeys int `json:"maxTagKeys"`
}

func (o tooManyTagKeysRequested) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *tooManyTagKeysRequested) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewTooManyTagKeysRequested returns new instance of TooManyTagKeysRequested error.
func NewTooManyTagKeysRequested(maxTagKeysArg int) *TooManyTagKeysRequested {
	return &TooManyTagKeysRequested{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), tooManyTagKeysRequested: tooManyTagKeysRequested{MaxTagKeys: maxTagKeysArg}}
}

// WrapWithTooManyTagKeysRequested returns new instance of TooManyTagKeysRequested error wrapping an existing error.
func WrapWithTooManyTagKeysRequested(err error, maxTagKeysArg int) *TooManyTagKeysRequested {
	return &TooManyTagKeysRequested{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, tooManyTagKeysRequested: tooManyTagKeysRequested{MaxTagKeys: maxTagKeysArg}}
}

// TooManyTagKeysRequested is an error type.
type TooManyTagKeysRequested struct {
	errorInstanceID uuid.UUID
	tooManyTagKeysRequested
	cause error
	stack werror.StackTrace
}

// IsTooManyTagKeysRequested returns true if err is an instance of TooManyTagKeysRequested.
func IsTooManyTagKeysRequested(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*TooManyTagKeysRequested)
	return ok
}

func (e *TooManyTagKeysRequested) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT DataSource:TooManyTagKeysRequested (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *TooManyTagKeysRequested) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *TooManyTagKeysRequested) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *TooManyTagKeysRequested) Message() string {
	return "INVALID_ARGUMENT DataSource:TooManyTagKeysRequested"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *TooManyTagKeysRequested) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *TooManyTagKeysRequested) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *TooManyTagKeysRequested) Name() string {
	return "DataSource:TooManyTagKeysRequested"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *TooManyTagKeysRequested) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *TooManyTagKeysRequested) Parameters() map[string]interface{} {
	return map[string]interface{}{"maxTagKeys": e.MaxTagKeys}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *TooManyTagKeysRequested) safeParams() map[string]interface{} {
	return map[string]interface{}{"maxTagKeys": e.MaxTagKeys, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyTagKeysRequested) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *TooManyTagKeysRequested) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *TooManyTagKeysRequested) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e TooManyTagKeysRequested) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.tooManyTagKeysRequested)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "DataSource:TooManyTagKeysRequested", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *TooManyTagKeysRequested) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters tooManyTagKeysRequested
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.tooManyTagKeysRequested = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("DataSource:CannotGetTagsForNonSeriesDataSource", reflect.TypeOf(CannotGetTagsForNonSeriesDataSource{}))
	conjureerrors.RegisterErrorType("DataSource:DataSourceNotFound", reflect.TypeOf(DataSourceNotFound{}))
	conjureerrors.RegisterErrorType("DataSource:DataSourcesNotFound", reflect.TypeOf(DataSourcesNotFound{}))
	conjureerrors.RegisterErrorType("DataSource:FailedToGetTagsForDataSource", reflect.TypeOf(FailedToGetTagsForDataSource{}))
	conjureerrors.RegisterErrorType("DataSource:MissingTagFilters", reflect.TypeOf(MissingTagFilters{}))
	conjureerrors.RegisterErrorType("DataSource:NoPrefixTreeForDataSources", reflect.TypeOf(NoPrefixTreeForDataSources{}))
	conjureerrors.RegisterErrorType("DataSource:PrefixTreeTooLarge", reflect.TypeOf(PrefixTreeTooLarge{}))
	conjureerrors.RegisterErrorType("DataSource:RequestedPageOffsetTooLarge", reflect.TypeOf(RequestedPageOffsetTooLarge{}))
	conjureerrors.RegisterErrorType("DataSource:RequestedPageSizeTooLarge", reflect.TypeOf(RequestedPageSizeTooLarge{}))
	conjureerrors.RegisterErrorType("DataSource:TooManyTagKeysRequested", reflect.TypeOf(TooManyTagKeysRequested{}))
}
