// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/io/nominal/datasource"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
)

type AttachLogsAndFinalizeRequest struct {
	Logs []Log `json:"logs"`
}

func (o AttachLogsAndFinalizeRequest) MarshalJSON() ([]byte, error) {
	if o.Logs == nil {
		o.Logs = make([]Log, 0)
	}
	type _tmpAttachLogsAndFinalizeRequest AttachLogsAndFinalizeRequest
	return safejson.Marshal(_tmpAttachLogsAndFinalizeRequest(o))
}

func (o *AttachLogsAndFinalizeRequest) UnmarshalJSON(data []byte) error {
	type _tmpAttachLogsAndFinalizeRequest AttachLogsAndFinalizeRequest
	var rawAttachLogsAndFinalizeRequest _tmpAttachLogsAndFinalizeRequest
	if err := safejson.Unmarshal(data, &rawAttachLogsAndFinalizeRequest); err != nil {
		return err
	}
	if rawAttachLogsAndFinalizeRequest.Logs == nil {
		rawAttachLogsAndFinalizeRequest.Logs = make([]Log, 0)
	}
	*o = AttachLogsAndFinalizeRequest(rawAttachLogsAndFinalizeRequest)
	return nil
}

func (o AttachLogsAndFinalizeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AttachLogsAndFinalizeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// A largely unopinionated but very flexible format.
type BasicLogBody struct {
	Properties map[string]string `json:"properties"`
	Message    string            `json:"message"`
}

func (o BasicLogBody) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[string]string, 0)
	}
	type _tmpBasicLogBody BasicLogBody
	return safejson.Marshal(_tmpBasicLogBody(o))
}

func (o *BasicLogBody) UnmarshalJSON(data []byte) error {
	type _tmpBasicLogBody BasicLogBody
	var rawBasicLogBody _tmpBasicLogBody
	if err := safejson.Unmarshal(data, &rawBasicLogBody); err != nil {
		return err
	}
	if rawBasicLogBody.Properties == nil {
		rawBasicLogBody.Properties = make(map[string]string, 0)
	}
	*o = BasicLogBody(rawBasicLogBody)
	return nil
}

func (o BasicLogBody) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BasicLogBody) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateLogSetRequest struct {
	Name           string                   `json:"name"`
	Description    *string                  `json:"description,omitempty"`
	OriginMetadata map[string]string        `json:"originMetadata"`
	TimestampType  datasource.TimestampType `json:"timestampType"`
	/*
	   The workspace in which to create the logset. If not provided, the logset will be created in the default workspace for
	   the user's organization, if the default workspace for the organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the logset. If not provided, the logset will be created in the default workspace for\nthe user's organization, if the default workspace for the organization is configured." json:"workspace,omitempty"`
}

func (o CreateLogSetRequest) MarshalJSON() ([]byte, error) {
	if o.OriginMetadata == nil {
		o.OriginMetadata = make(map[string]string, 0)
	}
	type _tmpCreateLogSetRequest CreateLogSetRequest
	return safejson.Marshal(_tmpCreateLogSetRequest(o))
}

func (o *CreateLogSetRequest) UnmarshalJSON(data []byte) error {
	type _tmpCreateLogSetRequest CreateLogSetRequest
	var rawCreateLogSetRequest _tmpCreateLogSetRequest
	if err := safejson.Unmarshal(data, &rawCreateLogSetRequest); err != nil {
		return err
	}
	if rawCreateLogSetRequest.OriginMetadata == nil {
		rawCreateLogSetRequest.OriginMetadata = make(map[string]string, 0)
	}
	*o = CreateLogSetRequest(rawCreateLogSetRequest)
	return nil
}

func (o CreateLogSetRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateLogSetRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Log struct {
	Time api.Timestamp `json:"time"`
	Body LogBody       `json:"body"`
}

func (o Log) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Log) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogSetMetadata struct {
	Rid            LogSetRid                `json:"rid"`
	CreatedBy      rid.ResourceIdentifier   `json:"createdBy"`
	Name           string                   `json:"name"`
	Description    *string                  `json:"description,omitempty"`
	OriginMetadata map[string]string        `json:"originMetadata"`
	CreatedAt      datetime.DateTime        `json:"createdAt"`
	UpdatedAt      datetime.DateTime        `json:"updatedAt"`
	LogCount       safelong.SafeLong        `json:"logCount"`
	TimestampType  datasource.TimestampType `json:"timestampType"`
}

func (o LogSetMetadata) MarshalJSON() ([]byte, error) {
	if o.OriginMetadata == nil {
		o.OriginMetadata = make(map[string]string, 0)
	}
	type _tmpLogSetMetadata LogSetMetadata
	return safejson.Marshal(_tmpLogSetMetadata(o))
}

func (o *LogSetMetadata) UnmarshalJSON(data []byte) error {
	type _tmpLogSetMetadata LogSetMetadata
	var rawLogSetMetadata _tmpLogSetMetadata
	if err := safejson.Unmarshal(data, &rawLogSetMetadata); err != nil {
		return err
	}
	if rawLogSetMetadata.OriginMetadata == nil {
		rawLogSetMetadata.OriginMetadata = make(map[string]string, 0)
	}
	*o = LogSetMetadata(rawLogSetMetadata)
	return nil
}

func (o LogSetMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogSetMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type S3LogHandle struct {
	Path   string    `json:"path"`
	Format LogFormat `json:"format"`
}

func (o S3LogHandle) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *S3LogHandle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchLogSetsRequest struct {
	Token *api.Token `json:"token,omitempty"`
	// The maximum allowed page size is 1000. Defaults to the maximum if not supplied.
	PageSize *int `conjure-docs:"The maximum allowed page size is 1000. Defaults to the maximum if not supplied." json:"pageSize,omitempty"`
	/*
	   If supplied, will return only the log sets within the supplied workspaces. If empty
	   will return all connections for workspaces that the user is permitted to see.
	*/
	Workspaces []rids.WorkspaceRid `conjure-docs:"If supplied, will return only the log sets within the supplied workspaces. If empty\nwill return all connections for workspaces that the user is permitted to see." json:"workspaces"`
}

func (o SearchLogSetsRequest) MarshalJSON() ([]byte, error) {
	if o.Workspaces == nil {
		o.Workspaces = make([]rids.WorkspaceRid, 0)
	}
	type _tmpSearchLogSetsRequest SearchLogSetsRequest
	return safejson.Marshal(_tmpSearchLogSetsRequest(o))
}

func (o *SearchLogSetsRequest) UnmarshalJSON(data []byte) error {
	type _tmpSearchLogSetsRequest SearchLogSetsRequest
	var rawSearchLogSetsRequest _tmpSearchLogSetsRequest
	if err := safejson.Unmarshal(data, &rawSearchLogSetsRequest); err != nil {
		return err
	}
	if rawSearchLogSetsRequest.Workspaces == nil {
		rawSearchLogSetsRequest.Workspaces = make([]rids.WorkspaceRid, 0)
	}
	*o = SearchLogSetsRequest(rawSearchLogSetsRequest)
	return nil
}

func (o SearchLogSetsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchLogSetsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchLogSetsResponse struct {
	Values        []LogSetMetadata `json:"values"`
	NextPageToken *api.Token       `json:"nextPageToken,omitempty"`
}

func (o SearchLogSetsResponse) MarshalJSON() ([]byte, error) {
	if o.Values == nil {
		o.Values = make([]LogSetMetadata, 0)
	}
	type _tmpSearchLogSetsResponse SearchLogSetsResponse
	return safejson.Marshal(_tmpSearchLogSetsResponse(o))
}

func (o *SearchLogSetsResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchLogSetsResponse SearchLogSetsResponse
	var rawSearchLogSetsResponse _tmpSearchLogSetsResponse
	if err := safejson.Unmarshal(data, &rawSearchLogSetsResponse); err != nil {
		return err
	}
	if rawSearchLogSetsResponse.Values == nil {
		rawSearchLogSetsResponse.Values = make([]LogSetMetadata, 0)
	}
	*o = SearchLogSetsResponse(rawSearchLogSetsResponse)
	return nil
}

func (o SearchLogSetsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchLogSetsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchLogsRequest struct {
	Token *api.Token `json:"token,omitempty"`
	// The maximum allowed page size is 10000. Defaults to the maximum if not supplied.
	PageSize *int `conjure-docs:"The maximum allowed page size is 10000. Defaults to the maximum if not supplied." json:"pageSize,omitempty"`
}

func (o SearchLogsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchLogsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchLogsResponse struct {
	Logs          []Log      `json:"logs"`
	NextPageToken *api.Token `json:"nextPageToken,omitempty"`
}

func (o SearchLogsResponse) MarshalJSON() ([]byte, error) {
	if o.Logs == nil {
		o.Logs = make([]Log, 0)
	}
	type _tmpSearchLogsResponse SearchLogsResponse
	return safejson.Marshal(_tmpSearchLogsResponse(o))
}

func (o *SearchLogsResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchLogsResponse SearchLogsResponse
	var rawSearchLogsResponse _tmpSearchLogsResponse
	if err := safejson.Unmarshal(data, &rawSearchLogsResponse); err != nil {
		return err
	}
	if rawSearchLogsResponse.Logs == nil {
		rawSearchLogsResponse.Logs = make([]Log, 0)
	}
	*o = SearchLogsResponse(rawSearchLogsResponse)
	return nil
}

func (o SearchLogsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchLogsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
