// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"
)

type LogBodyWithT[T any] LogBody

func (u *LogBodyWithT[T]) Accept(ctx context.Context, v LogBodyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "basic":
		if u.basic == nil {
			return result, fmt.Errorf("field \"basic\" is required")
		}
		return v.VisitBasic(ctx, *u.basic)
	}
}

func (u *LogBodyWithT[T]) AcceptFuncs(basicFunc func(BasicLogBody) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "basic":
		if u.basic == nil {
			return result, fmt.Errorf("field \"basic\" is required")
		}
		return basicFunc(*u.basic)
	}
}

func (u *LogBodyWithT[T]) BasicNoopSuccess(BasicLogBody) (T, error) {
	var result T
	return result, nil
}

func (u *LogBodyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LogBodyVisitorWithT[T any] interface {
	VisitBasic(ctx context.Context, v BasicLogBody) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type LogHandleWithT[T any] LogHandle

func (u *LogHandleWithT[T]) Accept(ctx context.Context, v LogHandleVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "s3":
		if u.s3 == nil {
			return result, fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3(ctx, *u.s3)
	}
}

func (u *LogHandleWithT[T]) AcceptFuncs(s3Func func(S3LogHandle) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "s3":
		if u.s3 == nil {
			return result, fmt.Errorf("field \"s3\" is required")
		}
		return s3Func(*u.s3)
	}
}

func (u *LogHandleWithT[T]) S3NoopSuccess(S3LogHandle) (T, error) {
	var result T
	return result, nil
}

func (u *LogHandleWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LogHandleVisitorWithT[T any] interface {
	VisitS3(ctx context.Context, v S3LogHandle) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
