// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type LogBody struct {
	typ   string
	basic *BasicLogBody
}

type logBodyDeserializer struct {
	Type  string        `json:"type"`
	Basic *BasicLogBody `json:"basic"`
}

func (u *logBodyDeserializer) toStruct() LogBody {
	return LogBody{typ: u.Type, basic: u.Basic}
}

func (u *LogBody) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "basic":
		if u.basic == nil {
			return nil, fmt.Errorf("field \"basic\" is required")
		}
		return struct {
			Type  string       `json:"type"`
			Basic BasicLogBody `json:"basic"`
		}{Type: "basic", Basic: *u.basic}, nil
	}
}

func (u LogBody) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LogBody) UnmarshalJSON(data []byte) error {
	var deser logBodyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "basic":
		if u.basic == nil {
			return fmt.Errorf("field \"basic\" is required")
		}
	}
	return nil
}

func (u LogBody) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LogBody) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LogBody) AcceptFuncs(basicFunc func(BasicLogBody) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "basic":
		if u.basic == nil {
			return fmt.Errorf("field \"basic\" is required")
		}
		return basicFunc(*u.basic)
	}
}

func (u *LogBody) BasicNoopSuccess(BasicLogBody) error {
	return nil
}

func (u *LogBody) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LogBody) Accept(v LogBodyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "basic":
		if u.basic == nil {
			return fmt.Errorf("field \"basic\" is required")
		}
		return v.VisitBasic(*u.basic)
	}
}

type LogBodyVisitor interface {
	VisitBasic(v BasicLogBody) error
	VisitUnknown(typeName string) error
}

func (u *LogBody) AcceptWithContext(ctx context.Context, v LogBodyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "basic":
		if u.basic == nil {
			return fmt.Errorf("field \"basic\" is required")
		}
		return v.VisitBasicWithContext(ctx, *u.basic)
	}
}

type LogBodyVisitorWithContext interface {
	VisitBasicWithContext(ctx context.Context, v BasicLogBody) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLogBodyFromBasic(v BasicLogBody) LogBody {
	return LogBody{typ: "basic", basic: &v}
}

type LogHandle struct {
	typ string
	s3  *S3LogHandle
}

type logHandleDeserializer struct {
	Type string       `json:"type"`
	S3   *S3LogHandle `json:"s3"`
}

func (u *logHandleDeserializer) toStruct() LogHandle {
	return LogHandle{typ: u.Type, s3: u.S3}
}

func (u *LogHandle) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "s3":
		if u.s3 == nil {
			return nil, fmt.Errorf("field \"s3\" is required")
		}
		return struct {
			Type string      `json:"type"`
			S3   S3LogHandle `json:"s3"`
		}{Type: "s3", S3: *u.s3}, nil
	}
}

func (u LogHandle) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LogHandle) UnmarshalJSON(data []byte) error {
	var deser logHandleDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
	}
	return nil
}

func (u LogHandle) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LogHandle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LogHandle) AcceptFuncs(s3Func func(S3LogHandle) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return s3Func(*u.s3)
	}
}

func (u *LogHandle) S3NoopSuccess(S3LogHandle) error {
	return nil
}

func (u *LogHandle) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LogHandle) Accept(v LogHandleVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3(*u.s3)
	}
}

type LogHandleVisitor interface {
	VisitS3(v S3LogHandle) error
	VisitUnknown(typeName string) error
}

func (u *LogHandle) AcceptWithContext(ctx context.Context, v LogHandleVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3WithContext(ctx, *u.s3)
	}
}

type LogHandleVisitorWithContext interface {
	VisitS3WithContext(ctx context.Context, v S3LogHandle) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLogHandleFromS3(v S3LogHandle) LogHandle {
	return LogHandle{typ: "s3", s3: &v}
}
