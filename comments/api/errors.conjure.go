// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type commentNotFound struct{}

func (o commentNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *commentNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCommentNotFound returns new instance of CommentNotFound error.
func NewCommentNotFound() *CommentNotFound {
	return &CommentNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), commentNotFound: commentNotFound{}}
}

// WrapWithCommentNotFound returns new instance of CommentNotFound error wrapping an existing error.
func WrapWithCommentNotFound(err error) *CommentNotFound {
	return &CommentNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, commentNotFound: commentNotFound{}}
}

// CommentNotFound is an error type.
type CommentNotFound struct {
	errorInstanceID uuid.UUID
	commentNotFound
	cause error
	stack werror.StackTrace
}

// IsCommentNotFound returns true if err is an instance of CommentNotFound.
func IsCommentNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CommentNotFound)
	return ok
}

func (e *CommentNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Comments:CommentNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CommentNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CommentNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CommentNotFound) Message() string {
	return "NOT_FOUND Comments:CommentNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CommentNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CommentNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *CommentNotFound) Name() string {
	return "Comments:CommentNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CommentNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CommentNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CommentNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CommentNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CommentNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CommentNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CommentNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.commentNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Comments:CommentNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CommentNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters commentNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.commentNotFound = parameters
	return nil
}

type contentTooLong struct{}

func (o contentTooLong) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *contentTooLong) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewContentTooLong returns new instance of ContentTooLong error.
func NewContentTooLong() *ContentTooLong {
	return &ContentTooLong{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), contentTooLong: contentTooLong{}}
}

// WrapWithContentTooLong returns new instance of ContentTooLong error wrapping an existing error.
func WrapWithContentTooLong(err error) *ContentTooLong {
	return &ContentTooLong{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, contentTooLong: contentTooLong{}}
}

// ContentTooLong is an error type.
type ContentTooLong struct {
	errorInstanceID uuid.UUID
	contentTooLong
	cause error
	stack werror.StackTrace
}

// IsContentTooLong returns true if err is an instance of ContentTooLong.
func IsContentTooLong(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ContentTooLong)
	return ok
}

func (e *ContentTooLong) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Comments:ContentTooLong (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ContentTooLong) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ContentTooLong) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ContentTooLong) Message() string {
	return "INVALID_ARGUMENT Comments:ContentTooLong"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ContentTooLong) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ContentTooLong) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ContentTooLong) Name() string {
	return "Comments:ContentTooLong"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ContentTooLong) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ContentTooLong) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ContentTooLong) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ContentTooLong) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ContentTooLong) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ContentTooLong) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ContentTooLong) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.contentTooLong)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Comments:ContentTooLong", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ContentTooLong) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters contentTooLong
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.contentTooLong = parameters
	return nil
}

type emptyCommentContent struct{}

func (o emptyCommentContent) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *emptyCommentContent) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewEmptyCommentContent returns new instance of EmptyCommentContent error.
func NewEmptyCommentContent() *EmptyCommentContent {
	return &EmptyCommentContent{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), emptyCommentContent: emptyCommentContent{}}
}

// WrapWithEmptyCommentContent returns new instance of EmptyCommentContent error wrapping an existing error.
func WrapWithEmptyCommentContent(err error) *EmptyCommentContent {
	return &EmptyCommentContent{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, emptyCommentContent: emptyCommentContent{}}
}

// EmptyCommentContent is an error type.
type EmptyCommentContent struct {
	errorInstanceID uuid.UUID
	emptyCommentContent
	cause error
	stack werror.StackTrace
}

// IsEmptyCommentContent returns true if err is an instance of EmptyCommentContent.
func IsEmptyCommentContent(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*EmptyCommentContent)
	return ok
}

func (e *EmptyCommentContent) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Comments:EmptyCommentContent (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *EmptyCommentContent) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *EmptyCommentContent) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *EmptyCommentContent) Message() string {
	return "INVALID_ARGUMENT Comments:EmptyCommentContent"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *EmptyCommentContent) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *EmptyCommentContent) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *EmptyCommentContent) Name() string {
	return "Comments:EmptyCommentContent"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *EmptyCommentContent) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *EmptyCommentContent) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *EmptyCommentContent) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *EmptyCommentContent) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *EmptyCommentContent) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *EmptyCommentContent) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e EmptyCommentContent) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.emptyCommentContent)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Comments:EmptyCommentContent", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *EmptyCommentContent) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters emptyCommentContent
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.emptyCommentContent = parameters
	return nil
}

type invalidAttachment struct{}

func (o invalidAttachment) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidAttachment) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidAttachment returns new instance of InvalidAttachment error.
func NewInvalidAttachment() *InvalidAttachment {
	return &InvalidAttachment{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidAttachment: invalidAttachment{}}
}

// WrapWithInvalidAttachment returns new instance of InvalidAttachment error wrapping an existing error.
func WrapWithInvalidAttachment(err error) *InvalidAttachment {
	return &InvalidAttachment{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidAttachment: invalidAttachment{}}
}

// InvalidAttachment is an error type.
type InvalidAttachment struct {
	errorInstanceID uuid.UUID
	invalidAttachment
	cause error
	stack werror.StackTrace
}

// IsInvalidAttachment returns true if err is an instance of InvalidAttachment.
func IsInvalidAttachment(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidAttachment)
	return ok
}

func (e *InvalidAttachment) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Comments:InvalidAttachment (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidAttachment) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidAttachment) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidAttachment) Message() string {
	return "INVALID_ARGUMENT Comments:InvalidAttachment"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidAttachment) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidAttachment) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidAttachment) Name() string {
	return "Comments:InvalidAttachment"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidAttachment) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidAttachment) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidAttachment) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidAttachment) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidAttachment) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidAttachment) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidAttachment) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidAttachment)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Comments:InvalidAttachment", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidAttachment) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidAttachment
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidAttachment = parameters
	return nil
}

type maxNestingDepthExceeded struct{}

func (o maxNestingDepthExceeded) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *maxNestingDepthExceeded) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMaxNestingDepthExceeded returns new instance of MaxNestingDepthExceeded error.
func NewMaxNestingDepthExceeded() *MaxNestingDepthExceeded {
	return &MaxNestingDepthExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), maxNestingDepthExceeded: maxNestingDepthExceeded{}}
}

// WrapWithMaxNestingDepthExceeded returns new instance of MaxNestingDepthExceeded error wrapping an existing error.
func WrapWithMaxNestingDepthExceeded(err error) *MaxNestingDepthExceeded {
	return &MaxNestingDepthExceeded{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, maxNestingDepthExceeded: maxNestingDepthExceeded{}}
}

// MaxNestingDepthExceeded is an error type.
type MaxNestingDepthExceeded struct {
	errorInstanceID uuid.UUID
	maxNestingDepthExceeded
	cause error
	stack werror.StackTrace
}

// IsMaxNestingDepthExceeded returns true if err is an instance of MaxNestingDepthExceeded.
func IsMaxNestingDepthExceeded(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MaxNestingDepthExceeded)
	return ok
}

func (e *MaxNestingDepthExceeded) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Comments:MaxNestingDepthExceeded (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MaxNestingDepthExceeded) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MaxNestingDepthExceeded) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MaxNestingDepthExceeded) Message() string {
	return "INVALID_ARGUMENT Comments:MaxNestingDepthExceeded"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MaxNestingDepthExceeded) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MaxNestingDepthExceeded) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MaxNestingDepthExceeded) Name() string {
	return "Comments:MaxNestingDepthExceeded"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MaxNestingDepthExceeded) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MaxNestingDepthExceeded) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MaxNestingDepthExceeded) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MaxNestingDepthExceeded) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MaxNestingDepthExceeded) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MaxNestingDepthExceeded) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MaxNestingDepthExceeded) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.maxNestingDepthExceeded)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Comments:MaxNestingDepthExceeded", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MaxNestingDepthExceeded) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters maxNestingDepthExceeded
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.maxNestingDepthExceeded = parameters
	return nil
}

type unauthorized struct{}

func (o unauthorized) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *unauthorized) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUnauthorized returns new instance of Unauthorized error.
func NewUnauthorized() *Unauthorized {
	return &Unauthorized{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), unauthorized: unauthorized{}}
}

// WrapWithUnauthorized returns new instance of Unauthorized error wrapping an existing error.
func WrapWithUnauthorized(err error) *Unauthorized {
	return &Unauthorized{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, unauthorized: unauthorized{}}
}

// Unauthorized is an error type.
type Unauthorized struct {
	errorInstanceID uuid.UUID
	unauthorized
	cause error
	stack werror.StackTrace
}

// IsUnauthorized returns true if err is an instance of Unauthorized.
func IsUnauthorized(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*Unauthorized)
	return ok
}

func (e *Unauthorized) Error() string {
	return fmt.Sprintf("PERMISSION_DENIED Comments:Unauthorized (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *Unauthorized) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *Unauthorized) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *Unauthorized) Message() string {
	return "PERMISSION_DENIED Comments:Unauthorized"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *Unauthorized) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *Unauthorized) Code() errors.ErrorCode {
	return errors.PermissionDenied
}

// Name returns an error name identifying error type.
func (e *Unauthorized) Name() string {
	return "Comments:Unauthorized"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *Unauthorized) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *Unauthorized) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *Unauthorized) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *Unauthorized) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *Unauthorized) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *Unauthorized) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e Unauthorized) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.unauthorized)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.PermissionDenied, ErrorName: "Comments:Unauthorized", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *Unauthorized) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters unauthorized
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.unauthorized = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Comments:CommentNotFound", reflect.TypeOf(CommentNotFound{}))
	conjureerrors.RegisterErrorType("Comments:ContentTooLong", reflect.TypeOf(ContentTooLong{}))
	conjureerrors.RegisterErrorType("Comments:EmptyCommentContent", reflect.TypeOf(EmptyCommentContent{}))
	conjureerrors.RegisterErrorType("Comments:InvalidAttachment", reflect.TypeOf(InvalidAttachment{}))
	conjureerrors.RegisterErrorType("Comments:MaxNestingDepthExceeded", reflect.TypeOf(MaxNestingDepthExceeded{}))
	conjureerrors.RegisterErrorType("Comments:Unauthorized", reflect.TypeOf(Unauthorized{}))
}
