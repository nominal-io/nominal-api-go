// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type Comment struct {
	// Unique resource identifier for the comment
	Rid CommentRid `conjure-docs:"Unique resource identifier for the comment" json:"rid"`
	// The parent of the comment. It can be a resource or another comment.
	Parent CommentParent `conjure-docs:"The parent of the comment. It can be a resource or another comment." json:"parent"`
	// The user who authored the comment
	AuthorRid rid.ResourceIdentifier `conjure-docs:"The user who authored the comment" json:"authorRid"`
	// The time the comment was created
	CreatedAt datetime.DateTime `conjure-docs:"The time the comment was created" json:"createdAt"`
	// The time the comment was edited. Empty if the comment has not been edited.
	EditedAt *datetime.DateTime `conjure-docs:"The time the comment was edited. Empty if the comment has not been edited." json:"editedAt,omitempty"`
	// The time the comment was deleted. Empty if the comment has not been deleted.
	DeletedAt *datetime.DateTime `conjure-docs:"The time the comment was deleted. Empty if the comment has not been deleted." json:"deletedAt,omitempty"`
	// The markdown content of the comment.
	Content string `conjure-docs:"The markdown content of the comment." json:"content"`
	// The user who pinned the comment. Empty if the comment is not pinned.
	PinnedBy *rid.ResourceIdentifier `conjure-docs:"The user who pinned the comment. Empty if the comment is not pinned." json:"pinnedBy,omitempty"`
	// The time the comment was pinned. Empty if the comment is not pinned.
	PinnedAt *datetime.DateTime `conjure-docs:"The time the comment was pinned. Empty if the comment is not pinned." json:"pinnedAt,omitempty"`
	// The reactions on the comment
	Reactions []Reaction `conjure-docs:"The reactions on the comment" json:"reactions"`
	// The comment's attachments
	Attachments []rids.AttachmentRid `conjure-docs:"The comment's attachments" json:"attachments"`
}

func (o Comment) MarshalJSON() ([]byte, error) {
	if o.Reactions == nil {
		o.Reactions = make([]Reaction, 0)
	}
	if o.Attachments == nil {
		o.Attachments = make([]rids.AttachmentRid, 0)
	}
	type _tmpComment Comment
	return safejson.Marshal(_tmpComment(o))
}

func (o *Comment) UnmarshalJSON(data []byte) error {
	type _tmpComment Comment
	var rawComment _tmpComment
	if err := safejson.Unmarshal(data, &rawComment); err != nil {
		return err
	}
	if rawComment.Reactions == nil {
		rawComment.Reactions = make([]Reaction, 0)
	}
	if rawComment.Attachments == nil {
		rawComment.Attachments = make([]rids.AttachmentRid, 0)
	}
	*o = Comment(rawComment)
	return nil
}

func (o Comment) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Comment) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CommentParentComment struct {
	// The resource identifier for the comment that the comment is replying to
	CommentRid CommentRid `conjure-docs:"The resource identifier for the comment that the comment is replying to" json:"commentRid"`
}

func (o CommentParentComment) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CommentParentComment) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CommentParentResource struct {
	// The type of resource that the comment is associated with
	ResourceType ResourceType `conjure-docs:"The type of resource that the comment is associated with" json:"resourceType"`
	// The resource identifier for the resource that the comment is associated with. For example, a run or a workbook.
	ResourceRid rid.ResourceIdentifier `conjure-docs:"The resource identifier for the resource that the comment is associated with. For example, a run or a workbook." json:"resourceRid"`
}

func (o CommentParentResource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CommentParentResource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Conversation struct {
	// RID for the resource that the conversation is associated with.
	ResourceRid rid.ResourceIdentifier `conjure-docs:"RID for the resource that the conversation is associated with." json:"resourceRid"`
	// The type of the resource that the conversation is associated with.
	ResourceType ResourceType `conjure-docs:"The type of the resource that the conversation is associated with." json:"resourceType"`
	/*
	   The comments on the conversation ordered by creation time.
	   Empty if the comment has no replies.
	*/
	Comments []ConversationNode `conjure-docs:"The comments on the conversation ordered by creation time.\nEmpty if the comment has no replies." json:"comments"`
}

func (o Conversation) MarshalJSON() ([]byte, error) {
	if o.Comments == nil {
		o.Comments = make([]ConversationNode, 0)
	}
	type _tmpConversation Conversation
	return safejson.Marshal(_tmpConversation(o))
}

func (o *Conversation) UnmarshalJSON(data []byte) error {
	type _tmpConversation Conversation
	var rawConversation _tmpConversation
	if err := safejson.Unmarshal(data, &rawConversation); err != nil {
		return err
	}
	if rawConversation.Comments == nil {
		rawConversation.Comments = make([]ConversationNode, 0)
	}
	*o = Conversation(rawConversation)
	return nil
}

func (o Conversation) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Conversation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ConversationNode struct {
	// The comment
	Comment Comment `conjure-docs:"The comment" json:"comment"`
	// The comments on (aka replies to) the comment ordered by creation time. Empty if the comment has no replies.
	Replies []ConversationNode `conjure-docs:"The comments on (aka replies to) the comment ordered by creation time. Empty if the comment has no replies." json:"replies"`
}

func (o ConversationNode) MarshalJSON() ([]byte, error) {
	if o.Replies == nil {
		o.Replies = make([]ConversationNode, 0)
	}
	type _tmpConversationNode ConversationNode
	return safejson.Marshal(_tmpConversationNode(o))
}

func (o *ConversationNode) UnmarshalJSON(data []byte) error {
	type _tmpConversationNode ConversationNode
	var rawConversationNode _tmpConversationNode
	if err := safejson.Unmarshal(data, &rawConversationNode); err != nil {
		return err
	}
	if rawConversationNode.Replies == nil {
		rawConversationNode.Replies = make([]ConversationNode, 0)
	}
	*o = ConversationNode(rawConversationNode)
	return nil
}

func (o ConversationNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ConversationNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateCommentRequest struct {
	Parent CommentParent `json:"parent"`
	// The content of the comment. Markdown supported.
	Content string `conjure-docs:"The content of the comment. Markdown supported." json:"content"`
	// Attachments to the comment.
	Attachments []rids.AttachmentRid `conjure-docs:"Attachments to the comment." json:"attachments"`
}

func (o CreateCommentRequest) MarshalJSON() ([]byte, error) {
	if o.Attachments == nil {
		o.Attachments = make([]rids.AttachmentRid, 0)
	}
	type _tmpCreateCommentRequest CreateCommentRequest
	return safejson.Marshal(_tmpCreateCommentRequest(o))
}

func (o *CreateCommentRequest) UnmarshalJSON(data []byte) error {
	type _tmpCreateCommentRequest CreateCommentRequest
	var rawCreateCommentRequest _tmpCreateCommentRequest
	if err := safejson.Unmarshal(data, &rawCreateCommentRequest); err != nil {
		return err
	}
	if rawCreateCommentRequest.Attachments == nil {
		rawCreateCommentRequest.Attachments = make([]rids.AttachmentRid, 0)
	}
	*o = CreateCommentRequest(rawCreateCommentRequest)
	return nil
}

func (o CreateCommentRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateCommentRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EditCommentRequest struct {
	// The content of the comment. Markdown supported.
	Content string `conjure-docs:"The content of the comment. Markdown supported." json:"content"`
	// Attachments to the comment.
	Attachments []rids.AttachmentRid `conjure-docs:"Attachments to the comment." json:"attachments"`
}

func (o EditCommentRequest) MarshalJSON() ([]byte, error) {
	if o.Attachments == nil {
		o.Attachments = make([]rids.AttachmentRid, 0)
	}
	type _tmpEditCommentRequest EditCommentRequest
	return safejson.Marshal(_tmpEditCommentRequest(o))
}

func (o *EditCommentRequest) UnmarshalJSON(data []byte) error {
	type _tmpEditCommentRequest EditCommentRequest
	var rawEditCommentRequest _tmpEditCommentRequest
	if err := safejson.Unmarshal(data, &rawEditCommentRequest); err != nil {
		return err
	}
	if rawEditCommentRequest.Attachments == nil {
		rawEditCommentRequest.Attachments = make([]rids.AttachmentRid, 0)
	}
	*o = EditCommentRequest(rawEditCommentRequest)
	return nil
}

func (o EditCommentRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EditCommentRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Reaction struct {
	// Unique resource identifier for the reaction
	Rid ReactionRid `conjure-docs:"Unique resource identifier for the reaction" json:"rid"`
	// The user who authored the reaction
	UserRid rid.ResourceIdentifier `conjure-docs:"The user who authored the reaction" json:"userRid"`
	// The time the reaction was created
	CreatedAt datetime.DateTime `conjure-docs:"The time the reaction was created" json:"createdAt"`
	// The type of reaction
	Type ReactionType `conjure-docs:"The type of reaction" json:"type"`
}

func (o Reaction) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Reaction) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
