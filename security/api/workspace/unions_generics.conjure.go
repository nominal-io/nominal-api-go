// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package workspace

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api/io/nominal/api"
)

type PreferredRefNameConfigurationWithT[T any] PreferredRefNameConfiguration

func (u *PreferredRefNameConfigurationWithT[T]) Accept(ctx context.Context, v PreferredRefNameConfigurationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v.VisitV1(ctx, *u.v1)
	}
}

func (u *PreferredRefNameConfigurationWithT[T]) AcceptFuncs(v1Func func([]api.RefNameAndType) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "v1":
		if u.v1 == nil {
			return result, fmt.Errorf("field \"v1\" is required")
		}
		return v1Func(*u.v1)
	}
}

func (u *PreferredRefNameConfigurationWithT[T]) V1NoopSuccess([]api.RefNameAndType) (T, error) {
	var result T
	return result, nil
}

func (u *PreferredRefNameConfigurationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PreferredRefNameConfigurationVisitorWithT[T any] interface {
	VisitV1(ctx context.Context, v []api.RefNameAndType) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UpdateOrRemoveWorkspaceDisplayNameWithT[T any] UpdateOrRemoveWorkspaceDisplayName

func (u *UpdateOrRemoveWorkspaceDisplayNameWithT[T]) Accept(ctx context.Context, v UpdateOrRemoveWorkspaceDisplayNameVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "displayName":
		if u.displayName == nil {
			return result, fmt.Errorf("field \"displayName\" is required")
		}
		return v.VisitDisplayName(ctx, *u.displayName)
	case "removeType":
		if u.removeType == nil {
			return result, fmt.Errorf("field \"removeType\" is required")
		}
		return v.VisitRemoveType(ctx, *u.removeType)
	}
}

func (u *UpdateOrRemoveWorkspaceDisplayNameWithT[T]) AcceptFuncs(displayNameFunc func(string) (T, error), removeTypeFunc func(RemoveType) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "displayName":
		if u.displayName == nil {
			return result, fmt.Errorf("field \"displayName\" is required")
		}
		return displayNameFunc(*u.displayName)
	case "removeType":
		if u.removeType == nil {
			return result, fmt.Errorf("field \"removeType\" is required")
		}
		return removeTypeFunc(*u.removeType)
	}
}

func (u *UpdateOrRemoveWorkspaceDisplayNameWithT[T]) DisplayNameNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateOrRemoveWorkspaceDisplayNameWithT[T]) RemoveTypeNoopSuccess(RemoveType) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateOrRemoveWorkspaceDisplayNameWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UpdateOrRemoveWorkspaceDisplayNameVisitorWithT[T any] interface {
	VisitDisplayName(ctx context.Context, v string) (T, error)
	VisitRemoveType(ctx context.Context, v RemoveType) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UpdateOrRemoveWorkspaceSymbolWithT[T any] UpdateOrRemoveWorkspaceSymbol

func (u *UpdateOrRemoveWorkspaceSymbolWithT[T]) Accept(ctx context.Context, v UpdateOrRemoveWorkspaceSymbolVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "symbol":
		if u.symbol == nil {
			return result, fmt.Errorf("field \"symbol\" is required")
		}
		return v.VisitSymbol(ctx, *u.symbol)
	case "removeType":
		if u.removeType == nil {
			return result, fmt.Errorf("field \"removeType\" is required")
		}
		return v.VisitRemoveType(ctx, *u.removeType)
	}
}

func (u *UpdateOrRemoveWorkspaceSymbolWithT[T]) AcceptFuncs(symbolFunc func(WorkspaceSymbol) (T, error), removeTypeFunc func(RemoveType) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "symbol":
		if u.symbol == nil {
			return result, fmt.Errorf("field \"symbol\" is required")
		}
		return symbolFunc(*u.symbol)
	case "removeType":
		if u.removeType == nil {
			return result, fmt.Errorf("field \"removeType\" is required")
		}
		return removeTypeFunc(*u.removeType)
	}
}

func (u *UpdateOrRemoveWorkspaceSymbolWithT[T]) SymbolNoopSuccess(WorkspaceSymbol) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateOrRemoveWorkspaceSymbolWithT[T]) RemoveTypeNoopSuccess(RemoveType) (T, error) {
	var result T
	return result, nil
}

func (u *UpdateOrRemoveWorkspaceSymbolWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UpdateOrRemoveWorkspaceSymbolVisitorWithT[T any] interface {
	VisitSymbol(ctx context.Context, v WorkspaceSymbol) (T, error)
	VisitRemoveType(ctx context.Context, v RemoveType) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type WorkspaceSymbolWithT[T any] WorkspaceSymbol

func (u *WorkspaceSymbolWithT[T]) Accept(ctx context.Context, v WorkspaceSymbolVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "icon":
		if u.icon == nil {
			return result, fmt.Errorf("field \"icon\" is required")
		}
		return v.VisitIcon(ctx, *u.icon)
	case "emoji":
		if u.emoji == nil {
			return result, fmt.Errorf("field \"emoji\" is required")
		}
		return v.VisitEmoji(ctx, *u.emoji)
	case "image":
		if u.image == nil {
			return result, fmt.Errorf("field \"image\" is required")
		}
		return v.VisitImage(ctx, *u.image)
	}
}

func (u *WorkspaceSymbolWithT[T]) AcceptFuncs(iconFunc func(string) (T, error), emojiFunc func(string) (T, error), imageFunc func(string) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "icon":
		if u.icon == nil {
			return result, fmt.Errorf("field \"icon\" is required")
		}
		return iconFunc(*u.icon)
	case "emoji":
		if u.emoji == nil {
			return result, fmt.Errorf("field \"emoji\" is required")
		}
		return emojiFunc(*u.emoji)
	case "image":
		if u.image == nil {
			return result, fmt.Errorf("field \"image\" is required")
		}
		return imageFunc(*u.image)
	}
}

func (u *WorkspaceSymbolWithT[T]) IconNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *WorkspaceSymbolWithT[T]) EmojiNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *WorkspaceSymbolWithT[T]) ImageNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *WorkspaceSymbolWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type WorkspaceSymbolVisitorWithT[T any] interface {
	VisitIcon(ctx context.Context, v string) (T, error)
	VisitEmoji(ctx context.Context, v string) (T, error)
	VisitImage(ctx context.Context, v string) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
