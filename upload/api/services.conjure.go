// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"
	"net/url"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/ingest/api"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	"github.com/palantir/pkg/safelong"
	werror "github.com/palantir/witchcraft-go-error"
)

// The Upload Service manages file uploads to object storage.
type UploadServiceClient interface {
	/*
	   Initiates a multipart upload to object storage.
	   Returns an uploadId that should be used with listParts, signPart, and completeMultipartUpload.
	*/
	InitiateMultipartUpload(ctx context.Context, authHeader bearertoken.Token, uploadRequestArg api.InitiateMultipartUploadRequest) (api.InitiateMultipartUploadResponse, error)
	// Lists the parts that have been uploaded for a given uploadId.
	ListParts(ctx context.Context, authHeader bearertoken.Token, uploadIdArg string, keyArg string) ([]api.PartWithSize, error)
	/*
	   Signs an upload request for a single part.
	   Returns a URL that will execute the upload without further authentication.
	*/
	SignPart(ctx context.Context, authHeader bearertoken.Token, uploadIdArg string, keyArg string, partNumberArg int) (api.SignPartResponse, error)
	/*
	   Completes a multipart upload to object storage.
	   This should be called after all parts have been uploaded.
	   Will throw EmptyMultipartUpload if there are 0 parts.
	*/
	CompleteMultipartUpload(ctx context.Context, authHeader bearertoken.Token, uploadIdArg string, keyArg string, partsArg []api.Part) (api.CompleteMultipartUploadResponse, error)
	/*
	   Aborts a multipart upload to S3.
	   Frees storage used by previously uploaded parts and prevents further uploads to the same uploadId.
	*/
	AbortMultipartUpload(ctx context.Context, authHeader bearertoken.Token, uploadIdArg string, keyArg string) error
	// Uploads a file to S3. Intended for smaller files.
	UploadFile(ctx context.Context, authHeader bearertoken.Token, fileNameArg string, sizeBytesArg *safelong.SafeLong, workspaceArg *rids.WorkspaceRid, bodyArg httpclient.RequestBody) (api1.S3Path, error)
}

type uploadServiceClient struct {
	client httpclient.Client
}

func NewUploadServiceClient(client httpclient.Client) UploadServiceClient {
	return &uploadServiceClient{client: client}
}

func (c *uploadServiceClient) InitiateMultipartUpload(ctx context.Context, authHeader bearertoken.Token, uploadRequestArg api.InitiateMultipartUploadRequest) (api.InitiateMultipartUploadResponse, error) {
	var defaultReturnVal api.InitiateMultipartUploadResponse
	var returnVal *api.InitiateMultipartUploadResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("InitiateMultipartUpload"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/upload/v1/multipart-upload"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(uploadRequestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "initiateMultipartUpload failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "initiateMultipartUpload response cannot be nil")
	}
	return *returnVal, nil
}

func (c *uploadServiceClient) ListParts(ctx context.Context, authHeader bearertoken.Token, uploadIdArg string, keyArg string) ([]api.PartWithSize, error) {
	var returnVal []api.PartWithSize
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ListParts"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/upload/v1/multipart-upload/%s", url.PathEscape(fmt.Sprint(uploadIdArg))))
	queryParams := make(url.Values)
	queryParams.Set("key", fmt.Sprint(keyArg))
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "listParts failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "listParts response cannot be nil")
	}
	return returnVal, nil
}

func (c *uploadServiceClient) SignPart(ctx context.Context, authHeader bearertoken.Token, uploadIdArg string, keyArg string, partNumberArg int) (api.SignPartResponse, error) {
	var defaultReturnVal api.SignPartResponse
	var returnVal *api.SignPartResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SignPart"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/upload/v1/multipart-upload/%s", url.PathEscape(fmt.Sprint(uploadIdArg))))
	queryParams := make(url.Values)
	queryParams.Set("key", fmt.Sprint(keyArg))
	queryParams.Set("partNumber", fmt.Sprint(partNumberArg))
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "signPart failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "signPart response cannot be nil")
	}
	return *returnVal, nil
}

func (c *uploadServiceClient) CompleteMultipartUpload(ctx context.Context, authHeader bearertoken.Token, uploadIdArg string, keyArg string, partsArg []api.Part) (api.CompleteMultipartUploadResponse, error) {
	var defaultReturnVal api.CompleteMultipartUploadResponse
	var returnVal *api.CompleteMultipartUploadResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CompleteMultipartUpload"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/upload/v1/multipart-upload/%s/complete", url.PathEscape(fmt.Sprint(uploadIdArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(partsArg))
	queryParams := make(url.Values)
	queryParams.Set("key", fmt.Sprint(keyArg))
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "completeMultipartUpload failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "completeMultipartUpload response cannot be nil")
	}
	return *returnVal, nil
}

func (c *uploadServiceClient) AbortMultipartUpload(ctx context.Context, authHeader bearertoken.Token, uploadIdArg string, keyArg string) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("AbortMultipartUpload"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/upload/v1/multipart-upload/%s/abort", url.PathEscape(fmt.Sprint(uploadIdArg))))
	queryParams := make(url.Values)
	queryParams.Set("key", fmt.Sprint(keyArg))
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "abortMultipartUpload failed")
	}
	return nil
}

func (c *uploadServiceClient) UploadFile(ctx context.Context, authHeader bearertoken.Token, fileNameArg string, sizeBytesArg *safelong.SafeLong, workspaceArg *rids.WorkspaceRid, bodyArg httpclient.RequestBody) (api1.S3Path, error) {
	var defaultReturnVal api1.S3Path
	var returnVal *api1.S3Path
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UploadFile"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/upload/v1/upload-file"))
	requestParams = append(requestParams, httpclient.WithBinaryRequestBody(bodyArg))
	queryParams := make(url.Values)
	queryParams.Set("fileName", fmt.Sprint(fileNameArg))
	if sizeBytesArg != nil {
		queryParams.Set("sizeBytes", fmt.Sprint(*sizeBytesArg))
	}
	if workspaceArg != nil {
		queryParams.Set("workspace", fmt.Sprint(*workspaceArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "uploadFile failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "uploadFile response cannot be nil")
	}
	return *returnVal, nil
}

// The Upload Service manages file uploads to object storage.
type UploadServiceClientWithAuth interface {
	/*
	   Initiates a multipart upload to object storage.
	   Returns an uploadId that should be used with listParts, signPart, and completeMultipartUpload.
	*/
	InitiateMultipartUpload(ctx context.Context, uploadRequestArg api.InitiateMultipartUploadRequest) (api.InitiateMultipartUploadResponse, error)
	// Lists the parts that have been uploaded for a given uploadId.
	ListParts(ctx context.Context, uploadIdArg string, keyArg string) ([]api.PartWithSize, error)
	/*
	   Signs an upload request for a single part.
	   Returns a URL that will execute the upload without further authentication.
	*/
	SignPart(ctx context.Context, uploadIdArg string, keyArg string, partNumberArg int) (api.SignPartResponse, error)
	/*
	   Completes a multipart upload to object storage.
	   This should be called after all parts have been uploaded.
	   Will throw EmptyMultipartUpload if there are 0 parts.
	*/
	CompleteMultipartUpload(ctx context.Context, uploadIdArg string, keyArg string, partsArg []api.Part) (api.CompleteMultipartUploadResponse, error)
	/*
	   Aborts a multipart upload to S3.
	   Frees storage used by previously uploaded parts and prevents further uploads to the same uploadId.
	*/
	AbortMultipartUpload(ctx context.Context, uploadIdArg string, keyArg string) error
	// Uploads a file to S3. Intended for smaller files.
	UploadFile(ctx context.Context, fileNameArg string, sizeBytesArg *safelong.SafeLong, workspaceArg *rids.WorkspaceRid, bodyArg httpclient.RequestBody) (api1.S3Path, error)
}

func NewUploadServiceClientWithAuth(client UploadServiceClient, authHeader bearertoken.Token) UploadServiceClientWithAuth {
	return &uploadServiceClientWithAuth{client: client, authHeader: authHeader}
}

type uploadServiceClientWithAuth struct {
	client     UploadServiceClient
	authHeader bearertoken.Token
}

func (c *uploadServiceClientWithAuth) InitiateMultipartUpload(ctx context.Context, uploadRequestArg api.InitiateMultipartUploadRequest) (api.InitiateMultipartUploadResponse, error) {
	return c.client.InitiateMultipartUpload(ctx, c.authHeader, uploadRequestArg)
}

func (c *uploadServiceClientWithAuth) ListParts(ctx context.Context, uploadIdArg string, keyArg string) ([]api.PartWithSize, error) {
	return c.client.ListParts(ctx, c.authHeader, uploadIdArg, keyArg)
}

func (c *uploadServiceClientWithAuth) SignPart(ctx context.Context, uploadIdArg string, keyArg string, partNumberArg int) (api.SignPartResponse, error) {
	return c.client.SignPart(ctx, c.authHeader, uploadIdArg, keyArg, partNumberArg)
}

func (c *uploadServiceClientWithAuth) CompleteMultipartUpload(ctx context.Context, uploadIdArg string, keyArg string, partsArg []api.Part) (api.CompleteMultipartUploadResponse, error) {
	return c.client.CompleteMultipartUpload(ctx, c.authHeader, uploadIdArg, keyArg, partsArg)
}

func (c *uploadServiceClientWithAuth) AbortMultipartUpload(ctx context.Context, uploadIdArg string, keyArg string) error {
	return c.client.AbortMultipartUpload(ctx, c.authHeader, uploadIdArg, keyArg)
}

func (c *uploadServiceClientWithAuth) UploadFile(ctx context.Context, fileNameArg string, sizeBytesArg *safelong.SafeLong, workspaceArg *rids.WorkspaceRid, bodyArg httpclient.RequestBody) (api1.S3Path, error) {
	return c.client.UploadFile(ctx, c.authHeader, fileNameArg, sizeBytesArg, workspaceArg, bodyArg)
}

func NewUploadServiceClientWithTokenProvider(client UploadServiceClient, tokenProvider httpclient.TokenProvider) UploadServiceClientWithAuth {
	return &uploadServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type uploadServiceClientWithTokenProvider struct {
	client        UploadServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *uploadServiceClientWithTokenProvider) InitiateMultipartUpload(ctx context.Context, uploadRequestArg api.InitiateMultipartUploadRequest) (api.InitiateMultipartUploadResponse, error) {
	var defaultReturnVal api.InitiateMultipartUploadResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.InitiateMultipartUpload(ctx, bearertoken.Token(token), uploadRequestArg)
}

func (c *uploadServiceClientWithTokenProvider) ListParts(ctx context.Context, uploadIdArg string, keyArg string) ([]api.PartWithSize, error) {
	var defaultReturnVal []api.PartWithSize
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ListParts(ctx, bearertoken.Token(token), uploadIdArg, keyArg)
}

func (c *uploadServiceClientWithTokenProvider) SignPart(ctx context.Context, uploadIdArg string, keyArg string, partNumberArg int) (api.SignPartResponse, error) {
	var defaultReturnVal api.SignPartResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.SignPart(ctx, bearertoken.Token(token), uploadIdArg, keyArg, partNumberArg)
}

func (c *uploadServiceClientWithTokenProvider) CompleteMultipartUpload(ctx context.Context, uploadIdArg string, keyArg string, partsArg []api.Part) (api.CompleteMultipartUploadResponse, error) {
	var defaultReturnVal api.CompleteMultipartUploadResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CompleteMultipartUpload(ctx, bearertoken.Token(token), uploadIdArg, keyArg, partsArg)
}

func (c *uploadServiceClientWithTokenProvider) AbortMultipartUpload(ctx context.Context, uploadIdArg string, keyArg string) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.AbortMultipartUpload(ctx, bearertoken.Token(token), uploadIdArg, keyArg)
}

func (c *uploadServiceClientWithTokenProvider) UploadFile(ctx context.Context, fileNameArg string, sizeBytesArg *safelong.SafeLong, workspaceArg *rids.WorkspaceRid, bodyArg httpclient.RequestBody) (api1.S3Path, error) {
	var defaultReturnVal api1.S3Path
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UploadFile(ctx, bearertoken.Token(token), fileNameArg, sizeBytesArg, workspaceArg, bodyArg)
}
