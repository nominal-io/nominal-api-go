// Code generated by conjure-go. DO NOT EDIT.

package manifest

import (
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

/*
Manifest file produced by containerized extractors to describe their outputs.
This is written as manifest.json in the OUTPUT_DIR by the container.
*/
type ExtractorManifest struct {
	// List of output files produced by the extractor
	Outputs []ManifestOutput `conjure-docs:"List of output files produced by the extractor" json:"outputs"`
}

func (o ExtractorManifest) MarshalJSON() ([]byte, error) {
	if o.Outputs == nil {
		o.Outputs = make([]ManifestOutput, 0)
	}
	type _tmpExtractorManifest ExtractorManifest
	return safejson.Marshal(_tmpExtractorManifest(o))
}

func (o *ExtractorManifest) UnmarshalJSON(data []byte) error {
	type _tmpExtractorManifest ExtractorManifest
	var rawExtractorManifest _tmpExtractorManifest
	if err := safejson.Unmarshal(data, &rawExtractorManifest); err != nil {
		return err
	}
	if rawExtractorManifest.Outputs == nil {
		rawExtractorManifest.Outputs = make([]ManifestOutput, 0)
	}
	*o = ExtractorManifest(rawExtractorManifest)
	return nil
}

func (o ExtractorManifest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExtractorManifest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Metadata file created by yeeter after uploading extractor outputs to S3.
This is uploaded to S3 by yeeter and read by the Temporal activity to orchestrate ingestion.
*/
type ExtractorUploadMetadata struct {
	// List of uploaded files with their S3 locations and manifest metadata
	Uploads []UploadMetadata `conjure-docs:"List of uploaded files with their S3 locations and manifest metadata" json:"uploads"`
}

func (o ExtractorUploadMetadata) MarshalJSON() ([]byte, error) {
	if o.Uploads == nil {
		o.Uploads = make([]UploadMetadata, 0)
	}
	type _tmpExtractorUploadMetadata ExtractorUploadMetadata
	return safejson.Marshal(_tmpExtractorUploadMetadata(o))
}

func (o *ExtractorUploadMetadata) UnmarshalJSON(data []byte) error {
	type _tmpExtractorUploadMetadata ExtractorUploadMetadata
	var rawExtractorUploadMetadata _tmpExtractorUploadMetadata
	if err := safejson.Unmarshal(data, &rawExtractorUploadMetadata); err != nil {
		return err
	}
	if rawExtractorUploadMetadata.Uploads == nil {
		rawExtractorUploadMetadata.Uploads = make([]UploadMetadata, 0)
	}
	*o = ExtractorUploadMetadata(rawExtractorUploadMetadata)
	return nil
}

func (o ExtractorUploadMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExtractorUploadMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Describes a single output file from a containerized extractor.
This is written by the container in manifest.json.
*/
type ManifestOutput struct {
	// The type of ingestion for this output file
	IngestType ManifestIngestType `conjure-docs:"The type of ingestion for this output file" json:"ingestType"`
	/*
	   Relative path to the output file within OUTPUT_DIR.
	   Example: "telemetry.csv" or "data/sensor_readings.parquet"
	*/
	RelativePath string `conjure-docs:"Relative path to the output file within OUTPUT_DIR.\nExample: \"telemetry.csv\" or \"data/sensor_readings.parquet\"" json:"relativePath"`
	/*
	   Optional mapping of tag names to column names for CSV/Parquet ingestion.
	   Example: {"vehicle_id": "veh_id", "mission_id": "msn_id"}
	*/
	TagColumns map[string]string `conjure-docs:"Optional mapping of tag names to column names for CSV/Parquet ingestion.\nExample: {\"vehicle_id\": \"veh_id\", \"mission_id\": \"msn_id\"}" json:"tagColumns"`
	/*
	   Optional prefix to prepend to channel names during ingestion.
	   Example: "telemetry/" would create channels like "telemetry/speed", "telemetry/altitude"
	*/
	ChannelPrefix *string `conjure-docs:"Optional prefix to prepend to channel names during ingestion.\nExample: \"telemetry/\" would create channels like \"telemetry/speed\", \"telemetry/altitude\"" json:"channelPrefix,omitempty"`
}

func (o ManifestOutput) MarshalJSON() ([]byte, error) {
	if o.TagColumns == nil {
		o.TagColumns = make(map[string]string, 0)
	}
	type _tmpManifestOutput ManifestOutput
	return safejson.Marshal(_tmpManifestOutput(o))
}

func (o *ManifestOutput) UnmarshalJSON(data []byte) error {
	type _tmpManifestOutput ManifestOutput
	var rawManifestOutput _tmpManifestOutput
	if err := safejson.Unmarshal(data, &rawManifestOutput); err != nil {
		return err
	}
	if rawManifestOutput.TagColumns == nil {
		rawManifestOutput.TagColumns = make(map[string]string, 0)
	}
	*o = ManifestOutput(rawManifestOutput)
	return nil
}

func (o ManifestOutput) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ManifestOutput) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Metadata about a single file uploaded to S3 by yeeter.
Enriches the original manifest entry with S3 upload information.
*/
type UploadMetadata struct {
	// Full S3 key where the file was uploaded
	S3Key string `conjure-docs:"Full S3 key where the file was uploaded" json:"s3Key"`
	// S3 bucket name where the file was uploaded
	S3Bucket string `conjure-docs:"S3 bucket name where the file was uploaded" json:"s3Bucket"`
	// The original manifest entry from the container's manifest.yaml
	ManifestOutput ManifestOutput `conjure-docs:"The original manifest entry from the container's manifest.yaml" json:"manifestOutput"`
}

func (o UploadMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UploadMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
