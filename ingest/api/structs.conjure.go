// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/io/nominal/datasource"
	api2 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/run/api"
	api4 "github.com/nominal-io/nominal-api-go/scout/video/api"
	api3 "github.com/nominal-io/nominal-api-go/secrets/api"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safelong"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
)

type AsyncHandle struct {
	Rid rid.ResourceIdentifier `json:"rid"`
}

func (o AsyncHandle) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AsyncHandle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Options for ingesting Avro data with the following schema. This is a "stream-like" file format to support
use cases where a columnar/tabular format does not make sense. This closely matches Nominal's streaming
API, making it useful for use cases where network connection drops during streaming and a backup file needs
to be created.

If this schema is not used, will result in a failed ingestion.

	{
	    "type": "record",
	    "name": "AvroStream",
	    "namespace": "io.nominal.ingest",
	    "fields": [
	        {
	            "name": "channel",
	            "type": "string",
	            "doc": "Channel/series name (e.g., 'vehicle_id', 'col_1', 'temperature')",
	        },
	        {
	            "name": "timestamps",
	            "type": {"type": "array", "items": "long"},
	            "doc": "Array of Unix timestamps in nanoseconds",
	        },
	        {
	            "name": "values",
	            "type": {"type": "array", "items": ["double", "string"]},
	            "doc": "Array of values. Can either be doubles or strings",
	        },
	        {
	            "name": "tags",
	            "type": {"type": "map", "values": "string"},
	            "default": {},
	            "doc": "Key-value metadata tags",
	        },
	    ],
	}
*/
type AvroStreamOpts struct {
	Source IngestSource        `json:"source"`
	Target DatasetIngestTarget `json:"target"`
}

func (o AvroStreamOpts) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *AvroStreamOpts) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ChannelConfig struct {
	// If set, will construct a prefix tree for channels of the dataset using the given delimiter.
	PrefixTreeDelimiter *string `conjure-docs:"If set, will construct a prefix tree for channels of the dataset using the given delimiter." json:"prefixTreeDelimiter,omitempty"`
}

func (o ChannelConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ChannelConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CompleteMultipartUploadResponse struct {
	Location *string `json:"location,omitempty"`
}

func (o CompleteMultipartUploadResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CompleteMultipartUploadResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Represents a containerized extractor that processes input files using a container.
type ContainerizedExtractor struct {
	// Unique resource identifier for the extractor.
	Rid ContainerizedExtractorRid `conjure-docs:"Unique resource identifier for the extractor." json:"rid"`
	// The name of the extractor as defined by the user.
	Name string `conjure-docs:"The name of the extractor as defined by the user." json:"name"`
	// Optional description of the extractor.
	Description *string `conjure-docs:"Optional description of the extractor." json:"description,omitempty"`
	// Container image used to run the extractor.
	Image DockerImageSource `conjure-docs:"Container image used to run the extractor." json:"image"`
	// The input files that this extractor requires, mapped to environment variables that store the path to the file.
	Inputs []FileExtractionInput `conjure-docs:"The input files that this extractor requires, mapped to environment variables that store the path to the file." json:"inputs"`
	// Additional properties associated with this extractor.
	Properties map[api.PropertyName]api.PropertyValue `conjure-docs:"Additional properties associated with this extractor." json:"properties"`
	// Set of labels applied to this extractor.
	Labels []api.Label `conjure-docs:"Set of labels applied to this extractor." json:"labels"`
	// Timestamp when this extractor was created.
	CreatedAt datetime.DateTime `conjure-docs:"Timestamp when this extractor was created." json:"createdAt"`
	// Whether this extractor is archived.
	IsArchived bool `conjure-docs:"Whether this extractor is archived." json:"isArchived"`
	// Metadata about the intermediate parquet this extractor will produce
	TimestampMetadata TimestampMetadata `conjure-docs:"Metadata about the intermediate parquet this extractor will produce" json:"timestampMetadata"`
	// The format of the output file. Currently only "parquet", "csv", "parquet.tar" are supported
	OutputFileFormat FileOutputFormat `conjure-docs:"The format of the output file. Currently only \"parquet\", \"csv\", \"parquet.tar\" are supported" json:"outputFileFormat"`
}

func (o ContainerizedExtractor) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]FileExtractionInput, 0)
	}
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	type _tmpContainerizedExtractor ContainerizedExtractor
	return safejson.Marshal(_tmpContainerizedExtractor(o))
}

func (o *ContainerizedExtractor) UnmarshalJSON(data []byte) error {
	type _tmpContainerizedExtractor ContainerizedExtractor
	var rawContainerizedExtractor _tmpContainerizedExtractor
	if err := safejson.Unmarshal(data, &rawContainerizedExtractor); err != nil {
		return err
	}
	if rawContainerizedExtractor.Inputs == nil {
		rawContainerizedExtractor.Inputs = make([]FileExtractionInput, 0)
	}
	if rawContainerizedExtractor.Properties == nil {
		rawContainerizedExtractor.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if rawContainerizedExtractor.Labels == nil {
		rawContainerizedExtractor.Labels = make([]api.Label, 0)
	}
	*o = ContainerizedExtractor(rawContainerizedExtractor)
	return nil
}

func (o ContainerizedExtractor) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ContainerizedExtractor) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ContainerizedOpts struct {
	Sources      map[EnvironmentVariable]IngestSource `json:"sources"`
	ExtractorRid ContainerizedExtractorRid            `json:"extractorRid"`
	Tag          *string                              `json:"tag,omitempty"`
	Target       DatasetIngestTarget                  `json:"target"`
}

func (o ContainerizedOpts) MarshalJSON() ([]byte, error) {
	if o.Sources == nil {
		o.Sources = make(map[EnvironmentVariable]IngestSource, 0)
	}
	type _tmpContainerizedOpts ContainerizedOpts
	return safejson.Marshal(_tmpContainerizedOpts(o))
}

func (o *ContainerizedOpts) UnmarshalJSON(data []byte) error {
	type _tmpContainerizedOpts ContainerizedOpts
	var rawContainerizedOpts _tmpContainerizedOpts
	if err := safejson.Unmarshal(data, &rawContainerizedOpts); err != nil {
		return err
	}
	if rawContainerizedOpts.Sources == nil {
		rawContainerizedOpts.Sources = make(map[EnvironmentVariable]IngestSource, 0)
	}
	*o = ContainerizedOpts(rawContainerizedOpts)
	return nil
}

func (o ContainerizedOpts) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ContainerizedOpts) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Options for ingesting csv files.  Supported file formats include .csv, .csv.gz
type CsvOpts struct {
	Source            IngestSource        `json:"source"`
	Target            DatasetIngestTarget `json:"target"`
	TimestampMetadata TimestampMetadata   `json:"timestampMetadata"`
	ChannelPrefix     ChannelPrefix       `json:"channelPrefix"`
	// Deprecated: Deprecated in favor of tagColumns.
	TagKeysFromColumns *[]api.TagName `json:"tagKeysFromColumns,omitempty"`
	// A map of tag names to column names to derive the tag values from.
	TagColumns *map[api.TagName]api.ColumnName `conjure-docs:"A map of tag names to column names to derive the tag values from." json:"tagColumns,omitempty"`
	// Specifies a tag set to apply to all data in the file.
	AdditionalFileTags *map[api.TagName]api.TagValue `conjure-docs:"Specifies a tag set to apply to all data in the file." json:"additionalFileTags,omitempty"`
}

func (o CsvOpts) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CsvOpts) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CustomTimestamp struct {
	// The format string should be in the format of the `DateTimeFormatter` class in Java.
	Format string `conjure-docs:"The format string should be in the format of the \"DateTimeFormatter\" class in Java." json:"format"`
	// Default year is accepted as an optional field for cases like IRIG time format and will be overridden by year in time format.
	DefaultYear *int `conjure-docs:"Default year is accepted as an optional field for cases like IRIG time format and will be overridden by year in time format." json:"defaultYear,omitempty"`
	// Default day of year is accepted as an optional field for cases like IRIG time format and will be overridden by day of year in time format.
	DefaultDayOfYear *int `conjure-docs:"Default day of year is accepted as an optional field for cases like IRIG time format and will be overridden by day of year in time format." json:"defaultDayOfYear,omitempty"`
}

func (o CustomTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CustomTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DataflashOpts struct {
	Source IngestSource        `json:"source"`
	Target DatasetIngestTarget `json:"target"`
}

func (o DataflashOpts) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DataflashOpts) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DatasetSpec struct {
	Name *string `json:"name,omitempty"`
}

func (o DatasetSpec) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DatasetSpec) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DeprecatedNewCsv struct {
	Source         IngestSource       `json:"source"`
	Name           *string            `json:"name,omitempty"`
	Properties     map[string]string  `json:"properties"`
	TimeColumnSpec *TimestampMetadata `json:"timeColumnSpec,omitempty"`
	ChannelConfig  *ChannelConfig     `json:"channelConfig,omitempty"`
}

func (o DeprecatedNewCsv) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[string]string, 0)
	}
	type _tmpDeprecatedNewCsv DeprecatedNewCsv
	return safejson.Marshal(_tmpDeprecatedNewCsv(o))
}

func (o *DeprecatedNewCsv) UnmarshalJSON(data []byte) error {
	type _tmpDeprecatedNewCsv DeprecatedNewCsv
	var rawDeprecatedNewCsv _tmpDeprecatedNewCsv
	if err := safejson.Unmarshal(data, &rawDeprecatedNewCsv); err != nil {
		return err
	}
	if rawDeprecatedNewCsv.Properties == nil {
		rawDeprecatedNewCsv.Properties = make(map[string]string, 0)
	}
	*o = DeprecatedNewCsv(rawDeprecatedNewCsv)
	return nil
}

func (o DeprecatedNewCsv) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DeprecatedNewCsv) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DeprecatedTimestampMetadata struct {
	SeriesName string `json:"seriesName"`
	IsAbsolute bool   `json:"isAbsolute"`
}

func (o DeprecatedTimestampMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DeprecatedTimestampMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type DeprecatedTriggerIngest struct {
	Source            IngestSource                 `json:"source"`
	Properties        map[string]string            `json:"properties"`
	DatasetName       *string                      `json:"datasetName,omitempty"`
	TimestampMetadata *DeprecatedTimestampMetadata `json:"timestampMetadata,omitempty"`
	/*
	   The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for
	   the user's organization, if the default workspace for the organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for\nthe user's organization, if the default workspace for the organization is configured." json:"workspace,omitempty"`
}

func (o DeprecatedTriggerIngest) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[string]string, 0)
	}
	type _tmpDeprecatedTriggerIngest DeprecatedTriggerIngest
	return safejson.Marshal(_tmpDeprecatedTriggerIngest(o))
}

func (o *DeprecatedTriggerIngest) UnmarshalJSON(data []byte) error {
	type _tmpDeprecatedTriggerIngest DeprecatedTriggerIngest
	var rawDeprecatedTriggerIngest _tmpDeprecatedTriggerIngest
	if err := safejson.Unmarshal(data, &rawDeprecatedTriggerIngest); err != nil {
		return err
	}
	if rawDeprecatedTriggerIngest.Properties == nil {
		rawDeprecatedTriggerIngest.Properties = make(map[string]string, 0)
	}
	*o = DeprecatedTriggerIngest(rawDeprecatedTriggerIngest)
	return nil
}

func (o DeprecatedTriggerIngest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DeprecatedTriggerIngest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Docker container image source definition.
type DockerImageSource struct {
	// The container registry where the image is hosted.
	Registry string `conjure-docs:"The container registry where the image is hosted." json:"registry"`
	// The repository name of the image.
	Repository string     `conjure-docs:"The repository name of the image." json:"repository"`
	TagDetails TagDetails `json:"tagDetails"`
	// Optional authentication for accessing private container registries.
	Authentication Authentication `conjure-docs:"Optional authentication for accessing private container registries." json:"authentication"`
	Command        *string        `json:"command,omitempty"`
}

func (o DockerImageSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *DockerImageSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EpochTimestamp struct {
	TimeUnit api.TimeUnit `json:"timeUnit"`
}

func (o EpochTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EpochTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExistingDatasetIngestDestination struct {
	DatasetRid rid.ResourceIdentifier `json:"datasetRid"`
	/*
	   The ingest will keep track of the range of timestamps in the ingested data and update the included
	   run's time bounds.
	   For runs with no end time (uninitialized), it will always set the start time to the file's start time
	   and set the end time to the file's end time.
	   For runs with existing end times, it will only expand the bounds (earliest start time, latest end time).
	*/
	ExpandRunBounds *[]api1.RunRid `conjure-docs:"The ingest will keep track of the range of timestamps in the ingested data and update the included\nrun's time bounds.\nFor runs with no end time (uninitialized), it will always set the start time to the file's start time\nand set the end time to the file's end time.\nFor runs with existing end times, it will only expand the bounds (earliest start time, latest end time)." json:"expandRunBounds,omitempty"`
}

func (o ExistingDatasetIngestDestination) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExistingDatasetIngestDestination) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ExistingVideoIngestDestination struct {
	// RID of the video to ingest the newly created video file to.
	VideoRid rids.VideoRid `conjure-docs:"RID of the video to ingest the newly created video file to." json:"videoRid"`
	// Metadata to associate with any created video file
	VideoFileDetails *VideoFileIngestDetails `conjure-docs:"Metadata to associate with any created video file" json:"videoFileDetails,omitempty"`
}

func (o ExistingVideoIngestDestination) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ExistingVideoIngestDestination) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Defines an input file to be provided to the extractor.
type FileExtractionInput struct {
	// The environment variable that stores the path to the input file.
	EnvironmentVariable EnvironmentVariable `conjure-docs:"The environment variable that stores the path to the input file." json:"environmentVariable"`
	// Name of the input file which users will be prompted with
	Name string `conjure-docs:"Name of the input file which users will be prompted with" json:"name"`
	// Description of the input file which users will be prompted with
	Description *string `conjure-docs:"Description of the input file which users will be prompted with" json:"description,omitempty"`
	// Optionally filter files for file selection
	FileFilters []FileFilter `conjure-docs:"Optionally filter files for file selection" json:"fileFilters"`
	// Whether the input file is required for the extractor to run.
	Required *bool `conjure-docs:"Whether the input file is required for the extractor to run." json:"required,omitempty"`
}

func (o FileExtractionInput) MarshalJSON() ([]byte, error) {
	if o.FileFilters == nil {
		o.FileFilters = make([]FileFilter, 0)
	}
	type _tmpFileExtractionInput FileExtractionInput
	return safejson.Marshal(_tmpFileExtractionInput(o))
}

func (o *FileExtractionInput) UnmarshalJSON(data []byte) error {
	type _tmpFileExtractionInput FileExtractionInput
	var rawFileExtractionInput _tmpFileExtractionInput
	if err := safejson.Unmarshal(data, &rawFileExtractionInput); err != nil {
		return err
	}
	if rawFileExtractionInput.FileFilters == nil {
		rawFileExtractionInput.FileFilters = make([]FileFilter, 0)
	}
	*o = FileExtractionInput(rawFileExtractionInput)
	return nil
}

func (o FileExtractionInput) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FileExtractionInput) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GcsIngestSource struct {
	Path string `json:"path"`
}

func (o GcsIngestSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GcsIngestSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetContainerizedExtractorsRequest struct {
	ExtractorRids []ContainerizedExtractorRid `json:"extractorRids"`
}

func (o GetContainerizedExtractorsRequest) MarshalJSON() ([]byte, error) {
	if o.ExtractorRids == nil {
		o.ExtractorRids = make([]ContainerizedExtractorRid, 0)
	}
	type _tmpGetContainerizedExtractorsRequest GetContainerizedExtractorsRequest
	return safejson.Marshal(_tmpGetContainerizedExtractorsRequest(o))
}

func (o *GetContainerizedExtractorsRequest) UnmarshalJSON(data []byte) error {
	type _tmpGetContainerizedExtractorsRequest GetContainerizedExtractorsRequest
	var rawGetContainerizedExtractorsRequest _tmpGetContainerizedExtractorsRequest
	if err := safejson.Unmarshal(data, &rawGetContainerizedExtractorsRequest); err != nil {
		return err
	}
	if rawGetContainerizedExtractorsRequest.ExtractorRids == nil {
		rawGetContainerizedExtractorsRequest.ExtractorRids = make([]ContainerizedExtractorRid, 0)
	}
	*o = GetContainerizedExtractorsRequest(rawGetContainerizedExtractorsRequest)
	return nil
}

func (o GetContainerizedExtractorsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetContainerizedExtractorsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetContainerizedExtractorsResponse struct {
	Extractors []ContainerizedExtractor `json:"extractors"`
}

func (o GetContainerizedExtractorsResponse) MarshalJSON() ([]byte, error) {
	if o.Extractors == nil {
		o.Extractors = make([]ContainerizedExtractor, 0)
	}
	type _tmpGetContainerizedExtractorsResponse GetContainerizedExtractorsResponse
	return safejson.Marshal(_tmpGetContainerizedExtractorsResponse(o))
}

func (o *GetContainerizedExtractorsResponse) UnmarshalJSON(data []byte) error {
	type _tmpGetContainerizedExtractorsResponse GetContainerizedExtractorsResponse
	var rawGetContainerizedExtractorsResponse _tmpGetContainerizedExtractorsResponse
	if err := safejson.Unmarshal(data, &rawGetContainerizedExtractorsResponse); err != nil {
		return err
	}
	if rawGetContainerizedExtractorsResponse.Extractors == nil {
		rawGetContainerizedExtractorsResponse.Extractors = make([]ContainerizedExtractor, 0)
	}
	*o = GetContainerizedExtractorsResponse(rawGetContainerizedExtractorsResponse)
	return nil
}

func (o GetContainerizedExtractorsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetContainerizedExtractorsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestDatasetFileDetails struct {
	DatasetFileId uuid.UUID       `json:"datasetFileId"`
	DatasetRid    rids.DatasetRid `json:"datasetRid"`
}

func (o IngestDatasetFileDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestDatasetFileDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestJob struct {
	IngestJobRid     IngestJobRid     `json:"ingestJobRid"`
	Status           IngestJobStatus  `json:"status"`
	IngestJobRequest IngestJobRequest `json:"ingestJobRequest"`
	OriginFiles      *[]string        `json:"originFiles,omitempty"`
	CreatedBy        uuid.UUID        `json:"createdBy"`
	OrgUuid          uuid.UUID        `json:"orgUuid"`
	IngestType       IngestType       `json:"ingestType"`
}

func (o IngestJob) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestJob) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestMcapRequest struct {
	/*
	   List of files in S3 to be ingested. These should be ordered by time, as data will be ingested and
	   concatenated across all the files.
	   Note: only a single files are currently supported, this field is mostly for forward compatibility.
	*/
	Sources       []IngestSource      `conjure-docs:"List of files in S3 to be ingested. These should be ordered by time, as data will be ingested and\nconcatenated across all the files.\nNote: only a single files are currently supported, this field is mostly for forward compatibility." json:"sources"`
	ChannelConfig []McapChannelConfig `json:"channelConfig"`
	/*
	   Config to define which channels in the mcap should be ingested. The default is to ingest only
	   channels with config, otherwise the mcap may not be supported.
	*/
	Channels    *McapChannels                          `conjure-docs:"Config to define which channels in the mcap should be ingested. The default is to ingest only\nchannels with config, otherwise the mcap may not be supported." json:"channels,omitempty"`
	Properties  map[api.PropertyName]api.PropertyValue `json:"properties"`
	Labels      []api.Label                            `json:"labels"`
	Title       *string                                `json:"title,omitempty"`
	Description *string                                `json:"description,omitempty"`
	/*
	   The workspace in which to create the dataset or video. If not provided, the dataset or video
	   will be created in the default workspace for the user's organization, if the default
	   workspace for the organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the dataset or video. If not provided, the dataset or video\nwill be created in the default workspace for the user's organization, if the default\nworkspace for the organization is configured." json:"workspace,omitempty"`
}

func (o IngestMcapRequest) MarshalJSON() ([]byte, error) {
	if o.Sources == nil {
		o.Sources = make([]IngestSource, 0)
	}
	if o.ChannelConfig == nil {
		o.ChannelConfig = make([]McapChannelConfig, 0)
	}
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	type _tmpIngestMcapRequest IngestMcapRequest
	return safejson.Marshal(_tmpIngestMcapRequest(o))
}

func (o *IngestMcapRequest) UnmarshalJSON(data []byte) error {
	type _tmpIngestMcapRequest IngestMcapRequest
	var rawIngestMcapRequest _tmpIngestMcapRequest
	if err := safejson.Unmarshal(data, &rawIngestMcapRequest); err != nil {
		return err
	}
	if rawIngestMcapRequest.Sources == nil {
		rawIngestMcapRequest.Sources = make([]IngestSource, 0)
	}
	if rawIngestMcapRequest.ChannelConfig == nil {
		rawIngestMcapRequest.ChannelConfig = make([]McapChannelConfig, 0)
	}
	if rawIngestMcapRequest.Properties == nil {
		rawIngestMcapRequest.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if rawIngestMcapRequest.Labels == nil {
		rawIngestMcapRequest.Labels = make([]api.Label, 0)
	}
	*o = IngestMcapRequest(rawIngestMcapRequest)
	return nil
}

func (o IngestMcapRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestMcapRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Returns references to the data ingested from an MCAP file.
type IngestMcapResponse struct {
	Outputs []McapIngestionOutput `json:"outputs"`
	// Deprecated: Deprecated
	AsyncHandle *AsyncHandle `json:"asyncHandle,omitempty"`
}

func (o IngestMcapResponse) MarshalJSON() ([]byte, error) {
	if o.Outputs == nil {
		o.Outputs = make([]McapIngestionOutput, 0)
	}
	type _tmpIngestMcapResponse IngestMcapResponse
	return safejson.Marshal(_tmpIngestMcapResponse(o))
}

func (o *IngestMcapResponse) UnmarshalJSON(data []byte) error {
	type _tmpIngestMcapResponse IngestMcapResponse
	var rawIngestMcapResponse _tmpIngestMcapResponse
	if err := safejson.Unmarshal(data, &rawIngestMcapResponse); err != nil {
		return err
	}
	if rawIngestMcapResponse.Outputs == nil {
		rawIngestMcapResponse.Outputs = make([]McapIngestionOutput, 0)
	}
	*o = IngestMcapResponse(rawIngestMcapResponse)
	return nil
}

func (o IngestMcapResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestMcapResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestMetadata struct {
	/*
	   The timestamp metadata will be recovered from the dataset files if possible.
	   Older datasets may have unrecoverable timestamp metadata.
	   If unrecoverable, reingestion will throw MissingMetadataForReingest if not provided in request.
	*/
	TimestampMetadata *TimestampMetadata `conjure-docs:"The timestamp metadata will be recovered from the dataset files if possible.\nOlder datasets may have unrecoverable timestamp metadata.\nIf unrecoverable, reingestion will throw MissingMetadataForReingest if not provided in request." json:"timestampMetadata,omitempty"`
	/*
	   Channel prefix to use when reingesting the dataset.
	   Defaults to empty string. Not recoverable from prior ingests and must be provided in request if needed.
	*/
	ChannelPrefix *string `conjure-docs:"Channel prefix to use when reingesting the dataset.\nDefaults to empty string. Not recoverable from prior ingests and must be provided in request if needed." json:"channelPrefix,omitempty"`
	/*
	   A map of tag names to column names to derive the tag values from.
	   Not recoverable from prior ingests and must be provided in request if needed.
	*/
	TagColumns *map[api.TagName]api.ColumnName `conjure-docs:"A map of tag names to column names to derive the tag values from.\nNot recoverable from prior ingests and must be provided in request if needed." json:"tagColumns,omitempty"`
	/*
	   Additional tags to apply to all dataset files within the the given dataset.
	   Not recoverable from prior ingests and must be provided in request if needed.
	*/
	AdditionalFileTags *map[api.TagName]api.TagValue `conjure-docs:"Additional tags to apply to all dataset files within the the given dataset.\nNot recoverable from prior ingests and must be provided in request if needed." json:"additionalFileTags,omitempty"`
}

func (o IngestMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestProgressV2 struct {
	// Timestamp at start of ingest
	StartTime datetime.DateTime `conjure-docs:"Timestamp at start of ingest" json:"startTime"`
	// Timestamp at end of ingest, empty if still in progress
	EndTime *datetime.DateTime `conjure-docs:"Timestamp at end of ingest, empty if still in progress" json:"endTime,omitempty"`
	// Status of ingest, contains error if failed
	IngestStatus api.IngestStatusV2 `conjure-docs:"Status of ingest, contains error if failed" json:"ingestStatus"`
	// Whether ingest duration can be reliably calculated
	Incalculable *bool `conjure-docs:"Whether ingest duration can be reliably calculated" json:"incalculable,omitempty"`
}

func (o IngestProgressV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestProgressV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestRequest struct {
	Options IngestOptions `json:"options"`
}

func (o IngestRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestResponse struct {
	Details      IngestDetails `json:"details"`
	IngestJobRid *IngestJobRid `json:"ingestJobRid,omitempty"`
}

func (o IngestResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestRunDataSource struct {
	DataSource     IngestDataSource `json:"dataSource"`
	TimeOffsetSpec *TimeOffsetSpec  `json:"timeOffsetSpec,omitempty"`
}

func (o IngestRunDataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestRunDataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestRunRequest struct {
	// If a run with the same rid already exists, the run will be updated.
	Rid         *rid.ResourceIdentifier                `conjure-docs:"If a run with the same rid already exists, the run will be updated." json:"rid,omitempty"`
	Title       string                                 `json:"title"`
	Description string                                 `json:"description"`
	StartTime   UtcTimestamp                           `json:"startTime"`
	EndTime     *UtcTimestamp                          `json:"endTime,omitempty"`
	Properties  map[api.PropertyName]api.PropertyValue `json:"properties"`
	Labels      []api.Label                            `json:"labels"`
	// for example, SIM, HTL, FLT
	RunPrefix   *string                                   `conjure-docs:"for example, SIM, HTL, FLT" json:"runPrefix,omitempty"`
	DataSources map[DataSourceRefName]IngestRunDataSource `json:"dataSources"`
	/*
	   The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for
	   the user's organization, if the default workspace for the organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for\nthe user's organization, if the default workspace for the organization is configured." json:"workspace,omitempty"`
}

func (o IngestRunRequest) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	if o.DataSources == nil {
		o.DataSources = make(map[DataSourceRefName]IngestRunDataSource, 0)
	}
	type _tmpIngestRunRequest IngestRunRequest
	return safejson.Marshal(_tmpIngestRunRequest(o))
}

func (o *IngestRunRequest) UnmarshalJSON(data []byte) error {
	type _tmpIngestRunRequest IngestRunRequest
	var rawIngestRunRequest _tmpIngestRunRequest
	if err := safejson.Unmarshal(data, &rawIngestRunRequest); err != nil {
		return err
	}
	if rawIngestRunRequest.Properties == nil {
		rawIngestRunRequest.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if rawIngestRunRequest.Labels == nil {
		rawIngestRunRequest.Labels = make([]api.Label, 0)
	}
	if rawIngestRunRequest.DataSources == nil {
		rawIngestRunRequest.DataSources = make(map[DataSourceRefName]IngestRunDataSource, 0)
	}
	*o = IngestRunRequest(rawIngestRunRequest)
	return nil
}

func (o IngestRunRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestRunRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestRunResponse struct {
	RunRid api1.RunRid `json:"runRid"`
}

func (o IngestRunResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestRunResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestSourceMetadata struct {
	TimestampMetadata *TimestampMetadata `json:"timestampMetadata,omitempty"`
}

func (o IngestSourceMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestSourceMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestVideoFileDetails struct {
	VideoFileRid rids.VideoFileRid `json:"videoFileRid"`
	VideoRid     rids.VideoRid     `json:"videoRid"`
}

func (o IngestVideoFileDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestVideoFileDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestVideoRequest struct {
	Sources     []IngestSource                         `json:"sources"`
	Properties  map[api.PropertyName]api.PropertyValue `json:"properties"`
	Labels      []api.Label                            `json:"labels"`
	Title       *string                                `json:"title,omitempty"`
	Description *string                                `json:"description,omitempty"`
	Timestamps  VideoTimestampManifest                 `json:"timestamps"`
	/*
	   The workspace in which to create the video. If not provided, the video will be created in the default workspace for
	   the user's organization, if the default workspace for the organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the video. If not provided, the video will be created in the default workspace for\nthe user's organization, if the default workspace for the organization is configured." json:"workspace,omitempty"`
}

func (o IngestVideoRequest) MarshalJSON() ([]byte, error) {
	if o.Sources == nil {
		o.Sources = make([]IngestSource, 0)
	}
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	type _tmpIngestVideoRequest IngestVideoRequest
	return safejson.Marshal(_tmpIngestVideoRequest(o))
}

func (o *IngestVideoRequest) UnmarshalJSON(data []byte) error {
	type _tmpIngestVideoRequest IngestVideoRequest
	var rawIngestVideoRequest _tmpIngestVideoRequest
	if err := safejson.Unmarshal(data, &rawIngestVideoRequest); err != nil {
		return err
	}
	if rawIngestVideoRequest.Sources == nil {
		rawIngestVideoRequest.Sources = make([]IngestSource, 0)
	}
	if rawIngestVideoRequest.Properties == nil {
		rawIngestVideoRequest.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if rawIngestVideoRequest.Labels == nil {
		rawIngestVideoRequest.Labels = make([]api.Label, 0)
	}
	*o = IngestVideoRequest(rawIngestVideoRequest)
	return nil
}

func (o IngestVideoRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestVideoRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestVideoResponse struct {
	VideoRid     rids.VideoRid     `json:"videoRid"`
	VideoFileRid rids.VideoFileRid `json:"videoFileRid"`
	// Deprecated: Deprecated
	AsyncHandle *AsyncHandle `json:"asyncHandle,omitempty"`
}

func (o IngestVideoResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestVideoResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type InitiateMultipartUploadRequest struct {
	/*
	   The desired name of the file in object storage. The final name will be
	   prefixed with a timestamp to ensure uniqueness.
	*/
	Filename string `conjure-docs:"The desired name of the file in object storage. The final name will be\nprefixed with a timestamp to ensure uniqueness." json:"filename"`
	/*
	   The MIME type of the file, eg "text/csv" for CSVs or "application/octet-stream"
	   for binary files.
	*/
	Filetype string `conjure-docs:"The MIME type of the file, eg \"text/csv\" for CSVs or \"application/octet-stream\"\nfor binary files." json:"filetype"`
	/*
	   The workspace in which to upload the file. If not provided, the file will be uploaded to
	   the default workspace for the user's organization, if that is configured and the user
	   has access to it.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to upload the file. If not provided, the file will be uploaded to\nthe default workspace for the user's organization, if that is configured and the user\nhas access to it." json:"workspace,omitempty"`
}

func (o InitiateMultipartUploadRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *InitiateMultipartUploadRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type InitiateMultipartUploadResponse struct {
	UploadId string `json:"uploadId"`
	Key      string `json:"key"`
	Bucket   string `json:"bucket"`
}

func (o InitiateMultipartUploadResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *InitiateMultipartUploadResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Iso8601Timestamp struct{}

func (o Iso8601Timestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Iso8601Timestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type JournalJsonOpts struct {
	Source IngestSource        `json:"source"`
	Target DatasetIngestTarget `json:"target"`
	/*
	   If provided, ingests logs to the given channel.
	   By default, log data will be ingested to a channel named 'logs'.
	*/
	Channel *api.Channel `conjure-docs:"If provided, ingests logs to the given channel.\nBy default, log data will be ingested to a channel named 'logs'." json:"channel,omitempty"`
}

func (o JournalJsonOpts) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *JournalJsonOpts) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type JournalTimestampMetadata struct {
	FieldName       string         `json:"fieldName"`
	EpochOfTimeUnit EpochTimestamp `json:"epochOfTimeUnit"`
}

func (o JournalTimestampMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *JournalTimestampMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogTime struct{}

func (o LogTime) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogTime) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type McapChannelConfig struct {
	Locator     api.McapChannelLocator `json:"locator"`
	ChannelType McapChannelConfigType  `json:"channelType"`
}

func (o McapChannelConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *McapChannelConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type McapIngestionOutput struct {
	Source McapSource      `json:"source"`
	Target McapDestination `json:"target"`
	/*
	   If the destination points to a video, this will be populated with the video file
	   populated during ingestion.
	*/
	VideoFileRid *rids.VideoFileRid `conjure-docs:"If the destination points to a video, this will be populated with the video file\npopulated during ingestion." json:"videoFileRid,omitempty"`
}

func (o McapIngestionOutput) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *McapIngestionOutput) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type McapProtobufTimeseriesOpts struct {
	Source        IngestSource        `json:"source"`
	Target        DatasetIngestTarget `json:"target"`
	ChannelFilter McapChannels        `json:"channelFilter"`
	TimestampType McapTimestampType   `json:"timestampType"`
}

func (o McapProtobufTimeseriesOpts) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *McapProtobufTimeseriesOpts) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Ingest a channel as video. This requires:
* Using the `foxglove.CompressedVideo` schema
* Protobuf representation of the message data
* Messages are in sequential order in the mcap file
*/
type McapVideoChannelConfig struct{}

func (o McapVideoChannelConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *McapVideoChannelConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NewDataSource struct {
	Source         IngestSource                           `json:"source"`
	Properties     map[api.PropertyName]api.PropertyValue `json:"properties"`
	Labels         []api.Label                            `json:"labels"`
	Description    *string                                `json:"description,omitempty"`
	Name           *string                                `json:"name,omitempty"`
	TimeColumnSpec *TimestampMetadata                     `json:"timeColumnSpec,omitempty"`
	ChannelConfig  *ChannelConfig                         `json:"channelConfig,omitempty"`
}

func (o NewDataSource) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	type _tmpNewDataSource NewDataSource
	return safejson.Marshal(_tmpNewDataSource(o))
}

func (o *NewDataSource) UnmarshalJSON(data []byte) error {
	type _tmpNewDataSource NewDataSource
	var rawNewDataSource _tmpNewDataSource
	if err := safejson.Unmarshal(data, &rawNewDataSource); err != nil {
		return err
	}
	if rawNewDataSource.Properties == nil {
		rawNewDataSource.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if rawNewDataSource.Labels == nil {
		rawNewDataSource.Labels = make([]api.Label, 0)
	}
	*o = NewDataSource(rawNewDataSource)
	return nil
}

func (o NewDataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NewDataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NewDatasetIngestDestination struct {
	DatasetName        *string                                `json:"datasetName,omitempty"`
	DatasetDescription *string                                `json:"datasetDescription,omitempty"`
	Properties         map[api.PropertyName]api.PropertyValue `json:"properties"`
	Labels             []api.Label                            `json:"labels"`
	ChannelConfig      *ChannelConfig                         `json:"channelConfig,omitempty"`
	/*
	   The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for
	   the user's organization, if the default workspace for the organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for\nthe user's organization, if the default workspace for the organization is configured." json:"workspace,omitempty"`
	/*
	   The markings to apply to the created dataset.
	   If not provided, the dataset will be visible to all users in the same workspace.
	*/
	MarkingRids []api2.MarkingRid `conjure-docs:"The markings to apply to the created dataset.\nIf not provided, the dataset will be visible to all users in the same workspace." json:"markingRids"`
}

func (o NewDatasetIngestDestination) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	if o.MarkingRids == nil {
		o.MarkingRids = make([]api2.MarkingRid, 0)
	}
	type _tmpNewDatasetIngestDestination NewDatasetIngestDestination
	return safejson.Marshal(_tmpNewDatasetIngestDestination(o))
}

func (o *NewDatasetIngestDestination) UnmarshalJSON(data []byte) error {
	type _tmpNewDatasetIngestDestination NewDatasetIngestDestination
	var rawNewDatasetIngestDestination _tmpNewDatasetIngestDestination
	if err := safejson.Unmarshal(data, &rawNewDatasetIngestDestination); err != nil {
		return err
	}
	if rawNewDatasetIngestDestination.Properties == nil {
		rawNewDatasetIngestDestination.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if rawNewDatasetIngestDestination.Labels == nil {
		rawNewDatasetIngestDestination.Labels = make([]api.Label, 0)
	}
	if rawNewDatasetIngestDestination.MarkingRids == nil {
		rawNewDatasetIngestDestination.MarkingRids = make([]api2.MarkingRid, 0)
	}
	*o = NewDatasetIngestDestination(rawNewDatasetIngestDestination)
	return nil
}

func (o NewDatasetIngestDestination) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NewDatasetIngestDestination) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NewVideoIngestDestination struct {
	/*
	   Title of the Video that will get created.
	   If not provided, a name is deduced from the ingested file.
	*/
	Title *string `conjure-docs:"Title of the Video that will get created.\nIf not provided, a name is deduced from the ingested file." json:"title,omitempty"`
	// Description that is applied to the newly created video
	Description *string `conjure-docs:"Description that is applied to the newly created video" json:"description,omitempty"`
	// Key-Value properties that are applied to the newly created video
	Properties map[api.PropertyName]api.PropertyValue `conjure-docs:"Key-Value properties that are applied to the newly created video" json:"properties"`
	// Labels that are applied to the newly created video
	Labels []api.Label `conjure-docs:"Labels that are applied to the newly created video" json:"labels"`
	// Metadata to associate with any created video file
	VideoFileDetails *VideoFileIngestDetails `conjure-docs:"Metadata to associate with any created video file" json:"videoFileDetails,omitempty"`
	/*
	   The workspace in which to create the video. If not provided, the video will be created in the default workspace for
	   the user's organization, if the default workspace for the organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the video. If not provided, the video will be created in the default workspace for\nthe user's organization, if the default workspace for the organization is configured." json:"workspace,omitempty"`
	/*
	   The markings to apply to the created video.
	   If not provided, the video will be visible to all users in the same workspace.
	*/
	MarkingRids []api2.MarkingRid `conjure-docs:"The markings to apply to the created video.\nIf not provided, the video will be visible to all users in the same workspace." json:"markingRids"`
}

func (o NewVideoIngestDestination) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	if o.MarkingRids == nil {
		o.MarkingRids = make([]api2.MarkingRid, 0)
	}
	type _tmpNewVideoIngestDestination NewVideoIngestDestination
	return safejson.Marshal(_tmpNewVideoIngestDestination(o))
}

func (o *NewVideoIngestDestination) UnmarshalJSON(data []byte) error {
	type _tmpNewVideoIngestDestination NewVideoIngestDestination
	var rawNewVideoIngestDestination _tmpNewVideoIngestDestination
	if err := safejson.Unmarshal(data, &rawNewVideoIngestDestination); err != nil {
		return err
	}
	if rawNewVideoIngestDestination.Properties == nil {
		rawNewVideoIngestDestination.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if rawNewVideoIngestDestination.Labels == nil {
		rawNewVideoIngestDestination.Labels = make([]api.Label, 0)
	}
	if rawNewVideoIngestDestination.MarkingRids == nil {
		rawNewVideoIngestDestination.MarkingRids = make([]api2.MarkingRid, 0)
	}
	*o = NewVideoIngestDestination(rawNewVideoIngestDestination)
	return nil
}

func (o NewVideoIngestDestination) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NewVideoIngestDestination) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NoTimestampManifest struct {
	StartingTimestamp UtcTimestamp `json:"startingTimestamp"`
	// A field that specifies that the frame rate of the video does not match the frame rate of the camera | i.e. a slowed down or sped up video. Can specify either the camera frame rate or the absolute end time.
	ScaleParameter *ScaleParameter `conjure-docs:"A field that specifies that the frame rate of the video does not match the frame rate of the camera | i.e. a slowed down or sped up video. Can specify either the camera frame rate or the absolute end time." json:"scaleParameter,omitempty"`
}

func (o NoTimestampManifest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NoTimestampManifest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Options for ingesting parquet files.
Supported file formats include .parquet, .parquet.gz
and archives such as .tar, .tar.gz, and .zip (must set the isArchive flag).
*/
type ParquetOpts struct {
	Source            IngestSource        `json:"source"`
	Target            DatasetIngestTarget `json:"target"`
	TimestampMetadata TimestampMetadata   `json:"timestampMetadata"`
	ChannelPrefix     ChannelPrefix       `json:"channelPrefix"`
	// Deprecated: Deprecated in favor of tagColumns.
	TagKeysFromColumns *[]api.TagName `json:"tagKeysFromColumns,omitempty"`
	// A map of tag names to column names to derive the tag values from.
	TagColumns *map[api.TagName]api.ColumnName `conjure-docs:"A map of tag names to column names to derive the tag values from." json:"tagColumns,omitempty"`
	// Specifies a tag set to apply to all data in the file.
	AdditionalFileTags *map[api.TagName]api.TagValue `conjure-docs:"Specifies a tag set to apply to all data in the file." json:"additionalFileTags,omitempty"`
	/*
	   If true, the file is an archive. Supported archive formats include
	   .tar, .tar.gz, and .zip. Only files ending in .parquet
	   within the archive will be ingested. If field not provided, defaults to false.
	*/
	IsArchive *bool `conjure-docs:"If true, the file is an archive. Supported archive formats include\n.tar, .tar.gz, and .zip. Only files ending in .parquet\nwithin the archive will be ingested. If field not provided, defaults to false." json:"isArchive,omitempty"`
}

func (o ParquetOpts) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ParquetOpts) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Part struct {
	PartNumber int    `json:"partNumber"`
	Etag       string `json:"etag"`
}

func (o Part) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Part) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PartWithSize struct {
	PartNumber int               `json:"partNumber"`
	Etag       string            `json:"etag"`
	Size       safelong.SafeLong `json:"size"`
}

func (o PartWithSize) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PartWithSize) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PublicAuthentication struct{}

func (o PublicAuthentication) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PublicAuthentication) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RegisterContainerizedExtractorRequest struct {
	Name        string            `json:"name"`
	Description *string           `json:"description,omitempty"`
	Image       DockerImageSource `json:"image"`
	// payload must match input defined in containerized extraction
	Inputs     []FileExtractionInput                  `conjure-docs:"payload must match input defined in containerized extraction" json:"inputs"`
	Properties map[api.PropertyName]api.PropertyValue `json:"properties"`
	Labels     []api.Label                            `json:"labels"`
	// The workspace in which to create the extractor
	Workspace rids.WorkspaceRid `conjure-docs:"The workspace in which to create the extractor" json:"workspace"`
	// Metadata about the intermediate parquet this extractor will produce
	TimestampMetadata TimestampMetadata `conjure-docs:"Metadata about the intermediate parquet this extractor will produce" json:"timestampMetadata"`
	// The format of the output file. Currently only "parquet", "csv", "parquet.tar" are supported
	OutputFileFormat *FileOutputFormat `conjure-docs:"The format of the output file. Currently only \"parquet\", \"csv\", \"parquet.tar\" are supported" json:"outputFileFormat,omitempty"`
}

func (o RegisterContainerizedExtractorRequest) MarshalJSON() ([]byte, error) {
	if o.Inputs == nil {
		o.Inputs = make([]FileExtractionInput, 0)
	}
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	type _tmpRegisterContainerizedExtractorRequest RegisterContainerizedExtractorRequest
	return safejson.Marshal(_tmpRegisterContainerizedExtractorRequest(o))
}

func (o *RegisterContainerizedExtractorRequest) UnmarshalJSON(data []byte) error {
	type _tmpRegisterContainerizedExtractorRequest RegisterContainerizedExtractorRequest
	var rawRegisterContainerizedExtractorRequest _tmpRegisterContainerizedExtractorRequest
	if err := safejson.Unmarshal(data, &rawRegisterContainerizedExtractorRequest); err != nil {
		return err
	}
	if rawRegisterContainerizedExtractorRequest.Inputs == nil {
		rawRegisterContainerizedExtractorRequest.Inputs = make([]FileExtractionInput, 0)
	}
	if rawRegisterContainerizedExtractorRequest.Properties == nil {
		rawRegisterContainerizedExtractorRequest.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if rawRegisterContainerizedExtractorRequest.Labels == nil {
		rawRegisterContainerizedExtractorRequest.Labels = make([]api.Label, 0)
	}
	*o = RegisterContainerizedExtractorRequest(rawRegisterContainerizedExtractorRequest)
	return nil
}

func (o RegisterContainerizedExtractorRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RegisterContainerizedExtractorRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RegisterContainerizedExtractorResponse struct {
	ExtractorRid ContainerizedExtractorRid `json:"extractorRid"`
}

func (o RegisterContainerizedExtractorResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RegisterContainerizedExtractorResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ReingestDatasetsRequest struct {
	/*
	   The datasets to reingest data from. Can only include tagless, non-streaming datasets (V1).
	   The datasets must be of the same granularity and must only include CSV or Parquet files.
	   Will attempt to reingest from datasets in list order.
	*/
	SourceDatasets []rids.DatasetRid `conjure-docs:"The datasets to reingest data from. Can only include tagless, non-streaming datasets (V1).\nThe datasets must be of the same granularity and must only include CSV or Parquet files.\nWill attempt to reingest from datasets in list order." json:"sourceDatasets"`
	// The dataset to ingest data into. Can either be a new dataset or an existing dataset RID.
	TargetDataset DatasetIngestTarget `conjure-docs:"The dataset to ingest data into. Can either be a new dataset or an existing dataset RID." json:"targetDataset"`
	/*
	   Mapping of dataset to ingest metadata.
	   Ingest metadata only needs to be provided in request if it cannot be recovered from prior ingests.
	   See documentation on each field to determine what metadata can be auto-recovered.
	*/
	IngestMetadata map[rids.DatasetRid]IngestMetadata `conjure-docs:"Mapping of dataset to ingest metadata.\nIngest metadata only needs to be provided in request if it cannot be recovered from prior ingests.\nSee documentation on each field to determine what metadata can be auto-recovered." json:"ingestMetadata"`
}

func (o ReingestDatasetsRequest) MarshalJSON() ([]byte, error) {
	if o.SourceDatasets == nil {
		o.SourceDatasets = make([]rids.DatasetRid, 0)
	}
	if o.IngestMetadata == nil {
		o.IngestMetadata = make(map[rids.DatasetRid]IngestMetadata, 0)
	}
	type _tmpReingestDatasetsRequest ReingestDatasetsRequest
	return safejson.Marshal(_tmpReingestDatasetsRequest(o))
}

func (o *ReingestDatasetsRequest) UnmarshalJSON(data []byte) error {
	type _tmpReingestDatasetsRequest ReingestDatasetsRequest
	var rawReingestDatasetsRequest _tmpReingestDatasetsRequest
	if err := safejson.Unmarshal(data, &rawReingestDatasetsRequest); err != nil {
		return err
	}
	if rawReingestDatasetsRequest.SourceDatasets == nil {
		rawReingestDatasetsRequest.SourceDatasets = make([]rids.DatasetRid, 0)
	}
	if rawReingestDatasetsRequest.IngestMetadata == nil {
		rawReingestDatasetsRequest.IngestMetadata = make(map[rids.DatasetRid]IngestMetadata, 0)
	}
	*o = ReingestDatasetsRequest(rawReingestDatasetsRequest)
	return nil
}

func (o ReingestDatasetsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ReingestDatasetsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The response to a reingest request.
Maps the source dataset RID and file ID to the destination dataset RID and file ID.
*/
type ReingestDatasetsResponse struct {
	Datasets map[rids.DatasetRid]ReingestFilesMapping `json:"datasets"`
}

func (o ReingestDatasetsResponse) MarshalJSON() ([]byte, error) {
	if o.Datasets == nil {
		o.Datasets = make(map[rids.DatasetRid]ReingestFilesMapping, 0)
	}
	type _tmpReingestDatasetsResponse ReingestDatasetsResponse
	return safejson.Marshal(_tmpReingestDatasetsResponse(o))
}

func (o *ReingestDatasetsResponse) UnmarshalJSON(data []byte) error {
	type _tmpReingestDatasetsResponse ReingestDatasetsResponse
	var rawReingestDatasetsResponse _tmpReingestDatasetsResponse
	if err := safejson.Unmarshal(data, &rawReingestDatasetsResponse); err != nil {
		return err
	}
	if rawReingestDatasetsResponse.Datasets == nil {
		rawReingestDatasetsResponse.Datasets = make(map[rids.DatasetRid]ReingestFilesMapping, 0)
	}
	*o = ReingestDatasetsResponse(rawReingestDatasetsResponse)
	return nil
}

func (o ReingestDatasetsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ReingestDatasetsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Maps the source dataset file ID to the destination dataset and file ID.
type ReingestFilesMapping struct {
	FileMap map[datasource.DatasetFileId]IngestDetails `json:"fileMap"`
}

func (o ReingestFilesMapping) MarshalJSON() ([]byte, error) {
	if o.FileMap == nil {
		o.FileMap = make(map[datasource.DatasetFileId]IngestDetails, 0)
	}
	type _tmpReingestFilesMapping ReingestFilesMapping
	return safejson.Marshal(_tmpReingestFilesMapping(o))
}

func (o *ReingestFilesMapping) UnmarshalJSON(data []byte) error {
	type _tmpReingestFilesMapping ReingestFilesMapping
	var rawReingestFilesMapping _tmpReingestFilesMapping
	if err := safejson.Unmarshal(data, &rawReingestFilesMapping); err != nil {
		return err
	}
	if rawReingestFilesMapping.FileMap == nil {
		rawReingestFilesMapping.FileMap = make(map[datasource.DatasetFileId]IngestDetails, 0)
	}
	*o = ReingestFilesMapping(rawReingestFilesMapping)
	return nil
}

func (o ReingestFilesMapping) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ReingestFilesMapping) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RelativeTimestamp struct {
	TimeUnit api.TimeUnit `json:"timeUnit"`
	// Starting timestamp to use when indexing the file. This field is required when uploading a new file to an existing dataset.
	Offset *datetime.DateTime `conjure-docs:"Starting timestamp to use when indexing the file. This field is required when uploading a new file to an existing dataset." json:"offset,omitempty"`
}

func (o RelativeTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RelativeTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type RerunIngestRequest struct {
	IngestJobRid IngestJobRid `json:"ingestJobRid"`
}

func (o RerunIngestRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RerunIngestRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type S3IngestSource struct {
	Path string `json:"path"`
}

func (o S3IngestSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *S3IngestSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchContainerizedExtractorsRequest struct {
	Query SearchContainerizedExtractorsQuery `json:"query"`
}

func (o SearchContainerizedExtractorsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchContainerizedExtractorsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SignPartResponse struct {
	Url     string            `json:"url"`
	Headers map[string]string `json:"headers"`
}

func (o SignPartResponse) MarshalJSON() ([]byte, error) {
	if o.Headers == nil {
		o.Headers = make(map[string]string, 0)
	}
	type _tmpSignPartResponse SignPartResponse
	return safejson.Marshal(_tmpSignPartResponse(o))
}

func (o *SignPartResponse) UnmarshalJSON(data []byte) error {
	type _tmpSignPartResponse SignPartResponse
	var rawSignPartResponse _tmpSignPartResponse
	if err := safejson.Unmarshal(data, &rawSignPartResponse); err != nil {
		return err
	}
	if rawSignPartResponse.Headers == nil {
		rawSignPartResponse.Headers = make(map[string]string, 0)
	}
	*o = SignPartResponse(rawSignPartResponse)
	return nil
}

func (o SignPartResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SignPartResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SkipRowsConfig struct {
	HeaderRowIndex    int `json:"headerRowIndex"`
	DataStartRowIndex int `json:"dataStartRowIndex"`
}

func (o SkipRowsConfig) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SkipRowsConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TagDetails struct {
	Tags       []string `json:"tags"`
	DefaultTag string   `json:"defaultTag"`
}

func (o TagDetails) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make([]string, 0)
	}
	type _tmpTagDetails TagDetails
	return safejson.Marshal(_tmpTagDetails(o))
}

func (o *TagDetails) UnmarshalJSON(data []byte) error {
	type _tmpTagDetails TagDetails
	var rawTagDetails _tmpTagDetails
	if err := safejson.Unmarshal(data, &rawTagDetails); err != nil {
		return err
	}
	if rawTagDetails.Tags == nil {
		rawTagDetails.Tags = make([]string, 0)
	}
	*o = TagDetails(rawTagDetails)
	return nil
}

func (o TagDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TagDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
The timestamp manifest files will contain a list of absolute timestamps, in nanoseconds, that correspond to
each frame in a video. Each file should be of type JSON and store a single list, the length of which equals
the number of frames in its corresponding video.
*/
type TimestampManifest struct {
	Sources []IngestSource `json:"sources"`
}

func (o TimestampManifest) MarshalJSON() ([]byte, error) {
	if o.Sources == nil {
		o.Sources = make([]IngestSource, 0)
	}
	type _tmpTimestampManifest TimestampManifest
	return safejson.Marshal(_tmpTimestampManifest(o))
}

func (o *TimestampManifest) UnmarshalJSON(data []byte) error {
	type _tmpTimestampManifest TimestampManifest
	var rawTimestampManifest _tmpTimestampManifest
	if err := safejson.Unmarshal(data, &rawTimestampManifest); err != nil {
		return err
	}
	if rawTimestampManifest.Sources == nil {
		rawTimestampManifest.Sources = make([]IngestSource, 0)
	}
	*o = TimestampManifest(rawTimestampManifest)
	return nil
}

func (o TimestampManifest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimestampManifest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimestampMetadata struct {
	SeriesName    string        `json:"seriesName"`
	TimestampType TimestampType `json:"timestampType"`
}

func (o TimestampMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimestampMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TriggerFileIngest struct {
	/*
	   Source data for the ingest. Supported file types include:
	     * CSV (*.csv)
	     * Compressed CSV (*.csv.gz)
	     * Parquet (*.parquet)
	     * Parquet archives (*.parquet.tar, *.parquet.tar.gz, *.parquet.zip).
	         Note that timestamp column must have the same name and format across files.
	         Non parquet files will be ignored.
	         Each file can contribute to the overall schema, but conflicting types will fail the ingest.
	         Conflicting values (same timestamp, column) across files will be de-conflicted based on archive file ordering (first point taken)
	*/
	Source         IngestSource         `conjure-docs:"Source data for the ingest. Supported file types include:\n  * CSV (*.csv)\n  * Compressed CSV (*.csv.gz)\n  * Parquet (*.parquet)\n  * Parquet archives (*.parquet.tar, *.parquet.tar.gz, *.parquet.zip).\n      Note that timestamp column must have the same name and format across files.\n      Non parquet files will be ignored.\n      Each file can contribute to the overall schema, but conflicting types will fail the ingest.\n      Conflicting values (same timestamp, column) across files will be de-conflicted based on archive file ordering (first point taken)" json:"source"`
	SourceMetadata IngestSourceMetadata `json:"sourceMetadata"`
	Destination    IngestDestination    `json:"destination"`
}

func (o TriggerFileIngest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TriggerFileIngest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TriggerIngest struct {
	Source             IngestSource                           `json:"source"`
	Properties         map[api.PropertyName]api.PropertyValue `json:"properties"`
	Labels             []api.Label                            `json:"labels"`
	DatasetName        *string                                `json:"datasetName,omitempty"`
	DatasetDescription *string                                `json:"datasetDescription,omitempty"`
	TimestampMetadata  *TimestampMetadata                     `json:"timestampMetadata,omitempty"`
	// If absent, will default to a channel config that constructs a prefix tree with `.` as the delimiter.
	ChannelConfig *ChannelConfig `conjure-docs:"If absent, will default to a channel config that constructs a prefix tree with \".\" as the delimiter." json:"channelConfig,omitempty"`
	/*
	   The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for
	   the user's organization, if the default workspace for the organization is configured.
	*/
	Workspace *rids.WorkspaceRid `conjure-docs:"The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for\nthe user's organization, if the default workspace for the organization is configured." json:"workspace,omitempty"`
}

func (o TriggerIngest) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if o.Labels == nil {
		o.Labels = make([]api.Label, 0)
	}
	type _tmpTriggerIngest TriggerIngest
	return safejson.Marshal(_tmpTriggerIngest(o))
}

func (o *TriggerIngest) UnmarshalJSON(data []byte) error {
	type _tmpTriggerIngest TriggerIngest
	var rawTriggerIngest _tmpTriggerIngest
	if err := safejson.Unmarshal(data, &rawTriggerIngest); err != nil {
		return err
	}
	if rawTriggerIngest.Properties == nil {
		rawTriggerIngest.Properties = make(map[api.PropertyName]api.PropertyValue, 0)
	}
	if rawTriggerIngest.Labels == nil {
		rawTriggerIngest.Labels = make([]api.Label, 0)
	}
	*o = TriggerIngest(rawTriggerIngest)
	return nil
}

func (o TriggerIngest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TriggerIngest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TriggeredIngest struct {
	DatasetRid    rid.ResourceIdentifier `json:"datasetRid"`
	DatasetFileId *uuid.UUID             `json:"datasetFileId,omitempty"`
	AsyncHandle   *AsyncHandle           `json:"asyncHandle,omitempty"`
}

func (o TriggeredIngest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TriggeredIngest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateContainerizedExtractorRequest struct {
	Name              *string                                 `json:"name,omitempty"`
	Description       *string                                 `json:"description,omitempty"`
	Inputs            *[]FileExtractionInput                  `json:"inputs,omitempty"`
	Properties        *map[api.PropertyName]api.PropertyValue `json:"properties,omitempty"`
	Labels            *[]api.Label                            `json:"labels,omitempty"`
	TimestampMetadata *TimestampMetadata                      `json:"timestampMetadata,omitempty"`
	OutputFileFormat  *FileOutputFormat                       `json:"outputFileFormat,omitempty"`
	Tags              *[]string                               `json:"tags,omitempty"`
	DefaultTag        *string                                 `json:"defaultTag,omitempty"`
	Authentication    *Authentication                         `json:"authentication,omitempty"`
	Command           *string                                 `json:"command,omitempty"`
}

func (o UpdateContainerizedExtractorRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateContainerizedExtractorRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Username and password authentication.
type UserAndPasswordAuthentication struct {
	// Username for registry authentication.
	Username string `conjure-docs:"Username for registry authentication." json:"username"`
	// The RID of the secret containing the password for registry authentication.
	PasswordSecretRid api3.SecretRid `conjure-docs:"The RID of the secret containing the password for registry authentication." json:"passwordSecretRid"`
}

func (o UserAndPasswordAuthentication) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UserAndPasswordAuthentication) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UtcTimestamp struct {
	SecondsSinceEpoch safelong.SafeLong  `json:"secondsSinceEpoch"`
	OffsetNanoseconds *safelong.SafeLong `json:"offsetNanoseconds,omitempty"`
}

func (o UtcTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UtcTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type VideoFileIngestDetails struct {
	/*
	   Description that is applied to the newly created video file.
	   If not provided, defaults to the description used to create the video.
	*/
	FileDescription *string `conjure-docs:"Description that is applied to the newly created video file.\nIf not provided, defaults to the description used to create the video." json:"fileDescription,omitempty"`
	/*
	   Key-Value properties that are applied to the newly created video file.

	   Deprecated: Field is ignored as video files do not have properties.
	   Will be removed after 4/5/2025
	*/
	FileProperties *map[api.PropertyName]api.PropertyValue `conjure-docs:"Key-Value properties that are applied to the newly created video file." json:"fileProperties,omitempty"`
	/*
	   Labels that are applied to the newly created video file.

	   Deprecated: Field is ignored as video files do not have labels.
	   Will be removed after 4/5/2025
	*/
	FileLabels *[]api.Label `conjure-docs:"Labels that are applied to the newly created video file." json:"fileLabels,omitempty"`
}

func (o VideoFileIngestDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VideoFileIngestDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type VideoOpts struct {
	Source            IngestSource                    `json:"source"`
	Target            VideoIngestTarget               `json:"target"`
	TimestampManifest api4.VideoFileTimestampManifest `json:"timestampManifest"`
}

func (o VideoOpts) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VideoOpts) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
