// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/run/api"
	"github.com/palantir/pkg/rid"
)

type AbsoluteTimestampWithT[T any] AbsoluteTimestamp

func (u *AbsoluteTimestampWithT[T]) Accept(ctx context.Context, v AbsoluteTimestampVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return result, fmt.Errorf("field \"iso8601\" is required")
		}
		return v.VisitIso8601(ctx, *u.iso8601)
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return result, fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return v.VisitEpochOfTimeUnit(ctx, *u.epochOfTimeUnit)
	case "customFormat":
		if u.customFormat == nil {
			return result, fmt.Errorf("field \"customFormat\" is required")
		}
		return v.VisitCustomFormat(ctx, *u.customFormat)
	}
}

func (u *AbsoluteTimestampWithT[T]) AcceptFuncs(iso8601Func func(Iso8601Timestamp) (T, error), epochOfTimeUnitFunc func(EpochTimestamp) (T, error), customFormatFunc func(CustomTimestamp) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return result, fmt.Errorf("field \"iso8601\" is required")
		}
		return iso8601Func(*u.iso8601)
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return result, fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return epochOfTimeUnitFunc(*u.epochOfTimeUnit)
	case "customFormat":
		if u.customFormat == nil {
			return result, fmt.Errorf("field \"customFormat\" is required")
		}
		return customFormatFunc(*u.customFormat)
	}
}

func (u *AbsoluteTimestampWithT[T]) Iso8601NoopSuccess(Iso8601Timestamp) (T, error) {
	var result T
	return result, nil
}

func (u *AbsoluteTimestampWithT[T]) EpochOfTimeUnitNoopSuccess(EpochTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *AbsoluteTimestampWithT[T]) CustomFormatNoopSuccess(CustomTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *AbsoluteTimestampWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type AbsoluteTimestampVisitorWithT[T any] interface {
	VisitIso8601(ctx context.Context, v Iso8601Timestamp) (T, error)
	VisitEpochOfTimeUnit(ctx context.Context, v EpochTimestamp) (T, error)
	VisitCustomFormat(ctx context.Context, v CustomTimestamp) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type AuthenticationWithT[T any] Authentication

func (u *AuthenticationWithT[T]) Accept(ctx context.Context, v AuthenticationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "userAndPassword":
		if u.userAndPassword == nil {
			return result, fmt.Errorf("field \"userAndPassword\" is required")
		}
		return v.VisitUserAndPassword(ctx, *u.userAndPassword)
	case "public":
		if u.public == nil {
			return result, fmt.Errorf("field \"public\" is required")
		}
		return v.VisitPublic(ctx, *u.public)
	}
}

func (u *AuthenticationWithT[T]) AcceptFuncs(userAndPasswordFunc func(UserAndPasswordAuthentication) (T, error), publicFunc func(PublicAuthentication) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "userAndPassword":
		if u.userAndPassword == nil {
			return result, fmt.Errorf("field \"userAndPassword\" is required")
		}
		return userAndPasswordFunc(*u.userAndPassword)
	case "public":
		if u.public == nil {
			return result, fmt.Errorf("field \"public\" is required")
		}
		return publicFunc(*u.public)
	}
}

func (u *AuthenticationWithT[T]) UserAndPasswordNoopSuccess(UserAndPasswordAuthentication) (T, error) {
	var result T
	return result, nil
}

func (u *AuthenticationWithT[T]) PublicNoopSuccess(PublicAuthentication) (T, error) {
	var result T
	return result, nil
}

func (u *AuthenticationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type AuthenticationVisitorWithT[T any] interface {
	VisitUserAndPassword(ctx context.Context, v UserAndPasswordAuthentication) (T, error)
	VisitPublic(ctx context.Context, v PublicAuthentication) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type DatasetIngestTargetWithT[T any] DatasetIngestTarget

func (u *DatasetIngestTargetWithT[T]) Accept(ctx context.Context, v DatasetIngestTargetVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "new":
		if u.new == nil {
			return result, fmt.Errorf("field \"new\" is required")
		}
		return v.VisitNew(ctx, *u.new)
	case "existing":
		if u.existing == nil {
			return result, fmt.Errorf("field \"existing\" is required")
		}
		return v.VisitExisting(ctx, *u.existing)
	}
}

func (u *DatasetIngestTargetWithT[T]) AcceptFuncs(newFunc func(NewDatasetIngestDestination) (T, error), existingFunc func(ExistingDatasetIngestDestination) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "new":
		if u.new == nil {
			return result, fmt.Errorf("field \"new\" is required")
		}
		return newFunc(*u.new)
	case "existing":
		if u.existing == nil {
			return result, fmt.Errorf("field \"existing\" is required")
		}
		return existingFunc(*u.existing)
	}
}

func (u *DatasetIngestTargetWithT[T]) NewNoopSuccess(NewDatasetIngestDestination) (T, error) {
	var result T
	return result, nil
}

func (u *DatasetIngestTargetWithT[T]) ExistingNoopSuccess(ExistingDatasetIngestDestination) (T, error) {
	var result T
	return result, nil
}

func (u *DatasetIngestTargetWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DatasetIngestTargetVisitorWithT[T any] interface {
	VisitNew(ctx context.Context, v NewDatasetIngestDestination) (T, error)
	VisitExisting(ctx context.Context, v ExistingDatasetIngestDestination) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type DeprecatedNewDataSourceWithT[T any] DeprecatedNewDataSource

func (u *DeprecatedNewDataSourceWithT[T]) Accept(ctx context.Context, v DeprecatedNewDataSourceVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "csv":
		if u.csv == nil {
			return result, fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsv(ctx, *u.csv)
	}
}

func (u *DeprecatedNewDataSourceWithT[T]) AcceptFuncs(csvFunc func(DeprecatedNewCsv) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "csv":
		if u.csv == nil {
			return result, fmt.Errorf("field \"csv\" is required")
		}
		return csvFunc(*u.csv)
	}
}

func (u *DeprecatedNewDataSourceWithT[T]) CsvNoopSuccess(DeprecatedNewCsv) (T, error) {
	var result T
	return result, nil
}

func (u *DeprecatedNewDataSourceWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type DeprecatedNewDataSourceVisitorWithT[T any] interface {
	VisitCsv(ctx context.Context, v DeprecatedNewCsv) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type FileFilterWithT[T any] FileFilter

func (u *FileFilterWithT[T]) Accept(ctx context.Context, v FileFilterVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "suffix":
		if u.suffix == nil {
			return result, fmt.Errorf("field \"suffix\" is required")
		}
		return v.VisitSuffix(ctx, *u.suffix)
	}
}

func (u *FileFilterWithT[T]) AcceptFuncs(suffixFunc func(FileSuffix) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "suffix":
		if u.suffix == nil {
			return result, fmt.Errorf("field \"suffix\" is required")
		}
		return suffixFunc(*u.suffix)
	}
}

func (u *FileFilterWithT[T]) SuffixNoopSuccess(FileSuffix) (T, error) {
	var result T
	return result, nil
}

func (u *FileFilterWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FileFilterVisitorWithT[T any] interface {
	VisitSuffix(ctx context.Context, v FileSuffix) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type IngestDataSourceWithT[T any] IngestDataSource

func (u *IngestDataSourceWithT[T]) Accept(ctx context.Context, v IngestDataSourceVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "existingDataSource":
		if u.existingDataSource == nil {
			return result, fmt.Errorf("field \"existingDataSource\" is required")
		}
		return v.VisitExistingDataSource(ctx, *u.existingDataSource)
	case "newDataSource":
		if u.newDataSource == nil {
			return result, fmt.Errorf("field \"newDataSource\" is required")
		}
		return v.VisitNewDataSource(ctx, *u.newDataSource)
	case "newDataSourceV2":
		if u.newDataSourceV2 == nil {
			return result, fmt.Errorf("field \"newDataSourceV2\" is required")
		}
		return v.VisitNewDataSourceV2(ctx, *u.newDataSourceV2)
	}
}

func (u *IngestDataSourceWithT[T]) AcceptFuncs(existingDataSourceFunc func(rids.DataSourceRid) (T, error), newDataSourceFunc func(DeprecatedNewDataSource) (T, error), newDataSourceV2Func func(NewDataSource) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "existingDataSource":
		if u.existingDataSource == nil {
			return result, fmt.Errorf("field \"existingDataSource\" is required")
		}
		return existingDataSourceFunc(*u.existingDataSource)
	case "newDataSource":
		if u.newDataSource == nil {
			return result, fmt.Errorf("field \"newDataSource\" is required")
		}
		return newDataSourceFunc(*u.newDataSource)
	case "newDataSourceV2":
		if u.newDataSourceV2 == nil {
			return result, fmt.Errorf("field \"newDataSourceV2\" is required")
		}
		return newDataSourceV2Func(*u.newDataSourceV2)
	}
}

func (u *IngestDataSourceWithT[T]) ExistingDataSourceNoopSuccess(rids.DataSourceRid) (T, error) {
	var result T
	return result, nil
}

func (u *IngestDataSourceWithT[T]) NewDataSourceNoopSuccess(DeprecatedNewDataSource) (T, error) {
	var result T
	return result, nil
}

func (u *IngestDataSourceWithT[T]) NewDataSourceV2NoopSuccess(NewDataSource) (T, error) {
	var result T
	return result, nil
}

func (u *IngestDataSourceWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type IngestDataSourceVisitorWithT[T any] interface {
	VisitExistingDataSource(ctx context.Context, v rids.DataSourceRid) (T, error)
	VisitNewDataSource(ctx context.Context, v DeprecatedNewDataSource) (T, error)
	VisitNewDataSourceV2(ctx context.Context, v NewDataSource) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type IngestDestinationWithT[T any] IngestDestination

func (u *IngestDestinationWithT[T]) Accept(ctx context.Context, v IngestDestinationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "newDataset":
		if u.newDataset == nil {
			return result, fmt.Errorf("field \"newDataset\" is required")
		}
		return v.VisitNewDataset(ctx, *u.newDataset)
	case "existingDataset":
		if u.existingDataset == nil {
			return result, fmt.Errorf("field \"existingDataset\" is required")
		}
		return v.VisitExistingDataset(ctx, *u.existingDataset)
	}
}

func (u *IngestDestinationWithT[T]) AcceptFuncs(newDatasetFunc func(NewDatasetIngestDestination) (T, error), existingDatasetFunc func(ExistingDatasetIngestDestination) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "newDataset":
		if u.newDataset == nil {
			return result, fmt.Errorf("field \"newDataset\" is required")
		}
		return newDatasetFunc(*u.newDataset)
	case "existingDataset":
		if u.existingDataset == nil {
			return result, fmt.Errorf("field \"existingDataset\" is required")
		}
		return existingDatasetFunc(*u.existingDataset)
	}
}

func (u *IngestDestinationWithT[T]) NewDatasetNoopSuccess(NewDatasetIngestDestination) (T, error) {
	var result T
	return result, nil
}

func (u *IngestDestinationWithT[T]) ExistingDatasetNoopSuccess(ExistingDatasetIngestDestination) (T, error) {
	var result T
	return result, nil
}

func (u *IngestDestinationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type IngestDestinationVisitorWithT[T any] interface {
	VisitNewDataset(ctx context.Context, v NewDatasetIngestDestination) (T, error)
	VisitExistingDataset(ctx context.Context, v ExistingDatasetIngestDestination) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type IngestDetailsWithT[T any] IngestDetails

func (u *IngestDetailsWithT[T]) Accept(ctx context.Context, v IngestDetailsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "dataset":
		if u.dataset == nil {
			return result, fmt.Errorf("field \"dataset\" is required")
		}
		return v.VisitDataset(ctx, *u.dataset)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(ctx, *u.video)
	}
}

func (u *IngestDetailsWithT[T]) AcceptFuncs(datasetFunc func(IngestDatasetFileDetails) (T, error), videoFunc func(IngestVideoFileDetails) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dataset":
		if u.dataset == nil {
			return result, fmt.Errorf("field \"dataset\" is required")
		}
		return datasetFunc(*u.dataset)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	}
}

func (u *IngestDetailsWithT[T]) DatasetNoopSuccess(IngestDatasetFileDetails) (T, error) {
	var result T
	return result, nil
}

func (u *IngestDetailsWithT[T]) VideoNoopSuccess(IngestVideoFileDetails) (T, error) {
	var result T
	return result, nil
}

func (u *IngestDetailsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type IngestDetailsVisitorWithT[T any] interface {
	VisitDataset(ctx context.Context, v IngestDatasetFileDetails) (T, error)
	VisitVideo(ctx context.Context, v IngestVideoFileDetails) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type IngestJobRequestWithT[T any] IngestJobRequest

func (u *IngestJobRequestWithT[T]) Accept(ctx context.Context, v IngestJobRequestVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "ingestMcap":
		if u.ingestMcap == nil {
			return result, fmt.Errorf("field \"ingestMcap\" is required")
		}
		return v.VisitIngestMcap(ctx, *u.ingestMcap)
	case "triggerFileIngest":
		if u.triggerFileIngest == nil {
			return result, fmt.Errorf("field \"triggerFileIngest\" is required")
		}
		return v.VisitTriggerFileIngest(ctx, *u.triggerFileIngest)
	case "ingestRequest":
		if u.ingestRequest == nil {
			return result, fmt.Errorf("field \"ingestRequest\" is required")
		}
		return v.VisitIngestRequest(ctx, *u.ingestRequest)
	case "triggerIngest":
		if u.triggerIngest == nil {
			return result, fmt.Errorf("field \"triggerIngest\" is required")
		}
		return v.VisitTriggerIngest(ctx, *u.triggerIngest)
	}
}

func (u *IngestJobRequestWithT[T]) AcceptFuncs(ingestMcapFunc func(IngestMcapRequest) (T, error), triggerFileIngestFunc func(TriggerFileIngest) (T, error), ingestRequestFunc func(IngestRequest) (T, error), triggerIngestFunc func(TriggerIngest) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ingestMcap":
		if u.ingestMcap == nil {
			return result, fmt.Errorf("field \"ingestMcap\" is required")
		}
		return ingestMcapFunc(*u.ingestMcap)
	case "triggerFileIngest":
		if u.triggerFileIngest == nil {
			return result, fmt.Errorf("field \"triggerFileIngest\" is required")
		}
		return triggerFileIngestFunc(*u.triggerFileIngest)
	case "ingestRequest":
		if u.ingestRequest == nil {
			return result, fmt.Errorf("field \"ingestRequest\" is required")
		}
		return ingestRequestFunc(*u.ingestRequest)
	case "triggerIngest":
		if u.triggerIngest == nil {
			return result, fmt.Errorf("field \"triggerIngest\" is required")
		}
		return triggerIngestFunc(*u.triggerIngest)
	}
}

func (u *IngestJobRequestWithT[T]) IngestMcapNoopSuccess(IngestMcapRequest) (T, error) {
	var result T
	return result, nil
}

func (u *IngestJobRequestWithT[T]) TriggerFileIngestNoopSuccess(TriggerFileIngest) (T, error) {
	var result T
	return result, nil
}

func (u *IngestJobRequestWithT[T]) IngestRequestNoopSuccess(IngestRequest) (T, error) {
	var result T
	return result, nil
}

func (u *IngestJobRequestWithT[T]) TriggerIngestNoopSuccess(TriggerIngest) (T, error) {
	var result T
	return result, nil
}

func (u *IngestJobRequestWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type IngestJobRequestVisitorWithT[T any] interface {
	VisitIngestMcap(ctx context.Context, v IngestMcapRequest) (T, error)
	VisitTriggerFileIngest(ctx context.Context, v TriggerFileIngest) (T, error)
	VisitIngestRequest(ctx context.Context, v IngestRequest) (T, error)
	VisitTriggerIngest(ctx context.Context, v TriggerIngest) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type IngestOptionsWithT[T any] IngestOptions

func (u *IngestOptionsWithT[T]) Accept(ctx context.Context, v IngestOptionsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "dataflash":
		if u.dataflash == nil {
			return result, fmt.Errorf("field \"dataflash\" is required")
		}
		return v.VisitDataflash(ctx, *u.dataflash)
	case "mcapProtobufTimeseries":
		if u.mcapProtobufTimeseries == nil {
			return result, fmt.Errorf("field \"mcapProtobufTimeseries\" is required")
		}
		return v.VisitMcapProtobufTimeseries(ctx, *u.mcapProtobufTimeseries)
	case "journalJson":
		if u.journalJson == nil {
			return result, fmt.Errorf("field \"journalJson\" is required")
		}
		return v.VisitJournalJson(ctx, *u.journalJson)
	case "csv":
		if u.csv == nil {
			return result, fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsv(ctx, *u.csv)
	case "parquet":
		if u.parquet == nil {
			return result, fmt.Errorf("field \"parquet\" is required")
		}
		return v.VisitParquet(ctx, *u.parquet)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(ctx, *u.video)
	case "containerized":
		if u.containerized == nil {
			return result, fmt.Errorf("field \"containerized\" is required")
		}
		return v.VisitContainerized(ctx, *u.containerized)
	case "avroStream":
		if u.avroStream == nil {
			return result, fmt.Errorf("field \"avroStream\" is required")
		}
		return v.VisitAvroStream(ctx, *u.avroStream)
	}
}

func (u *IngestOptionsWithT[T]) AcceptFuncs(dataflashFunc func(DataflashOpts) (T, error), mcapProtobufTimeseriesFunc func(McapProtobufTimeseriesOpts) (T, error), journalJsonFunc func(JournalJsonOpts) (T, error), csvFunc func(CsvOpts) (T, error), parquetFunc func(ParquetOpts) (T, error), videoFunc func(VideoOpts) (T, error), containerizedFunc func(ContainerizedOpts) (T, error), avroStreamFunc func(AvroStreamOpts) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dataflash":
		if u.dataflash == nil {
			return result, fmt.Errorf("field \"dataflash\" is required")
		}
		return dataflashFunc(*u.dataflash)
	case "mcapProtobufTimeseries":
		if u.mcapProtobufTimeseries == nil {
			return result, fmt.Errorf("field \"mcapProtobufTimeseries\" is required")
		}
		return mcapProtobufTimeseriesFunc(*u.mcapProtobufTimeseries)
	case "journalJson":
		if u.journalJson == nil {
			return result, fmt.Errorf("field \"journalJson\" is required")
		}
		return journalJsonFunc(*u.journalJson)
	case "csv":
		if u.csv == nil {
			return result, fmt.Errorf("field \"csv\" is required")
		}
		return csvFunc(*u.csv)
	case "parquet":
		if u.parquet == nil {
			return result, fmt.Errorf("field \"parquet\" is required")
		}
		return parquetFunc(*u.parquet)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	case "containerized":
		if u.containerized == nil {
			return result, fmt.Errorf("field \"containerized\" is required")
		}
		return containerizedFunc(*u.containerized)
	case "avroStream":
		if u.avroStream == nil {
			return result, fmt.Errorf("field \"avroStream\" is required")
		}
		return avroStreamFunc(*u.avroStream)
	}
}

func (u *IngestOptionsWithT[T]) DataflashNoopSuccess(DataflashOpts) (T, error) {
	var result T
	return result, nil
}

func (u *IngestOptionsWithT[T]) McapProtobufTimeseriesNoopSuccess(McapProtobufTimeseriesOpts) (T, error) {
	var result T
	return result, nil
}

func (u *IngestOptionsWithT[T]) JournalJsonNoopSuccess(JournalJsonOpts) (T, error) {
	var result T
	return result, nil
}

func (u *IngestOptionsWithT[T]) CsvNoopSuccess(CsvOpts) (T, error) {
	var result T
	return result, nil
}

func (u *IngestOptionsWithT[T]) ParquetNoopSuccess(ParquetOpts) (T, error) {
	var result T
	return result, nil
}

func (u *IngestOptionsWithT[T]) VideoNoopSuccess(VideoOpts) (T, error) {
	var result T
	return result, nil
}

func (u *IngestOptionsWithT[T]) ContainerizedNoopSuccess(ContainerizedOpts) (T, error) {
	var result T
	return result, nil
}

func (u *IngestOptionsWithT[T]) AvroStreamNoopSuccess(AvroStreamOpts) (T, error) {
	var result T
	return result, nil
}

func (u *IngestOptionsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type IngestOptionsVisitorWithT[T any] interface {
	VisitDataflash(ctx context.Context, v DataflashOpts) (T, error)
	VisitMcapProtobufTimeseries(ctx context.Context, v McapProtobufTimeseriesOpts) (T, error)
	VisitJournalJson(ctx context.Context, v JournalJsonOpts) (T, error)
	VisitCsv(ctx context.Context, v CsvOpts) (T, error)
	VisitParquet(ctx context.Context, v ParquetOpts) (T, error)
	VisitVideo(ctx context.Context, v VideoOpts) (T, error)
	VisitContainerized(ctx context.Context, v ContainerizedOpts) (T, error)
	VisitAvroStream(ctx context.Context, v AvroStreamOpts) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type IngestSourceWithT[T any] IngestSource

func (u *IngestSourceWithT[T]) Accept(ctx context.Context, v IngestSourceVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "s3":
		if u.s3 == nil {
			return result, fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3(ctx, *u.s3)
	case "gcs":
		if u.gcs == nil {
			return result, fmt.Errorf("field \"gcs\" is required")
		}
		return v.VisitGcs(ctx, *u.gcs)
	}
}

func (u *IngestSourceWithT[T]) AcceptFuncs(s3Func func(S3IngestSource) (T, error), gcsFunc func(GcsIngestSource) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "s3":
		if u.s3 == nil {
			return result, fmt.Errorf("field \"s3\" is required")
		}
		return s3Func(*u.s3)
	case "gcs":
		if u.gcs == nil {
			return result, fmt.Errorf("field \"gcs\" is required")
		}
		return gcsFunc(*u.gcs)
	}
}

func (u *IngestSourceWithT[T]) S3NoopSuccess(S3IngestSource) (T, error) {
	var result T
	return result, nil
}

func (u *IngestSourceWithT[T]) GcsNoopSuccess(GcsIngestSource) (T, error) {
	var result T
	return result, nil
}

func (u *IngestSourceWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type IngestSourceVisitorWithT[T any] interface {
	VisitS3(ctx context.Context, v S3IngestSource) (T, error)
	VisitGcs(ctx context.Context, v GcsIngestSource) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type McapChannelConfigTypeWithT[T any] McapChannelConfigType

func (u *McapChannelConfigTypeWithT[T]) Accept(ctx context.Context, v McapChannelConfigTypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(ctx, *u.video)
	}
}

func (u *McapChannelConfigTypeWithT[T]) AcceptFuncs(videoFunc func(McapVideoChannelConfig) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "video":
		if u.video == nil {
			return result, fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	}
}

func (u *McapChannelConfigTypeWithT[T]) VideoNoopSuccess(McapVideoChannelConfig) (T, error) {
	var result T
	return result, nil
}

func (u *McapChannelConfigTypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type McapChannelConfigTypeVisitorWithT[T any] interface {
	VisitVideo(ctx context.Context, v McapVideoChannelConfig) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type McapChannelsWithT[T any] McapChannels

func (u *McapChannelsWithT[T]) Accept(ctx context.Context, v McapChannelsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "all":
		if u.all == nil {
			return result, fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAll(ctx, *u.all)
	case "include":
		if u.include == nil {
			return result, fmt.Errorf("field \"include\" is required")
		}
		return v.VisitInclude(ctx, *u.include)
	case "exclude":
		if u.exclude == nil {
			return result, fmt.Errorf("field \"exclude\" is required")
		}
		return v.VisitExclude(ctx, *u.exclude)
	}
}

func (u *McapChannelsWithT[T]) AcceptFuncs(allFunc func(api.Empty) (T, error), includeFunc func([]api.McapChannelLocator) (T, error), excludeFunc func([]api.McapChannelLocator) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "all":
		if u.all == nil {
			return result, fmt.Errorf("field \"all\" is required")
		}
		return allFunc(*u.all)
	case "include":
		if u.include == nil {
			return result, fmt.Errorf("field \"include\" is required")
		}
		return includeFunc(*u.include)
	case "exclude":
		if u.exclude == nil {
			return result, fmt.Errorf("field \"exclude\" is required")
		}
		return excludeFunc(*u.exclude)
	}
}

func (u *McapChannelsWithT[T]) AllNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *McapChannelsWithT[T]) IncludeNoopSuccess([]api.McapChannelLocator) (T, error) {
	var result T
	return result, nil
}

func (u *McapChannelsWithT[T]) ExcludeNoopSuccess([]api.McapChannelLocator) (T, error) {
	var result T
	return result, nil
}

func (u *McapChannelsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type McapChannelsVisitorWithT[T any] interface {
	VisitAll(ctx context.Context, v api.Empty) (T, error)
	VisitInclude(ctx context.Context, v []api.McapChannelLocator) (T, error)
	VisitExclude(ctx context.Context, v []api.McapChannelLocator) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type McapDestinationWithT[T any] McapDestination

func (u *McapDestinationWithT[T]) Accept(ctx context.Context, v McapDestinationVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "videoRid":
		if u.videoRid == nil {
			return result, fmt.Errorf("field \"videoRid\" is required")
		}
		return v.VisitVideoRid(ctx, *u.videoRid)
	case "datasetRid":
		if u.datasetRid == nil {
			return result, fmt.Errorf("field \"datasetRid\" is required")
		}
		return v.VisitDatasetRid(ctx, *u.datasetRid)
	}
}

func (u *McapDestinationWithT[T]) AcceptFuncs(videoRidFunc func(rids.VideoRid) (T, error), datasetRidFunc func(rid.ResourceIdentifier) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "videoRid":
		if u.videoRid == nil {
			return result, fmt.Errorf("field \"videoRid\" is required")
		}
		return videoRidFunc(*u.videoRid)
	case "datasetRid":
		if u.datasetRid == nil {
			return result, fmt.Errorf("field \"datasetRid\" is required")
		}
		return datasetRidFunc(*u.datasetRid)
	}
}

func (u *McapDestinationWithT[T]) VideoRidNoopSuccess(rids.VideoRid) (T, error) {
	var result T
	return result, nil
}

func (u *McapDestinationWithT[T]) DatasetRidNoopSuccess(rid.ResourceIdentifier) (T, error) {
	var result T
	return result, nil
}

func (u *McapDestinationWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type McapDestinationVisitorWithT[T any] interface {
	VisitVideoRid(ctx context.Context, v rids.VideoRid) (T, error)
	VisitDatasetRid(ctx context.Context, v rid.ResourceIdentifier) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type McapSourceWithT[T any] McapSource

func (u *McapSourceWithT[T]) Accept(ctx context.Context, v McapSourceVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "singleChannel":
		if u.singleChannel == nil {
			return result, fmt.Errorf("field \"singleChannel\" is required")
		}
		return v.VisitSingleChannel(ctx, *u.singleChannel)
	case "mcapFile":
		if u.mcapFile == nil {
			return result, fmt.Errorf("field \"mcapFile\" is required")
		}
		return v.VisitMcapFile(ctx, *u.mcapFile)
	}
}

func (u *McapSourceWithT[T]) AcceptFuncs(singleChannelFunc func(api.McapChannelLocator) (T, error), mcapFileFunc func(IngestSource) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "singleChannel":
		if u.singleChannel == nil {
			return result, fmt.Errorf("field \"singleChannel\" is required")
		}
		return singleChannelFunc(*u.singleChannel)
	case "mcapFile":
		if u.mcapFile == nil {
			return result, fmt.Errorf("field \"mcapFile\" is required")
		}
		return mcapFileFunc(*u.mcapFile)
	}
}

func (u *McapSourceWithT[T]) SingleChannelNoopSuccess(api.McapChannelLocator) (T, error) {
	var result T
	return result, nil
}

func (u *McapSourceWithT[T]) McapFileNoopSuccess(IngestSource) (T, error) {
	var result T
	return result, nil
}

func (u *McapSourceWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type McapSourceVisitorWithT[T any] interface {
	VisitSingleChannel(ctx context.Context, v api.McapChannelLocator) (T, error)
	VisitMcapFile(ctx context.Context, v IngestSource) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type McapTimestampTypeWithT[T any] McapTimestampType

func (u *McapTimestampTypeWithT[T]) Accept(ctx context.Context, v McapTimestampTypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "logTime":
		if u.logTime == nil {
			return result, fmt.Errorf("field \"logTime\" is required")
		}
		return v.VisitLogTime(ctx, *u.logTime)
	}
}

func (u *McapTimestampTypeWithT[T]) AcceptFuncs(logTimeFunc func(LogTime) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "logTime":
		if u.logTime == nil {
			return result, fmt.Errorf("field \"logTime\" is required")
		}
		return logTimeFunc(*u.logTime)
	}
}

func (u *McapTimestampTypeWithT[T]) LogTimeNoopSuccess(LogTime) (T, error) {
	var result T
	return result, nil
}

func (u *McapTimestampTypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type McapTimestampTypeVisitorWithT[T any] interface {
	VisitLogTime(ctx context.Context, v LogTime) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ScaleParameterWithT[T any] ScaleParameter

func (u *ScaleParameterWithT[T]) Accept(ctx context.Context, v ScaleParameterVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return result, fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return v.VisitTrueFrameRate(ctx, *u.trueFrameRate)
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return result, fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return v.VisitEndingTimestamp(ctx, *u.endingTimestamp)
	case "scaleFactor":
		if u.scaleFactor == nil {
			return result, fmt.Errorf("field \"scaleFactor\" is required")
		}
		return v.VisitScaleFactor(ctx, *u.scaleFactor)
	}
}

func (u *ScaleParameterWithT[T]) AcceptFuncs(trueFrameRateFunc func(float64) (T, error), endingTimestampFunc func(UtcTimestamp) (T, error), scaleFactorFunc func(float64) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return result, fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return trueFrameRateFunc(*u.trueFrameRate)
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return result, fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return endingTimestampFunc(*u.endingTimestamp)
	case "scaleFactor":
		if u.scaleFactor == nil {
			return result, fmt.Errorf("field \"scaleFactor\" is required")
		}
		return scaleFactorFunc(*u.scaleFactor)
	}
}

func (u *ScaleParameterWithT[T]) TrueFrameRateNoopSuccess(float64) (T, error) {
	var result T
	return result, nil
}

func (u *ScaleParameterWithT[T]) EndingTimestampNoopSuccess(UtcTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *ScaleParameterWithT[T]) ScaleFactorNoopSuccess(float64) (T, error) {
	var result T
	return result, nil
}

func (u *ScaleParameterWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ScaleParameterVisitorWithT[T any] interface {
	VisitTrueFrameRate(ctx context.Context, v float64) (T, error)
	VisitEndingTimestamp(ctx context.Context, v UtcTimestamp) (T, error)
	VisitScaleFactor(ctx context.Context, v float64) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SearchContainerizedExtractorsQueryWithT[T any] SearchContainerizedExtractorsQuery

func (u *SearchContainerizedExtractorsQueryWithT[T]) Accept(ctx context.Context, v SearchContainerizedExtractorsQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(ctx, *u.searchText)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(ctx, *u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(ctx, *u.property)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	}
}

func (u *SearchContainerizedExtractorsQueryWithT[T]) AcceptFuncs(searchTextFunc func(string) (T, error), labelFunc func(api.Label) (T, error), propertyFunc func(api.Property) (T, error), andFunc func([]SearchContainerizedExtractorsQuery) (T, error), orFunc func([]SearchContainerizedExtractorsQuery) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "label":
		if u.label == nil {
			return result, fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return result, fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchContainerizedExtractorsQueryWithT[T]) SearchTextNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchContainerizedExtractorsQueryWithT[T]) LabelNoopSuccess(api.Label) (T, error) {
	var result T
	return result, nil
}

func (u *SearchContainerizedExtractorsQueryWithT[T]) PropertyNoopSuccess(api.Property) (T, error) {
	var result T
	return result, nil
}

func (u *SearchContainerizedExtractorsQueryWithT[T]) AndNoopSuccess([]SearchContainerizedExtractorsQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchContainerizedExtractorsQueryWithT[T]) OrNoopSuccess([]SearchContainerizedExtractorsQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchContainerizedExtractorsQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchContainerizedExtractorsQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchContainerizedExtractorsQueryVisitorWithT[T any] interface {
	VisitSearchText(ctx context.Context, v string) (T, error)
	VisitLabel(ctx context.Context, v api.Label) (T, error)
	VisitProperty(ctx context.Context, v api.Property) (T, error)
	VisitAnd(ctx context.Context, v []SearchContainerizedExtractorsQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchContainerizedExtractorsQuery) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimeOffsetSpecWithT[T any] TimeOffsetSpec

func (u *TimeOffsetSpecWithT[T]) Accept(ctx context.Context, v TimeOffsetSpecVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "nanos":
		if u.nanos == nil {
			return result, fmt.Errorf("field \"nanos\" is required")
		}
		return v.VisitNanos(ctx, *u.nanos)
	}
}

func (u *TimeOffsetSpecWithT[T]) AcceptFuncs(nanosFunc func(api1.Duration) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "nanos":
		if u.nanos == nil {
			return result, fmt.Errorf("field \"nanos\" is required")
		}
		return nanosFunc(*u.nanos)
	}
}

func (u *TimeOffsetSpecWithT[T]) NanosNoopSuccess(api1.Duration) (T, error) {
	var result T
	return result, nil
}

func (u *TimeOffsetSpecWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimeOffsetSpecVisitorWithT[T any] interface {
	VisitNanos(ctx context.Context, v api1.Duration) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TimestampTypeWithT[T any] TimestampType

func (u *TimestampTypeWithT[T]) Accept(ctx context.Context, v TimestampTypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "relative":
		if u.relative == nil {
			return result, fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelative(ctx, *u.relative)
	case "absolute":
		if u.absolute == nil {
			return result, fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsolute(ctx, *u.absolute)
	}
}

func (u *TimestampTypeWithT[T]) AcceptFuncs(relativeFunc func(RelativeTimestamp) (T, error), absoluteFunc func(AbsoluteTimestamp) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "relative":
		if u.relative == nil {
			return result, fmt.Errorf("field \"relative\" is required")
		}
		return relativeFunc(*u.relative)
	case "absolute":
		if u.absolute == nil {
			return result, fmt.Errorf("field \"absolute\" is required")
		}
		return absoluteFunc(*u.absolute)
	}
}

func (u *TimestampTypeWithT[T]) RelativeNoopSuccess(RelativeTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *TimestampTypeWithT[T]) AbsoluteNoopSuccess(AbsoluteTimestamp) (T, error) {
	var result T
	return result, nil
}

func (u *TimestampTypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TimestampTypeVisitorWithT[T any] interface {
	VisitRelative(ctx context.Context, v RelativeTimestamp) (T, error)
	VisitAbsolute(ctx context.Context, v AbsoluteTimestamp) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VideoIngestTargetWithT[T any] VideoIngestTarget

func (u *VideoIngestTargetWithT[T]) Accept(ctx context.Context, v VideoIngestTargetVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "new":
		if u.new == nil {
			return result, fmt.Errorf("field \"new\" is required")
		}
		return v.VisitNew(ctx, *u.new)
	case "existing":
		if u.existing == nil {
			return result, fmt.Errorf("field \"existing\" is required")
		}
		return v.VisitExisting(ctx, *u.existing)
	}
}

func (u *VideoIngestTargetWithT[T]) AcceptFuncs(newFunc func(NewVideoIngestDestination) (T, error), existingFunc func(ExistingVideoIngestDestination) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "new":
		if u.new == nil {
			return result, fmt.Errorf("field \"new\" is required")
		}
		return newFunc(*u.new)
	case "existing":
		if u.existing == nil {
			return result, fmt.Errorf("field \"existing\" is required")
		}
		return existingFunc(*u.existing)
	}
}

func (u *VideoIngestTargetWithT[T]) NewNoopSuccess(NewVideoIngestDestination) (T, error) {
	var result T
	return result, nil
}

func (u *VideoIngestTargetWithT[T]) ExistingNoopSuccess(ExistingVideoIngestDestination) (T, error) {
	var result T
	return result, nil
}

func (u *VideoIngestTargetWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VideoIngestTargetVisitorWithT[T any] interface {
	VisitNew(ctx context.Context, v NewVideoIngestDestination) (T, error)
	VisitExisting(ctx context.Context, v ExistingVideoIngestDestination) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VideoTimestampManifestWithT[T any] VideoTimestampManifest

func (u *VideoTimestampManifestWithT[T]) Accept(ctx context.Context, v VideoTimestampManifestVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "noManifest":
		if u.noManifest == nil {
			return result, fmt.Errorf("field \"noManifest\" is required")
		}
		return v.VisitNoManifest(ctx, *u.noManifest)
	case "timestampManifests":
		if u.timestampManifests == nil {
			return result, fmt.Errorf("field \"timestampManifests\" is required")
		}
		return v.VisitTimestampManifests(ctx, *u.timestampManifests)
	}
}

func (u *VideoTimestampManifestWithT[T]) AcceptFuncs(noManifestFunc func(NoTimestampManifest) (T, error), timestampManifestsFunc func(TimestampManifest) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "noManifest":
		if u.noManifest == nil {
			return result, fmt.Errorf("field \"noManifest\" is required")
		}
		return noManifestFunc(*u.noManifest)
	case "timestampManifests":
		if u.timestampManifests == nil {
			return result, fmt.Errorf("field \"timestampManifests\" is required")
		}
		return timestampManifestsFunc(*u.timestampManifests)
	}
}

func (u *VideoTimestampManifestWithT[T]) NoManifestNoopSuccess(NoTimestampManifest) (T, error) {
	var result T
	return result, nil
}

func (u *VideoTimestampManifestWithT[T]) TimestampManifestsNoopSuccess(TimestampManifest) (T, error) {
	var result T
	return result, nil
}

func (u *VideoTimestampManifestWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VideoTimestampManifestVisitorWithT[T any] interface {
	VisitNoManifest(ctx context.Context, v NoTimestampManifest) (T, error)
	VisitTimestampManifests(ctx context.Context, v TimestampManifest) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
