// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/run/api"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type AbsoluteTimestamp struct {
	typ             string
	iso8601         *Iso8601Timestamp
	epochOfTimeUnit *EpochTimestamp
	customFormat    *CustomTimestamp
}

type absoluteTimestampDeserializer struct {
	Type            string            `json:"type"`
	Iso8601         *Iso8601Timestamp `json:"iso8601"`
	EpochOfTimeUnit *EpochTimestamp   `json:"epochOfTimeUnit"`
	CustomFormat    *CustomTimestamp  `json:"customFormat"`
}

func (u *absoluteTimestampDeserializer) toStruct() AbsoluteTimestamp {
	return AbsoluteTimestamp{typ: u.Type, iso8601: u.Iso8601, epochOfTimeUnit: u.EpochOfTimeUnit, customFormat: u.CustomFormat}
}

func (u *AbsoluteTimestamp) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return nil, fmt.Errorf("field \"iso8601\" is required")
		}
		return struct {
			Type    string           `json:"type"`
			Iso8601 Iso8601Timestamp `json:"iso8601"`
		}{Type: "iso8601", Iso8601: *u.iso8601}, nil
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return nil, fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return struct {
			Type            string         `json:"type"`
			EpochOfTimeUnit EpochTimestamp `json:"epochOfTimeUnit"`
		}{Type: "epochOfTimeUnit", EpochOfTimeUnit: *u.epochOfTimeUnit}, nil
	case "customFormat":
		if u.customFormat == nil {
			return nil, fmt.Errorf("field \"customFormat\" is required")
		}
		return struct {
			Type         string          `json:"type"`
			CustomFormat CustomTimestamp `json:"customFormat"`
		}{Type: "customFormat", CustomFormat: *u.customFormat}, nil
	}
}

func (u AbsoluteTimestamp) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *AbsoluteTimestamp) UnmarshalJSON(data []byte) error {
	var deser absoluteTimestampDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
	case "customFormat":
		if u.customFormat == nil {
			return fmt.Errorf("field \"customFormat\" is required")
		}
	}
	return nil
}

func (u AbsoluteTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *AbsoluteTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *AbsoluteTimestamp) AcceptFuncs(iso8601Func func(Iso8601Timestamp) error, epochOfTimeUnitFunc func(EpochTimestamp) error, customFormatFunc func(CustomTimestamp) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
		return iso8601Func(*u.iso8601)
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return epochOfTimeUnitFunc(*u.epochOfTimeUnit)
	case "customFormat":
		if u.customFormat == nil {
			return fmt.Errorf("field \"customFormat\" is required")
		}
		return customFormatFunc(*u.customFormat)
	}
}

func (u *AbsoluteTimestamp) Iso8601NoopSuccess(Iso8601Timestamp) error {
	return nil
}

func (u *AbsoluteTimestamp) EpochOfTimeUnitNoopSuccess(EpochTimestamp) error {
	return nil
}

func (u *AbsoluteTimestamp) CustomFormatNoopSuccess(CustomTimestamp) error {
	return nil
}

func (u *AbsoluteTimestamp) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *AbsoluteTimestamp) Accept(v AbsoluteTimestampVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
		return v.VisitIso8601(*u.iso8601)
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return v.VisitEpochOfTimeUnit(*u.epochOfTimeUnit)
	case "customFormat":
		if u.customFormat == nil {
			return fmt.Errorf("field \"customFormat\" is required")
		}
		return v.VisitCustomFormat(*u.customFormat)
	}
}

type AbsoluteTimestampVisitor interface {
	VisitIso8601(v Iso8601Timestamp) error
	VisitEpochOfTimeUnit(v EpochTimestamp) error
	VisitCustomFormat(v CustomTimestamp) error
	VisitUnknown(typeName string) error
}

func (u *AbsoluteTimestamp) AcceptWithContext(ctx context.Context, v AbsoluteTimestampVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "iso8601":
		if u.iso8601 == nil {
			return fmt.Errorf("field \"iso8601\" is required")
		}
		return v.VisitIso8601WithContext(ctx, *u.iso8601)
	case "epochOfTimeUnit":
		if u.epochOfTimeUnit == nil {
			return fmt.Errorf("field \"epochOfTimeUnit\" is required")
		}
		return v.VisitEpochOfTimeUnitWithContext(ctx, *u.epochOfTimeUnit)
	case "customFormat":
		if u.customFormat == nil {
			return fmt.Errorf("field \"customFormat\" is required")
		}
		return v.VisitCustomFormatWithContext(ctx, *u.customFormat)
	}
}

type AbsoluteTimestampVisitorWithContext interface {
	VisitIso8601WithContext(ctx context.Context, v Iso8601Timestamp) error
	VisitEpochOfTimeUnitWithContext(ctx context.Context, v EpochTimestamp) error
	VisitCustomFormatWithContext(ctx context.Context, v CustomTimestamp) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAbsoluteTimestampFromIso8601(v Iso8601Timestamp) AbsoluteTimestamp {
	return AbsoluteTimestamp{typ: "iso8601", iso8601: &v}
}

func NewAbsoluteTimestampFromEpochOfTimeUnit(v EpochTimestamp) AbsoluteTimestamp {
	return AbsoluteTimestamp{typ: "epochOfTimeUnit", epochOfTimeUnit: &v}
}

func NewAbsoluteTimestampFromCustomFormat(v CustomTimestamp) AbsoluteTimestamp {
	return AbsoluteTimestamp{typ: "customFormat", customFormat: &v}
}

// Authentication methods for Docker registries.
type Authentication struct {
	typ             string
	userAndPassword *UserAndPasswordAuthentication
	public          *PublicAuthentication
}

type authenticationDeserializer struct {
	Type            string                         `json:"type"`
	UserAndPassword *UserAndPasswordAuthentication `json:"userAndPassword"`
	Public          *PublicAuthentication          `json:"public"`
}

func (u *authenticationDeserializer) toStruct() Authentication {
	return Authentication{typ: u.Type, userAndPassword: u.UserAndPassword, public: u.Public}
}

func (u *Authentication) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "userAndPassword":
		if u.userAndPassword == nil {
			return nil, fmt.Errorf("field \"userAndPassword\" is required")
		}
		return struct {
			Type            string                        `json:"type"`
			UserAndPassword UserAndPasswordAuthentication `json:"userAndPassword"`
		}{Type: "userAndPassword", UserAndPassword: *u.userAndPassword}, nil
	case "public":
		if u.public == nil {
			return nil, fmt.Errorf("field \"public\" is required")
		}
		return struct {
			Type   string               `json:"type"`
			Public PublicAuthentication `json:"public"`
		}{Type: "public", Public: *u.public}, nil
	}
}

func (u Authentication) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Authentication) UnmarshalJSON(data []byte) error {
	var deser authenticationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "userAndPassword":
		if u.userAndPassword == nil {
			return fmt.Errorf("field \"userAndPassword\" is required")
		}
	case "public":
		if u.public == nil {
			return fmt.Errorf("field \"public\" is required")
		}
	}
	return nil
}

func (u Authentication) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Authentication) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Authentication) AcceptFuncs(userAndPasswordFunc func(UserAndPasswordAuthentication) error, publicFunc func(PublicAuthentication) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "userAndPassword":
		if u.userAndPassword == nil {
			return fmt.Errorf("field \"userAndPassword\" is required")
		}
		return userAndPasswordFunc(*u.userAndPassword)
	case "public":
		if u.public == nil {
			return fmt.Errorf("field \"public\" is required")
		}
		return publicFunc(*u.public)
	}
}

func (u *Authentication) UserAndPasswordNoopSuccess(UserAndPasswordAuthentication) error {
	return nil
}

func (u *Authentication) PublicNoopSuccess(PublicAuthentication) error {
	return nil
}

func (u *Authentication) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Authentication) Accept(v AuthenticationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "userAndPassword":
		if u.userAndPassword == nil {
			return fmt.Errorf("field \"userAndPassword\" is required")
		}
		return v.VisitUserAndPassword(*u.userAndPassword)
	case "public":
		if u.public == nil {
			return fmt.Errorf("field \"public\" is required")
		}
		return v.VisitPublic(*u.public)
	}
}

type AuthenticationVisitor interface {
	VisitUserAndPassword(v UserAndPasswordAuthentication) error
	VisitPublic(v PublicAuthentication) error
	VisitUnknown(typeName string) error
}

func (u *Authentication) AcceptWithContext(ctx context.Context, v AuthenticationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "userAndPassword":
		if u.userAndPassword == nil {
			return fmt.Errorf("field \"userAndPassword\" is required")
		}
		return v.VisitUserAndPasswordWithContext(ctx, *u.userAndPassword)
	case "public":
		if u.public == nil {
			return fmt.Errorf("field \"public\" is required")
		}
		return v.VisitPublicWithContext(ctx, *u.public)
	}
}

type AuthenticationVisitorWithContext interface {
	VisitUserAndPasswordWithContext(ctx context.Context, v UserAndPasswordAuthentication) error
	VisitPublicWithContext(ctx context.Context, v PublicAuthentication) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewAuthenticationFromUserAndPassword(v UserAndPasswordAuthentication) Authentication {
	return Authentication{typ: "userAndPassword", userAndPassword: &v}
}

func NewAuthenticationFromPublic(v PublicAuthentication) Authentication {
	return Authentication{typ: "public", public: &v}
}

type DatasetIngestTarget struct {
	typ      string
	new      *NewDatasetIngestDestination
	existing *ExistingDatasetIngestDestination
}

type datasetIngestTargetDeserializer struct {
	Type     string                            `json:"type"`
	New      *NewDatasetIngestDestination      `json:"new"`
	Existing *ExistingDatasetIngestDestination `json:"existing"`
}

func (u *datasetIngestTargetDeserializer) toStruct() DatasetIngestTarget {
	return DatasetIngestTarget{typ: u.Type, new: u.New, existing: u.Existing}
}

func (u *DatasetIngestTarget) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "new":
		if u.new == nil {
			return nil, fmt.Errorf("field \"new\" is required")
		}
		return struct {
			Type string                      `json:"type"`
			New  NewDatasetIngestDestination `json:"new"`
		}{Type: "new", New: *u.new}, nil
	case "existing":
		if u.existing == nil {
			return nil, fmt.Errorf("field \"existing\" is required")
		}
		return struct {
			Type     string                           `json:"type"`
			Existing ExistingDatasetIngestDestination `json:"existing"`
		}{Type: "existing", Existing: *u.existing}, nil
	}
}

func (u DatasetIngestTarget) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DatasetIngestTarget) UnmarshalJSON(data []byte) error {
	var deser datasetIngestTargetDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "new":
		if u.new == nil {
			return fmt.Errorf("field \"new\" is required")
		}
	case "existing":
		if u.existing == nil {
			return fmt.Errorf("field \"existing\" is required")
		}
	}
	return nil
}

func (u DatasetIngestTarget) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DatasetIngestTarget) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DatasetIngestTarget) AcceptFuncs(newFunc func(NewDatasetIngestDestination) error, existingFunc func(ExistingDatasetIngestDestination) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "new":
		if u.new == nil {
			return fmt.Errorf("field \"new\" is required")
		}
		return newFunc(*u.new)
	case "existing":
		if u.existing == nil {
			return fmt.Errorf("field \"existing\" is required")
		}
		return existingFunc(*u.existing)
	}
}

func (u *DatasetIngestTarget) NewNoopSuccess(NewDatasetIngestDestination) error {
	return nil
}

func (u *DatasetIngestTarget) ExistingNoopSuccess(ExistingDatasetIngestDestination) error {
	return nil
}

func (u *DatasetIngestTarget) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DatasetIngestTarget) Accept(v DatasetIngestTargetVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "new":
		if u.new == nil {
			return fmt.Errorf("field \"new\" is required")
		}
		return v.VisitNew(*u.new)
	case "existing":
		if u.existing == nil {
			return fmt.Errorf("field \"existing\" is required")
		}
		return v.VisitExisting(*u.existing)
	}
}

type DatasetIngestTargetVisitor interface {
	VisitNew(v NewDatasetIngestDestination) error
	VisitExisting(v ExistingDatasetIngestDestination) error
	VisitUnknown(typeName string) error
}

func (u *DatasetIngestTarget) AcceptWithContext(ctx context.Context, v DatasetIngestTargetVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "new":
		if u.new == nil {
			return fmt.Errorf("field \"new\" is required")
		}
		return v.VisitNewWithContext(ctx, *u.new)
	case "existing":
		if u.existing == nil {
			return fmt.Errorf("field \"existing\" is required")
		}
		return v.VisitExistingWithContext(ctx, *u.existing)
	}
}

type DatasetIngestTargetVisitorWithContext interface {
	VisitNewWithContext(ctx context.Context, v NewDatasetIngestDestination) error
	VisitExistingWithContext(ctx context.Context, v ExistingDatasetIngestDestination) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDatasetIngestTargetFromNew(v NewDatasetIngestDestination) DatasetIngestTarget {
	return DatasetIngestTarget{typ: "new", new: &v}
}

func NewDatasetIngestTargetFromExisting(v ExistingDatasetIngestDestination) DatasetIngestTarget {
	return DatasetIngestTarget{typ: "existing", existing: &v}
}

type DeprecatedNewDataSource struct {
	typ string
	csv *DeprecatedNewCsv
}

type deprecatedNewDataSourceDeserializer struct {
	Type string            `json:"type"`
	Csv  *DeprecatedNewCsv `json:"csv"`
}

func (u *deprecatedNewDataSourceDeserializer) toStruct() DeprecatedNewDataSource {
	return DeprecatedNewDataSource{typ: u.Type, csv: u.Csv}
}

func (u *DeprecatedNewDataSource) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "csv":
		if u.csv == nil {
			return nil, fmt.Errorf("field \"csv\" is required")
		}
		return struct {
			Type string           `json:"type"`
			Csv  DeprecatedNewCsv `json:"csv"`
		}{Type: "csv", Csv: *u.csv}, nil
	}
}

func (u DeprecatedNewDataSource) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *DeprecatedNewDataSource) UnmarshalJSON(data []byte) error {
	var deser deprecatedNewDataSourceDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
	}
	return nil
}

func (u DeprecatedNewDataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *DeprecatedNewDataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *DeprecatedNewDataSource) AcceptFuncs(csvFunc func(DeprecatedNewCsv) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return csvFunc(*u.csv)
	}
}

func (u *DeprecatedNewDataSource) CsvNoopSuccess(DeprecatedNewCsv) error {
	return nil
}

func (u *DeprecatedNewDataSource) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *DeprecatedNewDataSource) Accept(v DeprecatedNewDataSourceVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsv(*u.csv)
	}
}

type DeprecatedNewDataSourceVisitor interface {
	VisitCsv(v DeprecatedNewCsv) error
	VisitUnknown(typeName string) error
}

func (u *DeprecatedNewDataSource) AcceptWithContext(ctx context.Context, v DeprecatedNewDataSourceVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsvWithContext(ctx, *u.csv)
	}
}

type DeprecatedNewDataSourceVisitorWithContext interface {
	VisitCsvWithContext(ctx context.Context, v DeprecatedNewCsv) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewDeprecatedNewDataSourceFromCsv(v DeprecatedNewCsv) DeprecatedNewDataSource {
	return DeprecatedNewDataSource{typ: "csv", csv: &v}
}

type FileFilter struct {
	typ    string
	suffix *FileSuffix
}

type fileFilterDeserializer struct {
	Type   string      `json:"type"`
	Suffix *FileSuffix `json:"suffix"`
}

func (u *fileFilterDeserializer) toStruct() FileFilter {
	return FileFilter{typ: u.Type, suffix: u.Suffix}
}

func (u *FileFilter) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "suffix":
		if u.suffix == nil {
			return nil, fmt.Errorf("field \"suffix\" is required")
		}
		return struct {
			Type   string     `json:"type"`
			Suffix FileSuffix `json:"suffix"`
		}{Type: "suffix", Suffix: *u.suffix}, nil
	}
}

func (u FileFilter) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FileFilter) UnmarshalJSON(data []byte) error {
	var deser fileFilterDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "suffix":
		if u.suffix == nil {
			return fmt.Errorf("field \"suffix\" is required")
		}
	}
	return nil
}

func (u FileFilter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FileFilter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FileFilter) AcceptFuncs(suffixFunc func(FileSuffix) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "suffix":
		if u.suffix == nil {
			return fmt.Errorf("field \"suffix\" is required")
		}
		return suffixFunc(*u.suffix)
	}
}

func (u *FileFilter) SuffixNoopSuccess(FileSuffix) error {
	return nil
}

func (u *FileFilter) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FileFilter) Accept(v FileFilterVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "suffix":
		if u.suffix == nil {
			return fmt.Errorf("field \"suffix\" is required")
		}
		return v.VisitSuffix(*u.suffix)
	}
}

type FileFilterVisitor interface {
	VisitSuffix(v FileSuffix) error
	VisitUnknown(typeName string) error
}

func (u *FileFilter) AcceptWithContext(ctx context.Context, v FileFilterVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "suffix":
		if u.suffix == nil {
			return fmt.Errorf("field \"suffix\" is required")
		}
		return v.VisitSuffixWithContext(ctx, *u.suffix)
	}
}

type FileFilterVisitorWithContext interface {
	VisitSuffixWithContext(ctx context.Context, v FileSuffix) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFileFilterFromSuffix(v FileSuffix) FileFilter {
	return FileFilter{typ: "suffix", suffix: &v}
}

type IngestDataSource struct {
	typ                string
	existingDataSource *rids.DataSourceRid
	newDataSource      *DeprecatedNewDataSource
	newDataSourceV2    *NewDataSource
}

type ingestDataSourceDeserializer struct {
	Type               string                   `json:"type"`
	ExistingDataSource *rids.DataSourceRid      `json:"existingDataSource"`
	NewDataSource      *DeprecatedNewDataSource `json:"newDataSource"`
	NewDataSourceV2    *NewDataSource           `json:"newDataSourceV2"`
}

func (u *ingestDataSourceDeserializer) toStruct() IngestDataSource {
	return IngestDataSource{typ: u.Type, existingDataSource: u.ExistingDataSource, newDataSource: u.NewDataSource, newDataSourceV2: u.NewDataSourceV2}
}

func (u *IngestDataSource) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "existingDataSource":
		if u.existingDataSource == nil {
			return nil, fmt.Errorf("field \"existingDataSource\" is required")
		}
		return struct {
			Type               string             `json:"type"`
			ExistingDataSource rids.DataSourceRid `json:"existingDataSource"`
		}{Type: "existingDataSource", ExistingDataSource: *u.existingDataSource}, nil
	case "newDataSource":
		if u.newDataSource == nil {
			return nil, fmt.Errorf("field \"newDataSource\" is required")
		}
		return struct {
			Type          string                  `json:"type"`
			NewDataSource DeprecatedNewDataSource `json:"newDataSource"`
		}{Type: "newDataSource", NewDataSource: *u.newDataSource}, nil
	case "newDataSourceV2":
		if u.newDataSourceV2 == nil {
			return nil, fmt.Errorf("field \"newDataSourceV2\" is required")
		}
		return struct {
			Type            string        `json:"type"`
			NewDataSourceV2 NewDataSource `json:"newDataSourceV2"`
		}{Type: "newDataSourceV2", NewDataSourceV2: *u.newDataSourceV2}, nil
	}
}

func (u IngestDataSource) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *IngestDataSource) UnmarshalJSON(data []byte) error {
	var deser ingestDataSourceDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "existingDataSource":
		if u.existingDataSource == nil {
			return fmt.Errorf("field \"existingDataSource\" is required")
		}
	case "newDataSource":
		if u.newDataSource == nil {
			return fmt.Errorf("field \"newDataSource\" is required")
		}
	case "newDataSourceV2":
		if u.newDataSourceV2 == nil {
			return fmt.Errorf("field \"newDataSourceV2\" is required")
		}
	}
	return nil
}

func (u IngestDataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *IngestDataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *IngestDataSource) AcceptFuncs(existingDataSourceFunc func(rids.DataSourceRid) error, newDataSourceFunc func(DeprecatedNewDataSource) error, newDataSourceV2Func func(NewDataSource) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "existingDataSource":
		if u.existingDataSource == nil {
			return fmt.Errorf("field \"existingDataSource\" is required")
		}
		return existingDataSourceFunc(*u.existingDataSource)
	case "newDataSource":
		if u.newDataSource == nil {
			return fmt.Errorf("field \"newDataSource\" is required")
		}
		return newDataSourceFunc(*u.newDataSource)
	case "newDataSourceV2":
		if u.newDataSourceV2 == nil {
			return fmt.Errorf("field \"newDataSourceV2\" is required")
		}
		return newDataSourceV2Func(*u.newDataSourceV2)
	}
}

func (u *IngestDataSource) ExistingDataSourceNoopSuccess(rids.DataSourceRid) error {
	return nil
}

func (u *IngestDataSource) NewDataSourceNoopSuccess(DeprecatedNewDataSource) error {
	return nil
}

func (u *IngestDataSource) NewDataSourceV2NoopSuccess(NewDataSource) error {
	return nil
}

func (u *IngestDataSource) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *IngestDataSource) Accept(v IngestDataSourceVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "existingDataSource":
		if u.existingDataSource == nil {
			return fmt.Errorf("field \"existingDataSource\" is required")
		}
		return v.VisitExistingDataSource(*u.existingDataSource)
	case "newDataSource":
		if u.newDataSource == nil {
			return fmt.Errorf("field \"newDataSource\" is required")
		}
		return v.VisitNewDataSource(*u.newDataSource)
	case "newDataSourceV2":
		if u.newDataSourceV2 == nil {
			return fmt.Errorf("field \"newDataSourceV2\" is required")
		}
		return v.VisitNewDataSourceV2(*u.newDataSourceV2)
	}
}

type IngestDataSourceVisitor interface {
	VisitExistingDataSource(v rids.DataSourceRid) error
	VisitNewDataSource(v DeprecatedNewDataSource) error
	VisitNewDataSourceV2(v NewDataSource) error
	VisitUnknown(typeName string) error
}

func (u *IngestDataSource) AcceptWithContext(ctx context.Context, v IngestDataSourceVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "existingDataSource":
		if u.existingDataSource == nil {
			return fmt.Errorf("field \"existingDataSource\" is required")
		}
		return v.VisitExistingDataSourceWithContext(ctx, *u.existingDataSource)
	case "newDataSource":
		if u.newDataSource == nil {
			return fmt.Errorf("field \"newDataSource\" is required")
		}
		return v.VisitNewDataSourceWithContext(ctx, *u.newDataSource)
	case "newDataSourceV2":
		if u.newDataSourceV2 == nil {
			return fmt.Errorf("field \"newDataSourceV2\" is required")
		}
		return v.VisitNewDataSourceV2WithContext(ctx, *u.newDataSourceV2)
	}
}

type IngestDataSourceVisitorWithContext interface {
	VisitExistingDataSourceWithContext(ctx context.Context, v rids.DataSourceRid) error
	VisitNewDataSourceWithContext(ctx context.Context, v DeprecatedNewDataSource) error
	VisitNewDataSourceV2WithContext(ctx context.Context, v NewDataSource) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewIngestDataSourceFromExistingDataSource(v rids.DataSourceRid) IngestDataSource {
	return IngestDataSource{typ: "existingDataSource", existingDataSource: &v}
}

func NewIngestDataSourceFromNewDataSource(v DeprecatedNewDataSource) IngestDataSource {
	return IngestDataSource{typ: "newDataSource", newDataSource: &v}
}

func NewIngestDataSourceFromNewDataSourceV2(v NewDataSource) IngestDataSource {
	return IngestDataSource{typ: "newDataSourceV2", newDataSourceV2: &v}
}

type IngestDestination struct {
	typ             string
	newDataset      *NewDatasetIngestDestination
	existingDataset *ExistingDatasetIngestDestination
}

type ingestDestinationDeserializer struct {
	Type            string                            `json:"type"`
	NewDataset      *NewDatasetIngestDestination      `json:"newDataset"`
	ExistingDataset *ExistingDatasetIngestDestination `json:"existingDataset"`
}

func (u *ingestDestinationDeserializer) toStruct() IngestDestination {
	return IngestDestination{typ: u.Type, newDataset: u.NewDataset, existingDataset: u.ExistingDataset}
}

func (u *IngestDestination) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "newDataset":
		if u.newDataset == nil {
			return nil, fmt.Errorf("field \"newDataset\" is required")
		}
		return struct {
			Type       string                      `json:"type"`
			NewDataset NewDatasetIngestDestination `json:"newDataset"`
		}{Type: "newDataset", NewDataset: *u.newDataset}, nil
	case "existingDataset":
		if u.existingDataset == nil {
			return nil, fmt.Errorf("field \"existingDataset\" is required")
		}
		return struct {
			Type            string                           `json:"type"`
			ExistingDataset ExistingDatasetIngestDestination `json:"existingDataset"`
		}{Type: "existingDataset", ExistingDataset: *u.existingDataset}, nil
	}
}

func (u IngestDestination) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *IngestDestination) UnmarshalJSON(data []byte) error {
	var deser ingestDestinationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "newDataset":
		if u.newDataset == nil {
			return fmt.Errorf("field \"newDataset\" is required")
		}
	case "existingDataset":
		if u.existingDataset == nil {
			return fmt.Errorf("field \"existingDataset\" is required")
		}
	}
	return nil
}

func (u IngestDestination) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *IngestDestination) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *IngestDestination) AcceptFuncs(newDatasetFunc func(NewDatasetIngestDestination) error, existingDatasetFunc func(ExistingDatasetIngestDestination) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "newDataset":
		if u.newDataset == nil {
			return fmt.Errorf("field \"newDataset\" is required")
		}
		return newDatasetFunc(*u.newDataset)
	case "existingDataset":
		if u.existingDataset == nil {
			return fmt.Errorf("field \"existingDataset\" is required")
		}
		return existingDatasetFunc(*u.existingDataset)
	}
}

func (u *IngestDestination) NewDatasetNoopSuccess(NewDatasetIngestDestination) error {
	return nil
}

func (u *IngestDestination) ExistingDatasetNoopSuccess(ExistingDatasetIngestDestination) error {
	return nil
}

func (u *IngestDestination) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *IngestDestination) Accept(v IngestDestinationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "newDataset":
		if u.newDataset == nil {
			return fmt.Errorf("field \"newDataset\" is required")
		}
		return v.VisitNewDataset(*u.newDataset)
	case "existingDataset":
		if u.existingDataset == nil {
			return fmt.Errorf("field \"existingDataset\" is required")
		}
		return v.VisitExistingDataset(*u.existingDataset)
	}
}

type IngestDestinationVisitor interface {
	VisitNewDataset(v NewDatasetIngestDestination) error
	VisitExistingDataset(v ExistingDatasetIngestDestination) error
	VisitUnknown(typeName string) error
}

func (u *IngestDestination) AcceptWithContext(ctx context.Context, v IngestDestinationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "newDataset":
		if u.newDataset == nil {
			return fmt.Errorf("field \"newDataset\" is required")
		}
		return v.VisitNewDatasetWithContext(ctx, *u.newDataset)
	case "existingDataset":
		if u.existingDataset == nil {
			return fmt.Errorf("field \"existingDataset\" is required")
		}
		return v.VisitExistingDatasetWithContext(ctx, *u.existingDataset)
	}
}

type IngestDestinationVisitorWithContext interface {
	VisitNewDatasetWithContext(ctx context.Context, v NewDatasetIngestDestination) error
	VisitExistingDatasetWithContext(ctx context.Context, v ExistingDatasetIngestDestination) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewIngestDestinationFromNewDataset(v NewDatasetIngestDestination) IngestDestination {
	return IngestDestination{typ: "newDataset", newDataset: &v}
}

func NewIngestDestinationFromExistingDataset(v ExistingDatasetIngestDestination) IngestDestination {
	return IngestDestination{typ: "existingDataset", existingDataset: &v}
}

type IngestDetails struct {
	typ     string
	dataset *IngestDatasetFileDetails
	video   *IngestVideoFileDetails
}

type ingestDetailsDeserializer struct {
	Type    string                    `json:"type"`
	Dataset *IngestDatasetFileDetails `json:"dataset"`
	Video   *IngestVideoFileDetails   `json:"video"`
}

func (u *ingestDetailsDeserializer) toStruct() IngestDetails {
	return IngestDetails{typ: u.Type, dataset: u.Dataset, video: u.Video}
}

func (u *IngestDetails) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "dataset":
		if u.dataset == nil {
			return nil, fmt.Errorf("field \"dataset\" is required")
		}
		return struct {
			Type    string                   `json:"type"`
			Dataset IngestDatasetFileDetails `json:"dataset"`
		}{Type: "dataset", Dataset: *u.dataset}, nil
	case "video":
		if u.video == nil {
			return nil, fmt.Errorf("field \"video\" is required")
		}
		return struct {
			Type  string                 `json:"type"`
			Video IngestVideoFileDetails `json:"video"`
		}{Type: "video", Video: *u.video}, nil
	}
}

func (u IngestDetails) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *IngestDetails) UnmarshalJSON(data []byte) error {
	var deser ingestDetailsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
	}
	return nil
}

func (u IngestDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *IngestDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *IngestDetails) AcceptFuncs(datasetFunc func(IngestDatasetFileDetails) error, videoFunc func(IngestVideoFileDetails) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
		return datasetFunc(*u.dataset)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	}
}

func (u *IngestDetails) DatasetNoopSuccess(IngestDatasetFileDetails) error {
	return nil
}

func (u *IngestDetails) VideoNoopSuccess(IngestVideoFileDetails) error {
	return nil
}

func (u *IngestDetails) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *IngestDetails) Accept(v IngestDetailsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
		return v.VisitDataset(*u.dataset)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(*u.video)
	}
}

type IngestDetailsVisitor interface {
	VisitDataset(v IngestDatasetFileDetails) error
	VisitVideo(v IngestVideoFileDetails) error
	VisitUnknown(typeName string) error
}

func (u *IngestDetails) AcceptWithContext(ctx context.Context, v IngestDetailsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "dataset":
		if u.dataset == nil {
			return fmt.Errorf("field \"dataset\" is required")
		}
		return v.VisitDatasetWithContext(ctx, *u.dataset)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideoWithContext(ctx, *u.video)
	}
}

type IngestDetailsVisitorWithContext interface {
	VisitDatasetWithContext(ctx context.Context, v IngestDatasetFileDetails) error
	VisitVideoWithContext(ctx context.Context, v IngestVideoFileDetails) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewIngestDetailsFromDataset(v IngestDatasetFileDetails) IngestDetails {
	return IngestDetails{typ: "dataset", dataset: &v}
}

func NewIngestDetailsFromVideo(v IngestVideoFileDetails) IngestDetails {
	return IngestDetails{typ: "video", video: &v}
}

type IngestJobRequest struct {
	typ           string
	ingestRequest *IngestRequest
}

type ingestJobRequestDeserializer struct {
	Type          string         `json:"type"`
	IngestRequest *IngestRequest `json:"ingestRequest"`
}

func (u *ingestJobRequestDeserializer) toStruct() IngestJobRequest {
	return IngestJobRequest{typ: u.Type, ingestRequest: u.IngestRequest}
}

func (u *IngestJobRequest) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "ingestRequest":
		if u.ingestRequest == nil {
			return nil, fmt.Errorf("field \"ingestRequest\" is required")
		}
		return struct {
			Type          string        `json:"type"`
			IngestRequest IngestRequest `json:"ingestRequest"`
		}{Type: "ingestRequest", IngestRequest: *u.ingestRequest}, nil
	}
}

func (u IngestJobRequest) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *IngestJobRequest) UnmarshalJSON(data []byte) error {
	var deser ingestJobRequestDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "ingestRequest":
		if u.ingestRequest == nil {
			return fmt.Errorf("field \"ingestRequest\" is required")
		}
	}
	return nil
}

func (u IngestJobRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *IngestJobRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *IngestJobRequest) AcceptFuncs(ingestRequestFunc func(IngestRequest) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "ingestRequest":
		if u.ingestRequest == nil {
			return fmt.Errorf("field \"ingestRequest\" is required")
		}
		return ingestRequestFunc(*u.ingestRequest)
	}
}

func (u *IngestJobRequest) IngestRequestNoopSuccess(IngestRequest) error {
	return nil
}

func (u *IngestJobRequest) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *IngestJobRequest) Accept(v IngestJobRequestVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "ingestRequest":
		if u.ingestRequest == nil {
			return fmt.Errorf("field \"ingestRequest\" is required")
		}
		return v.VisitIngestRequest(*u.ingestRequest)
	}
}

type IngestJobRequestVisitor interface {
	VisitIngestRequest(v IngestRequest) error
	VisitUnknown(typeName string) error
}

func (u *IngestJobRequest) AcceptWithContext(ctx context.Context, v IngestJobRequestVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "ingestRequest":
		if u.ingestRequest == nil {
			return fmt.Errorf("field \"ingestRequest\" is required")
		}
		return v.VisitIngestRequestWithContext(ctx, *u.ingestRequest)
	}
}

type IngestJobRequestVisitorWithContext interface {
	VisitIngestRequestWithContext(ctx context.Context, v IngestRequest) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewIngestJobRequestFromIngestRequest(v IngestRequest) IngestJobRequest {
	return IngestJobRequest{typ: "ingestRequest", ingestRequest: &v}
}

type IngestOptions struct {
	typ                    string
	dataflash              *DataflashOpts
	mcapProtobufTimeseries *McapProtobufTimeseriesOpts
	journalJson            *JournalJsonOpts
	csv                    *CsvOpts
	parquet                *ParquetOpts
	video                  *VideoOpts
	containerized          *ContainerizedOpts
	avroStream             *AvroStreamOpts
}

type ingestOptionsDeserializer struct {
	Type                   string                      `json:"type"`
	Dataflash              *DataflashOpts              `json:"dataflash"`
	McapProtobufTimeseries *McapProtobufTimeseriesOpts `json:"mcapProtobufTimeseries"`
	JournalJson            *JournalJsonOpts            `json:"journalJson"`
	Csv                    *CsvOpts                    `json:"csv"`
	Parquet                *ParquetOpts                `json:"parquet"`
	Video                  *VideoOpts                  `json:"video"`
	Containerized          *ContainerizedOpts          `json:"containerized"`
	AvroStream             *AvroStreamOpts             `json:"avroStream"`
}

func (u *ingestOptionsDeserializer) toStruct() IngestOptions {
	return IngestOptions{typ: u.Type, dataflash: u.Dataflash, mcapProtobufTimeseries: u.McapProtobufTimeseries, journalJson: u.JournalJson, csv: u.Csv, parquet: u.Parquet, video: u.Video, containerized: u.Containerized, avroStream: u.AvroStream}
}

func (u *IngestOptions) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "dataflash":
		if u.dataflash == nil {
			return nil, fmt.Errorf("field \"dataflash\" is required")
		}
		return struct {
			Type      string        `json:"type"`
			Dataflash DataflashOpts `json:"dataflash"`
		}{Type: "dataflash", Dataflash: *u.dataflash}, nil
	case "mcapProtobufTimeseries":
		if u.mcapProtobufTimeseries == nil {
			return nil, fmt.Errorf("field \"mcapProtobufTimeseries\" is required")
		}
		return struct {
			Type                   string                     `json:"type"`
			McapProtobufTimeseries McapProtobufTimeseriesOpts `json:"mcapProtobufTimeseries"`
		}{Type: "mcapProtobufTimeseries", McapProtobufTimeseries: *u.mcapProtobufTimeseries}, nil
	case "journalJson":
		if u.journalJson == nil {
			return nil, fmt.Errorf("field \"journalJson\" is required")
		}
		return struct {
			Type        string          `json:"type"`
			JournalJson JournalJsonOpts `json:"journalJson"`
		}{Type: "journalJson", JournalJson: *u.journalJson}, nil
	case "csv":
		if u.csv == nil {
			return nil, fmt.Errorf("field \"csv\" is required")
		}
		return struct {
			Type string  `json:"type"`
			Csv  CsvOpts `json:"csv"`
		}{Type: "csv", Csv: *u.csv}, nil
	case "parquet":
		if u.parquet == nil {
			return nil, fmt.Errorf("field \"parquet\" is required")
		}
		return struct {
			Type    string      `json:"type"`
			Parquet ParquetOpts `json:"parquet"`
		}{Type: "parquet", Parquet: *u.parquet}, nil
	case "video":
		if u.video == nil {
			return nil, fmt.Errorf("field \"video\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Video VideoOpts `json:"video"`
		}{Type: "video", Video: *u.video}, nil
	case "containerized":
		if u.containerized == nil {
			return nil, fmt.Errorf("field \"containerized\" is required")
		}
		return struct {
			Type          string            `json:"type"`
			Containerized ContainerizedOpts `json:"containerized"`
		}{Type: "containerized", Containerized: *u.containerized}, nil
	case "avroStream":
		if u.avroStream == nil {
			return nil, fmt.Errorf("field \"avroStream\" is required")
		}
		return struct {
			Type       string         `json:"type"`
			AvroStream AvroStreamOpts `json:"avroStream"`
		}{Type: "avroStream", AvroStream: *u.avroStream}, nil
	}
}

func (u IngestOptions) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *IngestOptions) UnmarshalJSON(data []byte) error {
	var deser ingestOptionsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "dataflash":
		if u.dataflash == nil {
			return fmt.Errorf("field \"dataflash\" is required")
		}
	case "mcapProtobufTimeseries":
		if u.mcapProtobufTimeseries == nil {
			return fmt.Errorf("field \"mcapProtobufTimeseries\" is required")
		}
	case "journalJson":
		if u.journalJson == nil {
			return fmt.Errorf("field \"journalJson\" is required")
		}
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
	case "parquet":
		if u.parquet == nil {
			return fmt.Errorf("field \"parquet\" is required")
		}
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
	case "containerized":
		if u.containerized == nil {
			return fmt.Errorf("field \"containerized\" is required")
		}
	case "avroStream":
		if u.avroStream == nil {
			return fmt.Errorf("field \"avroStream\" is required")
		}
	}
	return nil
}

func (u IngestOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *IngestOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *IngestOptions) AcceptFuncs(dataflashFunc func(DataflashOpts) error, mcapProtobufTimeseriesFunc func(McapProtobufTimeseriesOpts) error, journalJsonFunc func(JournalJsonOpts) error, csvFunc func(CsvOpts) error, parquetFunc func(ParquetOpts) error, videoFunc func(VideoOpts) error, containerizedFunc func(ContainerizedOpts) error, avroStreamFunc func(AvroStreamOpts) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "dataflash":
		if u.dataflash == nil {
			return fmt.Errorf("field \"dataflash\" is required")
		}
		return dataflashFunc(*u.dataflash)
	case "mcapProtobufTimeseries":
		if u.mcapProtobufTimeseries == nil {
			return fmt.Errorf("field \"mcapProtobufTimeseries\" is required")
		}
		return mcapProtobufTimeseriesFunc(*u.mcapProtobufTimeseries)
	case "journalJson":
		if u.journalJson == nil {
			return fmt.Errorf("field \"journalJson\" is required")
		}
		return journalJsonFunc(*u.journalJson)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return csvFunc(*u.csv)
	case "parquet":
		if u.parquet == nil {
			return fmt.Errorf("field \"parquet\" is required")
		}
		return parquetFunc(*u.parquet)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	case "containerized":
		if u.containerized == nil {
			return fmt.Errorf("field \"containerized\" is required")
		}
		return containerizedFunc(*u.containerized)
	case "avroStream":
		if u.avroStream == nil {
			return fmt.Errorf("field \"avroStream\" is required")
		}
		return avroStreamFunc(*u.avroStream)
	}
}

func (u *IngestOptions) DataflashNoopSuccess(DataflashOpts) error {
	return nil
}

func (u *IngestOptions) McapProtobufTimeseriesNoopSuccess(McapProtobufTimeseriesOpts) error {
	return nil
}

func (u *IngestOptions) JournalJsonNoopSuccess(JournalJsonOpts) error {
	return nil
}

func (u *IngestOptions) CsvNoopSuccess(CsvOpts) error {
	return nil
}

func (u *IngestOptions) ParquetNoopSuccess(ParquetOpts) error {
	return nil
}

func (u *IngestOptions) VideoNoopSuccess(VideoOpts) error {
	return nil
}

func (u *IngestOptions) ContainerizedNoopSuccess(ContainerizedOpts) error {
	return nil
}

func (u *IngestOptions) AvroStreamNoopSuccess(AvroStreamOpts) error {
	return nil
}

func (u *IngestOptions) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *IngestOptions) Accept(v IngestOptionsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "dataflash":
		if u.dataflash == nil {
			return fmt.Errorf("field \"dataflash\" is required")
		}
		return v.VisitDataflash(*u.dataflash)
	case "mcapProtobufTimeseries":
		if u.mcapProtobufTimeseries == nil {
			return fmt.Errorf("field \"mcapProtobufTimeseries\" is required")
		}
		return v.VisitMcapProtobufTimeseries(*u.mcapProtobufTimeseries)
	case "journalJson":
		if u.journalJson == nil {
			return fmt.Errorf("field \"journalJson\" is required")
		}
		return v.VisitJournalJson(*u.journalJson)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsv(*u.csv)
	case "parquet":
		if u.parquet == nil {
			return fmt.Errorf("field \"parquet\" is required")
		}
		return v.VisitParquet(*u.parquet)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(*u.video)
	case "containerized":
		if u.containerized == nil {
			return fmt.Errorf("field \"containerized\" is required")
		}
		return v.VisitContainerized(*u.containerized)
	case "avroStream":
		if u.avroStream == nil {
			return fmt.Errorf("field \"avroStream\" is required")
		}
		return v.VisitAvroStream(*u.avroStream)
	}
}

type IngestOptionsVisitor interface {
	VisitDataflash(v DataflashOpts) error
	VisitMcapProtobufTimeseries(v McapProtobufTimeseriesOpts) error
	VisitJournalJson(v JournalJsonOpts) error
	VisitCsv(v CsvOpts) error
	VisitParquet(v ParquetOpts) error
	VisitVideo(v VideoOpts) error
	VisitContainerized(v ContainerizedOpts) error
	VisitAvroStream(v AvroStreamOpts) error
	VisitUnknown(typeName string) error
}

func (u *IngestOptions) AcceptWithContext(ctx context.Context, v IngestOptionsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "dataflash":
		if u.dataflash == nil {
			return fmt.Errorf("field \"dataflash\" is required")
		}
		return v.VisitDataflashWithContext(ctx, *u.dataflash)
	case "mcapProtobufTimeseries":
		if u.mcapProtobufTimeseries == nil {
			return fmt.Errorf("field \"mcapProtobufTimeseries\" is required")
		}
		return v.VisitMcapProtobufTimeseriesWithContext(ctx, *u.mcapProtobufTimeseries)
	case "journalJson":
		if u.journalJson == nil {
			return fmt.Errorf("field \"journalJson\" is required")
		}
		return v.VisitJournalJsonWithContext(ctx, *u.journalJson)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsvWithContext(ctx, *u.csv)
	case "parquet":
		if u.parquet == nil {
			return fmt.Errorf("field \"parquet\" is required")
		}
		return v.VisitParquetWithContext(ctx, *u.parquet)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideoWithContext(ctx, *u.video)
	case "containerized":
		if u.containerized == nil {
			return fmt.Errorf("field \"containerized\" is required")
		}
		return v.VisitContainerizedWithContext(ctx, *u.containerized)
	case "avroStream":
		if u.avroStream == nil {
			return fmt.Errorf("field \"avroStream\" is required")
		}
		return v.VisitAvroStreamWithContext(ctx, *u.avroStream)
	}
}

type IngestOptionsVisitorWithContext interface {
	VisitDataflashWithContext(ctx context.Context, v DataflashOpts) error
	VisitMcapProtobufTimeseriesWithContext(ctx context.Context, v McapProtobufTimeseriesOpts) error
	VisitJournalJsonWithContext(ctx context.Context, v JournalJsonOpts) error
	VisitCsvWithContext(ctx context.Context, v CsvOpts) error
	VisitParquetWithContext(ctx context.Context, v ParquetOpts) error
	VisitVideoWithContext(ctx context.Context, v VideoOpts) error
	VisitContainerizedWithContext(ctx context.Context, v ContainerizedOpts) error
	VisitAvroStreamWithContext(ctx context.Context, v AvroStreamOpts) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewIngestOptionsFromDataflash(v DataflashOpts) IngestOptions {
	return IngestOptions{typ: "dataflash", dataflash: &v}
}

func NewIngestOptionsFromMcapProtobufTimeseries(v McapProtobufTimeseriesOpts) IngestOptions {
	return IngestOptions{typ: "mcapProtobufTimeseries", mcapProtobufTimeseries: &v}
}

func NewIngestOptionsFromJournalJson(v JournalJsonOpts) IngestOptions {
	return IngestOptions{typ: "journalJson", journalJson: &v}
}

func NewIngestOptionsFromCsv(v CsvOpts) IngestOptions {
	return IngestOptions{typ: "csv", csv: &v}
}

func NewIngestOptionsFromParquet(v ParquetOpts) IngestOptions {
	return IngestOptions{typ: "parquet", parquet: &v}
}

func NewIngestOptionsFromVideo(v VideoOpts) IngestOptions {
	return IngestOptions{typ: "video", video: &v}
}

func NewIngestOptionsFromContainerized(v ContainerizedOpts) IngestOptions {
	return IngestOptions{typ: "containerized", containerized: &v}
}

func NewIngestOptionsFromAvroStream(v AvroStreamOpts) IngestOptions {
	return IngestOptions{typ: "avroStream", avroStream: &v}
}

type IngestSource struct {
	typ           string
	s3            *S3IngestSource
	gcs           *GcsIngestSource
	presignedFile *PresignedFileIngestSource
}

type ingestSourceDeserializer struct {
	Type          string                     `json:"type"`
	S3            *S3IngestSource            `json:"s3"`
	Gcs           *GcsIngestSource           `json:"gcs"`
	PresignedFile *PresignedFileIngestSource `json:"presignedFile"`
}

func (u *ingestSourceDeserializer) toStruct() IngestSource {
	return IngestSource{typ: u.Type, s3: u.S3, gcs: u.Gcs, presignedFile: u.PresignedFile}
}

func (u *IngestSource) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "s3":
		if u.s3 == nil {
			return nil, fmt.Errorf("field \"s3\" is required")
		}
		return struct {
			Type string         `json:"type"`
			S3   S3IngestSource `json:"s3"`
		}{Type: "s3", S3: *u.s3}, nil
	case "gcs":
		if u.gcs == nil {
			return nil, fmt.Errorf("field \"gcs\" is required")
		}
		return struct {
			Type string          `json:"type"`
			Gcs  GcsIngestSource `json:"gcs"`
		}{Type: "gcs", Gcs: *u.gcs}, nil
	case "presignedFile":
		if u.presignedFile == nil {
			return nil, fmt.Errorf("field \"presignedFile\" is required")
		}
		return struct {
			Type          string                    `json:"type"`
			PresignedFile PresignedFileIngestSource `json:"presignedFile"`
		}{Type: "presignedFile", PresignedFile: *u.presignedFile}, nil
	}
}

func (u IngestSource) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *IngestSource) UnmarshalJSON(data []byte) error {
	var deser ingestSourceDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
	case "gcs":
		if u.gcs == nil {
			return fmt.Errorf("field \"gcs\" is required")
		}
	case "presignedFile":
		if u.presignedFile == nil {
			return fmt.Errorf("field \"presignedFile\" is required")
		}
	}
	return nil
}

func (u IngestSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *IngestSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *IngestSource) AcceptFuncs(s3Func func(S3IngestSource) error, gcsFunc func(GcsIngestSource) error, presignedFileFunc func(PresignedFileIngestSource) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return s3Func(*u.s3)
	case "gcs":
		if u.gcs == nil {
			return fmt.Errorf("field \"gcs\" is required")
		}
		return gcsFunc(*u.gcs)
	case "presignedFile":
		if u.presignedFile == nil {
			return fmt.Errorf("field \"presignedFile\" is required")
		}
		return presignedFileFunc(*u.presignedFile)
	}
}

func (u *IngestSource) S3NoopSuccess(S3IngestSource) error {
	return nil
}

func (u *IngestSource) GcsNoopSuccess(GcsIngestSource) error {
	return nil
}

func (u *IngestSource) PresignedFileNoopSuccess(PresignedFileIngestSource) error {
	return nil
}

func (u *IngestSource) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *IngestSource) Accept(v IngestSourceVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3(*u.s3)
	case "gcs":
		if u.gcs == nil {
			return fmt.Errorf("field \"gcs\" is required")
		}
		return v.VisitGcs(*u.gcs)
	case "presignedFile":
		if u.presignedFile == nil {
			return fmt.Errorf("field \"presignedFile\" is required")
		}
		return v.VisitPresignedFile(*u.presignedFile)
	}
}

type IngestSourceVisitor interface {
	VisitS3(v S3IngestSource) error
	VisitGcs(v GcsIngestSource) error
	VisitPresignedFile(v PresignedFileIngestSource) error
	VisitUnknown(typeName string) error
}

func (u *IngestSource) AcceptWithContext(ctx context.Context, v IngestSourceVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3WithContext(ctx, *u.s3)
	case "gcs":
		if u.gcs == nil {
			return fmt.Errorf("field \"gcs\" is required")
		}
		return v.VisitGcsWithContext(ctx, *u.gcs)
	case "presignedFile":
		if u.presignedFile == nil {
			return fmt.Errorf("field \"presignedFile\" is required")
		}
		return v.VisitPresignedFileWithContext(ctx, *u.presignedFile)
	}
}

type IngestSourceVisitorWithContext interface {
	VisitS3WithContext(ctx context.Context, v S3IngestSource) error
	VisitGcsWithContext(ctx context.Context, v GcsIngestSource) error
	VisitPresignedFileWithContext(ctx context.Context, v PresignedFileIngestSource) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewIngestSourceFromS3(v S3IngestSource) IngestSource {
	return IngestSource{typ: "s3", s3: &v}
}

func NewIngestSourceFromGcs(v GcsIngestSource) IngestSource {
	return IngestSource{typ: "gcs", gcs: &v}
}

func NewIngestSourceFromPresignedFile(v PresignedFileIngestSource) IngestSource {
	return IngestSource{typ: "presignedFile", presignedFile: &v}
}

type McapChannelConfigType struct {
	typ   string
	video *McapVideoChannelConfig
}

type mcapChannelConfigTypeDeserializer struct {
	Type  string                  `json:"type"`
	Video *McapVideoChannelConfig `json:"video"`
}

func (u *mcapChannelConfigTypeDeserializer) toStruct() McapChannelConfigType {
	return McapChannelConfigType{typ: u.Type, video: u.Video}
}

func (u *McapChannelConfigType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "video":
		if u.video == nil {
			return nil, fmt.Errorf("field \"video\" is required")
		}
		return struct {
			Type  string                 `json:"type"`
			Video McapVideoChannelConfig `json:"video"`
		}{Type: "video", Video: *u.video}, nil
	}
}

func (u McapChannelConfigType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *McapChannelConfigType) UnmarshalJSON(data []byte) error {
	var deser mcapChannelConfigTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
	}
	return nil
}

func (u McapChannelConfigType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *McapChannelConfigType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *McapChannelConfigType) AcceptFuncs(videoFunc func(McapVideoChannelConfig) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return videoFunc(*u.video)
	}
}

func (u *McapChannelConfigType) VideoNoopSuccess(McapVideoChannelConfig) error {
	return nil
}

func (u *McapChannelConfigType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *McapChannelConfigType) Accept(v McapChannelConfigTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideo(*u.video)
	}
}

type McapChannelConfigTypeVisitor interface {
	VisitVideo(v McapVideoChannelConfig) error
	VisitUnknown(typeName string) error
}

func (u *McapChannelConfigType) AcceptWithContext(ctx context.Context, v McapChannelConfigTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "video":
		if u.video == nil {
			return fmt.Errorf("field \"video\" is required")
		}
		return v.VisitVideoWithContext(ctx, *u.video)
	}
}

type McapChannelConfigTypeVisitorWithContext interface {
	VisitVideoWithContext(ctx context.Context, v McapVideoChannelConfig) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewMcapChannelConfigTypeFromVideo(v McapVideoChannelConfig) McapChannelConfigType {
	return McapChannelConfigType{typ: "video", video: &v}
}

type McapChannels struct {
	typ     string
	all     *api.Empty
	include *[]api.McapChannelLocator
	exclude *[]api.McapChannelLocator
}

type mcapChannelsDeserializer struct {
	Type    string                    `json:"type"`
	All     *api.Empty                `json:"all"`
	Include *[]api.McapChannelLocator `json:"include"`
	Exclude *[]api.McapChannelLocator `json:"exclude"`
}

func (u *mcapChannelsDeserializer) toStruct() McapChannels {
	return McapChannels{typ: u.Type, all: u.All, include: u.Include, exclude: u.Exclude}
}

func (u *McapChannels) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "all":
		if u.all == nil {
			return nil, fmt.Errorf("field \"all\" is required")
		}
		return struct {
			Type string    `json:"type"`
			All  api.Empty `json:"all"`
		}{Type: "all", All: *u.all}, nil
	case "include":
		if u.include == nil {
			return nil, fmt.Errorf("field \"include\" is required")
		}
		return struct {
			Type    string                   `json:"type"`
			Include []api.McapChannelLocator `json:"include"`
		}{Type: "include", Include: *u.include}, nil
	case "exclude":
		if u.exclude == nil {
			return nil, fmt.Errorf("field \"exclude\" is required")
		}
		return struct {
			Type    string                   `json:"type"`
			Exclude []api.McapChannelLocator `json:"exclude"`
		}{Type: "exclude", Exclude: *u.exclude}, nil
	}
}

func (u McapChannels) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *McapChannels) UnmarshalJSON(data []byte) error {
	var deser mcapChannelsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
	case "include":
		if u.include == nil {
			return fmt.Errorf("field \"include\" is required")
		}
	case "exclude":
		if u.exclude == nil {
			return fmt.Errorf("field \"exclude\" is required")
		}
	}
	return nil
}

func (u McapChannels) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *McapChannels) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *McapChannels) AcceptFuncs(allFunc func(api.Empty) error, includeFunc func([]api.McapChannelLocator) error, excludeFunc func([]api.McapChannelLocator) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return allFunc(*u.all)
	case "include":
		if u.include == nil {
			return fmt.Errorf("field \"include\" is required")
		}
		return includeFunc(*u.include)
	case "exclude":
		if u.exclude == nil {
			return fmt.Errorf("field \"exclude\" is required")
		}
		return excludeFunc(*u.exclude)
	}
}

func (u *McapChannels) AllNoopSuccess(api.Empty) error {
	return nil
}

func (u *McapChannels) IncludeNoopSuccess([]api.McapChannelLocator) error {
	return nil
}

func (u *McapChannels) ExcludeNoopSuccess([]api.McapChannelLocator) error {
	return nil
}

func (u *McapChannels) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *McapChannels) Accept(v McapChannelsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAll(*u.all)
	case "include":
		if u.include == nil {
			return fmt.Errorf("field \"include\" is required")
		}
		return v.VisitInclude(*u.include)
	case "exclude":
		if u.exclude == nil {
			return fmt.Errorf("field \"exclude\" is required")
		}
		return v.VisitExclude(*u.exclude)
	}
}

type McapChannelsVisitor interface {
	VisitAll(v api.Empty) error
	VisitInclude(v []api.McapChannelLocator) error
	VisitExclude(v []api.McapChannelLocator) error
	VisitUnknown(typeName string) error
}

func (u *McapChannels) AcceptWithContext(ctx context.Context, v McapChannelsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAllWithContext(ctx, *u.all)
	case "include":
		if u.include == nil {
			return fmt.Errorf("field \"include\" is required")
		}
		return v.VisitIncludeWithContext(ctx, *u.include)
	case "exclude":
		if u.exclude == nil {
			return fmt.Errorf("field \"exclude\" is required")
		}
		return v.VisitExcludeWithContext(ctx, *u.exclude)
	}
}

type McapChannelsVisitorWithContext interface {
	VisitAllWithContext(ctx context.Context, v api.Empty) error
	VisitIncludeWithContext(ctx context.Context, v []api.McapChannelLocator) error
	VisitExcludeWithContext(ctx context.Context, v []api.McapChannelLocator) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewMcapChannelsFromAll(v api.Empty) McapChannels {
	return McapChannels{typ: "all", all: &v}
}

func NewMcapChannelsFromInclude(v []api.McapChannelLocator) McapChannels {
	return McapChannels{typ: "include", include: &v}
}

func NewMcapChannelsFromExclude(v []api.McapChannelLocator) McapChannels {
	return McapChannels{typ: "exclude", exclude: &v}
}

type McapDestination struct {
	typ        string
	videoRid   *rids.VideoRid
	datasetRid *rid.ResourceIdentifier
}

type mcapDestinationDeserializer struct {
	Type       string                  `json:"type"`
	VideoRid   *rids.VideoRid          `json:"videoRid"`
	DatasetRid *rid.ResourceIdentifier `json:"datasetRid"`
}

func (u *mcapDestinationDeserializer) toStruct() McapDestination {
	return McapDestination{typ: u.Type, videoRid: u.VideoRid, datasetRid: u.DatasetRid}
}

func (u *McapDestination) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "videoRid":
		if u.videoRid == nil {
			return nil, fmt.Errorf("field \"videoRid\" is required")
		}
		return struct {
			Type     string        `json:"type"`
			VideoRid rids.VideoRid `json:"videoRid"`
		}{Type: "videoRid", VideoRid: *u.videoRid}, nil
	case "datasetRid":
		if u.datasetRid == nil {
			return nil, fmt.Errorf("field \"datasetRid\" is required")
		}
		return struct {
			Type       string                 `json:"type"`
			DatasetRid rid.ResourceIdentifier `json:"datasetRid"`
		}{Type: "datasetRid", DatasetRid: *u.datasetRid}, nil
	}
}

func (u McapDestination) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *McapDestination) UnmarshalJSON(data []byte) error {
	var deser mcapDestinationDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "videoRid":
		if u.videoRid == nil {
			return fmt.Errorf("field \"videoRid\" is required")
		}
	case "datasetRid":
		if u.datasetRid == nil {
			return fmt.Errorf("field \"datasetRid\" is required")
		}
	}
	return nil
}

func (u McapDestination) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *McapDestination) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *McapDestination) AcceptFuncs(videoRidFunc func(rids.VideoRid) error, datasetRidFunc func(rid.ResourceIdentifier) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "videoRid":
		if u.videoRid == nil {
			return fmt.Errorf("field \"videoRid\" is required")
		}
		return videoRidFunc(*u.videoRid)
	case "datasetRid":
		if u.datasetRid == nil {
			return fmt.Errorf("field \"datasetRid\" is required")
		}
		return datasetRidFunc(*u.datasetRid)
	}
}

func (u *McapDestination) VideoRidNoopSuccess(rids.VideoRid) error {
	return nil
}

func (u *McapDestination) DatasetRidNoopSuccess(rid.ResourceIdentifier) error {
	return nil
}

func (u *McapDestination) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *McapDestination) Accept(v McapDestinationVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "videoRid":
		if u.videoRid == nil {
			return fmt.Errorf("field \"videoRid\" is required")
		}
		return v.VisitVideoRid(*u.videoRid)
	case "datasetRid":
		if u.datasetRid == nil {
			return fmt.Errorf("field \"datasetRid\" is required")
		}
		return v.VisitDatasetRid(*u.datasetRid)
	}
}

type McapDestinationVisitor interface {
	VisitVideoRid(v rids.VideoRid) error
	VisitDatasetRid(v rid.ResourceIdentifier) error
	VisitUnknown(typeName string) error
}

func (u *McapDestination) AcceptWithContext(ctx context.Context, v McapDestinationVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "videoRid":
		if u.videoRid == nil {
			return fmt.Errorf("field \"videoRid\" is required")
		}
		return v.VisitVideoRidWithContext(ctx, *u.videoRid)
	case "datasetRid":
		if u.datasetRid == nil {
			return fmt.Errorf("field \"datasetRid\" is required")
		}
		return v.VisitDatasetRidWithContext(ctx, *u.datasetRid)
	}
}

type McapDestinationVisitorWithContext interface {
	VisitVideoRidWithContext(ctx context.Context, v rids.VideoRid) error
	VisitDatasetRidWithContext(ctx context.Context, v rid.ResourceIdentifier) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewMcapDestinationFromVideoRid(v rids.VideoRid) McapDestination {
	return McapDestination{typ: "videoRid", videoRid: &v}
}

func NewMcapDestinationFromDatasetRid(v rid.ResourceIdentifier) McapDestination {
	return McapDestination{typ: "datasetRid", datasetRid: &v}
}

type McapSource struct {
	typ           string
	singleChannel *api.McapChannelLocator
	mcapFile      *IngestSource
}

type mcapSourceDeserializer struct {
	Type          string                  `json:"type"`
	SingleChannel *api.McapChannelLocator `json:"singleChannel"`
	McapFile      *IngestSource           `json:"mcapFile"`
}

func (u *mcapSourceDeserializer) toStruct() McapSource {
	return McapSource{typ: u.Type, singleChannel: u.SingleChannel, mcapFile: u.McapFile}
}

func (u *McapSource) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "singleChannel":
		if u.singleChannel == nil {
			return nil, fmt.Errorf("field \"singleChannel\" is required")
		}
		return struct {
			Type          string                 `json:"type"`
			SingleChannel api.McapChannelLocator `json:"singleChannel"`
		}{Type: "singleChannel", SingleChannel: *u.singleChannel}, nil
	case "mcapFile":
		if u.mcapFile == nil {
			return nil, fmt.Errorf("field \"mcapFile\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			McapFile IngestSource `json:"mcapFile"`
		}{Type: "mcapFile", McapFile: *u.mcapFile}, nil
	}
}

func (u McapSource) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *McapSource) UnmarshalJSON(data []byte) error {
	var deser mcapSourceDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "singleChannel":
		if u.singleChannel == nil {
			return fmt.Errorf("field \"singleChannel\" is required")
		}
	case "mcapFile":
		if u.mcapFile == nil {
			return fmt.Errorf("field \"mcapFile\" is required")
		}
	}
	return nil
}

func (u McapSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *McapSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *McapSource) AcceptFuncs(singleChannelFunc func(api.McapChannelLocator) error, mcapFileFunc func(IngestSource) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "singleChannel":
		if u.singleChannel == nil {
			return fmt.Errorf("field \"singleChannel\" is required")
		}
		return singleChannelFunc(*u.singleChannel)
	case "mcapFile":
		if u.mcapFile == nil {
			return fmt.Errorf("field \"mcapFile\" is required")
		}
		return mcapFileFunc(*u.mcapFile)
	}
}

func (u *McapSource) SingleChannelNoopSuccess(api.McapChannelLocator) error {
	return nil
}

func (u *McapSource) McapFileNoopSuccess(IngestSource) error {
	return nil
}

func (u *McapSource) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *McapSource) Accept(v McapSourceVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "singleChannel":
		if u.singleChannel == nil {
			return fmt.Errorf("field \"singleChannel\" is required")
		}
		return v.VisitSingleChannel(*u.singleChannel)
	case "mcapFile":
		if u.mcapFile == nil {
			return fmt.Errorf("field \"mcapFile\" is required")
		}
		return v.VisitMcapFile(*u.mcapFile)
	}
}

type McapSourceVisitor interface {
	VisitSingleChannel(v api.McapChannelLocator) error
	VisitMcapFile(v IngestSource) error
	VisitUnknown(typeName string) error
}

func (u *McapSource) AcceptWithContext(ctx context.Context, v McapSourceVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "singleChannel":
		if u.singleChannel == nil {
			return fmt.Errorf("field \"singleChannel\" is required")
		}
		return v.VisitSingleChannelWithContext(ctx, *u.singleChannel)
	case "mcapFile":
		if u.mcapFile == nil {
			return fmt.Errorf("field \"mcapFile\" is required")
		}
		return v.VisitMcapFileWithContext(ctx, *u.mcapFile)
	}
}

type McapSourceVisitorWithContext interface {
	VisitSingleChannelWithContext(ctx context.Context, v api.McapChannelLocator) error
	VisitMcapFileWithContext(ctx context.Context, v IngestSource) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewMcapSourceFromSingleChannel(v api.McapChannelLocator) McapSource {
	return McapSource{typ: "singleChannel", singleChannel: &v}
}

func NewMcapSourceFromMcapFile(v IngestSource) McapSource {
	return McapSource{typ: "mcapFile", mcapFile: &v}
}

// LogTime is default timestamp for MCAP messages and should be used in most cases.
type McapTimestampType struct {
	typ     string
	logTime *LogTime
}

type mcapTimestampTypeDeserializer struct {
	Type    string   `json:"type"`
	LogTime *LogTime `json:"logTime"`
}

func (u *mcapTimestampTypeDeserializer) toStruct() McapTimestampType {
	return McapTimestampType{typ: u.Type, logTime: u.LogTime}
}

func (u *McapTimestampType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "logTime":
		if u.logTime == nil {
			return nil, fmt.Errorf("field \"logTime\" is required")
		}
		return struct {
			Type    string  `json:"type"`
			LogTime LogTime `json:"logTime"`
		}{Type: "logTime", LogTime: *u.logTime}, nil
	}
}

func (u McapTimestampType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *McapTimestampType) UnmarshalJSON(data []byte) error {
	var deser mcapTimestampTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "logTime":
		if u.logTime == nil {
			return fmt.Errorf("field \"logTime\" is required")
		}
	}
	return nil
}

func (u McapTimestampType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *McapTimestampType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *McapTimestampType) AcceptFuncs(logTimeFunc func(LogTime) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "logTime":
		if u.logTime == nil {
			return fmt.Errorf("field \"logTime\" is required")
		}
		return logTimeFunc(*u.logTime)
	}
}

func (u *McapTimestampType) LogTimeNoopSuccess(LogTime) error {
	return nil
}

func (u *McapTimestampType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *McapTimestampType) Accept(v McapTimestampTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "logTime":
		if u.logTime == nil {
			return fmt.Errorf("field \"logTime\" is required")
		}
		return v.VisitLogTime(*u.logTime)
	}
}

type McapTimestampTypeVisitor interface {
	VisitLogTime(v LogTime) error
	VisitUnknown(typeName string) error
}

func (u *McapTimestampType) AcceptWithContext(ctx context.Context, v McapTimestampTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "logTime":
		if u.logTime == nil {
			return fmt.Errorf("field \"logTime\" is required")
		}
		return v.VisitLogTimeWithContext(ctx, *u.logTime)
	}
}

type McapTimestampTypeVisitorWithContext interface {
	VisitLogTimeWithContext(ctx context.Context, v LogTime) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewMcapTimestampTypeFromLogTime(v LogTime) McapTimestampType {
	return McapTimestampType{typ: "logTime", logTime: &v}
}

type ScaleParameter struct {
	typ             string
	trueFrameRate   *float64
	endingTimestamp *UtcTimestamp
	scaleFactor     *float64
}

type scaleParameterDeserializer struct {
	Type            string        `json:"type"`
	TrueFrameRate   *float64      `json:"trueFrameRate"`
	EndingTimestamp *UtcTimestamp `json:"endingTimestamp"`
	ScaleFactor     *float64      `json:"scaleFactor"`
}

func (u *scaleParameterDeserializer) toStruct() ScaleParameter {
	return ScaleParameter{typ: u.Type, trueFrameRate: u.TrueFrameRate, endingTimestamp: u.EndingTimestamp, scaleFactor: u.ScaleFactor}
}

func (u *ScaleParameter) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return nil, fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return struct {
			Type          string  `json:"type"`
			TrueFrameRate float64 `json:"trueFrameRate"`
		}{Type: "trueFrameRate", TrueFrameRate: *u.trueFrameRate}, nil
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return nil, fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return struct {
			Type            string       `json:"type"`
			EndingTimestamp UtcTimestamp `json:"endingTimestamp"`
		}{Type: "endingTimestamp", EndingTimestamp: *u.endingTimestamp}, nil
	case "scaleFactor":
		if u.scaleFactor == nil {
			return nil, fmt.Errorf("field \"scaleFactor\" is required")
		}
		return struct {
			Type        string  `json:"type"`
			ScaleFactor float64 `json:"scaleFactor"`
		}{Type: "scaleFactor", ScaleFactor: *u.scaleFactor}, nil
	}
}

func (u ScaleParameter) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ScaleParameter) UnmarshalJSON(data []byte) error {
	var deser scaleParameterDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return fmt.Errorf("field \"trueFrameRate\" is required")
		}
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return fmt.Errorf("field \"endingTimestamp\" is required")
		}
	case "scaleFactor":
		if u.scaleFactor == nil {
			return fmt.Errorf("field \"scaleFactor\" is required")
		}
	}
	return nil
}

func (u ScaleParameter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ScaleParameter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ScaleParameter) AcceptFuncs(trueFrameRateFunc func(float64) error, endingTimestampFunc func(UtcTimestamp) error, scaleFactorFunc func(float64) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return trueFrameRateFunc(*u.trueFrameRate)
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return endingTimestampFunc(*u.endingTimestamp)
	case "scaleFactor":
		if u.scaleFactor == nil {
			return fmt.Errorf("field \"scaleFactor\" is required")
		}
		return scaleFactorFunc(*u.scaleFactor)
	}
}

func (u *ScaleParameter) TrueFrameRateNoopSuccess(float64) error {
	return nil
}

func (u *ScaleParameter) EndingTimestampNoopSuccess(UtcTimestamp) error {
	return nil
}

func (u *ScaleParameter) ScaleFactorNoopSuccess(float64) error {
	return nil
}

func (u *ScaleParameter) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ScaleParameter) Accept(v ScaleParameterVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return v.VisitTrueFrameRate(*u.trueFrameRate)
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return v.VisitEndingTimestamp(*u.endingTimestamp)
	case "scaleFactor":
		if u.scaleFactor == nil {
			return fmt.Errorf("field \"scaleFactor\" is required")
		}
		return v.VisitScaleFactor(*u.scaleFactor)
	}
}

type ScaleParameterVisitor interface {
	VisitTrueFrameRate(v float64) error
	VisitEndingTimestamp(v UtcTimestamp) error
	VisitScaleFactor(v float64) error
	VisitUnknown(typeName string) error
}

func (u *ScaleParameter) AcceptWithContext(ctx context.Context, v ScaleParameterVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "trueFrameRate":
		if u.trueFrameRate == nil {
			return fmt.Errorf("field \"trueFrameRate\" is required")
		}
		return v.VisitTrueFrameRateWithContext(ctx, *u.trueFrameRate)
	case "endingTimestamp":
		if u.endingTimestamp == nil {
			return fmt.Errorf("field \"endingTimestamp\" is required")
		}
		return v.VisitEndingTimestampWithContext(ctx, *u.endingTimestamp)
	case "scaleFactor":
		if u.scaleFactor == nil {
			return fmt.Errorf("field \"scaleFactor\" is required")
		}
		return v.VisitScaleFactorWithContext(ctx, *u.scaleFactor)
	}
}

type ScaleParameterVisitorWithContext interface {
	VisitTrueFrameRateWithContext(ctx context.Context, v float64) error
	VisitEndingTimestampWithContext(ctx context.Context, v UtcTimestamp) error
	VisitScaleFactorWithContext(ctx context.Context, v float64) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewScaleParameterFromTrueFrameRate(v float64) ScaleParameter {
	return ScaleParameter{typ: "trueFrameRate", trueFrameRate: &v}
}

func NewScaleParameterFromEndingTimestamp(v UtcTimestamp) ScaleParameter {
	return ScaleParameter{typ: "endingTimestamp", endingTimestamp: &v}
}

func NewScaleParameterFromScaleFactor(v float64) ScaleParameter {
	return ScaleParameter{typ: "scaleFactor", scaleFactor: &v}
}

type SearchContainerizedExtractorsQuery struct {
	typ        string
	searchText *string
	label      *api.Label
	property   *api.Property
	and        *[]SearchContainerizedExtractorsQuery
	or         *[]SearchContainerizedExtractorsQuery
	workspace  *rids.WorkspaceRid
}

type searchContainerizedExtractorsQueryDeserializer struct {
	Type       string                                `json:"type"`
	SearchText *string                               `json:"searchText"`
	Label      *api.Label                            `json:"label"`
	Property   *api.Property                         `json:"property"`
	And        *[]SearchContainerizedExtractorsQuery `json:"and"`
	Or         *[]SearchContainerizedExtractorsQuery `json:"or"`
	Workspace  *rids.WorkspaceRid                    `json:"workspace"`
}

func (u *searchContainerizedExtractorsQueryDeserializer) toStruct() SearchContainerizedExtractorsQuery {
	return SearchContainerizedExtractorsQuery{typ: u.Type, searchText: u.SearchText, label: u.Label, property: u.Property, and: u.And, or: u.Or, workspace: u.Workspace}
}

func (u *SearchContainerizedExtractorsQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "label":
		if u.label == nil {
			return nil, fmt.Errorf("field \"label\" is required")
		}
		return struct {
			Type  string    `json:"type"`
			Label api.Label `json:"label"`
		}{Type: "label", Label: *u.label}, nil
	case "property":
		if u.property == nil {
			return nil, fmt.Errorf("field \"property\" is required")
		}
		return struct {
			Type     string       `json:"type"`
			Property api.Property `json:"property"`
		}{Type: "property", Property: *u.property}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string                               `json:"type"`
			And  []SearchContainerizedExtractorsQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string                               `json:"type"`
			Or   []SearchContainerizedExtractorsQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	}
}

func (u SearchContainerizedExtractorsQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchContainerizedExtractorsQuery) UnmarshalJSON(data []byte) error {
	var deser searchContainerizedExtractorsQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	}
	return nil
}

func (u SearchContainerizedExtractorsQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchContainerizedExtractorsQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchContainerizedExtractorsQuery) AcceptFuncs(searchTextFunc func(string) error, labelFunc func(api.Label) error, propertyFunc func(api.Property) error, andFunc func([]SearchContainerizedExtractorsQuery) error, orFunc func([]SearchContainerizedExtractorsQuery) error, workspaceFunc func(rids.WorkspaceRid) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return labelFunc(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return propertyFunc(*u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	}
}

func (u *SearchContainerizedExtractorsQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *SearchContainerizedExtractorsQuery) LabelNoopSuccess(api.Label) error {
	return nil
}

func (u *SearchContainerizedExtractorsQuery) PropertyNoopSuccess(api.Property) error {
	return nil
}

func (u *SearchContainerizedExtractorsQuery) AndNoopSuccess([]SearchContainerizedExtractorsQuery) error {
	return nil
}

func (u *SearchContainerizedExtractorsQuery) OrNoopSuccess([]SearchContainerizedExtractorsQuery) error {
	return nil
}

func (u *SearchContainerizedExtractorsQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *SearchContainerizedExtractorsQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchContainerizedExtractorsQuery) Accept(v SearchContainerizedExtractorsQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabel(*u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitProperty(*u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	}
}

type SearchContainerizedExtractorsQueryVisitor interface {
	VisitSearchText(v string) error
	VisitLabel(v api.Label) error
	VisitProperty(v api.Property) error
	VisitAnd(v []SearchContainerizedExtractorsQuery) error
	VisitOr(v []SearchContainerizedExtractorsQuery) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitUnknown(typeName string) error
}

func (u *SearchContainerizedExtractorsQuery) AcceptWithContext(ctx context.Context, v SearchContainerizedExtractorsQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "label":
		if u.label == nil {
			return fmt.Errorf("field \"label\" is required")
		}
		return v.VisitLabelWithContext(ctx, *u.label)
	case "property":
		if u.property == nil {
			return fmt.Errorf("field \"property\" is required")
		}
		return v.VisitPropertyWithContext(ctx, *u.property)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	}
}

type SearchContainerizedExtractorsQueryVisitorWithContext interface {
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitLabelWithContext(ctx context.Context, v api.Label) error
	VisitPropertyWithContext(ctx context.Context, v api.Property) error
	VisitAndWithContext(ctx context.Context, v []SearchContainerizedExtractorsQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchContainerizedExtractorsQuery) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchContainerizedExtractorsQueryFromSearchText(v string) SearchContainerizedExtractorsQuery {
	return SearchContainerizedExtractorsQuery{typ: "searchText", searchText: &v}
}

func NewSearchContainerizedExtractorsQueryFromLabel(v api.Label) SearchContainerizedExtractorsQuery {
	return SearchContainerizedExtractorsQuery{typ: "label", label: &v}
}

func NewSearchContainerizedExtractorsQueryFromProperty(v api.Property) SearchContainerizedExtractorsQuery {
	return SearchContainerizedExtractorsQuery{typ: "property", property: &v}
}

func NewSearchContainerizedExtractorsQueryFromAnd(v []SearchContainerizedExtractorsQuery) SearchContainerizedExtractorsQuery {
	return SearchContainerizedExtractorsQuery{typ: "and", and: &v}
}

func NewSearchContainerizedExtractorsQueryFromOr(v []SearchContainerizedExtractorsQuery) SearchContainerizedExtractorsQuery {
	return SearchContainerizedExtractorsQuery{typ: "or", or: &v}
}

func NewSearchContainerizedExtractorsQueryFromWorkspace(v rids.WorkspaceRid) SearchContainerizedExtractorsQuery {
	return SearchContainerizedExtractorsQuery{typ: "workspace", workspace: &v}
}

type TimeOffsetSpec struct {
	typ   string
	nanos *api1.Duration
}

type timeOffsetSpecDeserializer struct {
	Type  string         `json:"type"`
	Nanos *api1.Duration `json:"nanos"`
}

func (u *timeOffsetSpecDeserializer) toStruct() TimeOffsetSpec {
	return TimeOffsetSpec{typ: u.Type, nanos: u.Nanos}
}

func (u *TimeOffsetSpec) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "nanos":
		if u.nanos == nil {
			return nil, fmt.Errorf("field \"nanos\" is required")
		}
		return struct {
			Type  string        `json:"type"`
			Nanos api1.Duration `json:"nanos"`
		}{Type: "nanos", Nanos: *u.nanos}, nil
	}
}

func (u TimeOffsetSpec) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimeOffsetSpec) UnmarshalJSON(data []byte) error {
	var deser timeOffsetSpecDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "nanos":
		if u.nanos == nil {
			return fmt.Errorf("field \"nanos\" is required")
		}
	}
	return nil
}

func (u TimeOffsetSpec) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimeOffsetSpec) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimeOffsetSpec) AcceptFuncs(nanosFunc func(api1.Duration) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "nanos":
		if u.nanos == nil {
			return fmt.Errorf("field \"nanos\" is required")
		}
		return nanosFunc(*u.nanos)
	}
}

func (u *TimeOffsetSpec) NanosNoopSuccess(api1.Duration) error {
	return nil
}

func (u *TimeOffsetSpec) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimeOffsetSpec) Accept(v TimeOffsetSpecVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "nanos":
		if u.nanos == nil {
			return fmt.Errorf("field \"nanos\" is required")
		}
		return v.VisitNanos(*u.nanos)
	}
}

type TimeOffsetSpecVisitor interface {
	VisitNanos(v api1.Duration) error
	VisitUnknown(typeName string) error
}

func (u *TimeOffsetSpec) AcceptWithContext(ctx context.Context, v TimeOffsetSpecVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "nanos":
		if u.nanos == nil {
			return fmt.Errorf("field \"nanos\" is required")
		}
		return v.VisitNanosWithContext(ctx, *u.nanos)
	}
}

type TimeOffsetSpecVisitorWithContext interface {
	VisitNanosWithContext(ctx context.Context, v api1.Duration) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimeOffsetSpecFromNanos(v api1.Duration) TimeOffsetSpec {
	return TimeOffsetSpec{typ: "nanos", nanos: &v}
}

type TimestampType struct {
	typ      string
	relative *RelativeTimestamp
	absolute *AbsoluteTimestamp
}

type timestampTypeDeserializer struct {
	Type     string             `json:"type"`
	Relative *RelativeTimestamp `json:"relative"`
	Absolute *AbsoluteTimestamp `json:"absolute"`
}

func (u *timestampTypeDeserializer) toStruct() TimestampType {
	return TimestampType{typ: u.Type, relative: u.Relative, absolute: u.Absolute}
}

func (u *TimestampType) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "relative":
		if u.relative == nil {
			return nil, fmt.Errorf("field \"relative\" is required")
		}
		return struct {
			Type     string            `json:"type"`
			Relative RelativeTimestamp `json:"relative"`
		}{Type: "relative", Relative: *u.relative}, nil
	case "absolute":
		if u.absolute == nil {
			return nil, fmt.Errorf("field \"absolute\" is required")
		}
		return struct {
			Type     string            `json:"type"`
			Absolute AbsoluteTimestamp `json:"absolute"`
		}{Type: "absolute", Absolute: *u.absolute}, nil
	}
}

func (u TimestampType) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TimestampType) UnmarshalJSON(data []byte) error {
	var deser timestampTypeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
	}
	return nil
}

func (u TimestampType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TimestampType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TimestampType) AcceptFuncs(relativeFunc func(RelativeTimestamp) error, absoluteFunc func(AbsoluteTimestamp) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return relativeFunc(*u.relative)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return absoluteFunc(*u.absolute)
	}
}

func (u *TimestampType) RelativeNoopSuccess(RelativeTimestamp) error {
	return nil
}

func (u *TimestampType) AbsoluteNoopSuccess(AbsoluteTimestamp) error {
	return nil
}

func (u *TimestampType) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TimestampType) Accept(v TimestampTypeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelative(*u.relative)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsolute(*u.absolute)
	}
}

type TimestampTypeVisitor interface {
	VisitRelative(v RelativeTimestamp) error
	VisitAbsolute(v AbsoluteTimestamp) error
	VisitUnknown(typeName string) error
}

func (u *TimestampType) AcceptWithContext(ctx context.Context, v TimestampTypeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "relative":
		if u.relative == nil {
			return fmt.Errorf("field \"relative\" is required")
		}
		return v.VisitRelativeWithContext(ctx, *u.relative)
	case "absolute":
		if u.absolute == nil {
			return fmt.Errorf("field \"absolute\" is required")
		}
		return v.VisitAbsoluteWithContext(ctx, *u.absolute)
	}
}

type TimestampTypeVisitorWithContext interface {
	VisitRelativeWithContext(ctx context.Context, v RelativeTimestamp) error
	VisitAbsoluteWithContext(ctx context.Context, v AbsoluteTimestamp) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTimestampTypeFromRelative(v RelativeTimestamp) TimestampType {
	return TimestampType{typ: "relative", relative: &v}
}

func NewTimestampTypeFromAbsolute(v AbsoluteTimestamp) TimestampType {
	return TimestampType{typ: "absolute", absolute: &v}
}

type VideoIngestTarget struct {
	typ      string
	new      *NewVideoIngestDestination
	existing *ExistingVideoIngestDestination
}

type videoIngestTargetDeserializer struct {
	Type     string                          `json:"type"`
	New      *NewVideoIngestDestination      `json:"new"`
	Existing *ExistingVideoIngestDestination `json:"existing"`
}

func (u *videoIngestTargetDeserializer) toStruct() VideoIngestTarget {
	return VideoIngestTarget{typ: u.Type, new: u.New, existing: u.Existing}
}

func (u *VideoIngestTarget) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "new":
		if u.new == nil {
			return nil, fmt.Errorf("field \"new\" is required")
		}
		return struct {
			Type string                    `json:"type"`
			New  NewVideoIngestDestination `json:"new"`
		}{Type: "new", New: *u.new}, nil
	case "existing":
		if u.existing == nil {
			return nil, fmt.Errorf("field \"existing\" is required")
		}
		return struct {
			Type     string                         `json:"type"`
			Existing ExistingVideoIngestDestination `json:"existing"`
		}{Type: "existing", Existing: *u.existing}, nil
	}
}

func (u VideoIngestTarget) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VideoIngestTarget) UnmarshalJSON(data []byte) error {
	var deser videoIngestTargetDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "new":
		if u.new == nil {
			return fmt.Errorf("field \"new\" is required")
		}
	case "existing":
		if u.existing == nil {
			return fmt.Errorf("field \"existing\" is required")
		}
	}
	return nil
}

func (u VideoIngestTarget) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VideoIngestTarget) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VideoIngestTarget) AcceptFuncs(newFunc func(NewVideoIngestDestination) error, existingFunc func(ExistingVideoIngestDestination) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "new":
		if u.new == nil {
			return fmt.Errorf("field \"new\" is required")
		}
		return newFunc(*u.new)
	case "existing":
		if u.existing == nil {
			return fmt.Errorf("field \"existing\" is required")
		}
		return existingFunc(*u.existing)
	}
}

func (u *VideoIngestTarget) NewNoopSuccess(NewVideoIngestDestination) error {
	return nil
}

func (u *VideoIngestTarget) ExistingNoopSuccess(ExistingVideoIngestDestination) error {
	return nil
}

func (u *VideoIngestTarget) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VideoIngestTarget) Accept(v VideoIngestTargetVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "new":
		if u.new == nil {
			return fmt.Errorf("field \"new\" is required")
		}
		return v.VisitNew(*u.new)
	case "existing":
		if u.existing == nil {
			return fmt.Errorf("field \"existing\" is required")
		}
		return v.VisitExisting(*u.existing)
	}
}

type VideoIngestTargetVisitor interface {
	VisitNew(v NewVideoIngestDestination) error
	VisitExisting(v ExistingVideoIngestDestination) error
	VisitUnknown(typeName string) error
}

func (u *VideoIngestTarget) AcceptWithContext(ctx context.Context, v VideoIngestTargetVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "new":
		if u.new == nil {
			return fmt.Errorf("field \"new\" is required")
		}
		return v.VisitNewWithContext(ctx, *u.new)
	case "existing":
		if u.existing == nil {
			return fmt.Errorf("field \"existing\" is required")
		}
		return v.VisitExistingWithContext(ctx, *u.existing)
	}
}

type VideoIngestTargetVisitorWithContext interface {
	VisitNewWithContext(ctx context.Context, v NewVideoIngestDestination) error
	VisitExistingWithContext(ctx context.Context, v ExistingVideoIngestDestination) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVideoIngestTargetFromNew(v NewVideoIngestDestination) VideoIngestTarget {
	return VideoIngestTarget{typ: "new", new: &v}
}

func NewVideoIngestTargetFromExisting(v ExistingVideoIngestDestination) VideoIngestTarget {
	return VideoIngestTarget{typ: "existing", existing: &v}
}

type VideoTimestampManifest struct {
	typ                string
	noManifest         *NoTimestampManifest
	timestampManifests *TimestampManifest
}

type videoTimestampManifestDeserializer struct {
	Type               string               `json:"type"`
	NoManifest         *NoTimestampManifest `json:"noManifest"`
	TimestampManifests *TimestampManifest   `json:"timestampManifests"`
}

func (u *videoTimestampManifestDeserializer) toStruct() VideoTimestampManifest {
	return VideoTimestampManifest{typ: u.Type, noManifest: u.NoManifest, timestampManifests: u.TimestampManifests}
}

func (u *VideoTimestampManifest) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "noManifest":
		if u.noManifest == nil {
			return nil, fmt.Errorf("field \"noManifest\" is required")
		}
		return struct {
			Type       string              `json:"type"`
			NoManifest NoTimestampManifest `json:"noManifest"`
		}{Type: "noManifest", NoManifest: *u.noManifest}, nil
	case "timestampManifests":
		if u.timestampManifests == nil {
			return nil, fmt.Errorf("field \"timestampManifests\" is required")
		}
		return struct {
			Type               string            `json:"type"`
			TimestampManifests TimestampManifest `json:"timestampManifests"`
		}{Type: "timestampManifests", TimestampManifests: *u.timestampManifests}, nil
	}
}

func (u VideoTimestampManifest) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VideoTimestampManifest) UnmarshalJSON(data []byte) error {
	var deser videoTimestampManifestDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
	case "timestampManifests":
		if u.timestampManifests == nil {
			return fmt.Errorf("field \"timestampManifests\" is required")
		}
	}
	return nil
}

func (u VideoTimestampManifest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VideoTimestampManifest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VideoTimestampManifest) AcceptFuncs(noManifestFunc func(NoTimestampManifest) error, timestampManifestsFunc func(TimestampManifest) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
		return noManifestFunc(*u.noManifest)
	case "timestampManifests":
		if u.timestampManifests == nil {
			return fmt.Errorf("field \"timestampManifests\" is required")
		}
		return timestampManifestsFunc(*u.timestampManifests)
	}
}

func (u *VideoTimestampManifest) NoManifestNoopSuccess(NoTimestampManifest) error {
	return nil
}

func (u *VideoTimestampManifest) TimestampManifestsNoopSuccess(TimestampManifest) error {
	return nil
}

func (u *VideoTimestampManifest) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VideoTimestampManifest) Accept(v VideoTimestampManifestVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
		return v.VisitNoManifest(*u.noManifest)
	case "timestampManifests":
		if u.timestampManifests == nil {
			return fmt.Errorf("field \"timestampManifests\" is required")
		}
		return v.VisitTimestampManifests(*u.timestampManifests)
	}
}

type VideoTimestampManifestVisitor interface {
	VisitNoManifest(v NoTimestampManifest) error
	VisitTimestampManifests(v TimestampManifest) error
	VisitUnknown(typeName string) error
}

func (u *VideoTimestampManifest) AcceptWithContext(ctx context.Context, v VideoTimestampManifestVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "noManifest":
		if u.noManifest == nil {
			return fmt.Errorf("field \"noManifest\" is required")
		}
		return v.VisitNoManifestWithContext(ctx, *u.noManifest)
	case "timestampManifests":
		if u.timestampManifests == nil {
			return fmt.Errorf("field \"timestampManifests\" is required")
		}
		return v.VisitTimestampManifestsWithContext(ctx, *u.timestampManifests)
	}
}

type VideoTimestampManifestVisitorWithContext interface {
	VisitNoManifestWithContext(ctx context.Context, v NoTimestampManifest) error
	VisitTimestampManifestsWithContext(ctx context.Context, v TimestampManifest) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVideoTimestampManifestFromNoManifest(v NoTimestampManifest) VideoTimestampManifest {
	return VideoTimestampManifest{typ: "noManifest", noManifest: &v}
}

func NewVideoTimestampManifestFromTimestampManifests(v TimestampManifest) VideoTimestampManifest {
	return VideoTimestampManifest{typ: "timestampManifests", timestampManifests: &v}
}
