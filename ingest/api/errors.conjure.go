// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type batchGranularityMismatch struct {
	DatasetRids map[api.Granularity][]rid.ResourceIdentifier `json:"datasetRids"`
}

func (o batchGranularityMismatch) MarshalJSON() ([]byte, error) {
	if o.DatasetRids == nil {
		o.DatasetRids = make(map[api.Granularity][]rid.ResourceIdentifier, 0)
	}
	type _tmpbatchGranularityMismatch batchGranularityMismatch
	return safejson.Marshal(_tmpbatchGranularityMismatch(o))
}

func (o *batchGranularityMismatch) UnmarshalJSON(data []byte) error {
	type _tmpbatchGranularityMismatch batchGranularityMismatch
	var rawbatchGranularityMismatch _tmpbatchGranularityMismatch
	if err := safejson.Unmarshal(data, &rawbatchGranularityMismatch); err != nil {
		return err
	}
	if rawbatchGranularityMismatch.DatasetRids == nil {
		rawbatchGranularityMismatch.DatasetRids = make(map[api.Granularity][]rid.ResourceIdentifier, 0)
	}
	*o = batchGranularityMismatch(rawbatchGranularityMismatch)
	return nil
}

func (o batchGranularityMismatch) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *batchGranularityMismatch) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewBatchGranularityMismatch returns new instance of BatchGranularityMismatch error.
func NewBatchGranularityMismatch(datasetRidsArg map[api.Granularity][]rid.ResourceIdentifier) *BatchGranularityMismatch {
	return &BatchGranularityMismatch{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), batchGranularityMismatch: batchGranularityMismatch{DatasetRids: datasetRidsArg}}
}

// WrapWithBatchGranularityMismatch returns new instance of BatchGranularityMismatch error wrapping an existing error.
func WrapWithBatchGranularityMismatch(err error, datasetRidsArg map[api.Granularity][]rid.ResourceIdentifier) *BatchGranularityMismatch {
	return &BatchGranularityMismatch{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, batchGranularityMismatch: batchGranularityMismatch{DatasetRids: datasetRidsArg}}
}

// BatchGranularityMismatch is an error type.
// All dataset granularities must match.
type BatchGranularityMismatch struct {
	errorInstanceID uuid.UUID
	batchGranularityMismatch
	cause error
	stack werror.StackTrace
}

// IsBatchGranularityMismatch returns true if err is an instance of BatchGranularityMismatch.
func IsBatchGranularityMismatch(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*BatchGranularityMismatch)
	return ok
}

func (e *BatchGranularityMismatch) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:BatchGranularityMismatch (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *BatchGranularityMismatch) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *BatchGranularityMismatch) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *BatchGranularityMismatch) Message() string {
	return "INVALID_ARGUMENT IngestService:BatchGranularityMismatch"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *BatchGranularityMismatch) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *BatchGranularityMismatch) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *BatchGranularityMismatch) Name() string {
	return "IngestService:BatchGranularityMismatch"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *BatchGranularityMismatch) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *BatchGranularityMismatch) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRids": e.DatasetRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *BatchGranularityMismatch) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRids": e.DatasetRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *BatchGranularityMismatch) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *BatchGranularityMismatch) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *BatchGranularityMismatch) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e BatchGranularityMismatch) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.batchGranularityMismatch)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:BatchGranularityMismatch", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *BatchGranularityMismatch) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters batchGranularityMismatch
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.batchGranularityMismatch = parameters
	return nil
}

type containerizedExtractorContainerFailed struct {
	Message string `json:"message"`
}

func (o containerizedExtractorContainerFailed) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *containerizedExtractorContainerFailed) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewContainerizedExtractorContainerFailed returns new instance of ContainerizedExtractorContainerFailed error.
func NewContainerizedExtractorContainerFailed(messageArg string) *ContainerizedExtractorContainerFailed {
	return &ContainerizedExtractorContainerFailed{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), containerizedExtractorContainerFailed: containerizedExtractorContainerFailed{Message: messageArg}}
}

// WrapWithContainerizedExtractorContainerFailed returns new instance of ContainerizedExtractorContainerFailed error wrapping an existing error.
func WrapWithContainerizedExtractorContainerFailed(err error, messageArg string) *ContainerizedExtractorContainerFailed {
	return &ContainerizedExtractorContainerFailed{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, containerizedExtractorContainerFailed: containerizedExtractorContainerFailed{Message: messageArg}}
}

// ContainerizedExtractorContainerFailed is an error type.
type ContainerizedExtractorContainerFailed struct {
	errorInstanceID uuid.UUID
	containerizedExtractorContainerFailed
	cause error
	stack werror.StackTrace
}

// IsContainerizedExtractorContainerFailed returns true if err is an instance of ContainerizedExtractorContainerFailed.
func IsContainerizedExtractorContainerFailed(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ContainerizedExtractorContainerFailed)
	return ok
}

func (e *ContainerizedExtractorContainerFailed) Error() string {
	return fmt.Sprintf("INTERNAL IngestService:ContainerizedExtractorContainerFailed (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ContainerizedExtractorContainerFailed) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ContainerizedExtractorContainerFailed) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ContainerizedExtractorContainerFailed) Message() string {
	return "INTERNAL IngestService:ContainerizedExtractorContainerFailed"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ContainerizedExtractorContainerFailed) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ContainerizedExtractorContainerFailed) Code() errors.ErrorCode {
	return errors.Internal
}

// Name returns an error name identifying error type.
func (e *ContainerizedExtractorContainerFailed) Name() string {
	return "IngestService:ContainerizedExtractorContainerFailed"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ContainerizedExtractorContainerFailed) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ContainerizedExtractorContainerFailed) Parameters() map[string]interface{} {
	return map[string]interface{}{"message": e.Message}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ContainerizedExtractorContainerFailed) safeParams() map[string]interface{} {
	return map[string]interface{}{"message": e.Message, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ContainerizedExtractorContainerFailed) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ContainerizedExtractorContainerFailed) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ContainerizedExtractorContainerFailed) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ContainerizedExtractorContainerFailed) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.containerizedExtractorContainerFailed)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Internal, ErrorName: "IngestService:ContainerizedExtractorContainerFailed", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ContainerizedExtractorContainerFailed) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters containerizedExtractorContainerFailed
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.containerizedExtractorContainerFailed = parameters
	return nil
}

type containerizedExtractorNotFound struct {
	ExtractorRid rid.ResourceIdentifier `json:"extractorRid"`
}

func (o containerizedExtractorNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *containerizedExtractorNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewContainerizedExtractorNotFound returns new instance of ContainerizedExtractorNotFound error.
func NewContainerizedExtractorNotFound(extractorRidArg rid.ResourceIdentifier) *ContainerizedExtractorNotFound {
	return &ContainerizedExtractorNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), containerizedExtractorNotFound: containerizedExtractorNotFound{ExtractorRid: extractorRidArg}}
}

// WrapWithContainerizedExtractorNotFound returns new instance of ContainerizedExtractorNotFound error wrapping an existing error.
func WrapWithContainerizedExtractorNotFound(err error, extractorRidArg rid.ResourceIdentifier) *ContainerizedExtractorNotFound {
	return &ContainerizedExtractorNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, containerizedExtractorNotFound: containerizedExtractorNotFound{ExtractorRid: extractorRidArg}}
}

// ContainerizedExtractorNotFound is an error type.
type ContainerizedExtractorNotFound struct {
	errorInstanceID uuid.UUID
	containerizedExtractorNotFound
	cause error
	stack werror.StackTrace
}

// IsContainerizedExtractorNotFound returns true if err is an instance of ContainerizedExtractorNotFound.
func IsContainerizedExtractorNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ContainerizedExtractorNotFound)
	return ok
}

func (e *ContainerizedExtractorNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND ContainerizedExtractor:ContainerizedExtractorNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ContainerizedExtractorNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ContainerizedExtractorNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ContainerizedExtractorNotFound) Message() string {
	return "NOT_FOUND ContainerizedExtractor:ContainerizedExtractorNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ContainerizedExtractorNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ContainerizedExtractorNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *ContainerizedExtractorNotFound) Name() string {
	return "ContainerizedExtractor:ContainerizedExtractorNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ContainerizedExtractorNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ContainerizedExtractorNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"extractorRid": e.ExtractorRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ContainerizedExtractorNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"extractorRid": e.ExtractorRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ContainerizedExtractorNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ContainerizedExtractorNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ContainerizedExtractorNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ContainerizedExtractorNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.containerizedExtractorNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "ContainerizedExtractor:ContainerizedExtractorNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ContainerizedExtractorNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters containerizedExtractorNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.containerizedExtractorNotFound = parameters
	return nil
}

type containerizedExtractorsNotFound struct {
	ExtractorRids []rid.ResourceIdentifier `json:"extractorRids"`
}

func (o containerizedExtractorsNotFound) MarshalJSON() ([]byte, error) {
	if o.ExtractorRids == nil {
		o.ExtractorRids = make([]rid.ResourceIdentifier, 0)
	}
	type _tmpcontainerizedExtractorsNotFound containerizedExtractorsNotFound
	return safejson.Marshal(_tmpcontainerizedExtractorsNotFound(o))
}

func (o *containerizedExtractorsNotFound) UnmarshalJSON(data []byte) error {
	type _tmpcontainerizedExtractorsNotFound containerizedExtractorsNotFound
	var rawcontainerizedExtractorsNotFound _tmpcontainerizedExtractorsNotFound
	if err := safejson.Unmarshal(data, &rawcontainerizedExtractorsNotFound); err != nil {
		return err
	}
	if rawcontainerizedExtractorsNotFound.ExtractorRids == nil {
		rawcontainerizedExtractorsNotFound.ExtractorRids = make([]rid.ResourceIdentifier, 0)
	}
	*o = containerizedExtractorsNotFound(rawcontainerizedExtractorsNotFound)
	return nil
}

func (o containerizedExtractorsNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *containerizedExtractorsNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewContainerizedExtractorsNotFound returns new instance of ContainerizedExtractorsNotFound error.
func NewContainerizedExtractorsNotFound(extractorRidsArg []rid.ResourceIdentifier) *ContainerizedExtractorsNotFound {
	return &ContainerizedExtractorsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), containerizedExtractorsNotFound: containerizedExtractorsNotFound{ExtractorRids: extractorRidsArg}}
}

// WrapWithContainerizedExtractorsNotFound returns new instance of ContainerizedExtractorsNotFound error wrapping an existing error.
func WrapWithContainerizedExtractorsNotFound(err error, extractorRidsArg []rid.ResourceIdentifier) *ContainerizedExtractorsNotFound {
	return &ContainerizedExtractorsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, containerizedExtractorsNotFound: containerizedExtractorsNotFound{ExtractorRids: extractorRidsArg}}
}

// ContainerizedExtractorsNotFound is an error type.
type ContainerizedExtractorsNotFound struct {
	errorInstanceID uuid.UUID
	containerizedExtractorsNotFound
	cause error
	stack werror.StackTrace
}

// IsContainerizedExtractorsNotFound returns true if err is an instance of ContainerizedExtractorsNotFound.
func IsContainerizedExtractorsNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ContainerizedExtractorsNotFound)
	return ok
}

func (e *ContainerizedExtractorsNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND ContainerizedExtractor:ContainerizedExtractorsNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ContainerizedExtractorsNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ContainerizedExtractorsNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ContainerizedExtractorsNotFound) Message() string {
	return "NOT_FOUND ContainerizedExtractor:ContainerizedExtractorsNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ContainerizedExtractorsNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ContainerizedExtractorsNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *ContainerizedExtractorsNotFound) Name() string {
	return "ContainerizedExtractor:ContainerizedExtractorsNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ContainerizedExtractorsNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ContainerizedExtractorsNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"extractorRids": e.ExtractorRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ContainerizedExtractorsNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"extractorRids": e.ExtractorRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ContainerizedExtractorsNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ContainerizedExtractorsNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ContainerizedExtractorsNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ContainerizedExtractorsNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.containerizedExtractorsNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "ContainerizedExtractor:ContainerizedExtractorsNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ContainerizedExtractorsNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters containerizedExtractorsNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.containerizedExtractorsNotFound = parameters
	return nil
}

type datasetFileNotFound struct {
	DatasetRid rids.DatasetRid `json:"datasetRid"`
	FileId     uuid.UUID       `json:"fileId"`
}

func (o datasetFileNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *datasetFileNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDatasetFileNotFound returns new instance of DatasetFileNotFound error.
func NewDatasetFileNotFound(datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) *DatasetFileNotFound {
	return &DatasetFileNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), datasetFileNotFound: datasetFileNotFound{DatasetRid: datasetRidArg, FileId: fileIdArg}}
}

// WrapWithDatasetFileNotFound returns new instance of DatasetFileNotFound error wrapping an existing error.
func WrapWithDatasetFileNotFound(err error, datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) *DatasetFileNotFound {
	return &DatasetFileNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, datasetFileNotFound: datasetFileNotFound{DatasetRid: datasetRidArg, FileId: fileIdArg}}
}

// DatasetFileNotFound is an error type.
// The target dataset file could not be found.
type DatasetFileNotFound struct {
	errorInstanceID uuid.UUID
	datasetFileNotFound
	cause error
	stack werror.StackTrace
}

// IsDatasetFileNotFound returns true if err is an instance of DatasetFileNotFound.
func IsDatasetFileNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DatasetFileNotFound)
	return ok
}

func (e *DatasetFileNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND IngestService:DatasetFileNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DatasetFileNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DatasetFileNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DatasetFileNotFound) Message() string {
	return "NOT_FOUND IngestService:DatasetFileNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DatasetFileNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DatasetFileNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *DatasetFileNotFound) Name() string {
	return "IngestService:DatasetFileNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DatasetFileNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DatasetFileNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "fileId": e.FileId}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DatasetFileNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "fileId": e.FileId, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetFileNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DatasetFileNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetFileNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DatasetFileNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.datasetFileNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "IngestService:DatasetFileNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DatasetFileNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters datasetFileNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.datasetFileNotFound = parameters
	return nil
}

type datasetNotFound struct {
	DatasetRid rids.DatasetRid `json:"datasetRid"`
}

func (o datasetNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *datasetNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDatasetNotFound returns new instance of DatasetNotFound error.
func NewDatasetNotFound(datasetRidArg rids.DatasetRid) *DatasetNotFound {
	return &DatasetNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), datasetNotFound: datasetNotFound{DatasetRid: datasetRidArg}}
}

// WrapWithDatasetNotFound returns new instance of DatasetNotFound error wrapping an existing error.
func WrapWithDatasetNotFound(err error, datasetRidArg rids.DatasetRid) *DatasetNotFound {
	return &DatasetNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, datasetNotFound: datasetNotFound{DatasetRid: datasetRidArg}}
}

// DatasetNotFound is an error type.
// The target dataset could not be found.
type DatasetNotFound struct {
	errorInstanceID uuid.UUID
	datasetNotFound
	cause error
	stack werror.StackTrace
}

// IsDatasetNotFound returns true if err is an instance of DatasetNotFound.
func IsDatasetNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DatasetNotFound)
	return ok
}

func (e *DatasetNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND IngestService:DatasetNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DatasetNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DatasetNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DatasetNotFound) Message() string {
	return "NOT_FOUND IngestService:DatasetNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DatasetNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DatasetNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *DatasetNotFound) Name() string {
	return "IngestService:DatasetNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DatasetNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DatasetNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DatasetNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DatasetNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DatasetNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DatasetNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.datasetNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "IngestService:DatasetNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DatasetNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters datasetNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.datasetNotFound = parameters
	return nil
}

type emptyMultipartUpload struct{}

func (o emptyMultipartUpload) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *emptyMultipartUpload) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewEmptyMultipartUpload returns new instance of EmptyMultipartUpload error.
func NewEmptyMultipartUpload() *EmptyMultipartUpload {
	return &EmptyMultipartUpload{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), emptyMultipartUpload: emptyMultipartUpload{}}
}

// WrapWithEmptyMultipartUpload returns new instance of EmptyMultipartUpload error wrapping an existing error.
func WrapWithEmptyMultipartUpload(err error) *EmptyMultipartUpload {
	return &EmptyMultipartUpload{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, emptyMultipartUpload: emptyMultipartUpload{}}
}

// EmptyMultipartUpload is an error type.
type EmptyMultipartUpload struct {
	errorInstanceID uuid.UUID
	emptyMultipartUpload
	cause error
	stack werror.StackTrace
}

// IsEmptyMultipartUpload returns true if err is an instance of EmptyMultipartUpload.
func IsEmptyMultipartUpload(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*EmptyMultipartUpload)
	return ok
}

func (e *EmptyMultipartUpload) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT UploadService:EmptyMultipartUpload (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *EmptyMultipartUpload) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *EmptyMultipartUpload) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *EmptyMultipartUpload) Message() string {
	return "INVALID_ARGUMENT UploadService:EmptyMultipartUpload"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *EmptyMultipartUpload) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *EmptyMultipartUpload) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *EmptyMultipartUpload) Name() string {
	return "UploadService:EmptyMultipartUpload"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *EmptyMultipartUpload) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *EmptyMultipartUpload) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *EmptyMultipartUpload) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *EmptyMultipartUpload) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *EmptyMultipartUpload) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *EmptyMultipartUpload) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e EmptyMultipartUpload) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.emptyMultipartUpload)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "UploadService:EmptyMultipartUpload", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *EmptyMultipartUpload) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters emptyMultipartUpload
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.emptyMultipartUpload = parameters
	return nil
}

type failedToDownloadFile struct{}

func (o failedToDownloadFile) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *failedToDownloadFile) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewFailedToDownloadFile returns new instance of FailedToDownloadFile error.
func NewFailedToDownloadFile() *FailedToDownloadFile {
	return &FailedToDownloadFile{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), failedToDownloadFile: failedToDownloadFile{}}
}

// WrapWithFailedToDownloadFile returns new instance of FailedToDownloadFile error wrapping an existing error.
func WrapWithFailedToDownloadFile(err error) *FailedToDownloadFile {
	return &FailedToDownloadFile{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, failedToDownloadFile: failedToDownloadFile{}}
}

// FailedToDownloadFile is an error type.
type FailedToDownloadFile struct {
	errorInstanceID uuid.UUID
	failedToDownloadFile
	cause error
	stack werror.StackTrace
}

// IsFailedToDownloadFile returns true if err is an instance of FailedToDownloadFile.
func IsFailedToDownloadFile(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*FailedToDownloadFile)
	return ok
}

func (e *FailedToDownloadFile) Error() string {
	return fmt.Sprintf("INTERNAL IngestService:FailedToDownloadFile (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *FailedToDownloadFile) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *FailedToDownloadFile) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *FailedToDownloadFile) Message() string {
	return "INTERNAL IngestService:FailedToDownloadFile"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *FailedToDownloadFile) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *FailedToDownloadFile) Code() errors.ErrorCode {
	return errors.Internal
}

// Name returns an error name identifying error type.
func (e *FailedToDownloadFile) Name() string {
	return "IngestService:FailedToDownloadFile"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *FailedToDownloadFile) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *FailedToDownloadFile) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *FailedToDownloadFile) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *FailedToDownloadFile) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *FailedToDownloadFile) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *FailedToDownloadFile) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e FailedToDownloadFile) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.failedToDownloadFile)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Internal, ErrorName: "IngestService:FailedToDownloadFile", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *FailedToDownloadFile) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters failedToDownloadFile
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.failedToDownloadFile = parameters
	return nil
}

type failedToDownloadFileUserError struct{}

func (o failedToDownloadFileUserError) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *failedToDownloadFileUserError) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewFailedToDownloadFileUserError returns new instance of FailedToDownloadFileUserError error.
func NewFailedToDownloadFileUserError() *FailedToDownloadFileUserError {
	return &FailedToDownloadFileUserError{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), failedToDownloadFileUserError: failedToDownloadFileUserError{}}
}

// WrapWithFailedToDownloadFileUserError returns new instance of FailedToDownloadFileUserError error wrapping an existing error.
func WrapWithFailedToDownloadFileUserError(err error) *FailedToDownloadFileUserError {
	return &FailedToDownloadFileUserError{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, failedToDownloadFileUserError: failedToDownloadFileUserError{}}
}

// FailedToDownloadFileUserError is an error type.
type FailedToDownloadFileUserError struct {
	errorInstanceID uuid.UUID
	failedToDownloadFileUserError
	cause error
	stack werror.StackTrace
}

// IsFailedToDownloadFileUserError returns true if err is an instance of FailedToDownloadFileUserError.
func IsFailedToDownloadFileUserError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*FailedToDownloadFileUserError)
	return ok
}

func (e *FailedToDownloadFileUserError) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:FailedToDownloadFileUserError (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *FailedToDownloadFileUserError) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *FailedToDownloadFileUserError) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *FailedToDownloadFileUserError) Message() string {
	return "INVALID_ARGUMENT IngestService:FailedToDownloadFileUserError"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *FailedToDownloadFileUserError) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *FailedToDownloadFileUserError) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *FailedToDownloadFileUserError) Name() string {
	return "IngestService:FailedToDownloadFileUserError"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *FailedToDownloadFileUserError) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *FailedToDownloadFileUserError) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *FailedToDownloadFileUserError) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *FailedToDownloadFileUserError) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *FailedToDownloadFileUserError) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *FailedToDownloadFileUserError) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e FailedToDownloadFileUserError) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.failedToDownloadFileUserError)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:FailedToDownloadFileUserError", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *FailedToDownloadFileUserError) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters failedToDownloadFileUserError
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.failedToDownloadFileUserError = parameters
	return nil
}

type frameCountTimestampsMismatch struct{}

func (o frameCountTimestampsMismatch) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *frameCountTimestampsMismatch) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewFrameCountTimestampsMismatch returns new instance of FrameCountTimestampsMismatch error.
func NewFrameCountTimestampsMismatch() *FrameCountTimestampsMismatch {
	return &FrameCountTimestampsMismatch{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), frameCountTimestampsMismatch: frameCountTimestampsMismatch{}}
}

// WrapWithFrameCountTimestampsMismatch returns new instance of FrameCountTimestampsMismatch error wrapping an existing error.
func WrapWithFrameCountTimestampsMismatch(err error) *FrameCountTimestampsMismatch {
	return &FrameCountTimestampsMismatch{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, frameCountTimestampsMismatch: frameCountTimestampsMismatch{}}
}

// FrameCountTimestampsMismatch is an error type.
type FrameCountTimestampsMismatch struct {
	errorInstanceID uuid.UUID
	frameCountTimestampsMismatch
	cause error
	stack werror.StackTrace
}

// IsFrameCountTimestampsMismatch returns true if err is an instance of FrameCountTimestampsMismatch.
func IsFrameCountTimestampsMismatch(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*FrameCountTimestampsMismatch)
	return ok
}

func (e *FrameCountTimestampsMismatch) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:FrameCountTimestampsMismatch (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *FrameCountTimestampsMismatch) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *FrameCountTimestampsMismatch) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *FrameCountTimestampsMismatch) Message() string {
	return "INVALID_ARGUMENT IngestService:FrameCountTimestampsMismatch"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *FrameCountTimestampsMismatch) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *FrameCountTimestampsMismatch) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *FrameCountTimestampsMismatch) Name() string {
	return "IngestService:FrameCountTimestampsMismatch"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *FrameCountTimestampsMismatch) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *FrameCountTimestampsMismatch) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *FrameCountTimestampsMismatch) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *FrameCountTimestampsMismatch) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *FrameCountTimestampsMismatch) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *FrameCountTimestampsMismatch) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e FrameCountTimestampsMismatch) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.frameCountTimestampsMismatch)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:FrameCountTimestampsMismatch", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *FrameCountTimestampsMismatch) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters frameCountTimestampsMismatch
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.frameCountTimestampsMismatch = parameters
	return nil
}

type incompatibleConnectionTypeAndLogQuery struct{}

func (o incompatibleConnectionTypeAndLogQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *incompatibleConnectionTypeAndLogQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewIncompatibleConnectionTypeAndLogQuery returns new instance of IncompatibleConnectionTypeAndLogQuery error.
func NewIncompatibleConnectionTypeAndLogQuery() *IncompatibleConnectionTypeAndLogQuery {
	return &IncompatibleConnectionTypeAndLogQuery{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), incompatibleConnectionTypeAndLogQuery: incompatibleConnectionTypeAndLogQuery{}}
}

// WrapWithIncompatibleConnectionTypeAndLogQuery returns new instance of IncompatibleConnectionTypeAndLogQuery error wrapping an existing error.
func WrapWithIncompatibleConnectionTypeAndLogQuery(err error) *IncompatibleConnectionTypeAndLogQuery {
	return &IncompatibleConnectionTypeAndLogQuery{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, incompatibleConnectionTypeAndLogQuery: incompatibleConnectionTypeAndLogQuery{}}
}

// IncompatibleConnectionTypeAndLogQuery is an error type.
type IncompatibleConnectionTypeAndLogQuery struct {
	errorInstanceID uuid.UUID
	incompatibleConnectionTypeAndLogQuery
	cause error
	stack werror.StackTrace
}

// IsIncompatibleConnectionTypeAndLogQuery returns true if err is an instance of IncompatibleConnectionTypeAndLogQuery.
func IsIncompatibleConnectionTypeAndLogQuery(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*IncompatibleConnectionTypeAndLogQuery)
	return ok
}

func (e *IncompatibleConnectionTypeAndLogQuery) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:IncompatibleConnectionTypeAndLogQuery (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *IncompatibleConnectionTypeAndLogQuery) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *IncompatibleConnectionTypeAndLogQuery) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *IncompatibleConnectionTypeAndLogQuery) Message() string {
	return "INVALID_ARGUMENT IngestService:IncompatibleConnectionTypeAndLogQuery"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *IncompatibleConnectionTypeAndLogQuery) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *IncompatibleConnectionTypeAndLogQuery) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *IncompatibleConnectionTypeAndLogQuery) Name() string {
	return "IngestService:IncompatibleConnectionTypeAndLogQuery"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *IncompatibleConnectionTypeAndLogQuery) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *IncompatibleConnectionTypeAndLogQuery) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *IncompatibleConnectionTypeAndLogQuery) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *IncompatibleConnectionTypeAndLogQuery) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *IncompatibleConnectionTypeAndLogQuery) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *IncompatibleConnectionTypeAndLogQuery) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e IncompatibleConnectionTypeAndLogQuery) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.incompatibleConnectionTypeAndLogQuery)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:IncompatibleConnectionTypeAndLogQuery", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *IncompatibleConnectionTypeAndLogQuery) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters incompatibleConnectionTypeAndLogQuery
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.incompatibleConnectionTypeAndLogQuery = parameters
	return nil
}

type incompatibleFileForDataset struct{}

func (o incompatibleFileForDataset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *incompatibleFileForDataset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewIncompatibleFileForDataset returns new instance of IncompatibleFileForDataset error.
func NewIncompatibleFileForDataset() *IncompatibleFileForDataset {
	return &IncompatibleFileForDataset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), incompatibleFileForDataset: incompatibleFileForDataset{}}
}

// WrapWithIncompatibleFileForDataset returns new instance of IncompatibleFileForDataset error wrapping an existing error.
func WrapWithIncompatibleFileForDataset(err error) *IncompatibleFileForDataset {
	return &IncompatibleFileForDataset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, incompatibleFileForDataset: incompatibleFileForDataset{}}
}

// IncompatibleFileForDataset is an error type.
type IncompatibleFileForDataset struct {
	errorInstanceID uuid.UUID
	incompatibleFileForDataset
	cause error
	stack werror.StackTrace
}

// IsIncompatibleFileForDataset returns true if err is an instance of IncompatibleFileForDataset.
func IsIncompatibleFileForDataset(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*IncompatibleFileForDataset)
	return ok
}

func (e *IncompatibleFileForDataset) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:IncompatibleFileForDataset (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *IncompatibleFileForDataset) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *IncompatibleFileForDataset) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *IncompatibleFileForDataset) Message() string {
	return "INVALID_ARGUMENT IngestService:IncompatibleFileForDataset"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *IncompatibleFileForDataset) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *IncompatibleFileForDataset) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *IncompatibleFileForDataset) Name() string {
	return "IngestService:IncompatibleFileForDataset"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *IncompatibleFileForDataset) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *IncompatibleFileForDataset) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *IncompatibleFileForDataset) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *IncompatibleFileForDataset) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *IncompatibleFileForDataset) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *IncompatibleFileForDataset) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e IncompatibleFileForDataset) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.incompatibleFileForDataset)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:IncompatibleFileForDataset", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *IncompatibleFileForDataset) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters incompatibleFileForDataset
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.incompatibleFileForDataset = parameters
	return nil
}

type incompatibleInputs struct {
	Message *string `json:"message,omitempty"`
}

func (o incompatibleInputs) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *incompatibleInputs) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewIncompatibleInputs returns new instance of IncompatibleInputs error.
func NewIncompatibleInputs(messageArg *string) *IncompatibleInputs {
	return &IncompatibleInputs{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), incompatibleInputs: incompatibleInputs{Message: messageArg}}
}

// WrapWithIncompatibleInputs returns new instance of IncompatibleInputs error wrapping an existing error.
func WrapWithIncompatibleInputs(err error, messageArg *string) *IncompatibleInputs {
	return &IncompatibleInputs{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, incompatibleInputs: incompatibleInputs{Message: messageArg}}
}

// IncompatibleInputs is an error type.
// The inputs provided to the ingest job are incompatible with each other
type IncompatibleInputs struct {
	errorInstanceID uuid.UUID
	incompatibleInputs
	cause error
	stack werror.StackTrace
}

// IsIncompatibleInputs returns true if err is an instance of IncompatibleInputs.
func IsIncompatibleInputs(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*IncompatibleInputs)
	return ok
}

func (e *IncompatibleInputs) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:IncompatibleInputs (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *IncompatibleInputs) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *IncompatibleInputs) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *IncompatibleInputs) Message() string {
	return "INVALID_ARGUMENT IngestService:IncompatibleInputs"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *IncompatibleInputs) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *IncompatibleInputs) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *IncompatibleInputs) Name() string {
	return "IngestService:IncompatibleInputs"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *IncompatibleInputs) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *IncompatibleInputs) Parameters() map[string]interface{} {
	return map[string]interface{}{"message": e.Message}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *IncompatibleInputs) safeParams() map[string]interface{} {
	return map[string]interface{}{"message": e.Message, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *IncompatibleInputs) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *IncompatibleInputs) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *IncompatibleInputs) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e IncompatibleInputs) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.incompatibleInputs)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:IncompatibleInputs", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *IncompatibleInputs) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters incompatibleInputs
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.incompatibleInputs = parameters
	return nil
}

type incorrectSizeBytes struct{}

func (o incorrectSizeBytes) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *incorrectSizeBytes) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewIncorrectSizeBytes returns new instance of IncorrectSizeBytes error.
func NewIncorrectSizeBytes() *IncorrectSizeBytes {
	return &IncorrectSizeBytes{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), incorrectSizeBytes: incorrectSizeBytes{}}
}

// WrapWithIncorrectSizeBytes returns new instance of IncorrectSizeBytes error wrapping an existing error.
func WrapWithIncorrectSizeBytes(err error) *IncorrectSizeBytes {
	return &IncorrectSizeBytes{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, incorrectSizeBytes: incorrectSizeBytes{}}
}

// IncorrectSizeBytes is an error type.
type IncorrectSizeBytes struct {
	errorInstanceID uuid.UUID
	incorrectSizeBytes
	cause error
	stack werror.StackTrace
}

// IsIncorrectSizeBytes returns true if err is an instance of IncorrectSizeBytes.
func IsIncorrectSizeBytes(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*IncorrectSizeBytes)
	return ok
}

func (e *IncorrectSizeBytes) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT UploadService:IncorrectSizeBytes (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *IncorrectSizeBytes) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *IncorrectSizeBytes) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *IncorrectSizeBytes) Message() string {
	return "INVALID_ARGUMENT UploadService:IncorrectSizeBytes"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *IncorrectSizeBytes) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *IncorrectSizeBytes) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *IncorrectSizeBytes) Name() string {
	return "UploadService:IncorrectSizeBytes"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *IncorrectSizeBytes) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *IncorrectSizeBytes) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *IncorrectSizeBytes) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *IncorrectSizeBytes) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *IncorrectSizeBytes) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *IncorrectSizeBytes) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e IncorrectSizeBytes) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.incorrectSizeBytes)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "UploadService:IncorrectSizeBytes", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *IncorrectSizeBytes) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters incorrectSizeBytes
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.incorrectSizeBytes = parameters
	return nil
}

type ingestJobNotCompatibleForRerun struct {
	Message      string       `json:"message"`
	IngestJobRid IngestJobRid `json:"ingestJobRid"`
}

func (o ingestJobNotCompatibleForRerun) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ingestJobNotCompatibleForRerun) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewIngestJobNotCompatibleForRerun returns new instance of IngestJobNotCompatibleForRerun error.
func NewIngestJobNotCompatibleForRerun(messageArg string, ingestJobRidArg IngestJobRid) *IngestJobNotCompatibleForRerun {
	return &IngestJobNotCompatibleForRerun{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), ingestJobNotCompatibleForRerun: ingestJobNotCompatibleForRerun{Message: messageArg, IngestJobRid: ingestJobRidArg}}
}

// WrapWithIngestJobNotCompatibleForRerun returns new instance of IngestJobNotCompatibleForRerun error wrapping an existing error.
func WrapWithIngestJobNotCompatibleForRerun(err error, messageArg string, ingestJobRidArg IngestJobRid) *IngestJobNotCompatibleForRerun {
	return &IngestJobNotCompatibleForRerun{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, ingestJobNotCompatibleForRerun: ingestJobNotCompatibleForRerun{Message: messageArg, IngestJobRid: ingestJobRidArg}}
}

// IngestJobNotCompatibleForRerun is an error type.
// The ingest job exists but is not compatible to be re-run.
type IngestJobNotCompatibleForRerun struct {
	errorInstanceID uuid.UUID
	ingestJobNotCompatibleForRerun
	cause error
	stack werror.StackTrace
}

// IsIngestJobNotCompatibleForRerun returns true if err is an instance of IngestJobNotCompatibleForRerun.
func IsIngestJobNotCompatibleForRerun(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*IngestJobNotCompatibleForRerun)
	return ok
}

func (e *IngestJobNotCompatibleForRerun) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:IngestJobNotCompatibleForRerun (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *IngestJobNotCompatibleForRerun) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *IngestJobNotCompatibleForRerun) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *IngestJobNotCompatibleForRerun) Message() string {
	return "INVALID_ARGUMENT IngestService:IngestJobNotCompatibleForRerun"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *IngestJobNotCompatibleForRerun) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *IngestJobNotCompatibleForRerun) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *IngestJobNotCompatibleForRerun) Name() string {
	return "IngestService:IngestJobNotCompatibleForRerun"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *IngestJobNotCompatibleForRerun) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *IngestJobNotCompatibleForRerun) Parameters() map[string]interface{} {
	return map[string]interface{}{"message": e.Message, "ingestJobRid": e.IngestJobRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *IngestJobNotCompatibleForRerun) safeParams() map[string]interface{} {
	return map[string]interface{}{"message": e.Message, "ingestJobRid": e.IngestJobRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *IngestJobNotCompatibleForRerun) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *IngestJobNotCompatibleForRerun) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *IngestJobNotCompatibleForRerun) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e IngestJobNotCompatibleForRerun) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.ingestJobNotCompatibleForRerun)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:IngestJobNotCompatibleForRerun", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *IngestJobNotCompatibleForRerun) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters ingestJobNotCompatibleForRerun
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.ingestJobNotCompatibleForRerun = parameters
	return nil
}

type ingestJobNotFound struct {
	IngestJobRid IngestJobRid `json:"ingestJobRid"`
}

func (o ingestJobNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ingestJobNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewIngestJobNotFound returns new instance of IngestJobNotFound error.
func NewIngestJobNotFound(ingestJobRidArg IngestJobRid) *IngestJobNotFound {
	return &IngestJobNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), ingestJobNotFound: ingestJobNotFound{IngestJobRid: ingestJobRidArg}}
}

// WrapWithIngestJobNotFound returns new instance of IngestJobNotFound error wrapping an existing error.
func WrapWithIngestJobNotFound(err error, ingestJobRidArg IngestJobRid) *IngestJobNotFound {
	return &IngestJobNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, ingestJobNotFound: ingestJobNotFound{IngestJobRid: ingestJobRidArg}}
}

// IngestJobNotFound is an error type.
type IngestJobNotFound struct {
	errorInstanceID uuid.UUID
	ingestJobNotFound
	cause error
	stack werror.StackTrace
}

// IsIngestJobNotFound returns true if err is an instance of IngestJobNotFound.
func IsIngestJobNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*IngestJobNotFound)
	return ok
}

func (e *IngestJobNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND IngestService:IngestJobNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *IngestJobNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *IngestJobNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *IngestJobNotFound) Message() string {
	return "NOT_FOUND IngestService:IngestJobNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *IngestJobNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *IngestJobNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *IngestJobNotFound) Name() string {
	return "IngestService:IngestJobNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *IngestJobNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *IngestJobNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"ingestJobRid": e.IngestJobRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *IngestJobNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"ingestJobRid": e.IngestJobRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *IngestJobNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *IngestJobNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *IngestJobNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e IngestJobNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.ingestJobNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "IngestService:IngestJobNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *IngestJobNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters ingestJobNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.ingestJobNotFound = parameters
	return nil
}

type invalidBucket struct {
	Bucket string `json:"bucket"`
}

func (o invalidBucket) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidBucket) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidBucket returns new instance of InvalidBucket error.
func NewInvalidBucket(bucketArg string) *InvalidBucket {
	return &InvalidBucket{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidBucket: invalidBucket{Bucket: bucketArg}}
}

// WrapWithInvalidBucket returns new instance of InvalidBucket error wrapping an existing error.
func WrapWithInvalidBucket(err error, bucketArg string) *InvalidBucket {
	return &InvalidBucket{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidBucket: invalidBucket{Bucket: bucketArg}}
}

// InvalidBucket is an error type.
type InvalidBucket struct {
	errorInstanceID uuid.UUID
	invalidBucket
	cause error
	stack werror.StackTrace
}

// IsInvalidBucket returns true if err is an instance of InvalidBucket.
func IsInvalidBucket(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidBucket)
	return ok
}

func (e *InvalidBucket) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:InvalidBucket (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidBucket) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidBucket) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidBucket) Message() string {
	return "INVALID_ARGUMENT IngestService:InvalidBucket"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidBucket) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidBucket) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidBucket) Name() string {
	return "IngestService:InvalidBucket"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidBucket) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidBucket) Parameters() map[string]interface{} {
	return map[string]interface{}{"bucket": e.Bucket}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidBucket) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidBucket) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidBucket) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"bucket": e.Bucket}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidBucket) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidBucket) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidBucket)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:InvalidBucket", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidBucket) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidBucket
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidBucket = parameters
	return nil
}

type invalidContainerImage struct {
	Image DockerImageSource `json:"image"`
}

func (o invalidContainerImage) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidContainerImage) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidContainerImage returns new instance of InvalidContainerImage error.
func NewInvalidContainerImage(imageArg DockerImageSource) *InvalidContainerImage {
	return &InvalidContainerImage{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidContainerImage: invalidContainerImage{Image: imageArg}}
}

// WrapWithInvalidContainerImage returns new instance of InvalidContainerImage error wrapping an existing error.
func WrapWithInvalidContainerImage(err error, imageArg DockerImageSource) *InvalidContainerImage {
	return &InvalidContainerImage{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidContainerImage: invalidContainerImage{Image: imageArg}}
}

// InvalidContainerImage is an error type.
type InvalidContainerImage struct {
	errorInstanceID uuid.UUID
	invalidContainerImage
	cause error
	stack werror.StackTrace
}

// IsInvalidContainerImage returns true if err is an instance of InvalidContainerImage.
func IsInvalidContainerImage(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidContainerImage)
	return ok
}

func (e *InvalidContainerImage) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT ContainerizedExtractor:InvalidContainerImage (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidContainerImage) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidContainerImage) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidContainerImage) Message() string {
	return "INVALID_ARGUMENT ContainerizedExtractor:InvalidContainerImage"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidContainerImage) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidContainerImage) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidContainerImage) Name() string {
	return "ContainerizedExtractor:InvalidContainerImage"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidContainerImage) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidContainerImage) Parameters() map[string]interface{} {
	return map[string]interface{}{"image": e.Image}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidContainerImage) safeParams() map[string]interface{} {
	return map[string]interface{}{"image": e.Image, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidContainerImage) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidContainerImage) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidContainerImage) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidContainerImage) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidContainerImage)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "ContainerizedExtractor:InvalidContainerImage", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidContainerImage) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidContainerImage
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidContainerImage = parameters
	return nil
}

type invalidCustomTimestampFormat struct {
	TimeFormat string `json:"timeFormat"`
	Reason     string `json:"reason"`
}

func (o invalidCustomTimestampFormat) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidCustomTimestampFormat) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidCustomTimestampFormat returns new instance of InvalidCustomTimestampFormat error.
func NewInvalidCustomTimestampFormat(timeFormatArg string, reasonArg string) *InvalidCustomTimestampFormat {
	return &InvalidCustomTimestampFormat{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidCustomTimestampFormat: invalidCustomTimestampFormat{TimeFormat: timeFormatArg, Reason: reasonArg}}
}

// WrapWithInvalidCustomTimestampFormat returns new instance of InvalidCustomTimestampFormat error wrapping an existing error.
func WrapWithInvalidCustomTimestampFormat(err error, timeFormatArg string, reasonArg string) *InvalidCustomTimestampFormat {
	return &InvalidCustomTimestampFormat{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidCustomTimestampFormat: invalidCustomTimestampFormat{TimeFormat: timeFormatArg, Reason: reasonArg}}
}

// InvalidCustomTimestampFormat is an error type.
type InvalidCustomTimestampFormat struct {
	errorInstanceID uuid.UUID
	invalidCustomTimestampFormat
	cause error
	stack werror.StackTrace
}

// IsInvalidCustomTimestampFormat returns true if err is an instance of InvalidCustomTimestampFormat.
func IsInvalidCustomTimestampFormat(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidCustomTimestampFormat)
	return ok
}

func (e *InvalidCustomTimestampFormat) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:InvalidCustomTimestampFormat (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidCustomTimestampFormat) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidCustomTimestampFormat) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidCustomTimestampFormat) Message() string {
	return "INVALID_ARGUMENT IngestService:InvalidCustomTimestampFormat"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidCustomTimestampFormat) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidCustomTimestampFormat) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidCustomTimestampFormat) Name() string {
	return "IngestService:InvalidCustomTimestampFormat"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidCustomTimestampFormat) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidCustomTimestampFormat) Parameters() map[string]interface{} {
	return map[string]interface{}{"timeFormat": e.TimeFormat, "reason": e.Reason}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidCustomTimestampFormat) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidCustomTimestampFormat) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidCustomTimestampFormat) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"timeFormat": e.TimeFormat, "reason": e.Reason}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidCustomTimestampFormat) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidCustomTimestampFormat) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidCustomTimestampFormat)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:InvalidCustomTimestampFormat", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidCustomTimestampFormat) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidCustomTimestampFormat
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidCustomTimestampFormat = parameters
	return nil
}

type invalidDefaultTag struct {
	DefaultTag string `json:"defaultTag"`
}

func (o invalidDefaultTag) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidDefaultTag) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidDefaultTag returns new instance of InvalidDefaultTag error.
func NewInvalidDefaultTag(defaultTagArg string) *InvalidDefaultTag {
	return &InvalidDefaultTag{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidDefaultTag: invalidDefaultTag{DefaultTag: defaultTagArg}}
}

// WrapWithInvalidDefaultTag returns new instance of InvalidDefaultTag error wrapping an existing error.
func WrapWithInvalidDefaultTag(err error, defaultTagArg string) *InvalidDefaultTag {
	return &InvalidDefaultTag{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidDefaultTag: invalidDefaultTag{DefaultTag: defaultTagArg}}
}

// InvalidDefaultTag is an error type.
type InvalidDefaultTag struct {
	errorInstanceID uuid.UUID
	invalidDefaultTag
	cause error
	stack werror.StackTrace
}

// IsInvalidDefaultTag returns true if err is an instance of InvalidDefaultTag.
func IsInvalidDefaultTag(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidDefaultTag)
	return ok
}

func (e *InvalidDefaultTag) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT ContainerizedExtractor:InvalidDefaultTag (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidDefaultTag) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidDefaultTag) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidDefaultTag) Message() string {
	return "INVALID_ARGUMENT ContainerizedExtractor:InvalidDefaultTag"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidDefaultTag) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidDefaultTag) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidDefaultTag) Name() string {
	return "ContainerizedExtractor:InvalidDefaultTag"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidDefaultTag) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidDefaultTag) Parameters() map[string]interface{} {
	return map[string]interface{}{"defaultTag": e.DefaultTag}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidDefaultTag) safeParams() map[string]interface{} {
	return map[string]interface{}{"defaultTag": e.DefaultTag, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidDefaultTag) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidDefaultTag) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidDefaultTag) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidDefaultTag) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidDefaultTag)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "ContainerizedExtractor:InvalidDefaultTag", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidDefaultTag) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidDefaultTag
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidDefaultTag = parameters
	return nil
}

type invalidOutputFileFormat struct {
	OutputFileFormat string `json:"outputFileFormat"`
}

func (o invalidOutputFileFormat) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidOutputFileFormat) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidOutputFileFormat returns new instance of InvalidOutputFileFormat error.
func NewInvalidOutputFileFormat(outputFileFormatArg string) *InvalidOutputFileFormat {
	return &InvalidOutputFileFormat{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidOutputFileFormat: invalidOutputFileFormat{OutputFileFormat: outputFileFormatArg}}
}

// WrapWithInvalidOutputFileFormat returns new instance of InvalidOutputFileFormat error wrapping an existing error.
func WrapWithInvalidOutputFileFormat(err error, outputFileFormatArg string) *InvalidOutputFileFormat {
	return &InvalidOutputFileFormat{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidOutputFileFormat: invalidOutputFileFormat{OutputFileFormat: outputFileFormatArg}}
}

// InvalidOutputFileFormat is an error type.
type InvalidOutputFileFormat struct {
	errorInstanceID uuid.UUID
	invalidOutputFileFormat
	cause error
	stack werror.StackTrace
}

// IsInvalidOutputFileFormat returns true if err is an instance of InvalidOutputFileFormat.
func IsInvalidOutputFileFormat(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidOutputFileFormat)
	return ok
}

func (e *InvalidOutputFileFormat) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT ContainerizedExtractor:InvalidOutputFileFormat (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidOutputFileFormat) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidOutputFileFormat) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidOutputFileFormat) Message() string {
	return "INVALID_ARGUMENT ContainerizedExtractor:InvalidOutputFileFormat"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidOutputFileFormat) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidOutputFileFormat) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidOutputFileFormat) Name() string {
	return "ContainerizedExtractor:InvalidOutputFileFormat"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidOutputFileFormat) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidOutputFileFormat) Parameters() map[string]interface{} {
	return map[string]interface{}{"outputFileFormat": e.OutputFileFormat}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidOutputFileFormat) safeParams() map[string]interface{} {
	return map[string]interface{}{"outputFileFormat": e.OutputFileFormat, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidOutputFileFormat) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidOutputFileFormat) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidOutputFileFormat) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidOutputFileFormat) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidOutputFileFormat)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "ContainerizedExtractor:InvalidOutputFileFormat", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidOutputFileFormat) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidOutputFileFormat
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidOutputFileFormat = parameters
	return nil
}

type invalidS3Path struct {
	Path string `json:"path"`
}

func (o invalidS3Path) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidS3Path) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidS3Path returns new instance of InvalidS3Path error.
func NewInvalidS3Path(pathArg string) *InvalidS3Path {
	return &InvalidS3Path{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidS3Path: invalidS3Path{Path: pathArg}}
}

// WrapWithInvalidS3Path returns new instance of InvalidS3Path error wrapping an existing error.
func WrapWithInvalidS3Path(err error, pathArg string) *InvalidS3Path {
	return &InvalidS3Path{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidS3Path: invalidS3Path{Path: pathArg}}
}

// InvalidS3Path is an error type.
type InvalidS3Path struct {
	errorInstanceID uuid.UUID
	invalidS3Path
	cause error
	stack werror.StackTrace
}

// IsInvalidS3Path returns true if err is an instance of InvalidS3Path.
func IsInvalidS3Path(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidS3Path)
	return ok
}

func (e *InvalidS3Path) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:InvalidS3Path (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidS3Path) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidS3Path) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidS3Path) Message() string {
	return "INVALID_ARGUMENT IngestService:InvalidS3Path"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidS3Path) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidS3Path) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidS3Path) Name() string {
	return "IngestService:InvalidS3Path"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidS3Path) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidS3Path) Parameters() map[string]interface{} {
	return map[string]interface{}{"path": e.Path}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidS3Path) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidS3Path) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidS3Path) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"path": e.Path}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidS3Path) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidS3Path) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidS3Path)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:InvalidS3Path", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidS3Path) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidS3Path
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidS3Path = parameters
	return nil
}

type invalidUrl struct {
	Url string `json:"url"`
}

func (o invalidUrl) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidUrl) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidUrl returns new instance of InvalidUrl error.
func NewInvalidUrl(urlArg string) *InvalidUrl {
	return &InvalidUrl{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidUrl: invalidUrl{Url: urlArg}}
}

// WrapWithInvalidUrl returns new instance of InvalidUrl error wrapping an existing error.
func WrapWithInvalidUrl(err error, urlArg string) *InvalidUrl {
	return &InvalidUrl{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidUrl: invalidUrl{Url: urlArg}}
}

// InvalidUrl is an error type.
type InvalidUrl struct {
	errorInstanceID uuid.UUID
	invalidUrl
	cause error
	stack werror.StackTrace
}

// IsInvalidUrl returns true if err is an instance of InvalidUrl.
func IsInvalidUrl(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidUrl)
	return ok
}

func (e *InvalidUrl) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:InvalidUrl (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidUrl) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidUrl) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidUrl) Message() string {
	return "INVALID_ARGUMENT IngestService:InvalidUrl"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidUrl) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidUrl) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidUrl) Name() string {
	return "IngestService:InvalidUrl"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidUrl) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidUrl) Parameters() map[string]interface{} {
	return map[string]interface{}{"url": e.Url}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidUrl) safeParams() map[string]interface{} {
	return map[string]interface{}{"url": e.Url, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidUrl) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidUrl) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidUrl) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidUrl) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidUrl)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:InvalidUrl", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidUrl) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidUrl
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidUrl = parameters
	return nil
}

type missingMetadataForReingest struct {
	DatasetRids []rids.DatasetRid `json:"datasetRids"`
}

func (o missingMetadataForReingest) MarshalJSON() ([]byte, error) {
	if o.DatasetRids == nil {
		o.DatasetRids = make([]rids.DatasetRid, 0)
	}
	type _tmpmissingMetadataForReingest missingMetadataForReingest
	return safejson.Marshal(_tmpmissingMetadataForReingest(o))
}

func (o *missingMetadataForReingest) UnmarshalJSON(data []byte) error {
	type _tmpmissingMetadataForReingest missingMetadataForReingest
	var rawmissingMetadataForReingest _tmpmissingMetadataForReingest
	if err := safejson.Unmarshal(data, &rawmissingMetadataForReingest); err != nil {
		return err
	}
	if rawmissingMetadataForReingest.DatasetRids == nil {
		rawmissingMetadataForReingest.DatasetRids = make([]rids.DatasetRid, 0)
	}
	*o = missingMetadataForReingest(rawmissingMetadataForReingest)
	return nil
}

func (o missingMetadataForReingest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *missingMetadataForReingest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMissingMetadataForReingest returns new instance of MissingMetadataForReingest error.
func NewMissingMetadataForReingest(datasetRidsArg []rids.DatasetRid) *MissingMetadataForReingest {
	return &MissingMetadataForReingest{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), missingMetadataForReingest: missingMetadataForReingest{DatasetRids: datasetRidsArg}}
}

// WrapWithMissingMetadataForReingest returns new instance of MissingMetadataForReingest error wrapping an existing error.
func WrapWithMissingMetadataForReingest(err error, datasetRidsArg []rids.DatasetRid) *MissingMetadataForReingest {
	return &MissingMetadataForReingest{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, missingMetadataForReingest: missingMetadataForReingest{DatasetRids: datasetRidsArg}}
}

// MissingMetadataForReingest is an error type.
// The timestamp metadata required to reingest the dataset is missing and must be provided in the request.
type MissingMetadataForReingest struct {
	errorInstanceID uuid.UUID
	missingMetadataForReingest
	cause error
	stack werror.StackTrace
}

// IsMissingMetadataForReingest returns true if err is an instance of MissingMetadataForReingest.
func IsMissingMetadataForReingest(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MissingMetadataForReingest)
	return ok
}

func (e *MissingMetadataForReingest) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:MissingMetadataForReingest (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MissingMetadataForReingest) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MissingMetadataForReingest) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MissingMetadataForReingest) Message() string {
	return "INVALID_ARGUMENT IngestService:MissingMetadataForReingest"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MissingMetadataForReingest) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MissingMetadataForReingest) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MissingMetadataForReingest) Name() string {
	return "IngestService:MissingMetadataForReingest"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MissingMetadataForReingest) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MissingMetadataForReingest) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRids": e.DatasetRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MissingMetadataForReingest) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRids": e.DatasetRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingMetadataForReingest) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MissingMetadataForReingest) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MissingMetadataForReingest) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MissingMetadataForReingest) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.missingMetadataForReingest)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:MissingMetadataForReingest", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MissingMetadataForReingest) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters missingMetadataForReingest
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.missingMetadataForReingest = parameters
	return nil
}

type nullKey struct{}

func (o nullKey) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *nullKey) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNullKey returns new instance of NullKey error.
func NewNullKey() *NullKey {
	return &NullKey{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), nullKey: nullKey{}}
}

// WrapWithNullKey returns new instance of NullKey error wrapping an existing error.
func WrapWithNullKey(err error) *NullKey {
	return &NullKey{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, nullKey: nullKey{}}
}

// NullKey is an error type.
type NullKey struct {
	errorInstanceID uuid.UUID
	nullKey
	cause error
	stack werror.StackTrace
}

// IsNullKey returns true if err is an instance of NullKey.
func IsNullKey(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NullKey)
	return ok
}

func (e *NullKey) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT UploadService:NullKey (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NullKey) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NullKey) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NullKey) Message() string {
	return "INVALID_ARGUMENT UploadService:NullKey"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NullKey) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NullKey) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *NullKey) Name() string {
	return "UploadService:NullKey"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NullKey) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NullKey) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NullKey) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NullKey) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NullKey) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NullKey) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NullKey) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.nullKey)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "UploadService:NullKey", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NullKey) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters nullKey
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.nullKey = parameters
	return nil
}

type parallelReingestIntoDatasetV1 struct{}

func (o parallelReingestIntoDatasetV1) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *parallelReingestIntoDatasetV1) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewParallelReingestIntoDatasetV1 returns new instance of ParallelReingestIntoDatasetV1 error.
func NewParallelReingestIntoDatasetV1() *ParallelReingestIntoDatasetV1 {
	return &ParallelReingestIntoDatasetV1{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), parallelReingestIntoDatasetV1: parallelReingestIntoDatasetV1{}}
}

// WrapWithParallelReingestIntoDatasetV1 returns new instance of ParallelReingestIntoDatasetV1 error wrapping an existing error.
func WrapWithParallelReingestIntoDatasetV1(err error) *ParallelReingestIntoDatasetV1 {
	return &ParallelReingestIntoDatasetV1{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, parallelReingestIntoDatasetV1: parallelReingestIntoDatasetV1{}}
}

// ParallelReingestIntoDatasetV1 is an error type.
/*
Cannot ingest multiple datasets in parallel into older datasets.
It is recommended to reingest all source datasets and the target dataset into a new dataset destination.
*/
type ParallelReingestIntoDatasetV1 struct {
	errorInstanceID uuid.UUID
	parallelReingestIntoDatasetV1
	cause error
	stack werror.StackTrace
}

// IsParallelReingestIntoDatasetV1 returns true if err is an instance of ParallelReingestIntoDatasetV1.
func IsParallelReingestIntoDatasetV1(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ParallelReingestIntoDatasetV1)
	return ok
}

func (e *ParallelReingestIntoDatasetV1) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:ParallelReingestIntoDatasetV1 (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ParallelReingestIntoDatasetV1) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ParallelReingestIntoDatasetV1) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ParallelReingestIntoDatasetV1) Message() string {
	return "INVALID_ARGUMENT IngestService:ParallelReingestIntoDatasetV1"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ParallelReingestIntoDatasetV1) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ParallelReingestIntoDatasetV1) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ParallelReingestIntoDatasetV1) Name() string {
	return "IngestService:ParallelReingestIntoDatasetV1"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ParallelReingestIntoDatasetV1) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ParallelReingestIntoDatasetV1) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ParallelReingestIntoDatasetV1) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ParallelReingestIntoDatasetV1) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ParallelReingestIntoDatasetV1) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ParallelReingestIntoDatasetV1) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ParallelReingestIntoDatasetV1) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.parallelReingestIntoDatasetV1)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:ParallelReingestIntoDatasetV1", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ParallelReingestIntoDatasetV1) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters parallelReingestIntoDatasetV1
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.parallelReingestIntoDatasetV1 = parameters
	return nil
}

type recursiveReingest struct{}

func (o recursiveReingest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *recursiveReingest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewRecursiveReingest returns new instance of RecursiveReingest error.
func NewRecursiveReingest() *RecursiveReingest {
	return &RecursiveReingest{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), recursiveReingest: recursiveReingest{}}
}

// WrapWithRecursiveReingest returns new instance of RecursiveReingest error wrapping an existing error.
func WrapWithRecursiveReingest(err error) *RecursiveReingest {
	return &RecursiveReingest{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, recursiveReingest: recursiveReingest{}}
}

// RecursiveReingest is an error type.
// The target dataset is included in the source datasets.
type RecursiveReingest struct {
	errorInstanceID uuid.UUID
	recursiveReingest
	cause error
	stack werror.StackTrace
}

// IsRecursiveReingest returns true if err is an instance of RecursiveReingest.
func IsRecursiveReingest(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*RecursiveReingest)
	return ok
}

func (e *RecursiveReingest) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:RecursiveReingest (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *RecursiveReingest) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *RecursiveReingest) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *RecursiveReingest) Message() string {
	return "INVALID_ARGUMENT IngestService:RecursiveReingest"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *RecursiveReingest) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *RecursiveReingest) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *RecursiveReingest) Name() string {
	return "IngestService:RecursiveReingest"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *RecursiveReingest) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *RecursiveReingest) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *RecursiveReingest) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *RecursiveReingest) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *RecursiveReingest) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *RecursiveReingest) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e RecursiveReingest) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.recursiveReingest)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:RecursiveReingest", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *RecursiveReingest) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters recursiveReingest
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.recursiveReingest = parameters
	return nil
}

type reingestTooManyFiles struct {
	MaxFiles int `json:"maxFiles"`
}

func (o reingestTooManyFiles) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *reingestTooManyFiles) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewReingestTooManyFiles returns new instance of ReingestTooManyFiles error.
func NewReingestTooManyFiles(maxFilesArg int) *ReingestTooManyFiles {
	return &ReingestTooManyFiles{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), reingestTooManyFiles: reingestTooManyFiles{MaxFiles: maxFilesArg}}
}

// WrapWithReingestTooManyFiles returns new instance of ReingestTooManyFiles error wrapping an existing error.
func WrapWithReingestTooManyFiles(err error, maxFilesArg int) *ReingestTooManyFiles {
	return &ReingestTooManyFiles{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, reingestTooManyFiles: reingestTooManyFiles{MaxFiles: maxFilesArg}}
}

// ReingestTooManyFiles is an error type.
// The number of files to reingest is too large.
type ReingestTooManyFiles struct {
	errorInstanceID uuid.UUID
	reingestTooManyFiles
	cause error
	stack werror.StackTrace
}

// IsReingestTooManyFiles returns true if err is an instance of ReingestTooManyFiles.
func IsReingestTooManyFiles(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ReingestTooManyFiles)
	return ok
}

func (e *ReingestTooManyFiles) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:ReingestTooManyFiles (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ReingestTooManyFiles) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ReingestTooManyFiles) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ReingestTooManyFiles) Message() string {
	return "INVALID_ARGUMENT IngestService:ReingestTooManyFiles"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ReingestTooManyFiles) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ReingestTooManyFiles) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ReingestTooManyFiles) Name() string {
	return "IngestService:ReingestTooManyFiles"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ReingestTooManyFiles) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ReingestTooManyFiles) Parameters() map[string]interface{} {
	return map[string]interface{}{"maxFiles": e.MaxFiles}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ReingestTooManyFiles) safeParams() map[string]interface{} {
	return map[string]interface{}{"maxFiles": e.MaxFiles, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ReingestTooManyFiles) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ReingestTooManyFiles) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ReingestTooManyFiles) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ReingestTooManyFiles) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.reingestTooManyFiles)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:ReingestTooManyFiles", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ReingestTooManyFiles) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters reingestTooManyFiles
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.reingestTooManyFiles = parameters
	return nil
}

type runBoundsInverted struct{}

func (o runBoundsInverted) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *runBoundsInverted) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewRunBoundsInverted returns new instance of RunBoundsInverted error.
func NewRunBoundsInverted() *RunBoundsInverted {
	return &RunBoundsInverted{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), runBoundsInverted: runBoundsInverted{}}
}

// WrapWithRunBoundsInverted returns new instance of RunBoundsInverted error wrapping an existing error.
func WrapWithRunBoundsInverted(err error) *RunBoundsInverted {
	return &RunBoundsInverted{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, runBoundsInverted: runBoundsInverted{}}
}

// RunBoundsInverted is an error type.
type RunBoundsInverted struct {
	errorInstanceID uuid.UUID
	runBoundsInverted
	cause error
	stack werror.StackTrace
}

// IsRunBoundsInverted returns true if err is an instance of RunBoundsInverted.
func IsRunBoundsInverted(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*RunBoundsInverted)
	return ok
}

func (e *RunBoundsInverted) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:RunBoundsInverted (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *RunBoundsInverted) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *RunBoundsInverted) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *RunBoundsInverted) Message() string {
	return "INVALID_ARGUMENT IngestService:RunBoundsInverted"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *RunBoundsInverted) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *RunBoundsInverted) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *RunBoundsInverted) Name() string {
	return "IngestService:RunBoundsInverted"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *RunBoundsInverted) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *RunBoundsInverted) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *RunBoundsInverted) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *RunBoundsInverted) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *RunBoundsInverted) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *RunBoundsInverted) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e RunBoundsInverted) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.runBoundsInverted)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:RunBoundsInverted", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *RunBoundsInverted) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters runBoundsInverted
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.runBoundsInverted = parameters
	return nil
}

type s3PathNotFound struct {
	S3Path api.S3Path `json:"s3Path"`
}

func (o s3PathNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *s3PathNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewS3PathNotFound returns new instance of S3PathNotFound error.
func NewS3PathNotFound(s3PathArg api.S3Path) *S3PathNotFound {
	return &S3PathNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), s3PathNotFound: s3PathNotFound{S3Path: s3PathArg}}
}

// WrapWithS3PathNotFound returns new instance of S3PathNotFound error wrapping an existing error.
func WrapWithS3PathNotFound(err error, s3PathArg api.S3Path) *S3PathNotFound {
	return &S3PathNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, s3PathNotFound: s3PathNotFound{S3Path: s3PathArg}}
}

// S3PathNotFound is an error type.
type S3PathNotFound struct {
	errorInstanceID uuid.UUID
	s3PathNotFound
	cause error
	stack werror.StackTrace
}

// IsS3PathNotFound returns true if err is an instance of S3PathNotFound.
func IsS3PathNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*S3PathNotFound)
	return ok
}

func (e *S3PathNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND IngestService:S3PathNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *S3PathNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *S3PathNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *S3PathNotFound) Message() string {
	return "NOT_FOUND IngestService:S3PathNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *S3PathNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *S3PathNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *S3PathNotFound) Name() string {
	return "IngestService:S3PathNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *S3PathNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *S3PathNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"s3Path": e.S3Path}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *S3PathNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *S3PathNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *S3PathNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"s3Path": e.S3Path}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *S3PathNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e S3PathNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.s3PathNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "IngestService:S3PathNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *S3PathNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters s3PathNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.s3PathNotFound = parameters
	return nil
}

type unsupportedIngestSource struct{}

func (o unsupportedIngestSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *unsupportedIngestSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUnsupportedIngestSource returns new instance of UnsupportedIngestSource error.
func NewUnsupportedIngestSource() *UnsupportedIngestSource {
	return &UnsupportedIngestSource{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), unsupportedIngestSource: unsupportedIngestSource{}}
}

// WrapWithUnsupportedIngestSource returns new instance of UnsupportedIngestSource error wrapping an existing error.
func WrapWithUnsupportedIngestSource(err error) *UnsupportedIngestSource {
	return &UnsupportedIngestSource{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, unsupportedIngestSource: unsupportedIngestSource{}}
}

// UnsupportedIngestSource is an error type.
type UnsupportedIngestSource struct {
	errorInstanceID uuid.UUID
	unsupportedIngestSource
	cause error
	stack werror.StackTrace
}

// IsUnsupportedIngestSource returns true if err is an instance of UnsupportedIngestSource.
func IsUnsupportedIngestSource(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*UnsupportedIngestSource)
	return ok
}

func (e *UnsupportedIngestSource) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:UnsupportedIngestSource (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *UnsupportedIngestSource) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *UnsupportedIngestSource) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *UnsupportedIngestSource) Message() string {
	return "INVALID_ARGUMENT IngestService:UnsupportedIngestSource"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *UnsupportedIngestSource) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *UnsupportedIngestSource) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *UnsupportedIngestSource) Name() string {
	return "IngestService:UnsupportedIngestSource"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *UnsupportedIngestSource) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *UnsupportedIngestSource) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *UnsupportedIngestSource) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnsupportedIngestSource) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *UnsupportedIngestSource) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnsupportedIngestSource) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e UnsupportedIngestSource) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.unsupportedIngestSource)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:UnsupportedIngestSource", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *UnsupportedIngestSource) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters unsupportedIngestSource
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.unsupportedIngestSource = parameters
	return nil
}

type unsupportedRequestTypeForReIngest struct {
	RequestType  string       `json:"requestType"`
	IngestJobRid IngestJobRid `json:"ingestJobRid"`
}

func (o unsupportedRequestTypeForReIngest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *unsupportedRequestTypeForReIngest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUnsupportedRequestTypeForReIngest returns new instance of UnsupportedRequestTypeForReIngest error.
func NewUnsupportedRequestTypeForReIngest(requestTypeArg string, ingestJobRidArg IngestJobRid) *UnsupportedRequestTypeForReIngest {
	return &UnsupportedRequestTypeForReIngest{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), unsupportedRequestTypeForReIngest: unsupportedRequestTypeForReIngest{RequestType: requestTypeArg, IngestJobRid: ingestJobRidArg}}
}

// WrapWithUnsupportedRequestTypeForReIngest returns new instance of UnsupportedRequestTypeForReIngest error wrapping an existing error.
func WrapWithUnsupportedRequestTypeForReIngest(err error, requestTypeArg string, ingestJobRidArg IngestJobRid) *UnsupportedRequestTypeForReIngest {
	return &UnsupportedRequestTypeForReIngest{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, unsupportedRequestTypeForReIngest: unsupportedRequestTypeForReIngest{RequestType: requestTypeArg, IngestJobRid: ingestJobRidArg}}
}

// UnsupportedRequestTypeForReIngest is an error type.
type UnsupportedRequestTypeForReIngest struct {
	errorInstanceID uuid.UUID
	unsupportedRequestTypeForReIngest
	cause error
	stack werror.StackTrace
}

// IsUnsupportedRequestTypeForReIngest returns true if err is an instance of UnsupportedRequestTypeForReIngest.
func IsUnsupportedRequestTypeForReIngest(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*UnsupportedRequestTypeForReIngest)
	return ok
}

func (e *UnsupportedRequestTypeForReIngest) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT IngestService:UnsupportedRequestTypeForReIngest (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *UnsupportedRequestTypeForReIngest) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *UnsupportedRequestTypeForReIngest) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *UnsupportedRequestTypeForReIngest) Message() string {
	return "INVALID_ARGUMENT IngestService:UnsupportedRequestTypeForReIngest"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *UnsupportedRequestTypeForReIngest) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *UnsupportedRequestTypeForReIngest) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *UnsupportedRequestTypeForReIngest) Name() string {
	return "IngestService:UnsupportedRequestTypeForReIngest"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *UnsupportedRequestTypeForReIngest) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *UnsupportedRequestTypeForReIngest) Parameters() map[string]interface{} {
	return map[string]interface{}{"requestType": e.RequestType, "ingestJobRid": e.IngestJobRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *UnsupportedRequestTypeForReIngest) safeParams() map[string]interface{} {
	return map[string]interface{}{"requestType": e.RequestType, "ingestJobRid": e.IngestJobRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnsupportedRequestTypeForReIngest) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *UnsupportedRequestTypeForReIngest) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnsupportedRequestTypeForReIngest) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e UnsupportedRequestTypeForReIngest) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.unsupportedRequestTypeForReIngest)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "IngestService:UnsupportedRequestTypeForReIngest", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *UnsupportedRequestTypeForReIngest) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters unsupportedRequestTypeForReIngest
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.unsupportedRequestTypeForReIngest = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("IngestService:BatchGranularityMismatch", reflect.TypeOf(BatchGranularityMismatch{}))
	conjureerrors.RegisterErrorType("IngestService:ContainerizedExtractorContainerFailed", reflect.TypeOf(ContainerizedExtractorContainerFailed{}))
	conjureerrors.RegisterErrorType("ContainerizedExtractor:ContainerizedExtractorNotFound", reflect.TypeOf(ContainerizedExtractorNotFound{}))
	conjureerrors.RegisterErrorType("ContainerizedExtractor:ContainerizedExtractorsNotFound", reflect.TypeOf(ContainerizedExtractorsNotFound{}))
	conjureerrors.RegisterErrorType("IngestService:DatasetFileNotFound", reflect.TypeOf(DatasetFileNotFound{}))
	conjureerrors.RegisterErrorType("IngestService:DatasetNotFound", reflect.TypeOf(DatasetNotFound{}))
	conjureerrors.RegisterErrorType("UploadService:EmptyMultipartUpload", reflect.TypeOf(EmptyMultipartUpload{}))
	conjureerrors.RegisterErrorType("IngestService:FailedToDownloadFile", reflect.TypeOf(FailedToDownloadFile{}))
	conjureerrors.RegisterErrorType("IngestService:FailedToDownloadFileUserError", reflect.TypeOf(FailedToDownloadFileUserError{}))
	conjureerrors.RegisterErrorType("IngestService:FrameCountTimestampsMismatch", reflect.TypeOf(FrameCountTimestampsMismatch{}))
	conjureerrors.RegisterErrorType("IngestService:IncompatibleConnectionTypeAndLogQuery", reflect.TypeOf(IncompatibleConnectionTypeAndLogQuery{}))
	conjureerrors.RegisterErrorType("IngestService:IncompatibleFileForDataset", reflect.TypeOf(IncompatibleFileForDataset{}))
	conjureerrors.RegisterErrorType("IngestService:IncompatibleInputs", reflect.TypeOf(IncompatibleInputs{}))
	conjureerrors.RegisterErrorType("UploadService:IncorrectSizeBytes", reflect.TypeOf(IncorrectSizeBytes{}))
	conjureerrors.RegisterErrorType("IngestService:IngestJobNotCompatibleForRerun", reflect.TypeOf(IngestJobNotCompatibleForRerun{}))
	conjureerrors.RegisterErrorType("IngestService:IngestJobNotFound", reflect.TypeOf(IngestJobNotFound{}))
	conjureerrors.RegisterErrorType("IngestService:InvalidBucket", reflect.TypeOf(InvalidBucket{}))
	conjureerrors.RegisterErrorType("ContainerizedExtractor:InvalidContainerImage", reflect.TypeOf(InvalidContainerImage{}))
	conjureerrors.RegisterErrorType("IngestService:InvalidCustomTimestampFormat", reflect.TypeOf(InvalidCustomTimestampFormat{}))
	conjureerrors.RegisterErrorType("ContainerizedExtractor:InvalidDefaultTag", reflect.TypeOf(InvalidDefaultTag{}))
	conjureerrors.RegisterErrorType("ContainerizedExtractor:InvalidOutputFileFormat", reflect.TypeOf(InvalidOutputFileFormat{}))
	conjureerrors.RegisterErrorType("IngestService:InvalidS3Path", reflect.TypeOf(InvalidS3Path{}))
	conjureerrors.RegisterErrorType("IngestService:InvalidUrl", reflect.TypeOf(InvalidUrl{}))
	conjureerrors.RegisterErrorType("IngestService:MissingMetadataForReingest", reflect.TypeOf(MissingMetadataForReingest{}))
	conjureerrors.RegisterErrorType("UploadService:NullKey", reflect.TypeOf(NullKey{}))
	conjureerrors.RegisterErrorType("IngestService:ParallelReingestIntoDatasetV1", reflect.TypeOf(ParallelReingestIntoDatasetV1{}))
	conjureerrors.RegisterErrorType("IngestService:RecursiveReingest", reflect.TypeOf(RecursiveReingest{}))
	conjureerrors.RegisterErrorType("IngestService:ReingestTooManyFiles", reflect.TypeOf(ReingestTooManyFiles{}))
	conjureerrors.RegisterErrorType("IngestService:RunBoundsInverted", reflect.TypeOf(RunBoundsInverted{}))
	conjureerrors.RegisterErrorType("IngestService:S3PathNotFound", reflect.TypeOf(S3PathNotFound{}))
	conjureerrors.RegisterErrorType("IngestService:UnsupportedIngestSource", reflect.TypeOf(UnsupportedIngestSource{}))
	conjureerrors.RegisterErrorType("IngestService:UnsupportedRequestTypeForReIngest", reflect.TypeOf(UnsupportedRequestTypeForReIngest{}))
}
