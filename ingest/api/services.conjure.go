// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"
	"net/url"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

// The Containerized Extractor service provides functionality for creating, updating, and archiving containerized extractors.
type ContainerizedExtractorServiceClient interface {
	// Registers a containerized extractor for a given set of containerized files.
	RegisterContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, requestArg RegisterContainerizedExtractorRequest) (RegisterContainerizedExtractorResponse, error)
	// Get a containerized extractor by its RID.
	GetContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) (ContainerizedExtractor, error)
	// Search for containerized extractors based on query parameters.
	SearchContainerizedExtractors(ctx context.Context, authHeader bearertoken.Token, requestArg SearchContainerizedExtractorsRequest) ([]ContainerizedExtractor, error)
	// Update a containerized extractor. Only the fields that are set in the request will be updated.
	UpdateContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier, requestArg UpdateContainerizedExtractorRequest) (ContainerizedExtractor, error)
	// Archive a containerized extractor.
	ArchiveContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) error
	// Unarchive a containerized extractor.
	UnarchiveContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) error
}

type containerizedExtractorServiceClient struct {
	client httpclient.Client
}

func NewContainerizedExtractorServiceClient(client httpclient.Client) ContainerizedExtractorServiceClient {
	return &containerizedExtractorServiceClient{client: client}
}

func (c *containerizedExtractorServiceClient) RegisterContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, requestArg RegisterContainerizedExtractorRequest) (RegisterContainerizedExtractorResponse, error) {
	var defaultReturnVal RegisterContainerizedExtractorResponse
	var returnVal *RegisterContainerizedExtractorResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("RegisterContainerizedExtractor"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "registerContainerizedExtractor failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "registerContainerizedExtractor response cannot be nil")
	}
	return *returnVal, nil
}

func (c *containerizedExtractorServiceClient) GetContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) (ContainerizedExtractor, error) {
	var defaultReturnVal ContainerizedExtractor
	var returnVal *ContainerizedExtractor
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetContainerizedExtractor"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container/%s", url.PathEscape(fmt.Sprint(extractorRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getContainerizedExtractor failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getContainerizedExtractor response cannot be nil")
	}
	return *returnVal, nil
}

func (c *containerizedExtractorServiceClient) SearchContainerizedExtractors(ctx context.Context, authHeader bearertoken.Token, requestArg SearchContainerizedExtractorsRequest) ([]ContainerizedExtractor, error) {
	var returnVal []ContainerizedExtractor
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SearchContainerizedExtractors"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container/search"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "searchContainerizedExtractors failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "searchContainerizedExtractors response cannot be nil")
	}
	return returnVal, nil
}

func (c *containerizedExtractorServiceClient) UpdateContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier, requestArg UpdateContainerizedExtractorRequest) (ContainerizedExtractor, error) {
	var defaultReturnVal ContainerizedExtractor
	var returnVal *ContainerizedExtractor
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateContainerizedExtractor"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container/%s", url.PathEscape(fmt.Sprint(extractorRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateContainerizedExtractor failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateContainerizedExtractor response cannot be nil")
	}
	return *returnVal, nil
}

func (c *containerizedExtractorServiceClient) ArchiveContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ArchiveContainerizedExtractor"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container/%s/archive", url.PathEscape(fmt.Sprint(extractorRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "archiveContainerizedExtractor failed")
	}
	return nil
}

func (c *containerizedExtractorServiceClient) UnarchiveContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UnarchiveContainerizedExtractor"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container/%s/unarchive", url.PathEscape(fmt.Sprint(extractorRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "unarchiveContainerizedExtractor failed")
	}
	return nil
}

// The Containerized Extractor service provides functionality for creating, updating, and archiving containerized extractors.
type ContainerizedExtractorServiceClientWithAuth interface {
	// Registers a containerized extractor for a given set of containerized files.
	RegisterContainerizedExtractor(ctx context.Context, requestArg RegisterContainerizedExtractorRequest) (RegisterContainerizedExtractorResponse, error)
	// Get a containerized extractor by its RID.
	GetContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) (ContainerizedExtractor, error)
	// Search for containerized extractors based on query parameters.
	SearchContainerizedExtractors(ctx context.Context, requestArg SearchContainerizedExtractorsRequest) ([]ContainerizedExtractor, error)
	// Update a containerized extractor. Only the fields that are set in the request will be updated.
	UpdateContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier, requestArg UpdateContainerizedExtractorRequest) (ContainerizedExtractor, error)
	// Archive a containerized extractor.
	ArchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error
	// Unarchive a containerized extractor.
	UnarchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error
}

func NewContainerizedExtractorServiceClientWithAuth(client ContainerizedExtractorServiceClient, authHeader bearertoken.Token) ContainerizedExtractorServiceClientWithAuth {
	return &containerizedExtractorServiceClientWithAuth{client: client, authHeader: authHeader}
}

type containerizedExtractorServiceClientWithAuth struct {
	client     ContainerizedExtractorServiceClient
	authHeader bearertoken.Token
}

func (c *containerizedExtractorServiceClientWithAuth) RegisterContainerizedExtractor(ctx context.Context, requestArg RegisterContainerizedExtractorRequest) (RegisterContainerizedExtractorResponse, error) {
	return c.client.RegisterContainerizedExtractor(ctx, c.authHeader, requestArg)
}

func (c *containerizedExtractorServiceClientWithAuth) GetContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) (ContainerizedExtractor, error) {
	return c.client.GetContainerizedExtractor(ctx, c.authHeader, extractorRidArg)
}

func (c *containerizedExtractorServiceClientWithAuth) SearchContainerizedExtractors(ctx context.Context, requestArg SearchContainerizedExtractorsRequest) ([]ContainerizedExtractor, error) {
	return c.client.SearchContainerizedExtractors(ctx, c.authHeader, requestArg)
}

func (c *containerizedExtractorServiceClientWithAuth) UpdateContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier, requestArg UpdateContainerizedExtractorRequest) (ContainerizedExtractor, error) {
	return c.client.UpdateContainerizedExtractor(ctx, c.authHeader, extractorRidArg, requestArg)
}

func (c *containerizedExtractorServiceClientWithAuth) ArchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error {
	return c.client.ArchiveContainerizedExtractor(ctx, c.authHeader, extractorRidArg)
}

func (c *containerizedExtractorServiceClientWithAuth) UnarchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error {
	return c.client.UnarchiveContainerizedExtractor(ctx, c.authHeader, extractorRidArg)
}

func NewContainerizedExtractorServiceClientWithTokenProvider(client ContainerizedExtractorServiceClient, tokenProvider httpclient.TokenProvider) ContainerizedExtractorServiceClientWithAuth {
	return &containerizedExtractorServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type containerizedExtractorServiceClientWithTokenProvider struct {
	client        ContainerizedExtractorServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *containerizedExtractorServiceClientWithTokenProvider) RegisterContainerizedExtractor(ctx context.Context, requestArg RegisterContainerizedExtractorRequest) (RegisterContainerizedExtractorResponse, error) {
	var defaultReturnVal RegisterContainerizedExtractorResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.RegisterContainerizedExtractor(ctx, bearertoken.Token(token), requestArg)
}

func (c *containerizedExtractorServiceClientWithTokenProvider) GetContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) (ContainerizedExtractor, error) {
	var defaultReturnVal ContainerizedExtractor
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetContainerizedExtractor(ctx, bearertoken.Token(token), extractorRidArg)
}

func (c *containerizedExtractorServiceClientWithTokenProvider) SearchContainerizedExtractors(ctx context.Context, requestArg SearchContainerizedExtractorsRequest) ([]ContainerizedExtractor, error) {
	var defaultReturnVal []ContainerizedExtractor
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.SearchContainerizedExtractors(ctx, bearertoken.Token(token), requestArg)
}

func (c *containerizedExtractorServiceClientWithTokenProvider) UpdateContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier, requestArg UpdateContainerizedExtractorRequest) (ContainerizedExtractor, error) {
	var defaultReturnVal ContainerizedExtractor
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateContainerizedExtractor(ctx, bearertoken.Token(token), extractorRidArg, requestArg)
}

func (c *containerizedExtractorServiceClientWithTokenProvider) ArchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.ArchiveContainerizedExtractor(ctx, bearertoken.Token(token), extractorRidArg)
}

func (c *containerizedExtractorServiceClientWithTokenProvider) UnarchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.UnarchiveContainerizedExtractor(ctx, bearertoken.Token(token), extractorRidArg)
}

// The Ingest Service handles the data ingestion into Nominal/Clickhouse.
type IngestServiceClient interface {
	/*
	   Triggers an ingest job, allowing either creating a new dataset or uploading to an
	   existing one. This endpoint is meant to supersede all other ingestion endpoints as their functionality
	   gets migrated to this one.
	*/
	Ingest(ctx context.Context, authHeader bearertoken.Token, triggerIngestArg IngestRequest) (IngestResponse, error)
	/*
	   Triggers an ingest job using an existing ingest job RID.
	   Returns the same response format as the /ingest endpoint.
	*/
	RerunIngest(ctx context.Context, authHeader bearertoken.Token, requestArg RerunIngestRequest) (IngestResponse, error)
	// Deprecated: Replaced by ingest.
	DeprecatedTriggerIngest(ctx context.Context, authHeader bearertoken.Token, triggerIngestArg DeprecatedTriggerIngest) (TriggeredIngest, error)
	/*
	   Triggers an ingest job for the given data source.
	   The ingest job will be processed asynchronously.

	   Deprecated: Replaced by ingest.
	*/
	TriggerIngest(ctx context.Context, authHeader bearertoken.Token, triggerIngestArg TriggerIngest) (TriggeredIngest, error)
	/*
	   Triggers an ingest job of a new file, allowing either creating a new dataset or uploading to an
	   existing one.

	   Deprecated: Replaced by ingest.
	*/
	TriggerFileIngest(ctx context.Context, authHeader bearertoken.Token, triggerIngestArg TriggerFileIngest) (TriggeredIngest, error)
	// Creates a run and ingests data sources to be added to the run.
	IngestRun(ctx context.Context, authHeader bearertoken.Token, requestArg IngestRunRequest) (IngestRunResponse, error)
	/*
	   Ingests video data from a S3 Nominal upload bucket.

	   Deprecated: Replaced by ingest.
	*/
	IngestVideo(ctx context.Context, authHeader bearertoken.Token, ingestVideoArg IngestVideoRequest) (IngestVideoResponse, error)
	/*
	   Ingests data from mcap files in the S3 Nominal upload bucket.

	   Deprecated: Replaced by ingest.
	*/
	IngestMcap(ctx context.Context, authHeader bearertoken.Token, ingestVideoArg IngestMcapRequest) (IngestMcapResponse, error)
	/*
	   Re-ingests data from provided source datasets into either an existing target dataset, or a new one.
	   Only supported for CSV and Parquet dataset files.
	   Will only reingest dataset files and will drop streaming data from datasets.
	*/
	ReingestFromDatasets(ctx context.Context, authHeader bearertoken.Token, requestArg ReingestDatasetsRequest) (ReingestDatasetsResponse, error)
	/*
	   This is a best effort deletion of the file's data based on the ingestedAt timestamp. This is an unreversible
	   action. Only v2 dataset file deletion is supported.
	   !!!WARNING!!!
	   It's possible that the file has overwritten points, in which case, those older points will not be recovered.
	   Only use this endpoint if this is acceptable, the data across files are disjoint, or you're willing to
	   re-ingest files to manually recover older points.
	*/
	DeleteFile(ctx context.Context, authHeader bearertoken.Token, datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) error
}

type ingestServiceClient struct {
	client httpclient.Client
}

func NewIngestServiceClient(client httpclient.Client) IngestServiceClient {
	return &ingestServiceClient{client: client}
}

func (c *ingestServiceClient) Ingest(ctx context.Context, authHeader bearertoken.Token, triggerIngestArg IngestRequest) (IngestResponse, error) {
	var defaultReturnVal IngestResponse
	var returnVal *IngestResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Ingest"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/ingest"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(triggerIngestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "ingest failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "ingest response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) RerunIngest(ctx context.Context, authHeader bearertoken.Token, requestArg RerunIngestRequest) (IngestResponse, error) {
	var defaultReturnVal IngestResponse
	var returnVal *IngestResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("RerunIngest"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/re-ingest"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "rerunIngest failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "rerunIngest response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) DeprecatedTriggerIngest(ctx context.Context, authHeader bearertoken.Token, triggerIngestArg DeprecatedTriggerIngest) (TriggeredIngest, error) {
	var defaultReturnVal TriggeredIngest
	var returnVal *TriggeredIngest
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("DeprecatedTriggerIngest"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/trigger-ingest"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(triggerIngestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "deprecatedTriggerIngest failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "deprecatedTriggerIngest response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) TriggerIngest(ctx context.Context, authHeader bearertoken.Token, triggerIngestArg TriggerIngest) (TriggeredIngest, error) {
	var defaultReturnVal TriggeredIngest
	var returnVal *TriggeredIngest
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("TriggerIngest"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/trigger-ingest-v2"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(triggerIngestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "triggerIngest failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "triggerIngest response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) TriggerFileIngest(ctx context.Context, authHeader bearertoken.Token, triggerIngestArg TriggerFileIngest) (TriggeredIngest, error) {
	var defaultReturnVal TriggeredIngest
	var returnVal *TriggeredIngest
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("TriggerFileIngest"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/trigger-file-ingest"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(triggerIngestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "triggerFileIngest failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "triggerFileIngest response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) IngestRun(ctx context.Context, authHeader bearertoken.Token, requestArg IngestRunRequest) (IngestRunResponse, error) {
	var defaultReturnVal IngestRunResponse
	var returnVal *IngestRunResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("IngestRun"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/ingest-run"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "ingestRun failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "ingestRun response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) IngestVideo(ctx context.Context, authHeader bearertoken.Token, ingestVideoArg IngestVideoRequest) (IngestVideoResponse, error) {
	var defaultReturnVal IngestVideoResponse
	var returnVal *IngestVideoResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("IngestVideo"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/ingest-video"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(ingestVideoArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "ingestVideo failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "ingestVideo response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) IngestMcap(ctx context.Context, authHeader bearertoken.Token, ingestVideoArg IngestMcapRequest) (IngestMcapResponse, error) {
	var defaultReturnVal IngestMcapResponse
	var returnVal *IngestMcapResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("IngestMcap"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/ingest-mcap"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(ingestVideoArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "ingestMcap failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "ingestMcap response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) ReingestFromDatasets(ctx context.Context, authHeader bearertoken.Token, requestArg ReingestDatasetsRequest) (ReingestDatasetsResponse, error) {
	var defaultReturnVal ReingestDatasetsResponse
	var returnVal *ReingestDatasetsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ReingestFromDatasets"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/reingest-dataset-files"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "reingestFromDatasets failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "reingestFromDatasets response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) DeleteFile(ctx context.Context, authHeader bearertoken.Token, datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("DeleteFile"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("DELETE"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/delete-file/%s/file/%s", url.PathEscape(fmt.Sprint(datasetRidArg)), url.PathEscape(fmt.Sprint(fileIdArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "deleteFile failed")
	}
	return nil
}

// The Ingest Service handles the data ingestion into Nominal/Clickhouse.
type IngestServiceClientWithAuth interface {
	/*
	   Triggers an ingest job, allowing either creating a new dataset or uploading to an
	   existing one. This endpoint is meant to supersede all other ingestion endpoints as their functionality
	   gets migrated to this one.
	*/
	Ingest(ctx context.Context, triggerIngestArg IngestRequest) (IngestResponse, error)
	/*
	   Triggers an ingest job using an existing ingest job RID.
	   Returns the same response format as the /ingest endpoint.
	*/
	RerunIngest(ctx context.Context, requestArg RerunIngestRequest) (IngestResponse, error)
	// Deprecated: Replaced by ingest.
	DeprecatedTriggerIngest(ctx context.Context, triggerIngestArg DeprecatedTriggerIngest) (TriggeredIngest, error)
	/*
	   Triggers an ingest job for the given data source.
	   The ingest job will be processed asynchronously.

	   Deprecated: Replaced by ingest.
	*/
	TriggerIngest(ctx context.Context, triggerIngestArg TriggerIngest) (TriggeredIngest, error)
	/*
	   Triggers an ingest job of a new file, allowing either creating a new dataset or uploading to an
	   existing one.

	   Deprecated: Replaced by ingest.
	*/
	TriggerFileIngest(ctx context.Context, triggerIngestArg TriggerFileIngest) (TriggeredIngest, error)
	// Creates a run and ingests data sources to be added to the run.
	IngestRun(ctx context.Context, requestArg IngestRunRequest) (IngestRunResponse, error)
	/*
	   Ingests video data from a S3 Nominal upload bucket.

	   Deprecated: Replaced by ingest.
	*/
	IngestVideo(ctx context.Context, ingestVideoArg IngestVideoRequest) (IngestVideoResponse, error)
	/*
	   Ingests data from mcap files in the S3 Nominal upload bucket.

	   Deprecated: Replaced by ingest.
	*/
	IngestMcap(ctx context.Context, ingestVideoArg IngestMcapRequest) (IngestMcapResponse, error)
	/*
	   Re-ingests data from provided source datasets into either an existing target dataset, or a new one.
	   Only supported for CSV and Parquet dataset files.
	   Will only reingest dataset files and will drop streaming data from datasets.
	*/
	ReingestFromDatasets(ctx context.Context, requestArg ReingestDatasetsRequest) (ReingestDatasetsResponse, error)
	/*
	   This is a best effort deletion of the file's data based on the ingestedAt timestamp. This is an unreversible
	   action. Only v2 dataset file deletion is supported.
	   !!!WARNING!!!
	   It's possible that the file has overwritten points, in which case, those older points will not be recovered.
	   Only use this endpoint if this is acceptable, the data across files are disjoint, or you're willing to
	   re-ingest files to manually recover older points.
	*/
	DeleteFile(ctx context.Context, datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) error
}

func NewIngestServiceClientWithAuth(client IngestServiceClient, authHeader bearertoken.Token) IngestServiceClientWithAuth {
	return &ingestServiceClientWithAuth{client: client, authHeader: authHeader}
}

type ingestServiceClientWithAuth struct {
	client     IngestServiceClient
	authHeader bearertoken.Token
}

func (c *ingestServiceClientWithAuth) Ingest(ctx context.Context, triggerIngestArg IngestRequest) (IngestResponse, error) {
	return c.client.Ingest(ctx, c.authHeader, triggerIngestArg)
}

func (c *ingestServiceClientWithAuth) RerunIngest(ctx context.Context, requestArg RerunIngestRequest) (IngestResponse, error) {
	return c.client.RerunIngest(ctx, c.authHeader, requestArg)
}

func (c *ingestServiceClientWithAuth) DeprecatedTriggerIngest(ctx context.Context, triggerIngestArg DeprecatedTriggerIngest) (TriggeredIngest, error) {
	return c.client.DeprecatedTriggerIngest(ctx, c.authHeader, triggerIngestArg)
}

func (c *ingestServiceClientWithAuth) TriggerIngest(ctx context.Context, triggerIngestArg TriggerIngest) (TriggeredIngest, error) {
	return c.client.TriggerIngest(ctx, c.authHeader, triggerIngestArg)
}

func (c *ingestServiceClientWithAuth) TriggerFileIngest(ctx context.Context, triggerIngestArg TriggerFileIngest) (TriggeredIngest, error) {
	return c.client.TriggerFileIngest(ctx, c.authHeader, triggerIngestArg)
}

func (c *ingestServiceClientWithAuth) IngestRun(ctx context.Context, requestArg IngestRunRequest) (IngestRunResponse, error) {
	return c.client.IngestRun(ctx, c.authHeader, requestArg)
}

func (c *ingestServiceClientWithAuth) IngestVideo(ctx context.Context, ingestVideoArg IngestVideoRequest) (IngestVideoResponse, error) {
	return c.client.IngestVideo(ctx, c.authHeader, ingestVideoArg)
}

func (c *ingestServiceClientWithAuth) IngestMcap(ctx context.Context, ingestVideoArg IngestMcapRequest) (IngestMcapResponse, error) {
	return c.client.IngestMcap(ctx, c.authHeader, ingestVideoArg)
}

func (c *ingestServiceClientWithAuth) ReingestFromDatasets(ctx context.Context, requestArg ReingestDatasetsRequest) (ReingestDatasetsResponse, error) {
	return c.client.ReingestFromDatasets(ctx, c.authHeader, requestArg)
}

func (c *ingestServiceClientWithAuth) DeleteFile(ctx context.Context, datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) error {
	return c.client.DeleteFile(ctx, c.authHeader, datasetRidArg, fileIdArg)
}

func NewIngestServiceClientWithTokenProvider(client IngestServiceClient, tokenProvider httpclient.TokenProvider) IngestServiceClientWithAuth {
	return &ingestServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type ingestServiceClientWithTokenProvider struct {
	client        IngestServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *ingestServiceClientWithTokenProvider) Ingest(ctx context.Context, triggerIngestArg IngestRequest) (IngestResponse, error) {
	var defaultReturnVal IngestResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Ingest(ctx, bearertoken.Token(token), triggerIngestArg)
}

func (c *ingestServiceClientWithTokenProvider) RerunIngest(ctx context.Context, requestArg RerunIngestRequest) (IngestResponse, error) {
	var defaultReturnVal IngestResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.RerunIngest(ctx, bearertoken.Token(token), requestArg)
}

func (c *ingestServiceClientWithTokenProvider) DeprecatedTriggerIngest(ctx context.Context, triggerIngestArg DeprecatedTriggerIngest) (TriggeredIngest, error) {
	var defaultReturnVal TriggeredIngest
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.DeprecatedTriggerIngest(ctx, bearertoken.Token(token), triggerIngestArg)
}

func (c *ingestServiceClientWithTokenProvider) TriggerIngest(ctx context.Context, triggerIngestArg TriggerIngest) (TriggeredIngest, error) {
	var defaultReturnVal TriggeredIngest
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.TriggerIngest(ctx, bearertoken.Token(token), triggerIngestArg)
}

func (c *ingestServiceClientWithTokenProvider) TriggerFileIngest(ctx context.Context, triggerIngestArg TriggerFileIngest) (TriggeredIngest, error) {
	var defaultReturnVal TriggeredIngest
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.TriggerFileIngest(ctx, bearertoken.Token(token), triggerIngestArg)
}

func (c *ingestServiceClientWithTokenProvider) IngestRun(ctx context.Context, requestArg IngestRunRequest) (IngestRunResponse, error) {
	var defaultReturnVal IngestRunResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.IngestRun(ctx, bearertoken.Token(token), requestArg)
}

func (c *ingestServiceClientWithTokenProvider) IngestVideo(ctx context.Context, ingestVideoArg IngestVideoRequest) (IngestVideoResponse, error) {
	var defaultReturnVal IngestVideoResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.IngestVideo(ctx, bearertoken.Token(token), ingestVideoArg)
}

func (c *ingestServiceClientWithTokenProvider) IngestMcap(ctx context.Context, ingestVideoArg IngestMcapRequest) (IngestMcapResponse, error) {
	var defaultReturnVal IngestMcapResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.IngestMcap(ctx, bearertoken.Token(token), ingestVideoArg)
}

func (c *ingestServiceClientWithTokenProvider) ReingestFromDatasets(ctx context.Context, requestArg ReingestDatasetsRequest) (ReingestDatasetsResponse, error) {
	var defaultReturnVal ReingestDatasetsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ReingestFromDatasets(ctx, bearertoken.Token(token), requestArg)
}

func (c *ingestServiceClientWithTokenProvider) DeleteFile(ctx context.Context, datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.DeleteFile(ctx, bearertoken.Token(token), datasetRidArg, fileIdArg)
}
