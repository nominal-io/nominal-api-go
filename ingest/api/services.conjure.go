// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"
	"net/url"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	"github.com/palantir/pkg/rid"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

// The Containerized Extractor service provides functionality for creating, updating, and archiving containerized extractors.
type ContainerizedExtractorServiceClient interface {
	// Registers a containerized extractor for a given set of containerized files.
	RegisterContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, requestArg RegisterContainerizedExtractorRequest) (RegisterContainerizedExtractorResponse, error)
	// Get a containerized extractor by its RID.
	GetContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) (ContainerizedExtractor, error)
	// Search for containerized extractors based on query parameters.
	SearchContainerizedExtractors(ctx context.Context, authHeader bearertoken.Token, requestArg SearchContainerizedExtractorsRequest) ([]ContainerizedExtractor, error)
	// Update a containerized extractor. Only the fields that are set in the request will be updated.
	UpdateContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier, requestArg UpdateContainerizedExtractorRequest) (ContainerizedExtractor, error)
	// Archive a containerized extractor.
	ArchiveContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) error
	// Unarchive a containerized extractor.
	UnarchiveContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) error
}

type containerizedExtractorServiceClient struct {
	client httpclient.Client
}

func NewContainerizedExtractorServiceClient(client httpclient.Client) ContainerizedExtractorServiceClient {
	return &containerizedExtractorServiceClient{client: client}
}

func (c *containerizedExtractorServiceClient) RegisterContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, requestArg RegisterContainerizedExtractorRequest) (RegisterContainerizedExtractorResponse, error) {
	var defaultReturnVal RegisterContainerizedExtractorResponse
	var returnVal *RegisterContainerizedExtractorResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("RegisterContainerizedExtractor"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "registerContainerizedExtractor failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "registerContainerizedExtractor response cannot be nil")
	}
	return *returnVal, nil
}

func (c *containerizedExtractorServiceClient) GetContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) (ContainerizedExtractor, error) {
	var defaultReturnVal ContainerizedExtractor
	var returnVal *ContainerizedExtractor
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetContainerizedExtractor"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container/%s", url.PathEscape(fmt.Sprint(extractorRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getContainerizedExtractor failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getContainerizedExtractor response cannot be nil")
	}
	return *returnVal, nil
}

func (c *containerizedExtractorServiceClient) SearchContainerizedExtractors(ctx context.Context, authHeader bearertoken.Token, requestArg SearchContainerizedExtractorsRequest) ([]ContainerizedExtractor, error) {
	var returnVal []ContainerizedExtractor
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SearchContainerizedExtractors"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container/search"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "searchContainerizedExtractors failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "searchContainerizedExtractors response cannot be nil")
	}
	return returnVal, nil
}

func (c *containerizedExtractorServiceClient) UpdateContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier, requestArg UpdateContainerizedExtractorRequest) (ContainerizedExtractor, error) {
	var defaultReturnVal ContainerizedExtractor
	var returnVal *ContainerizedExtractor
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateContainerizedExtractor"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container/%s", url.PathEscape(fmt.Sprint(extractorRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateContainerizedExtractor failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateContainerizedExtractor response cannot be nil")
	}
	return *returnVal, nil
}

func (c *containerizedExtractorServiceClient) ArchiveContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ArchiveContainerizedExtractor"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container/%s/archive", url.PathEscape(fmt.Sprint(extractorRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "archiveContainerizedExtractor failed")
	}
	return nil
}

func (c *containerizedExtractorServiceClient) UnarchiveContainerizedExtractor(ctx context.Context, authHeader bearertoken.Token, extractorRidArg rid.ResourceIdentifier) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UnarchiveContainerizedExtractor"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/extractors/v1/container/%s/unarchive", url.PathEscape(fmt.Sprint(extractorRidArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "unarchiveContainerizedExtractor failed")
	}
	return nil
}

// The Containerized Extractor service provides functionality for creating, updating, and archiving containerized extractors.
type ContainerizedExtractorServiceClientWithAuth interface {
	// Registers a containerized extractor for a given set of containerized files.
	RegisterContainerizedExtractor(ctx context.Context, requestArg RegisterContainerizedExtractorRequest) (RegisterContainerizedExtractorResponse, error)
	// Get a containerized extractor by its RID.
	GetContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) (ContainerizedExtractor, error)
	// Search for containerized extractors based on query parameters.
	SearchContainerizedExtractors(ctx context.Context, requestArg SearchContainerizedExtractorsRequest) ([]ContainerizedExtractor, error)
	// Update a containerized extractor. Only the fields that are set in the request will be updated.
	UpdateContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier, requestArg UpdateContainerizedExtractorRequest) (ContainerizedExtractor, error)
	// Archive a containerized extractor.
	ArchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error
	// Unarchive a containerized extractor.
	UnarchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error
}

func NewContainerizedExtractorServiceClientWithAuth(client ContainerizedExtractorServiceClient, authHeader bearertoken.Token) ContainerizedExtractorServiceClientWithAuth {
	return &containerizedExtractorServiceClientWithAuth{client: client, authHeader: authHeader}
}

type containerizedExtractorServiceClientWithAuth struct {
	client     ContainerizedExtractorServiceClient
	authHeader bearertoken.Token
}

func (c *containerizedExtractorServiceClientWithAuth) RegisterContainerizedExtractor(ctx context.Context, requestArg RegisterContainerizedExtractorRequest) (RegisterContainerizedExtractorResponse, error) {
	return c.client.RegisterContainerizedExtractor(ctx, c.authHeader, requestArg)
}

func (c *containerizedExtractorServiceClientWithAuth) GetContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) (ContainerizedExtractor, error) {
	return c.client.GetContainerizedExtractor(ctx, c.authHeader, extractorRidArg)
}

func (c *containerizedExtractorServiceClientWithAuth) SearchContainerizedExtractors(ctx context.Context, requestArg SearchContainerizedExtractorsRequest) ([]ContainerizedExtractor, error) {
	return c.client.SearchContainerizedExtractors(ctx, c.authHeader, requestArg)
}

func (c *containerizedExtractorServiceClientWithAuth) UpdateContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier, requestArg UpdateContainerizedExtractorRequest) (ContainerizedExtractor, error) {
	return c.client.UpdateContainerizedExtractor(ctx, c.authHeader, extractorRidArg, requestArg)
}

func (c *containerizedExtractorServiceClientWithAuth) ArchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error {
	return c.client.ArchiveContainerizedExtractor(ctx, c.authHeader, extractorRidArg)
}

func (c *containerizedExtractorServiceClientWithAuth) UnarchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error {
	return c.client.UnarchiveContainerizedExtractor(ctx, c.authHeader, extractorRidArg)
}

func NewContainerizedExtractorServiceClientWithTokenProvider(client ContainerizedExtractorServiceClient, tokenProvider httpclient.TokenProvider) ContainerizedExtractorServiceClientWithAuth {
	return &containerizedExtractorServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type containerizedExtractorServiceClientWithTokenProvider struct {
	client        ContainerizedExtractorServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *containerizedExtractorServiceClientWithTokenProvider) RegisterContainerizedExtractor(ctx context.Context, requestArg RegisterContainerizedExtractorRequest) (RegisterContainerizedExtractorResponse, error) {
	var defaultReturnVal RegisterContainerizedExtractorResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.RegisterContainerizedExtractor(ctx, bearertoken.Token(token), requestArg)
}

func (c *containerizedExtractorServiceClientWithTokenProvider) GetContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) (ContainerizedExtractor, error) {
	var defaultReturnVal ContainerizedExtractor
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetContainerizedExtractor(ctx, bearertoken.Token(token), extractorRidArg)
}

func (c *containerizedExtractorServiceClientWithTokenProvider) SearchContainerizedExtractors(ctx context.Context, requestArg SearchContainerizedExtractorsRequest) ([]ContainerizedExtractor, error) {
	var defaultReturnVal []ContainerizedExtractor
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.SearchContainerizedExtractors(ctx, bearertoken.Token(token), requestArg)
}

func (c *containerizedExtractorServiceClientWithTokenProvider) UpdateContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier, requestArg UpdateContainerizedExtractorRequest) (ContainerizedExtractor, error) {
	var defaultReturnVal ContainerizedExtractor
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateContainerizedExtractor(ctx, bearertoken.Token(token), extractorRidArg, requestArg)
}

func (c *containerizedExtractorServiceClientWithTokenProvider) ArchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.ArchiveContainerizedExtractor(ctx, bearertoken.Token(token), extractorRidArg)
}

func (c *containerizedExtractorServiceClientWithTokenProvider) UnarchiveContainerizedExtractor(ctx context.Context, extractorRidArg rid.ResourceIdentifier) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.UnarchiveContainerizedExtractor(ctx, bearertoken.Token(token), extractorRidArg)
}

// Public API for querying ingest jobs.
type IngestJobServiceClient interface {
	// Returns a single ingest job by RID. Does not include the full ingest request details.
	GetIngestJob(ctx context.Context, authHeader bearertoken.Token, ingestJobRidArg IngestJobRid) (IngestJob, error)
}

type ingestJobServiceClient struct {
	client httpclient.Client
}

func NewIngestJobServiceClient(client httpclient.Client) IngestJobServiceClient {
	return &ingestJobServiceClient{client: client}
}

func (c *ingestJobServiceClient) GetIngestJob(ctx context.Context, authHeader bearertoken.Token, ingestJobRidArg IngestJobRid) (IngestJob, error) {
	var defaultReturnVal IngestJob
	var returnVal *IngestJob
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetIngestJob"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/ingest-job/%s", url.PathEscape(fmt.Sprint(ingestJobRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getIngestJob failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getIngestJob response cannot be nil")
	}
	return *returnVal, nil
}

// Public API for querying ingest jobs.
type IngestJobServiceClientWithAuth interface {
	// Returns a single ingest job by RID. Does not include the full ingest request details.
	GetIngestJob(ctx context.Context, ingestJobRidArg IngestJobRid) (IngestJob, error)
}

func NewIngestJobServiceClientWithAuth(client IngestJobServiceClient, authHeader bearertoken.Token) IngestJobServiceClientWithAuth {
	return &ingestJobServiceClientWithAuth{client: client, authHeader: authHeader}
}

type ingestJobServiceClientWithAuth struct {
	client     IngestJobServiceClient
	authHeader bearertoken.Token
}

func (c *ingestJobServiceClientWithAuth) GetIngestJob(ctx context.Context, ingestJobRidArg IngestJobRid) (IngestJob, error) {
	return c.client.GetIngestJob(ctx, c.authHeader, ingestJobRidArg)
}

func NewIngestJobServiceClientWithTokenProvider(client IngestJobServiceClient, tokenProvider httpclient.TokenProvider) IngestJobServiceClientWithAuth {
	return &ingestJobServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type ingestJobServiceClientWithTokenProvider struct {
	client        IngestJobServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *ingestJobServiceClientWithTokenProvider) GetIngestJob(ctx context.Context, ingestJobRidArg IngestJobRid) (IngestJob, error) {
	var defaultReturnVal IngestJob
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetIngestJob(ctx, bearertoken.Token(token), ingestJobRidArg)
}

// The Ingest Service handles the data ingestion into Nominal/Clickhouse.
type IngestServiceClient interface {
	/*
	   Triggers an ingest job, allowing either creating a new dataset or uploading to an
	   existing one. This endpoint is meant to supersede all other ingestion endpoints as their functionality
	   gets migrated to this one.
	*/
	Ingest(ctx context.Context, authHeader bearertoken.Token, triggerIngestArg IngestRequest) (IngestResponse, error)
	/*
	   Triggers an ingest job using an existing ingest job RID.
	   Returns the same response format as the /ingest endpoint.
	*/
	RerunIngest(ctx context.Context, authHeader bearertoken.Token, requestArg RerunIngestRequest) (IngestResponse, error)
	// Creates a run and ingests data sources to be added to the run.
	IngestRun(ctx context.Context, authHeader bearertoken.Token, requestArg IngestRunRequest) (IngestRunResponse, error)
	/*
	   Ingests video data from a S3 Nominal upload bucket.

	   Deprecated: Replaced by ingest.
	*/
	IngestVideo(ctx context.Context, authHeader bearertoken.Token, ingestVideoArg IngestVideoRequest) (IngestVideoResponse, error)
	/*
	   Re-ingests data from provided source datasets into either an existing target dataset, or a new one.
	   Only supported for CSV and Parquet dataset files.
	   Will only reingest dataset files and will drop streaming data from datasets.
	*/
	ReingestFromDatasets(ctx context.Context, authHeader bearertoken.Token, requestArg ReingestDatasetsRequest) (ReingestDatasetsResponse, error)
	/*
	   This is a best effort deletion of the file's data based on the ingestedAt timestamp. This is an unreversible
	   action. Only v2 dataset file deletion is supported.
	   !!!WARNING!!!
	   It's possible that the file has overwritten points, in which case, those older points will not be recovered.
	   Only use this endpoint if this is acceptable, the data across files are disjoint, or you're willing to
	   re-ingest files to manually recover older points.
	*/
	DeleteFile(ctx context.Context, authHeader bearertoken.Token, datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) error
}

type ingestServiceClient struct {
	client httpclient.Client
}

func NewIngestServiceClient(client httpclient.Client) IngestServiceClient {
	return &ingestServiceClient{client: client}
}

func (c *ingestServiceClient) Ingest(ctx context.Context, authHeader bearertoken.Token, triggerIngestArg IngestRequest) (IngestResponse, error) {
	var defaultReturnVal IngestResponse
	var returnVal *IngestResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Ingest"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/ingest"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(triggerIngestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "ingest failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "ingest response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) RerunIngest(ctx context.Context, authHeader bearertoken.Token, requestArg RerunIngestRequest) (IngestResponse, error) {
	var defaultReturnVal IngestResponse
	var returnVal *IngestResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("RerunIngest"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/re-ingest"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "rerunIngest failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "rerunIngest response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) IngestRun(ctx context.Context, authHeader bearertoken.Token, requestArg IngestRunRequest) (IngestRunResponse, error) {
	var defaultReturnVal IngestRunResponse
	var returnVal *IngestRunResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("IngestRun"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/ingest-run"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "ingestRun failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "ingestRun response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) IngestVideo(ctx context.Context, authHeader bearertoken.Token, ingestVideoArg IngestVideoRequest) (IngestVideoResponse, error) {
	var defaultReturnVal IngestVideoResponse
	var returnVal *IngestVideoResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("IngestVideo"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/ingest-video"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(ingestVideoArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "ingestVideo failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "ingestVideo response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) ReingestFromDatasets(ctx context.Context, authHeader bearertoken.Token, requestArg ReingestDatasetsRequest) (ReingestDatasetsResponse, error) {
	var defaultReturnVal ReingestDatasetsResponse
	var returnVal *ReingestDatasetsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ReingestFromDatasets"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/reingest-dataset-files"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "reingestFromDatasets failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "reingestFromDatasets response cannot be nil")
	}
	return *returnVal, nil
}

func (c *ingestServiceClient) DeleteFile(ctx context.Context, authHeader bearertoken.Token, datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("DeleteFile"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("DELETE"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/ingest/v1/delete-file/%s/file/%s", url.PathEscape(fmt.Sprint(datasetRidArg)), url.PathEscape(fmt.Sprint(fileIdArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "deleteFile failed")
	}
	return nil
}

// The Ingest Service handles the data ingestion into Nominal/Clickhouse.
type IngestServiceClientWithAuth interface {
	/*
	   Triggers an ingest job, allowing either creating a new dataset or uploading to an
	   existing one. This endpoint is meant to supersede all other ingestion endpoints as their functionality
	   gets migrated to this one.
	*/
	Ingest(ctx context.Context, triggerIngestArg IngestRequest) (IngestResponse, error)
	/*
	   Triggers an ingest job using an existing ingest job RID.
	   Returns the same response format as the /ingest endpoint.
	*/
	RerunIngest(ctx context.Context, requestArg RerunIngestRequest) (IngestResponse, error)
	// Creates a run and ingests data sources to be added to the run.
	IngestRun(ctx context.Context, requestArg IngestRunRequest) (IngestRunResponse, error)
	/*
	   Ingests video data from a S3 Nominal upload bucket.

	   Deprecated: Replaced by ingest.
	*/
	IngestVideo(ctx context.Context, ingestVideoArg IngestVideoRequest) (IngestVideoResponse, error)
	/*
	   Re-ingests data from provided source datasets into either an existing target dataset, or a new one.
	   Only supported for CSV and Parquet dataset files.
	   Will only reingest dataset files and will drop streaming data from datasets.
	*/
	ReingestFromDatasets(ctx context.Context, requestArg ReingestDatasetsRequest) (ReingestDatasetsResponse, error)
	/*
	   This is a best effort deletion of the file's data based on the ingestedAt timestamp. This is an unreversible
	   action. Only v2 dataset file deletion is supported.
	   !!!WARNING!!!
	   It's possible that the file has overwritten points, in which case, those older points will not be recovered.
	   Only use this endpoint if this is acceptable, the data across files are disjoint, or you're willing to
	   re-ingest files to manually recover older points.
	*/
	DeleteFile(ctx context.Context, datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) error
}

func NewIngestServiceClientWithAuth(client IngestServiceClient, authHeader bearertoken.Token) IngestServiceClientWithAuth {
	return &ingestServiceClientWithAuth{client: client, authHeader: authHeader}
}

type ingestServiceClientWithAuth struct {
	client     IngestServiceClient
	authHeader bearertoken.Token
}

func (c *ingestServiceClientWithAuth) Ingest(ctx context.Context, triggerIngestArg IngestRequest) (IngestResponse, error) {
	return c.client.Ingest(ctx, c.authHeader, triggerIngestArg)
}

func (c *ingestServiceClientWithAuth) RerunIngest(ctx context.Context, requestArg RerunIngestRequest) (IngestResponse, error) {
	return c.client.RerunIngest(ctx, c.authHeader, requestArg)
}

func (c *ingestServiceClientWithAuth) IngestRun(ctx context.Context, requestArg IngestRunRequest) (IngestRunResponse, error) {
	return c.client.IngestRun(ctx, c.authHeader, requestArg)
}

func (c *ingestServiceClientWithAuth) IngestVideo(ctx context.Context, ingestVideoArg IngestVideoRequest) (IngestVideoResponse, error) {
	return c.client.IngestVideo(ctx, c.authHeader, ingestVideoArg)
}

func (c *ingestServiceClientWithAuth) ReingestFromDatasets(ctx context.Context, requestArg ReingestDatasetsRequest) (ReingestDatasetsResponse, error) {
	return c.client.ReingestFromDatasets(ctx, c.authHeader, requestArg)
}

func (c *ingestServiceClientWithAuth) DeleteFile(ctx context.Context, datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) error {
	return c.client.DeleteFile(ctx, c.authHeader, datasetRidArg, fileIdArg)
}

func NewIngestServiceClientWithTokenProvider(client IngestServiceClient, tokenProvider httpclient.TokenProvider) IngestServiceClientWithAuth {
	return &ingestServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type ingestServiceClientWithTokenProvider struct {
	client        IngestServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *ingestServiceClientWithTokenProvider) Ingest(ctx context.Context, triggerIngestArg IngestRequest) (IngestResponse, error) {
	var defaultReturnVal IngestResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Ingest(ctx, bearertoken.Token(token), triggerIngestArg)
}

func (c *ingestServiceClientWithTokenProvider) RerunIngest(ctx context.Context, requestArg RerunIngestRequest) (IngestResponse, error) {
	var defaultReturnVal IngestResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.RerunIngest(ctx, bearertoken.Token(token), requestArg)
}

func (c *ingestServiceClientWithTokenProvider) IngestRun(ctx context.Context, requestArg IngestRunRequest) (IngestRunResponse, error) {
	var defaultReturnVal IngestRunResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.IngestRun(ctx, bearertoken.Token(token), requestArg)
}

func (c *ingestServiceClientWithTokenProvider) IngestVideo(ctx context.Context, ingestVideoArg IngestVideoRequest) (IngestVideoResponse, error) {
	var defaultReturnVal IngestVideoResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.IngestVideo(ctx, bearertoken.Token(token), ingestVideoArg)
}

func (c *ingestServiceClientWithTokenProvider) ReingestFromDatasets(ctx context.Context, requestArg ReingestDatasetsRequest) (ReingestDatasetsResponse, error) {
	var defaultReturnVal ReingestDatasetsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ReingestFromDatasets(ctx, bearertoken.Token(token), requestArg)
}

func (c *ingestServiceClientWithTokenProvider) DeleteFile(ctx context.Context, datasetRidArg rids.DatasetRid, fileIdArg uuid.UUID) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.DeleteFile(ctx, bearertoken.Token(token), datasetRidArg, fileIdArg)
}

// Internal API for managing ingest jobs. This service is filtered out from public documentation.
type InternalIngestJobServiceClient interface {
	// Creates an ingest job, returning a RID for the job.
	CreateIngestJob(ctx context.Context, authHeader bearertoken.Token, createIngestJobRequestArg CreateIngestJobRequest) (IngestJobRid, error)
	// Returns a single ingest job by RID with full details including the ingest request.
	GetIngestJobInternal(ctx context.Context, authHeader bearertoken.Token, ingestJobRidArg IngestJobRid) (InternalIngestJob, error)
	// Updates the status of an ingest job.
	UpdateIngestJobStatus(ctx context.Context, authHeader bearertoken.Token, ingestJobRidArg IngestJobRid, statusArg IngestJobStatus) (IngestJobStatus, error)
}

type internalIngestJobServiceClient struct {
	client httpclient.Client
}

func NewInternalIngestJobServiceClient(client httpclient.Client) InternalIngestJobServiceClient {
	return &internalIngestJobServiceClient{client: client}
}

func (c *internalIngestJobServiceClient) CreateIngestJob(ctx context.Context, authHeader bearertoken.Token, createIngestJobRequestArg CreateIngestJobRequest) (IngestJobRid, error) {
	var defaultReturnVal IngestJobRid
	var returnVal *IngestJobRid
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateIngestJob"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/internal/ingest/v1/ingest-job"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(createIngestJobRequestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createIngestJob failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createIngestJob response cannot be nil")
	}
	return *returnVal, nil
}

func (c *internalIngestJobServiceClient) GetIngestJobInternal(ctx context.Context, authHeader bearertoken.Token, ingestJobRidArg IngestJobRid) (InternalIngestJob, error) {
	var defaultReturnVal InternalIngestJob
	var returnVal *InternalIngestJob
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetIngestJobInternal"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/internal/ingest/v1/ingest-job/%s", url.PathEscape(fmt.Sprint(ingestJobRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getIngestJobInternal failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getIngestJobInternal response cannot be nil")
	}
	return *returnVal, nil
}

func (c *internalIngestJobServiceClient) UpdateIngestJobStatus(ctx context.Context, authHeader bearertoken.Token, ingestJobRidArg IngestJobRid, statusArg IngestJobStatus) (IngestJobStatus, error) {
	var defaultReturnVal IngestJobStatus
	var returnVal *IngestJobStatus
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateIngestJobStatus"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/internal/ingest/v1/ingest-job/%s/status", url.PathEscape(fmt.Sprint(ingestJobRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(statusArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateIngestJobStatus failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateIngestJobStatus response cannot be nil")
	}
	return *returnVal, nil
}

// Internal API for managing ingest jobs. This service is filtered out from public documentation.
type InternalIngestJobServiceClientWithAuth interface {
	// Creates an ingest job, returning a RID for the job.
	CreateIngestJob(ctx context.Context, createIngestJobRequestArg CreateIngestJobRequest) (IngestJobRid, error)
	// Returns a single ingest job by RID with full details including the ingest request.
	GetIngestJobInternal(ctx context.Context, ingestJobRidArg IngestJobRid) (InternalIngestJob, error)
	// Updates the status of an ingest job.
	UpdateIngestJobStatus(ctx context.Context, ingestJobRidArg IngestJobRid, statusArg IngestJobStatus) (IngestJobStatus, error)
}

func NewInternalIngestJobServiceClientWithAuth(client InternalIngestJobServiceClient, authHeader bearertoken.Token) InternalIngestJobServiceClientWithAuth {
	return &internalIngestJobServiceClientWithAuth{client: client, authHeader: authHeader}
}

type internalIngestJobServiceClientWithAuth struct {
	client     InternalIngestJobServiceClient
	authHeader bearertoken.Token
}

func (c *internalIngestJobServiceClientWithAuth) CreateIngestJob(ctx context.Context, createIngestJobRequestArg CreateIngestJobRequest) (IngestJobRid, error) {
	return c.client.CreateIngestJob(ctx, c.authHeader, createIngestJobRequestArg)
}

func (c *internalIngestJobServiceClientWithAuth) GetIngestJobInternal(ctx context.Context, ingestJobRidArg IngestJobRid) (InternalIngestJob, error) {
	return c.client.GetIngestJobInternal(ctx, c.authHeader, ingestJobRidArg)
}

func (c *internalIngestJobServiceClientWithAuth) UpdateIngestJobStatus(ctx context.Context, ingestJobRidArg IngestJobRid, statusArg IngestJobStatus) (IngestJobStatus, error) {
	return c.client.UpdateIngestJobStatus(ctx, c.authHeader, ingestJobRidArg, statusArg)
}

func NewInternalIngestJobServiceClientWithTokenProvider(client InternalIngestJobServiceClient, tokenProvider httpclient.TokenProvider) InternalIngestJobServiceClientWithAuth {
	return &internalIngestJobServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type internalIngestJobServiceClientWithTokenProvider struct {
	client        InternalIngestJobServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *internalIngestJobServiceClientWithTokenProvider) CreateIngestJob(ctx context.Context, createIngestJobRequestArg CreateIngestJobRequest) (IngestJobRid, error) {
	var defaultReturnVal IngestJobRid
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateIngestJob(ctx, bearertoken.Token(token), createIngestJobRequestArg)
}

func (c *internalIngestJobServiceClientWithTokenProvider) GetIngestJobInternal(ctx context.Context, ingestJobRidArg IngestJobRid) (InternalIngestJob, error) {
	var defaultReturnVal InternalIngestJob
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetIngestJobInternal(ctx, bearertoken.Token(token), ingestJobRidArg)
}

func (c *internalIngestJobServiceClientWithTokenProvider) UpdateIngestJobStatus(ctx context.Context, ingestJobRidArg IngestJobRid, statusArg IngestJobStatus) (IngestJobStatus, error) {
	var defaultReturnVal IngestJobStatus
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateIngestJobStatus(ctx, bearertoken.Token(token), ingestJobRidArg, statusArg)
}
