// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/ingest/api"
	"github.com/nominal-io/nominal-api/scout/catalog"
	"github.com/palantir/pkg/bearertoken"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
)

type Empty struct{}

func (o Empty) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Empty) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Ensure that the extractor job exists in the control plane. Runs in the namespace given by workspaceRid.
type EnsureExtractorJobCreatedRequest struct {
	BearerToken            bearertoken.Token          `json:"bearerToken"`
	WorkspaceRid           rids.WorkspaceRid          `json:"workspaceRid"`
	IngestJobUuid          uuid.UUID                  `json:"ingestJobUuid"`
	ContainerizedExtractor api.ContainerizedExtractor `json:"containerizedExtractor"`
	Tag                    string                     `json:"tag"`
	ValidatedFileInputs    []ValidatedFileInput       `json:"validatedFileInputs"`
	MultipartUploadDetails MultipartUploadDetails     `json:"multipartUploadDetails"`
	// Name of the Kubernetes secret to use for pulling the image, if authentication is required.
	ImagePullSecretName *string `conjure-docs:"Name of the Kubernetes secret to use for pulling the image, if authentication is required." json:"imagePullSecretName,omitempty"`
}

func (o EnsureExtractorJobCreatedRequest) MarshalJSON() ([]byte, error) {
	if o.ValidatedFileInputs == nil {
		o.ValidatedFileInputs = make([]ValidatedFileInput, 0)
	}
	type _tmpEnsureExtractorJobCreatedRequest EnsureExtractorJobCreatedRequest
	return safejson.Marshal(_tmpEnsureExtractorJobCreatedRequest(o))
}

func (o *EnsureExtractorJobCreatedRequest) UnmarshalJSON(data []byte) error {
	type _tmpEnsureExtractorJobCreatedRequest EnsureExtractorJobCreatedRequest
	var rawEnsureExtractorJobCreatedRequest _tmpEnsureExtractorJobCreatedRequest
	if err := safejson.Unmarshal(data, &rawEnsureExtractorJobCreatedRequest); err != nil {
		return err
	}
	if rawEnsureExtractorJobCreatedRequest.ValidatedFileInputs == nil {
		rawEnsureExtractorJobCreatedRequest.ValidatedFileInputs = make([]ValidatedFileInput, 0)
	}
	*o = EnsureExtractorJobCreatedRequest(rawEnsureExtractorJobCreatedRequest)
	return nil
}

func (o EnsureExtractorJobCreatedRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnsureExtractorJobCreatedRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnsureExtractorJobCreatedResponse struct{}

func (o EnsureExtractorJobCreatedResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnsureExtractorJobCreatedResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Ensures a Kubernetes secret of type kubernetes.io/dockerconfigjson exists
for the given registry credentials.
*/
type EnsureImagePullSecretCreatedRequest struct {
	WorkspaceRid   rids.WorkspaceRid                 `json:"workspaceRid"`
	ImageSource    api.DockerImageSource             `json:"imageSource"`
	Authentication api.UserAndPasswordAuthentication `json:"authentication"`
	IngestJobUuid  uuid.UUID                         `json:"ingestJobUuid"`
	BearerToken    bearertoken.Token                 `json:"bearerToken"`
}

func (o EnsureImagePullSecretCreatedRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnsureImagePullSecretCreatedRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type EnsureImagePullSecretCreatedResponse struct {
	SecretName string `json:"secretName"`
}

func (o EnsureImagePullSecretCreatedResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnsureImagePullSecretCreatedResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// For a given workspace rid, ensures there is a log4j2 config map defined in the namespace.
type EnsureWorkspaceConfigMapCreatedRequest struct {
	WorkspaceRid rids.WorkspaceRid `json:"workspaceRid"`
}

func (o EnsureWorkspaceConfigMapCreatedRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnsureWorkspaceConfigMapCreatedRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// For a given workspace rid, ensures that there is a corresponding K8s namespace created.
type EnsureWorkspaceNamespaceCreatedRequest struct {
	WorkspaceRid rids.WorkspaceRid `json:"workspaceRid"`
}

func (o EnsureWorkspaceNamespaceCreatedRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnsureWorkspaceNamespaceCreatedRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// For a given workspace rid, ensures that there is a service account in the proper K8s Namespace.
type EnsureWorkspaceServiceAccountCreatedRequest struct {
	WorkspaceRid rids.WorkspaceRid `json:"workspaceRid"`
}

func (o EnsureWorkspaceServiceAccountCreatedRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *EnsureWorkspaceServiceAccountCreatedRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Request to fetch logs for all containers in a completed extractor job's pod.
type FetchExtractorJobLogsRequest struct {
	WorkspaceRid  rids.WorkspaceRid             `json:"workspaceRid"`
	LogDatasetRid rids.DatasetRid               `json:"logDatasetRid"`
	IngestJobUuid uuid.UUID                     `json:"ingestJobUuid"`
	BearerToken   bearertoken.Token             `json:"bearerToken"`
	ExtractorRid  api.ContainerizedExtractorRid `json:"extractorRid"`
}

func (o FetchExtractorJobLogsRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FetchExtractorJobLogsRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FetchExtractorJobLogsResponse struct{}

func (o FetchExtractorJobLogsResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FetchExtractorJobLogsResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetExtractorJobStateRequest struct {
	WorkspaceRid  rids.WorkspaceRid `json:"workspaceRid"`
	IngestJobUuid uuid.UUID         `json:"ingestJobUuid"`
}

func (o GetExtractorJobStateRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetExtractorJobStateRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type GetExtractorJobStateResponse struct {
	State   ExtractorJobState `json:"state"`
	Message *string           `json:"message,omitempty"`
}

func (o GetExtractorJobStateResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *GetExtractorJobStateResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestDataflashRequest struct {
	Locator ObjectLocator `json:"locator"`
}

func (o IngestDataflashRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestDataflashRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestDataflashResponse struct {
	Units map[string]string `json:"units"`
	/*
	   Azure or S3-style blob locators of parquet files. Currently
	   only a single file is supported, the list type is used for future compatibility.
	*/
	ParquetObjectLocators []ObjectLocator `conjure-docs:"Azure or S3-style blob locators of parquet files. Currently\nonly a single file is supported, the list type is used for future compatibility." json:"parquetObjectLocators"`
	// The name of the column in the generated parquet file that contains the timestamp.
	TimestampSeriesName string `conjure-docs:"The name of the column in the generated parquet file that contains the timestamp." json:"timestampSeriesName"`
	// The unit of time for the timestamp column. Can only be seconds.
	TimeUnit TimeUnitSeconds `conjure-docs:"The unit of time for the timestamp column. Can only be seconds." json:"timeUnit"`
}

func (o IngestDataflashResponse) MarshalJSON() ([]byte, error) {
	if o.Units == nil {
		o.Units = make(map[string]string, 0)
	}
	if o.ParquetObjectLocators == nil {
		o.ParquetObjectLocators = make([]ObjectLocator, 0)
	}
	type _tmpIngestDataflashResponse IngestDataflashResponse
	return safejson.Marshal(_tmpIngestDataflashResponse(o))
}

func (o *IngestDataflashResponse) UnmarshalJSON(data []byte) error {
	type _tmpIngestDataflashResponse IngestDataflashResponse
	var rawIngestDataflashResponse _tmpIngestDataflashResponse
	if err := safejson.Unmarshal(data, &rawIngestDataflashResponse); err != nil {
		return err
	}
	if rawIngestDataflashResponse.Units == nil {
		rawIngestDataflashResponse.Units = make(map[string]string, 0)
	}
	if rawIngestDataflashResponse.ParquetObjectLocators == nil {
		rawIngestDataflashResponse.ParquetObjectLocators = make([]ObjectLocator, 0)
	}
	*o = IngestDataflashResponse(rawIngestDataflashResponse)
	return nil
}

func (o IngestDataflashResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestDataflashResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestMcapProtobufRequest struct {
	Locator  ObjectLocator     `json:"locator"`
	Channels McapProtoChannels `json:"channels"`
}

func (o IngestMcapProtobufRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestMcapProtobufRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type IngestMcapProtobufResponse struct {
	TimestampColumnName string `json:"timestampColumnName"`
	/*
	   Azure or S3-style blob locators of parquet files. Currently
	   only a single file is supported, the list type is used for future compatibility.
	*/
	ParquetObjectLocators []ObjectLocator `conjure-docs:"Azure or S3-style blob locators of parquet files. Currently\nonly a single file is supported, the list type is used for future compatibility." json:"parquetObjectLocators"`
}

func (o IngestMcapProtobufResponse) MarshalJSON() ([]byte, error) {
	if o.ParquetObjectLocators == nil {
		o.ParquetObjectLocators = make([]ObjectLocator, 0)
	}
	type _tmpIngestMcapProtobufResponse IngestMcapProtobufResponse
	return safejson.Marshal(_tmpIngestMcapProtobufResponse(o))
}

func (o *IngestMcapProtobufResponse) UnmarshalJSON(data []byte) error {
	type _tmpIngestMcapProtobufResponse IngestMcapProtobufResponse
	var rawIngestMcapProtobufResponse _tmpIngestMcapProtobufResponse
	if err := safejson.Unmarshal(data, &rawIngestMcapProtobufResponse); err != nil {
		return err
	}
	if rawIngestMcapProtobufResponse.ParquetObjectLocators == nil {
		rawIngestMcapProtobufResponse.ParquetObjectLocators = make([]ObjectLocator, 0)
	}
	*o = IngestMcapProtobufResponse(rawIngestMcapProtobufResponse)
	return nil
}

func (o IngestMcapProtobufResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *IngestMcapProtobufResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type MultipartUploadDetails struct {
	UploadId string           `json:"uploadId"`
	S3Handle catalog.S3Handle `json:"s3Handle"`
}

func (o MultipartUploadDetails) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *MultipartUploadDetails) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

/*
Locator for files in an object store.
Clients are expected to have auth and origin/region configured independently.
*/
type ObjectLocator struct {
	Bucket     string `json:"bucket"`
	ObjectName string `json:"objectName"`
}

func (o ObjectLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ObjectLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type PresignedFileInput struct {
	Url   PresignedUrl       `json:"url"`
	Input ValidatedFileInput `json:"input"`
}

func (o PresignedFileInput) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PresignedFileInput) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ValidatedFileInput struct {
	// Path to the input file in S3.
	Handle catalog.S3Handle `conjure-docs:"Path to the input file in S3." json:"handle"`
	// Name of the file that will be placed on disk.
	FileName string `conjure-docs:"Name of the file that will be placed on disk." json:"fileName"`
	// Environment variable that will store the path to the file.
	EnvVar string `conjure-docs:"Environment variable that will store the path to the file." json:"envVar"`
}

func (o ValidatedFileInput) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ValidatedFileInput) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
