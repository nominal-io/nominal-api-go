// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type McapProtoChannels struct {
	typ           string
	all           *Empty
	includeTopics *[]McapTopicName
	excludeTopics *[]McapTopicName
}

type mcapProtoChannelsDeserializer struct {
	Type          string           `json:"type"`
	All           *Empty           `json:"all"`
	IncludeTopics *[]McapTopicName `json:"includeTopics"`
	ExcludeTopics *[]McapTopicName `json:"excludeTopics"`
}

func (u *mcapProtoChannelsDeserializer) toStruct() McapProtoChannels {
	return McapProtoChannels{typ: u.Type, all: u.All, includeTopics: u.IncludeTopics, excludeTopics: u.ExcludeTopics}
}

func (u *McapProtoChannels) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "all":
		if u.all == nil {
			return nil, fmt.Errorf("field \"all\" is required")
		}
		return struct {
			Type string `json:"type"`
			All  Empty  `json:"all"`
		}{Type: "all", All: *u.all}, nil
	case "includeTopics":
		if u.includeTopics == nil {
			return nil, fmt.Errorf("field \"includeTopics\" is required")
		}
		return struct {
			Type          string          `json:"type"`
			IncludeTopics []McapTopicName `json:"includeTopics"`
		}{Type: "includeTopics", IncludeTopics: *u.includeTopics}, nil
	case "excludeTopics":
		if u.excludeTopics == nil {
			return nil, fmt.Errorf("field \"excludeTopics\" is required")
		}
		return struct {
			Type          string          `json:"type"`
			ExcludeTopics []McapTopicName `json:"excludeTopics"`
		}{Type: "excludeTopics", ExcludeTopics: *u.excludeTopics}, nil
	}
}

func (u McapProtoChannels) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *McapProtoChannels) UnmarshalJSON(data []byte) error {
	var deser mcapProtoChannelsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
	case "includeTopics":
		if u.includeTopics == nil {
			return fmt.Errorf("field \"includeTopics\" is required")
		}
	case "excludeTopics":
		if u.excludeTopics == nil {
			return fmt.Errorf("field \"excludeTopics\" is required")
		}
	}
	return nil
}

func (u McapProtoChannels) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *McapProtoChannels) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *McapProtoChannels) AcceptFuncs(allFunc func(Empty) error, includeTopicsFunc func([]McapTopicName) error, excludeTopicsFunc func([]McapTopicName) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return allFunc(*u.all)
	case "includeTopics":
		if u.includeTopics == nil {
			return fmt.Errorf("field \"includeTopics\" is required")
		}
		return includeTopicsFunc(*u.includeTopics)
	case "excludeTopics":
		if u.excludeTopics == nil {
			return fmt.Errorf("field \"excludeTopics\" is required")
		}
		return excludeTopicsFunc(*u.excludeTopics)
	}
}

func (u *McapProtoChannels) AllNoopSuccess(Empty) error {
	return nil
}

func (u *McapProtoChannels) IncludeTopicsNoopSuccess([]McapTopicName) error {
	return nil
}

func (u *McapProtoChannels) ExcludeTopicsNoopSuccess([]McapTopicName) error {
	return nil
}

func (u *McapProtoChannels) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *McapProtoChannels) Accept(v McapProtoChannelsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAll(*u.all)
	case "includeTopics":
		if u.includeTopics == nil {
			return fmt.Errorf("field \"includeTopics\" is required")
		}
		return v.VisitIncludeTopics(*u.includeTopics)
	case "excludeTopics":
		if u.excludeTopics == nil {
			return fmt.Errorf("field \"excludeTopics\" is required")
		}
		return v.VisitExcludeTopics(*u.excludeTopics)
	}
}

type McapProtoChannelsVisitor interface {
	VisitAll(v Empty) error
	VisitIncludeTopics(v []McapTopicName) error
	VisitExcludeTopics(v []McapTopicName) error
	VisitUnknown(typeName string) error
}

func (u *McapProtoChannels) AcceptWithContext(ctx context.Context, v McapProtoChannelsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "all":
		if u.all == nil {
			return fmt.Errorf("field \"all\" is required")
		}
		return v.VisitAllWithContext(ctx, *u.all)
	case "includeTopics":
		if u.includeTopics == nil {
			return fmt.Errorf("field \"includeTopics\" is required")
		}
		return v.VisitIncludeTopicsWithContext(ctx, *u.includeTopics)
	case "excludeTopics":
		if u.excludeTopics == nil {
			return fmt.Errorf("field \"excludeTopics\" is required")
		}
		return v.VisitExcludeTopicsWithContext(ctx, *u.excludeTopics)
	}
}

type McapProtoChannelsVisitorWithContext interface {
	VisitAllWithContext(ctx context.Context, v Empty) error
	VisitIncludeTopicsWithContext(ctx context.Context, v []McapTopicName) error
	VisitExcludeTopicsWithContext(ctx context.Context, v []McapTopicName) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewMcapProtoChannelsFromAll(v Empty) McapProtoChannels {
	return McapProtoChannels{typ: "all", all: &v}
}

func NewMcapProtoChannelsFromIncludeTopics(v []McapTopicName) McapProtoChannels {
	return McapProtoChannels{typ: "includeTopics", includeTopics: &v}
}

func NewMcapProtoChannelsFromExcludeTopics(v []McapTopicName) McapProtoChannels {
	return McapProtoChannels{typ: "excludeTopics", excludeTopics: &v}
}
