// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type LocatorTemplate struct {
	typ            string
	timescaleDb    *TimescaleDbLocatorTemplate
	influx         *Influx2LocatorTemplate
	influx1        *Influx1LocatorTemplate
	nominal        *NominalLocatorTemplate
	timestream     *TimestreamLocatorTemplate
	visualCrossing *VisualCrossingLocatorTemplate
	bigQuery       *BigQueryLocatorTemplate
	csv            *CsvLocatorTemplate
	csvV2          *CsvLocatorV2Template
}

type locatorTemplateDeserializer struct {
	Type           string                         `json:"type"`
	TimescaleDb    *TimescaleDbLocatorTemplate    `json:"timescaleDb"`
	Influx         *Influx2LocatorTemplate        `json:"influx"`
	Influx1        *Influx1LocatorTemplate        `json:"influx1"`
	Nominal        *NominalLocatorTemplate        `json:"nominal"`
	Timestream     *TimestreamLocatorTemplate     `json:"timestream"`
	VisualCrossing *VisualCrossingLocatorTemplate `json:"visualCrossing"`
	BigQuery       *BigQueryLocatorTemplate       `json:"bigQuery"`
	Csv            *CsvLocatorTemplate            `json:"csv"`
	CsvV2          *CsvLocatorV2Template          `json:"csvV2"`
}

func (u *locatorTemplateDeserializer) toStruct() LocatorTemplate {
	return LocatorTemplate{typ: u.Type, timescaleDb: u.TimescaleDb, influx: u.Influx, influx1: u.Influx1, nominal: u.Nominal, timestream: u.Timestream, visualCrossing: u.VisualCrossing, bigQuery: u.BigQuery, csv: u.Csv, csvV2: u.CsvV2}
}

func (u *LocatorTemplate) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timescaleDb":
		if u.timescaleDb == nil {
			return nil, fmt.Errorf("field \"timescaleDb\" is required")
		}
		return struct {
			Type        string                     `json:"type"`
			TimescaleDb TimescaleDbLocatorTemplate `json:"timescaleDb"`
		}{Type: "timescaleDb", TimescaleDb: *u.timescaleDb}, nil
	case "influx":
		if u.influx == nil {
			return nil, fmt.Errorf("field \"influx\" is required")
		}
		return struct {
			Type   string                 `json:"type"`
			Influx Influx2LocatorTemplate `json:"influx"`
		}{Type: "influx", Influx: *u.influx}, nil
	case "influx1":
		if u.influx1 == nil {
			return nil, fmt.Errorf("field \"influx1\" is required")
		}
		return struct {
			Type    string                 `json:"type"`
			Influx1 Influx1LocatorTemplate `json:"influx1"`
		}{Type: "influx1", Influx1: *u.influx1}, nil
	case "nominal":
		if u.nominal == nil {
			return nil, fmt.Errorf("field \"nominal\" is required")
		}
		return struct {
			Type    string                 `json:"type"`
			Nominal NominalLocatorTemplate `json:"nominal"`
		}{Type: "nominal", Nominal: *u.nominal}, nil
	case "timestream":
		if u.timestream == nil {
			return nil, fmt.Errorf("field \"timestream\" is required")
		}
		return struct {
			Type       string                    `json:"type"`
			Timestream TimestreamLocatorTemplate `json:"timestream"`
		}{Type: "timestream", Timestream: *u.timestream}, nil
	case "visualCrossing":
		if u.visualCrossing == nil {
			return nil, fmt.Errorf("field \"visualCrossing\" is required")
		}
		return struct {
			Type           string                        `json:"type"`
			VisualCrossing VisualCrossingLocatorTemplate `json:"visualCrossing"`
		}{Type: "visualCrossing", VisualCrossing: *u.visualCrossing}, nil
	case "bigQuery":
		if u.bigQuery == nil {
			return nil, fmt.Errorf("field \"bigQuery\" is required")
		}
		return struct {
			Type     string                  `json:"type"`
			BigQuery BigQueryLocatorTemplate `json:"bigQuery"`
		}{Type: "bigQuery", BigQuery: *u.bigQuery}, nil
	case "csv":
		if u.csv == nil {
			return nil, fmt.Errorf("field \"csv\" is required")
		}
		return struct {
			Type string             `json:"type"`
			Csv  CsvLocatorTemplate `json:"csv"`
		}{Type: "csv", Csv: *u.csv}, nil
	case "csvV2":
		if u.csvV2 == nil {
			return nil, fmt.Errorf("field \"csvV2\" is required")
		}
		return struct {
			Type  string               `json:"type"`
			CsvV2 CsvLocatorV2Template `json:"csvV2"`
		}{Type: "csvV2", CsvV2: *u.csvV2}, nil
	}
}

func (u LocatorTemplate) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *LocatorTemplate) UnmarshalJSON(data []byte) error {
	var deser locatorTemplateDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timescaleDb":
		if u.timescaleDb == nil {
			return fmt.Errorf("field \"timescaleDb\" is required")
		}
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
	case "influx1":
		if u.influx1 == nil {
			return fmt.Errorf("field \"influx1\" is required")
		}
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
	case "csvV2":
		if u.csvV2 == nil {
			return fmt.Errorf("field \"csvV2\" is required")
		}
	}
	return nil
}

func (u LocatorTemplate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *LocatorTemplate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *LocatorTemplate) AcceptFuncs(timescaleDbFunc func(TimescaleDbLocatorTemplate) error, influxFunc func(Influx2LocatorTemplate) error, influx1Func func(Influx1LocatorTemplate) error, nominalFunc func(NominalLocatorTemplate) error, timestreamFunc func(TimestreamLocatorTemplate) error, visualCrossingFunc func(VisualCrossingLocatorTemplate) error, bigQueryFunc func(BigQueryLocatorTemplate) error, csvFunc func(CsvLocatorTemplate) error, csvV2Func func(CsvLocatorV2Template) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timescaleDb":
		if u.timescaleDb == nil {
			return fmt.Errorf("field \"timescaleDb\" is required")
		}
		return timescaleDbFunc(*u.timescaleDb)
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
		return influxFunc(*u.influx)
	case "influx1":
		if u.influx1 == nil {
			return fmt.Errorf("field \"influx1\" is required")
		}
		return influx1Func(*u.influx1)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return nominalFunc(*u.nominal)
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
		return timestreamFunc(*u.timestream)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
		return visualCrossingFunc(*u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
		return bigQueryFunc(*u.bigQuery)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return csvFunc(*u.csv)
	case "csvV2":
		if u.csvV2 == nil {
			return fmt.Errorf("field \"csvV2\" is required")
		}
		return csvV2Func(*u.csvV2)
	}
}

func (u *LocatorTemplate) TimescaleDbNoopSuccess(TimescaleDbLocatorTemplate) error {
	return nil
}

func (u *LocatorTemplate) InfluxNoopSuccess(Influx2LocatorTemplate) error {
	return nil
}

func (u *LocatorTemplate) Influx1NoopSuccess(Influx1LocatorTemplate) error {
	return nil
}

func (u *LocatorTemplate) NominalNoopSuccess(NominalLocatorTemplate) error {
	return nil
}

func (u *LocatorTemplate) TimestreamNoopSuccess(TimestreamLocatorTemplate) error {
	return nil
}

func (u *LocatorTemplate) VisualCrossingNoopSuccess(VisualCrossingLocatorTemplate) error {
	return nil
}

func (u *LocatorTemplate) BigQueryNoopSuccess(BigQueryLocatorTemplate) error {
	return nil
}

func (u *LocatorTemplate) CsvNoopSuccess(CsvLocatorTemplate) error {
	return nil
}

func (u *LocatorTemplate) CsvV2NoopSuccess(CsvLocatorV2Template) error {
	return nil
}

func (u *LocatorTemplate) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *LocatorTemplate) Accept(v LocatorTemplateVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timescaleDb":
		if u.timescaleDb == nil {
			return fmt.Errorf("field \"timescaleDb\" is required")
		}
		return v.VisitTimescaleDb(*u.timescaleDb)
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
		return v.VisitInflux(*u.influx)
	case "influx1":
		if u.influx1 == nil {
			return fmt.Errorf("field \"influx1\" is required")
		}
		return v.VisitInflux1(*u.influx1)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominal(*u.nominal)
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
		return v.VisitTimestream(*u.timestream)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
		return v.VisitVisualCrossing(*u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
		return v.VisitBigQuery(*u.bigQuery)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsv(*u.csv)
	case "csvV2":
		if u.csvV2 == nil {
			return fmt.Errorf("field \"csvV2\" is required")
		}
		return v.VisitCsvV2(*u.csvV2)
	}
}

type LocatorTemplateVisitor interface {
	VisitTimescaleDb(v TimescaleDbLocatorTemplate) error
	VisitInflux(v Influx2LocatorTemplate) error
	VisitInflux1(v Influx1LocatorTemplate) error
	VisitNominal(v NominalLocatorTemplate) error
	VisitTimestream(v TimestreamLocatorTemplate) error
	VisitVisualCrossing(v VisualCrossingLocatorTemplate) error
	VisitBigQuery(v BigQueryLocatorTemplate) error
	VisitCsv(v CsvLocatorTemplate) error
	VisitCsvV2(v CsvLocatorV2Template) error
	VisitUnknown(typeName string) error
}

func (u *LocatorTemplate) AcceptWithContext(ctx context.Context, v LocatorTemplateVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timescaleDb":
		if u.timescaleDb == nil {
			return fmt.Errorf("field \"timescaleDb\" is required")
		}
		return v.VisitTimescaleDbWithContext(ctx, *u.timescaleDb)
	case "influx":
		if u.influx == nil {
			return fmt.Errorf("field \"influx\" is required")
		}
		return v.VisitInfluxWithContext(ctx, *u.influx)
	case "influx1":
		if u.influx1 == nil {
			return fmt.Errorf("field \"influx1\" is required")
		}
		return v.VisitInflux1WithContext(ctx, *u.influx1)
	case "nominal":
		if u.nominal == nil {
			return fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominalWithContext(ctx, *u.nominal)
	case "timestream":
		if u.timestream == nil {
			return fmt.Errorf("field \"timestream\" is required")
		}
		return v.VisitTimestreamWithContext(ctx, *u.timestream)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return fmt.Errorf("field \"visualCrossing\" is required")
		}
		return v.VisitVisualCrossingWithContext(ctx, *u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return fmt.Errorf("field \"bigQuery\" is required")
		}
		return v.VisitBigQueryWithContext(ctx, *u.bigQuery)
	case "csv":
		if u.csv == nil {
			return fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsvWithContext(ctx, *u.csv)
	case "csvV2":
		if u.csvV2 == nil {
			return fmt.Errorf("field \"csvV2\" is required")
		}
		return v.VisitCsvV2WithContext(ctx, *u.csvV2)
	}
}

type LocatorTemplateVisitorWithContext interface {
	VisitTimescaleDbWithContext(ctx context.Context, v TimescaleDbLocatorTemplate) error
	VisitInfluxWithContext(ctx context.Context, v Influx2LocatorTemplate) error
	VisitInflux1WithContext(ctx context.Context, v Influx1LocatorTemplate) error
	VisitNominalWithContext(ctx context.Context, v NominalLocatorTemplate) error
	VisitTimestreamWithContext(ctx context.Context, v TimestreamLocatorTemplate) error
	VisitVisualCrossingWithContext(ctx context.Context, v VisualCrossingLocatorTemplate) error
	VisitBigQueryWithContext(ctx context.Context, v BigQueryLocatorTemplate) error
	VisitCsvWithContext(ctx context.Context, v CsvLocatorTemplate) error
	VisitCsvV2WithContext(ctx context.Context, v CsvLocatorV2Template) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLocatorTemplateFromTimescaleDb(v TimescaleDbLocatorTemplate) LocatorTemplate {
	return LocatorTemplate{typ: "timescaleDb", timescaleDb: &v}
}

func NewLocatorTemplateFromInflux(v Influx2LocatorTemplate) LocatorTemplate {
	return LocatorTemplate{typ: "influx", influx: &v}
}

func NewLocatorTemplateFromInflux1(v Influx1LocatorTemplate) LocatorTemplate {
	return LocatorTemplate{typ: "influx1", influx1: &v}
}

func NewLocatorTemplateFromNominal(v NominalLocatorTemplate) LocatorTemplate {
	return LocatorTemplate{typ: "nominal", nominal: &v}
}

func NewLocatorTemplateFromTimestream(v TimestreamLocatorTemplate) LocatorTemplate {
	return LocatorTemplate{typ: "timestream", timestream: &v}
}

func NewLocatorTemplateFromVisualCrossing(v VisualCrossingLocatorTemplate) LocatorTemplate {
	return LocatorTemplate{typ: "visualCrossing", visualCrossing: &v}
}

func NewLocatorTemplateFromBigQuery(v BigQueryLocatorTemplate) LocatorTemplate {
	return LocatorTemplate{typ: "bigQuery", bigQuery: &v}
}

func NewLocatorTemplateFromCsv(v CsvLocatorTemplate) LocatorTemplate {
	return LocatorTemplate{typ: "csv", csv: &v}
}

func NewLocatorTemplateFromCsvV2(v CsvLocatorV2Template) LocatorTemplate {
	return LocatorTemplate{typ: "csvV2", csvV2: &v}
}
