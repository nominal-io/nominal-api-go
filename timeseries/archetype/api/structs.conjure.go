// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	api2 "github.com/nominal-io/nominal-api-go/storage/series/api"
	"github.com/nominal-io/nominal-api-go/timeseries/logicalseries/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type BatchCreateSeriesArchetypeRequest struct {
	Requests []CreateSeriesArchetypeRequest `json:"requests"`
}

func (o BatchCreateSeriesArchetypeRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]CreateSeriesArchetypeRequest, 0)
	}
	type _tmpBatchCreateSeriesArchetypeRequest BatchCreateSeriesArchetypeRequest
	return safejson.Marshal(_tmpBatchCreateSeriesArchetypeRequest(o))
}

func (o *BatchCreateSeriesArchetypeRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchCreateSeriesArchetypeRequest BatchCreateSeriesArchetypeRequest
	var rawBatchCreateSeriesArchetypeRequest _tmpBatchCreateSeriesArchetypeRequest
	if err := safejson.Unmarshal(data, &rawBatchCreateSeriesArchetypeRequest); err != nil {
		return err
	}
	if rawBatchCreateSeriesArchetypeRequest.Requests == nil {
		rawBatchCreateSeriesArchetypeRequest.Requests = make([]CreateSeriesArchetypeRequest, 0)
	}
	*o = BatchCreateSeriesArchetypeRequest(rawBatchCreateSeriesArchetypeRequest)
	return nil
}

func (o BatchCreateSeriesArchetypeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchCreateSeriesArchetypeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchGetSeriesArchetypeRequest struct {
	Datasources []rids.DataSourceRid `json:"datasources"`
}

func (o BatchGetSeriesArchetypeRequest) MarshalJSON() ([]byte, error) {
	if o.Datasources == nil {
		o.Datasources = make([]rids.DataSourceRid, 0)
	}
	type _tmpBatchGetSeriesArchetypeRequest BatchGetSeriesArchetypeRequest
	return safejson.Marshal(_tmpBatchGetSeriesArchetypeRequest(o))
}

func (o *BatchGetSeriesArchetypeRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchGetSeriesArchetypeRequest BatchGetSeriesArchetypeRequest
	var rawBatchGetSeriesArchetypeRequest _tmpBatchGetSeriesArchetypeRequest
	if err := safejson.Unmarshal(data, &rawBatchGetSeriesArchetypeRequest); err != nil {
		return err
	}
	if rawBatchGetSeriesArchetypeRequest.Datasources == nil {
		rawBatchGetSeriesArchetypeRequest.Datasources = make([]rids.DataSourceRid, 0)
	}
	*o = BatchGetSeriesArchetypeRequest(rawBatchGetSeriesArchetypeRequest)
	return nil
}

func (o BatchGetSeriesArchetypeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchGetSeriesArchetypeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchGetSeriesArchetypeResponse struct {
	Responses map[rids.DataSourceRid][]SeriesArchetype `json:"responses"`
}

func (o BatchGetSeriesArchetypeResponse) MarshalJSON() ([]byte, error) {
	if o.Responses == nil {
		o.Responses = make(map[rids.DataSourceRid][]SeriesArchetype, 0)
	}
	type _tmpBatchGetSeriesArchetypeResponse BatchGetSeriesArchetypeResponse
	return safejson.Marshal(_tmpBatchGetSeriesArchetypeResponse(o))
}

func (o *BatchGetSeriesArchetypeResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchGetSeriesArchetypeResponse BatchGetSeriesArchetypeResponse
	var rawBatchGetSeriesArchetypeResponse _tmpBatchGetSeriesArchetypeResponse
	if err := safejson.Unmarshal(data, &rawBatchGetSeriesArchetypeResponse); err != nil {
		return err
	}
	if rawBatchGetSeriesArchetypeResponse.Responses == nil {
		rawBatchGetSeriesArchetypeResponse.Responses = make(map[rids.DataSourceRid][]SeriesArchetype, 0)
	}
	*o = BatchGetSeriesArchetypeResponse(rawBatchGetSeriesArchetypeResponse)
	return nil
}

func (o BatchGetSeriesArchetypeResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchGetSeriesArchetypeResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BigQueryLocatorTemplate struct {
	ValueColumn api.ColumnName   `json:"valueColumn"`
	TimeColumn  api.ColumnName   `json:"timeColumn"`
	Type        api.BigQueryType `json:"type"`
}

func (o BigQueryLocatorTemplate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BigQueryLocatorTemplate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateSeriesArchetypeRequest struct {
	/*
	   This name should be unique amongst SeriesArchetypes within the data source. All series created from this
	   archetype will share this name.
	*/
	Channel       api1.Channel       `conjure-docs:"This name should be unique amongst SeriesArchetypes within the data source. All series created from this\narchetype will share this name." json:"channel"`
	DataSourceRid rids.DataSourceRid `json:"dataSourceRid"`
	Locator       LocatorTemplate    `json:"locator"`
	Unit          *api1.Unit         `json:"unit,omitempty"`
	Description   *string            `json:"description,omitempty"`
	/*
	   Tags specified here will take precedence over tags specified in the RunDatasource, in the case that both specify the same TagName.

	   Deprecated: Deprecated. Should not be used.
	*/
	Tags map[api1.TagName]api1.TagValue `conjure-docs:"Tags specified here will take precedence over tags specified in the RunDatasource, in the case that both specify the same TagName." json:"tags"`
}

func (o CreateSeriesArchetypeRequest) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make(map[api1.TagName]api1.TagValue, 0)
	}
	type _tmpCreateSeriesArchetypeRequest CreateSeriesArchetypeRequest
	return safejson.Marshal(_tmpCreateSeriesArchetypeRequest(o))
}

func (o *CreateSeriesArchetypeRequest) UnmarshalJSON(data []byte) error {
	type _tmpCreateSeriesArchetypeRequest CreateSeriesArchetypeRequest
	var rawCreateSeriesArchetypeRequest _tmpCreateSeriesArchetypeRequest
	if err := safejson.Unmarshal(data, &rawCreateSeriesArchetypeRequest); err != nil {
		return err
	}
	if rawCreateSeriesArchetypeRequest.Tags == nil {
		rawCreateSeriesArchetypeRequest.Tags = make(map[api1.TagName]api1.TagValue, 0)
	}
	*o = CreateSeriesArchetypeRequest(rawCreateSeriesArchetypeRequest)
	return nil
}

func (o CreateSeriesArchetypeRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateSeriesArchetypeRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// Deprecated in favor of CsvLocatorV2Template
type CsvLocatorTemplate struct {
	S3Path api1.S3Path `json:"s3Path"`
	Index  int         `json:"index"`
	/*
	   If empty, defaults to false. This refers to whether the CSV was ingested using legacy format where the timestamp
	   and values are split into two separate arrow files.
	*/
	UsesLegacyFormat *bool `conjure-docs:"If empty, defaults to false. This refers to whether the CSV was ingested using legacy format where the timestamp\nand values are split into two separate arrow files." json:"usesLegacyFormat,omitempty"`
	// The handle of the x series to use for this logical series.
	XSeriesHandle *string `conjure-docs:"The handle of the x series to use for this logical series." json:"xSeriesHandle,omitempty"`
	// The handle of the y series to use for this logical series.
	YSeriesHandle *string              `conjure-docs:"The handle of the y series to use for this logical series." json:"ySeriesHandle,omitempty"`
	Type          api2.NominalDataType `json:"type"`
	Channel       api1.Channel         `json:"channel"`
}

func (o CsvLocatorTemplate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CsvLocatorTemplate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CsvLocatorV2Template struct {
	S3Path    api1.S3Path          `json:"s3Path"`
	Index     int                  `json:"index"`
	TimeIndex int                  `json:"timeIndex"`
	Type      api2.NominalDataType `json:"type"`
}

func (o CsvLocatorV2Template) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CsvLocatorV2Template) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Influx1LocatorTemplate struct {
	Database    api.DatabaseName    `json:"database"`
	Measurement api.MeasurementName `json:"measurement"`
	Field       api.FieldName       `json:"field"`
	Type        api.InfluxType      `json:"type"`
}

func (o Influx1LocatorTemplate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Influx1LocatorTemplate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Influx2LocatorTemplate struct {
	Bucket      api.BucketName      `json:"bucket"`
	Measurement api.MeasurementName `json:"measurement"`
	// If omitted, defaults to `_value`. Can be used to extract tag values.
	ValueColumn *string        `conjure-docs:"If omitted, defaults to \"_value\". Can be used to extract tag values." json:"valueColumn,omitempty"`
	Field       api.FieldName  `json:"field"`
	Type        api.InfluxType `json:"type"`
}

func (o Influx2LocatorTemplate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Influx2LocatorTemplate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NominalLocatorTemplate struct {
	Channel api1.Channel         `json:"channel"`
	Type    api2.NominalDataType `json:"type"`
}

func (o NominalLocatorTemplate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NominalLocatorTemplate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SeriesArchetype struct {
	Rid           api1.SeriesArchetypeRid `json:"rid"`
	Channel       api1.Channel            `json:"channel"`
	DataSourceRid rids.DataSourceRid      `json:"dataSourceRid"`
	Locator       LocatorTemplate         `json:"locator"`
	Unit          *api1.Unit              `json:"unit,omitempty"`
	Description   *string                 `json:"description,omitempty"`
	/*
	   Tags specified here will take precedence over tags specified in the RunDatasource, in the case that both specify the same TagName.

	   Deprecated: Deprecated. Should not be used.
	*/
	Tags           map[api1.TagName]api1.TagValue `conjure-docs:"Tags specified here will take precedence over tags specified in the RunDatasource, in the case that both specify the same TagName." json:"tags"`
	SeriesDataType *api1.SeriesDataType           `json:"seriesDataType,omitempty"`
}

func (o SeriesArchetype) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make(map[api1.TagName]api1.TagValue, 0)
	}
	type _tmpSeriesArchetype SeriesArchetype
	return safejson.Marshal(_tmpSeriesArchetype(o))
}

func (o *SeriesArchetype) UnmarshalJSON(data []byte) error {
	type _tmpSeriesArchetype SeriesArchetype
	var rawSeriesArchetype _tmpSeriesArchetype
	if err := safejson.Unmarshal(data, &rawSeriesArchetype); err != nil {
		return err
	}
	if rawSeriesArchetype.Tags == nil {
		rawSeriesArchetype.Tags = make(map[api1.TagName]api1.TagValue, 0)
	}
	*o = SeriesArchetype(rawSeriesArchetype)
	return nil
}

func (o SeriesArchetype) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SeriesArchetype) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimescaleDbLocatorTemplate struct {
	Table      api.TableName     `json:"table"`
	Schema     api.SchemaName    `json:"schema"`
	Column     api.ColumnName    `json:"column"`
	TimeColumn api.ColumnName    `json:"timeColumn"`
	Type       api.TimescaleType `json:"type"`
}

func (o TimescaleDbLocatorTemplate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimescaleDbLocatorTemplate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimestreamLocatorTemplate struct {
	Table     api.TableName      `json:"table"`
	Measure   api.MeasureName    `json:"measure"`
	Attribute *api.AttributeName `json:"attribute,omitempty"`
	Type      api.TimestreamType `json:"type"`
}

func (o TimestreamLocatorTemplate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimestreamLocatorTemplate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// If fields are present, will override existing values.
type UpdateSeriesArchetypeMetadataRequest struct {
	// Deprecated: Deprecated. Use unitUpdate instead.
	Unit        *api1.Unit      `json:"unit,omitempty"`
	UnitUpdate  *api.UnitUpdate `json:"unitUpdate,omitempty"`
	Description *string         `json:"description,omitempty"`
}

func (o UpdateSeriesArchetypeMetadataRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateSeriesArchetypeMetadataRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type VisualCrossingLocatorTemplate struct {
	Field api.FieldName `json:"field"`
	// Defaults to HISTORY.
	Endpoint *api.VisualCrossingEndpointUri `conjure-docs:"Defaults to HISTORY." json:"endpoint,omitempty"`
	Type     api.VisualCrossingType         `json:"type"`
}

func (o VisualCrossingLocatorTemplate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VisualCrossingLocatorTemplate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
