// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"
)

type LocatorTemplateWithT[T any] LocatorTemplate

func (u *LocatorTemplateWithT[T]) Accept(ctx context.Context, v LocatorTemplateVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "timescaleDb":
		if u.timescaleDb == nil {
			return result, fmt.Errorf("field \"timescaleDb\" is required")
		}
		return v.VisitTimescaleDb(ctx, *u.timescaleDb)
	case "influx":
		if u.influx == nil {
			return result, fmt.Errorf("field \"influx\" is required")
		}
		return v.VisitInflux(ctx, *u.influx)
	case "influx1":
		if u.influx1 == nil {
			return result, fmt.Errorf("field \"influx1\" is required")
		}
		return v.VisitInflux1(ctx, *u.influx1)
	case "nominal":
		if u.nominal == nil {
			return result, fmt.Errorf("field \"nominal\" is required")
		}
		return v.VisitNominal(ctx, *u.nominal)
	case "timestream":
		if u.timestream == nil {
			return result, fmt.Errorf("field \"timestream\" is required")
		}
		return v.VisitTimestream(ctx, *u.timestream)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return result, fmt.Errorf("field \"visualCrossing\" is required")
		}
		return v.VisitVisualCrossing(ctx, *u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return result, fmt.Errorf("field \"bigQuery\" is required")
		}
		return v.VisitBigQuery(ctx, *u.bigQuery)
	case "csv":
		if u.csv == nil {
			return result, fmt.Errorf("field \"csv\" is required")
		}
		return v.VisitCsv(ctx, *u.csv)
	case "csvV2":
		if u.csvV2 == nil {
			return result, fmt.Errorf("field \"csvV2\" is required")
		}
		return v.VisitCsvV2(ctx, *u.csvV2)
	}
}

func (u *LocatorTemplateWithT[T]) AcceptFuncs(timescaleDbFunc func(TimescaleDbLocatorTemplate) (T, error), influxFunc func(Influx2LocatorTemplate) (T, error), influx1Func func(Influx1LocatorTemplate) (T, error), nominalFunc func(NominalLocatorTemplate) (T, error), timestreamFunc func(TimestreamLocatorTemplate) (T, error), visualCrossingFunc func(VisualCrossingLocatorTemplate) (T, error), bigQueryFunc func(BigQueryLocatorTemplate) (T, error), csvFunc func(CsvLocatorTemplate) (T, error), csvV2Func func(CsvLocatorV2Template) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timescaleDb":
		if u.timescaleDb == nil {
			return result, fmt.Errorf("field \"timescaleDb\" is required")
		}
		return timescaleDbFunc(*u.timescaleDb)
	case "influx":
		if u.influx == nil {
			return result, fmt.Errorf("field \"influx\" is required")
		}
		return influxFunc(*u.influx)
	case "influx1":
		if u.influx1 == nil {
			return result, fmt.Errorf("field \"influx1\" is required")
		}
		return influx1Func(*u.influx1)
	case "nominal":
		if u.nominal == nil {
			return result, fmt.Errorf("field \"nominal\" is required")
		}
		return nominalFunc(*u.nominal)
	case "timestream":
		if u.timestream == nil {
			return result, fmt.Errorf("field \"timestream\" is required")
		}
		return timestreamFunc(*u.timestream)
	case "visualCrossing":
		if u.visualCrossing == nil {
			return result, fmt.Errorf("field \"visualCrossing\" is required")
		}
		return visualCrossingFunc(*u.visualCrossing)
	case "bigQuery":
		if u.bigQuery == nil {
			return result, fmt.Errorf("field \"bigQuery\" is required")
		}
		return bigQueryFunc(*u.bigQuery)
	case "csv":
		if u.csv == nil {
			return result, fmt.Errorf("field \"csv\" is required")
		}
		return csvFunc(*u.csv)
	case "csvV2":
		if u.csvV2 == nil {
			return result, fmt.Errorf("field \"csvV2\" is required")
		}
		return csvV2Func(*u.csvV2)
	}
}

func (u *LocatorTemplateWithT[T]) TimescaleDbNoopSuccess(TimescaleDbLocatorTemplate) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorTemplateWithT[T]) InfluxNoopSuccess(Influx2LocatorTemplate) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorTemplateWithT[T]) Influx1NoopSuccess(Influx1LocatorTemplate) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorTemplateWithT[T]) NominalNoopSuccess(NominalLocatorTemplate) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorTemplateWithT[T]) TimestreamNoopSuccess(TimestreamLocatorTemplate) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorTemplateWithT[T]) VisualCrossingNoopSuccess(VisualCrossingLocatorTemplate) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorTemplateWithT[T]) BigQueryNoopSuccess(BigQueryLocatorTemplate) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorTemplateWithT[T]) CsvNoopSuccess(CsvLocatorTemplate) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorTemplateWithT[T]) CsvV2NoopSuccess(CsvLocatorV2Template) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorTemplateWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LocatorTemplateVisitorWithT[T any] interface {
	VisitTimescaleDb(ctx context.Context, v TimescaleDbLocatorTemplate) (T, error)
	VisitInflux(ctx context.Context, v Influx2LocatorTemplate) (T, error)
	VisitInflux1(ctx context.Context, v Influx1LocatorTemplate) (T, error)
	VisitNominal(ctx context.Context, v NominalLocatorTemplate) (T, error)
	VisitTimestream(ctx context.Context, v TimestreamLocatorTemplate) (T, error)
	VisitVisualCrossing(ctx context.Context, v VisualCrossingLocatorTemplate) (T, error)
	VisitBigQuery(ctx context.Context, v BigQueryLocatorTemplate) (T, error)
	VisitCsv(ctx context.Context, v CsvLocatorTemplate) (T, error)
	VisitCsvV2(ctx context.Context, v CsvLocatorV2Template) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
