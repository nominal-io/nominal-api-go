// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"strings"
)

type ApiType struct {
	val ApiType_Value
}

type ApiType_Value string

const (
	ApiType_DOUBLE  ApiType_Value = "DOUBLE"
	ApiType_STRING  ApiType_Value = "STRING"
	ApiType_INT64   ApiType_Value = "INT64"
	ApiType_UNKNOWN ApiType_Value = "UNKNOWN"
)

// ApiType_Values returns all known variants of ApiType.
func ApiType_Values() []ApiType_Value {
	return []ApiType_Value{ApiType_DOUBLE, ApiType_STRING, ApiType_INT64}
}

func New_ApiType(value ApiType_Value) ApiType {
	return ApiType{val: value}
}

// IsUnknown returns false for all known variants of ApiType and true otherwise.
func (e ApiType) IsUnknown() bool {
	switch e.val {
	case ApiType_DOUBLE, ApiType_STRING, ApiType_INT64:
		return false
	}
	return true
}

func (e ApiType) Value() ApiType_Value {
	if e.IsUnknown() {
		return ApiType_UNKNOWN
	}
	return e.val
}

func (e ApiType) String() string {
	return string(e.val)
}

func (e ApiType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *ApiType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_ApiType(ApiType_Value(v))
	case "DOUBLE":
		*e = New_ApiType(ApiType_DOUBLE)
	case "STRING":
		*e = New_ApiType(ApiType_STRING)
	case "INT64":
		*e = New_ApiType(ApiType_INT64)
	}
	return nil
}

type BigQueryType struct {
	val BigQueryType_Value
}

type BigQueryType_Value string

const (
	BigQueryType_DOUBLE  BigQueryType_Value = "DOUBLE"
	BigQueryType_STRING  BigQueryType_Value = "STRING"
	BigQueryType_UNKNOWN BigQueryType_Value = "UNKNOWN"
)

// BigQueryType_Values returns all known variants of BigQueryType.
func BigQueryType_Values() []BigQueryType_Value {
	return []BigQueryType_Value{BigQueryType_DOUBLE, BigQueryType_STRING}
}

func New_BigQueryType(value BigQueryType_Value) BigQueryType {
	return BigQueryType{val: value}
}

// IsUnknown returns false for all known variants of BigQueryType and true otherwise.
func (e BigQueryType) IsUnknown() bool {
	switch e.val {
	case BigQueryType_DOUBLE, BigQueryType_STRING:
		return false
	}
	return true
}

func (e BigQueryType) Value() BigQueryType_Value {
	if e.IsUnknown() {
		return BigQueryType_UNKNOWN
	}
	return e.val
}

func (e BigQueryType) String() string {
	return string(e.val)
}

func (e BigQueryType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *BigQueryType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_BigQueryType(BigQueryType_Value(v))
	case "DOUBLE":
		*e = New_BigQueryType(BigQueryType_DOUBLE)
	case "STRING":
		*e = New_BigQueryType(BigQueryType_STRING)
	}
	return nil
}

type InfluxType struct {
	val InfluxType_Value
}

type InfluxType_Value string

const (
	InfluxType_BOOLEAN InfluxType_Value = "BOOLEAN"
	InfluxType_NUMERIC InfluxType_Value = "NUMERIC"
	InfluxType_STRING  InfluxType_Value = "STRING"
	InfluxType_UNKNOWN InfluxType_Value = "UNKNOWN"
)

// InfluxType_Values returns all known variants of InfluxType.
func InfluxType_Values() []InfluxType_Value {
	return []InfluxType_Value{InfluxType_BOOLEAN, InfluxType_NUMERIC, InfluxType_STRING}
}

func New_InfluxType(value InfluxType_Value) InfluxType {
	return InfluxType{val: value}
}

// IsUnknown returns false for all known variants of InfluxType and true otherwise.
func (e InfluxType) IsUnknown() bool {
	switch e.val {
	case InfluxType_BOOLEAN, InfluxType_NUMERIC, InfluxType_STRING:
		return false
	}
	return true
}

func (e InfluxType) Value() InfluxType_Value {
	if e.IsUnknown() {
		return InfluxType_UNKNOWN
	}
	return e.val
}

func (e InfluxType) String() string {
	return string(e.val)
}

func (e InfluxType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *InfluxType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_InfluxType(InfluxType_Value(v))
	case "BOOLEAN":
		*e = New_InfluxType(InfluxType_BOOLEAN)
	case "NUMERIC":
		*e = New_InfluxType(InfluxType_NUMERIC)
	case "STRING":
		*e = New_InfluxType(InfluxType_STRING)
	}
	return nil
}

type TimescaleType struct {
	val TimescaleType_Value
}

type TimescaleType_Value string

const (
	TimescaleType_BOOLEAN TimescaleType_Value = "BOOLEAN"
	TimescaleType_DOUBLE  TimescaleType_Value = "DOUBLE"
	TimescaleType_STRING  TimescaleType_Value = "STRING"
	TimescaleType_UNKNOWN TimescaleType_Value = "UNKNOWN"
)

// TimescaleType_Values returns all known variants of TimescaleType.
func TimescaleType_Values() []TimescaleType_Value {
	return []TimescaleType_Value{TimescaleType_BOOLEAN, TimescaleType_DOUBLE, TimescaleType_STRING}
}

func New_TimescaleType(value TimescaleType_Value) TimescaleType {
	return TimescaleType{val: value}
}

// IsUnknown returns false for all known variants of TimescaleType and true otherwise.
func (e TimescaleType) IsUnknown() bool {
	switch e.val {
	case TimescaleType_BOOLEAN, TimescaleType_DOUBLE, TimescaleType_STRING:
		return false
	}
	return true
}

func (e TimescaleType) Value() TimescaleType_Value {
	if e.IsUnknown() {
		return TimescaleType_UNKNOWN
	}
	return e.val
}

func (e TimescaleType) String() string {
	return string(e.val)
}

func (e TimescaleType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *TimescaleType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_TimescaleType(TimescaleType_Value(v))
	case "BOOLEAN":
		*e = New_TimescaleType(TimescaleType_BOOLEAN)
	case "DOUBLE":
		*e = New_TimescaleType(TimescaleType_DOUBLE)
	case "STRING":
		*e = New_TimescaleType(TimescaleType_STRING)
	}
	return nil
}

type TimestreamType struct {
	val TimestreamType_Value
}

type TimestreamType_Value string

const (
	TimestreamType_DOUBLE  TimestreamType_Value = "DOUBLE"
	TimestreamType_STRING  TimestreamType_Value = "STRING"
	TimestreamType_UNKNOWN TimestreamType_Value = "UNKNOWN"
)

// TimestreamType_Values returns all known variants of TimestreamType.
func TimestreamType_Values() []TimestreamType_Value {
	return []TimestreamType_Value{TimestreamType_DOUBLE, TimestreamType_STRING}
}

func New_TimestreamType(value TimestreamType_Value) TimestreamType {
	return TimestreamType{val: value}
}

// IsUnknown returns false for all known variants of TimestreamType and true otherwise.
func (e TimestreamType) IsUnknown() bool {
	switch e.val {
	case TimestreamType_DOUBLE, TimestreamType_STRING:
		return false
	}
	return true
}

func (e TimestreamType) Value() TimestreamType_Value {
	if e.IsUnknown() {
		return TimestreamType_UNKNOWN
	}
	return e.val
}

func (e TimestreamType) String() string {
	return string(e.val)
}

func (e TimestreamType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *TimestreamType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_TimestreamType(TimestreamType_Value(v))
	case "DOUBLE":
		*e = New_TimestreamType(TimestreamType_DOUBLE)
	case "STRING":
		*e = New_TimestreamType(TimestreamType_STRING)
	}
	return nil
}

type VisualCrossingEndpointUri struct {
	val VisualCrossingEndpointUri_Value
}

type VisualCrossingEndpointUri_Value string

const (
	VisualCrossingEndpointUri_HISTORY  VisualCrossingEndpointUri_Value = "HISTORY"
	VisualCrossingEndpointUri_TIMELINE VisualCrossingEndpointUri_Value = "TIMELINE"
	VisualCrossingEndpointUri_UNKNOWN  VisualCrossingEndpointUri_Value = "UNKNOWN"
)

// VisualCrossingEndpointUri_Values returns all known variants of VisualCrossingEndpointUri.
func VisualCrossingEndpointUri_Values() []VisualCrossingEndpointUri_Value {
	return []VisualCrossingEndpointUri_Value{VisualCrossingEndpointUri_HISTORY, VisualCrossingEndpointUri_TIMELINE}
}

func New_VisualCrossingEndpointUri(value VisualCrossingEndpointUri_Value) VisualCrossingEndpointUri {
	return VisualCrossingEndpointUri{val: value}
}

// IsUnknown returns false for all known variants of VisualCrossingEndpointUri and true otherwise.
func (e VisualCrossingEndpointUri) IsUnknown() bool {
	switch e.val {
	case VisualCrossingEndpointUri_HISTORY, VisualCrossingEndpointUri_TIMELINE:
		return false
	}
	return true
}

func (e VisualCrossingEndpointUri) Value() VisualCrossingEndpointUri_Value {
	if e.IsUnknown() {
		return VisualCrossingEndpointUri_UNKNOWN
	}
	return e.val
}

func (e VisualCrossingEndpointUri) String() string {
	return string(e.val)
}

func (e VisualCrossingEndpointUri) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *VisualCrossingEndpointUri) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_VisualCrossingEndpointUri(VisualCrossingEndpointUri_Value(v))
	case "HISTORY":
		*e = New_VisualCrossingEndpointUri(VisualCrossingEndpointUri_HISTORY)
	case "TIMELINE":
		*e = New_VisualCrossingEndpointUri(VisualCrossingEndpointUri_TIMELINE)
	}
	return nil
}

type VisualCrossingType struct {
	val VisualCrossingType_Value
}

type VisualCrossingType_Value string

const (
	VisualCrossingType_DOUBLE  VisualCrossingType_Value = "DOUBLE"
	VisualCrossingType_STRING  VisualCrossingType_Value = "STRING"
	VisualCrossingType_UNKNOWN VisualCrossingType_Value = "UNKNOWN"
)

// VisualCrossingType_Values returns all known variants of VisualCrossingType.
func VisualCrossingType_Values() []VisualCrossingType_Value {
	return []VisualCrossingType_Value{VisualCrossingType_DOUBLE, VisualCrossingType_STRING}
}

func New_VisualCrossingType(value VisualCrossingType_Value) VisualCrossingType {
	return VisualCrossingType{val: value}
}

// IsUnknown returns false for all known variants of VisualCrossingType and true otherwise.
func (e VisualCrossingType) IsUnknown() bool {
	switch e.val {
	case VisualCrossingType_DOUBLE, VisualCrossingType_STRING:
		return false
	}
	return true
}

func (e VisualCrossingType) Value() VisualCrossingType_Value {
	if e.IsUnknown() {
		return VisualCrossingType_UNKNOWN
	}
	return e.val
}

func (e VisualCrossingType) String() string {
	return string(e.val)
}

func (e VisualCrossingType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *VisualCrossingType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_VisualCrossingType(VisualCrossingType_Value(v))
	case "DOUBLE":
		*e = New_VisualCrossingType(VisualCrossingType_DOUBLE)
	case "STRING":
		*e = New_VisualCrossingType(VisualCrossingType_STRING)
	}
	return nil
}
