// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api/api/rids"
	"github.com/nominal-io/nominal-api/internal/conjureerrors"
	"github.com/nominal-io/nominal-api/io/nominal/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type dataSourcesNotFound struct {
	DataSourceRids []rids.DataSourceRid `json:"dataSourceRids"`
}

func (o dataSourcesNotFound) MarshalJSON() ([]byte, error) {
	if o.DataSourceRids == nil {
		o.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	type _tmpdataSourcesNotFound dataSourcesNotFound
	return safejson.Marshal(_tmpdataSourcesNotFound(o))
}

func (o *dataSourcesNotFound) UnmarshalJSON(data []byte) error {
	type _tmpdataSourcesNotFound dataSourcesNotFound
	var rawdataSourcesNotFound _tmpdataSourcesNotFound
	if err := safejson.Unmarshal(data, &rawdataSourcesNotFound); err != nil {
		return err
	}
	if rawdataSourcesNotFound.DataSourceRids == nil {
		rawdataSourcesNotFound.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	*o = dataSourcesNotFound(rawdataSourcesNotFound)
	return nil
}

func (o dataSourcesNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *dataSourcesNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDataSourcesNotFound returns new instance of DataSourcesNotFound error.
func NewDataSourcesNotFound(dataSourceRidsArg []rids.DataSourceRid) *DataSourcesNotFound {
	return &DataSourcesNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), dataSourcesNotFound: dataSourcesNotFound{DataSourceRids: dataSourceRidsArg}}
}

// WrapWithDataSourcesNotFound returns new instance of DataSourcesNotFound error wrapping an existing error.
func WrapWithDataSourcesNotFound(err error, dataSourceRidsArg []rids.DataSourceRid) *DataSourcesNotFound {
	return &DataSourcesNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, dataSourcesNotFound: dataSourcesNotFound{DataSourceRids: dataSourceRidsArg}}
}

// DataSourcesNotFound is an error type.
type DataSourcesNotFound struct {
	errorInstanceID uuid.UUID
	dataSourcesNotFound
	cause error
	stack werror.StackTrace
}

// IsDataSourcesNotFound returns true if err is an instance of DataSourcesNotFound.
func IsDataSourcesNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DataSourcesNotFound)
	return ok
}

func (e *DataSourcesNotFound) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT LogicalSeries:DataSourcesNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DataSourcesNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DataSourcesNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DataSourcesNotFound) Message() string {
	return "INVALID_ARGUMENT LogicalSeries:DataSourcesNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DataSourcesNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DataSourcesNotFound) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *DataSourcesNotFound) Name() string {
	return "LogicalSeries:DataSourcesNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DataSourcesNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DataSourcesNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DataSourcesNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DataSourcesNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DataSourcesNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DataSourcesNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DataSourcesNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.dataSourcesNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "LogicalSeries:DataSourcesNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DataSourcesNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters dataSourcesNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.dataSourcesNotFound = parameters
	return nil
}

type failedToCreateSeries struct {
	Message string `json:"message"`
}

func (o failedToCreateSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *failedToCreateSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewFailedToCreateSeries returns new instance of FailedToCreateSeries error.
func NewFailedToCreateSeries(messageArg string) *FailedToCreateSeries {
	return &FailedToCreateSeries{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), failedToCreateSeries: failedToCreateSeries{Message: messageArg}}
}

// WrapWithFailedToCreateSeries returns new instance of FailedToCreateSeries error wrapping an existing error.
func WrapWithFailedToCreateSeries(err error, messageArg string) *FailedToCreateSeries {
	return &FailedToCreateSeries{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, failedToCreateSeries: failedToCreateSeries{Message: messageArg}}
}

// FailedToCreateSeries is an error type.
type FailedToCreateSeries struct {
	errorInstanceID uuid.UUID
	failedToCreateSeries
	cause error
	stack werror.StackTrace
}

// IsFailedToCreateSeries returns true if err is an instance of FailedToCreateSeries.
func IsFailedToCreateSeries(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*FailedToCreateSeries)
	return ok
}

func (e *FailedToCreateSeries) Error() string {
	return fmt.Sprintf("INTERNAL LogicalSeries:FailedToCreateSeries (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *FailedToCreateSeries) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *FailedToCreateSeries) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *FailedToCreateSeries) Message() string {
	return "INTERNAL LogicalSeries:FailedToCreateSeries"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *FailedToCreateSeries) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *FailedToCreateSeries) Code() errors.ErrorCode {
	return errors.Internal
}

// Name returns an error name identifying error type.
func (e *FailedToCreateSeries) Name() string {
	return "LogicalSeries:FailedToCreateSeries"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *FailedToCreateSeries) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *FailedToCreateSeries) Parameters() map[string]interface{} {
	return map[string]interface{}{"message": e.Message}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *FailedToCreateSeries) safeParams() map[string]interface{} {
	return map[string]interface{}{"message": e.Message, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *FailedToCreateSeries) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *FailedToCreateSeries) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *FailedToCreateSeries) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e FailedToCreateSeries) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.failedToCreateSeries)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Internal, ErrorName: "LogicalSeries:FailedToCreateSeries", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *FailedToCreateSeries) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters failedToCreateSeries
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.failedToCreateSeries = parameters
	return nil
}

type invalidDataSources struct {
	DataSourceRids []rids.DataSourceRid `json:"dataSourceRids"`
}

func (o invalidDataSources) MarshalJSON() ([]byte, error) {
	if o.DataSourceRids == nil {
		o.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	type _tmpinvalidDataSources invalidDataSources
	return safejson.Marshal(_tmpinvalidDataSources(o))
}

func (o *invalidDataSources) UnmarshalJSON(data []byte) error {
	type _tmpinvalidDataSources invalidDataSources
	var rawinvalidDataSources _tmpinvalidDataSources
	if err := safejson.Unmarshal(data, &rawinvalidDataSources); err != nil {
		return err
	}
	if rawinvalidDataSources.DataSourceRids == nil {
		rawinvalidDataSources.DataSourceRids = make([]rids.DataSourceRid, 0)
	}
	*o = invalidDataSources(rawinvalidDataSources)
	return nil
}

func (o invalidDataSources) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidDataSources) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidDataSources returns new instance of InvalidDataSources error.
func NewInvalidDataSources(dataSourceRidsArg []rids.DataSourceRid) *InvalidDataSources {
	return &InvalidDataSources{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidDataSources: invalidDataSources{DataSourceRids: dataSourceRidsArg}}
}

// WrapWithInvalidDataSources returns new instance of InvalidDataSources error wrapping an existing error.
func WrapWithInvalidDataSources(err error, dataSourceRidsArg []rids.DataSourceRid) *InvalidDataSources {
	return &InvalidDataSources{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidDataSources: invalidDataSources{DataSourceRids: dataSourceRidsArg}}
}

// InvalidDataSources is an error type.
type InvalidDataSources struct {
	errorInstanceID uuid.UUID
	invalidDataSources
	cause error
	stack werror.StackTrace
}

// IsInvalidDataSources returns true if err is an instance of InvalidDataSources.
func IsInvalidDataSources(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidDataSources)
	return ok
}

func (e *InvalidDataSources) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT LogicalSeries:InvalidDataSources (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidDataSources) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidDataSources) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidDataSources) Message() string {
	return "INVALID_ARGUMENT LogicalSeries:InvalidDataSources"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidDataSources) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidDataSources) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidDataSources) Name() string {
	return "LogicalSeries:InvalidDataSources"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidDataSources) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidDataSources) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidDataSources) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidDataSources) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidDataSources) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidDataSources) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidDataSources) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidDataSources)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "LogicalSeries:InvalidDataSources", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidDataSources) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidDataSources
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidDataSources = parameters
	return nil
}

type logicalSeriesNotFound struct {
	Rids []api.LogicalSeriesRid `json:"rids"`
}

func (o logicalSeriesNotFound) MarshalJSON() ([]byte, error) {
	if o.Rids == nil {
		o.Rids = make([]api.LogicalSeriesRid, 0)
	}
	type _tmplogicalSeriesNotFound logicalSeriesNotFound
	return safejson.Marshal(_tmplogicalSeriesNotFound(o))
}

func (o *logicalSeriesNotFound) UnmarshalJSON(data []byte) error {
	type _tmplogicalSeriesNotFound logicalSeriesNotFound
	var rawlogicalSeriesNotFound _tmplogicalSeriesNotFound
	if err := safejson.Unmarshal(data, &rawlogicalSeriesNotFound); err != nil {
		return err
	}
	if rawlogicalSeriesNotFound.Rids == nil {
		rawlogicalSeriesNotFound.Rids = make([]api.LogicalSeriesRid, 0)
	}
	*o = logicalSeriesNotFound(rawlogicalSeriesNotFound)
	return nil
}

func (o logicalSeriesNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *logicalSeriesNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewLogicalSeriesNotFound returns new instance of LogicalSeriesNotFound error.
func NewLogicalSeriesNotFound(ridsArg []api.LogicalSeriesRid) *LogicalSeriesNotFound {
	return &LogicalSeriesNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), logicalSeriesNotFound: logicalSeriesNotFound{Rids: ridsArg}}
}

// WrapWithLogicalSeriesNotFound returns new instance of LogicalSeriesNotFound error wrapping an existing error.
func WrapWithLogicalSeriesNotFound(err error, ridsArg []api.LogicalSeriesRid) *LogicalSeriesNotFound {
	return &LogicalSeriesNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, logicalSeriesNotFound: logicalSeriesNotFound{Rids: ridsArg}}
}

// LogicalSeriesNotFound is an error type.
type LogicalSeriesNotFound struct {
	errorInstanceID uuid.UUID
	logicalSeriesNotFound
	cause error
	stack werror.StackTrace
}

// IsLogicalSeriesNotFound returns true if err is an instance of LogicalSeriesNotFound.
func IsLogicalSeriesNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*LogicalSeriesNotFound)
	return ok
}

func (e *LogicalSeriesNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND LogicalSeries:LogicalSeriesNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *LogicalSeriesNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *LogicalSeriesNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *LogicalSeriesNotFound) Message() string {
	return "NOT_FOUND LogicalSeries:LogicalSeriesNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *LogicalSeriesNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *LogicalSeriesNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *LogicalSeriesNotFound) Name() string {
	return "LogicalSeries:LogicalSeriesNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *LogicalSeriesNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *LogicalSeriesNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"rids": e.Rids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *LogicalSeriesNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"rids": e.Rids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *LogicalSeriesNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *LogicalSeriesNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *LogicalSeriesNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e LogicalSeriesNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.logicalSeriesNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "LogicalSeries:LogicalSeriesNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *LogicalSeriesNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters logicalSeriesNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.logicalSeriesNotFound = parameters
	return nil
}

type unableToResolve struct{}

func (o unableToResolve) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *unableToResolve) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUnableToResolve returns new instance of UnableToResolve error.
func NewUnableToResolve() *UnableToResolve {
	return &UnableToResolve{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), unableToResolve: unableToResolve{}}
}

// WrapWithUnableToResolve returns new instance of UnableToResolve error wrapping an existing error.
func WrapWithUnableToResolve(err error) *UnableToResolve {
	return &UnableToResolve{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, unableToResolve: unableToResolve{}}
}

// UnableToResolve is an error type.
type UnableToResolve struct {
	errorInstanceID uuid.UUID
	unableToResolve
	cause error
	stack werror.StackTrace
}

// IsUnableToResolve returns true if err is an instance of UnableToResolve.
func IsUnableToResolve(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*UnableToResolve)
	return ok
}

func (e *UnableToResolve) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT LogicalSeries:UnableToResolve (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *UnableToResolve) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *UnableToResolve) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *UnableToResolve) Message() string {
	return "INVALID_ARGUMENT LogicalSeries:UnableToResolve"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *UnableToResolve) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *UnableToResolve) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *UnableToResolve) Name() string {
	return "LogicalSeries:UnableToResolve"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *UnableToResolve) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *UnableToResolve) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *UnableToResolve) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnableToResolve) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *UnableToResolve) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *UnableToResolve) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e UnableToResolve) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.unableToResolve)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "LogicalSeries:UnableToResolve", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *UnableToResolve) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters unableToResolve
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.unableToResolve = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("LogicalSeries:DataSourcesNotFound", reflect.TypeOf(DataSourcesNotFound{}))
	conjureerrors.RegisterErrorType("LogicalSeries:FailedToCreateSeries", reflect.TypeOf(FailedToCreateSeries{}))
	conjureerrors.RegisterErrorType("LogicalSeries:InvalidDataSources", reflect.TypeOf(InvalidDataSources{}))
	conjureerrors.RegisterErrorType("LogicalSeries:LogicalSeriesNotFound", reflect.TypeOf(LogicalSeriesNotFound{}))
	conjureerrors.RegisterErrorType("LogicalSeries:UnableToResolve", reflect.TypeOf(UnableToResolve{}))
}
