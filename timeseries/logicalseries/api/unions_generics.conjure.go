// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/io/nominal/api"
)

type ContextPropertyWithT[T any] ContextProperty

func (u *ContextPropertyWithT[T]) Accept(ctx context.Context, v ContextPropertyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(ctx, *u.value)
	}
}

func (u *ContextPropertyWithT[T]) AcceptFuncs(valueFunc func(string) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "value":
		if u.value == nil {
			return result, fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *ContextPropertyWithT[T]) ValueNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *ContextPropertyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ContextPropertyVisitorWithT[T any] interface {
	VisitValue(ctx context.Context, v string) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type LocatorWithT[T any] Locator

func (u *LocatorWithT[T]) Accept(ctx context.Context, v LocatorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "timescaleDbLocator":
		if u.timescaleDbLocator == nil {
			return result, fmt.Errorf("field \"timescaleDbLocator\" is required")
		}
		return v.VisitTimescaleDbLocator(ctx, *u.timescaleDbLocator)
	case "influxLocator":
		if u.influxLocator == nil {
			return result, fmt.Errorf("field \"influxLocator\" is required")
		}
		return v.VisitInfluxLocator(ctx, *u.influxLocator)
	case "influx1Locator":
		if u.influx1Locator == nil {
			return result, fmt.Errorf("field \"influx1Locator\" is required")
		}
		return v.VisitInflux1Locator(ctx, *u.influx1Locator)
	case "nominalLocator":
		if u.nominalLocator == nil {
			return result, fmt.Errorf("field \"nominalLocator\" is required")
		}
		return v.VisitNominalLocator(ctx, *u.nominalLocator)
	case "timestreamLocator":
		if u.timestreamLocator == nil {
			return result, fmt.Errorf("field \"timestreamLocator\" is required")
		}
		return v.VisitTimestreamLocator(ctx, *u.timestreamLocator)
	case "visualCrossingLocator":
		if u.visualCrossingLocator == nil {
			return result, fmt.Errorf("field \"visualCrossingLocator\" is required")
		}
		return v.VisitVisualCrossingLocator(ctx, *u.visualCrossingLocator)
	case "bigQueryLocator":
		if u.bigQueryLocator == nil {
			return result, fmt.Errorf("field \"bigQueryLocator\" is required")
		}
		return v.VisitBigQueryLocator(ctx, *u.bigQueryLocator)
	case "apiLocator":
		if u.apiLocator == nil {
			return result, fmt.Errorf("field \"apiLocator\" is required")
		}
		return v.VisitApiLocator(ctx, *u.apiLocator)
	}
}

func (u *LocatorWithT[T]) AcceptFuncs(timescaleDbLocatorFunc func(TimescaleDbLocator) (T, error), influxLocatorFunc func(Influx2Locator) (T, error), influx1LocatorFunc func(Influx1Locator) (T, error), nominalLocatorFunc func(NominalLocator) (T, error), timestreamLocatorFunc func(TimestreamLocator) (T, error), visualCrossingLocatorFunc func(VisualCrossingLocator) (T, error), bigQueryLocatorFunc func(BigQueryLocator) (T, error), apiLocatorFunc func(ApiLocator) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timescaleDbLocator":
		if u.timescaleDbLocator == nil {
			return result, fmt.Errorf("field \"timescaleDbLocator\" is required")
		}
		return timescaleDbLocatorFunc(*u.timescaleDbLocator)
	case "influxLocator":
		if u.influxLocator == nil {
			return result, fmt.Errorf("field \"influxLocator\" is required")
		}
		return influxLocatorFunc(*u.influxLocator)
	case "influx1Locator":
		if u.influx1Locator == nil {
			return result, fmt.Errorf("field \"influx1Locator\" is required")
		}
		return influx1LocatorFunc(*u.influx1Locator)
	case "nominalLocator":
		if u.nominalLocator == nil {
			return result, fmt.Errorf("field \"nominalLocator\" is required")
		}
		return nominalLocatorFunc(*u.nominalLocator)
	case "timestreamLocator":
		if u.timestreamLocator == nil {
			return result, fmt.Errorf("field \"timestreamLocator\" is required")
		}
		return timestreamLocatorFunc(*u.timestreamLocator)
	case "visualCrossingLocator":
		if u.visualCrossingLocator == nil {
			return result, fmt.Errorf("field \"visualCrossingLocator\" is required")
		}
		return visualCrossingLocatorFunc(*u.visualCrossingLocator)
	case "bigQueryLocator":
		if u.bigQueryLocator == nil {
			return result, fmt.Errorf("field \"bigQueryLocator\" is required")
		}
		return bigQueryLocatorFunc(*u.bigQueryLocator)
	case "apiLocator":
		if u.apiLocator == nil {
			return result, fmt.Errorf("field \"apiLocator\" is required")
		}
		return apiLocatorFunc(*u.apiLocator)
	}
}

func (u *LocatorWithT[T]) TimescaleDbLocatorNoopSuccess(TimescaleDbLocator) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorWithT[T]) InfluxLocatorNoopSuccess(Influx2Locator) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorWithT[T]) Influx1LocatorNoopSuccess(Influx1Locator) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorWithT[T]) NominalLocatorNoopSuccess(NominalLocator) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorWithT[T]) TimestreamLocatorNoopSuccess(TimestreamLocator) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorWithT[T]) VisualCrossingLocatorNoopSuccess(VisualCrossingLocator) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorWithT[T]) BigQueryLocatorNoopSuccess(BigQueryLocator) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorWithT[T]) ApiLocatorNoopSuccess(ApiLocator) (T, error) {
	var result T
	return result, nil
}

func (u *LocatorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type LocatorVisitorWithT[T any] interface {
	VisitTimescaleDbLocator(ctx context.Context, v TimescaleDbLocator) (T, error)
	VisitInfluxLocator(ctx context.Context, v Influx2Locator) (T, error)
	VisitInflux1Locator(ctx context.Context, v Influx1Locator) (T, error)
	VisitNominalLocator(ctx context.Context, v NominalLocator) (T, error)
	VisitTimestreamLocator(ctx context.Context, v TimestreamLocator) (T, error)
	VisitVisualCrossingLocator(ctx context.Context, v VisualCrossingLocator) (T, error)
	VisitBigQueryLocator(ctx context.Context, v BigQueryLocator) (T, error)
	VisitApiLocator(ctx context.Context, v ApiLocator) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ResolveSeriesResponseWithT[T any] ResolveSeriesResponse

func (u *ResolveSeriesResponseWithT[T]) Accept(ctx context.Context, v ResolveSeriesResponseVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "rid":
		if u.rid == nil {
			return result, fmt.Errorf("field \"rid\" is required")
		}
		return v.VisitRid(ctx, *u.rid)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(ctx, *u.error)
	}
}

func (u *ResolveSeriesResponseWithT[T]) AcceptFuncs(ridFunc func(api.LogicalSeriesRid) (T, error), errorFunc func(ResolveSeriesError) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "rid":
		if u.rid == nil {
			return result, fmt.Errorf("field \"rid\" is required")
		}
		return ridFunc(*u.rid)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *ResolveSeriesResponseWithT[T]) RidNoopSuccess(api.LogicalSeriesRid) (T, error) {
	var result T
	return result, nil
}

func (u *ResolveSeriesResponseWithT[T]) ErrorNoopSuccess(ResolveSeriesError) (T, error) {
	var result T
	return result, nil
}

func (u *ResolveSeriesResponseWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ResolveSeriesResponseVisitorWithT[T any] interface {
	VisitRid(ctx context.Context, v api.LogicalSeriesRid) (T, error)
	VisitError(ctx context.Context, v ResolveSeriesError) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type UnitUpdateWithT[T any] UnitUpdate

func (u *UnitUpdateWithT[T]) Accept(ctx context.Context, v UnitUpdateVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "unit":
		if u.unit == nil {
			return result, fmt.Errorf("field \"unit\" is required")
		}
		return v.VisitUnit(ctx, *u.unit)
	case "clearUnit":
		if u.clearUnit == nil {
			return result, fmt.Errorf("field \"clearUnit\" is required")
		}
		return v.VisitClearUnit(ctx, *u.clearUnit)
	}
}

func (u *UnitUpdateWithT[T]) AcceptFuncs(unitFunc func(api.Unit) (T, error), clearUnitFunc func(api.Empty) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "unit":
		if u.unit == nil {
			return result, fmt.Errorf("field \"unit\" is required")
		}
		return unitFunc(*u.unit)
	case "clearUnit":
		if u.clearUnit == nil {
			return result, fmt.Errorf("field \"clearUnit\" is required")
		}
		return clearUnitFunc(*u.clearUnit)
	}
}

func (u *UnitUpdateWithT[T]) UnitNoopSuccess(api.Unit) (T, error) {
	var result T
	return result, nil
}

func (u *UnitUpdateWithT[T]) ClearUnitNoopSuccess(api.Empty) (T, error) {
	var result T
	return result, nil
}

func (u *UnitUpdateWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type UnitUpdateVisitorWithT[T any] interface {
	VisitUnit(ctx context.Context, v api.Unit) (T, error)
	VisitClearUnit(ctx context.Context, v api.Empty) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
