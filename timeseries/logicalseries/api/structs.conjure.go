// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	api1 "github.com/nominal-io/nominal-api-go/storage/series/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
)

type ApiLocator struct {
	Channel api.Channel                  `json:"channel"`
	Tags    map[api.TagName]api.TagValue `json:"tags"`
	Type    ApiType                      `json:"type"`
}

func (o ApiLocator) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpApiLocator ApiLocator
	return safejson.Marshal(_tmpApiLocator(o))
}

func (o *ApiLocator) UnmarshalJSON(data []byte) error {
	type _tmpApiLocator ApiLocator
	var rawApiLocator _tmpApiLocator
	if err := safejson.Unmarshal(data, &rawApiLocator); err != nil {
		return err
	}
	if rawApiLocator.Tags == nil {
		rawApiLocator.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	*o = ApiLocator(rawApiLocator)
	return nil
}

func (o ApiLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ApiLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchCreateLogicalSeriesRequest struct {
	Requests []CreateLogicalSeries `json:"requests"`
}

func (o BatchCreateLogicalSeriesRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]CreateLogicalSeries, 0)
	}
	type _tmpBatchCreateLogicalSeriesRequest BatchCreateLogicalSeriesRequest
	return safejson.Marshal(_tmpBatchCreateLogicalSeriesRequest(o))
}

func (o *BatchCreateLogicalSeriesRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchCreateLogicalSeriesRequest BatchCreateLogicalSeriesRequest
	var rawBatchCreateLogicalSeriesRequest _tmpBatchCreateLogicalSeriesRequest
	if err := safejson.Unmarshal(data, &rawBatchCreateLogicalSeriesRequest); err != nil {
		return err
	}
	if rawBatchCreateLogicalSeriesRequest.Requests == nil {
		rawBatchCreateLogicalSeriesRequest.Requests = make([]CreateLogicalSeries, 0)
	}
	*o = BatchCreateLogicalSeriesRequest(rawBatchCreateLogicalSeriesRequest)
	return nil
}

func (o BatchCreateLogicalSeriesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchCreateLogicalSeriesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchCreateLogicalSeriesResponse struct {
	Responses []LogicalSeries `json:"responses"`
}

func (o BatchCreateLogicalSeriesResponse) MarshalJSON() ([]byte, error) {
	if o.Responses == nil {
		o.Responses = make([]LogicalSeries, 0)
	}
	type _tmpBatchCreateLogicalSeriesResponse BatchCreateLogicalSeriesResponse
	return safejson.Marshal(_tmpBatchCreateLogicalSeriesResponse(o))
}

func (o *BatchCreateLogicalSeriesResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchCreateLogicalSeriesResponse BatchCreateLogicalSeriesResponse
	var rawBatchCreateLogicalSeriesResponse _tmpBatchCreateLogicalSeriesResponse
	if err := safejson.Unmarshal(data, &rawBatchCreateLogicalSeriesResponse); err != nil {
		return err
	}
	if rawBatchCreateLogicalSeriesResponse.Responses == nil {
		rawBatchCreateLogicalSeriesResponse.Responses = make([]LogicalSeries, 0)
	}
	*o = BatchCreateLogicalSeriesResponse(rawBatchCreateLogicalSeriesResponse)
	return nil
}

func (o BatchCreateLogicalSeriesResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchCreateLogicalSeriesResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchResolveSeriesRequest struct {
	Requests []ResolveSeriesRequest `json:"requests"`
}

func (o BatchResolveSeriesRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]ResolveSeriesRequest, 0)
	}
	type _tmpBatchResolveSeriesRequest BatchResolveSeriesRequest
	return safejson.Marshal(_tmpBatchResolveSeriesRequest(o))
}

func (o *BatchResolveSeriesRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchResolveSeriesRequest BatchResolveSeriesRequest
	var rawBatchResolveSeriesRequest _tmpBatchResolveSeriesRequest
	if err := safejson.Unmarshal(data, &rawBatchResolveSeriesRequest); err != nil {
		return err
	}
	if rawBatchResolveSeriesRequest.Requests == nil {
		rawBatchResolveSeriesRequest.Requests = make([]ResolveSeriesRequest, 0)
	}
	*o = BatchResolveSeriesRequest(rawBatchResolveSeriesRequest)
	return nil
}

func (o BatchResolveSeriesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchResolveSeriesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchResolveSeriesResponse struct {
	Series []ResolveSeriesResponse `json:"series"`
}

func (o BatchResolveSeriesResponse) MarshalJSON() ([]byte, error) {
	if o.Series == nil {
		o.Series = make([]ResolveSeriesResponse, 0)
	}
	type _tmpBatchResolveSeriesResponse BatchResolveSeriesResponse
	return safejson.Marshal(_tmpBatchResolveSeriesResponse(o))
}

func (o *BatchResolveSeriesResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchResolveSeriesResponse BatchResolveSeriesResponse
	var rawBatchResolveSeriesResponse _tmpBatchResolveSeriesResponse
	if err := safejson.Unmarshal(data, &rawBatchResolveSeriesResponse); err != nil {
		return err
	}
	if rawBatchResolveSeriesResponse.Series == nil {
		rawBatchResolveSeriesResponse.Series = make([]ResolveSeriesResponse, 0)
	}
	*o = BatchResolveSeriesResponse(rawBatchResolveSeriesResponse)
	return nil
}

func (o BatchResolveSeriesResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchResolveSeriesResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchUpdateLogicalSeriesRequest struct {
	Requests []UpdateLogicalSeries `json:"requests"`
}

func (o BatchUpdateLogicalSeriesRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]UpdateLogicalSeries, 0)
	}
	type _tmpBatchUpdateLogicalSeriesRequest BatchUpdateLogicalSeriesRequest
	return safejson.Marshal(_tmpBatchUpdateLogicalSeriesRequest(o))
}

func (o *BatchUpdateLogicalSeriesRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchUpdateLogicalSeriesRequest BatchUpdateLogicalSeriesRequest
	var rawBatchUpdateLogicalSeriesRequest _tmpBatchUpdateLogicalSeriesRequest
	if err := safejson.Unmarshal(data, &rawBatchUpdateLogicalSeriesRequest); err != nil {
		return err
	}
	if rawBatchUpdateLogicalSeriesRequest.Requests == nil {
		rawBatchUpdateLogicalSeriesRequest.Requests = make([]UpdateLogicalSeries, 0)
	}
	*o = BatchUpdateLogicalSeriesRequest(rawBatchUpdateLogicalSeriesRequest)
	return nil
}

func (o BatchUpdateLogicalSeriesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchUpdateLogicalSeriesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchUpdateLogicalSeriesResponse struct {
	Responses []LogicalSeries `json:"responses"`
}

func (o BatchUpdateLogicalSeriesResponse) MarshalJSON() ([]byte, error) {
	if o.Responses == nil {
		o.Responses = make([]LogicalSeries, 0)
	}
	type _tmpBatchUpdateLogicalSeriesResponse BatchUpdateLogicalSeriesResponse
	return safejson.Marshal(_tmpBatchUpdateLogicalSeriesResponse(o))
}

func (o *BatchUpdateLogicalSeriesResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchUpdateLogicalSeriesResponse BatchUpdateLogicalSeriesResponse
	var rawBatchUpdateLogicalSeriesResponse _tmpBatchUpdateLogicalSeriesResponse
	if err := safejson.Unmarshal(data, &rawBatchUpdateLogicalSeriesResponse); err != nil {
		return err
	}
	if rawBatchUpdateLogicalSeriesResponse.Responses == nil {
		rawBatchUpdateLogicalSeriesResponse.Responses = make([]LogicalSeries, 0)
	}
	*o = BatchUpdateLogicalSeriesResponse(rawBatchUpdateLogicalSeriesResponse)
	return nil
}

func (o BatchUpdateLogicalSeriesResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchUpdateLogicalSeriesResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BigQueryLocator struct {
	// The name of the column which has the values for this series
	ValueColumn ColumnName `conjure-docs:"The name of the column which has the values for this series" json:"valueColumn"`
	// The name of the column which has the timestamps for this series
	TimeColumn ColumnName `conjure-docs:"The name of the column which has the timestamps for this series" json:"timeColumn"`
	// The mapping of columns to column values to filter on
	TagValues map[api.TagName]api.TagValue `conjure-docs:"The mapping of columns to column values to filter on" json:"tagValues"`
	Type      BigQueryType                 `json:"type"`
}

func (o BigQueryLocator) MarshalJSON() ([]byte, error) {
	if o.TagValues == nil {
		o.TagValues = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpBigQueryLocator BigQueryLocator
	return safejson.Marshal(_tmpBigQueryLocator(o))
}

func (o *BigQueryLocator) UnmarshalJSON(data []byte) error {
	type _tmpBigQueryLocator BigQueryLocator
	var rawBigQueryLocator _tmpBigQueryLocator
	if err := safejson.Unmarshal(data, &rawBigQueryLocator); err != nil {
		return err
	}
	if rawBigQueryLocator.TagValues == nil {
		rawBigQueryLocator.TagValues = make(map[api.TagName]api.TagValue, 0)
	}
	*o = BigQueryLocator(rawBigQueryLocator)
	return nil
}

func (o BigQueryLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BigQueryLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Context struct {
	Properties map[string]ContextProperty `json:"properties"`
}

func (o Context) MarshalJSON() ([]byte, error) {
	if o.Properties == nil {
		o.Properties = make(map[string]ContextProperty, 0)
	}
	type _tmpContext Context
	return safejson.Marshal(_tmpContext(o))
}

func (o *Context) UnmarshalJSON(data []byte) error {
	type _tmpContext Context
	var rawContext _tmpContext
	if err := safejson.Unmarshal(data, &rawContext); err != nil {
		return err
	}
	if rawContext.Properties == nil {
		rawContext.Properties = make(map[string]ContextProperty, 0)
	}
	*o = Context(rawContext)
	return nil
}

func (o Context) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Context) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateLogicalSeries struct {
	Channel api.Channel `json:"channel"`
	Locator Locator     `json:"locator"`
	/*
	   If present, will be used as the locator of the LogicalSeriesRid. If a logical series already exists
	   with this id, will throw a CONFLICT.
	*/
	IdLocator      *uuid.UUID          `conjure-docs:"If present, will be used as the locator of the LogicalSeriesRid. If a logical series already exists\nwith this id, will throw a CONFLICT." json:"idLocator,omitempty"`
	DataSourceRid  rids.DataSourceRid  `json:"dataSourceRid"`
	Description    *string             `json:"description,omitempty"`
	Unit           *api.Unit           `json:"unit,omitempty"`
	SeriesDataType *api.SeriesDataType `json:"seriesDataType,omitempty"`
	Granularity    *api.Granularity    `json:"granularity,omitempty"`
	// Deprecated. Do not use.
	SeriesArchetypeRid *api.SeriesArchetypeRid `conjure-docs:"Deprecated. Do not use." json:"seriesArchetypeRid,omitempty"`
}

func (o CreateLogicalSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateLogicalSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Influx1Locator struct {
	Database    DatabaseName                 `json:"database"`
	Measurement MeasurementName              `json:"measurement"`
	Field       FieldName                    `json:"field"`
	Tags        map[api.TagName]api.TagValue `json:"tags"`
	Type        InfluxType                   `json:"type"`
}

func (o Influx1Locator) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpInflux1Locator Influx1Locator
	return safejson.Marshal(_tmpInflux1Locator(o))
}

func (o *Influx1Locator) UnmarshalJSON(data []byte) error {
	type _tmpInflux1Locator Influx1Locator
	var rawInflux1Locator _tmpInflux1Locator
	if err := safejson.Unmarshal(data, &rawInflux1Locator); err != nil {
		return err
	}
	if rawInflux1Locator.Tags == nil {
		rawInflux1Locator.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	*o = Influx1Locator(rawInflux1Locator)
	return nil
}

func (o Influx1Locator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Influx1Locator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Influx2Locator struct {
	Bucket      BucketName      `json:"bucket"`
	Measurement MeasurementName `json:"measurement"`
	Field       FieldName       `json:"field"`
	// If omitted, defaults to `_value`. Can be used to extract tag values.
	ValueColumn *string                      `conjure-docs:"If omitted, defaults to \"_value\". Can be used to extract tag values." json:"valueColumn,omitempty"`
	Tags        map[api.TagName]api.TagValue `json:"tags"`
	Type        InfluxType                   `json:"type"`
}

func (o Influx2Locator) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpInflux2Locator Influx2Locator
	return safejson.Marshal(_tmpInflux2Locator(o))
}

func (o *Influx2Locator) UnmarshalJSON(data []byte) error {
	type _tmpInflux2Locator Influx2Locator
	var rawInflux2Locator _tmpInflux2Locator
	if err := safejson.Unmarshal(data, &rawInflux2Locator); err != nil {
		return err
	}
	if rawInflux2Locator.Tags == nil {
		rawInflux2Locator.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	*o = Influx2Locator(rawInflux2Locator)
	return nil
}

func (o Influx2Locator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Influx2Locator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type LogicalSeries struct {
	Rid           api.LogicalSeriesRid `json:"rid"`
	DataSourceRid rids.DataSourceRid   `json:"dataSourceRid"`
	Locator       Locator              `json:"locator"`
	// Only required to be present for legacy CSVs.
	TimeLocator    *Locator            `conjure-docs:"Only required to be present for legacy CSVs." json:"timeLocator,omitempty"`
	Channel        api.Channel         `json:"channel"`
	Description    *string             `json:"description,omitempty"`
	Unit           *api.Unit           `json:"unit,omitempty"`
	SeriesDataType *api.SeriesDataType `json:"seriesDataType,omitempty"`
	/*
	   Time granularity of the series. If omitted, defaults to nanoseconds.

	   Deprecated: The source of truth for granularity comes from the data source of the logical series.
	*/
	Granularity *api.Granularity `conjure-docs:"Time granularity of the series. If omitted, defaults to nanoseconds." json:"granularity,omitempty"`
}

func (o LogicalSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LogicalSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type NominalLocator struct {
	Channel api.Channel                  `json:"channel"`
	Tags    map[api.TagName]api.TagValue `json:"tags"`
	Type    api1.NominalDataType         `json:"type"`
}

func (o NominalLocator) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpNominalLocator NominalLocator
	return safejson.Marshal(_tmpNominalLocator(o))
}

func (o *NominalLocator) UnmarshalJSON(data []byte) error {
	type _tmpNominalLocator NominalLocator
	var rawNominalLocator _tmpNominalLocator
	if err := safejson.Unmarshal(data, &rawNominalLocator); err != nil {
		return err
	}
	if rawNominalLocator.Tags == nil {
		rawNominalLocator.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	*o = NominalLocator(rawNominalLocator)
	return nil
}

func (o NominalLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *NominalLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ResolveSeriesError struct {
	Message string            `json:"message"`
	Args    map[string]string `json:"args"`
}

func (o ResolveSeriesError) MarshalJSON() ([]byte, error) {
	if o.Args == nil {
		o.Args = make(map[string]string, 0)
	}
	type _tmpResolveSeriesError ResolveSeriesError
	return safejson.Marshal(_tmpResolveSeriesError(o))
}

func (o *ResolveSeriesError) UnmarshalJSON(data []byte) error {
	type _tmpResolveSeriesError ResolveSeriesError
	var rawResolveSeriesError _tmpResolveSeriesError
	if err := safejson.Unmarshal(data, &rawResolveSeriesError); err != nil {
		return err
	}
	if rawResolveSeriesError.Args == nil {
		rawResolveSeriesError.Args = make(map[string]string, 0)
	}
	*o = ResolveSeriesError(rawResolveSeriesError)
	return nil
}

func (o ResolveSeriesError) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ResolveSeriesError) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ResolveSeriesRequest struct {
	Name       api.Channel                  `json:"name"`
	Datasource rids.DataSourceRid           `json:"datasource"`
	Tags       map[api.TagName]api.TagValue `json:"tags"`
}

func (o ResolveSeriesRequest) MarshalJSON() ([]byte, error) {
	if o.Tags == nil {
		o.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpResolveSeriesRequest ResolveSeriesRequest
	return safejson.Marshal(_tmpResolveSeriesRequest(o))
}

func (o *ResolveSeriesRequest) UnmarshalJSON(data []byte) error {
	type _tmpResolveSeriesRequest ResolveSeriesRequest
	var rawResolveSeriesRequest _tmpResolveSeriesRequest
	if err := safejson.Unmarshal(data, &rawResolveSeriesRequest); err != nil {
		return err
	}
	if rawResolveSeriesRequest.Tags == nil {
		rawResolveSeriesRequest.Tags = make(map[api.TagName]api.TagValue, 0)
	}
	*o = ResolveSeriesRequest(rawResolveSeriesRequest)
	return nil
}

func (o ResolveSeriesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ResolveSeriesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimescaleDbLocator struct {
	Table      TableName                    `json:"table"`
	Schema     SchemaName                   `json:"schema"`
	Column     ColumnName                   `json:"column"`
	TimeColumn ColumnName                   `json:"timeColumn"`
	Dimensions map[api.TagName]api.TagValue `json:"dimensions"`
	Type       TimescaleType                `json:"type"`
}

func (o TimescaleDbLocator) MarshalJSON() ([]byte, error) {
	if o.Dimensions == nil {
		o.Dimensions = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpTimescaleDbLocator TimescaleDbLocator
	return safejson.Marshal(_tmpTimescaleDbLocator(o))
}

func (o *TimescaleDbLocator) UnmarshalJSON(data []byte) error {
	type _tmpTimescaleDbLocator TimescaleDbLocator
	var rawTimescaleDbLocator _tmpTimescaleDbLocator
	if err := safejson.Unmarshal(data, &rawTimescaleDbLocator); err != nil {
		return err
	}
	if rawTimescaleDbLocator.Dimensions == nil {
		rawTimescaleDbLocator.Dimensions = make(map[api.TagName]api.TagValue, 0)
	}
	*o = TimescaleDbLocator(rawTimescaleDbLocator)
	return nil
}

func (o TimescaleDbLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimescaleDbLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type TimestreamLocator struct {
	Table      TableName                    `json:"table"`
	Dimensions map[api.TagName]api.TagValue `json:"dimensions"`
	Measure    MeasureName                  `json:"measure"`
	// If present, will be the attribute within the measurement for multi-measures.
	Attribute *AttributeName `conjure-docs:"If present, will be the attribute within the measurement for multi-measures." json:"attribute,omitempty"`
	Type      TimestreamType `json:"type"`
}

func (o TimestreamLocator) MarshalJSON() ([]byte, error) {
	if o.Dimensions == nil {
		o.Dimensions = make(map[api.TagName]api.TagValue, 0)
	}
	type _tmpTimestreamLocator TimestreamLocator
	return safejson.Marshal(_tmpTimestreamLocator(o))
}

func (o *TimestreamLocator) UnmarshalJSON(data []byte) error {
	type _tmpTimestreamLocator TimestreamLocator
	var rawTimestreamLocator _tmpTimestreamLocator
	if err := safejson.Unmarshal(data, &rawTimestreamLocator); err != nil {
		return err
	}
	if rawTimestreamLocator.Dimensions == nil {
		rawTimestreamLocator.Dimensions = make(map[api.TagName]api.TagValue, 0)
	}
	*o = TimestreamLocator(rawTimestreamLocator)
	return nil
}

func (o TimestreamLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TimestreamLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateLogicalSeries struct {
	LogicalSeriesRid api.LogicalSeriesRid `json:"logicalSeriesRid"`
	Description      *string              `json:"description,omitempty"`
	// Deprecated: Deprecated. Use unitUpdate instead.
	Unit       *api.Unit   `json:"unit,omitempty"`
	UnitUpdate *UnitUpdate `json:"unitUpdate,omitempty"`
}

func (o UpdateLogicalSeries) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateLogicalSeries) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type VisualCrossingLocator struct {
	/*
	   Location to fetch data from.  Can be any arbitrary string (i.e. name, abbreviation,
	   zip code, lat/long, etc.) as remote endpoint performs location resolution.
	*/
	Location LocationName `conjure-docs:"Location to fetch data from.  Can be any arbitrary string (i.e. name, abbreviation,\nzip code, lat/long, etc.) as remote endpoint performs location resolution." json:"location"`
	// Defaults to HISTORY.  Endpoint to fetch data from for this series.
	Endpoint *VisualCrossingEndpointUri `conjure-docs:"Defaults to HISTORY.  Endpoint to fetch data from for this series." json:"endpoint,omitempty"`
	Field    FieldName                  `json:"field"`
	Type     VisualCrossingType         `json:"type"`
}

func (o VisualCrossingLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *VisualCrossingLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
