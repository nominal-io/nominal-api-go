// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type ContextProperty struct {
	typ   string
	value *string
}

type contextPropertyDeserializer struct {
	Type  string  `json:"type"`
	Value *string `json:"value"`
}

func (u *contextPropertyDeserializer) toStruct() ContextProperty {
	return ContextProperty{typ: u.Type, value: u.Value}
}

func (u *ContextProperty) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "value":
		if u.value == nil {
			return nil, fmt.Errorf("field \"value\" is required")
		}
		return struct {
			Type  string `json:"type"`
			Value string `json:"value"`
		}{Type: "value", Value: *u.value}, nil
	}
}

func (u ContextProperty) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ContextProperty) UnmarshalJSON(data []byte) error {
	var deser contextPropertyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
	}
	return nil
}

func (u ContextProperty) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ContextProperty) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ContextProperty) AcceptFuncs(valueFunc func(string) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return valueFunc(*u.value)
	}
}

func (u *ContextProperty) ValueNoopSuccess(string) error {
	return nil
}

func (u *ContextProperty) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ContextProperty) Accept(v ContextPropertyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValue(*u.value)
	}
}

type ContextPropertyVisitor interface {
	VisitValue(v string) error
	VisitUnknown(typeName string) error
}

func (u *ContextProperty) AcceptWithContext(ctx context.Context, v ContextPropertyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "value":
		if u.value == nil {
			return fmt.Errorf("field \"value\" is required")
		}
		return v.VisitValueWithContext(ctx, *u.value)
	}
}

type ContextPropertyVisitorWithContext interface {
	VisitValueWithContext(ctx context.Context, v string) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewContextPropertyFromValue(v string) ContextProperty {
	return ContextProperty{typ: "value", value: &v}
}

type Locator struct {
	typ                   string
	timescaleDbLocator    *TimescaleDbLocator
	influxLocator         *Influx2Locator
	influx1Locator        *Influx1Locator
	nominalLocator        *NominalLocator
	timestreamLocator     *TimestreamLocator
	visualCrossingLocator *VisualCrossingLocator
	bigQueryLocator       *BigQueryLocator
	apiLocator            *ApiLocator
}

type locatorDeserializer struct {
	Type                  string                 `json:"type"`
	TimescaleDbLocator    *TimescaleDbLocator    `json:"timescaleDbLocator"`
	InfluxLocator         *Influx2Locator        `json:"influxLocator"`
	Influx1Locator        *Influx1Locator        `json:"influx1Locator"`
	NominalLocator        *NominalLocator        `json:"nominalLocator"`
	TimestreamLocator     *TimestreamLocator     `json:"timestreamLocator"`
	VisualCrossingLocator *VisualCrossingLocator `json:"visualCrossingLocator"`
	BigQueryLocator       *BigQueryLocator       `json:"bigQueryLocator"`
	ApiLocator            *ApiLocator            `json:"apiLocator"`
}

func (u *locatorDeserializer) toStruct() Locator {
	return Locator{typ: u.Type, timescaleDbLocator: u.TimescaleDbLocator, influxLocator: u.InfluxLocator, influx1Locator: u.Influx1Locator, nominalLocator: u.NominalLocator, timestreamLocator: u.TimestreamLocator, visualCrossingLocator: u.VisualCrossingLocator, bigQueryLocator: u.BigQueryLocator, apiLocator: u.ApiLocator}
}

func (u *Locator) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "timescaleDbLocator":
		if u.timescaleDbLocator == nil {
			return nil, fmt.Errorf("field \"timescaleDbLocator\" is required")
		}
		return struct {
			Type               string             `json:"type"`
			TimescaleDbLocator TimescaleDbLocator `json:"timescaleDbLocator"`
		}{Type: "timescaleDbLocator", TimescaleDbLocator: *u.timescaleDbLocator}, nil
	case "influxLocator":
		if u.influxLocator == nil {
			return nil, fmt.Errorf("field \"influxLocator\" is required")
		}
		return struct {
			Type          string         `json:"type"`
			InfluxLocator Influx2Locator `json:"influxLocator"`
		}{Type: "influxLocator", InfluxLocator: *u.influxLocator}, nil
	case "influx1Locator":
		if u.influx1Locator == nil {
			return nil, fmt.Errorf("field \"influx1Locator\" is required")
		}
		return struct {
			Type           string         `json:"type"`
			Influx1Locator Influx1Locator `json:"influx1Locator"`
		}{Type: "influx1Locator", Influx1Locator: *u.influx1Locator}, nil
	case "nominalLocator":
		if u.nominalLocator == nil {
			return nil, fmt.Errorf("field \"nominalLocator\" is required")
		}
		return struct {
			Type           string         `json:"type"`
			NominalLocator NominalLocator `json:"nominalLocator"`
		}{Type: "nominalLocator", NominalLocator: *u.nominalLocator}, nil
	case "timestreamLocator":
		if u.timestreamLocator == nil {
			return nil, fmt.Errorf("field \"timestreamLocator\" is required")
		}
		return struct {
			Type              string            `json:"type"`
			TimestreamLocator TimestreamLocator `json:"timestreamLocator"`
		}{Type: "timestreamLocator", TimestreamLocator: *u.timestreamLocator}, nil
	case "visualCrossingLocator":
		if u.visualCrossingLocator == nil {
			return nil, fmt.Errorf("field \"visualCrossingLocator\" is required")
		}
		return struct {
			Type                  string                `json:"type"`
			VisualCrossingLocator VisualCrossingLocator `json:"visualCrossingLocator"`
		}{Type: "visualCrossingLocator", VisualCrossingLocator: *u.visualCrossingLocator}, nil
	case "bigQueryLocator":
		if u.bigQueryLocator == nil {
			return nil, fmt.Errorf("field \"bigQueryLocator\" is required")
		}
		return struct {
			Type            string          `json:"type"`
			BigQueryLocator BigQueryLocator `json:"bigQueryLocator"`
		}{Type: "bigQueryLocator", BigQueryLocator: *u.bigQueryLocator}, nil
	case "apiLocator":
		if u.apiLocator == nil {
			return nil, fmt.Errorf("field \"apiLocator\" is required")
		}
		return struct {
			Type       string     `json:"type"`
			ApiLocator ApiLocator `json:"apiLocator"`
		}{Type: "apiLocator", ApiLocator: *u.apiLocator}, nil
	}
}

func (u Locator) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Locator) UnmarshalJSON(data []byte) error {
	var deser locatorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "timescaleDbLocator":
		if u.timescaleDbLocator == nil {
			return fmt.Errorf("field \"timescaleDbLocator\" is required")
		}
	case "influxLocator":
		if u.influxLocator == nil {
			return fmt.Errorf("field \"influxLocator\" is required")
		}
	case "influx1Locator":
		if u.influx1Locator == nil {
			return fmt.Errorf("field \"influx1Locator\" is required")
		}
	case "nominalLocator":
		if u.nominalLocator == nil {
			return fmt.Errorf("field \"nominalLocator\" is required")
		}
	case "timestreamLocator":
		if u.timestreamLocator == nil {
			return fmt.Errorf("field \"timestreamLocator\" is required")
		}
	case "visualCrossingLocator":
		if u.visualCrossingLocator == nil {
			return fmt.Errorf("field \"visualCrossingLocator\" is required")
		}
	case "bigQueryLocator":
		if u.bigQueryLocator == nil {
			return fmt.Errorf("field \"bigQueryLocator\" is required")
		}
	case "apiLocator":
		if u.apiLocator == nil {
			return fmt.Errorf("field \"apiLocator\" is required")
		}
	}
	return nil
}

func (u Locator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Locator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Locator) AcceptFuncs(timescaleDbLocatorFunc func(TimescaleDbLocator) error, influxLocatorFunc func(Influx2Locator) error, influx1LocatorFunc func(Influx1Locator) error, nominalLocatorFunc func(NominalLocator) error, timestreamLocatorFunc func(TimestreamLocator) error, visualCrossingLocatorFunc func(VisualCrossingLocator) error, bigQueryLocatorFunc func(BigQueryLocator) error, apiLocatorFunc func(ApiLocator) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "timescaleDbLocator":
		if u.timescaleDbLocator == nil {
			return fmt.Errorf("field \"timescaleDbLocator\" is required")
		}
		return timescaleDbLocatorFunc(*u.timescaleDbLocator)
	case "influxLocator":
		if u.influxLocator == nil {
			return fmt.Errorf("field \"influxLocator\" is required")
		}
		return influxLocatorFunc(*u.influxLocator)
	case "influx1Locator":
		if u.influx1Locator == nil {
			return fmt.Errorf("field \"influx1Locator\" is required")
		}
		return influx1LocatorFunc(*u.influx1Locator)
	case "nominalLocator":
		if u.nominalLocator == nil {
			return fmt.Errorf("field \"nominalLocator\" is required")
		}
		return nominalLocatorFunc(*u.nominalLocator)
	case "timestreamLocator":
		if u.timestreamLocator == nil {
			return fmt.Errorf("field \"timestreamLocator\" is required")
		}
		return timestreamLocatorFunc(*u.timestreamLocator)
	case "visualCrossingLocator":
		if u.visualCrossingLocator == nil {
			return fmt.Errorf("field \"visualCrossingLocator\" is required")
		}
		return visualCrossingLocatorFunc(*u.visualCrossingLocator)
	case "bigQueryLocator":
		if u.bigQueryLocator == nil {
			return fmt.Errorf("field \"bigQueryLocator\" is required")
		}
		return bigQueryLocatorFunc(*u.bigQueryLocator)
	case "apiLocator":
		if u.apiLocator == nil {
			return fmt.Errorf("field \"apiLocator\" is required")
		}
		return apiLocatorFunc(*u.apiLocator)
	}
}

func (u *Locator) TimescaleDbLocatorNoopSuccess(TimescaleDbLocator) error {
	return nil
}

func (u *Locator) InfluxLocatorNoopSuccess(Influx2Locator) error {
	return nil
}

func (u *Locator) Influx1LocatorNoopSuccess(Influx1Locator) error {
	return nil
}

func (u *Locator) NominalLocatorNoopSuccess(NominalLocator) error {
	return nil
}

func (u *Locator) TimestreamLocatorNoopSuccess(TimestreamLocator) error {
	return nil
}

func (u *Locator) VisualCrossingLocatorNoopSuccess(VisualCrossingLocator) error {
	return nil
}

func (u *Locator) BigQueryLocatorNoopSuccess(BigQueryLocator) error {
	return nil
}

func (u *Locator) ApiLocatorNoopSuccess(ApiLocator) error {
	return nil
}

func (u *Locator) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Locator) Accept(v LocatorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "timescaleDbLocator":
		if u.timescaleDbLocator == nil {
			return fmt.Errorf("field \"timescaleDbLocator\" is required")
		}
		return v.VisitTimescaleDbLocator(*u.timescaleDbLocator)
	case "influxLocator":
		if u.influxLocator == nil {
			return fmt.Errorf("field \"influxLocator\" is required")
		}
		return v.VisitInfluxLocator(*u.influxLocator)
	case "influx1Locator":
		if u.influx1Locator == nil {
			return fmt.Errorf("field \"influx1Locator\" is required")
		}
		return v.VisitInflux1Locator(*u.influx1Locator)
	case "nominalLocator":
		if u.nominalLocator == nil {
			return fmt.Errorf("field \"nominalLocator\" is required")
		}
		return v.VisitNominalLocator(*u.nominalLocator)
	case "timestreamLocator":
		if u.timestreamLocator == nil {
			return fmt.Errorf("field \"timestreamLocator\" is required")
		}
		return v.VisitTimestreamLocator(*u.timestreamLocator)
	case "visualCrossingLocator":
		if u.visualCrossingLocator == nil {
			return fmt.Errorf("field \"visualCrossingLocator\" is required")
		}
		return v.VisitVisualCrossingLocator(*u.visualCrossingLocator)
	case "bigQueryLocator":
		if u.bigQueryLocator == nil {
			return fmt.Errorf("field \"bigQueryLocator\" is required")
		}
		return v.VisitBigQueryLocator(*u.bigQueryLocator)
	case "apiLocator":
		if u.apiLocator == nil {
			return fmt.Errorf("field \"apiLocator\" is required")
		}
		return v.VisitApiLocator(*u.apiLocator)
	}
}

type LocatorVisitor interface {
	VisitTimescaleDbLocator(v TimescaleDbLocator) error
	VisitInfluxLocator(v Influx2Locator) error
	VisitInflux1Locator(v Influx1Locator) error
	VisitNominalLocator(v NominalLocator) error
	VisitTimestreamLocator(v TimestreamLocator) error
	VisitVisualCrossingLocator(v VisualCrossingLocator) error
	VisitBigQueryLocator(v BigQueryLocator) error
	VisitApiLocator(v ApiLocator) error
	VisitUnknown(typeName string) error
}

func (u *Locator) AcceptWithContext(ctx context.Context, v LocatorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "timescaleDbLocator":
		if u.timescaleDbLocator == nil {
			return fmt.Errorf("field \"timescaleDbLocator\" is required")
		}
		return v.VisitTimescaleDbLocatorWithContext(ctx, *u.timescaleDbLocator)
	case "influxLocator":
		if u.influxLocator == nil {
			return fmt.Errorf("field \"influxLocator\" is required")
		}
		return v.VisitInfluxLocatorWithContext(ctx, *u.influxLocator)
	case "influx1Locator":
		if u.influx1Locator == nil {
			return fmt.Errorf("field \"influx1Locator\" is required")
		}
		return v.VisitInflux1LocatorWithContext(ctx, *u.influx1Locator)
	case "nominalLocator":
		if u.nominalLocator == nil {
			return fmt.Errorf("field \"nominalLocator\" is required")
		}
		return v.VisitNominalLocatorWithContext(ctx, *u.nominalLocator)
	case "timestreamLocator":
		if u.timestreamLocator == nil {
			return fmt.Errorf("field \"timestreamLocator\" is required")
		}
		return v.VisitTimestreamLocatorWithContext(ctx, *u.timestreamLocator)
	case "visualCrossingLocator":
		if u.visualCrossingLocator == nil {
			return fmt.Errorf("field \"visualCrossingLocator\" is required")
		}
		return v.VisitVisualCrossingLocatorWithContext(ctx, *u.visualCrossingLocator)
	case "bigQueryLocator":
		if u.bigQueryLocator == nil {
			return fmt.Errorf("field \"bigQueryLocator\" is required")
		}
		return v.VisitBigQueryLocatorWithContext(ctx, *u.bigQueryLocator)
	case "apiLocator":
		if u.apiLocator == nil {
			return fmt.Errorf("field \"apiLocator\" is required")
		}
		return v.VisitApiLocatorWithContext(ctx, *u.apiLocator)
	}
}

type LocatorVisitorWithContext interface {
	VisitTimescaleDbLocatorWithContext(ctx context.Context, v TimescaleDbLocator) error
	VisitInfluxLocatorWithContext(ctx context.Context, v Influx2Locator) error
	VisitInflux1LocatorWithContext(ctx context.Context, v Influx1Locator) error
	VisitNominalLocatorWithContext(ctx context.Context, v NominalLocator) error
	VisitTimestreamLocatorWithContext(ctx context.Context, v TimestreamLocator) error
	VisitVisualCrossingLocatorWithContext(ctx context.Context, v VisualCrossingLocator) error
	VisitBigQueryLocatorWithContext(ctx context.Context, v BigQueryLocator) error
	VisitApiLocatorWithContext(ctx context.Context, v ApiLocator) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewLocatorFromTimescaleDbLocator(v TimescaleDbLocator) Locator {
	return Locator{typ: "timescaleDbLocator", timescaleDbLocator: &v}
}

func NewLocatorFromInfluxLocator(v Influx2Locator) Locator {
	return Locator{typ: "influxLocator", influxLocator: &v}
}

func NewLocatorFromInflux1Locator(v Influx1Locator) Locator {
	return Locator{typ: "influx1Locator", influx1Locator: &v}
}

func NewLocatorFromNominalLocator(v NominalLocator) Locator {
	return Locator{typ: "nominalLocator", nominalLocator: &v}
}

func NewLocatorFromTimestreamLocator(v TimestreamLocator) Locator {
	return Locator{typ: "timestreamLocator", timestreamLocator: &v}
}

func NewLocatorFromVisualCrossingLocator(v VisualCrossingLocator) Locator {
	return Locator{typ: "visualCrossingLocator", visualCrossingLocator: &v}
}

func NewLocatorFromBigQueryLocator(v BigQueryLocator) Locator {
	return Locator{typ: "bigQueryLocator", bigQueryLocator: &v}
}

func NewLocatorFromApiLocator(v ApiLocator) Locator {
	return Locator{typ: "apiLocator", apiLocator: &v}
}

type ResolveSeriesResponse struct {
	typ   string
	rid   *api.LogicalSeriesRid
	error *ResolveSeriesError
}

type resolveSeriesResponseDeserializer struct {
	Type  string                `json:"type"`
	Rid   *api.LogicalSeriesRid `json:"rid"`
	Error *ResolveSeriesError   `json:"error"`
}

func (u *resolveSeriesResponseDeserializer) toStruct() ResolveSeriesResponse {
	return ResolveSeriesResponse{typ: u.Type, rid: u.Rid, error: u.Error}
}

func (u *ResolveSeriesResponse) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "rid":
		if u.rid == nil {
			return nil, fmt.Errorf("field \"rid\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Rid  api.LogicalSeriesRid `json:"rid"`
		}{Type: "rid", Rid: *u.rid}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string             `json:"type"`
			Error ResolveSeriesError `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	}
}

func (u ResolveSeriesResponse) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ResolveSeriesResponse) UnmarshalJSON(data []byte) error {
	var deser resolveSeriesResponseDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "rid":
		if u.rid == nil {
			return fmt.Errorf("field \"rid\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	}
	return nil
}

func (u ResolveSeriesResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ResolveSeriesResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ResolveSeriesResponse) AcceptFuncs(ridFunc func(api.LogicalSeriesRid) error, errorFunc func(ResolveSeriesError) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "rid":
		if u.rid == nil {
			return fmt.Errorf("field \"rid\" is required")
		}
		return ridFunc(*u.rid)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	}
}

func (u *ResolveSeriesResponse) RidNoopSuccess(api.LogicalSeriesRid) error {
	return nil
}

func (u *ResolveSeriesResponse) ErrorNoopSuccess(ResolveSeriesError) error {
	return nil
}

func (u *ResolveSeriesResponse) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ResolveSeriesResponse) Accept(v ResolveSeriesResponseVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "rid":
		if u.rid == nil {
			return fmt.Errorf("field \"rid\" is required")
		}
		return v.VisitRid(*u.rid)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	}
}

type ResolveSeriesResponseVisitor interface {
	VisitRid(v api.LogicalSeriesRid) error
	VisitError(v ResolveSeriesError) error
	VisitUnknown(typeName string) error
}

func (u *ResolveSeriesResponse) AcceptWithContext(ctx context.Context, v ResolveSeriesResponseVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "rid":
		if u.rid == nil {
			return fmt.Errorf("field \"rid\" is required")
		}
		return v.VisitRidWithContext(ctx, *u.rid)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	}
}

type ResolveSeriesResponseVisitorWithContext interface {
	VisitRidWithContext(ctx context.Context, v api.LogicalSeriesRid) error
	VisitErrorWithContext(ctx context.Context, v ResolveSeriesError) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewResolveSeriesResponseFromRid(v api.LogicalSeriesRid) ResolveSeriesResponse {
	return ResolveSeriesResponse{typ: "rid", rid: &v}
}

func NewResolveSeriesResponseFromError(v ResolveSeriesError) ResolveSeriesResponse {
	return ResolveSeriesResponse{typ: "error", error: &v}
}

// UnitUpdate is used to either set a unit, or to clear an existing unit.
type UnitUpdate struct {
	typ       string
	unit      *api.Unit
	clearUnit *api.Empty
}

type unitUpdateDeserializer struct {
	Type      string     `json:"type"`
	Unit      *api.Unit  `json:"unit"`
	ClearUnit *api.Empty `json:"clearUnit"`
}

func (u *unitUpdateDeserializer) toStruct() UnitUpdate {
	return UnitUpdate{typ: u.Type, unit: u.Unit, clearUnit: u.ClearUnit}
}

func (u *UnitUpdate) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "unit":
		if u.unit == nil {
			return nil, fmt.Errorf("field \"unit\" is required")
		}
		return struct {
			Type string   `json:"type"`
			Unit api.Unit `json:"unit"`
		}{Type: "unit", Unit: *u.unit}, nil
	case "clearUnit":
		if u.clearUnit == nil {
			return nil, fmt.Errorf("field \"clearUnit\" is required")
		}
		return struct {
			Type      string    `json:"type"`
			ClearUnit api.Empty `json:"clearUnit"`
		}{Type: "clearUnit", ClearUnit: *u.clearUnit}, nil
	}
}

func (u UnitUpdate) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *UnitUpdate) UnmarshalJSON(data []byte) error {
	var deser unitUpdateDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "unit":
		if u.unit == nil {
			return fmt.Errorf("field \"unit\" is required")
		}
	case "clearUnit":
		if u.clearUnit == nil {
			return fmt.Errorf("field \"clearUnit\" is required")
		}
	}
	return nil
}

func (u UnitUpdate) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *UnitUpdate) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *UnitUpdate) AcceptFuncs(unitFunc func(api.Unit) error, clearUnitFunc func(api.Empty) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "unit":
		if u.unit == nil {
			return fmt.Errorf("field \"unit\" is required")
		}
		return unitFunc(*u.unit)
	case "clearUnit":
		if u.clearUnit == nil {
			return fmt.Errorf("field \"clearUnit\" is required")
		}
		return clearUnitFunc(*u.clearUnit)
	}
}

func (u *UnitUpdate) UnitNoopSuccess(api.Unit) error {
	return nil
}

func (u *UnitUpdate) ClearUnitNoopSuccess(api.Empty) error {
	return nil
}

func (u *UnitUpdate) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *UnitUpdate) Accept(v UnitUpdateVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "unit":
		if u.unit == nil {
			return fmt.Errorf("field \"unit\" is required")
		}
		return v.VisitUnit(*u.unit)
	case "clearUnit":
		if u.clearUnit == nil {
			return fmt.Errorf("field \"clearUnit\" is required")
		}
		return v.VisitClearUnit(*u.clearUnit)
	}
}

type UnitUpdateVisitor interface {
	VisitUnit(v api.Unit) error
	VisitClearUnit(v api.Empty) error
	VisitUnknown(typeName string) error
}

func (u *UnitUpdate) AcceptWithContext(ctx context.Context, v UnitUpdateVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "unit":
		if u.unit == nil {
			return fmt.Errorf("field \"unit\" is required")
		}
		return v.VisitUnitWithContext(ctx, *u.unit)
	case "clearUnit":
		if u.clearUnit == nil {
			return fmt.Errorf("field \"clearUnit\" is required")
		}
		return v.VisitClearUnitWithContext(ctx, *u.clearUnit)
	}
}

type UnitUpdateVisitorWithContext interface {
	VisitUnitWithContext(ctx context.Context, v api.Unit) error
	VisitClearUnitWithContext(ctx context.Context, v api.Empty) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewUnitUpdateFromUnit(v api.Unit) UnitUpdate {
	return UnitUpdate{typ: "unit", unit: &v}
}

func NewUnitUpdateFromClearUnit(v api.Empty) UnitUpdate {
	return UnitUpdate{typ: "clearUnit", clearUnit: &v}
}
