// Code generated by conjure-go. DO NOT EDIT.

package logicalseries

import (
	"context"
	"fmt"
	"net/url"

	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	api1 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/timeseries/logicalseries/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	werror "github.com/palantir/witchcraft-go-error"
)

// A logical series is a timeseries, represented by a channel name and a tag set.
type LogicalSeriesServiceClient interface {
	// Create a new logical series.
	CreateLogicalSeries(ctx context.Context, authHeader bearertoken.Token, createLogicalSeriesArg api.CreateLogicalSeries) (api.LogicalSeries, error)
	// Batch create new logical series.
	BatchCreateLogicalSeries(ctx context.Context, authHeader bearertoken.Token, requestArg api.BatchCreateLogicalSeriesRequest) (api.BatchCreateLogicalSeriesResponse, error)
	// Batch update logical series descriptions and units.
	BatchUpdateLogicalSeries(ctx context.Context, authHeader bearertoken.Token, requestArg api.BatchUpdateLogicalSeriesRequest) (api.BatchUpdateLogicalSeriesResponse, error)
	// Get a logical series by logical series rid.
	GetLogicalSeries(ctx context.Context, authHeader bearertoken.Token, ridArg api1.LogicalSeriesRid) (api.LogicalSeries, error)
	/*
	   Resolves groups of channels, datasources and tags into logical series rids. An error response is provided
	   if the channel + datasource + tag cannot be resolved into a logical series rid.
	*/
	ResolveBatch(ctx context.Context, authHeader bearertoken.Token, requestArg api.BatchResolveSeriesRequest) (api.BatchResolveSeriesResponse, error)
}

type logicalSeriesServiceClient struct {
	client httpclient.Client
}

func NewLogicalSeriesServiceClient(client httpclient.Client) LogicalSeriesServiceClient {
	return &logicalSeriesServiceClient{client: client}
}

func (c *logicalSeriesServiceClient) CreateLogicalSeries(ctx context.Context, authHeader bearertoken.Token, createLogicalSeriesArg api.CreateLogicalSeries) (api.LogicalSeries, error) {
	var defaultReturnVal api.LogicalSeries
	var returnVal *api.LogicalSeries
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateLogicalSeries"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/timeseries/logical-series/v1/logical-series"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(createLogicalSeriesArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createLogicalSeries failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createLogicalSeries response cannot be nil")
	}
	return *returnVal, nil
}

func (c *logicalSeriesServiceClient) BatchCreateLogicalSeries(ctx context.Context, authHeader bearertoken.Token, requestArg api.BatchCreateLogicalSeriesRequest) (api.BatchCreateLogicalSeriesResponse, error) {
	var defaultReturnVal api.BatchCreateLogicalSeriesResponse
	var returnVal *api.BatchCreateLogicalSeriesResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchCreateLogicalSeries"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/timeseries/logical-series/v1/logical-series/batch-create"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "batchCreateLogicalSeries failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "batchCreateLogicalSeries response cannot be nil")
	}
	return *returnVal, nil
}

func (c *logicalSeriesServiceClient) BatchUpdateLogicalSeries(ctx context.Context, authHeader bearertoken.Token, requestArg api.BatchUpdateLogicalSeriesRequest) (api.BatchUpdateLogicalSeriesResponse, error) {
	var defaultReturnVal api.BatchUpdateLogicalSeriesResponse
	var returnVal *api.BatchUpdateLogicalSeriesResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchUpdateLogicalSeries"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/timeseries/logical-series/v1/logical-series/batch-update"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "batchUpdateLogicalSeries failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "batchUpdateLogicalSeries response cannot be nil")
	}
	return *returnVal, nil
}

func (c *logicalSeriesServiceClient) GetLogicalSeries(ctx context.Context, authHeader bearertoken.Token, ridArg api1.LogicalSeriesRid) (api.LogicalSeries, error) {
	var defaultReturnVal api.LogicalSeries
	var returnVal *api.LogicalSeries
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetLogicalSeries"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/timeseries/logical-series/v1/logical-series/%s", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getLogicalSeries failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getLogicalSeries response cannot be nil")
	}
	return *returnVal, nil
}

func (c *logicalSeriesServiceClient) ResolveBatch(ctx context.Context, authHeader bearertoken.Token, requestArg api.BatchResolveSeriesRequest) (api.BatchResolveSeriesResponse, error) {
	var defaultReturnVal api.BatchResolveSeriesResponse
	var returnVal *api.BatchResolveSeriesResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ResolveBatch"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/timeseries/logical-series/v1/resolve"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "resolveBatch failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "resolveBatch response cannot be nil")
	}
	return *returnVal, nil
}

// A logical series is a timeseries, represented by a channel name and a tag set.
type LogicalSeriesServiceClientWithAuth interface {
	// Create a new logical series.
	CreateLogicalSeries(ctx context.Context, createLogicalSeriesArg api.CreateLogicalSeries) (api.LogicalSeries, error)
	// Batch create new logical series.
	BatchCreateLogicalSeries(ctx context.Context, requestArg api.BatchCreateLogicalSeriesRequest) (api.BatchCreateLogicalSeriesResponse, error)
	// Batch update logical series descriptions and units.
	BatchUpdateLogicalSeries(ctx context.Context, requestArg api.BatchUpdateLogicalSeriesRequest) (api.BatchUpdateLogicalSeriesResponse, error)
	// Get a logical series by logical series rid.
	GetLogicalSeries(ctx context.Context, ridArg api1.LogicalSeriesRid) (api.LogicalSeries, error)
	/*
	   Resolves groups of channels, datasources and tags into logical series rids. An error response is provided
	   if the channel + datasource + tag cannot be resolved into a logical series rid.
	*/
	ResolveBatch(ctx context.Context, requestArg api.BatchResolveSeriesRequest) (api.BatchResolveSeriesResponse, error)
}

func NewLogicalSeriesServiceClientWithAuth(client LogicalSeriesServiceClient, authHeader bearertoken.Token) LogicalSeriesServiceClientWithAuth {
	return &logicalSeriesServiceClientWithAuth{client: client, authHeader: authHeader}
}

type logicalSeriesServiceClientWithAuth struct {
	client     LogicalSeriesServiceClient
	authHeader bearertoken.Token
}

func (c *logicalSeriesServiceClientWithAuth) CreateLogicalSeries(ctx context.Context, createLogicalSeriesArg api.CreateLogicalSeries) (api.LogicalSeries, error) {
	return c.client.CreateLogicalSeries(ctx, c.authHeader, createLogicalSeriesArg)
}

func (c *logicalSeriesServiceClientWithAuth) BatchCreateLogicalSeries(ctx context.Context, requestArg api.BatchCreateLogicalSeriesRequest) (api.BatchCreateLogicalSeriesResponse, error) {
	return c.client.BatchCreateLogicalSeries(ctx, c.authHeader, requestArg)
}

func (c *logicalSeriesServiceClientWithAuth) BatchUpdateLogicalSeries(ctx context.Context, requestArg api.BatchUpdateLogicalSeriesRequest) (api.BatchUpdateLogicalSeriesResponse, error) {
	return c.client.BatchUpdateLogicalSeries(ctx, c.authHeader, requestArg)
}

func (c *logicalSeriesServiceClientWithAuth) GetLogicalSeries(ctx context.Context, ridArg api1.LogicalSeriesRid) (api.LogicalSeries, error) {
	return c.client.GetLogicalSeries(ctx, c.authHeader, ridArg)
}

func (c *logicalSeriesServiceClientWithAuth) ResolveBatch(ctx context.Context, requestArg api.BatchResolveSeriesRequest) (api.BatchResolveSeriesResponse, error) {
	return c.client.ResolveBatch(ctx, c.authHeader, requestArg)
}

func NewLogicalSeriesServiceClientWithTokenProvider(client LogicalSeriesServiceClient, tokenProvider httpclient.TokenProvider) LogicalSeriesServiceClientWithAuth {
	return &logicalSeriesServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type logicalSeriesServiceClientWithTokenProvider struct {
	client        LogicalSeriesServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *logicalSeriesServiceClientWithTokenProvider) CreateLogicalSeries(ctx context.Context, createLogicalSeriesArg api.CreateLogicalSeries) (api.LogicalSeries, error) {
	var defaultReturnVal api.LogicalSeries
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateLogicalSeries(ctx, bearertoken.Token(token), createLogicalSeriesArg)
}

func (c *logicalSeriesServiceClientWithTokenProvider) BatchCreateLogicalSeries(ctx context.Context, requestArg api.BatchCreateLogicalSeriesRequest) (api.BatchCreateLogicalSeriesResponse, error) {
	var defaultReturnVal api.BatchCreateLogicalSeriesResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchCreateLogicalSeries(ctx, bearertoken.Token(token), requestArg)
}

func (c *logicalSeriesServiceClientWithTokenProvider) BatchUpdateLogicalSeries(ctx context.Context, requestArg api.BatchUpdateLogicalSeriesRequest) (api.BatchUpdateLogicalSeriesResponse, error) {
	var defaultReturnVal api.BatchUpdateLogicalSeriesResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchUpdateLogicalSeries(ctx, bearertoken.Token(token), requestArg)
}

func (c *logicalSeriesServiceClientWithTokenProvider) GetLogicalSeries(ctx context.Context, ridArg api1.LogicalSeriesRid) (api.LogicalSeries, error) {
	var defaultReturnVal api.LogicalSeries
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetLogicalSeries(ctx, bearertoken.Token(token), ridArg)
}

func (c *logicalSeriesServiceClientWithTokenProvider) ResolveBatch(ctx context.Context, requestArg api.BatchResolveSeriesRequest) (api.BatchResolveSeriesResponse, error) {
	var defaultReturnVal api.BatchResolveSeriesResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ResolveBatch(ctx, bearertoken.Token(token), requestArg)
}
