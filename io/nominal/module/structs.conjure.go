// Code generated by conjure-go. DO NOT EDIT.

package module

import (
	"github.com/nominal-io/nominal-api-go/api/rids"
	api2 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/nominal-io/nominal-api-go/modules/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/datetime"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type BatchArchiveModulesRequest struct {
	Requests []api.ModuleRid `json:"requests"`
}

func (o BatchArchiveModulesRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]api.ModuleRid, 0)
	}
	type _tmpBatchArchiveModulesRequest BatchArchiveModulesRequest
	return safejson.Marshal(_tmpBatchArchiveModulesRequest(o))
}

func (o *BatchArchiveModulesRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchArchiveModulesRequest BatchArchiveModulesRequest
	var rawBatchArchiveModulesRequest _tmpBatchArchiveModulesRequest
	if err := safejson.Unmarshal(data, &rawBatchArchiveModulesRequest); err != nil {
		return err
	}
	if rawBatchArchiveModulesRequest.Requests == nil {
		rawBatchArchiveModulesRequest.Requests = make([]api.ModuleRid, 0)
	}
	*o = BatchArchiveModulesRequest(rawBatchArchiveModulesRequest)
	return nil
}

func (o BatchArchiveModulesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchArchiveModulesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchArchiveModulesResponse struct {
	ArchivedModuleRids []api.ModuleRid `json:"archivedModuleRids"`
}

func (o BatchArchiveModulesResponse) MarshalJSON() ([]byte, error) {
	if o.ArchivedModuleRids == nil {
		o.ArchivedModuleRids = make([]api.ModuleRid, 0)
	}
	type _tmpBatchArchiveModulesResponse BatchArchiveModulesResponse
	return safejson.Marshal(_tmpBatchArchiveModulesResponse(o))
}

func (o *BatchArchiveModulesResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchArchiveModulesResponse BatchArchiveModulesResponse
	var rawBatchArchiveModulesResponse _tmpBatchArchiveModulesResponse
	if err := safejson.Unmarshal(data, &rawBatchArchiveModulesResponse); err != nil {
		return err
	}
	if rawBatchArchiveModulesResponse.ArchivedModuleRids == nil {
		rawBatchArchiveModulesResponse.ArchivedModuleRids = make([]api.ModuleRid, 0)
	}
	*o = BatchArchiveModulesResponse(rawBatchArchiveModulesResponse)
	return nil
}

func (o BatchArchiveModulesResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchArchiveModulesResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchGetModulesRequest struct {
	Requests []RequestModuleRef `json:"requests"`
}

func (o BatchGetModulesRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]RequestModuleRef, 0)
	}
	type _tmpBatchGetModulesRequest BatchGetModulesRequest
	return safejson.Marshal(_tmpBatchGetModulesRequest(o))
}

func (o *BatchGetModulesRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchGetModulesRequest BatchGetModulesRequest
	var rawBatchGetModulesRequest _tmpBatchGetModulesRequest
	if err := safejson.Unmarshal(data, &rawBatchGetModulesRequest); err != nil {
		return err
	}
	if rawBatchGetModulesRequest.Requests == nil {
		rawBatchGetModulesRequest.Requests = make([]RequestModuleRef, 0)
	}
	*o = BatchGetModulesRequest(rawBatchGetModulesRequest)
	return nil
}

func (o BatchGetModulesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchGetModulesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchUnarchiveModulesRequest struct {
	Requests []api.ModuleRid `json:"requests"`
}

func (o BatchUnarchiveModulesRequest) MarshalJSON() ([]byte, error) {
	if o.Requests == nil {
		o.Requests = make([]api.ModuleRid, 0)
	}
	type _tmpBatchUnarchiveModulesRequest BatchUnarchiveModulesRequest
	return safejson.Marshal(_tmpBatchUnarchiveModulesRequest(o))
}

func (o *BatchUnarchiveModulesRequest) UnmarshalJSON(data []byte) error {
	type _tmpBatchUnarchiveModulesRequest BatchUnarchiveModulesRequest
	var rawBatchUnarchiveModulesRequest _tmpBatchUnarchiveModulesRequest
	if err := safejson.Unmarshal(data, &rawBatchUnarchiveModulesRequest); err != nil {
		return err
	}
	if rawBatchUnarchiveModulesRequest.Requests == nil {
		rawBatchUnarchiveModulesRequest.Requests = make([]api.ModuleRid, 0)
	}
	*o = BatchUnarchiveModulesRequest(rawBatchUnarchiveModulesRequest)
	return nil
}

func (o BatchUnarchiveModulesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchUnarchiveModulesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type BatchUnarchiveModulesResponse struct {
	UnarchivedModuleRids []api.ModuleRid `json:"unarchivedModuleRids"`
}

func (o BatchUnarchiveModulesResponse) MarshalJSON() ([]byte, error) {
	if o.UnarchivedModuleRids == nil {
		o.UnarchivedModuleRids = make([]api.ModuleRid, 0)
	}
	type _tmpBatchUnarchiveModulesResponse BatchUnarchiveModulesResponse
	return safejson.Marshal(_tmpBatchUnarchiveModulesResponse(o))
}

func (o *BatchUnarchiveModulesResponse) UnmarshalJSON(data []byte) error {
	type _tmpBatchUnarchiveModulesResponse BatchUnarchiveModulesResponse
	var rawBatchUnarchiveModulesResponse _tmpBatchUnarchiveModulesResponse
	if err := safejson.Unmarshal(data, &rawBatchUnarchiveModulesResponse); err != nil {
		return err
	}
	if rawBatchUnarchiveModulesResponse.UnarchivedModuleRids == nil {
		rawBatchUnarchiveModulesResponse.UnarchivedModuleRids = make([]api.ModuleRid, 0)
	}
	*o = BatchUnarchiveModulesResponse(rawBatchUnarchiveModulesResponse)
	return nil
}

func (o BatchUnarchiveModulesResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BatchUnarchiveModulesResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type CreateModuleRequest struct {
	// The API name for the module. This string will uniquely identify the module within the organization.
	ApiName     string                  `conjure-docs:"The API name for the module. This string will uniquely identify the module within the organization." json:"apiName"`
	Title       string                  `json:"title"`
	Description string                  `json:"description"`
	Definition  ModuleVersionDefinition `json:"definition"`
	Workspace   *rids.WorkspaceRid      `json:"workspace,omitempty"`
}

func (o CreateModuleRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *CreateModuleRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Function struct {
	// The name of the function. This should be unique to the function in the current module.
	Name         string              `conjure-docs:"The name of the function. This should be unique to the function in the current module." json:"name"`
	Description  string              `json:"description"`
	Parameters   []FunctionParameter `json:"parameters"`
	FunctionNode FunctionNode        `json:"functionNode"`
	IsExported   bool                `json:"isExported"`
}

func (o Function) MarshalJSON() ([]byte, error) {
	if o.Parameters == nil {
		o.Parameters = make([]FunctionParameter, 0)
	}
	type _tmpFunction Function
	return safejson.Marshal(_tmpFunction(o))
}

func (o *Function) UnmarshalJSON(data []byte) error {
	type _tmpFunction Function
	var rawFunction _tmpFunction
	if err := safejson.Unmarshal(data, &rawFunction); err != nil {
		return err
	}
	if rawFunction.Parameters == nil {
		rawFunction.Parameters = make([]FunctionParameter, 0)
	}
	*o = Function(rawFunction)
	return nil
}

func (o Function) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Function) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type FunctionParameter struct {
	Name ParameterName `json:"name"`
	Type ValueType     `json:"type"`
}

func (o FunctionParameter) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *FunctionParameter) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// This strategy refers to the latest version of the module.
type LatestVersionStrategy struct{}

func (o LatestVersionStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *LatestVersionStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type Module struct {
	Metadata        ModuleMetadata          `json:"metadata"`
	VersionMetadata ModuleVersionMetadata   `json:"versionMetadata"`
	Definition      ModuleVersionDefinition `json:"definition"`
}

func (o Module) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *Module) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ModuleMetadata struct {
	Rid api.ModuleRid `json:"rid"`
	/*
	   This uniquely identifies the module within the org.
	   Note that this cannot be changed after creation.
	*/
	ApiName     string            `conjure-docs:"This uniquely identifies the module within the org.\nNote that this cannot be changed after creation." json:"apiName"`
	Title       string            `json:"title"`
	Description string            `json:"description"`
	CreatedBy   api1.UserRid      `json:"createdBy"`
	CreatedAt   datetime.DateTime `json:"createdAt"`
	// The time at which the module was archived. Unset if the module is not archived.
	ArchivedAt *datetime.DateTime `conjure-docs:"The time at which the module was archived. Unset if the module is not archived." json:"archivedAt,omitempty"`
}

func (o ModuleMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ModuleMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ModuleRef struct {
	Rid     api.ModuleRid `json:"rid"`
	ApiName string        `json:"apiName"`
	Version ModuleVersion `json:"version"`
}

func (o ModuleRef) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ModuleRef) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ModuleSummary struct {
	Metadata ModuleMetadata        `json:"metadata"`
	Latest   ModuleVersionMetadata `json:"latest"`
}

func (o ModuleSummary) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ModuleSummary) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ModuleVersionDefinition struct {
	/*
	   The list of functions that resolve to derived series that appear in channel search after applying to an
	   asset. Limited to 100.
	*/
	Functions []Function `conjure-docs:"The list of functions that resolve to derived series that appear in channel search after applying to an\nasset. Limited to 100." json:"functions"`
}

func (o ModuleVersionDefinition) MarshalJSON() ([]byte, error) {
	if o.Functions == nil {
		o.Functions = make([]Function, 0)
	}
	type _tmpModuleVersionDefinition ModuleVersionDefinition
	return safejson.Marshal(_tmpModuleVersionDefinition(o))
}

func (o *ModuleVersionDefinition) UnmarshalJSON(data []byte) error {
	type _tmpModuleVersionDefinition ModuleVersionDefinition
	var rawModuleVersionDefinition _tmpModuleVersionDefinition
	if err := safejson.Unmarshal(data, &rawModuleVersionDefinition); err != nil {
		return err
	}
	if rawModuleVersionDefinition.Functions == nil {
		rawModuleVersionDefinition.Functions = make([]Function, 0)
	}
	*o = ModuleVersionDefinition(rawModuleVersionDefinition)
	return nil
}

func (o ModuleVersionDefinition) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ModuleVersionDefinition) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type ModuleVersionMetadata struct {
	CreatedBy api1.UserRid      `json:"createdBy"`
	CreatedAt datetime.DateTime `json:"createdAt"`
	Version   ModuleVersion     `json:"version"`
}

func (o ModuleVersionMetadata) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *ModuleVersionMetadata) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// This strategy refers to a specific version of the module.
type PinnedVersionStrategy struct {
	Version ModuleVersion `json:"version"`
}

func (o PinnedVersionStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *PinnedVersionStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// This is used to refer to modules in requests by name.
type RequestModuleNameRef struct {
	ApiName         string          `json:"apiName"`
	VersionStrategy VersionStrategy `json:"versionStrategy"`
}

func (o RequestModuleNameRef) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RequestModuleNameRef) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// This is used to refer to modules in requests by rid.
type RequestModuleRidRef struct {
	Rid             api.ModuleRid   `json:"rid"`
	VersionStrategy VersionStrategy `json:"versionStrategy"`
}

func (o RequestModuleRidRef) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *RequestModuleRidRef) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchModulesRequest struct {
	Query         SearchModulesQuery        `json:"query"`
	Sort          *SearchModulesSortOptions `json:"sort,omitempty"`
	PageSize      int                       `json:"pageSize"`
	NextPageToken *api2.Token               `json:"nextPageToken,omitempty"`
	// Default search status is NOT_ARCHIVED if none are provided. Allows for including archived modules in search.
	ArchivedStatuses *[]api2.ArchivedStatus `conjure-docs:"Default search status is NOT_ARCHIVED if none are provided. Allows for including archived modules in search." json:"archivedStatuses,omitempty"`
}

func (o SearchModulesRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchModulesRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchModulesResponse struct {
	Results       []ModuleSummary `json:"results"`
	NextPageToken *api2.Token     `json:"nextPageToken,omitempty"`
}

func (o SearchModulesResponse) MarshalJSON() ([]byte, error) {
	if o.Results == nil {
		o.Results = make([]ModuleSummary, 0)
	}
	type _tmpSearchModulesResponse SearchModulesResponse
	return safejson.Marshal(_tmpSearchModulesResponse(o))
}

func (o *SearchModulesResponse) UnmarshalJSON(data []byte) error {
	type _tmpSearchModulesResponse SearchModulesResponse
	var rawSearchModulesResponse _tmpSearchModulesResponse
	if err := safejson.Unmarshal(data, &rawSearchModulesResponse); err != nil {
		return err
	}
	if rawSearchModulesResponse.Results == nil {
		rawSearchModulesResponse.Results = make([]ModuleSummary, 0)
	}
	*o = SearchModulesResponse(rawSearchModulesResponse)
	return nil
}

func (o SearchModulesResponse) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchModulesResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type SearchModulesSortOptions struct {
	IsDescending bool                   `json:"isDescending"`
	Field        SearchModulesSortField `json:"field"`
}

func (o SearchModulesSortOptions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *SearchModulesSortOptions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

type UpdateModuleRequest struct {
	Title       string                  `json:"title"`
	Description string                  `json:"description"`
	Definition  ModuleVersionDefinition `json:"definition"`
}

func (o UpdateModuleRequest) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *UpdateModuleRequest) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
