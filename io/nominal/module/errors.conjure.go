// Code generated by conjure-go. DO NOT EDIT.

package module

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/nominal-io/nominal-api-go/modules/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type cyclicModuleFunctionDefinitions struct {
	FunctionNames []string `json:"functionNames"`
}

func (o cyclicModuleFunctionDefinitions) MarshalJSON() ([]byte, error) {
	if o.FunctionNames == nil {
		o.FunctionNames = make([]string, 0)
	}
	type _tmpcyclicModuleFunctionDefinitions cyclicModuleFunctionDefinitions
	return safejson.Marshal(_tmpcyclicModuleFunctionDefinitions(o))
}

func (o *cyclicModuleFunctionDefinitions) UnmarshalJSON(data []byte) error {
	type _tmpcyclicModuleFunctionDefinitions cyclicModuleFunctionDefinitions
	var rawcyclicModuleFunctionDefinitions _tmpcyclicModuleFunctionDefinitions
	if err := safejson.Unmarshal(data, &rawcyclicModuleFunctionDefinitions); err != nil {
		return err
	}
	if rawcyclicModuleFunctionDefinitions.FunctionNames == nil {
		rawcyclicModuleFunctionDefinitions.FunctionNames = make([]string, 0)
	}
	*o = cyclicModuleFunctionDefinitions(rawcyclicModuleFunctionDefinitions)
	return nil
}

func (o cyclicModuleFunctionDefinitions) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *cyclicModuleFunctionDefinitions) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewCyclicModuleFunctionDefinitions returns new instance of CyclicModuleFunctionDefinitions error.
func NewCyclicModuleFunctionDefinitions(functionNamesArg []string) *CyclicModuleFunctionDefinitions {
	return &CyclicModuleFunctionDefinitions{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cyclicModuleFunctionDefinitions: cyclicModuleFunctionDefinitions{FunctionNames: functionNamesArg}}
}

// WrapWithCyclicModuleFunctionDefinitions returns new instance of CyclicModuleFunctionDefinitions error wrapping an existing error.
func WrapWithCyclicModuleFunctionDefinitions(err error, functionNamesArg []string) *CyclicModuleFunctionDefinitions {
	return &CyclicModuleFunctionDefinitions{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, cyclicModuleFunctionDefinitions: cyclicModuleFunctionDefinitions{FunctionNames: functionNamesArg}}
}

// CyclicModuleFunctionDefinitions is an error type.
// One or more functions contain cyclic references to each other.
type CyclicModuleFunctionDefinitions struct {
	errorInstanceID uuid.UUID
	cyclicModuleFunctionDefinitions
	cause error
	stack werror.StackTrace
}

// IsCyclicModuleFunctionDefinitions returns true if err is an instance of CyclicModuleFunctionDefinitions.
func IsCyclicModuleFunctionDefinitions(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*CyclicModuleFunctionDefinitions)
	return ok
}

func (e *CyclicModuleFunctionDefinitions) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Module:CyclicModuleFunctionDefinitions (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *CyclicModuleFunctionDefinitions) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *CyclicModuleFunctionDefinitions) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *CyclicModuleFunctionDefinitions) Message() string {
	return "INVALID_ARGUMENT Module:CyclicModuleFunctionDefinitions"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *CyclicModuleFunctionDefinitions) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *CyclicModuleFunctionDefinitions) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *CyclicModuleFunctionDefinitions) Name() string {
	return "Module:CyclicModuleFunctionDefinitions"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *CyclicModuleFunctionDefinitions) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *CyclicModuleFunctionDefinitions) Parameters() map[string]interface{} {
	return map[string]interface{}{"functionNames": e.FunctionNames}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *CyclicModuleFunctionDefinitions) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *CyclicModuleFunctionDefinitions) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *CyclicModuleFunctionDefinitions) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"functionNames": e.FunctionNames}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *CyclicModuleFunctionDefinitions) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e CyclicModuleFunctionDefinitions) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.cyclicModuleFunctionDefinitions)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Module:CyclicModuleFunctionDefinitions", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *CyclicModuleFunctionDefinitions) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters cyclicModuleFunctionDefinitions
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.cyclicModuleFunctionDefinitions = parameters
	return nil
}

type functionNameConflict struct {
	FunctionNames []string `json:"functionNames"`
}

func (o functionNameConflict) MarshalJSON() ([]byte, error) {
	if o.FunctionNames == nil {
		o.FunctionNames = make([]string, 0)
	}
	type _tmpfunctionNameConflict functionNameConflict
	return safejson.Marshal(_tmpfunctionNameConflict(o))
}

func (o *functionNameConflict) UnmarshalJSON(data []byte) error {
	type _tmpfunctionNameConflict functionNameConflict
	var rawfunctionNameConflict _tmpfunctionNameConflict
	if err := safejson.Unmarshal(data, &rawfunctionNameConflict); err != nil {
		return err
	}
	if rawfunctionNameConflict.FunctionNames == nil {
		rawfunctionNameConflict.FunctionNames = make([]string, 0)
	}
	*o = functionNameConflict(rawfunctionNameConflict)
	return nil
}

func (o functionNameConflict) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *functionNameConflict) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewFunctionNameConflict returns new instance of FunctionNameConflict error.
func NewFunctionNameConflict(functionNamesArg []string) *FunctionNameConflict {
	return &FunctionNameConflict{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), functionNameConflict: functionNameConflict{FunctionNames: functionNamesArg}}
}

// WrapWithFunctionNameConflict returns new instance of FunctionNameConflict error wrapping an existing error.
func WrapWithFunctionNameConflict(err error, functionNamesArg []string) *FunctionNameConflict {
	return &FunctionNameConflict{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, functionNameConflict: functionNameConflict{FunctionNames: functionNamesArg}}
}

// FunctionNameConflict is an error type.
// One or more function names conflict with each other in the module definition.
type FunctionNameConflict struct {
	errorInstanceID uuid.UUID
	functionNameConflict
	cause error
	stack werror.StackTrace
}

// IsFunctionNameConflict returns true if err is an instance of FunctionNameConflict.
func IsFunctionNameConflict(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*FunctionNameConflict)
	return ok
}

func (e *FunctionNameConflict) Error() string {
	return fmt.Sprintf("CONFLICT Module:FunctionNameConflict (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *FunctionNameConflict) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *FunctionNameConflict) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *FunctionNameConflict) Message() string {
	return "CONFLICT Module:FunctionNameConflict"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *FunctionNameConflict) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *FunctionNameConflict) Code() errors.ErrorCode {
	return errors.Conflict
}

// Name returns an error name identifying error type.
func (e *FunctionNameConflict) Name() string {
	return "Module:FunctionNameConflict"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *FunctionNameConflict) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *FunctionNameConflict) Parameters() map[string]interface{} {
	return map[string]interface{}{"functionNames": e.FunctionNames}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *FunctionNameConflict) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *FunctionNameConflict) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *FunctionNameConflict) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"functionNames": e.FunctionNames}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *FunctionNameConflict) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e FunctionNameConflict) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.functionNameConflict)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Conflict, ErrorName: "Module:FunctionNameConflict", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *FunctionNameConflict) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters functionNameConflict
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.functionNameConflict = parameters
	return nil
}

type invalidFunctionNames struct {
	FunctionNames []string `json:"functionNames"`
}

func (o invalidFunctionNames) MarshalJSON() ([]byte, error) {
	if o.FunctionNames == nil {
		o.FunctionNames = make([]string, 0)
	}
	type _tmpinvalidFunctionNames invalidFunctionNames
	return safejson.Marshal(_tmpinvalidFunctionNames(o))
}

func (o *invalidFunctionNames) UnmarshalJSON(data []byte) error {
	type _tmpinvalidFunctionNames invalidFunctionNames
	var rawinvalidFunctionNames _tmpinvalidFunctionNames
	if err := safejson.Unmarshal(data, &rawinvalidFunctionNames); err != nil {
		return err
	}
	if rawinvalidFunctionNames.FunctionNames == nil {
		rawinvalidFunctionNames.FunctionNames = make([]string, 0)
	}
	*o = invalidFunctionNames(rawinvalidFunctionNames)
	return nil
}

func (o invalidFunctionNames) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidFunctionNames) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidFunctionNames returns new instance of InvalidFunctionNames error.
func NewInvalidFunctionNames(functionNamesArg []string) *InvalidFunctionNames {
	return &InvalidFunctionNames{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidFunctionNames: invalidFunctionNames{FunctionNames: functionNamesArg}}
}

// WrapWithInvalidFunctionNames returns new instance of InvalidFunctionNames error wrapping an existing error.
func WrapWithInvalidFunctionNames(err error, functionNamesArg []string) *InvalidFunctionNames {
	return &InvalidFunctionNames{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidFunctionNames: invalidFunctionNames{FunctionNames: functionNamesArg}}
}

// InvalidFunctionNames is an error type.
/*
One or more function names are invalid.
Function names must begin with a letter and can only contain letters, numbers, and underscores.
*/
type InvalidFunctionNames struct {
	errorInstanceID uuid.UUID
	invalidFunctionNames
	cause error
	stack werror.StackTrace
}

// IsInvalidFunctionNames returns true if err is an instance of InvalidFunctionNames.
func IsInvalidFunctionNames(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidFunctionNames)
	return ok
}

func (e *InvalidFunctionNames) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Module:InvalidFunctionNames (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidFunctionNames) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidFunctionNames) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidFunctionNames) Message() string {
	return "INVALID_ARGUMENT Module:InvalidFunctionNames"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidFunctionNames) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidFunctionNames) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidFunctionNames) Name() string {
	return "Module:InvalidFunctionNames"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidFunctionNames) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidFunctionNames) Parameters() map[string]interface{} {
	return map[string]interface{}{"functionNames": e.FunctionNames}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidFunctionNames) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidFunctionNames) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidFunctionNames) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"functionNames": e.FunctionNames}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidFunctionNames) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidFunctionNames) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidFunctionNames)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Module:InvalidFunctionNames", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidFunctionNames) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidFunctionNames
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidFunctionNames = parameters
	return nil
}

type invalidModuleApiName struct {
	ModuleApiName string `json:"moduleApiName"`
}

func (o invalidModuleApiName) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidModuleApiName) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidModuleApiName returns new instance of InvalidModuleApiName error.
func NewInvalidModuleApiName(moduleApiNameArg string) *InvalidModuleApiName {
	return &InvalidModuleApiName{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidModuleApiName: invalidModuleApiName{ModuleApiName: moduleApiNameArg}}
}

// WrapWithInvalidModuleApiName returns new instance of InvalidModuleApiName error wrapping an existing error.
func WrapWithInvalidModuleApiName(err error, moduleApiNameArg string) *InvalidModuleApiName {
	return &InvalidModuleApiName{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidModuleApiName: invalidModuleApiName{ModuleApiName: moduleApiNameArg}}
}

// InvalidModuleApiName is an error type.
/*
The provided module API name is invalid.
Module names must begin with a letter and can only contain letters, numbers, and underscores.
*/
type InvalidModuleApiName struct {
	errorInstanceID uuid.UUID
	invalidModuleApiName
	cause error
	stack werror.StackTrace
}

// IsInvalidModuleApiName returns true if err is an instance of InvalidModuleApiName.
func IsInvalidModuleApiName(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidModuleApiName)
	return ok
}

func (e *InvalidModuleApiName) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Module:InvalidModuleApiName (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidModuleApiName) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidModuleApiName) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidModuleApiName) Message() string {
	return "INVALID_ARGUMENT Module:InvalidModuleApiName"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidModuleApiName) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidModuleApiName) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidModuleApiName) Name() string {
	return "Module:InvalidModuleApiName"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidModuleApiName) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidModuleApiName) Parameters() map[string]interface{} {
	return map[string]interface{}{"moduleApiName": e.ModuleApiName}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidModuleApiName) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidModuleApiName) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidModuleApiName) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"moduleApiName": e.ModuleApiName}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidModuleApiName) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidModuleApiName) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidModuleApiName)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Module:InvalidModuleApiName", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidModuleApiName) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidModuleApiName
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidModuleApiName = parameters
	return nil
}

type invalidModuleVersionString struct {
	Version string `json:"version"`
}

func (o invalidModuleVersionString) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidModuleVersionString) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidModuleVersionString returns new instance of InvalidModuleVersionString error.
func NewInvalidModuleVersionString(versionArg string) *InvalidModuleVersionString {
	return &InvalidModuleVersionString{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidModuleVersionString: invalidModuleVersionString{Version: versionArg}}
}

// WrapWithInvalidModuleVersionString returns new instance of InvalidModuleVersionString error wrapping an existing error.
func WrapWithInvalidModuleVersionString(err error, versionArg string) *InvalidModuleVersionString {
	return &InvalidModuleVersionString{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidModuleVersionString: invalidModuleVersionString{Version: versionArg}}
}

// InvalidModuleVersionString is an error type.
/*
The provided module version string is invalid.
Module version strings must be of the form "MAJOR", where MAJOR is a non-negative integer.
*/
type InvalidModuleVersionString struct {
	errorInstanceID uuid.UUID
	invalidModuleVersionString
	cause error
	stack werror.StackTrace
}

// IsInvalidModuleVersionString returns true if err is an instance of InvalidModuleVersionString.
func IsInvalidModuleVersionString(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidModuleVersionString)
	return ok
}

func (e *InvalidModuleVersionString) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Module:InvalidModuleVersionString (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidModuleVersionString) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidModuleVersionString) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidModuleVersionString) Message() string {
	return "INVALID_ARGUMENT Module:InvalidModuleVersionString"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidModuleVersionString) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidModuleVersionString) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidModuleVersionString) Name() string {
	return "Module:InvalidModuleVersionString"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidModuleVersionString) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidModuleVersionString) Parameters() map[string]interface{} {
	return map[string]interface{}{"version": e.Version}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidModuleVersionString) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidModuleVersionString) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidModuleVersionString) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"version": e.Version}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidModuleVersionString) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidModuleVersionString) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidModuleVersionString)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Module:InvalidModuleVersionString", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidModuleVersionString) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidModuleVersionString
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidModuleVersionString = parameters
	return nil
}

type invalidNestedFunctionReferences struct {
	FunctionName []string `json:"functionName"`
}

func (o invalidNestedFunctionReferences) MarshalJSON() ([]byte, error) {
	if o.FunctionName == nil {
		o.FunctionName = make([]string, 0)
	}
	type _tmpinvalidNestedFunctionReferences invalidNestedFunctionReferences
	return safejson.Marshal(_tmpinvalidNestedFunctionReferences(o))
}

func (o *invalidNestedFunctionReferences) UnmarshalJSON(data []byte) error {
	type _tmpinvalidNestedFunctionReferences invalidNestedFunctionReferences
	var rawinvalidNestedFunctionReferences _tmpinvalidNestedFunctionReferences
	if err := safejson.Unmarshal(data, &rawinvalidNestedFunctionReferences); err != nil {
		return err
	}
	if rawinvalidNestedFunctionReferences.FunctionName == nil {
		rawinvalidNestedFunctionReferences.FunctionName = make([]string, 0)
	}
	*o = invalidNestedFunctionReferences(rawinvalidNestedFunctionReferences)
	return nil
}

func (o invalidNestedFunctionReferences) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidNestedFunctionReferences) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidNestedFunctionReferences returns new instance of InvalidNestedFunctionReferences error.
func NewInvalidNestedFunctionReferences(functionNameArg []string) *InvalidNestedFunctionReferences {
	return &InvalidNestedFunctionReferences{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidNestedFunctionReferences: invalidNestedFunctionReferences{FunctionName: functionNameArg}}
}

// WrapWithInvalidNestedFunctionReferences returns new instance of InvalidNestedFunctionReferences error wrapping an existing error.
func WrapWithInvalidNestedFunctionReferences(err error, functionNameArg []string) *InvalidNestedFunctionReferences {
	return &InvalidNestedFunctionReferences{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidNestedFunctionReferences: invalidNestedFunctionReferences{FunctionName: functionNameArg}}
}

// InvalidNestedFunctionReferences is an error type.
/*
One or more functions contain invalid nested function references.
Functions cannot reference other functions that are not defined in the same module.
*/
type InvalidNestedFunctionReferences struct {
	errorInstanceID uuid.UUID
	invalidNestedFunctionReferences
	cause error
	stack werror.StackTrace
}

// IsInvalidNestedFunctionReferences returns true if err is an instance of InvalidNestedFunctionReferences.
func IsInvalidNestedFunctionReferences(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidNestedFunctionReferences)
	return ok
}

func (e *InvalidNestedFunctionReferences) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Module:InvalidNestedFunctionReferences (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidNestedFunctionReferences) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidNestedFunctionReferences) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidNestedFunctionReferences) Message() string {
	return "INVALID_ARGUMENT Module:InvalidNestedFunctionReferences"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidNestedFunctionReferences) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidNestedFunctionReferences) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidNestedFunctionReferences) Name() string {
	return "Module:InvalidNestedFunctionReferences"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidNestedFunctionReferences) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidNestedFunctionReferences) Parameters() map[string]interface{} {
	return map[string]interface{}{"functionName": e.FunctionName}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidNestedFunctionReferences) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidNestedFunctionReferences) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidNestedFunctionReferences) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"functionName": e.FunctionName}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidNestedFunctionReferences) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidNestedFunctionReferences) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidNestedFunctionReferences)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Module:InvalidNestedFunctionReferences", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidNestedFunctionReferences) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidNestedFunctionReferences
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidNestedFunctionReferences = parameters
	return nil
}

type invalidParameterNames struct {
	ParameterName []string `json:"parameterName"`
}

func (o invalidParameterNames) MarshalJSON() ([]byte, error) {
	if o.ParameterName == nil {
		o.ParameterName = make([]string, 0)
	}
	type _tmpinvalidParameterNames invalidParameterNames
	return safejson.Marshal(_tmpinvalidParameterNames(o))
}

func (o *invalidParameterNames) UnmarshalJSON(data []byte) error {
	type _tmpinvalidParameterNames invalidParameterNames
	var rawinvalidParameterNames _tmpinvalidParameterNames
	if err := safejson.Unmarshal(data, &rawinvalidParameterNames); err != nil {
		return err
	}
	if rawinvalidParameterNames.ParameterName == nil {
		rawinvalidParameterNames.ParameterName = make([]string, 0)
	}
	*o = invalidParameterNames(rawinvalidParameterNames)
	return nil
}

func (o invalidParameterNames) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidParameterNames) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidParameterNames returns new instance of InvalidParameterNames error.
func NewInvalidParameterNames(parameterNameArg []string) *InvalidParameterNames {
	return &InvalidParameterNames{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidParameterNames: invalidParameterNames{ParameterName: parameterNameArg}}
}

// WrapWithInvalidParameterNames returns new instance of InvalidParameterNames error wrapping an existing error.
func WrapWithInvalidParameterNames(err error, parameterNameArg []string) *InvalidParameterNames {
	return &InvalidParameterNames{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidParameterNames: invalidParameterNames{ParameterName: parameterNameArg}}
}

// InvalidParameterNames is an error type.
/*
One or more parameter names are invalid.
Parameter names must begin with a letter and can only contain letters, numbers, and underscores.
*/
type InvalidParameterNames struct {
	errorInstanceID uuid.UUID
	invalidParameterNames
	cause error
	stack werror.StackTrace
}

// IsInvalidParameterNames returns true if err is an instance of InvalidParameterNames.
func IsInvalidParameterNames(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidParameterNames)
	return ok
}

func (e *InvalidParameterNames) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Module:InvalidParameterNames (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidParameterNames) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidParameterNames) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidParameterNames) Message() string {
	return "INVALID_ARGUMENT Module:InvalidParameterNames"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidParameterNames) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidParameterNames) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidParameterNames) Name() string {
	return "Module:InvalidParameterNames"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidParameterNames) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidParameterNames) Parameters() map[string]interface{} {
	return map[string]interface{}{"parameterName": e.ParameterName}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidParameterNames) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidParameterNames) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidParameterNames) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"parameterName": e.ParameterName}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidParameterNames) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidParameterNames) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidParameterNames)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Module:InvalidParameterNames", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidParameterNames) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidParameterNames
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidParameterNames = parameters
	return nil
}

type moduleNameConflict struct {
	ModuleApiName string `json:"moduleApiName"`
}

func (o moduleNameConflict) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *moduleNameConflict) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewModuleNameConflict returns new instance of ModuleNameConflict error.
func NewModuleNameConflict(moduleApiNameArg string) *ModuleNameConflict {
	return &ModuleNameConflict{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), moduleNameConflict: moduleNameConflict{ModuleApiName: moduleApiNameArg}}
}

// WrapWithModuleNameConflict returns new instance of ModuleNameConflict error wrapping an existing error.
func WrapWithModuleNameConflict(err error, moduleApiNameArg string) *ModuleNameConflict {
	return &ModuleNameConflict{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, moduleNameConflict: moduleNameConflict{ModuleApiName: moduleApiNameArg}}
}

// ModuleNameConflict is an error type.
// A module with the given API name already exists in the current organization.
type ModuleNameConflict struct {
	errorInstanceID uuid.UUID
	moduleNameConflict
	cause error
	stack werror.StackTrace
}

// IsModuleNameConflict returns true if err is an instance of ModuleNameConflict.
func IsModuleNameConflict(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ModuleNameConflict)
	return ok
}

func (e *ModuleNameConflict) Error() string {
	return fmt.Sprintf("CONFLICT Module:ModuleNameConflict (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ModuleNameConflict) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ModuleNameConflict) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ModuleNameConflict) Message() string {
	return "CONFLICT Module:ModuleNameConflict"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ModuleNameConflict) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ModuleNameConflict) Code() errors.ErrorCode {
	return errors.Conflict
}

// Name returns an error name identifying error type.
func (e *ModuleNameConflict) Name() string {
	return "Module:ModuleNameConflict"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ModuleNameConflict) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ModuleNameConflict) Parameters() map[string]interface{} {
	return map[string]interface{}{"moduleApiName": e.ModuleApiName}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ModuleNameConflict) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ModuleNameConflict) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ModuleNameConflict) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"moduleApiName": e.ModuleApiName}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ModuleNameConflict) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ModuleNameConflict) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.moduleNameConflict)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Conflict, ErrorName: "Module:ModuleNameConflict", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ModuleNameConflict) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters moduleNameConflict
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.moduleNameConflict = parameters
	return nil
}

type moduleRidsNotFound struct {
	ModuleRids []api.ModuleRid `json:"moduleRids"`
}

func (o moduleRidsNotFound) MarshalJSON() ([]byte, error) {
	if o.ModuleRids == nil {
		o.ModuleRids = make([]api.ModuleRid, 0)
	}
	type _tmpmoduleRidsNotFound moduleRidsNotFound
	return safejson.Marshal(_tmpmoduleRidsNotFound(o))
}

func (o *moduleRidsNotFound) UnmarshalJSON(data []byte) error {
	type _tmpmoduleRidsNotFound moduleRidsNotFound
	var rawmoduleRidsNotFound _tmpmoduleRidsNotFound
	if err := safejson.Unmarshal(data, &rawmoduleRidsNotFound); err != nil {
		return err
	}
	if rawmoduleRidsNotFound.ModuleRids == nil {
		rawmoduleRidsNotFound.ModuleRids = make([]api.ModuleRid, 0)
	}
	*o = moduleRidsNotFound(rawmoduleRidsNotFound)
	return nil
}

func (o moduleRidsNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *moduleRidsNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewModuleRidsNotFound returns new instance of ModuleRidsNotFound error.
func NewModuleRidsNotFound(moduleRidsArg []api.ModuleRid) *ModuleRidsNotFound {
	return &ModuleRidsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), moduleRidsNotFound: moduleRidsNotFound{ModuleRids: moduleRidsArg}}
}

// WrapWithModuleRidsNotFound returns new instance of ModuleRidsNotFound error wrapping an existing error.
func WrapWithModuleRidsNotFound(err error, moduleRidsArg []api.ModuleRid) *ModuleRidsNotFound {
	return &ModuleRidsNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, moduleRidsNotFound: moduleRidsNotFound{ModuleRids: moduleRidsArg}}
}

// ModuleRidsNotFound is an error type.
// One or more modules were not found in the current workspace.
type ModuleRidsNotFound struct {
	errorInstanceID uuid.UUID
	moduleRidsNotFound
	cause error
	stack werror.StackTrace
}

// IsModuleRidsNotFound returns true if err is an instance of ModuleRidsNotFound.
func IsModuleRidsNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ModuleRidsNotFound)
	return ok
}

func (e *ModuleRidsNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Module:ModuleRidsNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ModuleRidsNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ModuleRidsNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ModuleRidsNotFound) Message() string {
	return "NOT_FOUND Module:ModuleRidsNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ModuleRidsNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ModuleRidsNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *ModuleRidsNotFound) Name() string {
	return "Module:ModuleRidsNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ModuleRidsNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ModuleRidsNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"moduleRids": e.ModuleRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ModuleRidsNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"moduleRids": e.ModuleRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ModuleRidsNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ModuleRidsNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ModuleRidsNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ModuleRidsNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.moduleRidsNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Module:ModuleRidsNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ModuleRidsNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters moduleRidsNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.moduleRidsNotFound = parameters
	return nil
}

type modulesNotFound struct {
	ModuleRefs []RequestModuleRef `json:"moduleRefs"`
}

func (o modulesNotFound) MarshalJSON() ([]byte, error) {
	if o.ModuleRefs == nil {
		o.ModuleRefs = make([]RequestModuleRef, 0)
	}
	type _tmpmodulesNotFound modulesNotFound
	return safejson.Marshal(_tmpmodulesNotFound(o))
}

func (o *modulesNotFound) UnmarshalJSON(data []byte) error {
	type _tmpmodulesNotFound modulesNotFound
	var rawmodulesNotFound _tmpmodulesNotFound
	if err := safejson.Unmarshal(data, &rawmodulesNotFound); err != nil {
		return err
	}
	if rawmodulesNotFound.ModuleRefs == nil {
		rawmodulesNotFound.ModuleRefs = make([]RequestModuleRef, 0)
	}
	*o = modulesNotFound(rawmodulesNotFound)
	return nil
}

func (o modulesNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *modulesNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewModulesNotFound returns new instance of ModulesNotFound error.
func NewModulesNotFound(moduleRefsArg []RequestModuleRef) *ModulesNotFound {
	return &ModulesNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), modulesNotFound: modulesNotFound{ModuleRefs: moduleRefsArg}}
}

// WrapWithModulesNotFound returns new instance of ModulesNotFound error wrapping an existing error.
func WrapWithModulesNotFound(err error, moduleRefsArg []RequestModuleRef) *ModulesNotFound {
	return &ModulesNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, modulesNotFound: modulesNotFound{ModuleRefs: moduleRefsArg}}
}

// ModulesNotFound is an error type.
// One or more modules were not found in the current workspace.
type ModulesNotFound struct {
	errorInstanceID uuid.UUID
	modulesNotFound
	cause error
	stack werror.StackTrace
}

// IsModulesNotFound returns true if err is an instance of ModulesNotFound.
func IsModulesNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ModulesNotFound)
	return ok
}

func (e *ModulesNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND Module:ModulesNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ModulesNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ModulesNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ModulesNotFound) Message() string {
	return "NOT_FOUND Module:ModulesNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ModulesNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ModulesNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *ModulesNotFound) Name() string {
	return "Module:ModulesNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ModulesNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ModulesNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"moduleRefs": e.ModuleRefs}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ModulesNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ModulesNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ModulesNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"moduleRefs": e.ModuleRefs}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ModulesNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ModulesNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.modulesNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "Module:ModulesNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ModulesNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters modulesNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.modulesNotFound = parameters
	return nil
}

type parameterNameConflict struct {
	ParameterNames []string `json:"parameterNames"`
}

func (o parameterNameConflict) MarshalJSON() ([]byte, error) {
	if o.ParameterNames == nil {
		o.ParameterNames = make([]string, 0)
	}
	type _tmpparameterNameConflict parameterNameConflict
	return safejson.Marshal(_tmpparameterNameConflict(o))
}

func (o *parameterNameConflict) UnmarshalJSON(data []byte) error {
	type _tmpparameterNameConflict parameterNameConflict
	var rawparameterNameConflict _tmpparameterNameConflict
	if err := safejson.Unmarshal(data, &rawparameterNameConflict); err != nil {
		return err
	}
	if rawparameterNameConflict.ParameterNames == nil {
		rawparameterNameConflict.ParameterNames = make([]string, 0)
	}
	*o = parameterNameConflict(rawparameterNameConflict)
	return nil
}

func (o parameterNameConflict) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *parameterNameConflict) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewParameterNameConflict returns new instance of ParameterNameConflict error.
func NewParameterNameConflict(parameterNamesArg []string) *ParameterNameConflict {
	return &ParameterNameConflict{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), parameterNameConflict: parameterNameConflict{ParameterNames: parameterNamesArg}}
}

// WrapWithParameterNameConflict returns new instance of ParameterNameConflict error wrapping an existing error.
func WrapWithParameterNameConflict(err error, parameterNamesArg []string) *ParameterNameConflict {
	return &ParameterNameConflict{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, parameterNameConflict: parameterNameConflict{ParameterNames: parameterNamesArg}}
}

// ParameterNameConflict is an error type.
// One or more parameter names conflict with each other in the module definition.
type ParameterNameConflict struct {
	errorInstanceID uuid.UUID
	parameterNameConflict
	cause error
	stack werror.StackTrace
}

// IsParameterNameConflict returns true if err is an instance of ParameterNameConflict.
func IsParameterNameConflict(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ParameterNameConflict)
	return ok
}

func (e *ParameterNameConflict) Error() string {
	return fmt.Sprintf("CONFLICT Module:ParameterNameConflict (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ParameterNameConflict) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ParameterNameConflict) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ParameterNameConflict) Message() string {
	return "CONFLICT Module:ParameterNameConflict"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ParameterNameConflict) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ParameterNameConflict) Code() errors.ErrorCode {
	return errors.Conflict
}

// Name returns an error name identifying error type.
func (e *ParameterNameConflict) Name() string {
	return "Module:ParameterNameConflict"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ParameterNameConflict) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ParameterNameConflict) Parameters() map[string]interface{} {
	return map[string]interface{}{"parameterNames": e.ParameterNames}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ParameterNameConflict) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ParameterNameConflict) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ParameterNameConflict) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"parameterNames": e.ParameterNames}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ParameterNameConflict) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ParameterNameConflict) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.parameterNameConflict)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Conflict, ErrorName: "Module:ParameterNameConflict", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ParameterNameConflict) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters parameterNameConflict
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.parameterNameConflict = parameters
	return nil
}

type undefinedModuleFunctionReference struct {
	InvalidFunctionReference string `json:"invalidFunctionReference"`
}

func (o undefinedModuleFunctionReference) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *undefinedModuleFunctionReference) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewUndefinedModuleFunctionReference returns new instance of UndefinedModuleFunctionReference error.
func NewUndefinedModuleFunctionReference(invalidFunctionReferenceArg string) *UndefinedModuleFunctionReference {
	return &UndefinedModuleFunctionReference{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), undefinedModuleFunctionReference: undefinedModuleFunctionReference{InvalidFunctionReference: invalidFunctionReferenceArg}}
}

// WrapWithUndefinedModuleFunctionReference returns new instance of UndefinedModuleFunctionReference error wrapping an existing error.
func WrapWithUndefinedModuleFunctionReference(err error, invalidFunctionReferenceArg string) *UndefinedModuleFunctionReference {
	return &UndefinedModuleFunctionReference{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, undefinedModuleFunctionReference: undefinedModuleFunctionReference{InvalidFunctionReference: invalidFunctionReferenceArg}}
}

// UndefinedModuleFunctionReference is an error type.
// The following function reference is undefined in the module.
type UndefinedModuleFunctionReference struct {
	errorInstanceID uuid.UUID
	undefinedModuleFunctionReference
	cause error
	stack werror.StackTrace
}

// IsUndefinedModuleFunctionReference returns true if err is an instance of UndefinedModuleFunctionReference.
func IsUndefinedModuleFunctionReference(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*UndefinedModuleFunctionReference)
	return ok
}

func (e *UndefinedModuleFunctionReference) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT Module:UndefinedModuleFunctionReference (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *UndefinedModuleFunctionReference) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *UndefinedModuleFunctionReference) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *UndefinedModuleFunctionReference) Message() string {
	return "INVALID_ARGUMENT Module:UndefinedModuleFunctionReference"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *UndefinedModuleFunctionReference) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *UndefinedModuleFunctionReference) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *UndefinedModuleFunctionReference) Name() string {
	return "Module:UndefinedModuleFunctionReference"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *UndefinedModuleFunctionReference) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *UndefinedModuleFunctionReference) Parameters() map[string]interface{} {
	return map[string]interface{}{"invalidFunctionReference": e.InvalidFunctionReference}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *UndefinedModuleFunctionReference) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *UndefinedModuleFunctionReference) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *UndefinedModuleFunctionReference) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"invalidFunctionReference": e.InvalidFunctionReference}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *UndefinedModuleFunctionReference) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e UndefinedModuleFunctionReference) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.undefinedModuleFunctionReference)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "Module:UndefinedModuleFunctionReference", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *UndefinedModuleFunctionReference) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters undefinedModuleFunctionReference
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.undefinedModuleFunctionReference = parameters
	return nil
}

type variableNameConflict struct {
	VariableName []string `json:"variableName"`
}

func (o variableNameConflict) MarshalJSON() ([]byte, error) {
	if o.VariableName == nil {
		o.VariableName = make([]string, 0)
	}
	type _tmpvariableNameConflict variableNameConflict
	return safejson.Marshal(_tmpvariableNameConflict(o))
}

func (o *variableNameConflict) UnmarshalJSON(data []byte) error {
	type _tmpvariableNameConflict variableNameConflict
	var rawvariableNameConflict _tmpvariableNameConflict
	if err := safejson.Unmarshal(data, &rawvariableNameConflict); err != nil {
		return err
	}
	if rawvariableNameConflict.VariableName == nil {
		rawvariableNameConflict.VariableName = make([]string, 0)
	}
	*o = variableNameConflict(rawvariableNameConflict)
	return nil
}

func (o variableNameConflict) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *variableNameConflict) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewVariableNameConflict returns new instance of VariableNameConflict error.
func NewVariableNameConflict(variableNameArg []string) *VariableNameConflict {
	return &VariableNameConflict{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), variableNameConflict: variableNameConflict{VariableName: variableNameArg}}
}

// WrapWithVariableNameConflict returns new instance of VariableNameConflict error wrapping an existing error.
func WrapWithVariableNameConflict(err error, variableNameArg []string) *VariableNameConflict {
	return &VariableNameConflict{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, variableNameConflict: variableNameConflict{VariableName: variableNameArg}}
}

// VariableNameConflict is an error type.
// One or more variable names conflict with each other in the module definition.
type VariableNameConflict struct {
	errorInstanceID uuid.UUID
	variableNameConflict
	cause error
	stack werror.StackTrace
}

// IsVariableNameConflict returns true if err is an instance of VariableNameConflict.
func IsVariableNameConflict(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*VariableNameConflict)
	return ok
}

func (e *VariableNameConflict) Error() string {
	return fmt.Sprintf("CONFLICT Module:VariableNameConflict (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *VariableNameConflict) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *VariableNameConflict) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *VariableNameConflict) Message() string {
	return "CONFLICT Module:VariableNameConflict"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *VariableNameConflict) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *VariableNameConflict) Code() errors.ErrorCode {
	return errors.Conflict
}

// Name returns an error name identifying error type.
func (e *VariableNameConflict) Name() string {
	return "Module:VariableNameConflict"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *VariableNameConflict) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *VariableNameConflict) Parameters() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *VariableNameConflict) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *VariableNameConflict) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *VariableNameConflict) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"variableName": e.VariableName}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *VariableNameConflict) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e VariableNameConflict) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.variableNameConflict)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Conflict, ErrorName: "Module:VariableNameConflict", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *VariableNameConflict) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters variableNameConflict
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.variableNameConflict = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("Module:CyclicModuleFunctionDefinitions", reflect.TypeOf(CyclicModuleFunctionDefinitions{}))
	conjureerrors.RegisterErrorType("Module:FunctionNameConflict", reflect.TypeOf(FunctionNameConflict{}))
	conjureerrors.RegisterErrorType("Module:InvalidFunctionNames", reflect.TypeOf(InvalidFunctionNames{}))
	conjureerrors.RegisterErrorType("Module:InvalidModuleApiName", reflect.TypeOf(InvalidModuleApiName{}))
	conjureerrors.RegisterErrorType("Module:InvalidModuleVersionString", reflect.TypeOf(InvalidModuleVersionString{}))
	conjureerrors.RegisterErrorType("Module:InvalidNestedFunctionReferences", reflect.TypeOf(InvalidNestedFunctionReferences{}))
	conjureerrors.RegisterErrorType("Module:InvalidParameterNames", reflect.TypeOf(InvalidParameterNames{}))
	conjureerrors.RegisterErrorType("Module:ModuleNameConflict", reflect.TypeOf(ModuleNameConflict{}))
	conjureerrors.RegisterErrorType("Module:ModuleRidsNotFound", reflect.TypeOf(ModuleRidsNotFound{}))
	conjureerrors.RegisterErrorType("Module:ModulesNotFound", reflect.TypeOf(ModulesNotFound{}))
	conjureerrors.RegisterErrorType("Module:ParameterNameConflict", reflect.TypeOf(ParameterNameConflict{}))
	conjureerrors.RegisterErrorType("Module:UndefinedModuleFunctionReference", reflect.TypeOf(UndefinedModuleFunctionReference{}))
	conjureerrors.RegisterErrorType("Module:VariableNameConflict", reflect.TypeOf(VariableNameConflict{}))
}
