// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package module

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	api1 "github.com/nominal-io/nominal-api-go/modules/api"
	"github.com/nominal-io/nominal-api-go/scout/compute/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/rids/api"
)

type FunctionNodeWithT[T any] FunctionNode

func (u *FunctionNodeWithT[T]) Accept(ctx context.Context, v FunctionNodeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(ctx, *u.numeric)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(ctx, *u.ranges)
	}
}

func (u *FunctionNodeWithT[T]) AcceptFuncs(enumFunc func(api.EnumSeries) (T, error), numericFunc func(api.NumericSeries) (T, error), rangesFunc func(api.RangeSeries) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return result, fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "ranges":
		if u.ranges == nil {
			return result, fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	}
}

func (u *FunctionNodeWithT[T]) EnumNoopSuccess(api.EnumSeries) (T, error) {
	var result T
	return result, nil
}

func (u *FunctionNodeWithT[T]) NumericNoopSuccess(api.NumericSeries) (T, error) {
	var result T
	return result, nil
}

func (u *FunctionNodeWithT[T]) RangesNoopSuccess(api.RangeSeries) (T, error) {
	var result T
	return result, nil
}

func (u *FunctionNodeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type FunctionNodeVisitorWithT[T any] interface {
	VisitEnum(ctx context.Context, v api.EnumSeries) (T, error)
	VisitNumeric(ctx context.Context, v api.NumericSeries) (T, error)
	VisitRanges(ctx context.Context, v api.RangeSeries) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type RequestModuleRefWithT[T any] RequestModuleRef

func (u *RequestModuleRefWithT[T]) Accept(ctx context.Context, v RequestModuleRefVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "name":
		if u.name == nil {
			return result, fmt.Errorf("field \"name\" is required")
		}
		return v.VisitName(ctx, *u.name)
	}
}

func (u *RequestModuleRefWithT[T]) AcceptFuncs(nameFunc func(RequestModuleNameRef) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "name":
		if u.name == nil {
			return result, fmt.Errorf("field \"name\" is required")
		}
		return nameFunc(*u.name)
	}
}

func (u *RequestModuleRefWithT[T]) NameNoopSuccess(RequestModuleNameRef) (T, error) {
	var result T
	return result, nil
}

func (u *RequestModuleRefWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type RequestModuleRefVisitorWithT[T any] interface {
	VisitName(ctx context.Context, v RequestModuleNameRef) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SearchModuleApplicationsQueryWithT[T any] SearchModuleApplicationsQuery

func (u *SearchModuleApplicationsQueryWithT[T]) Accept(ctx context.Context, v SearchModuleApplicationsQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "moduleRid":
		if u.moduleRid == nil {
			return result, fmt.Errorf("field \"moduleRid\" is required")
		}
		return v.VisitModuleRid(ctx, *u.moduleRid)
	case "assetRid":
		if u.assetRid == nil {
			return result, fmt.Errorf("field \"assetRid\" is required")
		}
		return v.VisitAssetRid(ctx, *u.assetRid)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(ctx, *u.not)
	}
}

func (u *SearchModuleApplicationsQueryWithT[T]) AcceptFuncs(moduleRidFunc func(api1.ModuleRid) (T, error), assetRidFunc func(api2.AssetRid) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), andFunc func([]SearchModuleApplicationsQuery) (T, error), orFunc func([]SearchModuleApplicationsQuery) (T, error), notFunc func(SearchModuleApplicationsQuery) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "moduleRid":
		if u.moduleRid == nil {
			return result, fmt.Errorf("field \"moduleRid\" is required")
		}
		return moduleRidFunc(*u.moduleRid)
	case "assetRid":
		if u.assetRid == nil {
			return result, fmt.Errorf("field \"assetRid\" is required")
		}
		return assetRidFunc(*u.assetRid)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	}
}

func (u *SearchModuleApplicationsQueryWithT[T]) ModuleRidNoopSuccess(api1.ModuleRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModuleApplicationsQueryWithT[T]) AssetRidNoopSuccess(api2.AssetRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModuleApplicationsQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModuleApplicationsQueryWithT[T]) AndNoopSuccess([]SearchModuleApplicationsQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModuleApplicationsQueryWithT[T]) OrNoopSuccess([]SearchModuleApplicationsQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModuleApplicationsQueryWithT[T]) NotNoopSuccess(SearchModuleApplicationsQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModuleApplicationsQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchModuleApplicationsQueryVisitorWithT[T any] interface {
	VisitModuleRid(ctx context.Context, v api1.ModuleRid) (T, error)
	VisitAssetRid(ctx context.Context, v api2.AssetRid) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitAnd(ctx context.Context, v []SearchModuleApplicationsQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchModuleApplicationsQuery) (T, error)
	VisitNot(ctx context.Context, v SearchModuleApplicationsQuery) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type SearchModulesQueryWithT[T any] SearchModulesQuery

func (u *SearchModulesQueryWithT[T]) Accept(ctx context.Context, v SearchModulesQueryVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(ctx, *u.searchText)
	case "createdBy":
		if u.createdBy == nil {
			return result, fmt.Errorf("field \"createdBy\" is required")
		}
		return v.VisitCreatedBy(ctx, *u.createdBy)
	case "lastUpdatedBy":
		if u.lastUpdatedBy == nil {
			return result, fmt.Errorf("field \"lastUpdatedBy\" is required")
		}
		return v.VisitLastUpdatedBy(ctx, *u.lastUpdatedBy)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(ctx, *u.workspace)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(ctx, *u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(ctx, *u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(ctx, *u.not)
	}
}

func (u *SearchModulesQueryWithT[T]) AcceptFuncs(searchTextFunc func(string) (T, error), createdByFunc func(api2.UserRid) (T, error), lastUpdatedByFunc func(api2.UserRid) (T, error), workspaceFunc func(rids.WorkspaceRid) (T, error), andFunc func([]SearchModulesQuery) (T, error), orFunc func([]SearchModulesQuery) (T, error), notFunc func(SearchModulesQuery) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return result, fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "createdBy":
		if u.createdBy == nil {
			return result, fmt.Errorf("field \"createdBy\" is required")
		}
		return createdByFunc(*u.createdBy)
	case "lastUpdatedBy":
		if u.lastUpdatedBy == nil {
			return result, fmt.Errorf("field \"lastUpdatedBy\" is required")
		}
		return lastUpdatedByFunc(*u.lastUpdatedBy)
	case "workspace":
		if u.workspace == nil {
			return result, fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	case "and":
		if u.and == nil {
			return result, fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return result, fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return result, fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	}
}

func (u *SearchModulesQueryWithT[T]) SearchTextNoopSuccess(string) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModulesQueryWithT[T]) CreatedByNoopSuccess(api2.UserRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModulesQueryWithT[T]) LastUpdatedByNoopSuccess(api2.UserRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModulesQueryWithT[T]) WorkspaceNoopSuccess(rids.WorkspaceRid) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModulesQueryWithT[T]) AndNoopSuccess([]SearchModulesQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModulesQueryWithT[T]) OrNoopSuccess([]SearchModulesQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModulesQueryWithT[T]) NotNoopSuccess(SearchModulesQuery) (T, error) {
	var result T
	return result, nil
}

func (u *SearchModulesQueryWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type SearchModulesQueryVisitorWithT[T any] interface {
	VisitSearchText(ctx context.Context, v string) (T, error)
	VisitCreatedBy(ctx context.Context, v api2.UserRid) (T, error)
	VisitLastUpdatedBy(ctx context.Context, v api2.UserRid) (T, error)
	VisitWorkspace(ctx context.Context, v rids.WorkspaceRid) (T, error)
	VisitAnd(ctx context.Context, v []SearchModulesQuery) (T, error)
	VisitOr(ctx context.Context, v []SearchModulesQuery) (T, error)
	VisitNot(ctx context.Context, v SearchModulesQuery) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type VersionStrategyWithT[T any] VersionStrategy

func (u *VersionStrategyWithT[T]) Accept(ctx context.Context, v VersionStrategyVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "pinned":
		if u.pinned == nil {
			return result, fmt.Errorf("field \"pinned\" is required")
		}
		return v.VisitPinned(ctx, *u.pinned)
	case "latest":
		if u.latest == nil {
			return result, fmt.Errorf("field \"latest\" is required")
		}
		return v.VisitLatest(ctx, *u.latest)
	}
}

func (u *VersionStrategyWithT[T]) AcceptFuncs(pinnedFunc func(PinnedVersionStrategy) (T, error), latestFunc func(LatestVersionStrategy) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pinned":
		if u.pinned == nil {
			return result, fmt.Errorf("field \"pinned\" is required")
		}
		return pinnedFunc(*u.pinned)
	case "latest":
		if u.latest == nil {
			return result, fmt.Errorf("field \"latest\" is required")
		}
		return latestFunc(*u.latest)
	}
}

func (u *VersionStrategyWithT[T]) PinnedNoopSuccess(PinnedVersionStrategy) (T, error) {
	var result T
	return result, nil
}

func (u *VersionStrategyWithT[T]) LatestNoopSuccess(LatestVersionStrategy) (T, error) {
	var result T
	return result, nil
}

func (u *VersionStrategyWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type VersionStrategyVisitorWithT[T any] interface {
	VisitPinned(ctx context.Context, v PinnedVersionStrategy) (T, error)
	VisitLatest(ctx context.Context, v LatestVersionStrategy) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
