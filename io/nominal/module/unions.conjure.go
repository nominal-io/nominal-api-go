// Code generated by conjure-go. DO NOT EDIT.

package module

import (
	"context"
	"fmt"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/scout/compute/api1"
	"github.com/nominal-io/nominal-api-go/scout/rids/api"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type FunctionNode struct {
	typ     string
	enum    *api1.EnumSeries
	numeric *api1.NumericSeries
	ranges  *api1.RangeSeries
}

type functionNodeDeserializer struct {
	Type    string              `json:"type"`
	Enum    *api1.EnumSeries    `json:"enum"`
	Numeric *api1.NumericSeries `json:"numeric"`
	Ranges  *api1.RangeSeries   `json:"ranges"`
}

func (u *functionNodeDeserializer) toStruct() FunctionNode {
	return FunctionNode{typ: u.Type, enum: u.Enum, numeric: u.Numeric, ranges: u.Ranges}
}

func (u *FunctionNode) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "enum":
		if u.enum == nil {
			return nil, fmt.Errorf("field \"enum\" is required")
		}
		return struct {
			Type string          `json:"type"`
			Enum api1.EnumSeries `json:"enum"`
		}{Type: "enum", Enum: *u.enum}, nil
	case "numeric":
		if u.numeric == nil {
			return nil, fmt.Errorf("field \"numeric\" is required")
		}
		return struct {
			Type    string             `json:"type"`
			Numeric api1.NumericSeries `json:"numeric"`
		}{Type: "numeric", Numeric: *u.numeric}, nil
	case "ranges":
		if u.ranges == nil {
			return nil, fmt.Errorf("field \"ranges\" is required")
		}
		return struct {
			Type   string           `json:"type"`
			Ranges api1.RangeSeries `json:"ranges"`
		}{Type: "ranges", Ranges: *u.ranges}, nil
	}
}

func (u FunctionNode) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *FunctionNode) UnmarshalJSON(data []byte) error {
	var deser functionNodeDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
	}
	return nil
}

func (u FunctionNode) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *FunctionNode) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *FunctionNode) AcceptFuncs(enumFunc func(api1.EnumSeries) error, numericFunc func(api1.NumericSeries) error, rangesFunc func(api1.RangeSeries) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return numericFunc(*u.numeric)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return rangesFunc(*u.ranges)
	}
}

func (u *FunctionNode) EnumNoopSuccess(api1.EnumSeries) error {
	return nil
}

func (u *FunctionNode) NumericNoopSuccess(api1.NumericSeries) error {
	return nil
}

func (u *FunctionNode) RangesNoopSuccess(api1.RangeSeries) error {
	return nil
}

func (u *FunctionNode) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *FunctionNode) Accept(v FunctionNodeVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(*u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumeric(*u.numeric)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRanges(*u.ranges)
	}
}

type FunctionNodeVisitor interface {
	VisitEnum(v api1.EnumSeries) error
	VisitNumeric(v api1.NumericSeries) error
	VisitRanges(v api1.RangeSeries) error
	VisitUnknown(typeName string) error
}

func (u *FunctionNode) AcceptWithContext(ctx context.Context, v FunctionNodeVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "enum":
		if u.enum == nil {
			return fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnumWithContext(ctx, *u.enum)
	case "numeric":
		if u.numeric == nil {
			return fmt.Errorf("field \"numeric\" is required")
		}
		return v.VisitNumericWithContext(ctx, *u.numeric)
	case "ranges":
		if u.ranges == nil {
			return fmt.Errorf("field \"ranges\" is required")
		}
		return v.VisitRangesWithContext(ctx, *u.ranges)
	}
}

type FunctionNodeVisitorWithContext interface {
	VisitEnumWithContext(ctx context.Context, v api1.EnumSeries) error
	VisitNumericWithContext(ctx context.Context, v api1.NumericSeries) error
	VisitRangesWithContext(ctx context.Context, v api1.RangeSeries) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewFunctionNodeFromEnum(v api1.EnumSeries) FunctionNode {
	return FunctionNode{typ: "enum", enum: &v}
}

func NewFunctionNodeFromNumeric(v api1.NumericSeries) FunctionNode {
	return FunctionNode{typ: "numeric", numeric: &v}
}

func NewFunctionNodeFromRanges(v api1.RangeSeries) FunctionNode {
	return FunctionNode{typ: "ranges", ranges: &v}
}

// Request reference to a module. This is used to refer to modules in requests.
type RequestModuleRef struct {
	typ  string
	name *RequestModuleNameRef
	rid  *RequestModuleRidRef
}

type requestModuleRefDeserializer struct {
	Type string                `json:"type"`
	Name *RequestModuleNameRef `json:"name"`
	Rid  *RequestModuleRidRef  `json:"rid"`
}

func (u *requestModuleRefDeserializer) toStruct() RequestModuleRef {
	return RequestModuleRef{typ: u.Type, name: u.Name, rid: u.Rid}
}

func (u *RequestModuleRef) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "name":
		if u.name == nil {
			return nil, fmt.Errorf("field \"name\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Name RequestModuleNameRef `json:"name"`
		}{Type: "name", Name: *u.name}, nil
	case "rid":
		if u.rid == nil {
			return nil, fmt.Errorf("field \"rid\" is required")
		}
		return struct {
			Type string              `json:"type"`
			Rid  RequestModuleRidRef `json:"rid"`
		}{Type: "rid", Rid: *u.rid}, nil
	}
}

func (u RequestModuleRef) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *RequestModuleRef) UnmarshalJSON(data []byte) error {
	var deser requestModuleRefDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "name":
		if u.name == nil {
			return fmt.Errorf("field \"name\" is required")
		}
	case "rid":
		if u.rid == nil {
			return fmt.Errorf("field \"rid\" is required")
		}
	}
	return nil
}

func (u RequestModuleRef) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *RequestModuleRef) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *RequestModuleRef) AcceptFuncs(nameFunc func(RequestModuleNameRef) error, ridFunc func(RequestModuleRidRef) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "name":
		if u.name == nil {
			return fmt.Errorf("field \"name\" is required")
		}
		return nameFunc(*u.name)
	case "rid":
		if u.rid == nil {
			return fmt.Errorf("field \"rid\" is required")
		}
		return ridFunc(*u.rid)
	}
}

func (u *RequestModuleRef) NameNoopSuccess(RequestModuleNameRef) error {
	return nil
}

func (u *RequestModuleRef) RidNoopSuccess(RequestModuleRidRef) error {
	return nil
}

func (u *RequestModuleRef) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *RequestModuleRef) Accept(v RequestModuleRefVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "name":
		if u.name == nil {
			return fmt.Errorf("field \"name\" is required")
		}
		return v.VisitName(*u.name)
	case "rid":
		if u.rid == nil {
			return fmt.Errorf("field \"rid\" is required")
		}
		return v.VisitRid(*u.rid)
	}
}

type RequestModuleRefVisitor interface {
	VisitName(v RequestModuleNameRef) error
	VisitRid(v RequestModuleRidRef) error
	VisitUnknown(typeName string) error
}

func (u *RequestModuleRef) AcceptWithContext(ctx context.Context, v RequestModuleRefVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "name":
		if u.name == nil {
			return fmt.Errorf("field \"name\" is required")
		}
		return v.VisitNameWithContext(ctx, *u.name)
	case "rid":
		if u.rid == nil {
			return fmt.Errorf("field \"rid\" is required")
		}
		return v.VisitRidWithContext(ctx, *u.rid)
	}
}

type RequestModuleRefVisitorWithContext interface {
	VisitNameWithContext(ctx context.Context, v RequestModuleNameRef) error
	VisitRidWithContext(ctx context.Context, v RequestModuleRidRef) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewRequestModuleRefFromName(v RequestModuleNameRef) RequestModuleRef {
	return RequestModuleRef{typ: "name", name: &v}
}

func NewRequestModuleRefFromRid(v RequestModuleRidRef) RequestModuleRef {
	return RequestModuleRef{typ: "rid", rid: &v}
}

type SearchModulesQuery struct {
	typ           string
	searchText    *string
	createdBy     *api.UserRid
	lastUpdatedBy *api.UserRid
	workspace     *rids.WorkspaceRid
	and           *[]SearchModulesQuery
	or            *[]SearchModulesQuery
	not           *SearchModulesQuery
}

type searchModulesQueryDeserializer struct {
	Type          string                `json:"type"`
	SearchText    *string               `json:"searchText"`
	CreatedBy     *api.UserRid          `json:"createdBy"`
	LastUpdatedBy *api.UserRid          `json:"lastUpdatedBy"`
	Workspace     *rids.WorkspaceRid    `json:"workspace"`
	And           *[]SearchModulesQuery `json:"and"`
	Or            *[]SearchModulesQuery `json:"or"`
	Not           *SearchModulesQuery   `json:"not"`
}

func (u *searchModulesQueryDeserializer) toStruct() SearchModulesQuery {
	return SearchModulesQuery{typ: u.Type, searchText: u.SearchText, createdBy: u.CreatedBy, lastUpdatedBy: u.LastUpdatedBy, workspace: u.Workspace, and: u.And, or: u.Or, not: u.Not}
}

func (u *SearchModulesQuery) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "searchText":
		if u.searchText == nil {
			return nil, fmt.Errorf("field \"searchText\" is required")
		}
		return struct {
			Type       string `json:"type"`
			SearchText string `json:"searchText"`
		}{Type: "searchText", SearchText: *u.searchText}, nil
	case "createdBy":
		if u.createdBy == nil {
			return nil, fmt.Errorf("field \"createdBy\" is required")
		}
		return struct {
			Type      string      `json:"type"`
			CreatedBy api.UserRid `json:"createdBy"`
		}{Type: "createdBy", CreatedBy: *u.createdBy}, nil
	case "lastUpdatedBy":
		if u.lastUpdatedBy == nil {
			return nil, fmt.Errorf("field \"lastUpdatedBy\" is required")
		}
		return struct {
			Type          string      `json:"type"`
			LastUpdatedBy api.UserRid `json:"lastUpdatedBy"`
		}{Type: "lastUpdatedBy", LastUpdatedBy: *u.lastUpdatedBy}, nil
	case "workspace":
		if u.workspace == nil {
			return nil, fmt.Errorf("field \"workspace\" is required")
		}
		return struct {
			Type      string            `json:"type"`
			Workspace rids.WorkspaceRid `json:"workspace"`
		}{Type: "workspace", Workspace: *u.workspace}, nil
	case "and":
		if u.and == nil {
			return nil, fmt.Errorf("field \"and\" is required")
		}
		return struct {
			Type string               `json:"type"`
			And  []SearchModulesQuery `json:"and"`
		}{Type: "and", And: *u.and}, nil
	case "or":
		if u.or == nil {
			return nil, fmt.Errorf("field \"or\" is required")
		}
		return struct {
			Type string               `json:"type"`
			Or   []SearchModulesQuery `json:"or"`
		}{Type: "or", Or: *u.or}, nil
	case "not":
		if u.not == nil {
			return nil, fmt.Errorf("field \"not\" is required")
		}
		return struct {
			Type string             `json:"type"`
			Not  SearchModulesQuery `json:"not"`
		}{Type: "not", Not: *u.not}, nil
	}
}

func (u SearchModulesQuery) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *SearchModulesQuery) UnmarshalJSON(data []byte) error {
	var deser searchModulesQueryDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
	case "lastUpdatedBy":
		if u.lastUpdatedBy == nil {
			return fmt.Errorf("field \"lastUpdatedBy\" is required")
		}
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
	}
	return nil
}

func (u SearchModulesQuery) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *SearchModulesQuery) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *SearchModulesQuery) AcceptFuncs(searchTextFunc func(string) error, createdByFunc func(api.UserRid) error, lastUpdatedByFunc func(api.UserRid) error, workspaceFunc func(rids.WorkspaceRid) error, andFunc func([]SearchModulesQuery) error, orFunc func([]SearchModulesQuery) error, notFunc func(SearchModulesQuery) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return searchTextFunc(*u.searchText)
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
		return createdByFunc(*u.createdBy)
	case "lastUpdatedBy":
		if u.lastUpdatedBy == nil {
			return fmt.Errorf("field \"lastUpdatedBy\" is required")
		}
		return lastUpdatedByFunc(*u.lastUpdatedBy)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return workspaceFunc(*u.workspace)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return andFunc(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return orFunc(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return notFunc(*u.not)
	}
}

func (u *SearchModulesQuery) SearchTextNoopSuccess(string) error {
	return nil
}

func (u *SearchModulesQuery) CreatedByNoopSuccess(api.UserRid) error {
	return nil
}

func (u *SearchModulesQuery) LastUpdatedByNoopSuccess(api.UserRid) error {
	return nil
}

func (u *SearchModulesQuery) WorkspaceNoopSuccess(rids.WorkspaceRid) error {
	return nil
}

func (u *SearchModulesQuery) AndNoopSuccess([]SearchModulesQuery) error {
	return nil
}

func (u *SearchModulesQuery) OrNoopSuccess([]SearchModulesQuery) error {
	return nil
}

func (u *SearchModulesQuery) NotNoopSuccess(SearchModulesQuery) error {
	return nil
}

func (u *SearchModulesQuery) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *SearchModulesQuery) Accept(v SearchModulesQueryVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchText(*u.searchText)
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
		return v.VisitCreatedBy(*u.createdBy)
	case "lastUpdatedBy":
		if u.lastUpdatedBy == nil {
			return fmt.Errorf("field \"lastUpdatedBy\" is required")
		}
		return v.VisitLastUpdatedBy(*u.lastUpdatedBy)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspace(*u.workspace)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAnd(*u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOr(*u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNot(*u.not)
	}
}

type SearchModulesQueryVisitor interface {
	VisitSearchText(v string) error
	VisitCreatedBy(v api.UserRid) error
	VisitLastUpdatedBy(v api.UserRid) error
	VisitWorkspace(v rids.WorkspaceRid) error
	VisitAnd(v []SearchModulesQuery) error
	VisitOr(v []SearchModulesQuery) error
	VisitNot(v SearchModulesQuery) error
	VisitUnknown(typeName string) error
}

func (u *SearchModulesQuery) AcceptWithContext(ctx context.Context, v SearchModulesQueryVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "searchText":
		if u.searchText == nil {
			return fmt.Errorf("field \"searchText\" is required")
		}
		return v.VisitSearchTextWithContext(ctx, *u.searchText)
	case "createdBy":
		if u.createdBy == nil {
			return fmt.Errorf("field \"createdBy\" is required")
		}
		return v.VisitCreatedByWithContext(ctx, *u.createdBy)
	case "lastUpdatedBy":
		if u.lastUpdatedBy == nil {
			return fmt.Errorf("field \"lastUpdatedBy\" is required")
		}
		return v.VisitLastUpdatedByWithContext(ctx, *u.lastUpdatedBy)
	case "workspace":
		if u.workspace == nil {
			return fmt.Errorf("field \"workspace\" is required")
		}
		return v.VisitWorkspaceWithContext(ctx, *u.workspace)
	case "and":
		if u.and == nil {
			return fmt.Errorf("field \"and\" is required")
		}
		return v.VisitAndWithContext(ctx, *u.and)
	case "or":
		if u.or == nil {
			return fmt.Errorf("field \"or\" is required")
		}
		return v.VisitOrWithContext(ctx, *u.or)
	case "not":
		if u.not == nil {
			return fmt.Errorf("field \"not\" is required")
		}
		return v.VisitNotWithContext(ctx, *u.not)
	}
}

type SearchModulesQueryVisitorWithContext interface {
	VisitSearchTextWithContext(ctx context.Context, v string) error
	VisitCreatedByWithContext(ctx context.Context, v api.UserRid) error
	VisitLastUpdatedByWithContext(ctx context.Context, v api.UserRid) error
	VisitWorkspaceWithContext(ctx context.Context, v rids.WorkspaceRid) error
	VisitAndWithContext(ctx context.Context, v []SearchModulesQuery) error
	VisitOrWithContext(ctx context.Context, v []SearchModulesQuery) error
	VisitNotWithContext(ctx context.Context, v SearchModulesQuery) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewSearchModulesQueryFromSearchText(v string) SearchModulesQuery {
	return SearchModulesQuery{typ: "searchText", searchText: &v}
}

func NewSearchModulesQueryFromCreatedBy(v api.UserRid) SearchModulesQuery {
	return SearchModulesQuery{typ: "createdBy", createdBy: &v}
}

func NewSearchModulesQueryFromLastUpdatedBy(v api.UserRid) SearchModulesQuery {
	return SearchModulesQuery{typ: "lastUpdatedBy", lastUpdatedBy: &v}
}

func NewSearchModulesQueryFromWorkspace(v rids.WorkspaceRid) SearchModulesQuery {
	return SearchModulesQuery{typ: "workspace", workspace: &v}
}

func NewSearchModulesQueryFromAnd(v []SearchModulesQuery) SearchModulesQuery {
	return SearchModulesQuery{typ: "and", and: &v}
}

func NewSearchModulesQueryFromOr(v []SearchModulesQuery) SearchModulesQuery {
	return SearchModulesQuery{typ: "or", or: &v}
}

func NewSearchModulesQueryFromNot(v SearchModulesQuery) SearchModulesQuery {
	return SearchModulesQuery{typ: "not", not: &v}
}

type VersionStrategy struct {
	typ    string
	pinned *PinnedVersionStrategy
	latest *LatestVersionStrategy
}

type versionStrategyDeserializer struct {
	Type   string                 `json:"type"`
	Pinned *PinnedVersionStrategy `json:"pinned"`
	Latest *LatestVersionStrategy `json:"latest"`
}

func (u *versionStrategyDeserializer) toStruct() VersionStrategy {
	return VersionStrategy{typ: u.Type, pinned: u.Pinned, latest: u.Latest}
}

func (u *VersionStrategy) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "pinned":
		if u.pinned == nil {
			return nil, fmt.Errorf("field \"pinned\" is required")
		}
		return struct {
			Type   string                `json:"type"`
			Pinned PinnedVersionStrategy `json:"pinned"`
		}{Type: "pinned", Pinned: *u.pinned}, nil
	case "latest":
		if u.latest == nil {
			return nil, fmt.Errorf("field \"latest\" is required")
		}
		return struct {
			Type   string                `json:"type"`
			Latest LatestVersionStrategy `json:"latest"`
		}{Type: "latest", Latest: *u.latest}, nil
	}
}

func (u VersionStrategy) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *VersionStrategy) UnmarshalJSON(data []byte) error {
	var deser versionStrategyDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "pinned":
		if u.pinned == nil {
			return fmt.Errorf("field \"pinned\" is required")
		}
	case "latest":
		if u.latest == nil {
			return fmt.Errorf("field \"latest\" is required")
		}
	}
	return nil
}

func (u VersionStrategy) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *VersionStrategy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *VersionStrategy) AcceptFuncs(pinnedFunc func(PinnedVersionStrategy) error, latestFunc func(LatestVersionStrategy) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "pinned":
		if u.pinned == nil {
			return fmt.Errorf("field \"pinned\" is required")
		}
		return pinnedFunc(*u.pinned)
	case "latest":
		if u.latest == nil {
			return fmt.Errorf("field \"latest\" is required")
		}
		return latestFunc(*u.latest)
	}
}

func (u *VersionStrategy) PinnedNoopSuccess(PinnedVersionStrategy) error {
	return nil
}

func (u *VersionStrategy) LatestNoopSuccess(LatestVersionStrategy) error {
	return nil
}

func (u *VersionStrategy) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *VersionStrategy) Accept(v VersionStrategyVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "pinned":
		if u.pinned == nil {
			return fmt.Errorf("field \"pinned\" is required")
		}
		return v.VisitPinned(*u.pinned)
	case "latest":
		if u.latest == nil {
			return fmt.Errorf("field \"latest\" is required")
		}
		return v.VisitLatest(*u.latest)
	}
}

type VersionStrategyVisitor interface {
	VisitPinned(v PinnedVersionStrategy) error
	VisitLatest(v LatestVersionStrategy) error
	VisitUnknown(typeName string) error
}

func (u *VersionStrategy) AcceptWithContext(ctx context.Context, v VersionStrategyVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "pinned":
		if u.pinned == nil {
			return fmt.Errorf("field \"pinned\" is required")
		}
		return v.VisitPinnedWithContext(ctx, *u.pinned)
	case "latest":
		if u.latest == nil {
			return fmt.Errorf("field \"latest\" is required")
		}
		return v.VisitLatestWithContext(ctx, *u.latest)
	}
}

type VersionStrategyVisitorWithContext interface {
	VisitPinnedWithContext(ctx context.Context, v PinnedVersionStrategy) error
	VisitLatestWithContext(ctx context.Context, v LatestVersionStrategy) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewVersionStrategyFromPinned(v PinnedVersionStrategy) VersionStrategy {
	return VersionStrategy{typ: "pinned", pinned: &v}
}

func NewVersionStrategyFromLatest(v LatestVersionStrategy) VersionStrategy {
	return VersionStrategy{typ: "latest", latest: &v}
}
