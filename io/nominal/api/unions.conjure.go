// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type Handle struct {
	typ string
	s3  *S3Path
}

type handleDeserializer struct {
	Type string  `json:"type"`
	S3   *S3Path `json:"s3"`
}

func (u *handleDeserializer) toStruct() Handle {
	return Handle{typ: u.Type, s3: u.S3}
}

func (u *Handle) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "s3":
		if u.s3 == nil {
			return nil, fmt.Errorf("field \"s3\" is required")
		}
		return struct {
			Type string `json:"type"`
			S3   S3Path `json:"s3"`
		}{Type: "s3", S3: *u.s3}, nil
	}
}

func (u Handle) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Handle) UnmarshalJSON(data []byte) error {
	var deser handleDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
	}
	return nil
}

func (u Handle) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Handle) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Handle) AcceptFuncs(s3Func func(S3Path) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return s3Func(*u.s3)
	}
}

func (u *Handle) S3NoopSuccess(S3Path) error {
	return nil
}

func (u *Handle) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Handle) Accept(v HandleVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3(*u.s3)
	}
}

type HandleVisitor interface {
	VisitS3(v S3Path) error
	VisitUnknown(typeName string) error
}

func (u *Handle) AcceptWithContext(ctx context.Context, v HandleVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "s3":
		if u.s3 == nil {
			return fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3WithContext(ctx, *u.s3)
	}
}

type HandleVisitorWithContext interface {
	VisitS3WithContext(ctx context.Context, v S3Path) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewHandleFromS3(v S3Path) Handle {
	return Handle{typ: "s3", s3: &v}
}

type IngestStatusV2 struct {
	typ        string
	success    *SuccessResult
	error      *ErrorResult
	inProgress *InProgressResult
}

type ingestStatusV2Deserializer struct {
	Type       string            `json:"type"`
	Success    *SuccessResult    `json:"success"`
	Error      *ErrorResult      `json:"error"`
	InProgress *InProgressResult `json:"inProgress"`
}

func (u *ingestStatusV2Deserializer) toStruct() IngestStatusV2 {
	return IngestStatusV2{typ: u.Type, success: u.Success, error: u.Error, inProgress: u.InProgress}
}

func (u *IngestStatusV2) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "success":
		if u.success == nil {
			return nil, fmt.Errorf("field \"success\" is required")
		}
		return struct {
			Type    string        `json:"type"`
			Success SuccessResult `json:"success"`
		}{Type: "success", Success: *u.success}, nil
	case "error":
		if u.error == nil {
			return nil, fmt.Errorf("field \"error\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Error ErrorResult `json:"error"`
		}{Type: "error", Error: *u.error}, nil
	case "inProgress":
		if u.inProgress == nil {
			return nil, fmt.Errorf("field \"inProgress\" is required")
		}
		return struct {
			Type       string           `json:"type"`
			InProgress InProgressResult `json:"inProgress"`
		}{Type: "inProgress", InProgress: *u.inProgress}, nil
	}
}

func (u IngestStatusV2) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *IngestStatusV2) UnmarshalJSON(data []byte) error {
	var deser ingestStatusV2Deserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
	}
	return nil
}

func (u IngestStatusV2) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *IngestStatusV2) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *IngestStatusV2) AcceptFuncs(successFunc func(SuccessResult) error, errorFunc func(ErrorResult) error, inProgressFunc func(InProgressResult) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return inProgressFunc(*u.inProgress)
	}
}

func (u *IngestStatusV2) SuccessNoopSuccess(SuccessResult) error {
	return nil
}

func (u *IngestStatusV2) ErrorNoopSuccess(ErrorResult) error {
	return nil
}

func (u *IngestStatusV2) InProgressNoopSuccess(InProgressResult) error {
	return nil
}

func (u *IngestStatusV2) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *IngestStatusV2) Accept(v IngestStatusV2Visitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(*u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgress(*u.inProgress)
	}
}

type IngestStatusV2Visitor interface {
	VisitSuccess(v SuccessResult) error
	VisitError(v ErrorResult) error
	VisitInProgress(v InProgressResult) error
	VisitUnknown(typeName string) error
}

func (u *IngestStatusV2) AcceptWithContext(ctx context.Context, v IngestStatusV2VisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "success":
		if u.success == nil {
			return fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccessWithContext(ctx, *u.success)
	case "error":
		if u.error == nil {
			return fmt.Errorf("field \"error\" is required")
		}
		return v.VisitErrorWithContext(ctx, *u.error)
	case "inProgress":
		if u.inProgress == nil {
			return fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgressWithContext(ctx, *u.inProgress)
	}
}

type IngestStatusV2VisitorWithContext interface {
	VisitSuccessWithContext(ctx context.Context, v SuccessResult) error
	VisitErrorWithContext(ctx context.Context, v ErrorResult) error
	VisitInProgressWithContext(ctx context.Context, v InProgressResult) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewIngestStatusV2FromSuccess(v SuccessResult) IngestStatusV2 {
	return IngestStatusV2{typ: "success", success: &v}
}

func NewIngestStatusV2FromError(v ErrorResult) IngestStatusV2 {
	return IngestStatusV2{typ: "error", error: &v}
}

func NewIngestStatusV2FromInProgress(v InProgressResult) IngestStatusV2 {
	return IngestStatusV2{typ: "inProgress", inProgress: &v}
}

/*
Locator for a channel in an mcap file. Channel name is not guaranteed to be unique, so channel ID should
be used for mcap files with duplicate channel names.
*/
type McapChannelLocator struct {
	typ   string
	topic *McapChannelTopic
	id    *McapChannelId
}

type mcapChannelLocatorDeserializer struct {
	Type  string            `json:"type"`
	Topic *McapChannelTopic `json:"topic"`
	Id    *McapChannelId    `json:"id"`
}

func (u *mcapChannelLocatorDeserializer) toStruct() McapChannelLocator {
	return McapChannelLocator{typ: u.Type, topic: u.Topic, id: u.Id}
}

func (u *McapChannelLocator) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "topic":
		if u.topic == nil {
			return nil, fmt.Errorf("field \"topic\" is required")
		}
		return struct {
			Type  string           `json:"type"`
			Topic McapChannelTopic `json:"topic"`
		}{Type: "topic", Topic: *u.topic}, nil
	case "id":
		if u.id == nil {
			return nil, fmt.Errorf("field \"id\" is required")
		}
		return struct {
			Type string        `json:"type"`
			Id   McapChannelId `json:"id"`
		}{Type: "id", Id: *u.id}, nil
	}
}

func (u McapChannelLocator) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *McapChannelLocator) UnmarshalJSON(data []byte) error {
	var deser mcapChannelLocatorDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "topic":
		if u.topic == nil {
			return fmt.Errorf("field \"topic\" is required")
		}
	case "id":
		if u.id == nil {
			return fmt.Errorf("field \"id\" is required")
		}
	}
	return nil
}

func (u McapChannelLocator) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *McapChannelLocator) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *McapChannelLocator) AcceptFuncs(topicFunc func(McapChannelTopic) error, idFunc func(McapChannelId) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "topic":
		if u.topic == nil {
			return fmt.Errorf("field \"topic\" is required")
		}
		return topicFunc(*u.topic)
	case "id":
		if u.id == nil {
			return fmt.Errorf("field \"id\" is required")
		}
		return idFunc(*u.id)
	}
}

func (u *McapChannelLocator) TopicNoopSuccess(McapChannelTopic) error {
	return nil
}

func (u *McapChannelLocator) IdNoopSuccess(McapChannelId) error {
	return nil
}

func (u *McapChannelLocator) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *McapChannelLocator) Accept(v McapChannelLocatorVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "topic":
		if u.topic == nil {
			return fmt.Errorf("field \"topic\" is required")
		}
		return v.VisitTopic(*u.topic)
	case "id":
		if u.id == nil {
			return fmt.Errorf("field \"id\" is required")
		}
		return v.VisitId(*u.id)
	}
}

type McapChannelLocatorVisitor interface {
	VisitTopic(v McapChannelTopic) error
	VisitId(v McapChannelId) error
	VisitUnknown(typeName string) error
}

func (u *McapChannelLocator) AcceptWithContext(ctx context.Context, v McapChannelLocatorVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "topic":
		if u.topic == nil {
			return fmt.Errorf("field \"topic\" is required")
		}
		return v.VisitTopicWithContext(ctx, *u.topic)
	case "id":
		if u.id == nil {
			return fmt.Errorf("field \"id\" is required")
		}
		return v.VisitIdWithContext(ctx, *u.id)
	}
}

type McapChannelLocatorVisitorWithContext interface {
	VisitTopicWithContext(ctx context.Context, v McapChannelTopic) error
	VisitIdWithContext(ctx context.Context, v McapChannelId) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewMcapChannelLocatorFromTopic(v McapChannelTopic) McapChannelLocator {
	return McapChannelLocator{typ: "topic", topic: &v}
}

func NewMcapChannelLocatorFromId(v McapChannelId) McapChannelLocator {
	return McapChannelLocator{typ: "id", id: &v}
}
