// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"strings"
)

type ArchivedStatus struct {
	val ArchivedStatus_Value
}

type ArchivedStatus_Value string

const (
	ArchivedStatus_NOT_ARCHIVED ArchivedStatus_Value = "NOT_ARCHIVED"
	ArchivedStatus_ARCHIVED     ArchivedStatus_Value = "ARCHIVED"
	ArchivedStatus_UNKNOWN      ArchivedStatus_Value = "UNKNOWN"
)

// ArchivedStatus_Values returns all known variants of ArchivedStatus.
func ArchivedStatus_Values() []ArchivedStatus_Value {
	return []ArchivedStatus_Value{ArchivedStatus_NOT_ARCHIVED, ArchivedStatus_ARCHIVED}
}

func New_ArchivedStatus(value ArchivedStatus_Value) ArchivedStatus {
	return ArchivedStatus{val: value}
}

// IsUnknown returns false for all known variants of ArchivedStatus and true otherwise.
func (e ArchivedStatus) IsUnknown() bool {
	switch e.val {
	case ArchivedStatus_NOT_ARCHIVED, ArchivedStatus_ARCHIVED:
		return false
	}
	return true
}

func (e ArchivedStatus) Value() ArchivedStatus_Value {
	if e.IsUnknown() {
		return ArchivedStatus_UNKNOWN
	}
	return e.val
}

func (e ArchivedStatus) String() string {
	return string(e.val)
}

func (e ArchivedStatus) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *ArchivedStatus) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_ArchivedStatus(ArchivedStatus_Value(v))
	case "NOT_ARCHIVED":
		*e = New_ArchivedStatus(ArchivedStatus_NOT_ARCHIVED)
	case "ARCHIVED":
		*e = New_ArchivedStatus(ArchivedStatus_ARCHIVED)
	}
	return nil
}

type DataSourceType struct {
	val DataSourceType_Value
}

type DataSourceType_Value string

const (
	DataSourceType_DATASET    DataSourceType_Value = "DATASET"
	DataSourceType_CONNECTION DataSourceType_Value = "CONNECTION"
	DataSourceType_VIDEO      DataSourceType_Value = "VIDEO"
	DataSourceType_UNKNOWN    DataSourceType_Value = "UNKNOWN"
)

// DataSourceType_Values returns all known variants of DataSourceType.
func DataSourceType_Values() []DataSourceType_Value {
	return []DataSourceType_Value{DataSourceType_DATASET, DataSourceType_CONNECTION, DataSourceType_VIDEO}
}

func New_DataSourceType(value DataSourceType_Value) DataSourceType {
	return DataSourceType{val: value}
}

// IsUnknown returns false for all known variants of DataSourceType and true otherwise.
func (e DataSourceType) IsUnknown() bool {
	switch e.val {
	case DataSourceType_DATASET, DataSourceType_CONNECTION, DataSourceType_VIDEO:
		return false
	}
	return true
}

func (e DataSourceType) Value() DataSourceType_Value {
	if e.IsUnknown() {
		return DataSourceType_UNKNOWN
	}
	return e.val
}

func (e DataSourceType) String() string {
	return string(e.val)
}

func (e DataSourceType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *DataSourceType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_DataSourceType(DataSourceType_Value(v))
	case "DATASET":
		*e = New_DataSourceType(DataSourceType_DATASET)
	case "CONNECTION":
		*e = New_DataSourceType(DataSourceType_CONNECTION)
	case "VIDEO":
		*e = New_DataSourceType(DataSourceType_VIDEO)
	}
	return nil
}

type Granularity struct {
	val Granularity_Value
}

type Granularity_Value string

const (
	Granularity_PICOSECONDS Granularity_Value = "PICOSECONDS"
	Granularity_NANOSECONDS Granularity_Value = "NANOSECONDS"
	Granularity_UNKNOWN     Granularity_Value = "UNKNOWN"
)

// Granularity_Values returns all known variants of Granularity.
func Granularity_Values() []Granularity_Value {
	return []Granularity_Value{Granularity_PICOSECONDS, Granularity_NANOSECONDS}
}

func New_Granularity(value Granularity_Value) Granularity {
	return Granularity{val: value}
}

// IsUnknown returns false for all known variants of Granularity and true otherwise.
func (e Granularity) IsUnknown() bool {
	switch e.val {
	case Granularity_PICOSECONDS, Granularity_NANOSECONDS:
		return false
	}
	return true
}

func (e Granularity) Value() Granularity_Value {
	if e.IsUnknown() {
		return Granularity_UNKNOWN
	}
	return e.val
}

func (e Granularity) String() string {
	return string(e.val)
}

func (e Granularity) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *Granularity) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_Granularity(Granularity_Value(v))
	case "PICOSECONDS":
		*e = New_Granularity(Granularity_PICOSECONDS)
	case "NANOSECONDS":
		*e = New_Granularity(Granularity_NANOSECONDS)
	}
	return nil
}

type IngestStatus struct {
	val IngestStatus_Value
}

type IngestStatus_Value string

const (
	IngestStatus_SUCCEEDED   IngestStatus_Value = "SUCCEEDED"
	IngestStatus_FAILED      IngestStatus_Value = "FAILED"
	IngestStatus_IN_PROGRESS IngestStatus_Value = "IN_PROGRESS"
	IngestStatus_UNKNOWN     IngestStatus_Value = "UNKNOWN"
)

// IngestStatus_Values returns all known variants of IngestStatus.
func IngestStatus_Values() []IngestStatus_Value {
	return []IngestStatus_Value{IngestStatus_SUCCEEDED, IngestStatus_FAILED, IngestStatus_IN_PROGRESS}
}

func New_IngestStatus(value IngestStatus_Value) IngestStatus {
	return IngestStatus{val: value}
}

// IsUnknown returns false for all known variants of IngestStatus and true otherwise.
func (e IngestStatus) IsUnknown() bool {
	switch e.val {
	case IngestStatus_SUCCEEDED, IngestStatus_FAILED, IngestStatus_IN_PROGRESS:
		return false
	}
	return true
}

func (e IngestStatus) Value() IngestStatus_Value {
	if e.IsUnknown() {
		return IngestStatus_UNKNOWN
	}
	return e.val
}

func (e IngestStatus) String() string {
	return string(e.val)
}

func (e IngestStatus) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *IngestStatus) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_IngestStatus(IngestStatus_Value(v))
	case "SUCCEEDED":
		*e = New_IngestStatus(IngestStatus_SUCCEEDED)
	case "FAILED":
		*e = New_IngestStatus(IngestStatus_FAILED)
	case "IN_PROGRESS":
		*e = New_IngestStatus(IngestStatus_IN_PROGRESS)
	}
	return nil
}

// The data types that are available for querying.
type SeriesDataType struct {
	val SeriesDataType_Value
}

type SeriesDataType_Value string

const (
	SeriesDataType_DOUBLE       SeriesDataType_Value = "DOUBLE"
	SeriesDataType_STRING       SeriesDataType_Value = "STRING"
	SeriesDataType_LOG          SeriesDataType_Value = "LOG"
	SeriesDataType_INT          SeriesDataType_Value = "INT"
	SeriesDataType_UINT         SeriesDataType_Value = "UINT"
	SeriesDataType_DOUBLE_ARRAY SeriesDataType_Value = "DOUBLE_ARRAY"
	SeriesDataType_STRING_ARRAY SeriesDataType_Value = "STRING_ARRAY"
	SeriesDataType_UNKNOWN      SeriesDataType_Value = "UNKNOWN"
)

// SeriesDataType_Values returns all known variants of SeriesDataType.
func SeriesDataType_Values() []SeriesDataType_Value {
	return []SeriesDataType_Value{SeriesDataType_DOUBLE, SeriesDataType_STRING, SeriesDataType_LOG, SeriesDataType_INT, SeriesDataType_UINT, SeriesDataType_DOUBLE_ARRAY, SeriesDataType_STRING_ARRAY}
}

func New_SeriesDataType(value SeriesDataType_Value) SeriesDataType {
	return SeriesDataType{val: value}
}

// IsUnknown returns false for all known variants of SeriesDataType and true otherwise.
func (e SeriesDataType) IsUnknown() bool {
	switch e.val {
	case SeriesDataType_DOUBLE, SeriesDataType_STRING, SeriesDataType_LOG, SeriesDataType_INT, SeriesDataType_UINT, SeriesDataType_DOUBLE_ARRAY, SeriesDataType_STRING_ARRAY:
		return false
	}
	return true
}

func (e SeriesDataType) Value() SeriesDataType_Value {
	if e.IsUnknown() {
		return SeriesDataType_UNKNOWN
	}
	return e.val
}

func (e SeriesDataType) String() string {
	return string(e.val)
}

func (e SeriesDataType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *SeriesDataType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_SeriesDataType(SeriesDataType_Value(v))
	case "DOUBLE":
		*e = New_SeriesDataType(SeriesDataType_DOUBLE)
	case "STRING":
		*e = New_SeriesDataType(SeriesDataType_STRING)
	case "LOG":
		*e = New_SeriesDataType(SeriesDataType_LOG)
	case "INT":
		*e = New_SeriesDataType(SeriesDataType_INT)
	case "UINT":
		*e = New_SeriesDataType(SeriesDataType_UINT)
	case "DOUBLE_ARRAY":
		*e = New_SeriesDataType(SeriesDataType_DOUBLE_ARRAY)
	case "STRING_ARRAY":
		*e = New_SeriesDataType(SeriesDataType_STRING_ARRAY)
	}
	return nil
}

type TimeUnit struct {
	val TimeUnit_Value
}

type TimeUnit_Value string

const (
	TimeUnit_DAYS         TimeUnit_Value = "DAYS"
	TimeUnit_HOURS        TimeUnit_Value = "HOURS"
	TimeUnit_MINUTES      TimeUnit_Value = "MINUTES"
	TimeUnit_SECONDS      TimeUnit_Value = "SECONDS"
	TimeUnit_MILLISECONDS TimeUnit_Value = "MILLISECONDS"
	TimeUnit_MICROSECONDS TimeUnit_Value = "MICROSECONDS"
	TimeUnit_NANOSECONDS  TimeUnit_Value = "NANOSECONDS"
	TimeUnit_PICOSECONDS  TimeUnit_Value = "PICOSECONDS"
	TimeUnit_UNKNOWN      TimeUnit_Value = "UNKNOWN"
)

// TimeUnit_Values returns all known variants of TimeUnit.
func TimeUnit_Values() []TimeUnit_Value {
	return []TimeUnit_Value{TimeUnit_DAYS, TimeUnit_HOURS, TimeUnit_MINUTES, TimeUnit_SECONDS, TimeUnit_MILLISECONDS, TimeUnit_MICROSECONDS, TimeUnit_NANOSECONDS, TimeUnit_PICOSECONDS}
}

func New_TimeUnit(value TimeUnit_Value) TimeUnit {
	return TimeUnit{val: value}
}

// IsUnknown returns false for all known variants of TimeUnit and true otherwise.
func (e TimeUnit) IsUnknown() bool {
	switch e.val {
	case TimeUnit_DAYS, TimeUnit_HOURS, TimeUnit_MINUTES, TimeUnit_SECONDS, TimeUnit_MILLISECONDS, TimeUnit_MICROSECONDS, TimeUnit_NANOSECONDS, TimeUnit_PICOSECONDS:
		return false
	}
	return true
}

func (e TimeUnit) Value() TimeUnit_Value {
	if e.IsUnknown() {
		return TimeUnit_UNKNOWN
	}
	return e.val
}

func (e TimeUnit) String() string {
	return string(e.val)
}

func (e TimeUnit) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *TimeUnit) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_TimeUnit(TimeUnit_Value(v))
	case "DAYS":
		*e = New_TimeUnit(TimeUnit_DAYS)
	case "HOURS":
		*e = New_TimeUnit(TimeUnit_HOURS)
	case "MINUTES":
		*e = New_TimeUnit(TimeUnit_MINUTES)
	case "SECONDS":
		*e = New_TimeUnit(TimeUnit_SECONDS)
	case "MILLISECONDS":
		*e = New_TimeUnit(TimeUnit_MILLISECONDS)
	case "MICROSECONDS":
		*e = New_TimeUnit(TimeUnit_MICROSECONDS)
	case "NANOSECONDS":
		*e = New_TimeUnit(TimeUnit_NANOSECONDS)
	case "PICOSECONDS":
		*e = New_TimeUnit(TimeUnit_PICOSECONDS)
	}
	return nil
}
