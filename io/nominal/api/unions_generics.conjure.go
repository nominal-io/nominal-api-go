// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"
)

type HandleWithT[T any] Handle

func (u *HandleWithT[T]) Accept(ctx context.Context, v HandleVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "s3":
		if u.s3 == nil {
			return result, fmt.Errorf("field \"s3\" is required")
		}
		return v.VisitS3(ctx, *u.s3)
	}
}

func (u *HandleWithT[T]) AcceptFuncs(s3Func func(S3Path) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "s3":
		if u.s3 == nil {
			return result, fmt.Errorf("field \"s3\" is required")
		}
		return s3Func(*u.s3)
	}
}

func (u *HandleWithT[T]) S3NoopSuccess(S3Path) (T, error) {
	var result T
	return result, nil
}

func (u *HandleWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type HandleVisitorWithT[T any] interface {
	VisitS3(ctx context.Context, v S3Path) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type IngestStatusV2WithT[T any] IngestStatusV2

func (u *IngestStatusV2WithT[T]) Accept(ctx context.Context, v IngestStatusV2VisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return v.VisitSuccess(ctx, *u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return v.VisitError(ctx, *u.error)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return v.VisitInProgress(ctx, *u.inProgress)
	}
}

func (u *IngestStatusV2WithT[T]) AcceptFuncs(successFunc func(SuccessResult) (T, error), errorFunc func(ErrorResult) (T, error), inProgressFunc func(InProgressResult) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "success":
		if u.success == nil {
			return result, fmt.Errorf("field \"success\" is required")
		}
		return successFunc(*u.success)
	case "error":
		if u.error == nil {
			return result, fmt.Errorf("field \"error\" is required")
		}
		return errorFunc(*u.error)
	case "inProgress":
		if u.inProgress == nil {
			return result, fmt.Errorf("field \"inProgress\" is required")
		}
		return inProgressFunc(*u.inProgress)
	}
}

func (u *IngestStatusV2WithT[T]) SuccessNoopSuccess(SuccessResult) (T, error) {
	var result T
	return result, nil
}

func (u *IngestStatusV2WithT[T]) ErrorNoopSuccess(ErrorResult) (T, error) {
	var result T
	return result, nil
}

func (u *IngestStatusV2WithT[T]) InProgressNoopSuccess(InProgressResult) (T, error) {
	var result T
	return result, nil
}

func (u *IngestStatusV2WithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type IngestStatusV2VisitorWithT[T any] interface {
	VisitSuccess(ctx context.Context, v SuccessResult) (T, error)
	VisitError(ctx context.Context, v ErrorResult) (T, error)
	VisitInProgress(ctx context.Context, v InProgressResult) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type McapChannelLocatorWithT[T any] McapChannelLocator

func (u *McapChannelLocatorWithT[T]) Accept(ctx context.Context, v McapChannelLocatorVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "topic":
		if u.topic == nil {
			return result, fmt.Errorf("field \"topic\" is required")
		}
		return v.VisitTopic(ctx, *u.topic)
	case "id":
		if u.id == nil {
			return result, fmt.Errorf("field \"id\" is required")
		}
		return v.VisitId(ctx, *u.id)
	}
}

func (u *McapChannelLocatorWithT[T]) AcceptFuncs(topicFunc func(McapChannelTopic) (T, error), idFunc func(McapChannelId) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "topic":
		if u.topic == nil {
			return result, fmt.Errorf("field \"topic\" is required")
		}
		return topicFunc(*u.topic)
	case "id":
		if u.id == nil {
			return result, fmt.Errorf("field \"id\" is required")
		}
		return idFunc(*u.id)
	}
}

func (u *McapChannelLocatorWithT[T]) TopicNoopSuccess(McapChannelTopic) (T, error) {
	var result T
	return result, nil
}

func (u *McapChannelLocatorWithT[T]) IdNoopSuccess(McapChannelId) (T, error) {
	var result T
	return result, nil
}

func (u *McapChannelLocatorWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type McapChannelLocatorVisitorWithT[T any] interface {
	VisitTopic(ctx context.Context, v McapChannelTopic) (T, error)
	VisitId(ctx context.Context, v McapChannelId) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
