// Code generated by conjure-go. DO NOT EDIT.

package scout

import (
	"context"
	"fmt"
	"net/url"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	api7 "github.com/nominal-io/nominal-api-go/io/nominal/api"
	api3 "github.com/nominal-io/nominal-api-go/scout/api"
	api1 "github.com/nominal-io/nominal-api-go/scout/notebook/api"
	api2 "github.com/nominal-io/nominal-api-go/scout/rids/api"
	api4 "github.com/nominal-io/nominal-api-go/scout/run/api"
	api11 "github.com/nominal-io/nominal-api-go/scout/run/api1"
	api5 "github.com/nominal-io/nominal-api-go/scout/template/api"
	api6 "github.com/nominal-io/nominal-api-go/scout/units/api"
	"github.com/nominal-io/nominal-api-go/scout/versioning/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	"github.com/palantir/pkg/rid"
	werror "github.com/palantir/witchcraft-go-error"
)

/*
These endpoints are not intended to be used directly by clients, since
they require saving resource-specific state associated with new commits.
*/
type InternalVersioningServiceClient interface {
	/*
	   Creates a root commit (no parents) and a "main" branch
	   pointing to that commit, for the given resource.
	   Throws if the resource already has a commit graph.
	*/
	InitResourceVersioning(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, requestArg api.InitResourceVersioningRequest) (api.BranchAndCommit, error)
	/*
	   Creates a non-permanent commit on the given branch,
	   Throws if the branch doesn't exist.
	   Throws if latestCommit is passed and is not the latest commit.
	*/
	SaveWorkingState(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName, requestArg api.SaveWorkingStateRequest) (api.BranchAndCommit, error)
	/*
	   Creates a new permanent commit on the given branch.
	   Throws if the branch doesn't exist.
	   Throws if latestCommit is passed and is not the latest commit.
	*/
	Commit(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName, requestArg api.CommitRequest) (api.BranchAndCommit, error)
	/*
	   Compacts the commit graph for the resource by deleting
	   working state commits that match the provided strategy.
	   Persists commits that are pointed to by branches.
	   Returns the set of commits that were compacted.
	   Throws if the resource doesn't exist.
	*/
	CompactCommits(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, requestArg api.CompactCommitsRequest) ([]api.CommitId, error)
}

type internalVersioningServiceClient struct {
	client httpclient.Client
}

func NewInternalVersioningServiceClient(client httpclient.Client) InternalVersioningServiceClient {
	return &internalVersioningServiceClient{client: client}
}

func (c *internalVersioningServiceClient) InitResourceVersioning(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, requestArg api.InitResourceVersioningRequest) (api.BranchAndCommit, error) {
	var defaultReturnVal api.BranchAndCommit
	var returnVal *api.BranchAndCommit
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("InitResourceVersioning"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/internal/scout/v1/versioning/%s", url.PathEscape(fmt.Sprint(resourceRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "initResourceVersioning failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "initResourceVersioning response cannot be nil")
	}
	return *returnVal, nil
}

func (c *internalVersioningServiceClient) SaveWorkingState(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName, requestArg api.SaveWorkingStateRequest) (api.BranchAndCommit, error) {
	var defaultReturnVal api.BranchAndCommit
	var returnVal *api.BranchAndCommit
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SaveWorkingState"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/internal/scout/v1/versioning/%s/branch/%s/working-state", url.PathEscape(fmt.Sprint(resourceRidArg)), url.PathEscape(fmt.Sprint(branchNameArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "saveWorkingState failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "saveWorkingState response cannot be nil")
	}
	return *returnVal, nil
}

func (c *internalVersioningServiceClient) Commit(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName, requestArg api.CommitRequest) (api.BranchAndCommit, error) {
	var defaultReturnVal api.BranchAndCommit
	var returnVal *api.BranchAndCommit
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Commit"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/internal/scout/v1/versioning/%s/branch/%s/commit", url.PathEscape(fmt.Sprint(resourceRidArg)), url.PathEscape(fmt.Sprint(branchNameArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "commit failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "commit response cannot be nil")
	}
	return *returnVal, nil
}

func (c *internalVersioningServiceClient) CompactCommits(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, requestArg api.CompactCommitsRequest) ([]api.CommitId, error) {
	var returnVal []api.CommitId
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CompactCommits"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/internal/scout/v1/versioning/%s/compact-commits", url.PathEscape(fmt.Sprint(resourceRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "compactCommits failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "compactCommits response cannot be nil")
	}
	return returnVal, nil
}

/*
These endpoints are not intended to be used directly by clients, since
they require saving resource-specific state associated with new commits.
*/
type InternalVersioningServiceClientWithAuth interface {
	/*
	   Creates a root commit (no parents) and a "main" branch
	   pointing to that commit, for the given resource.
	   Throws if the resource already has a commit graph.
	*/
	InitResourceVersioning(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.InitResourceVersioningRequest) (api.BranchAndCommit, error)
	/*
	   Creates a non-permanent commit on the given branch,
	   Throws if the branch doesn't exist.
	   Throws if latestCommit is passed and is not the latest commit.
	*/
	SaveWorkingState(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName, requestArg api.SaveWorkingStateRequest) (api.BranchAndCommit, error)
	/*
	   Creates a new permanent commit on the given branch.
	   Throws if the branch doesn't exist.
	   Throws if latestCommit is passed and is not the latest commit.
	*/
	Commit(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName, requestArg api.CommitRequest) (api.BranchAndCommit, error)
	/*
	   Compacts the commit graph for the resource by deleting
	   working state commits that match the provided strategy.
	   Persists commits that are pointed to by branches.
	   Returns the set of commits that were compacted.
	   Throws if the resource doesn't exist.
	*/
	CompactCommits(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.CompactCommitsRequest) ([]api.CommitId, error)
}

func NewInternalVersioningServiceClientWithAuth(client InternalVersioningServiceClient, authHeader bearertoken.Token) InternalVersioningServiceClientWithAuth {
	return &internalVersioningServiceClientWithAuth{client: client, authHeader: authHeader}
}

type internalVersioningServiceClientWithAuth struct {
	client     InternalVersioningServiceClient
	authHeader bearertoken.Token
}

func (c *internalVersioningServiceClientWithAuth) InitResourceVersioning(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.InitResourceVersioningRequest) (api.BranchAndCommit, error) {
	return c.client.InitResourceVersioning(ctx, c.authHeader, resourceRidArg, requestArg)
}

func (c *internalVersioningServiceClientWithAuth) SaveWorkingState(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName, requestArg api.SaveWorkingStateRequest) (api.BranchAndCommit, error) {
	return c.client.SaveWorkingState(ctx, c.authHeader, resourceRidArg, branchNameArg, requestArg)
}

func (c *internalVersioningServiceClientWithAuth) Commit(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName, requestArg api.CommitRequest) (api.BranchAndCommit, error) {
	return c.client.Commit(ctx, c.authHeader, resourceRidArg, branchNameArg, requestArg)
}

func (c *internalVersioningServiceClientWithAuth) CompactCommits(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.CompactCommitsRequest) ([]api.CommitId, error) {
	return c.client.CompactCommits(ctx, c.authHeader, resourceRidArg, requestArg)
}

func NewInternalVersioningServiceClientWithTokenProvider(client InternalVersioningServiceClient, tokenProvider httpclient.TokenProvider) InternalVersioningServiceClientWithAuth {
	return &internalVersioningServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type internalVersioningServiceClientWithTokenProvider struct {
	client        InternalVersioningServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *internalVersioningServiceClientWithTokenProvider) InitResourceVersioning(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.InitResourceVersioningRequest) (api.BranchAndCommit, error) {
	var defaultReturnVal api.BranchAndCommit
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.InitResourceVersioning(ctx, bearertoken.Token(token), resourceRidArg, requestArg)
}

func (c *internalVersioningServiceClientWithTokenProvider) SaveWorkingState(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName, requestArg api.SaveWorkingStateRequest) (api.BranchAndCommit, error) {
	var defaultReturnVal api.BranchAndCommit
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.SaveWorkingState(ctx, bearertoken.Token(token), resourceRidArg, branchNameArg, requestArg)
}

func (c *internalVersioningServiceClientWithTokenProvider) Commit(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName, requestArg api.CommitRequest) (api.BranchAndCommit, error) {
	var defaultReturnVal api.BranchAndCommit
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Commit(ctx, bearertoken.Token(token), resourceRidArg, branchNameArg, requestArg)
}

func (c *internalVersioningServiceClientWithTokenProvider) CompactCommits(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.CompactCommitsRequest) ([]api.CommitId, error) {
	var defaultReturnVal []api.CommitId
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CompactCommits(ctx, bearertoken.Token(token), resourceRidArg, requestArg)
}

// NotebookService manages workbooks (formerly known as notebooks).
type NotebookServiceClient interface {
	/*
	   Creates a new workbook. The workbook will be associated with the provided run. If the run does not exist,
	   a RunNotFound error will be thrown.
	*/
	Create(ctx context.Context, authHeader bearertoken.Token, requestArg api1.CreateNotebookRequest) (api1.Notebook, error)
	// Updates the contents of a workbook.
	Update(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid, requestArg api1.UpdateNotebookRequest) (api1.Notebook, error)
	Get(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) (api1.Notebook, error)
	BatchGet(ctx context.Context, authHeader bearertoken.Token, ridsArg []api2.NotebookRid) ([]api1.Notebook, error)
	BatchGetMetadata(ctx context.Context, authHeader bearertoken.Token, ridsArg []api2.NotebookRid) ([]api1.NotebookMetadataWithRid, error)
	// Updates metadata about a workbook, but not its contents.
	UpdateMetadata(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid, requestArg api1.UpdateNotebookMetadataRequest) (api1.NotebookMetadata, error)
	// Returns the set of all ref names used by the workbook.
	GetUsedRefNames(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) ([]api3.DataSourceRefName, error)
	// Updates the data source ref names for all variables used in the workbook.
	UpdateRefNames(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid, requestArg api1.UpdateRefNameRequest) (api1.Notebook, error)
	/*
	   Returns all properties (key value pairs) and labels that have been previously used on workbook. These can
	   be used to organize workbooks.
	*/
	GetAllLabelsAndProperties(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) (api1.GetAllLabelsAndPropertiesResponse, error)
	Search(ctx context.Context, authHeader bearertoken.Token, requestArg api1.SearchNotebooksRequest) (api1.SearchNotebooksResponse, error)
	// Makes a workbook uneditable.
	Lock(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) error
	// Unlocks a workbook for editing.
	Unlock(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) error
	/*
	   Archives a workbook, which excludes it from search and hides it from being publicly visible, but does not
	   permanently delete it. Archived workbooks can be unarchived.
	*/
	Archive(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) error
	// Makes a previously archived workbook searchable.
	Unarchive(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) error
	// The workbook will be deleted and is not recoverable. For soft deletion, use archive.
	Delete(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) error
}

type notebookServiceClient struct {
	client httpclient.Client
}

func NewNotebookServiceClient(client httpclient.Client) NotebookServiceClient {
	return &notebookServiceClient{client: client}
}

func (c *notebookServiceClient) Create(ctx context.Context, authHeader bearertoken.Token, requestArg api1.CreateNotebookRequest) (api1.Notebook, error) {
	var defaultReturnVal api1.Notebook
	var returnVal *api1.Notebook
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Create"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "create failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "create response cannot be nil")
	}
	return *returnVal, nil
}

func (c *notebookServiceClient) Update(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid, requestArg api1.UpdateNotebookRequest) (api1.Notebook, error) {
	var defaultReturnVal api1.Notebook
	var returnVal *api1.Notebook
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Update"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/%s", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "update failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "update response cannot be nil")
	}
	return *returnVal, nil
}

func (c *notebookServiceClient) Get(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) (api1.Notebook, error) {
	var defaultReturnVal api1.Notebook
	var returnVal *api1.Notebook
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Get"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/%s", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "get failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "get response cannot be nil")
	}
	return *returnVal, nil
}

func (c *notebookServiceClient) BatchGet(ctx context.Context, authHeader bearertoken.Token, ridsArg []api2.NotebookRid) ([]api1.Notebook, error) {
	var returnVal []api1.Notebook
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGet"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/batch-get"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(ridsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGet failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGet response cannot be nil")
	}
	return returnVal, nil
}

func (c *notebookServiceClient) BatchGetMetadata(ctx context.Context, authHeader bearertoken.Token, ridsArg []api2.NotebookRid) ([]api1.NotebookMetadataWithRid, error) {
	var returnVal []api1.NotebookMetadataWithRid
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGetMetadata"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/batch-get-metadata"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(ridsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGetMetadata failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGetMetadata response cannot be nil")
	}
	return returnVal, nil
}

func (c *notebookServiceClient) UpdateMetadata(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid, requestArg api1.UpdateNotebookMetadataRequest) (api1.NotebookMetadata, error) {
	var defaultReturnVal api1.NotebookMetadata
	var returnVal *api1.NotebookMetadata
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateMetadata"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/%s/update-metadata", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateMetadata failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateMetadata response cannot be nil")
	}
	return *returnVal, nil
}

func (c *notebookServiceClient) GetUsedRefNames(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) ([]api3.DataSourceRefName, error) {
	var returnVal []api3.DataSourceRefName
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetUsedRefNames"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/%s/ref-names", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getUsedRefNames failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getUsedRefNames response cannot be nil")
	}
	return returnVal, nil
}

func (c *notebookServiceClient) UpdateRefNames(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid, requestArg api1.UpdateRefNameRequest) (api1.Notebook, error) {
	var defaultReturnVal api1.Notebook
	var returnVal *api1.Notebook
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateRefNames"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/%s/update-ref-names", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateRefNames failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateRefNames response cannot be nil")
	}
	return *returnVal, nil
}

func (c *notebookServiceClient) GetAllLabelsAndProperties(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) (api1.GetAllLabelsAndPropertiesResponse, error) {
	var defaultReturnVal api1.GetAllLabelsAndPropertiesResponse
	var returnVal *api1.GetAllLabelsAndPropertiesResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetAllLabelsAndProperties"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/get-all-labels-properties"))
	queryParams := make(url.Values)
	for _, v := range workspacesArg {
		queryParams.Add("workspaces", fmt.Sprint(v))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getAllLabelsAndProperties failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getAllLabelsAndProperties response cannot be nil")
	}
	return *returnVal, nil
}

func (c *notebookServiceClient) Search(ctx context.Context, authHeader bearertoken.Token, requestArg api1.SearchNotebooksRequest) (api1.SearchNotebooksResponse, error) {
	var defaultReturnVal api1.SearchNotebooksResponse
	var returnVal *api1.SearchNotebooksResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Search"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/search"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "search failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "search response cannot be nil")
	}
	return *returnVal, nil
}

func (c *notebookServiceClient) Lock(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Lock"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/%s/lock", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "lock failed")
	}
	return nil
}

func (c *notebookServiceClient) Unlock(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Unlock"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/%s/unlock", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "unlock failed")
	}
	return nil
}

func (c *notebookServiceClient) Archive(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Archive"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/%s/archive", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "archive failed")
	}
	return nil
}

func (c *notebookServiceClient) Unarchive(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Unarchive"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/%s/unarchive", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "unarchive failed")
	}
	return nil
}

func (c *notebookServiceClient) Delete(ctx context.Context, authHeader bearertoken.Token, ridArg api2.NotebookRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Delete"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("DELETE"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v2/notebook/%s", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "delete failed")
	}
	return nil
}

// NotebookService manages workbooks (formerly known as notebooks).
type NotebookServiceClientWithAuth interface {
	/*
	   Creates a new workbook. The workbook will be associated with the provided run. If the run does not exist,
	   a RunNotFound error will be thrown.
	*/
	Create(ctx context.Context, requestArg api1.CreateNotebookRequest) (api1.Notebook, error)
	// Updates the contents of a workbook.
	Update(ctx context.Context, ridArg api2.NotebookRid, requestArg api1.UpdateNotebookRequest) (api1.Notebook, error)
	Get(ctx context.Context, ridArg api2.NotebookRid) (api1.Notebook, error)
	BatchGet(ctx context.Context, ridsArg []api2.NotebookRid) ([]api1.Notebook, error)
	BatchGetMetadata(ctx context.Context, ridsArg []api2.NotebookRid) ([]api1.NotebookMetadataWithRid, error)
	// Updates metadata about a workbook, but not its contents.
	UpdateMetadata(ctx context.Context, ridArg api2.NotebookRid, requestArg api1.UpdateNotebookMetadataRequest) (api1.NotebookMetadata, error)
	// Returns the set of all ref names used by the workbook.
	GetUsedRefNames(ctx context.Context, ridArg api2.NotebookRid) ([]api3.DataSourceRefName, error)
	// Updates the data source ref names for all variables used in the workbook.
	UpdateRefNames(ctx context.Context, ridArg api2.NotebookRid, requestArg api1.UpdateRefNameRequest) (api1.Notebook, error)
	/*
	   Returns all properties (key value pairs) and labels that have been previously used on workbook. These can
	   be used to organize workbooks.
	*/
	GetAllLabelsAndProperties(ctx context.Context, workspacesArg []rids.WorkspaceRid) (api1.GetAllLabelsAndPropertiesResponse, error)
	Search(ctx context.Context, requestArg api1.SearchNotebooksRequest) (api1.SearchNotebooksResponse, error)
	// Makes a workbook uneditable.
	Lock(ctx context.Context, ridArg api2.NotebookRid) error
	// Unlocks a workbook for editing.
	Unlock(ctx context.Context, ridArg api2.NotebookRid) error
	/*
	   Archives a workbook, which excludes it from search and hides it from being publicly visible, but does not
	   permanently delete it. Archived workbooks can be unarchived.
	*/
	Archive(ctx context.Context, ridArg api2.NotebookRid) error
	// Makes a previously archived workbook searchable.
	Unarchive(ctx context.Context, ridArg api2.NotebookRid) error
	// The workbook will be deleted and is not recoverable. For soft deletion, use archive.
	Delete(ctx context.Context, ridArg api2.NotebookRid) error
}

func NewNotebookServiceClientWithAuth(client NotebookServiceClient, authHeader bearertoken.Token) NotebookServiceClientWithAuth {
	return &notebookServiceClientWithAuth{client: client, authHeader: authHeader}
}

type notebookServiceClientWithAuth struct {
	client     NotebookServiceClient
	authHeader bearertoken.Token
}

func (c *notebookServiceClientWithAuth) Create(ctx context.Context, requestArg api1.CreateNotebookRequest) (api1.Notebook, error) {
	return c.client.Create(ctx, c.authHeader, requestArg)
}

func (c *notebookServiceClientWithAuth) Update(ctx context.Context, ridArg api2.NotebookRid, requestArg api1.UpdateNotebookRequest) (api1.Notebook, error) {
	return c.client.Update(ctx, c.authHeader, ridArg, requestArg)
}

func (c *notebookServiceClientWithAuth) Get(ctx context.Context, ridArg api2.NotebookRid) (api1.Notebook, error) {
	return c.client.Get(ctx, c.authHeader, ridArg)
}

func (c *notebookServiceClientWithAuth) BatchGet(ctx context.Context, ridsArg []api2.NotebookRid) ([]api1.Notebook, error) {
	return c.client.BatchGet(ctx, c.authHeader, ridsArg)
}

func (c *notebookServiceClientWithAuth) BatchGetMetadata(ctx context.Context, ridsArg []api2.NotebookRid) ([]api1.NotebookMetadataWithRid, error) {
	return c.client.BatchGetMetadata(ctx, c.authHeader, ridsArg)
}

func (c *notebookServiceClientWithAuth) UpdateMetadata(ctx context.Context, ridArg api2.NotebookRid, requestArg api1.UpdateNotebookMetadataRequest) (api1.NotebookMetadata, error) {
	return c.client.UpdateMetadata(ctx, c.authHeader, ridArg, requestArg)
}

func (c *notebookServiceClientWithAuth) GetUsedRefNames(ctx context.Context, ridArg api2.NotebookRid) ([]api3.DataSourceRefName, error) {
	return c.client.GetUsedRefNames(ctx, c.authHeader, ridArg)
}

func (c *notebookServiceClientWithAuth) UpdateRefNames(ctx context.Context, ridArg api2.NotebookRid, requestArg api1.UpdateRefNameRequest) (api1.Notebook, error) {
	return c.client.UpdateRefNames(ctx, c.authHeader, ridArg, requestArg)
}

func (c *notebookServiceClientWithAuth) GetAllLabelsAndProperties(ctx context.Context, workspacesArg []rids.WorkspaceRid) (api1.GetAllLabelsAndPropertiesResponse, error) {
	return c.client.GetAllLabelsAndProperties(ctx, c.authHeader, workspacesArg)
}

func (c *notebookServiceClientWithAuth) Search(ctx context.Context, requestArg api1.SearchNotebooksRequest) (api1.SearchNotebooksResponse, error) {
	return c.client.Search(ctx, c.authHeader, requestArg)
}

func (c *notebookServiceClientWithAuth) Lock(ctx context.Context, ridArg api2.NotebookRid) error {
	return c.client.Lock(ctx, c.authHeader, ridArg)
}

func (c *notebookServiceClientWithAuth) Unlock(ctx context.Context, ridArg api2.NotebookRid) error {
	return c.client.Unlock(ctx, c.authHeader, ridArg)
}

func (c *notebookServiceClientWithAuth) Archive(ctx context.Context, ridArg api2.NotebookRid) error {
	return c.client.Archive(ctx, c.authHeader, ridArg)
}

func (c *notebookServiceClientWithAuth) Unarchive(ctx context.Context, ridArg api2.NotebookRid) error {
	return c.client.Unarchive(ctx, c.authHeader, ridArg)
}

func (c *notebookServiceClientWithAuth) Delete(ctx context.Context, ridArg api2.NotebookRid) error {
	return c.client.Delete(ctx, c.authHeader, ridArg)
}

func NewNotebookServiceClientWithTokenProvider(client NotebookServiceClient, tokenProvider httpclient.TokenProvider) NotebookServiceClientWithAuth {
	return &notebookServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type notebookServiceClientWithTokenProvider struct {
	client        NotebookServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *notebookServiceClientWithTokenProvider) Create(ctx context.Context, requestArg api1.CreateNotebookRequest) (api1.Notebook, error) {
	var defaultReturnVal api1.Notebook
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Create(ctx, bearertoken.Token(token), requestArg)
}

func (c *notebookServiceClientWithTokenProvider) Update(ctx context.Context, ridArg api2.NotebookRid, requestArg api1.UpdateNotebookRequest) (api1.Notebook, error) {
	var defaultReturnVal api1.Notebook
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Update(ctx, bearertoken.Token(token), ridArg, requestArg)
}

func (c *notebookServiceClientWithTokenProvider) Get(ctx context.Context, ridArg api2.NotebookRid) (api1.Notebook, error) {
	var defaultReturnVal api1.Notebook
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Get(ctx, bearertoken.Token(token), ridArg)
}

func (c *notebookServiceClientWithTokenProvider) BatchGet(ctx context.Context, ridsArg []api2.NotebookRid) ([]api1.Notebook, error) {
	var defaultReturnVal []api1.Notebook
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGet(ctx, bearertoken.Token(token), ridsArg)
}

func (c *notebookServiceClientWithTokenProvider) BatchGetMetadata(ctx context.Context, ridsArg []api2.NotebookRid) ([]api1.NotebookMetadataWithRid, error) {
	var defaultReturnVal []api1.NotebookMetadataWithRid
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGetMetadata(ctx, bearertoken.Token(token), ridsArg)
}

func (c *notebookServiceClientWithTokenProvider) UpdateMetadata(ctx context.Context, ridArg api2.NotebookRid, requestArg api1.UpdateNotebookMetadataRequest) (api1.NotebookMetadata, error) {
	var defaultReturnVal api1.NotebookMetadata
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateMetadata(ctx, bearertoken.Token(token), ridArg, requestArg)
}

func (c *notebookServiceClientWithTokenProvider) GetUsedRefNames(ctx context.Context, ridArg api2.NotebookRid) ([]api3.DataSourceRefName, error) {
	var defaultReturnVal []api3.DataSourceRefName
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetUsedRefNames(ctx, bearertoken.Token(token), ridArg)
}

func (c *notebookServiceClientWithTokenProvider) UpdateRefNames(ctx context.Context, ridArg api2.NotebookRid, requestArg api1.UpdateRefNameRequest) (api1.Notebook, error) {
	var defaultReturnVal api1.Notebook
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateRefNames(ctx, bearertoken.Token(token), ridArg, requestArg)
}

func (c *notebookServiceClientWithTokenProvider) GetAllLabelsAndProperties(ctx context.Context, workspacesArg []rids.WorkspaceRid) (api1.GetAllLabelsAndPropertiesResponse, error) {
	var defaultReturnVal api1.GetAllLabelsAndPropertiesResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetAllLabelsAndProperties(ctx, bearertoken.Token(token), workspacesArg)
}

func (c *notebookServiceClientWithTokenProvider) Search(ctx context.Context, requestArg api1.SearchNotebooksRequest) (api1.SearchNotebooksResponse, error) {
	var defaultReturnVal api1.SearchNotebooksResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Search(ctx, bearertoken.Token(token), requestArg)
}

func (c *notebookServiceClientWithTokenProvider) Lock(ctx context.Context, ridArg api2.NotebookRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Lock(ctx, bearertoken.Token(token), ridArg)
}

func (c *notebookServiceClientWithTokenProvider) Unlock(ctx context.Context, ridArg api2.NotebookRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Unlock(ctx, bearertoken.Token(token), ridArg)
}

func (c *notebookServiceClientWithTokenProvider) Archive(ctx context.Context, ridArg api2.NotebookRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Archive(ctx, bearertoken.Token(token), ridArg)
}

func (c *notebookServiceClientWithTokenProvider) Unarchive(ctx context.Context, ridArg api2.NotebookRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Unarchive(ctx, bearertoken.Token(token), ridArg)
}

func (c *notebookServiceClientWithTokenProvider) Delete(ctx context.Context, ridArg api2.NotebookRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.Delete(ctx, bearertoken.Token(token), ridArg)
}

/*
Runs are collections of channels and metadata from one or more data sources, synchronized over a
range of real time, which represents a test event or simulation. These API endpoints let you
manage runs in the Nominal app.
*/
type RunServiceClient interface {
	/*
	   Create a new run in Nominal.

	   Throws if start is equal to or after end.
	*/
	CreateRun(ctx context.Context, authHeader bearertoken.Token, detailsArg api4.CreateRunRequest) (api11.Run, error)
	/*
	   Updates an existing run based on its RID.

	   Throws if start is equal to or after end.
	*/
	UpdateRun(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid, detailsArg api4.UpdateRunRequest) (api11.Run, error)
	/*
	   Adds datasources to the run in question.

	   Throws if any of the ref names conflict with existing data sources or each other.
	*/
	AddDataSourcesToRun(ctx context.Context, authHeader bearertoken.Token, runRidArg api4.RunRid, requestArg map[api3.DataSourceRefName]api4.CreateRunDataSource) (api11.Run, error)
	/*
	   Updates a run if it exists, otherwise it's created from scratch.
	   Will throw if the workspace of an existing run is different from the workspace of the request.
	*/
	CreateOrUpdateRun(ctx context.Context, authHeader bearertoken.Token, detailsArg api4.CreateOrUpdateRunRequest) (api11.Run, error)
	// Fetches details about the run in question based on its RID.
	GetRun(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid) (api11.Run, error)
	/*
	   Fetches details about the run in question based on its RID,
	   including metrics for check and violation review status.
	*/
	GetRunWithDataReviewMetrics(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid) (api11.RunWithDataReviewMetrics, error)
	// Fetches details about the run in question based on its RID, including a summary of the data review status.
	GetRunWithDataReviewSummary(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid) (api11.RunWithDataReviewSummary, error)
	// Fetches a run based on the run number, rather than RID.
	GetRunById(ctx context.Context, authHeader bearertoken.Token, getRunByIdRequestArg api4.GetRunByIdRequest) (api11.Run, error)
	// Fetches a list of run details based on a list of RIDs.
	GetRuns(ctx context.Context, authHeader bearertoken.Token, ridsArg []api4.RunRid) (map[api4.RunRid]api11.Run, error)
	// Fetches the runs with the given asset.
	GetRunsByAsset(ctx context.Context, authHeader bearertoken.Token, requestArg api4.GetRunsByAssetRequest) (api11.GetRunsByAssetResponse, error)
	// Deprecated: Deprecated in favor of MetadataService#listPropertiesAndLabels
	GetAllRunsPropertiesAndLabels(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) (api4.AllRunsPropertiesAndLabelsResponse, error)
	// Searches for runs that match the given filters.
	SearchRuns(ctx context.Context, authHeader bearertoken.Token, requestArg api4.SearchRunsRequest) (api11.SearchRunsResponse, error)
	/*
	   Searches for runs that match the given filters and
	   includes metrics for check and violation review status.
	*/
	SearchRunsWithDataReviewMetrics(ctx context.Context, authHeader bearertoken.Token, requestArg api4.SearchRunsRequest) (api11.SearchRunsWithDataReviewMetricsResponse, error)
	/*
	   Searches for runs that match the given filters and includes a summary of the data review status.

	   Deprecated: Deprecated in favor of searchRunsWithDataReviewMetrics
	*/
	SearchRunsWithDataReviewSummary(ctx context.Context, authHeader bearertoken.Token, requestArg api4.SearchRunsRequest) (api11.SearchRunsWithDataReviewSummaryResponse, error)
	// Soft-deletes a run. Runs still exist in the database but are no longer visible.
	ArchiveRun(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid, includeLinkedWorkbooksArg *bool) (bool, error)
	UnarchiveRun(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid, includeLinkedWorkbooksArg *bool) (bool, error)
	// Returns the list of ref names that are in use across specified and authorized workspaces.
	GetDataSourceRefNameAndTypeList(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) ([]api4.RefNameAndType, error)
	// Deprecated: Deprecated in favor of DatasourceChannelSearchService#searchChannels
	SearchChannels(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid, requestArg api4.SearchRunChannelsRequest) (api4.SearchRunChannelsResponse, error)
	// Updates the attachments associated with a run.
	UpdateRunAttachment(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid, requestArg api4.UpdateAttachmentsRequest) error
}

type runServiceClient struct {
	client httpclient.Client
}

func NewRunServiceClient(client httpclient.Client) RunServiceClient {
	return &runServiceClient{client: client}
}

func (c *runServiceClient) CreateRun(ctx context.Context, authHeader bearertoken.Token, detailsArg api4.CreateRunRequest) (api11.Run, error) {
	var defaultReturnVal api11.Run
	var returnVal *api11.Run
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateRun"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(detailsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createRun failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createRun response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) UpdateRun(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid, detailsArg api4.UpdateRunRequest) (api11.Run, error) {
	var defaultReturnVal api11.Run
	var returnVal *api11.Run
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateRun"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run/%s", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(detailsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateRun failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateRun response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) AddDataSourcesToRun(ctx context.Context, authHeader bearertoken.Token, runRidArg api4.RunRid, requestArg map[api3.DataSourceRefName]api4.CreateRunDataSource) (api11.Run, error) {
	var defaultReturnVal api11.Run
	var returnVal *api11.Run
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("AddDataSourcesToRun"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run/%s/data-sources", url.PathEscape(fmt.Sprint(runRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "addDataSourcesToRun failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "addDataSourcesToRun response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) CreateOrUpdateRun(ctx context.Context, authHeader bearertoken.Token, detailsArg api4.CreateOrUpdateRunRequest) (api11.Run, error) {
	var defaultReturnVal api11.Run
	var returnVal *api11.Run
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateOrUpdateRun"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run/create-or-update"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(detailsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createOrUpdateRun failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createOrUpdateRun response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) GetRun(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid) (api11.Run, error) {
	var defaultReturnVal api11.Run
	var returnVal *api11.Run
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetRun"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run/%s", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getRun failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getRun response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) GetRunWithDataReviewMetrics(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid) (api11.RunWithDataReviewMetrics, error) {
	var defaultReturnVal api11.RunWithDataReviewMetrics
	var returnVal *api11.RunWithDataReviewMetrics
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetRunWithDataReviewMetrics"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run/%s/with-data-review-metrics", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getRunWithDataReviewMetrics failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getRunWithDataReviewMetrics response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) GetRunWithDataReviewSummary(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid) (api11.RunWithDataReviewSummary, error) {
	var defaultReturnVal api11.RunWithDataReviewSummary
	var returnVal *api11.RunWithDataReviewSummary
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetRunWithDataReviewSummary"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run/%s/with-data-review-summary", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getRunWithDataReviewSummary failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getRunWithDataReviewSummary response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) GetRunById(ctx context.Context, authHeader bearertoken.Token, getRunByIdRequestArg api4.GetRunByIdRequest) (api11.Run, error) {
	var defaultReturnVal api11.Run
	var returnVal *api11.Run
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetRunById"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run/by-id"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(getRunByIdRequestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getRunById failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getRunById response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) GetRuns(ctx context.Context, authHeader bearertoken.Token, ridsArg []api4.RunRid) (map[api4.RunRid]api11.Run, error) {
	var returnVal map[api4.RunRid]api11.Run
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetRuns"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run/multiple"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(ridsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getRuns failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getRuns response cannot be nil")
	}
	return returnVal, nil
}

func (c *runServiceClient) GetRunsByAsset(ctx context.Context, authHeader bearertoken.Token, requestArg api4.GetRunsByAssetRequest) (api11.GetRunsByAssetResponse, error) {
	var defaultReturnVal api11.GetRunsByAssetResponse
	var returnVal *api11.GetRunsByAssetResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetRunsByAsset"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run/by-asset"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getRunsByAsset failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getRunsByAsset response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) GetAllRunsPropertiesAndLabels(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) (api4.AllRunsPropertiesAndLabelsResponse, error) {
	var defaultReturnVal api4.AllRunsPropertiesAndLabelsResponse
	var returnVal *api4.AllRunsPropertiesAndLabelsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetAllRunsPropertiesAndLabels"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/all-runs-properties-labels"))
	queryParams := make(url.Values)
	for _, v := range workspacesArg {
		queryParams.Add("workspaces", fmt.Sprint(v))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getAllRunsPropertiesAndLabels failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getAllRunsPropertiesAndLabels response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) SearchRuns(ctx context.Context, authHeader bearertoken.Token, requestArg api4.SearchRunsRequest) (api11.SearchRunsResponse, error) {
	var defaultReturnVal api11.SearchRunsResponse
	var returnVal *api11.SearchRunsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SearchRuns"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/search-runs"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "searchRuns failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "searchRuns response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) SearchRunsWithDataReviewMetrics(ctx context.Context, authHeader bearertoken.Token, requestArg api4.SearchRunsRequest) (api11.SearchRunsWithDataReviewMetricsResponse, error) {
	var defaultReturnVal api11.SearchRunsWithDataReviewMetricsResponse
	var returnVal *api11.SearchRunsWithDataReviewMetricsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SearchRunsWithDataReviewMetrics"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/search-runs-with-data-review-metrics"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "searchRunsWithDataReviewMetrics failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "searchRunsWithDataReviewMetrics response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) SearchRunsWithDataReviewSummary(ctx context.Context, authHeader bearertoken.Token, requestArg api4.SearchRunsRequest) (api11.SearchRunsWithDataReviewSummaryResponse, error) {
	var defaultReturnVal api11.SearchRunsWithDataReviewSummaryResponse
	var returnVal *api11.SearchRunsWithDataReviewSummaryResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SearchRunsWithDataReviewSummary"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/search-runs-with-data-review-summary"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "searchRunsWithDataReviewSummary failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "searchRunsWithDataReviewSummary response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) ArchiveRun(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid, includeLinkedWorkbooksArg *bool) (bool, error) {
	var defaultReturnVal bool
	var returnVal *bool
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ArchiveRun"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/archive-run/%s", url.PathEscape(fmt.Sprint(ridArg))))
	queryParams := make(url.Values)
	if includeLinkedWorkbooksArg != nil {
		queryParams.Set("includeLinkedWorkbooks", fmt.Sprint(*includeLinkedWorkbooksArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "archiveRun failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "archiveRun response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) UnarchiveRun(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid, includeLinkedWorkbooksArg *bool) (bool, error) {
	var defaultReturnVal bool
	var returnVal *bool
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UnarchiveRun"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/unarchive-run/%s", url.PathEscape(fmt.Sprint(ridArg))))
	queryParams := make(url.Values)
	if includeLinkedWorkbooksArg != nil {
		queryParams.Set("includeLinkedWorkbooks", fmt.Sprint(*includeLinkedWorkbooksArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "unarchiveRun failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "unarchiveRun response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) GetDataSourceRefNameAndTypeList(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) ([]api4.RefNameAndType, error) {
	var returnVal []api4.RefNameAndType
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetDataSourceRefNameAndTypeList"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/data-source-ref-names-and-types"))
	queryParams := make(url.Values)
	for _, v := range workspacesArg {
		queryParams.Add("workspaces", fmt.Sprint(v))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getDataSourceRefNameAndTypeList failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getDataSourceRefNameAndTypeList response cannot be nil")
	}
	return returnVal, nil
}

func (c *runServiceClient) SearchChannels(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid, requestArg api4.SearchRunChannelsRequest) (api4.SearchRunChannelsResponse, error) {
	var defaultReturnVal api4.SearchRunChannelsResponse
	var returnVal *api4.SearchRunChannelsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SearchChannels"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run/%s/search-channels", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "searchChannels failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "searchChannels response cannot be nil")
	}
	return *returnVal, nil
}

func (c *runServiceClient) UpdateRunAttachment(ctx context.Context, authHeader bearertoken.Token, ridArg api4.RunRid, requestArg api4.UpdateAttachmentsRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateRunAttachment"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/run/%s/attachments", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "updateRunAttachment failed")
	}
	return nil
}

/*
Runs are collections of channels and metadata from one or more data sources, synchronized over a
range of real time, which represents a test event or simulation. These API endpoints let you
manage runs in the Nominal app.
*/
type RunServiceClientWithAuth interface {
	/*
	   Create a new run in Nominal.

	   Throws if start is equal to or after end.
	*/
	CreateRun(ctx context.Context, detailsArg api4.CreateRunRequest) (api11.Run, error)
	/*
	   Updates an existing run based on its RID.

	   Throws if start is equal to or after end.
	*/
	UpdateRun(ctx context.Context, ridArg api4.RunRid, detailsArg api4.UpdateRunRequest) (api11.Run, error)
	/*
	   Adds datasources to the run in question.

	   Throws if any of the ref names conflict with existing data sources or each other.
	*/
	AddDataSourcesToRun(ctx context.Context, runRidArg api4.RunRid, requestArg map[api3.DataSourceRefName]api4.CreateRunDataSource) (api11.Run, error)
	/*
	   Updates a run if it exists, otherwise it's created from scratch.
	   Will throw if the workspace of an existing run is different from the workspace of the request.
	*/
	CreateOrUpdateRun(ctx context.Context, detailsArg api4.CreateOrUpdateRunRequest) (api11.Run, error)
	// Fetches details about the run in question based on its RID.
	GetRun(ctx context.Context, ridArg api4.RunRid) (api11.Run, error)
	/*
	   Fetches details about the run in question based on its RID,
	   including metrics for check and violation review status.
	*/
	GetRunWithDataReviewMetrics(ctx context.Context, ridArg api4.RunRid) (api11.RunWithDataReviewMetrics, error)
	// Fetches details about the run in question based on its RID, including a summary of the data review status.
	GetRunWithDataReviewSummary(ctx context.Context, ridArg api4.RunRid) (api11.RunWithDataReviewSummary, error)
	// Fetches a run based on the run number, rather than RID.
	GetRunById(ctx context.Context, getRunByIdRequestArg api4.GetRunByIdRequest) (api11.Run, error)
	// Fetches a list of run details based on a list of RIDs.
	GetRuns(ctx context.Context, ridsArg []api4.RunRid) (map[api4.RunRid]api11.Run, error)
	// Fetches the runs with the given asset.
	GetRunsByAsset(ctx context.Context, requestArg api4.GetRunsByAssetRequest) (api11.GetRunsByAssetResponse, error)
	// Deprecated: Deprecated in favor of MetadataService#listPropertiesAndLabels
	GetAllRunsPropertiesAndLabels(ctx context.Context, workspacesArg []rids.WorkspaceRid) (api4.AllRunsPropertiesAndLabelsResponse, error)
	// Searches for runs that match the given filters.
	SearchRuns(ctx context.Context, requestArg api4.SearchRunsRequest) (api11.SearchRunsResponse, error)
	/*
	   Searches for runs that match the given filters and
	   includes metrics for check and violation review status.
	*/
	SearchRunsWithDataReviewMetrics(ctx context.Context, requestArg api4.SearchRunsRequest) (api11.SearchRunsWithDataReviewMetricsResponse, error)
	/*
	   Searches for runs that match the given filters and includes a summary of the data review status.

	   Deprecated: Deprecated in favor of searchRunsWithDataReviewMetrics
	*/
	SearchRunsWithDataReviewSummary(ctx context.Context, requestArg api4.SearchRunsRequest) (api11.SearchRunsWithDataReviewSummaryResponse, error)
	// Soft-deletes a run. Runs still exist in the database but are no longer visible.
	ArchiveRun(ctx context.Context, ridArg api4.RunRid, includeLinkedWorkbooksArg *bool) (bool, error)
	UnarchiveRun(ctx context.Context, ridArg api4.RunRid, includeLinkedWorkbooksArg *bool) (bool, error)
	// Returns the list of ref names that are in use across specified and authorized workspaces.
	GetDataSourceRefNameAndTypeList(ctx context.Context, workspacesArg []rids.WorkspaceRid) ([]api4.RefNameAndType, error)
	// Deprecated: Deprecated in favor of DatasourceChannelSearchService#searchChannels
	SearchChannels(ctx context.Context, ridArg api4.RunRid, requestArg api4.SearchRunChannelsRequest) (api4.SearchRunChannelsResponse, error)
	// Updates the attachments associated with a run.
	UpdateRunAttachment(ctx context.Context, ridArg api4.RunRid, requestArg api4.UpdateAttachmentsRequest) error
}

func NewRunServiceClientWithAuth(client RunServiceClient, authHeader bearertoken.Token) RunServiceClientWithAuth {
	return &runServiceClientWithAuth{client: client, authHeader: authHeader}
}

type runServiceClientWithAuth struct {
	client     RunServiceClient
	authHeader bearertoken.Token
}

func (c *runServiceClientWithAuth) CreateRun(ctx context.Context, detailsArg api4.CreateRunRequest) (api11.Run, error) {
	return c.client.CreateRun(ctx, c.authHeader, detailsArg)
}

func (c *runServiceClientWithAuth) UpdateRun(ctx context.Context, ridArg api4.RunRid, detailsArg api4.UpdateRunRequest) (api11.Run, error) {
	return c.client.UpdateRun(ctx, c.authHeader, ridArg, detailsArg)
}

func (c *runServiceClientWithAuth) AddDataSourcesToRun(ctx context.Context, runRidArg api4.RunRid, requestArg map[api3.DataSourceRefName]api4.CreateRunDataSource) (api11.Run, error) {
	return c.client.AddDataSourcesToRun(ctx, c.authHeader, runRidArg, requestArg)
}

func (c *runServiceClientWithAuth) CreateOrUpdateRun(ctx context.Context, detailsArg api4.CreateOrUpdateRunRequest) (api11.Run, error) {
	return c.client.CreateOrUpdateRun(ctx, c.authHeader, detailsArg)
}

func (c *runServiceClientWithAuth) GetRun(ctx context.Context, ridArg api4.RunRid) (api11.Run, error) {
	return c.client.GetRun(ctx, c.authHeader, ridArg)
}

func (c *runServiceClientWithAuth) GetRunWithDataReviewMetrics(ctx context.Context, ridArg api4.RunRid) (api11.RunWithDataReviewMetrics, error) {
	return c.client.GetRunWithDataReviewMetrics(ctx, c.authHeader, ridArg)
}

func (c *runServiceClientWithAuth) GetRunWithDataReviewSummary(ctx context.Context, ridArg api4.RunRid) (api11.RunWithDataReviewSummary, error) {
	return c.client.GetRunWithDataReviewSummary(ctx, c.authHeader, ridArg)
}

func (c *runServiceClientWithAuth) GetRunById(ctx context.Context, getRunByIdRequestArg api4.GetRunByIdRequest) (api11.Run, error) {
	return c.client.GetRunById(ctx, c.authHeader, getRunByIdRequestArg)
}

func (c *runServiceClientWithAuth) GetRuns(ctx context.Context, ridsArg []api4.RunRid) (map[api4.RunRid]api11.Run, error) {
	return c.client.GetRuns(ctx, c.authHeader, ridsArg)
}

func (c *runServiceClientWithAuth) GetRunsByAsset(ctx context.Context, requestArg api4.GetRunsByAssetRequest) (api11.GetRunsByAssetResponse, error) {
	return c.client.GetRunsByAsset(ctx, c.authHeader, requestArg)
}

func (c *runServiceClientWithAuth) GetAllRunsPropertiesAndLabels(ctx context.Context, workspacesArg []rids.WorkspaceRid) (api4.AllRunsPropertiesAndLabelsResponse, error) {
	return c.client.GetAllRunsPropertiesAndLabels(ctx, c.authHeader, workspacesArg)
}

func (c *runServiceClientWithAuth) SearchRuns(ctx context.Context, requestArg api4.SearchRunsRequest) (api11.SearchRunsResponse, error) {
	return c.client.SearchRuns(ctx, c.authHeader, requestArg)
}

func (c *runServiceClientWithAuth) SearchRunsWithDataReviewMetrics(ctx context.Context, requestArg api4.SearchRunsRequest) (api11.SearchRunsWithDataReviewMetricsResponse, error) {
	return c.client.SearchRunsWithDataReviewMetrics(ctx, c.authHeader, requestArg)
}

func (c *runServiceClientWithAuth) SearchRunsWithDataReviewSummary(ctx context.Context, requestArg api4.SearchRunsRequest) (api11.SearchRunsWithDataReviewSummaryResponse, error) {
	return c.client.SearchRunsWithDataReviewSummary(ctx, c.authHeader, requestArg)
}

func (c *runServiceClientWithAuth) ArchiveRun(ctx context.Context, ridArg api4.RunRid, includeLinkedWorkbooksArg *bool) (bool, error) {
	return c.client.ArchiveRun(ctx, c.authHeader, ridArg, includeLinkedWorkbooksArg)
}

func (c *runServiceClientWithAuth) UnarchiveRun(ctx context.Context, ridArg api4.RunRid, includeLinkedWorkbooksArg *bool) (bool, error) {
	return c.client.UnarchiveRun(ctx, c.authHeader, ridArg, includeLinkedWorkbooksArg)
}

func (c *runServiceClientWithAuth) GetDataSourceRefNameAndTypeList(ctx context.Context, workspacesArg []rids.WorkspaceRid) ([]api4.RefNameAndType, error) {
	return c.client.GetDataSourceRefNameAndTypeList(ctx, c.authHeader, workspacesArg)
}

func (c *runServiceClientWithAuth) SearchChannels(ctx context.Context, ridArg api4.RunRid, requestArg api4.SearchRunChannelsRequest) (api4.SearchRunChannelsResponse, error) {
	return c.client.SearchChannels(ctx, c.authHeader, ridArg, requestArg)
}

func (c *runServiceClientWithAuth) UpdateRunAttachment(ctx context.Context, ridArg api4.RunRid, requestArg api4.UpdateAttachmentsRequest) error {
	return c.client.UpdateRunAttachment(ctx, c.authHeader, ridArg, requestArg)
}

func NewRunServiceClientWithTokenProvider(client RunServiceClient, tokenProvider httpclient.TokenProvider) RunServiceClientWithAuth {
	return &runServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type runServiceClientWithTokenProvider struct {
	client        RunServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *runServiceClientWithTokenProvider) CreateRun(ctx context.Context, detailsArg api4.CreateRunRequest) (api11.Run, error) {
	var defaultReturnVal api11.Run
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateRun(ctx, bearertoken.Token(token), detailsArg)
}

func (c *runServiceClientWithTokenProvider) UpdateRun(ctx context.Context, ridArg api4.RunRid, detailsArg api4.UpdateRunRequest) (api11.Run, error) {
	var defaultReturnVal api11.Run
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateRun(ctx, bearertoken.Token(token), ridArg, detailsArg)
}

func (c *runServiceClientWithTokenProvider) AddDataSourcesToRun(ctx context.Context, runRidArg api4.RunRid, requestArg map[api3.DataSourceRefName]api4.CreateRunDataSource) (api11.Run, error) {
	var defaultReturnVal api11.Run
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.AddDataSourcesToRun(ctx, bearertoken.Token(token), runRidArg, requestArg)
}

func (c *runServiceClientWithTokenProvider) CreateOrUpdateRun(ctx context.Context, detailsArg api4.CreateOrUpdateRunRequest) (api11.Run, error) {
	var defaultReturnVal api11.Run
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateOrUpdateRun(ctx, bearertoken.Token(token), detailsArg)
}

func (c *runServiceClientWithTokenProvider) GetRun(ctx context.Context, ridArg api4.RunRid) (api11.Run, error) {
	var defaultReturnVal api11.Run
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetRun(ctx, bearertoken.Token(token), ridArg)
}

func (c *runServiceClientWithTokenProvider) GetRunWithDataReviewMetrics(ctx context.Context, ridArg api4.RunRid) (api11.RunWithDataReviewMetrics, error) {
	var defaultReturnVal api11.RunWithDataReviewMetrics
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetRunWithDataReviewMetrics(ctx, bearertoken.Token(token), ridArg)
}

func (c *runServiceClientWithTokenProvider) GetRunWithDataReviewSummary(ctx context.Context, ridArg api4.RunRid) (api11.RunWithDataReviewSummary, error) {
	var defaultReturnVal api11.RunWithDataReviewSummary
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetRunWithDataReviewSummary(ctx, bearertoken.Token(token), ridArg)
}

func (c *runServiceClientWithTokenProvider) GetRunById(ctx context.Context, getRunByIdRequestArg api4.GetRunByIdRequest) (api11.Run, error) {
	var defaultReturnVal api11.Run
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetRunById(ctx, bearertoken.Token(token), getRunByIdRequestArg)
}

func (c *runServiceClientWithTokenProvider) GetRuns(ctx context.Context, ridsArg []api4.RunRid) (map[api4.RunRid]api11.Run, error) {
	var defaultReturnVal map[api4.RunRid]api11.Run
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetRuns(ctx, bearertoken.Token(token), ridsArg)
}

func (c *runServiceClientWithTokenProvider) GetRunsByAsset(ctx context.Context, requestArg api4.GetRunsByAssetRequest) (api11.GetRunsByAssetResponse, error) {
	var defaultReturnVal api11.GetRunsByAssetResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetRunsByAsset(ctx, bearertoken.Token(token), requestArg)
}

func (c *runServiceClientWithTokenProvider) GetAllRunsPropertiesAndLabels(ctx context.Context, workspacesArg []rids.WorkspaceRid) (api4.AllRunsPropertiesAndLabelsResponse, error) {
	var defaultReturnVal api4.AllRunsPropertiesAndLabelsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetAllRunsPropertiesAndLabels(ctx, bearertoken.Token(token), workspacesArg)
}

func (c *runServiceClientWithTokenProvider) SearchRuns(ctx context.Context, requestArg api4.SearchRunsRequest) (api11.SearchRunsResponse, error) {
	var defaultReturnVal api11.SearchRunsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.SearchRuns(ctx, bearertoken.Token(token), requestArg)
}

func (c *runServiceClientWithTokenProvider) SearchRunsWithDataReviewMetrics(ctx context.Context, requestArg api4.SearchRunsRequest) (api11.SearchRunsWithDataReviewMetricsResponse, error) {
	var defaultReturnVal api11.SearchRunsWithDataReviewMetricsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.SearchRunsWithDataReviewMetrics(ctx, bearertoken.Token(token), requestArg)
}

func (c *runServiceClientWithTokenProvider) SearchRunsWithDataReviewSummary(ctx context.Context, requestArg api4.SearchRunsRequest) (api11.SearchRunsWithDataReviewSummaryResponse, error) {
	var defaultReturnVal api11.SearchRunsWithDataReviewSummaryResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.SearchRunsWithDataReviewSummary(ctx, bearertoken.Token(token), requestArg)
}

func (c *runServiceClientWithTokenProvider) ArchiveRun(ctx context.Context, ridArg api4.RunRid, includeLinkedWorkbooksArg *bool) (bool, error) {
	var defaultReturnVal bool
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ArchiveRun(ctx, bearertoken.Token(token), ridArg, includeLinkedWorkbooksArg)
}

func (c *runServiceClientWithTokenProvider) UnarchiveRun(ctx context.Context, ridArg api4.RunRid, includeLinkedWorkbooksArg *bool) (bool, error) {
	var defaultReturnVal bool
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UnarchiveRun(ctx, bearertoken.Token(token), ridArg, includeLinkedWorkbooksArg)
}

func (c *runServiceClientWithTokenProvider) GetDataSourceRefNameAndTypeList(ctx context.Context, workspacesArg []rids.WorkspaceRid) ([]api4.RefNameAndType, error) {
	var defaultReturnVal []api4.RefNameAndType
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetDataSourceRefNameAndTypeList(ctx, bearertoken.Token(token), workspacesArg)
}

func (c *runServiceClientWithTokenProvider) SearchChannels(ctx context.Context, ridArg api4.RunRid, requestArg api4.SearchRunChannelsRequest) (api4.SearchRunChannelsResponse, error) {
	var defaultReturnVal api4.SearchRunChannelsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.SearchChannels(ctx, bearertoken.Token(token), ridArg, requestArg)
}

func (c *runServiceClientWithTokenProvider) UpdateRunAttachment(ctx context.Context, ridArg api4.RunRid, requestArg api4.UpdateAttachmentsRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.UpdateRunAttachment(ctx, bearertoken.Token(token), ridArg, requestArg)
}

/*
TemplateService manages templates, which are workbooks that
can be re-used across runs. Templates are versioned.
*/
type TemplateServiceClient interface {
	// Creates a new template.
	Create(ctx context.Context, authHeader bearertoken.Token, requestArg api5.CreateTemplateRequest) (api5.Template, error)
	/*
	   Must only pass one of (branch, commit). If neither are passed,
	   the latest commit on the "main" branch is returned.
	   Throws if the template, branch, or commit doesn't exist.
	*/
	Get(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, branchArg *api.BranchName, commitArg *api.CommitId) (api5.Template, error)
	BatchGetMetadata(ctx context.Context, authHeader bearertoken.Token, ridsArg []api2.TemplateRid) ([]api5.TemplateSummary, error)
	/*
	   Creates a commit that may be compacted, e.g cleaned up and not exist anymore.
	   Throws if the template or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you save to an archived template.
	*/
	SaveWorkingState(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.SaveTemplateRequest) (api5.Template, error)
	// Returns the set of all ref names used by the template.
	GetUsedRefNames(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, branchArg *api.BranchName, commitArg *api.CommitId) ([]api3.DataSourceRefName, error)
	// Updates the data source ref names for all variables used in the template.
	UpdateRefNames(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.UpdateRefNameRequest) (api5.Template, error)
	/*
	   Creates a commit with a commit message.
	   Throws if the template or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you commit to an archived template.
	*/
	Commit(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.CommitTemplateRequest) (api5.Template, error)
	// Throws if the template doesn't exist.
	UpdateMetadata(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, requestArg api5.UpdateMetadataRequest) (api5.TemplateMetadata, error)
	SearchTemplates(ctx context.Context, authHeader bearertoken.Token, requestArg api5.SearchTemplatesRequest) (api5.SearchTemplatesResponse, error)
	GetAllLabelsAndProperties(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) (api5.GetAllLabelsAndPropertiesResponse, error)
	/*
	   Merges the given branch to the "main" branch.
	   Throws if the template or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you merge on an archived template.
	*/
	MergeToMain(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, requestArg api5.MergeToMainRequest) (api5.Template, error)
}

type templateServiceClient struct {
	client httpclient.Client
}

func NewTemplateServiceClient(client httpclient.Client) TemplateServiceClient {
	return &templateServiceClient{client: client}
}

func (c *templateServiceClient) Create(ctx context.Context, authHeader bearertoken.Token, requestArg api5.CreateTemplateRequest) (api5.Template, error) {
	var defaultReturnVal api5.Template
	var returnVal *api5.Template
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Create"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/template"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "create failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "create response cannot be nil")
	}
	return *returnVal, nil
}

func (c *templateServiceClient) Get(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, branchArg *api.BranchName, commitArg *api.CommitId) (api5.Template, error) {
	var defaultReturnVal api5.Template
	var returnVal *api5.Template
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Get"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/template/%s", url.PathEscape(fmt.Sprint(templateRidArg))))
	queryParams := make(url.Values)
	if branchArg != nil {
		queryParams.Set("branch", fmt.Sprint(*branchArg))
	}
	if commitArg != nil {
		queryParams.Set("commit", fmt.Sprint(*commitArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "get failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "get response cannot be nil")
	}
	return *returnVal, nil
}

func (c *templateServiceClient) BatchGetMetadata(ctx context.Context, authHeader bearertoken.Token, ridsArg []api2.TemplateRid) ([]api5.TemplateSummary, error) {
	var returnVal []api5.TemplateSummary
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGetMetadata"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/template/batch-get-metadata"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(ridsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGetMetadata failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGetMetadata response cannot be nil")
	}
	return returnVal, nil
}

func (c *templateServiceClient) SaveWorkingState(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.SaveTemplateRequest) (api5.Template, error) {
	var defaultReturnVal api5.Template
	var returnVal *api5.Template
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SaveWorkingState"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/template/%s/save-working-state", url.PathEscape(fmt.Sprint(templateRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	queryParams := make(url.Values)
	if branchArg != nil {
		queryParams.Set("branch", fmt.Sprint(*branchArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "saveWorkingState failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "saveWorkingState response cannot be nil")
	}
	return *returnVal, nil
}

func (c *templateServiceClient) GetUsedRefNames(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, branchArg *api.BranchName, commitArg *api.CommitId) ([]api3.DataSourceRefName, error) {
	var returnVal []api3.DataSourceRefName
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetUsedRefNames"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/template/%s/ref-names", url.PathEscape(fmt.Sprint(templateRidArg))))
	queryParams := make(url.Values)
	if branchArg != nil {
		queryParams.Set("branch", fmt.Sprint(*branchArg))
	}
	if commitArg != nil {
		queryParams.Set("commit", fmt.Sprint(*commitArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getUsedRefNames failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getUsedRefNames response cannot be nil")
	}
	return returnVal, nil
}

func (c *templateServiceClient) UpdateRefNames(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.UpdateRefNameRequest) (api5.Template, error) {
	var defaultReturnVal api5.Template
	var returnVal *api5.Template
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateRefNames"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/template/%s/update-ref-names", url.PathEscape(fmt.Sprint(templateRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	queryParams := make(url.Values)
	if branchArg != nil {
		queryParams.Set("branch", fmt.Sprint(*branchArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateRefNames failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateRefNames response cannot be nil")
	}
	return *returnVal, nil
}

func (c *templateServiceClient) Commit(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.CommitTemplateRequest) (api5.Template, error) {
	var defaultReturnVal api5.Template
	var returnVal *api5.Template
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Commit"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/template/%s/commit", url.PathEscape(fmt.Sprint(templateRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	queryParams := make(url.Values)
	if branchArg != nil {
		queryParams.Set("branch", fmt.Sprint(*branchArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "commit failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "commit response cannot be nil")
	}
	return *returnVal, nil
}

func (c *templateServiceClient) UpdateMetadata(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, requestArg api5.UpdateMetadataRequest) (api5.TemplateMetadata, error) {
	var defaultReturnVal api5.TemplateMetadata
	var returnVal *api5.TemplateMetadata
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("UpdateMetadata"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/template/%s/metadata", url.PathEscape(fmt.Sprint(templateRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "updateMetadata failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "updateMetadata response cannot be nil")
	}
	return *returnVal, nil
}

func (c *templateServiceClient) SearchTemplates(ctx context.Context, authHeader bearertoken.Token, requestArg api5.SearchTemplatesRequest) (api5.SearchTemplatesResponse, error) {
	var defaultReturnVal api5.SearchTemplatesResponse
	var returnVal *api5.SearchTemplatesResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("SearchTemplates"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/template/search"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "searchTemplates failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "searchTemplates response cannot be nil")
	}
	return *returnVal, nil
}

func (c *templateServiceClient) GetAllLabelsAndProperties(ctx context.Context, authHeader bearertoken.Token, workspacesArg []rids.WorkspaceRid) (api5.GetAllLabelsAndPropertiesResponse, error) {
	var defaultReturnVal api5.GetAllLabelsAndPropertiesResponse
	var returnVal *api5.GetAllLabelsAndPropertiesResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetAllLabelsAndProperties"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/template/get-all-labels-properties"))
	queryParams := make(url.Values)
	for _, v := range workspacesArg {
		queryParams.Add("workspaces", fmt.Sprint(v))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getAllLabelsAndProperties failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getAllLabelsAndProperties response cannot be nil")
	}
	return *returnVal, nil
}

func (c *templateServiceClient) MergeToMain(ctx context.Context, authHeader bearertoken.Token, templateRidArg api2.TemplateRid, requestArg api5.MergeToMainRequest) (api5.Template, error) {
	var defaultReturnVal api5.Template
	var returnVal *api5.Template
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("MergeToMain"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/template/%s/merge-to-main", url.PathEscape(fmt.Sprint(templateRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "mergeToMain failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "mergeToMain response cannot be nil")
	}
	return *returnVal, nil
}

/*
TemplateService manages templates, which are workbooks that
can be re-used across runs. Templates are versioned.
*/
type TemplateServiceClientWithAuth interface {
	// Creates a new template.
	Create(ctx context.Context, requestArg api5.CreateTemplateRequest) (api5.Template, error)
	/*
	   Must only pass one of (branch, commit). If neither are passed,
	   the latest commit on the "main" branch is returned.
	   Throws if the template, branch, or commit doesn't exist.
	*/
	Get(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, commitArg *api.CommitId) (api5.Template, error)
	BatchGetMetadata(ctx context.Context, ridsArg []api2.TemplateRid) ([]api5.TemplateSummary, error)
	/*
	   Creates a commit that may be compacted, e.g cleaned up and not exist anymore.
	   Throws if the template or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you save to an archived template.
	*/
	SaveWorkingState(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.SaveTemplateRequest) (api5.Template, error)
	// Returns the set of all ref names used by the template.
	GetUsedRefNames(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, commitArg *api.CommitId) ([]api3.DataSourceRefName, error)
	// Updates the data source ref names for all variables used in the template.
	UpdateRefNames(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.UpdateRefNameRequest) (api5.Template, error)
	/*
	   Creates a commit with a commit message.
	   Throws if the template or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you commit to an archived template.
	*/
	Commit(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.CommitTemplateRequest) (api5.Template, error)
	// Throws if the template doesn't exist.
	UpdateMetadata(ctx context.Context, templateRidArg api2.TemplateRid, requestArg api5.UpdateMetadataRequest) (api5.TemplateMetadata, error)
	SearchTemplates(ctx context.Context, requestArg api5.SearchTemplatesRequest) (api5.SearchTemplatesResponse, error)
	GetAllLabelsAndProperties(ctx context.Context, workspacesArg []rids.WorkspaceRid) (api5.GetAllLabelsAndPropertiesResponse, error)
	/*
	   Merges the given branch to the "main" branch.
	   Throws if the template or branch doesn't exist.
	   Throws if the latest commit doesn't match the provided id.
	   Throws if you merge on an archived template.
	*/
	MergeToMain(ctx context.Context, templateRidArg api2.TemplateRid, requestArg api5.MergeToMainRequest) (api5.Template, error)
}

func NewTemplateServiceClientWithAuth(client TemplateServiceClient, authHeader bearertoken.Token) TemplateServiceClientWithAuth {
	return &templateServiceClientWithAuth{client: client, authHeader: authHeader}
}

type templateServiceClientWithAuth struct {
	client     TemplateServiceClient
	authHeader bearertoken.Token
}

func (c *templateServiceClientWithAuth) Create(ctx context.Context, requestArg api5.CreateTemplateRequest) (api5.Template, error) {
	return c.client.Create(ctx, c.authHeader, requestArg)
}

func (c *templateServiceClientWithAuth) Get(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, commitArg *api.CommitId) (api5.Template, error) {
	return c.client.Get(ctx, c.authHeader, templateRidArg, branchArg, commitArg)
}

func (c *templateServiceClientWithAuth) BatchGetMetadata(ctx context.Context, ridsArg []api2.TemplateRid) ([]api5.TemplateSummary, error) {
	return c.client.BatchGetMetadata(ctx, c.authHeader, ridsArg)
}

func (c *templateServiceClientWithAuth) SaveWorkingState(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.SaveTemplateRequest) (api5.Template, error) {
	return c.client.SaveWorkingState(ctx, c.authHeader, templateRidArg, branchArg, requestArg)
}

func (c *templateServiceClientWithAuth) GetUsedRefNames(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, commitArg *api.CommitId) ([]api3.DataSourceRefName, error) {
	return c.client.GetUsedRefNames(ctx, c.authHeader, templateRidArg, branchArg, commitArg)
}

func (c *templateServiceClientWithAuth) UpdateRefNames(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.UpdateRefNameRequest) (api5.Template, error) {
	return c.client.UpdateRefNames(ctx, c.authHeader, templateRidArg, branchArg, requestArg)
}

func (c *templateServiceClientWithAuth) Commit(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.CommitTemplateRequest) (api5.Template, error) {
	return c.client.Commit(ctx, c.authHeader, templateRidArg, branchArg, requestArg)
}

func (c *templateServiceClientWithAuth) UpdateMetadata(ctx context.Context, templateRidArg api2.TemplateRid, requestArg api5.UpdateMetadataRequest) (api5.TemplateMetadata, error) {
	return c.client.UpdateMetadata(ctx, c.authHeader, templateRidArg, requestArg)
}

func (c *templateServiceClientWithAuth) SearchTemplates(ctx context.Context, requestArg api5.SearchTemplatesRequest) (api5.SearchTemplatesResponse, error) {
	return c.client.SearchTemplates(ctx, c.authHeader, requestArg)
}

func (c *templateServiceClientWithAuth) GetAllLabelsAndProperties(ctx context.Context, workspacesArg []rids.WorkspaceRid) (api5.GetAllLabelsAndPropertiesResponse, error) {
	return c.client.GetAllLabelsAndProperties(ctx, c.authHeader, workspacesArg)
}

func (c *templateServiceClientWithAuth) MergeToMain(ctx context.Context, templateRidArg api2.TemplateRid, requestArg api5.MergeToMainRequest) (api5.Template, error) {
	return c.client.MergeToMain(ctx, c.authHeader, templateRidArg, requestArg)
}

func NewTemplateServiceClientWithTokenProvider(client TemplateServiceClient, tokenProvider httpclient.TokenProvider) TemplateServiceClientWithAuth {
	return &templateServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type templateServiceClientWithTokenProvider struct {
	client        TemplateServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *templateServiceClientWithTokenProvider) Create(ctx context.Context, requestArg api5.CreateTemplateRequest) (api5.Template, error) {
	var defaultReturnVal api5.Template
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Create(ctx, bearertoken.Token(token), requestArg)
}

func (c *templateServiceClientWithTokenProvider) Get(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, commitArg *api.CommitId) (api5.Template, error) {
	var defaultReturnVal api5.Template
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Get(ctx, bearertoken.Token(token), templateRidArg, branchArg, commitArg)
}

func (c *templateServiceClientWithTokenProvider) BatchGetMetadata(ctx context.Context, ridsArg []api2.TemplateRid) ([]api5.TemplateSummary, error) {
	var defaultReturnVal []api5.TemplateSummary
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGetMetadata(ctx, bearertoken.Token(token), ridsArg)
}

func (c *templateServiceClientWithTokenProvider) SaveWorkingState(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.SaveTemplateRequest) (api5.Template, error) {
	var defaultReturnVal api5.Template
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.SaveWorkingState(ctx, bearertoken.Token(token), templateRidArg, branchArg, requestArg)
}

func (c *templateServiceClientWithTokenProvider) GetUsedRefNames(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, commitArg *api.CommitId) ([]api3.DataSourceRefName, error) {
	var defaultReturnVal []api3.DataSourceRefName
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetUsedRefNames(ctx, bearertoken.Token(token), templateRidArg, branchArg, commitArg)
}

func (c *templateServiceClientWithTokenProvider) UpdateRefNames(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.UpdateRefNameRequest) (api5.Template, error) {
	var defaultReturnVal api5.Template
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateRefNames(ctx, bearertoken.Token(token), templateRidArg, branchArg, requestArg)
}

func (c *templateServiceClientWithTokenProvider) Commit(ctx context.Context, templateRidArg api2.TemplateRid, branchArg *api.BranchName, requestArg api5.CommitTemplateRequest) (api5.Template, error) {
	var defaultReturnVal api5.Template
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Commit(ctx, bearertoken.Token(token), templateRidArg, branchArg, requestArg)
}

func (c *templateServiceClientWithTokenProvider) UpdateMetadata(ctx context.Context, templateRidArg api2.TemplateRid, requestArg api5.UpdateMetadataRequest) (api5.TemplateMetadata, error) {
	var defaultReturnVal api5.TemplateMetadata
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.UpdateMetadata(ctx, bearertoken.Token(token), templateRidArg, requestArg)
}

func (c *templateServiceClientWithTokenProvider) SearchTemplates(ctx context.Context, requestArg api5.SearchTemplatesRequest) (api5.SearchTemplatesResponse, error) {
	var defaultReturnVal api5.SearchTemplatesResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.SearchTemplates(ctx, bearertoken.Token(token), requestArg)
}

func (c *templateServiceClientWithTokenProvider) GetAllLabelsAndProperties(ctx context.Context, workspacesArg []rids.WorkspaceRid) (api5.GetAllLabelsAndPropertiesResponse, error) {
	var defaultReturnVal api5.GetAllLabelsAndPropertiesResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetAllLabelsAndProperties(ctx, bearertoken.Token(token), workspacesArg)
}

func (c *templateServiceClientWithTokenProvider) MergeToMain(ctx context.Context, templateRidArg api2.TemplateRid, requestArg api5.MergeToMainRequest) (api5.Template, error) {
	var defaultReturnVal api5.Template
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.MergeToMain(ctx, bearertoken.Token(token), templateRidArg, requestArg)
}

/*
The Units Service serves as a comprehensive catalog of the units of measurement supported by scout. Units, by
default, follow the UCUM convention for representation.
*/
type UnitsServiceClient interface {
	// Returns all known units, grouped by the physical property they measure.
	GetAllUnits(ctx context.Context, authHeader bearertoken.Token) (api6.GetUnitsResponse, error)
	// Returns information for a unit symbol if available. Returns as empty if the provided symbol cannot be parsed.
	GetUnit(ctx context.Context, authHeader bearertoken.Token, unitArg api6.UnitSymbol) (*api6.Unit, error)
	/*
	   Returns information for the unit symbols if available. If the provided symbol cannot be parsed, it will be
	   omitted from the map.
	*/
	GetBatchUnits(ctx context.Context, authHeader bearertoken.Token, unitsArg []api6.UnitSymbol) (map[api6.UnitSymbol]api6.Unit, error)
	/*
	   Returns the set of cataloged units that can be converted to and from the given unit.
	   No commensurable units does not imply the unit is invalid. Use /get-unit to check for validity.
	*/
	GetCommensurableUnits(ctx context.Context, authHeader bearertoken.Token, unitArg api6.UnitSymbol) ([]api6.Unit, error)
}

type unitsServiceClient struct {
	client httpclient.Client
}

func NewUnitsServiceClient(client httpclient.Client) UnitsServiceClient {
	return &unitsServiceClient{client: client}
}

func (c *unitsServiceClient) GetAllUnits(ctx context.Context, authHeader bearertoken.Token) (api6.GetUnitsResponse, error) {
	var defaultReturnVal api6.GetUnitsResponse
	var returnVal *api6.GetUnitsResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetAllUnits"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/units/v1/units"))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getAllUnits failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getAllUnits response cannot be nil")
	}
	return *returnVal, nil
}

func (c *unitsServiceClient) GetUnit(ctx context.Context, authHeader bearertoken.Token, unitArg api6.UnitSymbol) (*api6.Unit, error) {
	var returnVal *api6.Unit
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetUnit"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/units/v1/units/get-unit"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(unitArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getUnit failed")
	}
	return returnVal, nil
}

func (c *unitsServiceClient) GetBatchUnits(ctx context.Context, authHeader bearertoken.Token, unitsArg []api6.UnitSymbol) (map[api6.UnitSymbol]api6.Unit, error) {
	var returnVal map[api6.UnitSymbol]api6.Unit
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetBatchUnits"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/units/v1/units/get-batch-units"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(unitsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getBatchUnits failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getBatchUnits response cannot be nil")
	}
	return returnVal, nil
}

func (c *unitsServiceClient) GetCommensurableUnits(ctx context.Context, authHeader bearertoken.Token, unitArg api6.UnitSymbol) ([]api6.Unit, error) {
	var returnVal []api6.Unit
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetCommensurableUnits"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/units/v1/units/commensurable-units"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(unitArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getCommensurableUnits failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getCommensurableUnits response cannot be nil")
	}
	return returnVal, nil
}

/*
The Units Service serves as a comprehensive catalog of the units of measurement supported by scout. Units, by
default, follow the UCUM convention for representation.
*/
type UnitsServiceClientWithAuth interface {
	// Returns all known units, grouped by the physical property they measure.
	GetAllUnits(ctx context.Context) (api6.GetUnitsResponse, error)
	// Returns information for a unit symbol if available. Returns as empty if the provided symbol cannot be parsed.
	GetUnit(ctx context.Context, unitArg api6.UnitSymbol) (*api6.Unit, error)
	/*
	   Returns information for the unit symbols if available. If the provided symbol cannot be parsed, it will be
	   omitted from the map.
	*/
	GetBatchUnits(ctx context.Context, unitsArg []api6.UnitSymbol) (map[api6.UnitSymbol]api6.Unit, error)
	/*
	   Returns the set of cataloged units that can be converted to and from the given unit.
	   No commensurable units does not imply the unit is invalid. Use /get-unit to check for validity.
	*/
	GetCommensurableUnits(ctx context.Context, unitArg api6.UnitSymbol) ([]api6.Unit, error)
}

func NewUnitsServiceClientWithAuth(client UnitsServiceClient, authHeader bearertoken.Token) UnitsServiceClientWithAuth {
	return &unitsServiceClientWithAuth{client: client, authHeader: authHeader}
}

type unitsServiceClientWithAuth struct {
	client     UnitsServiceClient
	authHeader bearertoken.Token
}

func (c *unitsServiceClientWithAuth) GetAllUnits(ctx context.Context) (api6.GetUnitsResponse, error) {
	return c.client.GetAllUnits(ctx, c.authHeader)
}

func (c *unitsServiceClientWithAuth) GetUnit(ctx context.Context, unitArg api6.UnitSymbol) (*api6.Unit, error) {
	return c.client.GetUnit(ctx, c.authHeader, unitArg)
}

func (c *unitsServiceClientWithAuth) GetBatchUnits(ctx context.Context, unitsArg []api6.UnitSymbol) (map[api6.UnitSymbol]api6.Unit, error) {
	return c.client.GetBatchUnits(ctx, c.authHeader, unitsArg)
}

func (c *unitsServiceClientWithAuth) GetCommensurableUnits(ctx context.Context, unitArg api6.UnitSymbol) ([]api6.Unit, error) {
	return c.client.GetCommensurableUnits(ctx, c.authHeader, unitArg)
}

func NewUnitsServiceClientWithTokenProvider(client UnitsServiceClient, tokenProvider httpclient.TokenProvider) UnitsServiceClientWithAuth {
	return &unitsServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type unitsServiceClientWithTokenProvider struct {
	client        UnitsServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *unitsServiceClientWithTokenProvider) GetAllUnits(ctx context.Context) (api6.GetUnitsResponse, error) {
	var defaultReturnVal api6.GetUnitsResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetAllUnits(ctx, bearertoken.Token(token))
}

func (c *unitsServiceClientWithTokenProvider) GetUnit(ctx context.Context, unitArg api6.UnitSymbol) (*api6.Unit, error) {
	var defaultReturnVal *api6.Unit
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetUnit(ctx, bearertoken.Token(token), unitArg)
}

func (c *unitsServiceClientWithTokenProvider) GetBatchUnits(ctx context.Context, unitsArg []api6.UnitSymbol) (map[api6.UnitSymbol]api6.Unit, error) {
	var defaultReturnVal map[api6.UnitSymbol]api6.Unit
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetBatchUnits(ctx, bearertoken.Token(token), unitsArg)
}

func (c *unitsServiceClientWithTokenProvider) GetCommensurableUnits(ctx context.Context, unitArg api6.UnitSymbol) ([]api6.Unit, error) {
	var defaultReturnVal []api6.Unit
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetCommensurableUnits(ctx, bearertoken.Token(token), unitArg)
}

/*
This is the external-facing portion of VersioningService which
gives clients access to functionality that doesn't create new
commits. The creation of new commits should be done via the
resource-specific services.
*/
type VersioningServiceClient interface {
	/*
	   Creates a mutable pointer to the provided commit.
	   "Saves"/"commits" can be performed on this pointer.
	   Throws if the name is already used as a commit
	   pointer for this resource.
	   Throws if the provided commit doesn't exist.
	*/
	CreateBranch(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, requestArg api.CreateBranchRequest) (api.Branch, error)
	/*
	   Creates an immutable pointer to the provided commit.
	   Throws if the name is already used as a commit
	   pointer for this resource.
	   Throws if the provided commit doesn't exist.
	*/
	CreateTag(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, requestArg api.CreateTagRequest) (api.Tag, error)
	// Throws if the commit doesn't exist.
	GetCommit(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, commitIdArg api.CommitId) (api.Commit, error)
	// Filters out resources that are not authorized.
	BatchGetCommits(ctx context.Context, authHeader bearertoken.Token, resourceAndCommitIdsArg []api.ResourceAndCommitId) ([]api.Commit, error)
	/*
	   Returns the commit pointed to by the branch.
	   Throws if the branch doesn't exist.
	*/
	GetCommitByBranch(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) (api.Commit, error)
	/*
	   Returns the commit pointed to by the tag.
	   Throws if the tag doesn't exist.
	*/
	GetCommitByTag(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) (api.Commit, error)
	/*
	   Returns the least common ancestor of the two commits.
	   Throws if either commit doesn't exist.
	*/
	GetLeastCommonAncestor(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, requestArg api.GetLeastCommonAncestorRequest) (api.CommitId, error)
	/*
	   Returns the commit history sorted by creation time descending.
	   Excludes working state commits.
	   Throws if the commit doesn't exist.
	*/
	GetCommitHistory(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, commitIdArg api.CommitId, pageSizeArg *int, nextPageTokenArg *api7.Token) (api.CommitHistory, error)
	/*
	   Persists the commits so that they are not compacted.
	   This operation is atomic - either all commits are persisted
	   or none are (in the case of an error).
	*/
	PersistCommits(ctx context.Context, authHeader bearertoken.Token, requestArg []api.ResourceAndCommitId) error
	// Throws if the branch doesn't exist.
	GetBranch(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) (api.Branch, error)
	/*
	   Returns all branches for the resource in order of
	   most recently updated.
	*/
	GetBranches(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier) ([]api.Branch, error)
	// Omits branches that are not authorized.
	BatchGetBranches(ctx context.Context, authHeader bearertoken.Token, resourceAndBranchesArg []api.ResourceAndBranchName) ([]api.Branch, error)
	// Throws if the tag doesn't exist.
	GetTag(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) (api.Tag, error)
	// Omits tags that are not authorized.
	BatchGetTags(ctx context.Context, authHeader bearertoken.Token, resourceAndCommitsArg []api.ResourceAndCommitId) ([]api.Tag, error)
	/*
	   Returns all tags for the resource in order of
	   most recently created.
	*/
	GetTagsByResource(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier) ([]api.Tag, error)
	/*
	   Deletes the branch pointer.
	   Throws if the branch doesn't exist.
	   Throws if you attempt to delete the "main" branch.
	*/
	DeleteBranch(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) error
	/*
	   Deletes the branch pointers.
	   Throws if any resource or branch is non-existent
	   or unauthorized.
	   Throws if any attempt is made to delete "main".
	*/
	DeleteBranches(ctx context.Context, authHeader bearertoken.Token, resourceAndBranchesArg []api.ResourceAndBranchName) error
	/*
	   Deletes the tag pointer.
	   Throws if the tag doesn't exist.
	*/
	DeleteTag(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) error
}

type versioningServiceClient struct {
	client httpclient.Client
}

func NewVersioningServiceClient(client httpclient.Client) VersioningServiceClient {
	return &versioningServiceClient{client: client}
}

func (c *versioningServiceClient) CreateBranch(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, requestArg api.CreateBranchRequest) (api.Branch, error) {
	var defaultReturnVal api.Branch
	var returnVal *api.Branch
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateBranch"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/branch", url.PathEscape(fmt.Sprint(resourceRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createBranch failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createBranch response cannot be nil")
	}
	return *returnVal, nil
}

func (c *versioningServiceClient) CreateTag(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, requestArg api.CreateTagRequest) (api.Tag, error) {
	var defaultReturnVal api.Tag
	var returnVal *api.Tag
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateTag"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/tag", url.PathEscape(fmt.Sprint(resourceRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createTag failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createTag response cannot be nil")
	}
	return *returnVal, nil
}

func (c *versioningServiceClient) GetCommit(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, commitIdArg api.CommitId) (api.Commit, error) {
	var defaultReturnVal api.Commit
	var returnVal *api.Commit
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetCommit"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/commit/%s", url.PathEscape(fmt.Sprint(resourceRidArg)), url.PathEscape(fmt.Sprint(commitIdArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getCommit failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getCommit response cannot be nil")
	}
	return *returnVal, nil
}

func (c *versioningServiceClient) BatchGetCommits(ctx context.Context, authHeader bearertoken.Token, resourceAndCommitIdsArg []api.ResourceAndCommitId) ([]api.Commit, error) {
	var returnVal []api.Commit
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGetCommits"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/commit/batch-get"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(resourceAndCommitIdsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGetCommits failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGetCommits response cannot be nil")
	}
	return returnVal, nil
}

func (c *versioningServiceClient) GetCommitByBranch(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) (api.Commit, error) {
	var defaultReturnVal api.Commit
	var returnVal *api.Commit
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetCommitByBranch"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/branch/%s/commit", url.PathEscape(fmt.Sprint(resourceRidArg)), url.PathEscape(fmt.Sprint(branchNameArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getCommitByBranch failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getCommitByBranch response cannot be nil")
	}
	return *returnVal, nil
}

func (c *versioningServiceClient) GetCommitByTag(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) (api.Commit, error) {
	var defaultReturnVal api.Commit
	var returnVal *api.Commit
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetCommitByTag"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/tag/%s/commit", url.PathEscape(fmt.Sprint(resourceRidArg)), url.PathEscape(fmt.Sprint(tagNameArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getCommitByTag failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getCommitByTag response cannot be nil")
	}
	return *returnVal, nil
}

func (c *versioningServiceClient) GetLeastCommonAncestor(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, requestArg api.GetLeastCommonAncestorRequest) (api.CommitId, error) {
	var defaultReturnVal api.CommitId
	var returnVal *api.CommitId
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetLeastCommonAncestor"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/commit/least-common-ancestor", url.PathEscape(fmt.Sprint(resourceRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getLeastCommonAncestor failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getLeastCommonAncestor response cannot be nil")
	}
	return *returnVal, nil
}

func (c *versioningServiceClient) GetCommitHistory(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, commitIdArg api.CommitId, pageSizeArg *int, nextPageTokenArg *api7.Token) (api.CommitHistory, error) {
	var defaultReturnVal api.CommitHistory
	var returnVal *api.CommitHistory
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetCommitHistory"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/commit/%s/history", url.PathEscape(fmt.Sprint(resourceRidArg)), url.PathEscape(fmt.Sprint(commitIdArg))))
	queryParams := make(url.Values)
	if pageSizeArg != nil {
		queryParams.Set("pageSize", fmt.Sprint(*pageSizeArg))
	}
	if nextPageTokenArg != nil {
		queryParams.Set("nextPageToken", fmt.Sprint(*nextPageTokenArg))
	}
	requestParams = append(requestParams, httpclient.WithQueryValues(queryParams))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getCommitHistory failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getCommitHistory response cannot be nil")
	}
	return *returnVal, nil
}

func (c *versioningServiceClient) PersistCommits(ctx context.Context, authHeader bearertoken.Token, requestArg []api.ResourceAndCommitId) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("PersistCommits"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/commit/persist"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "persistCommits failed")
	}
	return nil
}

func (c *versioningServiceClient) GetBranch(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) (api.Branch, error) {
	var defaultReturnVal api.Branch
	var returnVal *api.Branch
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetBranch"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/branch/%s", url.PathEscape(fmt.Sprint(resourceRidArg)), url.PathEscape(fmt.Sprint(branchNameArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getBranch failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getBranch response cannot be nil")
	}
	return *returnVal, nil
}

func (c *versioningServiceClient) GetBranches(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier) ([]api.Branch, error) {
	var returnVal []api.Branch
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetBranches"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/branch", url.PathEscape(fmt.Sprint(resourceRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getBranches failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getBranches response cannot be nil")
	}
	return returnVal, nil
}

func (c *versioningServiceClient) BatchGetBranches(ctx context.Context, authHeader bearertoken.Token, resourceAndBranchesArg []api.ResourceAndBranchName) ([]api.Branch, error) {
	var returnVal []api.Branch
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGetBranches"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/branch/batch-get"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(resourceAndBranchesArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGetBranches failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGetBranches response cannot be nil")
	}
	return returnVal, nil
}

func (c *versioningServiceClient) GetTag(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) (api.Tag, error) {
	var defaultReturnVal api.Tag
	var returnVal *api.Tag
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetTag"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/tag/%s", url.PathEscape(fmt.Sprint(resourceRidArg)), url.PathEscape(fmt.Sprint(tagNameArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getTag failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getTag response cannot be nil")
	}
	return *returnVal, nil
}

func (c *versioningServiceClient) BatchGetTags(ctx context.Context, authHeader bearertoken.Token, resourceAndCommitsArg []api.ResourceAndCommitId) ([]api.Tag, error) {
	var returnVal []api.Tag
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGetTags"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/tag/batch-get"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(resourceAndCommitsArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGetTags failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGetTags response cannot be nil")
	}
	return returnVal, nil
}

func (c *versioningServiceClient) GetTagsByResource(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier) ([]api.Tag, error) {
	var returnVal []api.Tag
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetTagsByResource"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/tag", url.PathEscape(fmt.Sprint(resourceRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "getTagsByResource failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "getTagsByResource response cannot be nil")
	}
	return returnVal, nil
}

func (c *versioningServiceClient) DeleteBranch(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("DeleteBranch"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("DELETE"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/branch/%s", url.PathEscape(fmt.Sprint(resourceRidArg)), url.PathEscape(fmt.Sprint(branchNameArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "deleteBranch failed")
	}
	return nil
}

func (c *versioningServiceClient) DeleteBranches(ctx context.Context, authHeader bearertoken.Token, resourceAndBranchesArg []api.ResourceAndBranchName) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("DeleteBranches"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/branch/batch-delete"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(resourceAndBranchesArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "deleteBranches failed")
	}
	return nil
}

func (c *versioningServiceClient) DeleteTag(ctx context.Context, authHeader bearertoken.Token, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("DeleteTag"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("DELETE"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/scout/v1/versioning/%s/tag/%s", url.PathEscape(fmt.Sprint(resourceRidArg)), url.PathEscape(fmt.Sprint(tagNameArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "deleteTag failed")
	}
	return nil
}

/*
This is the external-facing portion of VersioningService which
gives clients access to functionality that doesn't create new
commits. The creation of new commits should be done via the
resource-specific services.
*/
type VersioningServiceClientWithAuth interface {
	/*
	   Creates a mutable pointer to the provided commit.
	   "Saves"/"commits" can be performed on this pointer.
	   Throws if the name is already used as a commit
	   pointer for this resource.
	   Throws if the provided commit doesn't exist.
	*/
	CreateBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.CreateBranchRequest) (api.Branch, error)
	/*
	   Creates an immutable pointer to the provided commit.
	   Throws if the name is already used as a commit
	   pointer for this resource.
	   Throws if the provided commit doesn't exist.
	*/
	CreateTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.CreateTagRequest) (api.Tag, error)
	// Throws if the commit doesn't exist.
	GetCommit(ctx context.Context, resourceRidArg rid.ResourceIdentifier, commitIdArg api.CommitId) (api.Commit, error)
	// Filters out resources that are not authorized.
	BatchGetCommits(ctx context.Context, resourceAndCommitIdsArg []api.ResourceAndCommitId) ([]api.Commit, error)
	/*
	   Returns the commit pointed to by the branch.
	   Throws if the branch doesn't exist.
	*/
	GetCommitByBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) (api.Commit, error)
	/*
	   Returns the commit pointed to by the tag.
	   Throws if the tag doesn't exist.
	*/
	GetCommitByTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) (api.Commit, error)
	/*
	   Returns the least common ancestor of the two commits.
	   Throws if either commit doesn't exist.
	*/
	GetLeastCommonAncestor(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.GetLeastCommonAncestorRequest) (api.CommitId, error)
	/*
	   Returns the commit history sorted by creation time descending.
	   Excludes working state commits.
	   Throws if the commit doesn't exist.
	*/
	GetCommitHistory(ctx context.Context, resourceRidArg rid.ResourceIdentifier, commitIdArg api.CommitId, pageSizeArg *int, nextPageTokenArg *api7.Token) (api.CommitHistory, error)
	/*
	   Persists the commits so that they are not compacted.
	   This operation is atomic - either all commits are persisted
	   or none are (in the case of an error).
	*/
	PersistCommits(ctx context.Context, requestArg []api.ResourceAndCommitId) error
	// Throws if the branch doesn't exist.
	GetBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) (api.Branch, error)
	/*
	   Returns all branches for the resource in order of
	   most recently updated.
	*/
	GetBranches(ctx context.Context, resourceRidArg rid.ResourceIdentifier) ([]api.Branch, error)
	// Omits branches that are not authorized.
	BatchGetBranches(ctx context.Context, resourceAndBranchesArg []api.ResourceAndBranchName) ([]api.Branch, error)
	// Throws if the tag doesn't exist.
	GetTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) (api.Tag, error)
	// Omits tags that are not authorized.
	BatchGetTags(ctx context.Context, resourceAndCommitsArg []api.ResourceAndCommitId) ([]api.Tag, error)
	/*
	   Returns all tags for the resource in order of
	   most recently created.
	*/
	GetTagsByResource(ctx context.Context, resourceRidArg rid.ResourceIdentifier) ([]api.Tag, error)
	/*
	   Deletes the branch pointer.
	   Throws if the branch doesn't exist.
	   Throws if you attempt to delete the "main" branch.
	*/
	DeleteBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) error
	/*
	   Deletes the branch pointers.
	   Throws if any resource or branch is non-existent
	   or unauthorized.
	   Throws if any attempt is made to delete "main".
	*/
	DeleteBranches(ctx context.Context, resourceAndBranchesArg []api.ResourceAndBranchName) error
	/*
	   Deletes the tag pointer.
	   Throws if the tag doesn't exist.
	*/
	DeleteTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) error
}

func NewVersioningServiceClientWithAuth(client VersioningServiceClient, authHeader bearertoken.Token) VersioningServiceClientWithAuth {
	return &versioningServiceClientWithAuth{client: client, authHeader: authHeader}
}

type versioningServiceClientWithAuth struct {
	client     VersioningServiceClient
	authHeader bearertoken.Token
}

func (c *versioningServiceClientWithAuth) CreateBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.CreateBranchRequest) (api.Branch, error) {
	return c.client.CreateBranch(ctx, c.authHeader, resourceRidArg, requestArg)
}

func (c *versioningServiceClientWithAuth) CreateTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.CreateTagRequest) (api.Tag, error) {
	return c.client.CreateTag(ctx, c.authHeader, resourceRidArg, requestArg)
}

func (c *versioningServiceClientWithAuth) GetCommit(ctx context.Context, resourceRidArg rid.ResourceIdentifier, commitIdArg api.CommitId) (api.Commit, error) {
	return c.client.GetCommit(ctx, c.authHeader, resourceRidArg, commitIdArg)
}

func (c *versioningServiceClientWithAuth) BatchGetCommits(ctx context.Context, resourceAndCommitIdsArg []api.ResourceAndCommitId) ([]api.Commit, error) {
	return c.client.BatchGetCommits(ctx, c.authHeader, resourceAndCommitIdsArg)
}

func (c *versioningServiceClientWithAuth) GetCommitByBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) (api.Commit, error) {
	return c.client.GetCommitByBranch(ctx, c.authHeader, resourceRidArg, branchNameArg)
}

func (c *versioningServiceClientWithAuth) GetCommitByTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) (api.Commit, error) {
	return c.client.GetCommitByTag(ctx, c.authHeader, resourceRidArg, tagNameArg)
}

func (c *versioningServiceClientWithAuth) GetLeastCommonAncestor(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.GetLeastCommonAncestorRequest) (api.CommitId, error) {
	return c.client.GetLeastCommonAncestor(ctx, c.authHeader, resourceRidArg, requestArg)
}

func (c *versioningServiceClientWithAuth) GetCommitHistory(ctx context.Context, resourceRidArg rid.ResourceIdentifier, commitIdArg api.CommitId, pageSizeArg *int, nextPageTokenArg *api7.Token) (api.CommitHistory, error) {
	return c.client.GetCommitHistory(ctx, c.authHeader, resourceRidArg, commitIdArg, pageSizeArg, nextPageTokenArg)
}

func (c *versioningServiceClientWithAuth) PersistCommits(ctx context.Context, requestArg []api.ResourceAndCommitId) error {
	return c.client.PersistCommits(ctx, c.authHeader, requestArg)
}

func (c *versioningServiceClientWithAuth) GetBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) (api.Branch, error) {
	return c.client.GetBranch(ctx, c.authHeader, resourceRidArg, branchNameArg)
}

func (c *versioningServiceClientWithAuth) GetBranches(ctx context.Context, resourceRidArg rid.ResourceIdentifier) ([]api.Branch, error) {
	return c.client.GetBranches(ctx, c.authHeader, resourceRidArg)
}

func (c *versioningServiceClientWithAuth) BatchGetBranches(ctx context.Context, resourceAndBranchesArg []api.ResourceAndBranchName) ([]api.Branch, error) {
	return c.client.BatchGetBranches(ctx, c.authHeader, resourceAndBranchesArg)
}

func (c *versioningServiceClientWithAuth) GetTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) (api.Tag, error) {
	return c.client.GetTag(ctx, c.authHeader, resourceRidArg, tagNameArg)
}

func (c *versioningServiceClientWithAuth) BatchGetTags(ctx context.Context, resourceAndCommitsArg []api.ResourceAndCommitId) ([]api.Tag, error) {
	return c.client.BatchGetTags(ctx, c.authHeader, resourceAndCommitsArg)
}

func (c *versioningServiceClientWithAuth) GetTagsByResource(ctx context.Context, resourceRidArg rid.ResourceIdentifier) ([]api.Tag, error) {
	return c.client.GetTagsByResource(ctx, c.authHeader, resourceRidArg)
}

func (c *versioningServiceClientWithAuth) DeleteBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) error {
	return c.client.DeleteBranch(ctx, c.authHeader, resourceRidArg, branchNameArg)
}

func (c *versioningServiceClientWithAuth) DeleteBranches(ctx context.Context, resourceAndBranchesArg []api.ResourceAndBranchName) error {
	return c.client.DeleteBranches(ctx, c.authHeader, resourceAndBranchesArg)
}

func (c *versioningServiceClientWithAuth) DeleteTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) error {
	return c.client.DeleteTag(ctx, c.authHeader, resourceRidArg, tagNameArg)
}

func NewVersioningServiceClientWithTokenProvider(client VersioningServiceClient, tokenProvider httpclient.TokenProvider) VersioningServiceClientWithAuth {
	return &versioningServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type versioningServiceClientWithTokenProvider struct {
	client        VersioningServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *versioningServiceClientWithTokenProvider) CreateBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.CreateBranchRequest) (api.Branch, error) {
	var defaultReturnVal api.Branch
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateBranch(ctx, bearertoken.Token(token), resourceRidArg, requestArg)
}

func (c *versioningServiceClientWithTokenProvider) CreateTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.CreateTagRequest) (api.Tag, error) {
	var defaultReturnVal api.Tag
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateTag(ctx, bearertoken.Token(token), resourceRidArg, requestArg)
}

func (c *versioningServiceClientWithTokenProvider) GetCommit(ctx context.Context, resourceRidArg rid.ResourceIdentifier, commitIdArg api.CommitId) (api.Commit, error) {
	var defaultReturnVal api.Commit
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetCommit(ctx, bearertoken.Token(token), resourceRidArg, commitIdArg)
}

func (c *versioningServiceClientWithTokenProvider) BatchGetCommits(ctx context.Context, resourceAndCommitIdsArg []api.ResourceAndCommitId) ([]api.Commit, error) {
	var defaultReturnVal []api.Commit
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGetCommits(ctx, bearertoken.Token(token), resourceAndCommitIdsArg)
}

func (c *versioningServiceClientWithTokenProvider) GetCommitByBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) (api.Commit, error) {
	var defaultReturnVal api.Commit
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetCommitByBranch(ctx, bearertoken.Token(token), resourceRidArg, branchNameArg)
}

func (c *versioningServiceClientWithTokenProvider) GetCommitByTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) (api.Commit, error) {
	var defaultReturnVal api.Commit
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetCommitByTag(ctx, bearertoken.Token(token), resourceRidArg, tagNameArg)
}

func (c *versioningServiceClientWithTokenProvider) GetLeastCommonAncestor(ctx context.Context, resourceRidArg rid.ResourceIdentifier, requestArg api.GetLeastCommonAncestorRequest) (api.CommitId, error) {
	var defaultReturnVal api.CommitId
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetLeastCommonAncestor(ctx, bearertoken.Token(token), resourceRidArg, requestArg)
}

func (c *versioningServiceClientWithTokenProvider) GetCommitHistory(ctx context.Context, resourceRidArg rid.ResourceIdentifier, commitIdArg api.CommitId, pageSizeArg *int, nextPageTokenArg *api7.Token) (api.CommitHistory, error) {
	var defaultReturnVal api.CommitHistory
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetCommitHistory(ctx, bearertoken.Token(token), resourceRidArg, commitIdArg, pageSizeArg, nextPageTokenArg)
}

func (c *versioningServiceClientWithTokenProvider) PersistCommits(ctx context.Context, requestArg []api.ResourceAndCommitId) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.PersistCommits(ctx, bearertoken.Token(token), requestArg)
}

func (c *versioningServiceClientWithTokenProvider) GetBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) (api.Branch, error) {
	var defaultReturnVal api.Branch
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetBranch(ctx, bearertoken.Token(token), resourceRidArg, branchNameArg)
}

func (c *versioningServiceClientWithTokenProvider) GetBranches(ctx context.Context, resourceRidArg rid.ResourceIdentifier) ([]api.Branch, error) {
	var defaultReturnVal []api.Branch
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetBranches(ctx, bearertoken.Token(token), resourceRidArg)
}

func (c *versioningServiceClientWithTokenProvider) BatchGetBranches(ctx context.Context, resourceAndBranchesArg []api.ResourceAndBranchName) ([]api.Branch, error) {
	var defaultReturnVal []api.Branch
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGetBranches(ctx, bearertoken.Token(token), resourceAndBranchesArg)
}

func (c *versioningServiceClientWithTokenProvider) GetTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) (api.Tag, error) {
	var defaultReturnVal api.Tag
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetTag(ctx, bearertoken.Token(token), resourceRidArg, tagNameArg)
}

func (c *versioningServiceClientWithTokenProvider) BatchGetTags(ctx context.Context, resourceAndCommitsArg []api.ResourceAndCommitId) ([]api.Tag, error) {
	var defaultReturnVal []api.Tag
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGetTags(ctx, bearertoken.Token(token), resourceAndCommitsArg)
}

func (c *versioningServiceClientWithTokenProvider) GetTagsByResource(ctx context.Context, resourceRidArg rid.ResourceIdentifier) ([]api.Tag, error) {
	var defaultReturnVal []api.Tag
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.GetTagsByResource(ctx, bearertoken.Token(token), resourceRidArg)
}

func (c *versioningServiceClientWithTokenProvider) DeleteBranch(ctx context.Context, resourceRidArg rid.ResourceIdentifier, branchNameArg api.BranchName) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.DeleteBranch(ctx, bearertoken.Token(token), resourceRidArg, branchNameArg)
}

func (c *versioningServiceClientWithTokenProvider) DeleteBranches(ctx context.Context, resourceAndBranchesArg []api.ResourceAndBranchName) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.DeleteBranches(ctx, bearertoken.Token(token), resourceAndBranchesArg)
}

func (c *versioningServiceClientWithTokenProvider) DeleteTag(ctx context.Context, resourceRidArg rid.ResourceIdentifier, tagNameArg api.TagName) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.DeleteTag(ctx, bearertoken.Token(token), resourceRidArg, tagNameArg)
}
