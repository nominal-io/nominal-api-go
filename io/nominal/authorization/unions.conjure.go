// Code generated by conjure-go. DO NOT EDIT.

package authorization

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type Claim struct {
	typ        string
	string     *string
	stringList *[]string
}

type claimDeserializer struct {
	Type       string    `json:"type"`
	String     *string   `json:"string"`
	StringList *[]string `json:"stringList"`
}

func (u *claimDeserializer) toStruct() Claim {
	return Claim{typ: u.Type, string: u.String, stringList: u.StringList}
}

func (u *Claim) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "string":
		if u.string == nil {
			return nil, fmt.Errorf("field \"string\" is required")
		}
		return struct {
			Type   string `json:"type"`
			String string `json:"string"`
		}{Type: "string", String: *u.string}, nil
	case "stringList":
		if u.stringList == nil {
			return nil, fmt.Errorf("field \"stringList\" is required")
		}
		return struct {
			Type       string   `json:"type"`
			StringList []string `json:"stringList"`
		}{Type: "stringList", StringList: *u.stringList}, nil
	}
}

func (u Claim) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Claim) UnmarshalJSON(data []byte) error {
	var deser claimDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
	case "stringList":
		if u.stringList == nil {
			return fmt.Errorf("field \"stringList\" is required")
		}
	}
	return nil
}

func (u Claim) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Claim) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Claim) AcceptFuncs(stringFunc func(string) error, stringListFunc func([]string) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return stringFunc(*u.string)
	case "stringList":
		if u.stringList == nil {
			return fmt.Errorf("field \"stringList\" is required")
		}
		return stringListFunc(*u.stringList)
	}
}

func (u *Claim) StringNoopSuccess(string) error {
	return nil
}

func (u *Claim) StringListNoopSuccess([]string) error {
	return nil
}

func (u *Claim) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Claim) Accept(v ClaimVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitString(*u.string)
	case "stringList":
		if u.stringList == nil {
			return fmt.Errorf("field \"stringList\" is required")
		}
		return v.VisitStringList(*u.stringList)
	}
}

type ClaimVisitor interface {
	VisitString(v string) error
	VisitStringList(v []string) error
	VisitUnknown(typeName string) error
}

func (u *Claim) AcceptWithContext(ctx context.Context, v ClaimVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitStringWithContext(ctx, *u.string)
	case "stringList":
		if u.stringList == nil {
			return fmt.Errorf("field \"stringList\" is required")
		}
		return v.VisitStringListWithContext(ctx, *u.stringList)
	}
}

type ClaimVisitorWithContext interface {
	VisitStringWithContext(ctx context.Context, v string) error
	VisitStringListWithContext(ctx context.Context, v []string) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewClaimFromString(v string) Claim {
	return Claim{typ: "string", string: &v}
}

func NewClaimFromStringList(v []string) Claim {
	return Claim{typ: "stringList", stringList: &v}
}
