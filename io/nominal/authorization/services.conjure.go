// Code generated by conjure-go. DO NOT EDIT.

package authorization

import (
	"context"
	"fmt"
	"net/url"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	"github.com/palantir/pkg/rid"
	werror "github.com/palantir/witchcraft-go-error"
)

/*
Authorization service manages the permissions for a user
to access resources.
*/
type AuthorizationServiceClient interface {
	/*
	   Given a set of resources, returns the set of resources that the
	   user is authorized to access.
	*/
	Authorize(ctx context.Context, authHeader bearertoken.Token, requestArg AuthorizationRequest) ([]rid.ResourceIdentifier, error)
	/*
	   Given a set of resources, returns the workspace that each resource belongs to. If a user
	   is not authorized on the resource, will omit the resource from the response.
	*/
	BatchGetWorkspaceForResource(ctx context.Context, authHeader bearertoken.Token, requestArg []rid.ResourceIdentifier) (map[rid.ResourceIdentifier]rids.WorkspaceRid, error)
	/*
	   Marks a set of resources as belonging to a workspace. Either all resources are
	   registered or none are.
	   If the user is not in the workspace, this will throw.
	   If a resource already belongs to a different workspace, this will throw.
	   If a resource already belongs to this workspace, this is a no-op.
	*/
	RegisterInWorkspace(ctx context.Context, authHeader bearertoken.Token, requestArg RegisterInWorkspaceRequest) error
	/*
	   Given an authenticated session, this endpoint returns a HTTP 204 if the
	   authenticated user is an admin and HTTP 403 otherwise.
	*/
	CheckAdmin(ctx context.Context, authHeader bearertoken.Token) error
	// Checks if the email is allowed to register.
	IsEmailAllowed(ctx context.Context, requestArg IsEmailAllowedRequest) (IsEmailAllowedResponse, error)
	// Checks if the email is allowed to register, following Okta "registration inline hook" API.
	IsEmailAllowedOkta(ctx context.Context, requestArg OktaRegistrationRequest) (OktaRegistrationResponse, error)
	/*
	   Provide an OIDC ID token to get a Nominal access token suitable for making API requests.
	   Its expiry will match that of the input ID token, capped at 24h. TODO(MGMT-933): reduce this duration.
	   Throws NotAuthorized if the ID token is invalid or if the OIDC provider is not known.
	*/
	GetAccessToken(ctx context.Context, requestArg GetAccessTokenRequest) (GetAccessTokenResponse, error)
	/*
	   Given an authenticated session, provide an OIDC access token to get a Nominal access token suitable
	   for making API requests. Its expiry will match that of the input access token, capped at 24h. TODO(MGMT-933):
	   reduce this duration. Throws NotAuthorized if the access token is invalid or if the OIDC provider is not
	   known.
	*/
	RefreshAccessToken(ctx context.Context, requestArg RefreshAccessTokenRequest) (RefreshAccessTokenResponse, error)
	/*
	   Provide a long-lived API key for making API requests.
	   The API key is irretrievable after initial creation.
	*/
	CreateApiKey(ctx context.Context, authHeader bearertoken.Token, requestArg CreateApiKeyRequest) (CreateApiKeyResponse, error)
	// List all API keys in the organization.
	ListApiKeysInOrg(ctx context.Context, authHeader bearertoken.Token, requestArg ListApiKeyRequest) (ListApiKeyResponse, error)
	// List all API keys for the user.
	ListUserApiKeys(ctx context.Context, authHeader bearertoken.Token, requestArg ListApiKeyRequest) (ListApiKeyResponse, error)
	// Delete an API key.
	RevokeApiKey(ctx context.Context, authHeader bearertoken.Token, ridArg ApiKeyRid) error
}

type authorizationServiceClient struct {
	client httpclient.Client
}

func NewAuthorizationServiceClient(client httpclient.Client) AuthorizationServiceClient {
	return &authorizationServiceClient{client: client}
}

func (c *authorizationServiceClient) Authorize(ctx context.Context, authHeader bearertoken.Token, requestArg AuthorizationRequest) ([]rid.ResourceIdentifier, error) {
	var returnVal []rid.ResourceIdentifier
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("Authorize"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/authorize"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "authorize failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "authorize response cannot be nil")
	}
	return returnVal, nil
}

func (c *authorizationServiceClient) BatchGetWorkspaceForResource(ctx context.Context, authHeader bearertoken.Token, requestArg []rid.ResourceIdentifier) (map[rid.ResourceIdentifier]rids.WorkspaceRid, error) {
	var returnVal map[rid.ResourceIdentifier]rids.WorkspaceRid
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("BatchGetWorkspaceForResource"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/batch-get-workspace-for-resource"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return nil, werror.WrapWithContextParams(ctx, err, "batchGetWorkspaceForResource failed")
	}
	if returnVal == nil {
		return nil, werror.ErrorWithContextParams(ctx, "batchGetWorkspaceForResource response cannot be nil")
	}
	return returnVal, nil
}

func (c *authorizationServiceClient) RegisterInWorkspace(ctx context.Context, authHeader bearertoken.Token, requestArg RegisterInWorkspaceRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("RegisterInWorkspace"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/register-in-workspace"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "registerInWorkspace failed")
	}
	return nil
}

func (c *authorizationServiceClient) CheckAdmin(ctx context.Context, authHeader bearertoken.Token) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CheckAdmin"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/checkAdmin"))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "checkAdmin failed")
	}
	return nil
}

func (c *authorizationServiceClient) IsEmailAllowed(ctx context.Context, requestArg IsEmailAllowedRequest) (IsEmailAllowedResponse, error) {
	var defaultReturnVal IsEmailAllowedResponse
	var returnVal *IsEmailAllowedResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("IsEmailAllowed"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/is-email-allowed"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "isEmailAllowed failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "isEmailAllowed response cannot be nil")
	}
	return *returnVal, nil
}

func (c *authorizationServiceClient) IsEmailAllowedOkta(ctx context.Context, requestArg OktaRegistrationRequest) (OktaRegistrationResponse, error) {
	var defaultReturnVal OktaRegistrationResponse
	var returnVal *OktaRegistrationResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("IsEmailAllowedOkta"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/is-email-allowed-okta"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "isEmailAllowedOkta failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "isEmailAllowedOkta response cannot be nil")
	}
	return *returnVal, nil
}

func (c *authorizationServiceClient) GetAccessToken(ctx context.Context, requestArg GetAccessTokenRequest) (GetAccessTokenResponse, error) {
	var defaultReturnVal GetAccessTokenResponse
	var returnVal *GetAccessTokenResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetAccessToken"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/access-token"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getAccessToken failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getAccessToken response cannot be nil")
	}
	return *returnVal, nil
}

func (c *authorizationServiceClient) RefreshAccessToken(ctx context.Context, requestArg RefreshAccessTokenRequest) (RefreshAccessTokenResponse, error) {
	var defaultReturnVal RefreshAccessTokenResponse
	var returnVal *RefreshAccessTokenResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("RefreshAccessToken"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/refresh-access-token"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "refreshAccessToken failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "refreshAccessToken response cannot be nil")
	}
	return *returnVal, nil
}

func (c *authorizationServiceClient) CreateApiKey(ctx context.Context, authHeader bearertoken.Token, requestArg CreateApiKeyRequest) (CreateApiKeyResponse, error) {
	var defaultReturnVal CreateApiKeyResponse
	var returnVal *CreateApiKeyResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("CreateApiKey"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/api-key"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "createApiKey failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "createApiKey response cannot be nil")
	}
	return *returnVal, nil
}

func (c *authorizationServiceClient) ListApiKeysInOrg(ctx context.Context, authHeader bearertoken.Token, requestArg ListApiKeyRequest) (ListApiKeyResponse, error) {
	var defaultReturnVal ListApiKeyResponse
	var returnVal *ListApiKeyResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ListApiKeysInOrg"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/api-keys/org"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "listApiKeysInOrg failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "listApiKeysInOrg response cannot be nil")
	}
	return *returnVal, nil
}

func (c *authorizationServiceClient) ListUserApiKeys(ctx context.Context, authHeader bearertoken.Token, requestArg ListApiKeyRequest) (ListApiKeyResponse, error) {
	var defaultReturnVal ListApiKeyResponse
	var returnVal *ListApiKeyResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("ListUserApiKeys"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/api-keys/user"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "listUserApiKeys failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "listUserApiKeys response cannot be nil")
	}
	return *returnVal, nil
}

func (c *authorizationServiceClient) RevokeApiKey(ctx context.Context, authHeader bearertoken.Token, ridArg ApiKeyRid) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("RevokeApiKey"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("PUT"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/authorization/v1/api-key/%s/delete", url.PathEscape(fmt.Sprint(ridArg))))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "revokeApiKey failed")
	}
	return nil
}

/*
Authorization service manages the permissions for a user
to access resources.
*/
type AuthorizationServiceClientWithAuth interface {
	/*
	   Given a set of resources, returns the set of resources that the
	   user is authorized to access.
	*/
	Authorize(ctx context.Context, requestArg AuthorizationRequest) ([]rid.ResourceIdentifier, error)
	/*
	   Given a set of resources, returns the workspace that each resource belongs to. If a user
	   is not authorized on the resource, will omit the resource from the response.
	*/
	BatchGetWorkspaceForResource(ctx context.Context, requestArg []rid.ResourceIdentifier) (map[rid.ResourceIdentifier]rids.WorkspaceRid, error)
	/*
	   Marks a set of resources as belonging to a workspace. Either all resources are
	   registered or none are.
	   If the user is not in the workspace, this will throw.
	   If a resource already belongs to a different workspace, this will throw.
	   If a resource already belongs to this workspace, this is a no-op.
	*/
	RegisterInWorkspace(ctx context.Context, requestArg RegisterInWorkspaceRequest) error
	/*
	   Given an authenticated session, this endpoint returns a HTTP 204 if the
	   authenticated user is an admin and HTTP 403 otherwise.
	*/
	CheckAdmin(ctx context.Context) error
	// Checks if the email is allowed to register.
	IsEmailAllowed(ctx context.Context, requestArg IsEmailAllowedRequest) (IsEmailAllowedResponse, error)
	// Checks if the email is allowed to register, following Okta "registration inline hook" API.
	IsEmailAllowedOkta(ctx context.Context, requestArg OktaRegistrationRequest) (OktaRegistrationResponse, error)
	/*
	   Provide an OIDC ID token to get a Nominal access token suitable for making API requests.
	   Its expiry will match that of the input ID token, capped at 24h. TODO(MGMT-933): reduce this duration.
	   Throws NotAuthorized if the ID token is invalid or if the OIDC provider is not known.
	*/
	GetAccessToken(ctx context.Context, requestArg GetAccessTokenRequest) (GetAccessTokenResponse, error)
	/*
	   Given an authenticated session, provide an OIDC access token to get a Nominal access token suitable
	   for making API requests. Its expiry will match that of the input access token, capped at 24h. TODO(MGMT-933):
	   reduce this duration. Throws NotAuthorized if the access token is invalid or if the OIDC provider is not
	   known.
	*/
	RefreshAccessToken(ctx context.Context, requestArg RefreshAccessTokenRequest) (RefreshAccessTokenResponse, error)
	/*
	   Provide a long-lived API key for making API requests.
	   The API key is irretrievable after initial creation.
	*/
	CreateApiKey(ctx context.Context, requestArg CreateApiKeyRequest) (CreateApiKeyResponse, error)
	// List all API keys in the organization.
	ListApiKeysInOrg(ctx context.Context, requestArg ListApiKeyRequest) (ListApiKeyResponse, error)
	// List all API keys for the user.
	ListUserApiKeys(ctx context.Context, requestArg ListApiKeyRequest) (ListApiKeyResponse, error)
	// Delete an API key.
	RevokeApiKey(ctx context.Context, ridArg ApiKeyRid) error
}

func NewAuthorizationServiceClientWithAuth(client AuthorizationServiceClient, authHeader bearertoken.Token) AuthorizationServiceClientWithAuth {
	return &authorizationServiceClientWithAuth{client: client, authHeader: authHeader}
}

type authorizationServiceClientWithAuth struct {
	client     AuthorizationServiceClient
	authHeader bearertoken.Token
}

func (c *authorizationServiceClientWithAuth) Authorize(ctx context.Context, requestArg AuthorizationRequest) ([]rid.ResourceIdentifier, error) {
	return c.client.Authorize(ctx, c.authHeader, requestArg)
}

func (c *authorizationServiceClientWithAuth) BatchGetWorkspaceForResource(ctx context.Context, requestArg []rid.ResourceIdentifier) (map[rid.ResourceIdentifier]rids.WorkspaceRid, error) {
	return c.client.BatchGetWorkspaceForResource(ctx, c.authHeader, requestArg)
}

func (c *authorizationServiceClientWithAuth) RegisterInWorkspace(ctx context.Context, requestArg RegisterInWorkspaceRequest) error {
	return c.client.RegisterInWorkspace(ctx, c.authHeader, requestArg)
}

func (c *authorizationServiceClientWithAuth) CheckAdmin(ctx context.Context) error {
	return c.client.CheckAdmin(ctx, c.authHeader)
}

func (c *authorizationServiceClientWithAuth) IsEmailAllowed(ctx context.Context, requestArg IsEmailAllowedRequest) (IsEmailAllowedResponse, error) {
	return c.client.IsEmailAllowed(ctx, requestArg)
}

func (c *authorizationServiceClientWithAuth) IsEmailAllowedOkta(ctx context.Context, requestArg OktaRegistrationRequest) (OktaRegistrationResponse, error) {
	return c.client.IsEmailAllowedOkta(ctx, requestArg)
}

func (c *authorizationServiceClientWithAuth) GetAccessToken(ctx context.Context, requestArg GetAccessTokenRequest) (GetAccessTokenResponse, error) {
	return c.client.GetAccessToken(ctx, requestArg)
}

func (c *authorizationServiceClientWithAuth) RefreshAccessToken(ctx context.Context, requestArg RefreshAccessTokenRequest) (RefreshAccessTokenResponse, error) {
	return c.client.RefreshAccessToken(ctx, requestArg)
}

func (c *authorizationServiceClientWithAuth) CreateApiKey(ctx context.Context, requestArg CreateApiKeyRequest) (CreateApiKeyResponse, error) {
	return c.client.CreateApiKey(ctx, c.authHeader, requestArg)
}

func (c *authorizationServiceClientWithAuth) ListApiKeysInOrg(ctx context.Context, requestArg ListApiKeyRequest) (ListApiKeyResponse, error) {
	return c.client.ListApiKeysInOrg(ctx, c.authHeader, requestArg)
}

func (c *authorizationServiceClientWithAuth) ListUserApiKeys(ctx context.Context, requestArg ListApiKeyRequest) (ListApiKeyResponse, error) {
	return c.client.ListUserApiKeys(ctx, c.authHeader, requestArg)
}

func (c *authorizationServiceClientWithAuth) RevokeApiKey(ctx context.Context, ridArg ApiKeyRid) error {
	return c.client.RevokeApiKey(ctx, c.authHeader, ridArg)
}

func NewAuthorizationServiceClientWithTokenProvider(client AuthorizationServiceClient, tokenProvider httpclient.TokenProvider) AuthorizationServiceClientWithAuth {
	return &authorizationServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type authorizationServiceClientWithTokenProvider struct {
	client        AuthorizationServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *authorizationServiceClientWithTokenProvider) Authorize(ctx context.Context, requestArg AuthorizationRequest) ([]rid.ResourceIdentifier, error) {
	var defaultReturnVal []rid.ResourceIdentifier
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.Authorize(ctx, bearertoken.Token(token), requestArg)
}

func (c *authorizationServiceClientWithTokenProvider) BatchGetWorkspaceForResource(ctx context.Context, requestArg []rid.ResourceIdentifier) (map[rid.ResourceIdentifier]rids.WorkspaceRid, error) {
	var defaultReturnVal map[rid.ResourceIdentifier]rids.WorkspaceRid
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.BatchGetWorkspaceForResource(ctx, bearertoken.Token(token), requestArg)
}

func (c *authorizationServiceClientWithTokenProvider) RegisterInWorkspace(ctx context.Context, requestArg RegisterInWorkspaceRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.RegisterInWorkspace(ctx, bearertoken.Token(token), requestArg)
}

func (c *authorizationServiceClientWithTokenProvider) CheckAdmin(ctx context.Context) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.CheckAdmin(ctx, bearertoken.Token(token))
}

func (c *authorizationServiceClientWithTokenProvider) IsEmailAllowed(ctx context.Context, requestArg IsEmailAllowedRequest) (IsEmailAllowedResponse, error) {
	return c.client.IsEmailAllowed(ctx, requestArg)
}

func (c *authorizationServiceClientWithTokenProvider) IsEmailAllowedOkta(ctx context.Context, requestArg OktaRegistrationRequest) (OktaRegistrationResponse, error) {
	return c.client.IsEmailAllowedOkta(ctx, requestArg)
}

func (c *authorizationServiceClientWithTokenProvider) GetAccessToken(ctx context.Context, requestArg GetAccessTokenRequest) (GetAccessTokenResponse, error) {
	return c.client.GetAccessToken(ctx, requestArg)
}

func (c *authorizationServiceClientWithTokenProvider) RefreshAccessToken(ctx context.Context, requestArg RefreshAccessTokenRequest) (RefreshAccessTokenResponse, error) {
	return c.client.RefreshAccessToken(ctx, requestArg)
}

func (c *authorizationServiceClientWithTokenProvider) CreateApiKey(ctx context.Context, requestArg CreateApiKeyRequest) (CreateApiKeyResponse, error) {
	var defaultReturnVal CreateApiKeyResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.CreateApiKey(ctx, bearertoken.Token(token), requestArg)
}

func (c *authorizationServiceClientWithTokenProvider) ListApiKeysInOrg(ctx context.Context, requestArg ListApiKeyRequest) (ListApiKeyResponse, error) {
	var defaultReturnVal ListApiKeyResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ListApiKeysInOrg(ctx, bearertoken.Token(token), requestArg)
}

func (c *authorizationServiceClientWithTokenProvider) ListUserApiKeys(ctx context.Context, requestArg ListApiKeyRequest) (ListApiKeyResponse, error) {
	var defaultReturnVal ListApiKeyResponse
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.ListUserApiKeys(ctx, bearertoken.Token(token), requestArg)
}

func (c *authorizationServiceClientWithTokenProvider) RevokeApiKey(ctx context.Context, ridArg ApiKeyRid) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.RevokeApiKey(ctx, bearertoken.Token(token), ridArg)
}

// This internal-only service manages long lived api keys.e
type InternalApiKeyServiceClient interface {
	/*
	   Get a Nominal-issued access token from a long-lived API key. Callers should verify that
	   their api key is formatted properly (i.e. prefixed with "nominal_api_key") before calling this endpoint.
	*/
	GetAccessTokenFromApiKeyValue(ctx context.Context, requestArg GetAccessTokenFromApiKeyRequest) (GetAccessTokenResponse, error)
}

type internalApiKeyServiceClient struct {
	client httpclient.Client
}

func NewInternalApiKeyServiceClient(client httpclient.Client) InternalApiKeyServiceClient {
	return &internalApiKeyServiceClient{client: client}
}

func (c *internalApiKeyServiceClient) GetAccessTokenFromApiKeyValue(ctx context.Context, requestArg GetAccessTokenFromApiKeyRequest) (GetAccessTokenResponse, error) {
	var defaultReturnVal GetAccessTokenResponse
	var returnVal *GetAccessTokenResponse
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("GetAccessTokenFromApiKeyValue"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithPathf("/api-key-internal/v1/access-token"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "getAccessTokenFromApiKeyValue failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "getAccessTokenFromApiKeyValue response cannot be nil")
	}
	return *returnVal, nil
}
