// Code generated by conjure-go. DO NOT EDIT.

package event

import (
	"strings"
)

type AggregateType struct {
	val AggregateType_Value
}

type AggregateType_Value string

const (
	AggregateType_TOTAL_DURATION AggregateType_Value = "TOTAL_DURATION"
	AggregateType_TOTAL_COUNT    AggregateType_Value = "TOTAL_COUNT"
	AggregateType_UNKNOWN        AggregateType_Value = "UNKNOWN"
)

// AggregateType_Values returns all known variants of AggregateType.
func AggregateType_Values() []AggregateType_Value {
	return []AggregateType_Value{AggregateType_TOTAL_DURATION, AggregateType_TOTAL_COUNT}
}

func New_AggregateType(value AggregateType_Value) AggregateType {
	return AggregateType{val: value}
}

// IsUnknown returns false for all known variants of AggregateType and true otherwise.
func (e AggregateType) IsUnknown() bool {
	switch e.val {
	case AggregateType_TOTAL_DURATION, AggregateType_TOTAL_COUNT:
		return false
	}
	return true
}

func (e AggregateType) Value() AggregateType_Value {
	if e.IsUnknown() {
		return AggregateType_UNKNOWN
	}
	return e.val
}

func (e AggregateType) String() string {
	return string(e.val)
}

func (e AggregateType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *AggregateType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_AggregateType(AggregateType_Value(v))
	case "TOTAL_DURATION":
		*e = New_AggregateType(AggregateType_TOTAL_DURATION)
	case "TOTAL_COUNT":
		*e = New_AggregateType(AggregateType_TOTAL_COUNT)
	}
	return nil
}

type EventDispositionStatus struct {
	val EventDispositionStatus_Value
}

type EventDispositionStatus_Value string

const (
	EventDispositionStatus_PENDING_REVIEW                 EventDispositionStatus_Value = "PENDING_REVIEW"
	EventDispositionStatus_CLOSED_IGNORED                 EventDispositionStatus_Value = "CLOSED_IGNORED"
	EventDispositionStatus_CLOSED_REQUIRES_FURTHER_ACTION EventDispositionStatus_Value = "CLOSED_REQUIRES_FURTHER_ACTION"
	EventDispositionStatus_NO_DISPOSITION                 EventDispositionStatus_Value = "NO_DISPOSITION"
	EventDispositionStatus_UNKNOWN                        EventDispositionStatus_Value = "UNKNOWN"
)

// EventDispositionStatus_Values returns all known variants of EventDispositionStatus.
func EventDispositionStatus_Values() []EventDispositionStatus_Value {
	return []EventDispositionStatus_Value{EventDispositionStatus_PENDING_REVIEW, EventDispositionStatus_CLOSED_IGNORED, EventDispositionStatus_CLOSED_REQUIRES_FURTHER_ACTION, EventDispositionStatus_NO_DISPOSITION}
}

func New_EventDispositionStatus(value EventDispositionStatus_Value) EventDispositionStatus {
	return EventDispositionStatus{val: value}
}

// IsUnknown returns false for all known variants of EventDispositionStatus and true otherwise.
func (e EventDispositionStatus) IsUnknown() bool {
	switch e.val {
	case EventDispositionStatus_PENDING_REVIEW, EventDispositionStatus_CLOSED_IGNORED, EventDispositionStatus_CLOSED_REQUIRES_FURTHER_ACTION, EventDispositionStatus_NO_DISPOSITION:
		return false
	}
	return true
}

func (e EventDispositionStatus) Value() EventDispositionStatus_Value {
	if e.IsUnknown() {
		return EventDispositionStatus_UNKNOWN
	}
	return e.val
}

func (e EventDispositionStatus) String() string {
	return string(e.val)
}

func (e EventDispositionStatus) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EventDispositionStatus) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EventDispositionStatus(EventDispositionStatus_Value(v))
	case "PENDING_REVIEW":
		*e = New_EventDispositionStatus(EventDispositionStatus_PENDING_REVIEW)
	case "CLOSED_IGNORED":
		*e = New_EventDispositionStatus(EventDispositionStatus_CLOSED_IGNORED)
	case "CLOSED_REQUIRES_FURTHER_ACTION":
		*e = New_EventDispositionStatus(EventDispositionStatus_CLOSED_REQUIRES_FURTHER_ACTION)
	case "NO_DISPOSITION":
		*e = New_EventDispositionStatus(EventDispositionStatus_NO_DISPOSITION)
	}
	return nil
}

type EventTimeFilterCondition struct {
	val EventTimeFilterCondition_Value
}

type EventTimeFilterCondition_Value string

const (
	EventTimeFilterCondition_START_TIME_BEFORE_INCLUSIVE EventTimeFilterCondition_Value = "START_TIME_BEFORE_INCLUSIVE"
	EventTimeFilterCondition_START_TIME_BEFORE_EXCLUSIVE EventTimeFilterCondition_Value = "START_TIME_BEFORE_EXCLUSIVE"
	EventTimeFilterCondition_START_TIME_AFTER_INCLUSIVE  EventTimeFilterCondition_Value = "START_TIME_AFTER_INCLUSIVE"
	EventTimeFilterCondition_START_TIME_AFTER_EXCLUSIVE  EventTimeFilterCondition_Value = "START_TIME_AFTER_EXCLUSIVE"
	EventTimeFilterCondition_END_TIME_BEFORE_INCLUSIVE   EventTimeFilterCondition_Value = "END_TIME_BEFORE_INCLUSIVE"
	EventTimeFilterCondition_END_TIME_BEFORE_EXCLUSIVE   EventTimeFilterCondition_Value = "END_TIME_BEFORE_EXCLUSIVE"
	EventTimeFilterCondition_END_TIME_AFTER_INCLUSIVE    EventTimeFilterCondition_Value = "END_TIME_AFTER_INCLUSIVE"
	EventTimeFilterCondition_END_TIME_AFTER_EXCLUSIVE    EventTimeFilterCondition_Value = "END_TIME_AFTER_EXCLUSIVE"
	EventTimeFilterCondition_UNKNOWN                     EventTimeFilterCondition_Value = "UNKNOWN"
)

// EventTimeFilterCondition_Values returns all known variants of EventTimeFilterCondition.
func EventTimeFilterCondition_Values() []EventTimeFilterCondition_Value {
	return []EventTimeFilterCondition_Value{EventTimeFilterCondition_START_TIME_BEFORE_INCLUSIVE, EventTimeFilterCondition_START_TIME_BEFORE_EXCLUSIVE, EventTimeFilterCondition_START_TIME_AFTER_INCLUSIVE, EventTimeFilterCondition_START_TIME_AFTER_EXCLUSIVE, EventTimeFilterCondition_END_TIME_BEFORE_INCLUSIVE, EventTimeFilterCondition_END_TIME_BEFORE_EXCLUSIVE, EventTimeFilterCondition_END_TIME_AFTER_INCLUSIVE, EventTimeFilterCondition_END_TIME_AFTER_EXCLUSIVE}
}

func New_EventTimeFilterCondition(value EventTimeFilterCondition_Value) EventTimeFilterCondition {
	return EventTimeFilterCondition{val: value}
}

// IsUnknown returns false for all known variants of EventTimeFilterCondition and true otherwise.
func (e EventTimeFilterCondition) IsUnknown() bool {
	switch e.val {
	case EventTimeFilterCondition_START_TIME_BEFORE_INCLUSIVE, EventTimeFilterCondition_START_TIME_BEFORE_EXCLUSIVE, EventTimeFilterCondition_START_TIME_AFTER_INCLUSIVE, EventTimeFilterCondition_START_TIME_AFTER_EXCLUSIVE, EventTimeFilterCondition_END_TIME_BEFORE_INCLUSIVE, EventTimeFilterCondition_END_TIME_BEFORE_EXCLUSIVE, EventTimeFilterCondition_END_TIME_AFTER_INCLUSIVE, EventTimeFilterCondition_END_TIME_AFTER_EXCLUSIVE:
		return false
	}
	return true
}

func (e EventTimeFilterCondition) Value() EventTimeFilterCondition_Value {
	if e.IsUnknown() {
		return EventTimeFilterCondition_UNKNOWN
	}
	return e.val
}

func (e EventTimeFilterCondition) String() string {
	return string(e.val)
}

func (e EventTimeFilterCondition) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EventTimeFilterCondition) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_Value(v))
	case "START_TIME_BEFORE_INCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_START_TIME_BEFORE_INCLUSIVE)
	case "START_TIME_BEFORE_EXCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_START_TIME_BEFORE_EXCLUSIVE)
	case "START_TIME_AFTER_INCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_START_TIME_AFTER_INCLUSIVE)
	case "START_TIME_AFTER_EXCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_START_TIME_AFTER_EXCLUSIVE)
	case "END_TIME_BEFORE_INCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_END_TIME_BEFORE_INCLUSIVE)
	case "END_TIME_BEFORE_EXCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_END_TIME_BEFORE_EXCLUSIVE)
	case "END_TIME_AFTER_INCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_END_TIME_AFTER_INCLUSIVE)
	case "END_TIME_AFTER_EXCLUSIVE":
		*e = New_EventTimeFilterCondition(EventTimeFilterCondition_END_TIME_AFTER_EXCLUSIVE)
	}
	return nil
}

type EventType struct {
	val EventType_Value
}

type EventType_Value string

const (
	EventType_INFO    EventType_Value = "INFO"
	EventType_FLAG    EventType_Value = "FLAG"
	EventType_ERROR   EventType_Value = "ERROR"
	EventType_SUCCESS EventType_Value = "SUCCESS"
	EventType_UNKNOWN EventType_Value = "UNKNOWN"
)

// EventType_Values returns all known variants of EventType.
func EventType_Values() []EventType_Value {
	return []EventType_Value{EventType_INFO, EventType_FLAG, EventType_ERROR, EventType_SUCCESS}
}

func New_EventType(value EventType_Value) EventType {
	return EventType{val: value}
}

// IsUnknown returns false for all known variants of EventType and true otherwise.
func (e EventType) IsUnknown() bool {
	switch e.val {
	case EventType_INFO, EventType_FLAG, EventType_ERROR, EventType_SUCCESS:
		return false
	}
	return true
}

func (e EventType) Value() EventType_Value {
	if e.IsUnknown() {
		return EventType_UNKNOWN
	}
	return e.val
}

func (e EventType) String() string {
	return string(e.val)
}

func (e EventType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *EventType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_EventType(EventType_Value(v))
	case "INFO":
		*e = New_EventType(EventType_INFO)
	case "FLAG":
		*e = New_EventType(EventType_FLAG)
	case "ERROR":
		*e = New_EventType(EventType_ERROR)
	case "SUCCESS":
		*e = New_EventType(EventType_SUCCESS)
	}
	return nil
}

type SearchEventOriginType struct {
	val SearchEventOriginType_Value
}

type SearchEventOriginType_Value string

const (
	SearchEventOriginType_WORKBOOK            SearchEventOriginType_Value = "WORKBOOK"
	SearchEventOriginType_TEMPLATE            SearchEventOriginType_Value = "TEMPLATE"
	SearchEventOriginType_API                 SearchEventOriginType_Value = "API"
	SearchEventOriginType_DATA_REVIEW         SearchEventOriginType_Value = "DATA_REVIEW"
	SearchEventOriginType_PROCEDURE           SearchEventOriginType_Value = "PROCEDURE"
	SearchEventOriginType_STREAMING_CHECKLIST SearchEventOriginType_Value = "STREAMING_CHECKLIST"
	SearchEventOriginType_UNKNOWN             SearchEventOriginType_Value = "UNKNOWN"
)

// SearchEventOriginType_Values returns all known variants of SearchEventOriginType.
func SearchEventOriginType_Values() []SearchEventOriginType_Value {
	return []SearchEventOriginType_Value{SearchEventOriginType_WORKBOOK, SearchEventOriginType_TEMPLATE, SearchEventOriginType_API, SearchEventOriginType_DATA_REVIEW, SearchEventOriginType_PROCEDURE, SearchEventOriginType_STREAMING_CHECKLIST}
}

func New_SearchEventOriginType(value SearchEventOriginType_Value) SearchEventOriginType {
	return SearchEventOriginType{val: value}
}

// IsUnknown returns false for all known variants of SearchEventOriginType and true otherwise.
func (e SearchEventOriginType) IsUnknown() bool {
	switch e.val {
	case SearchEventOriginType_WORKBOOK, SearchEventOriginType_TEMPLATE, SearchEventOriginType_API, SearchEventOriginType_DATA_REVIEW, SearchEventOriginType_PROCEDURE, SearchEventOriginType_STREAMING_CHECKLIST:
		return false
	}
	return true
}

func (e SearchEventOriginType) Value() SearchEventOriginType_Value {
	if e.IsUnknown() {
		return SearchEventOriginType_UNKNOWN
	}
	return e.val
}

func (e SearchEventOriginType) String() string {
	return string(e.val)
}

func (e SearchEventOriginType) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *SearchEventOriginType) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_SearchEventOriginType(SearchEventOriginType_Value(v))
	case "WORKBOOK":
		*e = New_SearchEventOriginType(SearchEventOriginType_WORKBOOK)
	case "TEMPLATE":
		*e = New_SearchEventOriginType(SearchEventOriginType_TEMPLATE)
	case "API":
		*e = New_SearchEventOriginType(SearchEventOriginType_API)
	case "DATA_REVIEW":
		*e = New_SearchEventOriginType(SearchEventOriginType_DATA_REVIEW)
	case "PROCEDURE":
		*e = New_SearchEventOriginType(SearchEventOriginType_PROCEDURE)
	case "STREAMING_CHECKLIST":
		*e = New_SearchEventOriginType(SearchEventOriginType_STREAMING_CHECKLIST)
	}
	return nil
}

type SortField struct {
	val SortField_Value
}

type SortField_Value string

const (
	SortField_START_TIME         SortField_Value = "START_TIME"
	SortField_END_TIME           SortField_Value = "END_TIME"
	SortField_DURATION           SortField_Value = "DURATION"
	SortField_DISPOSITION_STATUS SortField_Value = "DISPOSITION_STATUS"
	SortField_PRIORITY           SortField_Value = "PRIORITY"
	SortField_EVENT_NAME         SortField_Value = "EVENT_NAME"
	SortField_UNKNOWN            SortField_Value = "UNKNOWN"
)

// SortField_Values returns all known variants of SortField.
func SortField_Values() []SortField_Value {
	return []SortField_Value{SortField_START_TIME, SortField_END_TIME, SortField_DURATION, SortField_DISPOSITION_STATUS, SortField_PRIORITY, SortField_EVENT_NAME}
}

func New_SortField(value SortField_Value) SortField {
	return SortField{val: value}
}

// IsUnknown returns false for all known variants of SortField and true otherwise.
func (e SortField) IsUnknown() bool {
	switch e.val {
	case SortField_START_TIME, SortField_END_TIME, SortField_DURATION, SortField_DISPOSITION_STATUS, SortField_PRIORITY, SortField_EVENT_NAME:
		return false
	}
	return true
}

func (e SortField) Value() SortField_Value {
	if e.IsUnknown() {
		return SortField_UNKNOWN
	}
	return e.val
}

func (e SortField) String() string {
	return string(e.val)
}

func (e SortField) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *SortField) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_SortField(SortField_Value(v))
	case "START_TIME":
		*e = New_SortField(SortField_START_TIME)
	case "END_TIME":
		*e = New_SortField(SortField_END_TIME)
	case "DURATION":
		*e = New_SortField(SortField_DURATION)
	case "DISPOSITION_STATUS":
		*e = New_SortField(SortField_DISPOSITION_STATUS)
	case "PRIORITY":
		*e = New_SortField(SortField_PRIORITY)
	case "EVENT_NAME":
		*e = New_SortField(SortField_EVENT_NAME)
	}
	return nil
}
