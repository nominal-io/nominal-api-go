// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type dataSourceNotFound struct {
	DataSourceRid rids.NominalDataSourceRid `json:"dataSourceRid"`
}

func (o dataSourceNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *dataSourceNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDataSourceNotFound returns new instance of DataSourceNotFound error.
func NewDataSourceNotFound(dataSourceRidArg rids.NominalDataSourceRid) *DataSourceNotFound {
	return &DataSourceNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), dataSourceNotFound: dataSourceNotFound{DataSourceRid: dataSourceRidArg}}
}

// WrapWithDataSourceNotFound returns new instance of DataSourceNotFound error wrapping an existing error.
func WrapWithDataSourceNotFound(err error, dataSourceRidArg rids.NominalDataSourceRid) *DataSourceNotFound {
	return &DataSourceNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, dataSourceNotFound: dataSourceNotFound{DataSourceRid: dataSourceRidArg}}
}

// DataSourceNotFound is an error type.
type DataSourceNotFound struct {
	errorInstanceID uuid.UUID
	dataSourceNotFound
	cause error
	stack werror.StackTrace
}

// IsDataSourceNotFound returns true if err is an instance of DataSourceNotFound.
func IsDataSourceNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DataSourceNotFound)
	return ok
}

func (e *DataSourceNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND NominalDataSource:DataSourceNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DataSourceNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DataSourceNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DataSourceNotFound) Message() string {
	return "NOT_FOUND NominalDataSource:DataSourceNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DataSourceNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DataSourceNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *DataSourceNotFound) Name() string {
	return "NominalDataSource:DataSourceNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DataSourceNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DataSourceNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DataSourceNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DataSourceNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DataSourceNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DataSourceNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DataSourceNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.dataSourceNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "NominalDataSource:DataSourceNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DataSourceNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters dataSourceNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.dataSourceNotFound = parameters
	return nil
}

type dataSourcesNotFound struct {
	DataSourceRids []rids.NominalDataSourceRid `json:"dataSourceRids"`
}

func (o dataSourcesNotFound) MarshalJSON() ([]byte, error) {
	if o.DataSourceRids == nil {
		o.DataSourceRids = make([]rids.NominalDataSourceRid, 0)
	}
	type _tmpdataSourcesNotFound dataSourcesNotFound
	return safejson.Marshal(_tmpdataSourcesNotFound(o))
}

func (o *dataSourcesNotFound) UnmarshalJSON(data []byte) error {
	type _tmpdataSourcesNotFound dataSourcesNotFound
	var rawdataSourcesNotFound _tmpdataSourcesNotFound
	if err := safejson.Unmarshal(data, &rawdataSourcesNotFound); err != nil {
		return err
	}
	if rawdataSourcesNotFound.DataSourceRids == nil {
		rawdataSourcesNotFound.DataSourceRids = make([]rids.NominalDataSourceRid, 0)
	}
	*o = dataSourcesNotFound(rawdataSourcesNotFound)
	return nil
}

func (o dataSourcesNotFound) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *dataSourcesNotFound) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewDataSourcesNotFound returns new instance of DataSourcesNotFound error.
func NewDataSourcesNotFound(dataSourceRidsArg []rids.NominalDataSourceRid) *DataSourcesNotFound {
	return &DataSourcesNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), dataSourcesNotFound: dataSourcesNotFound{DataSourceRids: dataSourceRidsArg}}
}

// WrapWithDataSourcesNotFound returns new instance of DataSourcesNotFound error wrapping an existing error.
func WrapWithDataSourcesNotFound(err error, dataSourceRidsArg []rids.NominalDataSourceRid) *DataSourcesNotFound {
	return &DataSourcesNotFound{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, dataSourcesNotFound: dataSourcesNotFound{DataSourceRids: dataSourceRidsArg}}
}

// DataSourcesNotFound is an error type.
type DataSourcesNotFound struct {
	errorInstanceID uuid.UUID
	dataSourcesNotFound
	cause error
	stack werror.StackTrace
}

// IsDataSourcesNotFound returns true if err is an instance of DataSourcesNotFound.
func IsDataSourcesNotFound(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*DataSourcesNotFound)
	return ok
}

func (e *DataSourcesNotFound) Error() string {
	return fmt.Sprintf("NOT_FOUND NominalDataSource:DataSourcesNotFound (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *DataSourcesNotFound) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *DataSourcesNotFound) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *DataSourcesNotFound) Message() string {
	return "NOT_FOUND NominalDataSource:DataSourcesNotFound"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *DataSourcesNotFound) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *DataSourcesNotFound) Code() errors.ErrorCode {
	return errors.NotFound
}

// Name returns an error name identifying error type.
func (e *DataSourcesNotFound) Name() string {
	return "NominalDataSource:DataSourcesNotFound"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *DataSourcesNotFound) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *DataSourcesNotFound) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *DataSourcesNotFound) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRids": e.DataSourceRids, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *DataSourcesNotFound) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *DataSourcesNotFound) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *DataSourcesNotFound) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e DataSourcesNotFound) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.dataSourcesNotFound)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.NotFound, ErrorName: "NominalDataSource:DataSourcesNotFound", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *DataSourcesNotFound) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters dataSourcesNotFound
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.dataSourcesNotFound = parameters
	return nil
}

type invalidNominalDataSource struct {
	DataSourceRid rids.NominalDataSourceRid `json:"dataSourceRid"`
}

func (o invalidNominalDataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidNominalDataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidNominalDataSource returns new instance of InvalidNominalDataSource error.
func NewInvalidNominalDataSource(dataSourceRidArg rids.NominalDataSourceRid) *InvalidNominalDataSource {
	return &InvalidNominalDataSource{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidNominalDataSource: invalidNominalDataSource{DataSourceRid: dataSourceRidArg}}
}

// WrapWithInvalidNominalDataSource returns new instance of InvalidNominalDataSource error wrapping an existing error.
func WrapWithInvalidNominalDataSource(err error, dataSourceRidArg rids.NominalDataSourceRid) *InvalidNominalDataSource {
	return &InvalidNominalDataSource{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidNominalDataSource: invalidNominalDataSource{DataSourceRid: dataSourceRidArg}}
}

// InvalidNominalDataSource is an error type.
type InvalidNominalDataSource struct {
	errorInstanceID uuid.UUID
	invalidNominalDataSource
	cause error
	stack werror.StackTrace
}

// IsInvalidNominalDataSource returns true if err is an instance of InvalidNominalDataSource.
func IsInvalidNominalDataSource(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidNominalDataSource)
	return ok
}

func (e *InvalidNominalDataSource) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT NominalDataSource:InvalidNominalDataSource (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidNominalDataSource) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidNominalDataSource) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidNominalDataSource) Message() string {
	return "INVALID_ARGUMENT NominalDataSource:InvalidNominalDataSource"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidNominalDataSource) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidNominalDataSource) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidNominalDataSource) Name() string {
	return "NominalDataSource:InvalidNominalDataSource"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidNominalDataSource) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidNominalDataSource) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidNominalDataSource) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidNominalDataSource) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidNominalDataSource) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidNominalDataSource) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidNominalDataSource) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidNominalDataSource)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "NominalDataSource:InvalidNominalDataSource", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidNominalDataSource) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidNominalDataSource
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidNominalDataSource = parameters
	return nil
}

type nominalDataSourceConflict struct {
	Id NominalDataSourceId `json:"id"`
}

func (o nominalDataSourceConflict) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *nominalDataSourceConflict) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewNominalDataSourceConflict returns new instance of NominalDataSourceConflict error.
func NewNominalDataSourceConflict(idArg NominalDataSourceId) *NominalDataSourceConflict {
	return &NominalDataSourceConflict{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), nominalDataSourceConflict: nominalDataSourceConflict{Id: idArg}}
}

// WrapWithNominalDataSourceConflict returns new instance of NominalDataSourceConflict error wrapping an existing error.
func WrapWithNominalDataSourceConflict(err error, idArg NominalDataSourceId) *NominalDataSourceConflict {
	return &NominalDataSourceConflict{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, nominalDataSourceConflict: nominalDataSourceConflict{Id: idArg}}
}

// NominalDataSourceConflict is an error type.
// The requested data source already exists.
type NominalDataSourceConflict struct {
	errorInstanceID uuid.UUID
	nominalDataSourceConflict
	cause error
	stack werror.StackTrace
}

// IsNominalDataSourceConflict returns true if err is an instance of NominalDataSourceConflict.
func IsNominalDataSourceConflict(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*NominalDataSourceConflict)
	return ok
}

func (e *NominalDataSourceConflict) Error() string {
	return fmt.Sprintf("CONFLICT NominalDataSource:NominalDataSourceConflict (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *NominalDataSourceConflict) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *NominalDataSourceConflict) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *NominalDataSourceConflict) Message() string {
	return "CONFLICT NominalDataSource:NominalDataSourceConflict"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *NominalDataSourceConflict) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *NominalDataSourceConflict) Code() errors.ErrorCode {
	return errors.Conflict
}

// Name returns an error name identifying error type.
func (e *NominalDataSourceConflict) Name() string {
	return "NominalDataSource:NominalDataSourceConflict"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *NominalDataSourceConflict) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *NominalDataSourceConflict) Parameters() map[string]interface{} {
	return map[string]interface{}{"id": e.Id}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *NominalDataSourceConflict) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *NominalDataSourceConflict) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *NominalDataSourceConflict) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"id": e.Id}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *NominalDataSourceConflict) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e NominalDataSourceConflict) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.nominalDataSourceConflict)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.Conflict, ErrorName: "NominalDataSource:NominalDataSourceConflict", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *NominalDataSourceConflict) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters nominalDataSourceConflict
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.nominalDataSourceConflict = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("NominalDataSource:DataSourceNotFound", reflect.TypeOf(DataSourceNotFound{}))
	conjureerrors.RegisterErrorType("NominalDataSource:DataSourcesNotFound", reflect.TypeOf(DataSourcesNotFound{}))
	conjureerrors.RegisterErrorType("NominalDataSource:InvalidNominalDataSource", reflect.TypeOf(InvalidNominalDataSource{}))
	conjureerrors.RegisterErrorType("NominalDataSource:NominalDataSourceConflict", reflect.TypeOf(NominalDataSourceConflict{}))
}
