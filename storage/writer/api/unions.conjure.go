// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

// Array points for the internal API for directly writing points which supports all points types.
type ArrayPoints struct {
	typ    string
	double *[]DoubleArrayPoint
	string *[]StringArrayPoint
}

type arrayPointsDeserializer struct {
	Type   string              `json:"type"`
	Double *[]DoubleArrayPoint `json:"double"`
	String *[]StringArrayPoint `json:"string"`
}

func (u *arrayPointsDeserializer) toStruct() ArrayPoints {
	return ArrayPoints{typ: u.Type, double: u.Double, string: u.String}
}

func (u *ArrayPoints) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "double":
		if u.double == nil {
			return nil, fmt.Errorf("field \"double\" is required")
		}
		return struct {
			Type   string             `json:"type"`
			Double []DoubleArrayPoint `json:"double"`
		}{Type: "double", Double: *u.double}, nil
	case "string":
		if u.string == nil {
			return nil, fmt.Errorf("field \"string\" is required")
		}
		return struct {
			Type   string             `json:"type"`
			String []StringArrayPoint `json:"string"`
		}{Type: "string", String: *u.string}, nil
	}
}

func (u ArrayPoints) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ArrayPoints) UnmarshalJSON(data []byte) error {
	var deser arrayPointsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
	}
	return nil
}

func (u ArrayPoints) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ArrayPoints) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ArrayPoints) AcceptFuncs(doubleFunc func([]DoubleArrayPoint) error, stringFunc func([]StringArrayPoint) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return stringFunc(*u.string)
	}
}

func (u *ArrayPoints) DoubleNoopSuccess([]DoubleArrayPoint) error {
	return nil
}

func (u *ArrayPoints) StringNoopSuccess([]StringArrayPoint) error {
	return nil
}

func (u *ArrayPoints) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ArrayPoints) Accept(v ArrayPointsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(*u.double)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitString(*u.string)
	}
}

type ArrayPointsVisitor interface {
	VisitDouble(v []DoubleArrayPoint) error
	VisitString(v []StringArrayPoint) error
	VisitUnknown(typeName string) error
}

func (u *ArrayPoints) AcceptWithContext(ctx context.Context, v ArrayPointsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDoubleWithContext(ctx, *u.double)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitStringWithContext(ctx, *u.string)
	}
}

type ArrayPointsVisitorWithContext interface {
	VisitDoubleWithContext(ctx context.Context, v []DoubleArrayPoint) error
	VisitStringWithContext(ctx context.Context, v []StringArrayPoint) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewArrayPointsFromDouble(v []DoubleArrayPoint) ArrayPoints {
	return ArrayPoints{typ: "double", double: &v}
}

func NewArrayPointsFromString(v []StringArrayPoint) ArrayPoints {
	return ArrayPoints{typ: "string", string: &v}
}

/*
Each element within the outer list corresponds to an Array point. Subsequent inner lists contain the array
values recorded for that point.
*/
type ArraysValues struct {
	typ       string
	strings1d *[][]string
	doubles1d *[][]float64
}

type arraysValuesDeserializer struct {
	Type      string       `json:"type"`
	Strings1d *[][]string  `json:"strings1d"`
	Doubles1d *[][]float64 `json:"doubles1d"`
}

func (u *arraysValuesDeserializer) toStruct() ArraysValues {
	return ArraysValues{typ: u.Type, strings1d: u.Strings1d, doubles1d: u.Doubles1d}
}

func (u *ArraysValues) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "strings1d":
		if u.strings1d == nil {
			return nil, fmt.Errorf("field \"strings1d\" is required")
		}
		return struct {
			Type      string     `json:"type"`
			Strings1d [][]string `json:"strings1d"`
		}{Type: "strings1d", Strings1d: *u.strings1d}, nil
	case "doubles1d":
		if u.doubles1d == nil {
			return nil, fmt.Errorf("field \"doubles1d\" is required")
		}
		return struct {
			Type      string      `json:"type"`
			Doubles1d [][]float64 `json:"doubles1d"`
		}{Type: "doubles1d", Doubles1d: *u.doubles1d}, nil
	}
}

func (u ArraysValues) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ArraysValues) UnmarshalJSON(data []byte) error {
	var deser arraysValuesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "strings1d":
		if u.strings1d == nil {
			return fmt.Errorf("field \"strings1d\" is required")
		}
	case "doubles1d":
		if u.doubles1d == nil {
			return fmt.Errorf("field \"doubles1d\" is required")
		}
	}
	return nil
}

func (u ArraysValues) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ArraysValues) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ArraysValues) AcceptFuncs(strings1dFunc func([][]string) error, doubles1dFunc func([][]float64) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "strings1d":
		if u.strings1d == nil {
			return fmt.Errorf("field \"strings1d\" is required")
		}
		return strings1dFunc(*u.strings1d)
	case "doubles1d":
		if u.doubles1d == nil {
			return fmt.Errorf("field \"doubles1d\" is required")
		}
		return doubles1dFunc(*u.doubles1d)
	}
}

func (u *ArraysValues) Strings1dNoopSuccess([][]string) error {
	return nil
}

func (u *ArraysValues) Doubles1dNoopSuccess([][]float64) error {
	return nil
}

func (u *ArraysValues) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ArraysValues) Accept(v ArraysValuesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "strings1d":
		if u.strings1d == nil {
			return fmt.Errorf("field \"strings1d\" is required")
		}
		return v.VisitStrings1d(*u.strings1d)
	case "doubles1d":
		if u.doubles1d == nil {
			return fmt.Errorf("field \"doubles1d\" is required")
		}
		return v.VisitDoubles1d(*u.doubles1d)
	}
}

type ArraysValuesVisitor interface {
	VisitStrings1d(v [][]string) error
	VisitDoubles1d(v [][]float64) error
	VisitUnknown(typeName string) error
}

func (u *ArraysValues) AcceptWithContext(ctx context.Context, v ArraysValuesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "strings1d":
		if u.strings1d == nil {
			return fmt.Errorf("field \"strings1d\" is required")
		}
		return v.VisitStrings1dWithContext(ctx, *u.strings1d)
	case "doubles1d":
		if u.doubles1d == nil {
			return fmt.Errorf("field \"doubles1d\" is required")
		}
		return v.VisitDoubles1dWithContext(ctx, *u.doubles1d)
	}
}

type ArraysValuesVisitorWithContext interface {
	VisitStrings1dWithContext(ctx context.Context, v [][]string) error
	VisitDoubles1dWithContext(ctx context.Context, v [][]float64) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewArraysValuesFromStrings1d(v [][]string) ArraysValues {
	return ArraysValues{typ: "strings1d", strings1d: &v}
}

func NewArraysValuesFromDoubles1d(v [][]float64) ArraysValues {
	return ArraysValues{typ: "doubles1d", doubles1d: &v}
}

// List of values for a set of points to ingest from a single channel.
type ColumnValues struct {
	typ     string
	strings *[]string
	doubles *[]float64
	ints    *[]int
	arrays  *ArraysValues
	structs *[]string
}

type columnValuesDeserializer struct {
	Type    string        `json:"type"`
	Strings *[]string     `json:"strings"`
	Doubles *[]float64    `json:"doubles"`
	Ints    *[]int        `json:"ints"`
	Arrays  *ArraysValues `json:"arrays"`
	Structs *[]string     `json:"structs"`
}

func (u *columnValuesDeserializer) toStruct() ColumnValues {
	return ColumnValues{typ: u.Type, strings: u.Strings, doubles: u.Doubles, ints: u.Ints, arrays: u.Arrays, structs: u.Structs}
}

func (u *ColumnValues) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "strings":
		if u.strings == nil {
			return nil, fmt.Errorf("field \"strings\" is required")
		}
		return struct {
			Type    string   `json:"type"`
			Strings []string `json:"strings"`
		}{Type: "strings", Strings: *u.strings}, nil
	case "doubles":
		if u.doubles == nil {
			return nil, fmt.Errorf("field \"doubles\" is required")
		}
		return struct {
			Type    string    `json:"type"`
			Doubles []float64 `json:"doubles"`
		}{Type: "doubles", Doubles: *u.doubles}, nil
	case "ints":
		if u.ints == nil {
			return nil, fmt.Errorf("field \"ints\" is required")
		}
		return struct {
			Type string `json:"type"`
			Ints []int  `json:"ints"`
		}{Type: "ints", Ints: *u.ints}, nil
	case "arrays":
		if u.arrays == nil {
			return nil, fmt.Errorf("field \"arrays\" is required")
		}
		return struct {
			Type   string       `json:"type"`
			Arrays ArraysValues `json:"arrays"`
		}{Type: "arrays", Arrays: *u.arrays}, nil
	case "structs":
		if u.structs == nil {
			return nil, fmt.Errorf("field \"structs\" is required")
		}
		return struct {
			Type    string   `json:"type"`
			Structs []string `json:"structs"`
		}{Type: "structs", Structs: *u.structs}, nil
	}
}

func (u ColumnValues) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *ColumnValues) UnmarshalJSON(data []byte) error {
	var deser columnValuesDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "strings":
		if u.strings == nil {
			return fmt.Errorf("field \"strings\" is required")
		}
	case "doubles":
		if u.doubles == nil {
			return fmt.Errorf("field \"doubles\" is required")
		}
	case "ints":
		if u.ints == nil {
			return fmt.Errorf("field \"ints\" is required")
		}
	case "arrays":
		if u.arrays == nil {
			return fmt.Errorf("field \"arrays\" is required")
		}
	case "structs":
		if u.structs == nil {
			return fmt.Errorf("field \"structs\" is required")
		}
	}
	return nil
}

func (u ColumnValues) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *ColumnValues) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *ColumnValues) AcceptFuncs(stringsFunc func([]string) error, doublesFunc func([]float64) error, intsFunc func([]int) error, arraysFunc func(ArraysValues) error, structsFunc func([]string) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "strings":
		if u.strings == nil {
			return fmt.Errorf("field \"strings\" is required")
		}
		return stringsFunc(*u.strings)
	case "doubles":
		if u.doubles == nil {
			return fmt.Errorf("field \"doubles\" is required")
		}
		return doublesFunc(*u.doubles)
	case "ints":
		if u.ints == nil {
			return fmt.Errorf("field \"ints\" is required")
		}
		return intsFunc(*u.ints)
	case "arrays":
		if u.arrays == nil {
			return fmt.Errorf("field \"arrays\" is required")
		}
		return arraysFunc(*u.arrays)
	case "structs":
		if u.structs == nil {
			return fmt.Errorf("field \"structs\" is required")
		}
		return structsFunc(*u.structs)
	}
}

func (u *ColumnValues) StringsNoopSuccess([]string) error {
	return nil
}

func (u *ColumnValues) DoublesNoopSuccess([]float64) error {
	return nil
}

func (u *ColumnValues) IntsNoopSuccess([]int) error {
	return nil
}

func (u *ColumnValues) ArraysNoopSuccess(ArraysValues) error {
	return nil
}

func (u *ColumnValues) StructsNoopSuccess([]string) error {
	return nil
}

func (u *ColumnValues) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *ColumnValues) Accept(v ColumnValuesVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "strings":
		if u.strings == nil {
			return fmt.Errorf("field \"strings\" is required")
		}
		return v.VisitStrings(*u.strings)
	case "doubles":
		if u.doubles == nil {
			return fmt.Errorf("field \"doubles\" is required")
		}
		return v.VisitDoubles(*u.doubles)
	case "ints":
		if u.ints == nil {
			return fmt.Errorf("field \"ints\" is required")
		}
		return v.VisitInts(*u.ints)
	case "arrays":
		if u.arrays == nil {
			return fmt.Errorf("field \"arrays\" is required")
		}
		return v.VisitArrays(*u.arrays)
	case "structs":
		if u.structs == nil {
			return fmt.Errorf("field \"structs\" is required")
		}
		return v.VisitStructs(*u.structs)
	}
}

type ColumnValuesVisitor interface {
	VisitStrings(v []string) error
	VisitDoubles(v []float64) error
	VisitInts(v []int) error
	VisitArrays(v ArraysValues) error
	VisitStructs(v []string) error
	VisitUnknown(typeName string) error
}

func (u *ColumnValues) AcceptWithContext(ctx context.Context, v ColumnValuesVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "strings":
		if u.strings == nil {
			return fmt.Errorf("field \"strings\" is required")
		}
		return v.VisitStringsWithContext(ctx, *u.strings)
	case "doubles":
		if u.doubles == nil {
			return fmt.Errorf("field \"doubles\" is required")
		}
		return v.VisitDoublesWithContext(ctx, *u.doubles)
	case "ints":
		if u.ints == nil {
			return fmt.Errorf("field \"ints\" is required")
		}
		return v.VisitIntsWithContext(ctx, *u.ints)
	case "arrays":
		if u.arrays == nil {
			return fmt.Errorf("field \"arrays\" is required")
		}
		return v.VisitArraysWithContext(ctx, *u.arrays)
	case "structs":
		if u.structs == nil {
			return fmt.Errorf("field \"structs\" is required")
		}
		return v.VisitStructsWithContext(ctx, *u.structs)
	}
}

type ColumnValuesVisitorWithContext interface {
	VisitStringsWithContext(ctx context.Context, v []string) error
	VisitDoublesWithContext(ctx context.Context, v []float64) error
	VisitIntsWithContext(ctx context.Context, v []int) error
	VisitArraysWithContext(ctx context.Context, v ArraysValues) error
	VisitStructsWithContext(ctx context.Context, v []string) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewColumnValuesFromStrings(v []string) ColumnValues {
	return ColumnValues{typ: "strings", strings: &v}
}

func NewColumnValuesFromDoubles(v []float64) ColumnValues {
	return ColumnValues{typ: "doubles", doubles: &v}
}

func NewColumnValuesFromInts(v []int) ColumnValues {
	return ColumnValues{typ: "ints", ints: &v}
}

func NewColumnValuesFromArrays(v ArraysValues) ColumnValues {
	return ColumnValues{typ: "arrays", arrays: &v}
}

func NewColumnValuesFromStructs(v []string) ColumnValues {
	return ColumnValues{typ: "structs", structs: &v}
}

/*
Points for internal API for directly writing points which supports all points types.
Logs specifically are supported externally via a separate endpoint.
*/
type Points struct {
	typ     string
	string  *[]StringPoint
	double  *[]DoublePoint
	log     *[]LogPoint
	int     *[]IntPoint
	uint64  *[]Uint64Point
	array   *ArrayPoints
	struct_ *[]StructPoint
}

type pointsDeserializer struct {
	Type   string         `json:"type"`
	String *[]StringPoint `json:"string"`
	Double *[]DoublePoint `json:"double"`
	Log    *[]LogPoint    `json:"log"`
	Int    *[]IntPoint    `json:"int"`
	Uint64 *[]Uint64Point `json:"uint64"`
	Array  *ArrayPoints   `json:"array"`
	Struct *[]StructPoint `json:"struct"`
}

func (u *pointsDeserializer) toStruct() Points {
	return Points{typ: u.Type, string: u.String, double: u.Double, log: u.Log, int: u.Int, uint64: u.Uint64, array: u.Array, struct_: u.Struct}
}

func (u *Points) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "string":
		if u.string == nil {
			return nil, fmt.Errorf("field \"string\" is required")
		}
		return struct {
			Type   string        `json:"type"`
			String []StringPoint `json:"string"`
		}{Type: "string", String: *u.string}, nil
	case "double":
		if u.double == nil {
			return nil, fmt.Errorf("field \"double\" is required")
		}
		return struct {
			Type   string        `json:"type"`
			Double []DoublePoint `json:"double"`
		}{Type: "double", Double: *u.double}, nil
	case "log":
		if u.log == nil {
			return nil, fmt.Errorf("field \"log\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Log  []LogPoint `json:"log"`
		}{Type: "log", Log: *u.log}, nil
	case "int":
		if u.int == nil {
			return nil, fmt.Errorf("field \"int\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Int  []IntPoint `json:"int"`
		}{Type: "int", Int: *u.int}, nil
	case "uint64":
		if u.uint64 == nil {
			return nil, fmt.Errorf("field \"uint64\" is required")
		}
		return struct {
			Type   string        `json:"type"`
			Uint64 []Uint64Point `json:"uint64"`
		}{Type: "uint64", Uint64: *u.uint64}, nil
	case "array":
		if u.array == nil {
			return nil, fmt.Errorf("field \"array\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Array ArrayPoints `json:"array"`
		}{Type: "array", Array: *u.array}, nil
	case "struct":
		if u.struct_ == nil {
			return nil, fmt.Errorf("field \"struct\" is required")
		}
		return struct {
			Type   string        `json:"type"`
			Struct []StructPoint `json:"struct"`
		}{Type: "struct", Struct: *u.struct_}, nil
	}
}

func (u Points) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *Points) UnmarshalJSON(data []byte) error {
	var deser pointsDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
	case "int":
		if u.int == nil {
			return fmt.Errorf("field \"int\" is required")
		}
	case "uint64":
		if u.uint64 == nil {
			return fmt.Errorf("field \"uint64\" is required")
		}
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
	}
	return nil
}

func (u Points) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *Points) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *Points) AcceptFuncs(stringFunc func([]StringPoint) error, doubleFunc func([]DoublePoint) error, logFunc func([]LogPoint) error, intFunc func([]IntPoint) error, uint64Func func([]Uint64Point) error, arrayFunc func(ArrayPoints) error, struct_Func func([]StructPoint) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return stringFunc(*u.string)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "int":
		if u.int == nil {
			return fmt.Errorf("field \"int\" is required")
		}
		return intFunc(*u.int)
	case "uint64":
		if u.uint64 == nil {
			return fmt.Errorf("field \"uint64\" is required")
		}
		return uint64Func(*u.uint64)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return struct_Func(*u.struct_)
	}
}

func (u *Points) StringNoopSuccess([]StringPoint) error {
	return nil
}

func (u *Points) DoubleNoopSuccess([]DoublePoint) error {
	return nil
}

func (u *Points) LogNoopSuccess([]LogPoint) error {
	return nil
}

func (u *Points) IntNoopSuccess([]IntPoint) error {
	return nil
}

func (u *Points) Uint64NoopSuccess([]Uint64Point) error {
	return nil
}

func (u *Points) ArrayNoopSuccess(ArrayPoints) error {
	return nil
}

func (u *Points) StructNoopSuccess([]StructPoint) error {
	return nil
}

func (u *Points) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *Points) Accept(v PointsVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitString(*u.string)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(*u.double)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(*u.log)
	case "int":
		if u.int == nil {
			return fmt.Errorf("field \"int\" is required")
		}
		return v.VisitInt(*u.int)
	case "uint64":
		if u.uint64 == nil {
			return fmt.Errorf("field \"uint64\" is required")
		}
		return v.VisitUint64(*u.uint64)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(*u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStruct(*u.struct_)
	}
}

type PointsVisitor interface {
	VisitString(v []StringPoint) error
	VisitDouble(v []DoublePoint) error
	VisitLog(v []LogPoint) error
	VisitInt(v []IntPoint) error
	VisitUint64(v []Uint64Point) error
	VisitArray(v ArrayPoints) error
	VisitStruct(v []StructPoint) error
	VisitUnknown(typeName string) error
}

func (u *Points) AcceptWithContext(ctx context.Context, v PointsVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitStringWithContext(ctx, *u.string)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDoubleWithContext(ctx, *u.double)
	case "log":
		if u.log == nil {
			return fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLogWithContext(ctx, *u.log)
	case "int":
		if u.int == nil {
			return fmt.Errorf("field \"int\" is required")
		}
		return v.VisitIntWithContext(ctx, *u.int)
	case "uint64":
		if u.uint64 == nil {
			return fmt.Errorf("field \"uint64\" is required")
		}
		return v.VisitUint64WithContext(ctx, *u.uint64)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArrayWithContext(ctx, *u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStructWithContext(ctx, *u.struct_)
	}
}

type PointsVisitorWithContext interface {
	VisitStringWithContext(ctx context.Context, v []StringPoint) error
	VisitDoubleWithContext(ctx context.Context, v []DoublePoint) error
	VisitLogWithContext(ctx context.Context, v []LogPoint) error
	VisitIntWithContext(ctx context.Context, v []IntPoint) error
	VisitUint64WithContext(ctx context.Context, v []Uint64Point) error
	VisitArrayWithContext(ctx context.Context, v ArrayPoints) error
	VisitStructWithContext(ctx context.Context, v []StructPoint) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPointsFromString(v []StringPoint) Points {
	return Points{typ: "string", string: &v}
}

func NewPointsFromDouble(v []DoublePoint) Points {
	return Points{typ: "double", double: &v}
}

func NewPointsFromLog(v []LogPoint) Points {
	return Points{typ: "log", log: &v}
}

func NewPointsFromInt(v []IntPoint) Points {
	return Points{typ: "int", int: &v}
}

func NewPointsFromUint64(v []Uint64Point) Points {
	return Points{typ: "uint64", uint64: &v}
}

func NewPointsFromArray(v ArrayPoints) Points {
	return Points{typ: "array", array: &v}
}

func NewPointsFromStruct(v []StructPoint) Points {
	return Points{typ: "struct", struct_: &v}
}

type PointsExternal struct {
	typ     string
	string  *[]StringPoint
	double  *[]DoublePoint
	int     *[]IntPoint
	array   *ArrayPoints
	struct_ *[]StructPoint
}

type pointsExternalDeserializer struct {
	Type   string         `json:"type"`
	String *[]StringPoint `json:"string"`
	Double *[]DoublePoint `json:"double"`
	Int    *[]IntPoint    `json:"int"`
	Array  *ArrayPoints   `json:"array"`
	Struct *[]StructPoint `json:"struct"`
}

func (u *pointsExternalDeserializer) toStruct() PointsExternal {
	return PointsExternal{typ: u.Type, string: u.String, double: u.Double, int: u.Int, array: u.Array, struct_: u.Struct}
}

func (u *PointsExternal) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "string":
		if u.string == nil {
			return nil, fmt.Errorf("field \"string\" is required")
		}
		return struct {
			Type   string        `json:"type"`
			String []StringPoint `json:"string"`
		}{Type: "string", String: *u.string}, nil
	case "double":
		if u.double == nil {
			return nil, fmt.Errorf("field \"double\" is required")
		}
		return struct {
			Type   string        `json:"type"`
			Double []DoublePoint `json:"double"`
		}{Type: "double", Double: *u.double}, nil
	case "int":
		if u.int == nil {
			return nil, fmt.Errorf("field \"int\" is required")
		}
		return struct {
			Type string     `json:"type"`
			Int  []IntPoint `json:"int"`
		}{Type: "int", Int: *u.int}, nil
	case "array":
		if u.array == nil {
			return nil, fmt.Errorf("field \"array\" is required")
		}
		return struct {
			Type  string      `json:"type"`
			Array ArrayPoints `json:"array"`
		}{Type: "array", Array: *u.array}, nil
	case "struct":
		if u.struct_ == nil {
			return nil, fmt.Errorf("field \"struct\" is required")
		}
		return struct {
			Type   string        `json:"type"`
			Struct []StructPoint `json:"struct"`
		}{Type: "struct", Struct: *u.struct_}, nil
	}
}

func (u PointsExternal) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *PointsExternal) UnmarshalJSON(data []byte) error {
	var deser pointsExternalDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
	case "int":
		if u.int == nil {
			return fmt.Errorf("field \"int\" is required")
		}
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
	}
	return nil
}

func (u PointsExternal) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *PointsExternal) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *PointsExternal) AcceptFuncs(stringFunc func([]StringPoint) error, doubleFunc func([]DoublePoint) error, intFunc func([]IntPoint) error, arrayFunc func(ArrayPoints) error, struct_Func func([]StructPoint) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return stringFunc(*u.string)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "int":
		if u.int == nil {
			return fmt.Errorf("field \"int\" is required")
		}
		return intFunc(*u.int)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return struct_Func(*u.struct_)
	}
}

func (u *PointsExternal) StringNoopSuccess([]StringPoint) error {
	return nil
}

func (u *PointsExternal) DoubleNoopSuccess([]DoublePoint) error {
	return nil
}

func (u *PointsExternal) IntNoopSuccess([]IntPoint) error {
	return nil
}

func (u *PointsExternal) ArrayNoopSuccess(ArrayPoints) error {
	return nil
}

func (u *PointsExternal) StructNoopSuccess([]StructPoint) error {
	return nil
}

func (u *PointsExternal) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *PointsExternal) Accept(v PointsExternalVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitString(*u.string)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(*u.double)
	case "int":
		if u.int == nil {
			return fmt.Errorf("field \"int\" is required")
		}
		return v.VisitInt(*u.int)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(*u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStruct(*u.struct_)
	}
}

type PointsExternalVisitor interface {
	VisitString(v []StringPoint) error
	VisitDouble(v []DoublePoint) error
	VisitInt(v []IntPoint) error
	VisitArray(v ArrayPoints) error
	VisitStruct(v []StructPoint) error
	VisitUnknown(typeName string) error
}

func (u *PointsExternal) AcceptWithContext(ctx context.Context, v PointsExternalVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "string":
		if u.string == nil {
			return fmt.Errorf("field \"string\" is required")
		}
		return v.VisitStringWithContext(ctx, *u.string)
	case "double":
		if u.double == nil {
			return fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDoubleWithContext(ctx, *u.double)
	case "int":
		if u.int == nil {
			return fmt.Errorf("field \"int\" is required")
		}
		return v.VisitIntWithContext(ctx, *u.int)
	case "array":
		if u.array == nil {
			return fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArrayWithContext(ctx, *u.array)
	case "struct":
		if u.struct_ == nil {
			return fmt.Errorf("field \"struct\" is required")
		}
		return v.VisitStructWithContext(ctx, *u.struct_)
	}
}

type PointsExternalVisitorWithContext interface {
	VisitStringWithContext(ctx context.Context, v []StringPoint) error
	VisitDoubleWithContext(ctx context.Context, v []DoublePoint) error
	VisitIntWithContext(ctx context.Context, v []IntPoint) error
	VisitArrayWithContext(ctx context.Context, v ArrayPoints) error
	VisitStructWithContext(ctx context.Context, v []StructPoint) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewPointsExternalFromString(v []StringPoint) PointsExternal {
	return PointsExternal{typ: "string", string: &v}
}

func NewPointsExternalFromDouble(v []DoublePoint) PointsExternal {
	return PointsExternal{typ: "double", double: &v}
}

func NewPointsExternalFromInt(v []IntPoint) PointsExternal {
	return PointsExternal{typ: "int", int: &v}
}

func NewPointsExternalFromArray(v ArrayPoints) PointsExternal {
	return PointsExternal{typ: "array", array: &v}
}

func NewPointsExternalFromStruct(v []StructPoint) PointsExternal {
	return PointsExternal{typ: "struct", struct_: &v}
}
