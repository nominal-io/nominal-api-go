// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package api

import (
	"context"
	"fmt"
)

type ArrayPointsWithT[T any] ArrayPoints

func (u *ArrayPointsWithT[T]) Accept(ctx context.Context, v ArrayPointsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "double":
		if u.double == nil {
			return result, fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(ctx, *u.double)
	case "string":
		if u.string == nil {
			return result, fmt.Errorf("field \"string\" is required")
		}
		return v.VisitString(ctx, *u.string)
	}
}

func (u *ArrayPointsWithT[T]) AcceptFuncs(doubleFunc func([]DoubleArrayPoint) (T, error), stringFunc func([]StringArrayPoint) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "double":
		if u.double == nil {
			return result, fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "string":
		if u.string == nil {
			return result, fmt.Errorf("field \"string\" is required")
		}
		return stringFunc(*u.string)
	}
}

func (u *ArrayPointsWithT[T]) DoubleNoopSuccess([]DoubleArrayPoint) (T, error) {
	var result T
	return result, nil
}

func (u *ArrayPointsWithT[T]) StringNoopSuccess([]StringArrayPoint) (T, error) {
	var result T
	return result, nil
}

func (u *ArrayPointsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ArrayPointsVisitorWithT[T any] interface {
	VisitDouble(ctx context.Context, v []DoubleArrayPoint) (T, error)
	VisitString(ctx context.Context, v []StringArrayPoint) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ArraysValuesWithT[T any] ArraysValues

func (u *ArraysValuesWithT[T]) Accept(ctx context.Context, v ArraysValuesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "strings1d":
		if u.strings1d == nil {
			return result, fmt.Errorf("field \"strings1d\" is required")
		}
		return v.VisitStrings1d(ctx, *u.strings1d)
	case "doubles1d":
		if u.doubles1d == nil {
			return result, fmt.Errorf("field \"doubles1d\" is required")
		}
		return v.VisitDoubles1d(ctx, *u.doubles1d)
	}
}

func (u *ArraysValuesWithT[T]) AcceptFuncs(strings1dFunc func([][]string) (T, error), doubles1dFunc func([][]float64) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "strings1d":
		if u.strings1d == nil {
			return result, fmt.Errorf("field \"strings1d\" is required")
		}
		return strings1dFunc(*u.strings1d)
	case "doubles1d":
		if u.doubles1d == nil {
			return result, fmt.Errorf("field \"doubles1d\" is required")
		}
		return doubles1dFunc(*u.doubles1d)
	}
}

func (u *ArraysValuesWithT[T]) Strings1dNoopSuccess([][]string) (T, error) {
	var result T
	return result, nil
}

func (u *ArraysValuesWithT[T]) Doubles1dNoopSuccess([][]float64) (T, error) {
	var result T
	return result, nil
}

func (u *ArraysValuesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ArraysValuesVisitorWithT[T any] interface {
	VisitStrings1d(ctx context.Context, v [][]string) (T, error)
	VisitDoubles1d(ctx context.Context, v [][]float64) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ColumnValuesWithT[T any] ColumnValues

func (u *ColumnValuesWithT[T]) Accept(ctx context.Context, v ColumnValuesVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "strings":
		if u.strings == nil {
			return result, fmt.Errorf("field \"strings\" is required")
		}
		return v.VisitStrings(ctx, *u.strings)
	case "doubles":
		if u.doubles == nil {
			return result, fmt.Errorf("field \"doubles\" is required")
		}
		return v.VisitDoubles(ctx, *u.doubles)
	case "ints":
		if u.ints == nil {
			return result, fmt.Errorf("field \"ints\" is required")
		}
		return v.VisitInts(ctx, *u.ints)
	case "arrays":
		if u.arrays == nil {
			return result, fmt.Errorf("field \"arrays\" is required")
		}
		return v.VisitArrays(ctx, *u.arrays)
	}
}

func (u *ColumnValuesWithT[T]) AcceptFuncs(stringsFunc func([]string) (T, error), doublesFunc func([]float64) (T, error), intsFunc func([]int) (T, error), arraysFunc func(ArraysValues) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "strings":
		if u.strings == nil {
			return result, fmt.Errorf("field \"strings\" is required")
		}
		return stringsFunc(*u.strings)
	case "doubles":
		if u.doubles == nil {
			return result, fmt.Errorf("field \"doubles\" is required")
		}
		return doublesFunc(*u.doubles)
	case "ints":
		if u.ints == nil {
			return result, fmt.Errorf("field \"ints\" is required")
		}
		return intsFunc(*u.ints)
	case "arrays":
		if u.arrays == nil {
			return result, fmt.Errorf("field \"arrays\" is required")
		}
		return arraysFunc(*u.arrays)
	}
}

func (u *ColumnValuesWithT[T]) StringsNoopSuccess([]string) (T, error) {
	var result T
	return result, nil
}

func (u *ColumnValuesWithT[T]) DoublesNoopSuccess([]float64) (T, error) {
	var result T
	return result, nil
}

func (u *ColumnValuesWithT[T]) IntsNoopSuccess([]int) (T, error) {
	var result T
	return result, nil
}

func (u *ColumnValuesWithT[T]) ArraysNoopSuccess(ArraysValues) (T, error) {
	var result T
	return result, nil
}

func (u *ColumnValuesWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ColumnValuesVisitorWithT[T any] interface {
	VisitStrings(ctx context.Context, v []string) (T, error)
	VisitDoubles(ctx context.Context, v []float64) (T, error)
	VisitInts(ctx context.Context, v []int) (T, error)
	VisitArrays(ctx context.Context, v ArraysValues) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PointsWithT[T any] Points

func (u *PointsWithT[T]) Accept(ctx context.Context, v PointsVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "string":
		if u.string == nil {
			return result, fmt.Errorf("field \"string\" is required")
		}
		return v.VisitString(ctx, *u.string)
	case "double":
		if u.double == nil {
			return result, fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(ctx, *u.double)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return v.VisitLog(ctx, *u.log)
	case "int":
		if u.int == nil {
			return result, fmt.Errorf("field \"int\" is required")
		}
		return v.VisitInt(ctx, *u.int)
	case "array":
		if u.array == nil {
			return result, fmt.Errorf("field \"array\" is required")
		}
		return v.VisitArray(ctx, *u.array)
	}
}

func (u *PointsWithT[T]) AcceptFuncs(stringFunc func([]StringPoint) (T, error), doubleFunc func([]DoublePoint) (T, error), logFunc func([]LogPoint) (T, error), intFunc func([]IntPoint) (T, error), arrayFunc func(ArrayPoints) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "string":
		if u.string == nil {
			return result, fmt.Errorf("field \"string\" is required")
		}
		return stringFunc(*u.string)
	case "double":
		if u.double == nil {
			return result, fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "log":
		if u.log == nil {
			return result, fmt.Errorf("field \"log\" is required")
		}
		return logFunc(*u.log)
	case "int":
		if u.int == nil {
			return result, fmt.Errorf("field \"int\" is required")
		}
		return intFunc(*u.int)
	case "array":
		if u.array == nil {
			return result, fmt.Errorf("field \"array\" is required")
		}
		return arrayFunc(*u.array)
	}
}

func (u *PointsWithT[T]) StringNoopSuccess([]StringPoint) (T, error) {
	var result T
	return result, nil
}

func (u *PointsWithT[T]) DoubleNoopSuccess([]DoublePoint) (T, error) {
	var result T
	return result, nil
}

func (u *PointsWithT[T]) LogNoopSuccess([]LogPoint) (T, error) {
	var result T
	return result, nil
}

func (u *PointsWithT[T]) IntNoopSuccess([]IntPoint) (T, error) {
	var result T
	return result, nil
}

func (u *PointsWithT[T]) ArrayNoopSuccess(ArrayPoints) (T, error) {
	var result T
	return result, nil
}

func (u *PointsWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PointsVisitorWithT[T any] interface {
	VisitString(ctx context.Context, v []StringPoint) (T, error)
	VisitDouble(ctx context.Context, v []DoublePoint) (T, error)
	VisitLog(ctx context.Context, v []LogPoint) (T, error)
	VisitInt(ctx context.Context, v []IntPoint) (T, error)
	VisitArray(ctx context.Context, v ArrayPoints) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type PointsExternalWithT[T any] PointsExternal

func (u *PointsExternalWithT[T]) Accept(ctx context.Context, v PointsExternalVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "string":
		if u.string == nil {
			return result, fmt.Errorf("field \"string\" is required")
		}
		return v.VisitString(ctx, *u.string)
	case "double":
		if u.double == nil {
			return result, fmt.Errorf("field \"double\" is required")
		}
		return v.VisitDouble(ctx, *u.double)
	case "int":
		if u.int == nil {
			return result, fmt.Errorf("field \"int\" is required")
		}
		return v.VisitInt(ctx, *u.int)
	}
}

func (u *PointsExternalWithT[T]) AcceptFuncs(stringFunc func([]StringPoint) (T, error), doubleFunc func([]DoublePoint) (T, error), intFunc func([]IntPoint) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "string":
		if u.string == nil {
			return result, fmt.Errorf("field \"string\" is required")
		}
		return stringFunc(*u.string)
	case "double":
		if u.double == nil {
			return result, fmt.Errorf("field \"double\" is required")
		}
		return doubleFunc(*u.double)
	case "int":
		if u.int == nil {
			return result, fmt.Errorf("field \"int\" is required")
		}
		return intFunc(*u.int)
	}
}

func (u *PointsExternalWithT[T]) StringNoopSuccess([]StringPoint) (T, error) {
	var result T
	return result, nil
}

func (u *PointsExternalWithT[T]) DoubleNoopSuccess([]DoublePoint) (T, error) {
	var result T
	return result, nil
}

func (u *PointsExternalWithT[T]) IntNoopSuccess([]IntPoint) (T, error) {
	var result T
	return result, nil
}

func (u *PointsExternalWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type PointsExternalVisitorWithT[T any] interface {
	VisitString(ctx context.Context, v []StringPoint) (T, error)
	VisitDouble(ctx context.Context, v []DoublePoint) (T, error)
	VisitInt(ctx context.Context, v []IntPoint) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
