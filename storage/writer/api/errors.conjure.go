// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/nominal-io/nominal-api-go/io/nominal/api"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
	"github.com/palantir/pkg/uuid"
	werror "github.com/palantir/witchcraft-go-error"
)

type arrayTooLarge struct {
	MaxLength    int `json:"maxLength"`
	ActualLength int `json:"actualLength"`
}

func (o arrayTooLarge) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *arrayTooLarge) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewArrayTooLarge returns new instance of ArrayTooLarge error.
func NewArrayTooLarge(maxLengthArg int, actualLengthArg int) *ArrayTooLarge {
	return &ArrayTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), arrayTooLarge: arrayTooLarge{MaxLength: maxLengthArg, ActualLength: actualLengthArg}}
}

// WrapWithArrayTooLarge returns new instance of ArrayTooLarge error wrapping an existing error.
func WrapWithArrayTooLarge(err error, maxLengthArg int, actualLengthArg int) *ArrayTooLarge {
	return &ArrayTooLarge{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, arrayTooLarge: arrayTooLarge{MaxLength: maxLengthArg, ActualLength: actualLengthArg}}
}

// ArrayTooLarge is an error type.
// Array size exceeds maximum allowed length.
type ArrayTooLarge struct {
	errorInstanceID uuid.UUID
	arrayTooLarge
	cause error
	stack werror.StackTrace
}

// IsArrayTooLarge returns true if err is an instance of ArrayTooLarge.
func IsArrayTooLarge(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ArrayTooLarge)
	return ok
}

func (e *ArrayTooLarge) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT NominalChannelWriter:ArrayTooLarge (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ArrayTooLarge) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ArrayTooLarge) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ArrayTooLarge) Message() string {
	return "INVALID_ARGUMENT NominalChannelWriter:ArrayTooLarge"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ArrayTooLarge) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ArrayTooLarge) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ArrayTooLarge) Name() string {
	return "NominalChannelWriter:ArrayTooLarge"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ArrayTooLarge) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ArrayTooLarge) Parameters() map[string]interface{} {
	return map[string]interface{}{"maxLength": e.MaxLength, "actualLength": e.ActualLength}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ArrayTooLarge) safeParams() map[string]interface{} {
	return map[string]interface{}{"maxLength": e.MaxLength, "actualLength": e.ActualLength, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ArrayTooLarge) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ArrayTooLarge) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ArrayTooLarge) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ArrayTooLarge) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.arrayTooLarge)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "NominalChannelWriter:ArrayTooLarge", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ArrayTooLarge) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters arrayTooLarge
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.arrayTooLarge = parameters
	return nil
}

type conflictingDataTypes struct{}

func (o conflictingDataTypes) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *conflictingDataTypes) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewConflictingDataTypes returns new instance of ConflictingDataTypes error.
func NewConflictingDataTypes() *ConflictingDataTypes {
	return &ConflictingDataTypes{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), conflictingDataTypes: conflictingDataTypes{}}
}

// WrapWithConflictingDataTypes returns new instance of ConflictingDataTypes error wrapping an existing error.
func WrapWithConflictingDataTypes(err error) *ConflictingDataTypes {
	return &ConflictingDataTypes{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, conflictingDataTypes: conflictingDataTypes{}}
}

// ConflictingDataTypes is an error type.
// Found two different data types for the same series in the request.
type ConflictingDataTypes struct {
	errorInstanceID uuid.UUID
	conflictingDataTypes
	cause error
	stack werror.StackTrace
}

// IsConflictingDataTypes returns true if err is an instance of ConflictingDataTypes.
func IsConflictingDataTypes(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*ConflictingDataTypes)
	return ok
}

func (e *ConflictingDataTypes) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT NominalChannelWriter:ConflictingDataTypes (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *ConflictingDataTypes) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *ConflictingDataTypes) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *ConflictingDataTypes) Message() string {
	return "INVALID_ARGUMENT NominalChannelWriter:ConflictingDataTypes"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *ConflictingDataTypes) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *ConflictingDataTypes) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *ConflictingDataTypes) Name() string {
	return "NominalChannelWriter:ConflictingDataTypes"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *ConflictingDataTypes) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *ConflictingDataTypes) Parameters() map[string]interface{} {
	return map[string]interface{}{}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *ConflictingDataTypes) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConflictingDataTypes) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *ConflictingDataTypes) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *ConflictingDataTypes) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e ConflictingDataTypes) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.conflictingDataTypes)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "NominalChannelWriter:ConflictingDataTypes", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *ConflictingDataTypes) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters conflictingDataTypes
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.conflictingDataTypes = parameters
	return nil
}

type invalidChannelName struct {
	Channel string `json:"channel"`
	Reason  string `json:"reason"`
}

func (o invalidChannelName) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidChannelName) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidChannelName returns new instance of InvalidChannelName error.
func NewInvalidChannelName(channelArg string, reasonArg string) *InvalidChannelName {
	return &InvalidChannelName{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidChannelName: invalidChannelName{Channel: channelArg, Reason: reasonArg}}
}

// WrapWithInvalidChannelName returns new instance of InvalidChannelName error wrapping an existing error.
func WrapWithInvalidChannelName(err error, channelArg string, reasonArg string) *InvalidChannelName {
	return &InvalidChannelName{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidChannelName: invalidChannelName{Channel: channelArg, Reason: reasonArg}}
}

// InvalidChannelName is an error type.
// The channel name is invalid.
type InvalidChannelName struct {
	errorInstanceID uuid.UUID
	invalidChannelName
	cause error
	stack werror.StackTrace
}

// IsInvalidChannelName returns true if err is an instance of InvalidChannelName.
func IsInvalidChannelName(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidChannelName)
	return ok
}

func (e *InvalidChannelName) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT NominalChannelWriter:InvalidChannelName (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidChannelName) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidChannelName) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidChannelName) Message() string {
	return "INVALID_ARGUMENT NominalChannelWriter:InvalidChannelName"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidChannelName) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidChannelName) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidChannelName) Name() string {
	return "NominalChannelWriter:InvalidChannelName"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidChannelName) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidChannelName) Parameters() map[string]interface{} {
	return map[string]interface{}{"channel": e.Channel, "reason": e.Reason}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidChannelName) safeParams() map[string]interface{} {
	return map[string]interface{}{"channel": e.Channel, "reason": e.Reason, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidChannelName) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidChannelName) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidChannelName) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidChannelName) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidChannelName)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "NominalChannelWriter:InvalidChannelName", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidChannelName) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidChannelName
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidChannelName = parameters
	return nil
}

type invalidDataSource struct {
	DataSourceRid rids.NominalDataSourceOrDatasetRid `json:"dataSourceRid"`
}

func (o invalidDataSource) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidDataSource) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidDataSource returns new instance of InvalidDataSource error.
func NewInvalidDataSource(dataSourceRidArg rids.NominalDataSourceOrDatasetRid) *InvalidDataSource {
	return &InvalidDataSource{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidDataSource: invalidDataSource{DataSourceRid: dataSourceRidArg}}
}

// WrapWithInvalidDataSource returns new instance of InvalidDataSource error wrapping an existing error.
func WrapWithInvalidDataSource(err error, dataSourceRidArg rids.NominalDataSourceOrDatasetRid) *InvalidDataSource {
	return &InvalidDataSource{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidDataSource: invalidDataSource{DataSourceRid: dataSourceRidArg}}
}

// InvalidDataSource is an error type.
// The nominal data source or dataset provided is invalid.
type InvalidDataSource struct {
	errorInstanceID uuid.UUID
	invalidDataSource
	cause error
	stack werror.StackTrace
}

// IsInvalidDataSource returns true if err is an instance of InvalidDataSource.
func IsInvalidDataSource(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidDataSource)
	return ok
}

func (e *InvalidDataSource) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT NominalChannelWriter:InvalidDataSource (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidDataSource) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidDataSource) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidDataSource) Message() string {
	return "INVALID_ARGUMENT NominalChannelWriter:InvalidDataSource"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidDataSource) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidDataSource) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidDataSource) Name() string {
	return "NominalChannelWriter:InvalidDataSource"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidDataSource) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidDataSource) Parameters() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidDataSource) safeParams() map[string]interface{} {
	return map[string]interface{}{"dataSourceRid": e.DataSourceRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidDataSource) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidDataSource) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidDataSource) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidDataSource) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidDataSource)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "NominalChannelWriter:InvalidDataSource", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidDataSource) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidDataSource
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidDataSource = parameters
	return nil
}

type invalidTelegrafTimestamp struct {
	Timestamp interface{} `json:"timestamp"`
}

func (o invalidTelegrafTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidTelegrafTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidTelegrafTimestamp returns new instance of InvalidTelegrafTimestamp error.
func NewInvalidTelegrafTimestamp(timestampArg interface{}) *InvalidTelegrafTimestamp {
	return &InvalidTelegrafTimestamp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidTelegrafTimestamp: invalidTelegrafTimestamp{Timestamp: timestampArg}}
}

// WrapWithInvalidTelegrafTimestamp returns new instance of InvalidTelegrafTimestamp error wrapping an existing error.
func WrapWithInvalidTelegrafTimestamp(err error, timestampArg interface{}) *InvalidTelegrafTimestamp {
	return &InvalidTelegrafTimestamp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidTelegrafTimestamp: invalidTelegrafTimestamp{Timestamp: timestampArg}}
}

// InvalidTelegrafTimestamp is an error type.
type InvalidTelegrafTimestamp struct {
	errorInstanceID uuid.UUID
	invalidTelegrafTimestamp
	cause error
	stack werror.StackTrace
}

// IsInvalidTelegrafTimestamp returns true if err is an instance of InvalidTelegrafTimestamp.
func IsInvalidTelegrafTimestamp(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidTelegrafTimestamp)
	return ok
}

func (e *InvalidTelegrafTimestamp) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT NominalChannelWriter:InvalidTelegrafTimestamp (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidTelegrafTimestamp) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidTelegrafTimestamp) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidTelegrafTimestamp) Message() string {
	return "INVALID_ARGUMENT NominalChannelWriter:InvalidTelegrafTimestamp"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidTelegrafTimestamp) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidTelegrafTimestamp) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidTelegrafTimestamp) Name() string {
	return "NominalChannelWriter:InvalidTelegrafTimestamp"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidTelegrafTimestamp) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidTelegrafTimestamp) Parameters() map[string]interface{} {
	return map[string]interface{}{"timestamp": e.Timestamp}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidTelegrafTimestamp) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTelegrafTimestamp) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidTelegrafTimestamp) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"timestamp": e.Timestamp}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTelegrafTimestamp) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidTelegrafTimestamp) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidTelegrafTimestamp)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "NominalChannelWriter:InvalidTelegrafTimestamp", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidTelegrafTimestamp) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidTelegrafTimestamp
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidTelegrafTimestamp = parameters
	return nil
}

type invalidTimestamp struct {
	Timestamp api.Timestamp `json:"timestamp"`
}

func (o invalidTimestamp) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *invalidTimestamp) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewInvalidTimestamp returns new instance of InvalidTimestamp error.
func NewInvalidTimestamp(timestampArg api.Timestamp) *InvalidTimestamp {
	return &InvalidTimestamp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), invalidTimestamp: invalidTimestamp{Timestamp: timestampArg}}
}

// WrapWithInvalidTimestamp returns new instance of InvalidTimestamp error wrapping an existing error.
func WrapWithInvalidTimestamp(err error, timestampArg api.Timestamp) *InvalidTimestamp {
	return &InvalidTimestamp{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, invalidTimestamp: invalidTimestamp{Timestamp: timestampArg}}
}

// InvalidTimestamp is an error type.
type InvalidTimestamp struct {
	errorInstanceID uuid.UUID
	invalidTimestamp
	cause error
	stack werror.StackTrace
}

// IsInvalidTimestamp returns true if err is an instance of InvalidTimestamp.
func IsInvalidTimestamp(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*InvalidTimestamp)
	return ok
}

func (e *InvalidTimestamp) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT NominalChannelWriter:InvalidTimestamp (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *InvalidTimestamp) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *InvalidTimestamp) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *InvalidTimestamp) Message() string {
	return "INVALID_ARGUMENT NominalChannelWriter:InvalidTimestamp"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *InvalidTimestamp) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *InvalidTimestamp) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *InvalidTimestamp) Name() string {
	return "NominalChannelWriter:InvalidTimestamp"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *InvalidTimestamp) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *InvalidTimestamp) Parameters() map[string]interface{} {
	return map[string]interface{}{"timestamp": e.Timestamp}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *InvalidTimestamp) safeParams() map[string]interface{} {
	return map[string]interface{}{"errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTimestamp) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *InvalidTimestamp) unsafeParams() map[string]interface{} {
	return map[string]interface{}{"timestamp": e.Timestamp}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *InvalidTimestamp) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e InvalidTimestamp) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.invalidTimestamp)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "NominalChannelWriter:InvalidTimestamp", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *InvalidTimestamp) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters invalidTimestamp
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.invalidTimestamp = parameters
	return nil
}

type mismatchedTimestampsAndValues struct {
	TimestampCount int `json:"timestampCount"`
	ValueCount     int `json:"valueCount"`
}

func (o mismatchedTimestampsAndValues) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *mismatchedTimestampsAndValues) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewMismatchedTimestampsAndValues returns new instance of MismatchedTimestampsAndValues error.
func NewMismatchedTimestampsAndValues(timestampCountArg int, valueCountArg int) *MismatchedTimestampsAndValues {
	return &MismatchedTimestampsAndValues{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), mismatchedTimestampsAndValues: mismatchedTimestampsAndValues{TimestampCount: timestampCountArg, ValueCount: valueCountArg}}
}

// WrapWithMismatchedTimestampsAndValues returns new instance of MismatchedTimestampsAndValues error wrapping an existing error.
func WrapWithMismatchedTimestampsAndValues(err error, timestampCountArg int, valueCountArg int) *MismatchedTimestampsAndValues {
	return &MismatchedTimestampsAndValues{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, mismatchedTimestampsAndValues: mismatchedTimestampsAndValues{TimestampCount: timestampCountArg, ValueCount: valueCountArg}}
}

// MismatchedTimestampsAndValues is an error type.
// Columnar streaming request contains different numbers of timestamps and values
type MismatchedTimestampsAndValues struct {
	errorInstanceID uuid.UUID
	mismatchedTimestampsAndValues
	cause error
	stack werror.StackTrace
}

// IsMismatchedTimestampsAndValues returns true if err is an instance of MismatchedTimestampsAndValues.
func IsMismatchedTimestampsAndValues(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*MismatchedTimestampsAndValues)
	return ok
}

func (e *MismatchedTimestampsAndValues) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT NominalChannelWriter:MismatchedTimestampsAndValues (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *MismatchedTimestampsAndValues) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *MismatchedTimestampsAndValues) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *MismatchedTimestampsAndValues) Message() string {
	return "INVALID_ARGUMENT NominalChannelWriter:MismatchedTimestampsAndValues"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *MismatchedTimestampsAndValues) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *MismatchedTimestampsAndValues) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *MismatchedTimestampsAndValues) Name() string {
	return "NominalChannelWriter:MismatchedTimestampsAndValues"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *MismatchedTimestampsAndValues) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *MismatchedTimestampsAndValues) Parameters() map[string]interface{} {
	return map[string]interface{}{"timestampCount": e.TimestampCount, "valueCount": e.ValueCount}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *MismatchedTimestampsAndValues) safeParams() map[string]interface{} {
	return map[string]interface{}{"timestampCount": e.TimestampCount, "valueCount": e.ValueCount, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *MismatchedTimestampsAndValues) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *MismatchedTimestampsAndValues) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *MismatchedTimestampsAndValues) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e MismatchedTimestampsAndValues) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.mismatchedTimestampsAndValues)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "NominalChannelWriter:MismatchedTimestampsAndValues", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *MismatchedTimestampsAndValues) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters mismatchedTimestampsAndValues
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.mismatchedTimestampsAndValues = parameters
	return nil
}

type streamingDisabledOnDataset struct {
	DatasetRid rids.DatasetRid `json:"datasetRid"`
}

func (o streamingDisabledOnDataset) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *streamingDisabledOnDataset) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}

// NewStreamingDisabledOnDataset returns new instance of StreamingDisabledOnDataset error.
func NewStreamingDisabledOnDataset(datasetRidArg rids.DatasetRid) *StreamingDisabledOnDataset {
	return &StreamingDisabledOnDataset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), streamingDisabledOnDataset: streamingDisabledOnDataset{DatasetRid: datasetRidArg}}
}

// WrapWithStreamingDisabledOnDataset returns new instance of StreamingDisabledOnDataset error wrapping an existing error.
func WrapWithStreamingDisabledOnDataset(err error, datasetRidArg rids.DatasetRid) *StreamingDisabledOnDataset {
	return &StreamingDisabledOnDataset{errorInstanceID: uuid.NewUUID(), stack: werror.NewStackTrace(), cause: err, streamingDisabledOnDataset: streamingDisabledOnDataset{DatasetRid: datasetRidArg}}
}

// StreamingDisabledOnDataset is an error type.
// Unsupported dataset for streaming.
type StreamingDisabledOnDataset struct {
	errorInstanceID uuid.UUID
	streamingDisabledOnDataset
	cause error
	stack werror.StackTrace
}

// IsStreamingDisabledOnDataset returns true if err is an instance of StreamingDisabledOnDataset.
func IsStreamingDisabledOnDataset(err error) bool {
	if err == nil {
		return false
	}
	_, ok := errors.GetConjureError(err).(*StreamingDisabledOnDataset)
	return ok
}

func (e *StreamingDisabledOnDataset) Error() string {
	return fmt.Sprintf("INVALID_ARGUMENT NominalChannelWriter:StreamingDisabledOnDataset (%s)", e.errorInstanceID)
}

// Cause returns the underlying cause of the error, or nil if none.
// Note that cause is not serialized and sent over the wire.
func (e *StreamingDisabledOnDataset) Cause() error {
	return e.cause
}

// StackTrace returns the StackTrace for the error, or nil if none.
// Note that stack traces are not serialized and sent over the wire.
func (e *StreamingDisabledOnDataset) StackTrace() werror.StackTrace {
	return e.stack
}

// Message returns the message body for the error.
func (e *StreamingDisabledOnDataset) Message() string {
	return "INVALID_ARGUMENT NominalChannelWriter:StreamingDisabledOnDataset"
}

// Format implements fmt.Formatter, a requirement of werror.Werror.
func (e *StreamingDisabledOnDataset) Format(state fmt.State, verb rune) {
	werror.Format(e, e.safeParams(), state, verb)
}

// Code returns an enum describing error category.
func (e *StreamingDisabledOnDataset) Code() errors.ErrorCode {
	return errors.InvalidArgument
}

// Name returns an error name identifying error type.
func (e *StreamingDisabledOnDataset) Name() string {
	return "NominalChannelWriter:StreamingDisabledOnDataset"
}

// InstanceID returns unique identifier of this particular error instance.
func (e *StreamingDisabledOnDataset) InstanceID() uuid.UUID {
	return e.errorInstanceID
}

// Parameters returns a set of named parameters detailing this particular error instance.
func (e *StreamingDisabledOnDataset) Parameters() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid}
}

// safeParams returns a set of named safe parameters detailing this particular error instance.
func (e *StreamingDisabledOnDataset) safeParams() map[string]interface{} {
	return map[string]interface{}{"datasetRid": e.DatasetRid, "errorInstanceId": e.errorInstanceID, "errorName": e.Name()}
}

// SafeParams returns a set of named safe parameters detailing this particular error instance and
// any underlying causes.
func (e *StreamingDisabledOnDataset) SafeParams() map[string]interface{} {
	safeParams, _ := werror.ParamsFromError(e.cause)
	for k, v := range e.safeParams() {
		if _, exists := safeParams[k]; !exists {
			safeParams[k] = v
		}
	}
	return safeParams
}

// unsafeParams returns a set of named unsafe parameters detailing this particular error instance.
func (e *StreamingDisabledOnDataset) unsafeParams() map[string]interface{} {
	return map[string]interface{}{}
}

// UnsafeParams returns a set of named unsafe parameters detailing this particular error instance and
// any underlying causes.
func (e *StreamingDisabledOnDataset) UnsafeParams() map[string]interface{} {
	_, unsafeParams := werror.ParamsFromError(e.cause)
	for k, v := range e.unsafeParams() {
		if _, exists := unsafeParams[k]; !exists {
			unsafeParams[k] = v
		}
	}
	return unsafeParams
}

func (e StreamingDisabledOnDataset) MarshalJSON() ([]byte, error) {
	parameters, err := safejson.Marshal(e.streamingDisabledOnDataset)
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(errors.SerializableError{ErrorCode: errors.InvalidArgument, ErrorName: "NominalChannelWriter:StreamingDisabledOnDataset", ErrorInstanceID: e.errorInstanceID, Parameters: json.RawMessage(parameters)})
}

func (e *StreamingDisabledOnDataset) UnmarshalJSON(data []byte) error {
	var serializableError errors.SerializableError
	if err := safejson.Unmarshal(data, &serializableError); err != nil {
		return err
	}
	var parameters streamingDisabledOnDataset
	if err := safejson.Unmarshal([]byte(serializableError.Parameters), &parameters); err != nil {
		return err
	}
	e.errorInstanceID = serializableError.ErrorInstanceID
	e.streamingDisabledOnDataset = parameters
	return nil
}

func init() {
	conjureerrors.RegisterErrorType("NominalChannelWriter:ArrayTooLarge", reflect.TypeOf(ArrayTooLarge{}))
	conjureerrors.RegisterErrorType("NominalChannelWriter:ConflictingDataTypes", reflect.TypeOf(ConflictingDataTypes{}))
	conjureerrors.RegisterErrorType("NominalChannelWriter:InvalidChannelName", reflect.TypeOf(InvalidChannelName{}))
	conjureerrors.RegisterErrorType("NominalChannelWriter:InvalidDataSource", reflect.TypeOf(InvalidDataSource{}))
	conjureerrors.RegisterErrorType("NominalChannelWriter:InvalidTelegrafTimestamp", reflect.TypeOf(InvalidTelegrafTimestamp{}))
	conjureerrors.RegisterErrorType("NominalChannelWriter:InvalidTimestamp", reflect.TypeOf(InvalidTimestamp{}))
	conjureerrors.RegisterErrorType("NominalChannelWriter:MismatchedTimestampsAndValues", reflect.TypeOf(MismatchedTimestampsAndValues{}))
	conjureerrors.RegisterErrorType("NominalChannelWriter:StreamingDisabledOnDataset", reflect.TypeOf(StreamingDisabledOnDataset{}))
}
