// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"
	"net/url"

	"github.com/nominal-io/nominal-api-go/api/rids"
	"github.com/nominal-io/nominal-api-go/internal/conjureerrors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-client/httpclient"
	"github.com/palantir/pkg/bearertoken"
	werror "github.com/palantir/witchcraft-go-error"
)

// Writes data points directly to Nominal's managed database offering.
type DirectNominalChannelWriterServiceClient interface {
	/*
	   Synchronously writes batches of records to a Nominal data source. This endpoint bypasses the
	   Channel Writer service entirely, and should only be used if the implications are well understood.

	   If you call this endpoint, writes will go directly into Nominal DB and will not be placed in Nominal's
	   durable queue. This results in lower latency, but also consequently lower durability.
	*/
	WriteBatches(ctx context.Context, authHeader bearertoken.Token, requestArg WriteBatchesRequest) error
}

type directNominalChannelWriterServiceClient struct {
	client httpclient.Client
}

func NewDirectNominalChannelWriterServiceClient(client httpclient.Client) DirectNominalChannelWriterServiceClient {
	return &directNominalChannelWriterServiceClient{client: client}
}

func (c *directNominalChannelWriterServiceClient) WriteBatches(ctx context.Context, authHeader bearertoken.Token, requestArg WriteBatchesRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("WriteBatches"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/storage/direct-writer/v1"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "writeBatches failed")
	}
	return nil
}

// Writes data points directly to Nominal's managed database offering.
type DirectNominalChannelWriterServiceClientWithAuth interface {
	/*
	   Synchronously writes batches of records to a Nominal data source. This endpoint bypasses the
	   Channel Writer service entirely, and should only be used if the implications are well understood.

	   If you call this endpoint, writes will go directly into Nominal DB and will not be placed in Nominal's
	   durable queue. This results in lower latency, but also consequently lower durability.
	*/
	WriteBatches(ctx context.Context, requestArg WriteBatchesRequest) error
}

func NewDirectNominalChannelWriterServiceClientWithAuth(client DirectNominalChannelWriterServiceClient, authHeader bearertoken.Token) DirectNominalChannelWriterServiceClientWithAuth {
	return &directNominalChannelWriterServiceClientWithAuth{client: client, authHeader: authHeader}
}

type directNominalChannelWriterServiceClientWithAuth struct {
	client     DirectNominalChannelWriterServiceClient
	authHeader bearertoken.Token
}

func (c *directNominalChannelWriterServiceClientWithAuth) WriteBatches(ctx context.Context, requestArg WriteBatchesRequest) error {
	return c.client.WriteBatches(ctx, c.authHeader, requestArg)
}

func NewDirectNominalChannelWriterServiceClientWithTokenProvider(client DirectNominalChannelWriterServiceClient, tokenProvider httpclient.TokenProvider) DirectNominalChannelWriterServiceClientWithAuth {
	return &directNominalChannelWriterServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type directNominalChannelWriterServiceClientWithTokenProvider struct {
	client        DirectNominalChannelWriterServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *directNominalChannelWriterServiceClientWithTokenProvider) WriteBatches(ctx context.Context, requestArg WriteBatchesRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.WriteBatches(ctx, bearertoken.Token(token), requestArg)
}

// Write data points to Nominal data sources.
type NominalChannelWriterServiceClient interface {
	/*
	   Synchronously writes batches of records to a Nominal data source.

	   If the request is too large, either due to the number of individual batches (> 10) or the number of points
	   across batches (> 500k), the request may be split up into multiple requests internally when writing to the
	   Nominal data source. Generally, it's advisable to limit the number of points to 50k.
	*/
	WriteBatches(ctx context.Context, authHeader bearertoken.Token, requestArg WriteBatchesRequestExternal) error
	/*
	   Synchronously writes batches of columns of data to a Nominal data source.

	   This is a column-major variant of writeBatches (which is row-major) to optimize serialization and compression
	   time for client applications streaming large numbers of points from a single column at a time. This has the
	   tradeoff of slightly larger sizes post-gzipping of requests, so should be used in the particular case where
	   the main bottleneck is in encoding columnar data into the row-based format found in writeBatches.
	*/
	WriteColumnBatches(ctx context.Context, authHeader bearertoken.Token, requestArg WriteColumnBatchesRequest) error
	/*
	   Synchronously writes batches of records to a Nominal data source.

	   Has the same functionality as writeBatches, but is compatible with the Telegraf output format.
	   Assumes that the Telegraf batch format is used. Timestamp is assumed to be in nanoseconds.
	   The URL in the Telegraf output plugin configuration should be the fully qualified URL,
	   including the dataSourceRid query parameter.
	*/
	WriteTelegrafBatches(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg WriteTelegrafBatchesRequest) error
	/*
	   Synchronously writes batches of records to a Nominal data source.

	   Has the same functionality as writeBatches, but is encoded using the Prometheus remote write
	   format. We follow the specification defined here: https://prometheus.io/docs/specs/remote_write_spec/
	   There are a few notable caveats:
	     1. Must be content encoded as application/x-protobuf
	     2. Must be compressed using snappy compression
	*/
	WritePrometheusBatches(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg httpclient.RequestBody) error
	/*
	   Performs a health check for prometheus remote write Vector sink. All this endpoint does
	   is verify if the caller is authenticated and the server is online. Once Vector allows the Prometheus
	   remote write endpoint to configure the healthcheck url, we can remove this endpoint.

	   See: https://github.com/vectordotdev/vector/issues/8279
	*/
	PrometheusRemoteWriteHealthCheck(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg rids.NominalDataSourceOrDatasetRid) (bool, error)
	/*
	   Synchronously writes a Nominal Write Request to a Nominal data source using the NominalWrite Protobuf schema.
	   The request must be Protobuf-encoded and accompanied by the appropriate content encoding headers if compressed.

	   The request should follow this Protobuf schema:
	   ```proto
	   message WriteRequestNominal {
	     repeated Series series = 1;
	   }

	   message Series {
	     Channel channel = 1;
	     map<string, string> tags = 2;   // Key-value pairs for series tags
	     Points points = 3;              // Contains double, string, integer, array, or struct points
	   }

	   message Channel {
	     string name = 1;
	   }

	   message Points {
	     oneof points_type {
	       DoublePoints double_points = 1;
	       StringPoints string_points = 2;
	       IntegerPoints integer_points = 3;
	       ArrayPoints array_points = 4;
	       StructPoints struct_points = 5;
	       Uint64Points uint64_points = 6;
	     }
	   }

	   message DoublePoints {
	     repeated DoublePoint points = 1;
	   }

	   message StringPoints {
	     repeated StringPoint points = 1;
	   }

	   message IntegerPoints {
	     repeated IntegerPoint points = 1;
	   }

	   message Uint64Points {
	     repeated Uint64Point points = 1;
	   }

	   message ArrayPoints {
	     oneof array_type {
	       DoubleArrayPoints double_array_points = 1;
	       StringArrayPoints string_array_points = 2;
	     }
	   }

	   message DoubleArrayPoints {
	     repeated DoubleArrayPoint points = 1;
	   }

	   message StringArrayPoints {
	     repeated StringArrayPoint points = 1;
	   }

	   message StructPoints {
	     repeated StructPoint points = 1;
	   }

	   message DoublePoint {
	     google.protobuf.Timestamp timestamp = 1;
	     double value = 2;
	   }

	   message StringPoint {
	     google.protobuf.Timestamp timestamp = 1;
	     string value = 2;
	   }

	   message IntegerPoint {
	     google.protobuf.Timestamp timestamp = 1;
	     int64 value = 2;
	   }

	   message Uint64Point {
	     google.protobuf.Timestamp timestamp = 1;
	     uint64 value = 2;
	   }

	   message DoubleArrayPoint {
	     google.protobuf.Timestamp timestamp = 1;
	     repeated double value = 2;
	   }

	   message StringArrayPoint {
	     google.protobuf.Timestamp timestamp = 1;
	     repeated string value = 2;
	   }

	   message StructPoint {
	     google.protobuf.Timestamp timestamp = 1;
	     string jsonString = 2;
	   }
	   ```

	   Each request can contain multiple series, where each series consists of:
	   - A channel name
	   - A map of tags (key-value pairs)
	   - A collection of points, which can be double, string, integer, array (double/string), or struct (json) values
	   - Each point includes a timestamp (using google.protobuf.Timestamp) and its value
	   - Array points contain repeated values (array<double> or array<string>)
	   - Struct points are represented using strings that contain the JSON formatted blobs, with all keys being strings

	   The endpoint requires the Content-Type header to be set to "application/x-protobuf".
	   If the payload is compressed, the appropriate Content-Encoding header must be included.
	*/
	WriteNominalBatches(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg httpclient.RequestBody) error
	// Synchronously writes logs to a Nominal data source.
	WriteLogs(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg WriteLogsRequest) error
}

type nominalChannelWriterServiceClient struct {
	client httpclient.Client
}

func NewNominalChannelWriterServiceClient(client httpclient.Client) NominalChannelWriterServiceClient {
	return &nominalChannelWriterServiceClient{client: client}
}

func (c *nominalChannelWriterServiceClient) WriteBatches(ctx context.Context, authHeader bearertoken.Token, requestArg WriteBatchesRequestExternal) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("WriteBatches"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/storage/writer/v1"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "writeBatches failed")
	}
	return nil
}

func (c *nominalChannelWriterServiceClient) WriteColumnBatches(ctx context.Context, authHeader bearertoken.Token, requestArg WriteColumnBatchesRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("WriteColumnBatches"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/storage/writer/v1/columnar"))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "writeColumnBatches failed")
	}
	return nil
}

func (c *nominalChannelWriterServiceClient) WriteTelegrafBatches(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg WriteTelegrafBatchesRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("WriteTelegrafBatches"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/storage/writer/v1/telegraf/%s", url.PathEscape(fmt.Sprint(dataSourceRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "writeTelegrafBatches failed")
	}
	return nil
}

func (c *nominalChannelWriterServiceClient) WritePrometheusBatches(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg httpclient.RequestBody) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("WritePrometheusBatches"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/storage/writer/v1/prometheus/%s", url.PathEscape(fmt.Sprint(dataSourceRidArg))))
	requestParams = append(requestParams, httpclient.WithBinaryRequestBody(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "writePrometheusBatches failed")
	}
	return nil
}

func (c *nominalChannelWriterServiceClient) PrometheusRemoteWriteHealthCheck(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg rids.NominalDataSourceOrDatasetRid) (bool, error) {
	var defaultReturnVal bool
	var returnVal *bool
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("PrometheusRemoteWriteHealthCheck"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("GET"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/storage/writer/v1/prometheus/%s", url.PathEscape(fmt.Sprint(dataSourceRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONResponse(&returnVal))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return defaultReturnVal, werror.WrapWithContextParams(ctx, err, "prometheusRemoteWriteHealthCheck failed")
	}
	if returnVal == nil {
		return defaultReturnVal, werror.ErrorWithContextParams(ctx, "prometheusRemoteWriteHealthCheck response cannot be nil")
	}
	return *returnVal, nil
}

func (c *nominalChannelWriterServiceClient) WriteNominalBatches(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg httpclient.RequestBody) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("WriteNominalBatches"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/storage/writer/v1/nominal/%s", url.PathEscape(fmt.Sprint(dataSourceRidArg))))
	requestParams = append(requestParams, httpclient.WithBinaryRequestBody(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "writeNominalBatches failed")
	}
	return nil
}

func (c *nominalChannelWriterServiceClient) WriteLogs(ctx context.Context, authHeader bearertoken.Token, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg WriteLogsRequest) error {
	var requestParams []httpclient.RequestParam
	requestParams = append(requestParams, httpclient.WithRPCMethodName("WriteLogs"))
	requestParams = append(requestParams, httpclient.WithRequestMethod("POST"))
	requestParams = append(requestParams, httpclient.WithHeader("Authorization", fmt.Sprint("Bearer ", authHeader)))
	requestParams = append(requestParams, httpclient.WithPathf("/storage/writer/v1/logs/%s", url.PathEscape(fmt.Sprint(dataSourceRidArg))))
	requestParams = append(requestParams, httpclient.WithJSONRequest(requestArg))
	requestParams = append(requestParams, httpclient.WithRequestConjureErrorDecoder(conjureerrors.Decoder()))
	if _, err := c.client.Do(ctx, requestParams...); err != nil {
		return werror.WrapWithContextParams(ctx, err, "writeLogs failed")
	}
	return nil
}

// Write data points to Nominal data sources.
type NominalChannelWriterServiceClientWithAuth interface {
	/*
	   Synchronously writes batches of records to a Nominal data source.

	   If the request is too large, either due to the number of individual batches (> 10) or the number of points
	   across batches (> 500k), the request may be split up into multiple requests internally when writing to the
	   Nominal data source. Generally, it's advisable to limit the number of points to 50k.
	*/
	WriteBatches(ctx context.Context, requestArg WriteBatchesRequestExternal) error
	/*
	   Synchronously writes batches of columns of data to a Nominal data source.

	   This is a column-major variant of writeBatches (which is row-major) to optimize serialization and compression
	   time for client applications streaming large numbers of points from a single column at a time. This has the
	   tradeoff of slightly larger sizes post-gzipping of requests, so should be used in the particular case where
	   the main bottleneck is in encoding columnar data into the row-based format found in writeBatches.
	*/
	WriteColumnBatches(ctx context.Context, requestArg WriteColumnBatchesRequest) error
	/*
	   Synchronously writes batches of records to a Nominal data source.

	   Has the same functionality as writeBatches, but is compatible with the Telegraf output format.
	   Assumes that the Telegraf batch format is used. Timestamp is assumed to be in nanoseconds.
	   The URL in the Telegraf output plugin configuration should be the fully qualified URL,
	   including the dataSourceRid query parameter.
	*/
	WriteTelegrafBatches(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg WriteTelegrafBatchesRequest) error
	/*
	   Synchronously writes batches of records to a Nominal data source.

	   Has the same functionality as writeBatches, but is encoded using the Prometheus remote write
	   format. We follow the specification defined here: https://prometheus.io/docs/specs/remote_write_spec/
	   There are a few notable caveats:
	     1. Must be content encoded as application/x-protobuf
	     2. Must be compressed using snappy compression
	*/
	WritePrometheusBatches(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg httpclient.RequestBody) error
	/*
	   Performs a health check for prometheus remote write Vector sink. All this endpoint does
	   is verify if the caller is authenticated and the server is online. Once Vector allows the Prometheus
	   remote write endpoint to configure the healthcheck url, we can remove this endpoint.

	   See: https://github.com/vectordotdev/vector/issues/8279
	*/
	PrometheusRemoteWriteHealthCheck(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid) (bool, error)
	/*
	   Synchronously writes a Nominal Write Request to a Nominal data source using the NominalWrite Protobuf schema.
	   The request must be Protobuf-encoded and accompanied by the appropriate content encoding headers if compressed.

	   The request should follow this Protobuf schema:
	   ```proto
	   message WriteRequestNominal {
	     repeated Series series = 1;
	   }

	   message Series {
	     Channel channel = 1;
	     map<string, string> tags = 2;   // Key-value pairs for series tags
	     Points points = 3;              // Contains double, string, integer, array, or struct points
	   }

	   message Channel {
	     string name = 1;
	   }

	   message Points {
	     oneof points_type {
	       DoublePoints double_points = 1;
	       StringPoints string_points = 2;
	       IntegerPoints integer_points = 3;
	       ArrayPoints array_points = 4;
	       StructPoints struct_points = 5;
	       Uint64Points uint64_points = 6;
	     }
	   }

	   message DoublePoints {
	     repeated DoublePoint points = 1;
	   }

	   message StringPoints {
	     repeated StringPoint points = 1;
	   }

	   message IntegerPoints {
	     repeated IntegerPoint points = 1;
	   }

	   message Uint64Points {
	     repeated Uint64Point points = 1;
	   }

	   message ArrayPoints {
	     oneof array_type {
	       DoubleArrayPoints double_array_points = 1;
	       StringArrayPoints string_array_points = 2;
	     }
	   }

	   message DoubleArrayPoints {
	     repeated DoubleArrayPoint points = 1;
	   }

	   message StringArrayPoints {
	     repeated StringArrayPoint points = 1;
	   }

	   message StructPoints {
	     repeated StructPoint points = 1;
	   }

	   message DoublePoint {
	     google.protobuf.Timestamp timestamp = 1;
	     double value = 2;
	   }

	   message StringPoint {
	     google.protobuf.Timestamp timestamp = 1;
	     string value = 2;
	   }

	   message IntegerPoint {
	     google.protobuf.Timestamp timestamp = 1;
	     int64 value = 2;
	   }

	   message Uint64Point {
	     google.protobuf.Timestamp timestamp = 1;
	     uint64 value = 2;
	   }

	   message DoubleArrayPoint {
	     google.protobuf.Timestamp timestamp = 1;
	     repeated double value = 2;
	   }

	   message StringArrayPoint {
	     google.protobuf.Timestamp timestamp = 1;
	     repeated string value = 2;
	   }

	   message StructPoint {
	     google.protobuf.Timestamp timestamp = 1;
	     string jsonString = 2;
	   }
	   ```

	   Each request can contain multiple series, where each series consists of:
	   - A channel name
	   - A map of tags (key-value pairs)
	   - A collection of points, which can be double, string, integer, array (double/string), or struct (json) values
	   - Each point includes a timestamp (using google.protobuf.Timestamp) and its value
	   - Array points contain repeated values (array<double> or array<string>)
	   - Struct points are represented using strings that contain the JSON formatted blobs, with all keys being strings

	   The endpoint requires the Content-Type header to be set to "application/x-protobuf".
	   If the payload is compressed, the appropriate Content-Encoding header must be included.
	*/
	WriteNominalBatches(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg httpclient.RequestBody) error
	// Synchronously writes logs to a Nominal data source.
	WriteLogs(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg WriteLogsRequest) error
}

func NewNominalChannelWriterServiceClientWithAuth(client NominalChannelWriterServiceClient, authHeader bearertoken.Token) NominalChannelWriterServiceClientWithAuth {
	return &nominalChannelWriterServiceClientWithAuth{client: client, authHeader: authHeader}
}

type nominalChannelWriterServiceClientWithAuth struct {
	client     NominalChannelWriterServiceClient
	authHeader bearertoken.Token
}

func (c *nominalChannelWriterServiceClientWithAuth) WriteBatches(ctx context.Context, requestArg WriteBatchesRequestExternal) error {
	return c.client.WriteBatches(ctx, c.authHeader, requestArg)
}

func (c *nominalChannelWriterServiceClientWithAuth) WriteColumnBatches(ctx context.Context, requestArg WriteColumnBatchesRequest) error {
	return c.client.WriteColumnBatches(ctx, c.authHeader, requestArg)
}

func (c *nominalChannelWriterServiceClientWithAuth) WriteTelegrafBatches(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg WriteTelegrafBatchesRequest) error {
	return c.client.WriteTelegrafBatches(ctx, c.authHeader, dataSourceRidArg, requestArg)
}

func (c *nominalChannelWriterServiceClientWithAuth) WritePrometheusBatches(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg httpclient.RequestBody) error {
	return c.client.WritePrometheusBatches(ctx, c.authHeader, dataSourceRidArg, requestArg)
}

func (c *nominalChannelWriterServiceClientWithAuth) PrometheusRemoteWriteHealthCheck(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid) (bool, error) {
	return c.client.PrometheusRemoteWriteHealthCheck(ctx, c.authHeader, dataSourceRidArg)
}

func (c *nominalChannelWriterServiceClientWithAuth) WriteNominalBatches(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg httpclient.RequestBody) error {
	return c.client.WriteNominalBatches(ctx, c.authHeader, dataSourceRidArg, requestArg)
}

func (c *nominalChannelWriterServiceClientWithAuth) WriteLogs(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg WriteLogsRequest) error {
	return c.client.WriteLogs(ctx, c.authHeader, dataSourceRidArg, requestArg)
}

func NewNominalChannelWriterServiceClientWithTokenProvider(client NominalChannelWriterServiceClient, tokenProvider httpclient.TokenProvider) NominalChannelWriterServiceClientWithAuth {
	return &nominalChannelWriterServiceClientWithTokenProvider{client: client, tokenProvider: tokenProvider}
}

type nominalChannelWriterServiceClientWithTokenProvider struct {
	client        NominalChannelWriterServiceClient
	tokenProvider httpclient.TokenProvider
}

func (c *nominalChannelWriterServiceClientWithTokenProvider) WriteBatches(ctx context.Context, requestArg WriteBatchesRequestExternal) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.WriteBatches(ctx, bearertoken.Token(token), requestArg)
}

func (c *nominalChannelWriterServiceClientWithTokenProvider) WriteColumnBatches(ctx context.Context, requestArg WriteColumnBatchesRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.WriteColumnBatches(ctx, bearertoken.Token(token), requestArg)
}

func (c *nominalChannelWriterServiceClientWithTokenProvider) WriteTelegrafBatches(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg WriteTelegrafBatchesRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.WriteTelegrafBatches(ctx, bearertoken.Token(token), dataSourceRidArg, requestArg)
}

func (c *nominalChannelWriterServiceClientWithTokenProvider) WritePrometheusBatches(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg httpclient.RequestBody) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.WritePrometheusBatches(ctx, bearertoken.Token(token), dataSourceRidArg, requestArg)
}

func (c *nominalChannelWriterServiceClientWithTokenProvider) PrometheusRemoteWriteHealthCheck(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid) (bool, error) {
	var defaultReturnVal bool
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return defaultReturnVal, err
	}
	return c.client.PrometheusRemoteWriteHealthCheck(ctx, bearertoken.Token(token), dataSourceRidArg)
}

func (c *nominalChannelWriterServiceClientWithTokenProvider) WriteNominalBatches(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg httpclient.RequestBody) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.WriteNominalBatches(ctx, bearertoken.Token(token), dataSourceRidArg, requestArg)
}

func (c *nominalChannelWriterServiceClientWithTokenProvider) WriteLogs(ctx context.Context, dataSourceRidArg rids.NominalDataSourceOrDatasetRid, requestArg WriteLogsRequest) error {
	token, err := c.tokenProvider(ctx)
	if err != nil {
		return err
	}
	return c.client.WriteLogs(ctx, bearertoken.Token(token), dataSourceRidArg, requestArg)
}
